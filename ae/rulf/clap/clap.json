{"dependencies":{"<&'z T as args::any_arg::AnyArg<'n, 'e>>::aliases":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::blacklist":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::default_val":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::env":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::has_switch":[],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::help":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::is_set":["args::settings::ArgSettings"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::long":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::long_help":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::longest_filter":[],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::max_vals":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::min_vals":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::name":[],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::num_vals":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::overrides":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::required_unless":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::requires":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::set":["args::settings::ArgSettings"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::short":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::takes_value":[],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::val_delim":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::val_names":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::validator":["std::marker::Sized","std::option::Option"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::validator_os":["std::marker::Sized","std::option::Option"],"<T as app::help::ArgWithOrder<'b, 'c>>::as_base":[],"<app::App<'a, 'b> as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::settings::ArgSettings","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::settings::ArgSettings","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::App<'n, 'e> as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::meta::AppMeta<'b> as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","app::meta::AppMeta","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<app::meta::AppMeta<'b> as std::default::Default>::default":["alloc::raw_vec::RawVec","app::meta::AppMeta","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<app::parser::ParseResult<'a> as std::clone::Clone>::clone":["app::parser::ParseResult"],"<app::parser::ParseResult<'a> as std::cmp::PartialEq>::eq":["app::parser::ParseResult"],"<app::parser::ParseResult<'a> as std::fmt::Debug>::fmt":["app::parser::ParseResult","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<app::parser::Parser<'a, 'b> as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::parser::Parser<'a, 'b> as std::default::Default>::default":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<app::settings::AppFlags as std::clone::Clone>::clone":["app::settings::AppFlags","app::settings::Flags"],"<app::settings::AppFlags as std::cmp::PartialEq>::eq":["app::settings::AppFlags","app::settings::Flags"],"<app::settings::AppFlags as std::default::Default>::default":["app::settings::AppFlags","app::settings::Flags"],"<app::settings::AppFlags as std::fmt::Debug>::fmt":["app::settings::AppFlags","app::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<app::settings::AppFlags as std::ops::BitOr>::bitor":["app::settings::AppFlags","app::settings::Flags"],"<app::settings::AppSettings as std::clone::Clone>::clone":["app::settings::AppSettings"],"<app::settings::AppSettings as std::cmp::PartialEq>::eq":["app::settings::AppSettings"],"<app::settings::AppSettings as std::fmt::Debug>::fmt":["app::settings::AppSettings","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<app::settings::AppSettings as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_MISSING_POS":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_NEG_NUMS":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_UNK_SC":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ARGS_NEGATE_SCS":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ARGS_OVERRIDE_SELF":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::A_REQUIRED_ELSE_HELP":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLORED_HELP":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLOR_ALWAYS":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLOR_AUTO":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLOR_NEVER":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::CONTAINS_LAST":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DERIVE_DISP_ORDER":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DISABLE_HELP_FLAGS":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DISABLE_HELP_SC":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DISABLE_VERSION":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DONT_COLLAPSE_ARGS":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DONT_DELIM_TRAIL":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::GLOBAL_VERSION":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::INFER_SUBCOMMANDS":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::LEADING_HYPHEN":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::LOW_INDEX_MUL_POS":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEEDS_LONG_HELP":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEEDS_LONG_VERSION":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEEDS_SC_HELP":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEXT_LINE_HELP":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NO_BIN_NAME":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NO_POS_VALUES":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::PROPAGATED":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::PROPAGATE_VALS_DOWN":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::SC_NEGATE_REQS":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::SC_REQUIRED":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::SC_REQUIRED_ELSE_HELP":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::TRAILING_VALUES":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::TRAILING_VARARG":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::UNIFIED_HELP":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::UTF8_NONE":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::UTF8_STRICT":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::VALID_ARG_FOUND":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::VALID_NEG_NUM_FOUND":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::VERSIONLESS_SC":["app::settings::Flags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::WAIT_ON_ERROR":["app::settings::Flags"],"<app::settings::Flags as std::clone::Clone>::clone":["app::settings::Flags"],"<app::settings::Flags as std::cmp::Eq>::assert_receiver_is_total_eq":["app::settings::Flags"],"<app::settings::Flags as std::cmp::Ord>::cmp":["app::settings::Flags","std::cmp::Ordering"],"<app::settings::Flags as std::cmp::PartialEq>::eq":["app::settings::Flags"],"<app::settings::Flags as std::cmp::PartialOrd>::partial_cmp":["app::settings::Flags","std::marker::Sized","std::option::Option"],"<app::settings::Flags as std::fmt::Binary>::fmt":["app::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<app::settings::Flags as std::fmt::Debug>::fmt":["app::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_MISSING_POS":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_NEG_NUMS":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_UNK_SC":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ARGS_NEGATE_SCS":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ARGS_OVERRIDE_SELF":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::A_REQUIRED_ELSE_HELP":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLORED_HELP":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLOR_ALWAYS":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLOR_AUTO":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLOR_NEVER":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::CONTAINS_LAST":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DERIVE_DISP_ORDER":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DISABLE_HELP_FLAGS":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DISABLE_HELP_SC":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DISABLE_VERSION":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DONT_COLLAPSE_ARGS":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DONT_DELIM_TRAIL":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::GLOBAL_VERSION":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::INFER_SUBCOMMANDS":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::LEADING_HYPHEN":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::LOW_INDEX_MUL_POS":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEEDS_LONG_HELP":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEEDS_LONG_VERSION":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEEDS_SC_HELP":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEXT_LINE_HELP":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NO_BIN_NAME":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NO_POS_VALUES":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::PROPAGATED":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::PROPAGATE_VALS_DOWN":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::SC_NEGATE_REQS":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::SC_REQUIRED":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::SC_REQUIRED_ELSE_HELP":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::TRAILING_VALUES":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::TRAILING_VARARG":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::UNIFIED_HELP":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::UTF8_NONE":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::UTF8_STRICT":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::VALID_ARG_FOUND":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::VALID_NEG_NUM_FOUND":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::VERSIONLESS_SC":[],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::WAIT_ON_ERROR":[],"<app::settings::Flags as std::fmt::LowerHex>::fmt":["app::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<app::settings::Flags as std::fmt::Octal>::fmt":["app::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<app::settings::Flags as std::fmt::UpperHex>::fmt":["app::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<app::settings::Flags as std::hash::Hash>::hash":["app::settings::Flags","std::hash::Hasher","std::marker::Sized"],"<app::settings::Flags as std::iter::Extend<app::settings::Flags>>::extend":["app::settings::Flags","std::iter::IntoIterator","std::marker::Sized"],"<app::settings::Flags as std::iter::FromIterator<app::settings::Flags>>::from_iter":["app::settings::Flags","std::iter::IntoIterator","std::marker::Sized"],"<app::settings::Flags as std::ops::BitAnd>::bitand":["app::settings::Flags"],"<app::settings::Flags as std::ops::BitAndAssign>::bitand_assign":["app::settings::Flags"],"<app::settings::Flags as std::ops::BitOr>::bitor":["app::settings::Flags"],"<app::settings::Flags as std::ops::BitOrAssign>::bitor_assign":["app::settings::Flags"],"<app::settings::Flags as std::ops::BitXor>::bitxor":["app::settings::Flags"],"<app::settings::Flags as std::ops::BitXorAssign>::bitxor_assign":["app::settings::Flags"],"<app::settings::Flags as std::ops::Not>::not":["app::settings::Flags"],"<app::settings::Flags as std::ops::Sub>::sub":["app::settings::Flags"],"<app::settings::Flags as std::ops::SubAssign>::sub_assign":["app::settings::Flags"],"<args::arg::Arg<'a, 'b> as std::clone::Clone>::clone":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg::Arg<'a, 'b> as std::convert::From<&'z args::arg::Arg<'a, 'b>>>::from":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg::Arg<'a, 'b> as std::default::Default>::default":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg::Arg<'n, 'e> as std::cmp::PartialEq>::eq":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::base::Base<'a, 'b> as std::clone::Clone>::clone":["args::arg_builder::base::Base","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::base::Base<'a, 'b> as std::default::Default>::default":["args::arg_builder::base::Base","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::base::Base<'a, 'b> as std::fmt::Debug>::fmt":["args::arg_builder::base::Base","args::settings::ArgFlags","args::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::arg_builder::base::Base<'n, 'e> as std::cmp::PartialEq>::eq":["args::arg_builder::base::Base","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::base::Base<'n, 'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'a, 'b> as std::convert::From<&'z args::arg::Arg<'a, 'b>>>::from":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'a, 'b> as std::convert::From<args::arg::Arg<'a, 'b>>>::from":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::DispOrder>::disp_ord":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as std::clone::Clone>::clone":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as std::cmp::PartialEq>::eq":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as std::default::Default>::default":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as std::fmt::Debug>::fmt":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as std::fmt::Display>::fmt":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::DispOrder>::disp_ord":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::clone::Clone>::clone":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::cmp::PartialEq>::eq":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::convert::From<args::arg::Arg<'n, 'e>>>::from":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::default::Default>::default":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::fmt::Display>::fmt":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::DispOrder>::disp_ord":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as std::clone::Clone>::clone":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as std::cmp::PartialEq>::eq":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as std::default::Default>::default":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as std::fmt::Display>::fmt":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::arg_builder::switched::Switched<'b> as std::fmt::Debug>::fmt":["args::arg_builder::switched::Switched","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::arg_builder::switched::Switched<'e> as std::clone::Clone>::clone":["args::arg_builder::switched::Switched","std::marker::Sized","std::option::Option"],"<args::arg_builder::switched::Switched<'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::switched::Switched<'e> as std::default::Default>::default":["args::arg_builder::switched::Switched","std::marker::Sized","std::option::Option"],"<args::arg_builder::valued::Valued<'a, 'b> as std::clone::Clone>::clone":["args::arg_builder::valued::Valued","std::marker::Sized","std::option::Option"],"<args::arg_builder::valued::Valued<'n, 'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::arg_builder::valued::Valued<'n, 'e> as std::default::Default>::default":["args::arg_builder::valued::Valued","std::marker::Sized","std::option::Option"],"<args::arg_matcher::ArgMatcher<'a> as std::convert::Into<args::arg_matches::ArgMatches<'a>>>::into":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<args::arg_matcher::ArgMatcher<'a> as std::default::Default>::default":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<args::arg_matches::ArgMatches<'a> as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<args::arg_matches::ArgMatches<'a> as std::default::Default>::default":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<args::arg_matches::ArgMatches<'a> as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"<args::arg_matches::Indices<'a> as std::clone::Clone>::clone":["args::arg_matches::Indices","std::iter::Map","std::marker::Sized"],"<args::arg_matches::Indices<'a> as std::default::Default>::default":["args::arg_matches::Indices","std::iter::Map","std::marker::Sized"],"<args::arg_matches::Indices<'a> as std::default::Default>::default::to_usize":[],"<args::arg_matches::Indices<'a> as std::fmt::Debug>::fmt":["args::arg_matches::Indices","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::iter::Map","std::marker::Sized","std::option::Option","std::result::Result"],"<args::arg_matches::Indices<'a> as std::iter::DoubleEndedIterator>::next_back":["args::arg_matches::Indices","std::iter::Map","std::marker::Sized","std::option::Option"],"<args::arg_matches::Indices<'a> as std::iter::Iterator>::next":["args::arg_matches::Indices","std::iter::Map","std::marker::Sized","std::option::Option"],"<args::arg_matches::Indices<'a> as std::iter::Iterator>::size_hint":["args::arg_matches::Indices","std::iter::Map","std::marker::Sized","std::option::Option"],"<args::arg_matches::OsValues<'a> as std::clone::Clone>::clone":["args::arg_matches::OsValues","std::iter::Map","std::marker::Sized"],"<args::arg_matches::OsValues<'a> as std::default::Default>::default":["args::arg_matches::OsValues","std::iter::Map","std::marker::Sized"],"<args::arg_matches::OsValues<'a> as std::default::Default>::default::to_str_slice":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsStr","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::sys::unix::os_str::Slice","std::vec::Vec"],"<args::arg_matches::OsValues<'a> as std::fmt::Debug>::fmt":["args::arg_matches::OsValues","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::iter::Map","std::marker::Sized","std::option::Option","std::result::Result"],"<args::arg_matches::OsValues<'a> as std::iter::DoubleEndedIterator>::next_back":["args::arg_matches::OsValues","std::iter::Map","std::marker::Sized","std::option::Option"],"<args::arg_matches::OsValues<'a> as std::iter::Iterator>::next":["args::arg_matches::OsValues","std::iter::Map","std::marker::Sized","std::option::Option"],"<args::arg_matches::OsValues<'a> as std::iter::Iterator>::size_hint":["args::arg_matches::OsValues","std::iter::Map","std::marker::Sized","std::option::Option"],"<args::arg_matches::Values<'a> as std::clone::Clone>::clone":["args::arg_matches::Values","std::iter::Map","std::marker::Sized"],"<args::arg_matches::Values<'a> as std::default::Default>::default":["args::arg_matches::Values","std::iter::Map","std::marker::Sized"],"<args::arg_matches::Values<'a> as std::default::Default>::default::to_str_slice":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"<args::arg_matches::Values<'a> as std::fmt::Debug>::fmt":["args::arg_matches::Values","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::iter::Map","std::marker::Sized","std::option::Option","std::result::Result"],"<args::arg_matches::Values<'a> as std::iter::DoubleEndedIterator>::next_back":["args::arg_matches::Values","std::iter::Map","std::marker::Sized","std::option::Option"],"<args::arg_matches::Values<'a> as std::iter::Iterator>::next":["args::arg_matches::Values","std::iter::Map","std::marker::Sized","std::option::Option"],"<args::arg_matches::Values<'a> as std::iter::Iterator>::size_hint":["args::arg_matches::Values","std::iter::Map","std::marker::Sized","std::option::Option"],"<args::group::ArgGroup<'a> as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<args::group::ArgGroup<'a> as std::convert::From<&'z args::group::ArgGroup<'a>>>::from":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<args::group::ArgGroup<'a> as std::default::Default>::default":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<args::group::ArgGroup<'a> as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<args::matched_arg::MatchedArg as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","args::matched_arg::MatchedArg","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<args::matched_arg::MatchedArg as std::default::Default>::default":["alloc::raw_vec::RawVec","args::matched_arg::MatchedArg","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<args::matched_arg::MatchedArg as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","args::matched_arg::MatchedArg","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<args::settings::ArgFlags as std::clone::Clone>::clone":["args::settings::ArgFlags","args::settings::Flags"],"<args::settings::ArgFlags as std::default::Default>::default":["args::settings::ArgFlags","args::settings::Flags"],"<args::settings::ArgFlags as std::fmt::Debug>::fmt":["args::settings::ArgFlags","args::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::settings::ArgSettings as std::clone::Clone>::clone":["args::settings::ArgSettings"],"<args::settings::ArgSettings as std::cmp::PartialEq>::eq":["args::settings::ArgSettings"],"<args::settings::ArgSettings as std::fmt::Debug>::fmt":["args::settings::ArgSettings","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::settings::ArgSettings as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_TAC_VALS":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::CASE_INSENSITIVE":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DELIM_NOT_SET":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::EMPTY_VALS":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::GLOBAL":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN_LONG_H":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN_SHORT_H":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDE_DEFAULT_VAL":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDE_ENV_VALS":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDE_POS_VALS":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::LAST":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::MULTIPLE":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEXT_LINE_HELP":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::REQUIRED":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::REQUIRE_EQUALS":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::REQ_DELIM":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::R_UNLESS_ALL":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::TAKES_VAL":["args::settings::Flags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::USE_DELIM":["args::settings::Flags"],"<args::settings::Flags as std::clone::Clone>::clone":["args::settings::Flags"],"<args::settings::Flags as std::cmp::Eq>::assert_receiver_is_total_eq":["args::settings::Flags"],"<args::settings::Flags as std::cmp::Ord>::cmp":["args::settings::Flags","std::cmp::Ordering"],"<args::settings::Flags as std::cmp::PartialEq>::eq":["args::settings::Flags"],"<args::settings::Flags as std::cmp::PartialOrd>::partial_cmp":["args::settings::Flags","std::marker::Sized","std::option::Option"],"<args::settings::Flags as std::fmt::Binary>::fmt":["args::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::settings::Flags as std::fmt::Debug>::fmt":["args::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_TAC_VALS":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::CASE_INSENSITIVE":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DELIM_NOT_SET":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::EMPTY_VALS":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::GLOBAL":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN_LONG_H":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN_SHORT_H":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDE_DEFAULT_VAL":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDE_ENV_VALS":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDE_POS_VALS":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::LAST":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::MULTIPLE":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEXT_LINE_HELP":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::REQUIRED":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::REQUIRE_EQUALS":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::REQ_DELIM":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::R_UNLESS_ALL":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::TAKES_VAL":[],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::USE_DELIM":[],"<args::settings::Flags as std::fmt::LowerHex>::fmt":["args::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::settings::Flags as std::fmt::Octal>::fmt":["args::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::settings::Flags as std::fmt::UpperHex>::fmt":["args::settings::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<args::settings::Flags as std::hash::Hash>::hash":["args::settings::Flags","std::hash::Hasher","std::marker::Sized"],"<args::settings::Flags as std::iter::Extend<args::settings::Flags>>::extend":["args::settings::Flags","std::iter::IntoIterator","std::marker::Sized"],"<args::settings::Flags as std::iter::FromIterator<args::settings::Flags>>::from_iter":["args::settings::Flags","std::iter::IntoIterator","std::marker::Sized"],"<args::settings::Flags as std::ops::BitAnd>::bitand":["args::settings::Flags"],"<args::settings::Flags as std::ops::BitAndAssign>::bitand_assign":["args::settings::Flags"],"<args::settings::Flags as std::ops::BitOr>::bitor":["args::settings::Flags"],"<args::settings::Flags as std::ops::BitOrAssign>::bitor_assign":["args::settings::Flags"],"<args::settings::Flags as std::ops::BitXor>::bitxor":["args::settings::Flags"],"<args::settings::Flags as std::ops::BitXorAssign>::bitxor_assign":["args::settings::Flags"],"<args::settings::Flags as std::ops::Not>::not":["args::settings::Flags"],"<args::settings::Flags as std::ops::Sub>::sub":["args::settings::Flags"],"<args::settings::Flags as std::ops::SubAssign>::sub_assign":["args::settings::Flags"],"<args::subcommand::SubCommand<'a> as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","args::subcommand::SubCommand","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"<args::subcommand::SubCommand<'a> as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","args::subcommand::SubCommand","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"<completions::shell::Shell as std::clone::Clone>::clone":["completions::shell::Shell"],"<completions::shell::Shell as std::fmt::Debug>::fmt":["completions::shell::Shell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<completions::shell::Shell as std::fmt::Display>::fmt":["completions::shell::Shell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<completions::shell::Shell as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<errors::Error as std::convert::From<std::fmt::Error>>::from":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::fmt::Error","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<errors::Error as std::convert::From<std::io::Error>>::from":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<errors::Error as std::error::Error>::description":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<errors::Error as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<errors::Error as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<errors::ErrorKind as std::clone::Clone>::clone":["errors::ErrorKind"],"<errors::ErrorKind as std::cmp::PartialEq>::eq":["errors::ErrorKind"],"<errors::ErrorKind as std::fmt::Debug>::fmt":["errors::ErrorKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<fmt::ColorWhen as std::clone::Clone>::clone":["fmt::ColorWhen"],"<fmt::ColorWhen as std::cmp::PartialEq>::eq":["fmt::ColorWhen"],"<fmt::ColorWhen as std::fmt::Debug>::fmt":["fmt::ColorWhen","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<fmt::Colorizer as std::default::Default>::default":["fmt::ColorWhen","fmt::Colorizer"],"<fmt::Format<T> as std::fmt::Debug>::fmt":["fmt::Format","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<fmt::Format<T> as std::fmt::Display>::fmt":["fmt::Format","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<osstringext::OsSplit<'a> as std::clone::Clone>::clone":["osstringext::OsSplit"],"<osstringext::OsSplit<'a> as std::fmt::Debug>::fmt":["osstringext::OsSplit","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<osstringext::OsSplit<'a> as std::iter::Iterator>::next":["osstringext::OsSplit","std::marker::Sized","std::option::Option"],"<std::ffi::OsStr as osstringext::OsStrExt2>::contains_byte":["std::ffi::OsStr","std::sys::unix::os_str::Slice"],"<std::ffi::OsStr as osstringext::OsStrExt2>::split":["osstringext::OsSplit","std::ffi::OsStr","std::sys::unix::os_str::Slice"],"<std::ffi::OsStr as osstringext::OsStrExt2>::split_at":["std::ffi::OsStr","std::sys::unix::os_str::Slice"],"<std::ffi::OsStr as osstringext::OsStrExt2>::split_at_byte":["std::ffi::OsStr","std::sys::unix::os_str::Slice"],"<std::ffi::OsStr as osstringext::OsStrExt2>::starts_with":["std::ffi::OsStr","std::sys::unix::os_str::Slice"],"<std::ffi::OsStr as osstringext::OsStrExt2>::trim_left_matches":["std::ffi::OsStr","std::sys::unix::os_str::Slice"],"<str as strext::_StrExt>::_is_char_boundary":[],"<usage_parser::UsageParser<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","usage_parser::UsageParser","usage_parser::UsageToken"],"<usage_parser::UsageToken as std::cmp::PartialEq>::eq":["usage_parser::UsageToken"],"<usage_parser::UsageToken as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","usage_parser::UsageToken"],"app::App":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::about":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::after_help":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::alias":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::aliases":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::arg":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::arg_from_usage":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::args":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::args_from_usage":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::author":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::before_help":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::bin_name":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::display_order":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::gen_completions":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","completions::shell::Shell","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::gen_completions_to":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","completions::shell::Shell","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::get_bin_name":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::get_matches":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::get_matches_from":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::get_matches_from_safe":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::get_matches_from_safe_borrow":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::get_matches_safe":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::get_name":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::global_setting":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::global_settings":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::group":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::group::ArgGroup","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::groups":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::group::ArgGroup","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::help":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::help_message":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::help_short":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::long_about":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::long_version":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::max_term_width":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::name":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::new":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::print_help":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::print_long_help":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::set_term_width":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::setting":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::settings":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::subcommand":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::subcommands":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::template":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::unset_setting":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::unset_settings":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::usage":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::version":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::version_message":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::version_short":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::visible_alias":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::visible_aliases":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::with_defaults":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::write_help":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::write_long_help":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::write_long_version":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::App::<'a, 'b>::write_version":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::<impl args::any_arg::DispOrder for app::App<'b, 'c>>::disp_ord":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::ArgWithOrder::as_base":[],"app::help::CopyUntilResult":["app::help::CopyUntilResult","std::io::Error","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::ptr::NonNull"],"app::help::Help":["app::help::Help","fmt::ColorWhen","fmt::Colorizer"],"app::help::Help::<'a>::_write_parser_help":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::Help::<'a>::help":["app::help::Help","fmt::ColorWhen","fmt::Colorizer","std::marker::Sized","std::result::Result"],"app::help::Help::<'a>::long":["app::help::Help","fmt::ColorWhen","fmt::Colorizer","std::marker::Sized","std::result::Result"],"app::help::Help::<'a>::new":["app::help::Help","fmt::ColorWhen","fmt::Colorizer","std::marker::Sized","std::option::Option"],"app::help::Help::<'a>::short":["app::help::Help","fmt::ColorWhen","fmt::Colorizer","std::marker::Sized","std::result::Result"],"app::help::Help::<'a>::spec_vals":["alloc::raw_vec::RawVec","app::help::Help","fmt::ColorWhen","fmt::Colorizer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"app::help::Help::<'a>::val":["app::help::Help","fmt::ColorWhen","fmt::Colorizer","std::marker::Sized","std::result::Result"],"app::help::Help::<'a>::write_all_args":["alloc::raw_vec::RawVec","app::help::Help","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","fmt::Colorizer","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::Help::<'a>::write_app_help":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::Help::<'a>::write_arg":["app::help::Help","fmt::ColorWhen","fmt::Colorizer","std::marker::Sized","std::result::Result"],"app::help::Help::<'a>::write_args":["app::help::Help","args::arg_matches::Indices","fmt::ColorWhen","fmt::Colorizer","std::iter::Iterator","std::iter::Map","std::marker::Sized","std::result::Result"],"app::help::Help::<'a>::write_args_unsorted":["app::help::Help","args::arg_matches::Indices","fmt::ColorWhen","fmt::Colorizer","std::iter::Iterator","std::iter::Map","std::marker::Sized","std::result::Result"],"app::help::Help::<'a>::write_before_after_help":["app::help::Help","fmt::ColorWhen","fmt::Colorizer","std::marker::Sized","std::result::Result"],"app::help::Help::<'a>::write_bin_name":["alloc::raw_vec::RawVec","app::help::Help","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","fmt::Colorizer","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::Help::<'a>::write_default_help":["alloc::raw_vec::RawVec","app::help::Help","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","fmt::Colorizer","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::Help::<'a>::write_help":["alloc::raw_vec::RawVec","app::help::Help","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","fmt::Colorizer","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::Help::<'a>::write_parser_help":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::Help::<'a>::write_parser_help_to_stderr":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::Help::<'a>::write_subcommands":["alloc::raw_vec::RawVec","app::help::Help","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","fmt::Colorizer","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::Help::<'a>::write_templated_help":["alloc::raw_vec::RawVec","app::help::Help","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","fmt::Colorizer","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::Help::<'a>::write_version":["alloc::raw_vec::RawVec","app::help::Help","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","fmt::Colorizer","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::help::as_arg_trait":["<T as app::help::ArgWithOrder<'b, 'c>>::T","app::help::ArgWithOrder","std::marker::Sized"],"app::help::copy_and_capture":["std::io::Cursor","std::io::Read","std::io::Write","std::marker::Sized","std::option::Option"],"app::help::copy_until":["app::help::CopyUntilResult","std::io::Error","std::io::Read","std::io::Write","std::io::error::repr_bitpacked::Repr","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"app::help::should_show_arg":[],"app::help::str_width":[],"app::help::term_size::dimensions":["std::marker::Sized","std::option::Option"],"app::help::wrap_help":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"app::meta::AppMeta":["alloc::raw_vec::RawVec","app::meta::AppMeta","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"app::meta::AppMeta::<'b>::new":["alloc::raw_vec::RawVec","app::meta::AppMeta","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"app::meta::AppMeta::<'b>::with_name":["alloc::raw_vec::RawVec","app::meta::AppMeta","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"app::parser::ParseResult":["app::parser::ParseResult"],"app::parser::Parser":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::_help":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::_version":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::add_arg":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::add_arg_groups":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::add_arg_ref":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::add_conditional_reqs":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::add_defaults":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::add_env":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::add_group":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::group::ArgGroup","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::add_reqs":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::add_single_val_to_arg":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::any_arg::AnyArg","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::ffi::OsStr","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::add_subcommand":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::add_val_to_arg":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::any_arg::AnyArg","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::ffi::OsStr","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::app_debug_asserts":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::arg_names_in_group":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::args_in_group":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::build_bin_names":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::check_for_help_and_version_char":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::check_for_help_and_version_str":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::color":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::contains_long":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::contains_short":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::create_help_and_version":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::debug_asserts":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::derive_display_order":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::did_you_mean_error":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::find_any_arg":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::find_subcommand":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::flags":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::gen_completions":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::shell::Shell","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Buf","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::gen_completions_to":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::shell::Shell","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::get_matches_with":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::arg_matches::Indices","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::iter::Iterator","std::iter::Map","std::iter::Peekable","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::get_matches_with::as_trait_obj":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::any_arg::AnyArg","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::groups_for_arg":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::has_args":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::has_flags":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::has_opts":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::has_positionals":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::has_subcommands":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::has_visible_flags":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::has_visible_opts":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::has_visible_positionals":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::has_visible_subcommands":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::help_short":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::implied_settings":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::is_alias":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::is_bin_name":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::is_new_arg":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::ParseResult","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::is_set":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::opts":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::parse_flag":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::settings::ArgFlags","args::settings::Flags","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::parse_help_subcommand":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::arg_matches::Indices","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::iter::Iterator","std::iter::Map","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::parse_long_arg":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::arg_matches::Indices","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::ffi::OsStr","std::iter::Iterator","std::iter::Map","std::iter::Peekable","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::parse_opt":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::settings::ArgFlags","args::settings::Flags","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::parse_short_arg":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::parse_subcommand":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::arg_matches::Indices","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::iter::Iterator","std::iter::Map","std::iter::Peekable","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::positionals":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::string::String","std::vec::Vec","vec_map::Iter","vec_map::Values","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::possible_subcommand":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::possible_subcommand::starts":["std::ffi::OsStr","std::sys::unix::os_str::Slice"],"app::parser::Parser::<'a, 'b>::print_help":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::print_version":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::propagate_globals":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::propagate_help_version":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::propagate_settings":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::remove_overrides":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::required":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::set":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::subcommands":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::unset":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::use_long_help":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::verify_positionals":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::version_short":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::with_name":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::write_help":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::write_help_err":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::write_long_help":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::parser::Parser::<'a, 'b>::write_version":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::settings::AppFlags":["app::settings::AppFlags","app::settings::Flags"],"app::settings::AppFlags::is_set":["app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags"],"app::settings::AppFlags::new":["app::settings::AppFlags","app::settings::Flags"],"app::settings::AppFlags::set":["app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags"],"app::settings::AppFlags::unset":["app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags"],"app::settings::AppFlags::zeroed":["app::settings::AppFlags","app::settings::Flags"],"app::settings::AppSettings":["app::settings::AppSettings"],"app::settings::Flags":["app::settings::Flags"],"app::settings::Flags::all":["app::settings::Flags"],"app::settings::Flags::bits":["app::settings::Flags"],"app::settings::Flags::complement":["app::settings::Flags"],"app::settings::Flags::contains":["app::settings::Flags"],"app::settings::Flags::difference":["app::settings::Flags"],"app::settings::Flags::empty":["app::settings::Flags"],"app::settings::Flags::from_bits":["std::marker::Sized","std::option::Option"],"app::settings::Flags::from_bits_truncate":["app::settings::Flags"],"app::settings::Flags::from_bits_unchecked":["app::settings::Flags"],"app::settings::Flags::insert":["app::settings::Flags"],"app::settings::Flags::intersection":["app::settings::Flags"],"app::settings::Flags::intersects":["app::settings::Flags"],"app::settings::Flags::is_all":["app::settings::Flags"],"app::settings::Flags::is_empty":["app::settings::Flags"],"app::settings::Flags::remove":["app::settings::Flags"],"app::settings::Flags::set":["app::settings::Flags"],"app::settings::Flags::symmetric_difference":["app::settings::Flags"],"app::settings::Flags::toggle":["app::settings::Flags"],"app::settings::Flags::union":["app::settings::Flags"],"app::usage::create_error_usage":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::usage::create_help_usage":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::usage::create_smart_usage":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::usage::create_usage_no_title":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::usage::create_usage_with_title":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::usage::get_args_tag":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::usage::get_required_usage_from":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::collections::VecDeque","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::usage::needs_flags_tag":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::build_err":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::is_missing_required_ok":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::missing_required_error":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::new":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::ParseResult","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_conflicts":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_num_occurs":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::any_arg::AnyArg","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::matched_arg::MatchedArg","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_num_vals":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::any_arg::AnyArg","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::matched_arg::MatchedArg","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_requires":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::any_arg::AnyArg","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::matched_arg::MatchedArg","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_values":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::any_arg::AnyArg","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::matched_arg::MatchedArg","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate_blacklist":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate_blacklist::as_trait_obj":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::any_arg::AnyArg","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate_matched_args":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate_required":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate_required::as_trait_obj":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::any_arg::AnyArg","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"app::validator::Validator::<'a, 'b, 'z>::validate_required_unless":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","app::validator::Validator","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::any_arg::AnyArg::aliases":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::blacklist":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::default_val":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::default_vals_ifs":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::env":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::has_switch":[],"args::any_arg::AnyArg::help":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::is_set":["args::settings::ArgSettings"],"args::any_arg::AnyArg::long":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::long_help":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::longest_filter":[],"args::any_arg::AnyArg::max_vals":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::min_vals":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::name":[],"args::any_arg::AnyArg::num_vals":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::overrides":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::possible_vals":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::required_unless":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::requires":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::set":["args::settings::ArgSettings"],"args::any_arg::AnyArg::short":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::takes_value":[],"args::any_arg::AnyArg::val_delim":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::val_names":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::val_terminator":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::validator":["std::marker::Sized","std::option::Option"],"args::any_arg::AnyArg::validator_os":["std::marker::Sized","std::option::Option"],"args::any_arg::DispOrder::disp_ord":[],"args::arg::Arg":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::alias":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::settings::ArgFlags","args::settings::Flags","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg::Arg::<'a, 'b>::aliases":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::allow_hyphen_values":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::case_insensitive":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::conflicts_with":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::conflicts_with_all":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::default_value":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::default_value_if":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::default_value_if_os":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::ffi::OsStr","std::marker::Sized","std::option::Option","std::sys::unix::os_str::Slice"],"args::arg::Arg::<'a, 'b>::default_value_ifs":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::default_value_ifs_os":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::ffi::OsStr","std::marker::Sized","std::option::Option","std::sys::unix::os_str::Slice"],"args::arg::Arg::<'a, 'b>::default_value_os":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::ffi::OsStr","std::marker::Sized","std::option::Option","std::sys::unix::os_str::Slice"],"args::arg::Arg::<'a, 'b>::display_order":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::empty_values":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::env":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::env_os":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::ffi::OsStr","std::marker::Sized","std::option::Option","std::sys::unix::os_str::Slice"],"args::arg::Arg::<'a, 'b>::from_usage":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::global":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::group":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::groups":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::help":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::hidden":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::hidden_long_help":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::hidden_short_help":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::hide_default_value":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::hide_env_values":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::hide_possible_values":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::index":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::is_set":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::last":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::long":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::long_help":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::max_values":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::min_values":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::multiple":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::next_line_help":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::number_of_values":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::overrides_with":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::overrides_with_all":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::possible_value":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::possible_values":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::raw":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::require_delimiter":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::require_equals":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::required":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::required_if":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::required_ifs":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::required_unless":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::required_unless_all":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::required_unless_one":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::requires":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::requires_all":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::requires_if":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::requires_ifs":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::set":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::setb":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::short":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::convert::AsRef","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::takes_value":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::unset":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::unsetb":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::use_delimiter":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::validator":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::ops::Fn","std::option::Option"],"args::arg::Arg::<'a, 'b>::validator_os":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::ops::Fn","std::option::Option"],"args::arg::Arg::<'a, 'b>::value_delimiter":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::value_name":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::value_names":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::value_terminator":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::visible_alias":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::settings::ArgFlags","args::settings::Flags","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg::Arg::<'a, 'b>::visible_aliases":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg::Arg::<'a, 'b>::with_name":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::base::Base":["args::arg_builder::base::Base","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::base::Base::<'n, 'e>::is_set":["args::arg_builder::base::Base","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::base::Base::<'n, 'e>::new":["args::arg_builder::base::Base","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::base::Base::<'n, 'e>::set":["args::arg_builder::base::Base","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::base::Base::<'n, 'e>::unset":["args::arg_builder::base::Base","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::flag::FlagBuilder":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::flag::FlagBuilder::<'n, 'e>::new":["args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::option::OptBuilder":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::option::OptBuilder::<'n, 'e>::new":["args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::positional::PosBuilder":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::positional::PosBuilder::<'n, 'e>::from_arg":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::positional::PosBuilder::<'n, 'e>::from_arg_ref":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::positional::PosBuilder::<'n, 'e>::multiple_str":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::positional::PosBuilder::<'n, 'e>::name_no_brackets":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"args::arg_builder::positional::PosBuilder::<'n, 'e>::new":["args::arg_builder::base::Base","args::arg_builder::positional::PosBuilder","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option"],"args::arg_builder::switched::Switched":["args::arg_builder::switched::Switched","std::marker::Sized","std::option::Option"],"args::arg_builder::valued::Valued":["args::arg_builder::valued::Valued","std::marker::Sized","std::option::Option"],"args::arg_builder::valued::Valued::<'n, 'e>::fill_in":["args::arg_builder::valued::Valued","std::marker::Sized","std::option::Option"],"args::arg_matcher::ArgMatcher":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::add_index_to":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::add_val_to":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::arg_names":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::contains":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::entry":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::Bucket","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::rustc_entry::RustcOccupiedEntry","hashbrown::rustc_entry::RustcVacantEntry","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::collections::hash_map::Entry","std::collections::hash_map::OccupiedEntry","std::collections::hash_map::VacantEntry","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::fill_in_global_values":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::get":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::get_mut":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::handle_self_overrides":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::inc_occurrence_of":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::inc_occurrences_of":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::insert":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::is_empty":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::is_present":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::iter":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::map::Iter","hashbrown::raw::Bucket","hashbrown::raw::RawIter","hashbrown::raw::RawIterRange","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","hashbrown::raw::bitmask::BitMask","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::collections::hash_map::Iter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::needs_more_vals":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::any_arg::AnyArg","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::new":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::process_arg_overrides":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::propagate_globals":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::remove":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::remove_all":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::subcommand":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::subcommand::SubCommand","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::subcommand_name":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matcher::ArgMatcher::<'a>::usage":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::index_of":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::indices_of":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::indices_of::to_usize":[],"args::arg_matches::ArgMatches::<'a>::is_present":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::new":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::occurrences_of":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::subcommand":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::subcommand_matches":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::subcommand_name":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::usage":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::value_of":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::value_of_lossy":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::value_of_os":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::values_of":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::values_of::to_str_slice":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::vec::Vec"],"args::arg_matches::ArgMatches::<'a>::values_of_lossy":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::values_of_os":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::arg_matches::ArgMatches::<'a>::values_of_os::to_str_slice":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsStr","std::ffi::OsString","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::sys::unix::os_str::Buf","std::sys::unix::os_str::Slice","std::vec::Vec"],"args::arg_matches::Indices":["args::arg_matches::Indices","std::iter::Map","std::marker::Sized"],"args::arg_matches::OsValues":["args::arg_matches::OsValues","std::iter::Map","std::marker::Sized"],"args::arg_matches::Values":["args::arg_matches::Values","std::iter::Map","std::marker::Sized"],"args::group::ArgGroup":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::group::ArgGroup::<'a>::arg":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::group::ArgGroup::<'a>::args":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::group::ArgGroup::<'a>::conflicts_with":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::group::ArgGroup::<'a>::conflicts_with_all":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::group::ArgGroup::<'a>::multiple":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::group::ArgGroup::<'a>::required":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::group::ArgGroup::<'a>::requires":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::group::ArgGroup::<'a>::requires_all":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::group::ArgGroup::<'a>::with_name":["alloc::raw_vec::RawVec","args::group::ArgGroup","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::matched_arg::MatchedArg":["alloc::raw_vec::RawVec","args::matched_arg::MatchedArg","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::matched_arg::MatchedArg::new":["alloc::raw_vec::RawVec","args::matched_arg::MatchedArg","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"args::settings::ArgFlags":["args::settings::ArgFlags","args::settings::Flags"],"args::settings::ArgFlags::is_set":["args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags"],"args::settings::ArgFlags::new":["args::settings::ArgFlags","args::settings::Flags"],"args::settings::ArgFlags::set":["args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags"],"args::settings::ArgFlags::unset":["args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags"],"args::settings::ArgSettings":["args::settings::ArgSettings"],"args::settings::Flags":["args::settings::Flags"],"args::settings::Flags::all":["args::settings::Flags"],"args::settings::Flags::bits":["args::settings::Flags"],"args::settings::Flags::complement":["args::settings::Flags"],"args::settings::Flags::contains":["args::settings::Flags"],"args::settings::Flags::difference":["args::settings::Flags"],"args::settings::Flags::empty":["args::settings::Flags"],"args::settings::Flags::from_bits":["std::marker::Sized","std::option::Option"],"args::settings::Flags::from_bits_truncate":["args::settings::Flags"],"args::settings::Flags::from_bits_unchecked":["args::settings::Flags"],"args::settings::Flags::insert":["args::settings::Flags"],"args::settings::Flags::intersection":["args::settings::Flags"],"args::settings::Flags::intersects":["args::settings::Flags"],"args::settings::Flags::is_all":["args::settings::Flags"],"args::settings::Flags::is_empty":["args::settings::Flags"],"args::settings::Flags::remove":["args::settings::Flags"],"args::settings::Flags::set":["args::settings::Flags"],"args::settings::Flags::symmetric_difference":["args::settings::Flags"],"args::settings::Flags::toggle":["args::settings::Flags"],"args::settings::Flags::union":["args::settings::Flags"],"args::subcommand::SubCommand":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matches::ArgMatches","args::subcommand::SubCommand","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"args::subcommand::SubCommand::<'a>::with_name":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::ComplGen":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::ComplGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::ComplGen::<'a, 'b>::generate":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::ComplGen","completions::shell::Shell","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::ComplGen::<'a, 'b>::new":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::ComplGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::all_subcommand_names":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::all_subcommands":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::bash::BashGen":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::bash::BashGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::bash::BashGen::<'a, 'b>::all_options_for_path":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::bash::BashGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::bash::BashGen::<'a, 'b>::all_subcommands":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::bash::BashGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::bash::BashGen::<'a, 'b>::generate_to":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::bash::BashGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::bash::BashGen::<'a, 'b>::new":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::bash::BashGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::bash::BashGen::<'a, 'b>::option_details_for_path":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::bash::BashGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::bash::BashGen::<'a, 'b>::subcommand_details":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::bash::BashGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::bash::BashGen::<'a, 'b>::vals_for":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_builder::base::Base","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","completions::bash::BashGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::elvish::ElvishGen":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::elvish::ElvishGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::elvish::ElvishGen::<'a, 'b>::generate_to":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::elvish::ElvishGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::elvish::ElvishGen::<'a, 'b>::new":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::elvish::ElvishGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::elvish::escape_string":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"completions::elvish::generate_inner":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::elvish::get_tooltip":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::string::ToString","std::vec::Vec"],"completions::fish::FishGen":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::fish::FishGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::fish::FishGen::<'a, 'b>::generate_to":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::fish::FishGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::fish::FishGen::<'a, 'b>::new":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::fish::FishGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::fish::escape_string":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"completions::fish::gen_fish_inner":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::fish::FishGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::get_all_subcommand_paths":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::powershell::PowerShellGen":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::powershell::PowerShellGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::powershell::PowerShellGen::<'a, 'b>::generate_to":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::powershell::PowerShellGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::powershell::PowerShellGen::<'a, 'b>::new":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::powershell::PowerShellGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::powershell::escape_string":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"completions::powershell::generate_inner":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::powershell::get_tooltip":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::string::ToString","std::vec::Vec"],"completions::shell::Shell":["completions::shell::Shell"],"completions::shell::Shell::variants":[],"completions::subcommands_of":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::ZshGen":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::zsh::ZshGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::ZshGen::<'a, 'b>::generate_to":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::zsh::ZshGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::ZshGen::<'a, 'b>::new":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","completions::zsh::ZshGen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::escape_help":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"completions::zsh::escape_value":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"completions::zsh::get_args_of":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::get_subcommands_of":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::parser_of":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::subcommand_details":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::subcommands_of":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::subcommands_of::add_sc":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::write_flags_of":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::write_opts_of":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"completions::zsh::write_positionals_of":["alloc::raw_vec::RawVec","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"errors::Error::argument_conflict":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","errors::Error","errors::ErrorKind","fmt::ColorWhen","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::argument_not_found_auto":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","errors::Error","errors::ErrorKind","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::empty_value":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","errors::Error","errors::ErrorKind","fmt::ColorWhen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::exit":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"errors::Error::invalid_subcommand":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","errors::Error","errors::ErrorKind","fmt::ColorWhen","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::AsRef","std::convert::Into","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::invalid_utf8":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","errors::Error","errors::ErrorKind","fmt::ColorWhen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::invalid_value":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","errors::Error","errors::ErrorKind","fmt::ColorWhen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::convert::AsRef","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::io_error":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","fmt::ColorWhen","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"errors::Error::missing_required_argument":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","errors::Error","errors::ErrorKind","fmt::ColorWhen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::missing_subcommand":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","errors::Error","errors::ErrorKind","fmt::ColorWhen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::convert::AsRef","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::too_few_values":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","errors::Error","errors::ErrorKind","fmt::ColorWhen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::too_many_values":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","errors::Error","errors::ErrorKind","fmt::ColorWhen","std::alloc::Allocator","std::borrow::ToOwned","std::cell::Cell","std::cell::UnsafeCell","std::convert::AsRef","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::unexpected_multiple_usage":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","errors::Error","errors::ErrorKind","fmt::ColorWhen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::unknown_argument":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","errors::Error","errors::ErrorKind","fmt::ColorWhen","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::unrecognized_subcommand":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","errors::Error","errors::ErrorKind","fmt::ColorWhen","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::clone::Clone","std::collections::HashMap","std::convert::Into","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::Error::use_stderr":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"errors::Error::value_validation":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","fmt::ColorWhen","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"errors::Error::value_validation_auto":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"errors::Error::with_description":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"errors::Error::write_to":["alloc::raw_vec::RawVec","errors::Error","errors::ErrorKind","std::alloc::Allocator","std::io::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"errors::Error::wrong_number_of_values":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","errors::Error","errors::ErrorKind","fmt::ColorWhen","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"errors::ErrorKind":["errors::ErrorKind"],"fmt::ColorWhen":["fmt::ColorWhen"],"fmt::Colorizer":["fmt::ColorWhen","fmt::Colorizer"],"fmt::Colorizer::error":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","fmt::Colorizer","fmt::Format","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::convert::AsRef","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"fmt::Colorizer::good":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","fmt::Colorizer","fmt::Format","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::convert::AsRef","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"fmt::Colorizer::new":["fmt::ColorWhen","fmt::Colorizer","fmt::ColorizerOption"],"fmt::Colorizer::none":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","fmt::Colorizer","fmt::Format","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::convert::AsRef","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"fmt::Colorizer::warning":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","fmt::ColorWhen","fmt::Colorizer","fmt::Format","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::convert::AsRef","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"fmt::ColorizerOption":["fmt::ColorWhen","fmt::ColorizerOption"],"fmt::Format":["fmt::Format","std::marker::Sized"],"fmt::Format::<T>::format":["ansi_term::ANSIGenericString","ansi_term::Style","app::parser::ParseResult","fmt::Format","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Debug","std::marker::Sized","std::option::Option"],"fmt::is_a_tty":[],"fmt::is_term_dumb":[],"osstringext::OsSplit":["osstringext::OsSplit"],"osstringext::OsStrExt2::contains_byte":[],"osstringext::OsStrExt2::split":["osstringext::OsSplit"],"osstringext::OsStrExt2::split_at":["std::ffi::OsStr","std::sys::unix::os_str::Slice"],"osstringext::OsStrExt2::split_at_byte":["std::ffi::OsStr","std::sys::unix::os_str::Slice"],"osstringext::OsStrExt2::starts_with":[],"osstringext::OsStrExt2::trim_left_matches":["std::ffi::OsStr","std::sys::unix::os_str::Slice"],"strext::_StrExt::_is_char_boundary":[],"suggestions::did_you_mean":["std::convert::AsRef","std::iter::IntoIterator","std::marker::Sized","std::option::Option"],"suggestions::did_you_mean_flag_suffix":["alloc::raw_vec::RawVec","app::App","app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","app::settings::Flags","std::alloc::Allocator","std::cell::Cell","std::cell::UnsafeCell","std::convert::AsRef","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","vec_map::VecMap"],"suggestions::did_you_mean_value_suffix":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::convert::AsRef","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"usage_parser::UsageParser":["usage_parser::UsageParser","usage_parser::UsageToken"],"usage_parser::UsageParser::<'a>::from_usage":["usage_parser::UsageParser","usage_parser::UsageToken"],"usage_parser::UsageParser::<'a>::help":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option","usage_parser::UsageParser","usage_parser::UsageToken"],"usage_parser::UsageParser::<'a>::long":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option","usage_parser::UsageParser","usage_parser::UsageToken"],"usage_parser::UsageParser::<'a>::multiple":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option","usage_parser::UsageParser","usage_parser::UsageToken"],"usage_parser::UsageParser::<'a>::name":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option","usage_parser::UsageParser","usage_parser::UsageToken"],"usage_parser::UsageParser::<'a>::new":["usage_parser::UsageParser","usage_parser::UsageToken"],"usage_parser::UsageParser::<'a>::parse":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option","usage_parser::UsageParser","usage_parser::UsageToken"],"usage_parser::UsageParser::<'a>::short":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option","usage_parser::UsageParser","usage_parser::UsageToken"],"usage_parser::UsageParser::<'a>::short_or_long":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::settings::ArgFlags","args::settings::Flags","std::marker::Sized","std::option::Option","usage_parser::UsageParser","usage_parser::UsageToken"],"usage_parser::UsageParser::<'a>::stop_at":["std::marker::Sized","std::ops::Fn","usage_parser::UsageParser","usage_parser::UsageToken"],"usage_parser::UsageToken":["usage_parser::UsageToken"],"usage_parser::help_start":[],"usage_parser::long_end":[],"usage_parser::name_end":[],"usage_parser::token":[]},"glob_path_import":{},"self_to_fn":{"<T as app::help::ArgWithDisplay<'b, 'c>>::T":["impl<'b, 'c, T> ArgWithDisplay<'b, 'c> for T where T: AnyArg<'b, 'c> + Display {}"],"<T as app::help::ArgWithOrder<'b, 'c>>::T":["impl<'b, 'c, T> ArgWithOrder<'b, 'c> for T\nwhere\n    T: ArgWithDisplay<'b, 'c> + DispOrder,\n{\n    fn as_base(&self) -> &ArgWithDisplay<'b, 'c> {\n        self\n    }\n}"],"app::App":["impl<'a, 'b> App<'a, 'b> {\n    /// Creates a new instance of an application requiring a name. The name may be, but doesn't\n    /// have to be same as the binary. The name will be displayed to the user when they request to\n    /// print version or help and usage information.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// let prog = App::new(\"My Program\")\n    /// # ;\n    /// ```\n    pub fn new<S: Into<String>>(n: S) -> Self {\n        App {\n            p: Parser::with_name(n.into()),\n        }\n    }\n\n    /// Get the name of the app\n    pub fn get_name(&self) -> &str {\n        &self.p.meta.name\n    }\n\n    /// Get the name of the binary\n    pub fn get_bin_name(&self) -> Option<&str> {\n        self.p.meta.bin_name.as_ref().map(|s| s.as_str())\n    }\n\n    /// Creates a new instance of an application requiring a name, but uses the [`crate_authors!`]\n    /// and [`crate_version!`] macros to fill in the [`App::author`] and [`App::version`] fields.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// let prog = App::with_defaults(\"My Program\")\n    /// # ;\n    /// ```\n    /// [`crate_authors!`]: ./macro.crate_authors!.html\n    /// [`crate_version!`]: ./macro.crate_version!.html\n    /// [`App::author`]: ./struct.App.html#method.author\n    /// [`App::version`]: ./struct.App.html#method.author\n    #[deprecated(\n        since = \"2.14.1\",\n        note = \"Can never work; use explicit App::author() and App::version() calls instead\"\n    )]\n    pub fn with_defaults<S: Into<String>>(n: S) -> Self {\n        let mut a = App {\n            p: Parser::with_name(n.into()),\n        };\n        a.p.meta.author = Some(\"Kevin K. <kbknapp@gmail.com>\");\n        a.p.meta.version = Some(\"2.19.2\");\n        a\n    }\n\n    /// Creates a new instance of [`App`] from a .yml (YAML) file. A full example of supported YAML\n    /// objects can be found in [`examples/17_yaml.rs`] and [`examples/17_yaml.yml`]. One great use\n    /// for using YAML is when supporting multiple languages and dialects, as each language could\n    /// be a distinct YAML file and determined at compiletime via `cargo` \"features\" in your\n    /// `Cargo.toml`\n    ///\n    /// In order to use this function you must compile `clap` with the `features = [\"yaml\"]` in\n    /// your settings for the `[dependencies.clap]` table of your `Cargo.toml`\n    ///\n    /// **NOTE:** Due to how the YAML objects are built there is a convenience macro for loading\n    /// the YAML file at compile time (relative to the current file, like modules work). That YAML\n    /// object can then be passed to this function.\n    ///\n    /// # Panics\n    ///\n    /// The YAML file must be properly formatted or this function will [`panic!`]. A good way to\n    /// ensure this doesn't happen is to run your program with the `--help` switch. If this passes\n    /// without error, you needn't worry because the YAML is properly formatted.\n    ///\n    /// # Examples\n    ///\n    /// The following example shows how to load a properly formatted YAML file to build an instance\n    /// of an [`App`] struct.\n    ///\n    /// ```ignore\n    /// # #[macro_use]\n    /// # extern crate clap;\n    /// # use clap::App;\n    /// # fn main() {\n    /// let yml = load_yaml!(\"app.yml\");\n    /// let app = App::from_yaml(yml);\n    ///\n    /// // continued logic goes here, such as `app.get_matches()` etc.\n    /// # }\n    /// ```\n    /// [`App`]: ./struct.App.html\n    /// [`examples/17_yaml.rs`]: https://github.com/clap-rs/clap/blob/v2.33.1/examples/17_yaml.rs\n    /// [`examples/17_yaml.yml`]: https://github.com/clap-rs/clap/blob/v2.33.1/examples/17_yaml.yml\n    /// [`panic!`]: https://doc.rust-lang.org/std/macro.panic!.html\n    #[cfg(feature = \"yaml\")]\n    pub fn from_yaml(yaml: &'a Yaml) -> App<'a, 'a> {\n        App::from(yaml)\n    }\n\n    /// Sets a string of author(s) that will be displayed to the user when they\n    /// request the help information with `--help` or `-h`.\n    ///\n    /// **Pro-tip:** Use `clap`s convenience macro [`crate_authors!`] to automatically set your\n    /// application's author(s) to the same thing as your crate at compile time. See the [`examples/`]\n    /// directory for more information\n    ///\n    /// See the [`examples/`]\n    /// directory for more information\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///      .author(\"Me, me@mymain.com\")\n    /// # ;\n    /// ```\n    /// [`crate_authors!`]: ./macro.crate_authors!.html\n    /// [`examples/`]: https://github.com/clap-rs/clap/tree/v2.33.1/examples\n    pub fn author<S: Into<&'b str>>(mut self, author: S) -> Self {\n        self.p.meta.author = Some(author.into());\n        self\n    }\n\n    /// Overrides the system-determined binary name. This should only be used when absolutely\n    /// necessary, such as when the binary name for your application is misleading, or perhaps\n    /// *not* how the user should invoke your program.\n    ///\n    /// **Pro-tip:** When building things such as third party `cargo` subcommands, this setting\n    /// **should** be used!\n    ///\n    /// **NOTE:** This command **should not** be used for [`SubCommand`]s.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"My Program\")\n    ///      .bin_name(\"my_binary\")\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    pub fn bin_name<S: Into<String>>(mut self, name: S) -> Self {\n        self.p.meta.bin_name = Some(name.into());\n        self\n    }\n\n    /// Sets a string describing what the program does. This will be displayed when displaying help\n    /// information with `-h`.\n    ///\n    /// **NOTE:** If only `about` is provided, and not [`App::long_about`] but the user requests\n    /// `--help` clap will still display the contents of `about` appropriately\n    ///\n    /// **NOTE:** Only [`App::about`] is used in completion script generation in order to be\n    /// concise\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .about(\"Does really amazing things to great people\")\n    /// # ;\n    /// ```\n    /// [`App::long_about`]: ./struct.App.html#method.long_about\n    pub fn about<S: Into<&'b str>>(mut self, about: S) -> Self {\n        self.p.meta.about = Some(about.into());\n        self\n    }\n\n    /// Sets a string describing what the program does. This will be displayed when displaying help\n    /// information.\n    ///\n    /// **NOTE:** If only `long_about` is provided, and not [`App::about`] but the user requests\n    /// `-h` clap will still display the contents of `long_about` appropriately\n    ///\n    /// **NOTE:** Only [`App::about`] is used in completion script generation in order to be\n    /// concise\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .long_about(\n    /// \"Does really amazing things to great people. Now let's talk a little\n    ///  more in depth about how this subcommand really works. It may take about\n    ///  a few lines of text, but that's ok!\")\n    /// # ;\n    /// ```\n    /// [`App::about`]: ./struct.App.html#method.about\n    pub fn long_about<S: Into<&'b str>>(mut self, about: S) -> Self {\n        self.p.meta.long_about = Some(about.into());\n        self\n    }\n\n    /// Sets the program's name. This will be displayed when displaying help information.\n    ///\n    /// **Pro-top:** This function is particularly useful when configuring a program via\n    /// [`App::from_yaml`] in conjunction with the [`crate_name!`] macro to derive the program's\n    /// name from its `Cargo.toml`.\n    ///\n    /// # Examples\n    /// ```ignore\n    /// # #[macro_use]\n    /// # extern crate clap;\n    /// # use clap::App;\n    /// # fn main() {\n    /// let yml = load_yaml!(\"app.yml\");\n    /// let app = App::from_yaml(yml)\n    ///     .name(crate_name!());\n    ///\n    /// // continued logic goes here, such as `app.get_matches()` etc.\n    /// # }\n    /// ```\n    ///\n    /// [`App::from_yaml`]: ./struct.App.html#method.from_yaml\n    /// [`crate_name!`]: ./macro.crate_name.html\n    pub fn name<S: Into<String>>(mut self, name: S) -> Self {\n        self.p.meta.name = name.into();\n        self\n    }\n\n    /// Adds additional help information to be displayed in addition to auto-generated help. This\n    /// information is displayed **after** the auto-generated help information. This is often used\n    /// to describe how to use the arguments, or caveats to be noted.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::App;\n    /// App::new(\"myprog\")\n    ///     .after_help(\"Does really amazing things to great people...but be careful with -R\")\n    /// # ;\n    /// ```\n    pub fn after_help<S: Into<&'b str>>(mut self, help: S) -> Self {\n        self.p.meta.more_help = Some(help.into());\n        self\n    }\n\n    /// Adds additional help information to be displayed in addition to auto-generated help. This\n    /// information is displayed **before** the auto-generated help information. This is often used\n    /// for header information.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::App;\n    /// App::new(\"myprog\")\n    ///     .before_help(\"Some info I'd like to appear before the help info\")\n    /// # ;\n    /// ```\n    pub fn before_help<S: Into<&'b str>>(mut self, help: S) -> Self {\n        self.p.meta.pre_help = Some(help.into());\n        self\n    }\n\n    /// Sets a string of the version number to be displayed when displaying version or help\n    /// information with `-V`.\n    ///\n    /// **NOTE:** If only `version` is provided, and not [`App::long_version`] but the user\n    /// requests `--version` clap will still display the contents of `version` appropriately\n    ///\n    /// **Pro-tip:** Use `clap`s convenience macro [`crate_version!`] to automatically set your\n    /// application's version to the same thing as your crate at compile time. See the [`examples/`]\n    /// directory for more information\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .version(\"v0.1.24\")\n    /// # ;\n    /// ```\n    /// [`crate_version!`]: ./macro.crate_version!.html\n    /// [`examples/`]: https://github.com/clap-rs/clap/tree/v2.33.1/examples\n    /// [`App::long_version`]: ./struct.App.html#method.long_version\n    pub fn version<S: Into<&'b str>>(mut self, ver: S) -> Self {\n        self.p.meta.version = Some(ver.into());\n        self\n    }\n\n    /// Sets a string of the version number to be displayed when displaying version or help\n    /// information with `--version`.\n    ///\n    /// **NOTE:** If only `long_version` is provided, and not [`App::version`] but the user\n    /// requests `-V` clap will still display the contents of `long_version` appropriately\n    ///\n    /// **Pro-tip:** Use `clap`s convenience macro [`crate_version!`] to automatically set your\n    /// application's version to the same thing as your crate at compile time. See the [`examples/`]\n    /// directory for more information\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .long_version(\n    /// \"v0.1.24\n    ///  commit: abcdef89726d\n    ///  revision: 123\n    ///  release: 2\n    ///  binary: myprog\")\n    /// # ;\n    /// ```\n    /// [`crate_version!`]: ./macro.crate_version!.html\n    /// [`examples/`]: https://github.com/clap-rs/clap/tree/v2.33.1/examples\n    /// [`App::version`]: ./struct.App.html#method.version\n    pub fn long_version<S: Into<&'b str>>(mut self, ver: S) -> Self {\n        self.p.meta.long_version = Some(ver.into());\n        self\n    }\n\n    /// Sets a custom usage string to override the auto-generated usage string.\n    ///\n    /// This will be displayed to the user when errors are found in argument parsing, or when you\n    /// call [`ArgMatches::usage`]\n    ///\n    /// **CAUTION:** Using this setting disables `clap`s \"context-aware\" usage strings. After this\n    /// setting is set, this will be the only usage string displayed to the user!\n    ///\n    /// **NOTE:** You do not need to specify the \"USAGE: \\n\\t\" portion, as that will\n    /// still be applied by `clap`, you only need to specify the portion starting\n    /// with the binary name.\n    ///\n    /// **NOTE:** This will not replace the entire help message, *only* the portion\n    /// showing the usage.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .usage(\"myapp [-clDas] <some_file>\")\n    /// # ;\n    /// ```\n    /// [`ArgMatches::usage`]: ./struct.ArgMatches.html#method.usage\n    pub fn usage<S: Into<&'b str>>(mut self, usage: S) -> Self {\n        self.p.meta.usage_str = Some(usage.into());\n        self\n    }\n\n    /// Sets a custom help message and overrides the auto-generated one. This should only be used\n    /// when the auto-generated message does not suffice.\n    ///\n    /// This will be displayed to the user when they use `--help` or `-h`\n    ///\n    /// **NOTE:** This replaces the **entire** help message, so nothing will be auto-generated.\n    ///\n    /// **NOTE:** This **only** replaces the help message for the current command, meaning if you\n    /// are using subcommands, those help messages will still be auto-generated unless you\n    /// specify a [`Arg::help`] for them as well.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myapp\")\n    ///     .help(\"myapp v1.0\\n\\\n    ///            Does awesome things\\n\\\n    ///            (C) me@mail.com\\n\\n\\\n    ///\n    ///            USAGE: myapp <opts> <command>\\n\\n\\\n    ///\n    ///            Options:\\n\\\n    ///            -h, --help       Display this message\\n\\\n    ///            -V, --version    Display version info\\n\\\n    ///            -s <stuff>       Do something with stuff\\n\\\n    ///            -v               Be verbose\\n\\n\\\n    ///\n    ///            Commmands:\\n\\\n    ///            help             Prints this message\\n\\\n    ///            work             Do some work\")\n    /// # ;\n    /// ```\n    /// [`Arg::help`]: ./struct.Arg.html#method.help\n    pub fn help<S: Into<&'b str>>(mut self, help: S) -> Self {\n        self.p.meta.help_str = Some(help.into());\n        self\n    }\n\n    /// Sets the [`short`] for the auto-generated `help` argument.\n    ///\n    /// By default `clap` automatically assigns `h`, but this can be overridden if you have a\n    /// different argument which you'd prefer to use the `-h` short with. This can be done by\n    /// defining your own argument with a lowercase `h` as the [`short`].\n    ///\n    /// `clap` lazily generates these `help` arguments **after** you've defined any arguments of\n    /// your own.\n    ///\n    /// **NOTE:** Any leading `-` characters will be stripped, and only the first\n    /// non `-` character will be used as the [`short`] version\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .help_short(\"H\") // Using an uppercase `H` instead of the default lowercase `h`\n    /// # ;\n    /// ```\n    /// [`short`]: ./struct.Arg.html#method.short\n    pub fn help_short<S: AsRef<str> + 'b>(mut self, s: S) -> Self {\n        self.p.help_short(s.as_ref());\n        self\n    }\n\n    /// Sets the [`short`] for the auto-generated `version` argument.\n    ///\n    /// By default `clap` automatically assigns `V`, but this can be overridden if you have a\n    /// different argument which you'd prefer to use the `-V` short with. This can be done by\n    /// defining your own argument with an uppercase `V` as the [`short`].\n    ///\n    /// `clap` lazily generates these `version` arguments **after** you've defined any arguments of\n    /// your own.\n    ///\n    /// **NOTE:** Any leading `-` characters will be stripped, and only the first\n    /// non `-` character will be used as the `short` version\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .version_short(\"v\") // Using a lowercase `v` instead of the default capital `V`\n    /// # ;\n    /// ```\n    /// [`short`]: ./struct.Arg.html#method.short\n    pub fn version_short<S: AsRef<str>>(mut self, s: S) -> Self {\n        self.p.version_short(s.as_ref());\n        self\n    }\n\n    /// Sets the help text for the auto-generated `help` argument.\n    ///\n    /// By default `clap` sets this to `\"Prints help information\"`, but if you're using a\n    /// different convention for your help messages and would prefer a different phrasing you can\n    /// override it.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .help_message(\"Print help information\") // Perhaps you want imperative help messages\n    ///\n    /// # ;\n    /// ```\n    pub fn help_message<S: Into<&'a str>>(mut self, s: S) -> Self {\n        self.p.help_message = Some(s.into());\n        self\n    }\n\n    /// Sets the help text for the auto-generated `version` argument.\n    ///\n    /// By default `clap` sets this to `\"Prints version information\"`, but if you're using a\n    /// different convention for your help messages and would prefer a different phrasing then you\n    /// can change it.\n    ///\n    /// # Examples\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .version_message(\"Print version information\") // Perhaps you want imperative help messages\n    /// # ;\n    /// ```\n    pub fn version_message<S: Into<&'a str>>(mut self, s: S) -> Self {\n        self.p.version_message = Some(s.into());\n        self\n    }\n\n    /// Sets the help template to be used, overriding the default format.\n    ///\n    /// Tags arg given inside curly brackets.\n    ///\n    /// Valid tags are:\n    ///\n    ///   * `{bin}`         - Binary name.\n    ///   * `{version}`     - Version number.\n    ///   * `{author}`      - Author information.\n    ///   * `{about}`       - General description (from [`App::about`])\n    ///   * `{usage}`       - Automatically generated or given usage string.\n    ///   * `{all-args}`    - Help for all arguments (options, flags, positionals arguments,\n    ///                       and subcommands) including titles.\n    ///   * `{unified}`     - Unified help for options and flags. Note, you must *also* set\n    ///                       [`AppSettings::UnifiedHelpMessage`] to fully merge both options and\n    ///                       flags, otherwise the ordering is \"best effort\"\n    ///   * `{flags}`       - Help for flags.\n    ///   * `{options}`     - Help for options.\n    ///   * `{positionals}` - Help for positionals arguments.\n    ///   * `{subcommands}` - Help for subcommands.\n    ///   * `{after-help}`  - Help from [`App::after_help`]\n    ///   * `{before-help}`  - Help from [`App::before_help`]\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .version(\"1.0\")\n    ///     .template(\"{bin} ({version}) - {usage}\")\n    /// # ;\n    /// ```\n    /// **NOTE:** The template system is, on purpose, very simple. Therefore the tags have to be\n    /// written in lowercase and without spacing.\n    ///\n    /// [`App::about`]: ./struct.App.html#method.about\n    /// [`App::after_help`]: ./struct.App.html#method.after_help\n    /// [`App::before_help`]: ./struct.App.html#method.before_help\n    /// [`AppSettings::UnifiedHelpMessage`]: ./enum.AppSettings.html#variant.UnifiedHelpMessage\n    pub fn template<S: Into<&'b str>>(mut self, s: S) -> Self {\n        self.p.meta.template = Some(s.into());\n        self\n    }\n\n    /// Enables a single command, or [`SubCommand`], level settings.\n    ///\n    /// See [`AppSettings`] for a full list of possibilities and examples.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::SubcommandRequired)\n    ///     .setting(AppSettings::WaitOnError)\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`AppSettings`]: ./enum.AppSettings.html\n    pub fn setting(mut self, setting: AppSettings) -> Self {\n        self.p.set(setting);\n        self\n    }\n\n    /// Enables multiple command, or [`SubCommand`], level settings\n    ///\n    /// See [`AppSettings`] for a full list of possibilities and examples.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .settings(&[AppSettings::SubcommandRequired,\n    ///                  AppSettings::WaitOnError])\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`AppSettings`]: ./enum.AppSettings.html\n    pub fn settings(mut self, settings: &[AppSettings]) -> Self {\n        for s in settings {\n            self.p.set(*s);\n        }\n        self\n    }\n\n    /// Enables a single setting that is propagated down through all child [`SubCommand`]s.\n    ///\n    /// See [`AppSettings`] for a full list of possibilities and examples.\n    ///\n    /// **NOTE**: The setting is *only* propagated *down* and not up through parent commands.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .global_setting(AppSettings::SubcommandRequired)\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`AppSettings`]: ./enum.AppSettings.html\n    pub fn global_setting(mut self, setting: AppSettings) -> Self {\n        self.p.set(setting);\n        self.p.g_settings.set(setting);\n        self\n    }\n\n    /// Enables multiple settings which are propagated *down* through all child [`SubCommand`]s.\n    ///\n    /// See [`AppSettings`] for a full list of possibilities and examples.\n    ///\n    /// **NOTE**: The setting is *only* propagated *down* and not up through parent commands.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .global_settings(&[AppSettings::SubcommandRequired,\n    ///                  AppSettings::ColoredHelp])\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`AppSettings`]: ./enum.AppSettings.html\n    pub fn global_settings(mut self, settings: &[AppSettings]) -> Self {\n        for s in settings {\n            self.p.set(*s);\n            self.p.g_settings.set(*s)\n        }\n        self\n    }\n\n    /// Disables a single command, or [`SubCommand`], level setting.\n    ///\n    /// See [`AppSettings`] for a full list of possibilities and examples.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .unset_setting(AppSettings::ColorAuto)\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`AppSettings`]: ./enum.AppSettings.html\n    pub fn unset_setting(mut self, setting: AppSettings) -> Self {\n        self.p.unset(setting);\n        self\n    }\n\n    /// Disables multiple command, or [`SubCommand`], level settings.\n    ///\n    /// See [`AppSettings`] for a full list of possibilities and examples.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .unset_settings(&[AppSettings::ColorAuto,\n    ///                       AppSettings::AllowInvalidUtf8])\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`AppSettings`]: ./enum.AppSettings.html\n    pub fn unset_settings(mut self, settings: &[AppSettings]) -> Self {\n        for s in settings {\n            self.p.unset(*s);\n        }\n        self\n    }\n\n    /// Sets the terminal width at which to wrap help messages. Defaults to `120`. Using `0` will\n    /// ignore terminal widths and use source formatting.\n    ///\n    /// `clap` automatically tries to determine the terminal width on Unix, Linux, macOS and Windows\n    /// if the `wrap_help` cargo \"feature\" has been used while compiling. If the terminal width\n    /// cannot be determined, `clap` defaults to `120`.\n    ///\n    /// **NOTE:** This setting applies globally and *not* on a per-command basis.\n    ///\n    /// **NOTE:** This setting must be set **before** any subcommands are added!\n    ///\n    /// # Platform Specific\n    ///\n    /// Only Unix, Linux, macOS and Windows support automatic determination of terminal width.\n    /// Even on those platforms, this setting is useful if for any reason the terminal width\n    /// cannot be determined.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::App;\n    /// App::new(\"myprog\")\n    ///     .set_term_width(80)\n    /// # ;\n    /// ```\n    pub fn set_term_width(mut self, width: usize) -> Self {\n        self.p.meta.term_w = Some(width);\n        self\n    }\n\n    /// Sets the max terminal width at which to wrap help messages. Using `0` will ignore terminal\n    /// widths and use source formatting.\n    ///\n    /// `clap` automatically tries to determine the terminal width on Unix, Linux, macOS and Windows\n    /// if the `wrap_help` cargo \"feature\" has been used while compiling, but one might want to\n    /// limit the size (e.g. when the terminal is running fullscreen).\n    ///\n    /// **NOTE:** This setting applies globally and *not* on a per-command basis.\n    ///\n    /// **NOTE:** This setting must be set **before** any subcommands are added!\n    ///\n    /// # Platform Specific\n    ///\n    /// Only Unix, Linux, macOS and Windows support automatic determination of terminal width.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::App;\n    /// App::new(\"myprog\")\n    ///     .max_term_width(100)\n    /// # ;\n    /// ```\n    pub fn max_term_width(mut self, w: usize) -> Self {\n        self.p.meta.max_w = Some(w);\n        self\n    }\n\n    /// Adds an [argument] to the list of valid possibilities.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     // Adding a single \"flag\" argument with a short and help text, using Arg::with_name()\n    ///     .arg(\n    ///         Arg::with_name(\"debug\")\n    ///            .short(\"d\")\n    ///            .help(\"turns on debugging mode\")\n    ///     )\n    ///     // Adding a single \"option\" argument with a short, a long, and help text using the less\n    ///     // verbose Arg::from_usage()\n    ///     .arg(\n    ///         Arg::from_usage(\"-c --config=[CONFIG] 'Optionally sets a config file to use'\")\n    ///     )\n    /// # ;\n    /// ```\n    /// [argument]: ./struct.Arg.html\n    pub fn arg<A: Into<Arg<'a, 'b>>>(mut self, a: A) -> Self {\n        self.p.add_arg(a.into());\n        self\n    }\n\n    /// Adds multiple [arguments] to the list of valid possibilities\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .args(\n    ///         &[Arg::from_usage(\"[debug] -d 'turns on debugging info'\"),\n    ///          Arg::with_name(\"input\").index(1).help(\"the input file to use\")]\n    ///     )\n    /// # ;\n    /// ```\n    /// [arguments]: ./struct.Arg.html\n    pub fn args(mut self, args: &[Arg<'a, 'b>]) -> Self {\n        for arg in args {\n            self.p.add_arg_ref(arg);\n        }\n        self\n    }\n\n    /// A convenience method for adding a single [argument] from a usage type string. The string\n    /// used follows the same rules and syntax as [`Arg::from_usage`]\n    ///\n    /// **NOTE:** The downside to using this method is that you can not set any additional\n    /// properties of the [`Arg`] other than what [`Arg::from_usage`] supports.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .arg_from_usage(\"-c --config=<FILE> 'Sets a configuration file to use'\")\n    /// # ;\n    /// ```\n    /// [argument]: ./struct.Arg.html\n    /// [`Arg`]: ./struct.Arg.html\n    /// [`Arg::from_usage`]: ./struct.Arg.html#method.from_usage\n    pub fn arg_from_usage(mut self, usage: &'a str) -> Self {\n        self.p.add_arg(Arg::from_usage(usage));\n        self\n    }\n\n    /// Adds multiple [arguments] at once from a usage string, one per line. See\n    /// [`Arg::from_usage`] for details on the syntax and rules supported.\n    ///\n    /// **NOTE:** Like [`App::arg_from_usage`] the downside is you only set properties for the\n    /// [`Arg`]s which [`Arg::from_usage`] supports.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// App::new(\"myprog\")\n    ///     .args_from_usage(\n    ///         \"-c --config=[FILE] 'Sets a configuration file to use'\n    ///          [debug]... -d 'Sets the debugging level'\n    ///          <FILE> 'The input file to use'\"\n    ///     )\n    /// # ;\n    /// ```\n    /// [arguments]: ./struct.Arg.html\n    /// [`Arg::from_usage`]: ./struct.Arg.html#method.from_usage\n    /// [`App::arg_from_usage`]: ./struct.App.html#method.arg_from_usage\n    /// [`Arg`]: ./struct.Arg.html\n    pub fn args_from_usage(mut self, usage: &'a str) -> Self {\n        for line in usage.lines() {\n            let l = line.trim();\n            if l.is_empty() {\n                continue;\n            }\n            self.p.add_arg(Arg::from_usage(l));\n        }\n        self\n    }\n\n    /// Allows adding a [`SubCommand`] alias, which function as \"hidden\" subcommands that\n    /// automatically dispatch as if this subcommand was used. This is more efficient, and easier\n    /// than creating multiple hidden subcommands as one only needs to check for the existence of\n    /// this command, and not all variants.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand};\n    /// let m = App::new(\"myprog\")\n    ///             .subcommand(SubCommand::with_name(\"test\")\n    ///                 .alias(\"do-stuff\"))\n    ///             .get_matches_from(vec![\"myprog\", \"do-stuff\"]);\n    /// assert_eq!(m.subcommand_name(), Some(\"test\"));\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    pub fn alias<S: Into<&'b str>>(mut self, name: S) -> Self {\n        if let Some(ref mut als) = self.p.meta.aliases {\n            als.push((name.into(), false));\n        } else {\n            self.p.meta.aliases = Some(vec![(name.into(), false)]);\n        }\n        self\n    }\n\n    /// Allows adding [`SubCommand`] aliases, which function as \"hidden\" subcommands that\n    /// automatically dispatch as if this subcommand was used. This is more efficient, and easier\n    /// than creating multiple hidden subcommands as one only needs to check for the existence of\n    /// this command, and not all variants.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, SubCommand};\n    /// let m = App::new(\"myprog\")\n    ///             .subcommand(SubCommand::with_name(\"test\")\n    ///                 .aliases(&[\"do-stuff\", \"do-tests\", \"tests\"]))\n    ///                 .arg(Arg::with_name(\"input\")\n    ///                             .help(\"the file to add\")\n    ///                             .index(1)\n    ///                             .required(false))\n    ///             .get_matches_from(vec![\"myprog\", \"do-tests\"]);\n    /// assert_eq!(m.subcommand_name(), Some(\"test\"));\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    pub fn aliases(mut self, names: &[&'b str]) -> Self {\n        if let Some(ref mut als) = self.p.meta.aliases {\n            for n in names {\n                als.push((n, false));\n            }\n        } else {\n            self.p.meta.aliases = Some(names.iter().map(|n| (*n, false)).collect::<Vec<_>>());\n        }\n        self\n    }\n\n    /// Allows adding a [`SubCommand`] alias that functions exactly like those defined with\n    /// [`App::alias`], except that they are visible inside the help message.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand};\n    /// let m = App::new(\"myprog\")\n    ///             .subcommand(SubCommand::with_name(\"test\")\n    ///                 .visible_alias(\"do-stuff\"))\n    ///             .get_matches_from(vec![\"myprog\", \"do-stuff\"]);\n    /// assert_eq!(m.subcommand_name(), Some(\"test\"));\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`App::alias`]: ./struct.App.html#method.alias\n    pub fn visible_alias<S: Into<&'b str>>(mut self, name: S) -> Self {\n        if let Some(ref mut als) = self.p.meta.aliases {\n            als.push((name.into(), true));\n        } else {\n            self.p.meta.aliases = Some(vec![(name.into(), true)]);\n        }\n        self\n    }\n\n    /// Allows adding multiple [`SubCommand`] aliases that functions exactly like those defined\n    /// with [`App::aliases`], except that they are visible inside the help message.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand};\n    /// let m = App::new(\"myprog\")\n    ///             .subcommand(SubCommand::with_name(\"test\")\n    ///                 .visible_aliases(&[\"do-stuff\", \"tests\"]))\n    ///             .get_matches_from(vec![\"myprog\", \"do-stuff\"]);\n    /// assert_eq!(m.subcommand_name(), Some(\"test\"));\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`App::aliases`]: ./struct.App.html#method.aliases\n    pub fn visible_aliases(mut self, names: &[&'b str]) -> Self {\n        if let Some(ref mut als) = self.p.meta.aliases {\n            for n in names {\n                als.push((n, true));\n            }\n        } else {\n            self.p.meta.aliases = Some(names.iter().map(|n| (*n, true)).collect::<Vec<_>>());\n        }\n        self\n    }\n\n    /// Adds an [`ArgGroup`] to the application. [`ArgGroup`]s are a family of related arguments.\n    /// By placing them in a logical group, you can build easier requirement and exclusion rules.\n    /// For instance, you can make an entire [`ArgGroup`] required, meaning that one (and *only*\n    /// one) argument from that group must be present at runtime.\n    ///\n    /// You can also do things such as name an [`ArgGroup`] as a conflict to another argument.\n    /// Meaning any of the arguments that belong to that group will cause a failure if present with\n    /// the conflicting argument.\n    ///\n    /// Another added benefit of [`ArgGroup`]s is that you can extract a value from a group instead\n    /// of determining exactly which argument was used.\n    ///\n    /// Finally, using [`ArgGroup`]s to ensure exclusion between arguments is another very common\n    /// use\n    ///\n    /// # Examples\n    ///\n    /// The following example demonstrates using an [`ArgGroup`] to ensure that one, and only one,\n    /// of the arguments from the specified group is present at runtime.\n    ///\n    /// ```no_run\n    /// # use clap::{App, ArgGroup};\n    /// App::new(\"app\")\n    ///     .args_from_usage(\n    ///         \"--set-ver [ver] 'set the version manually'\n    ///          --major         'auto increase major'\n    ///          --minor         'auto increase minor'\n    ///          --patch         'auto increase patch'\")\n    ///     .group(ArgGroup::with_name(\"vers\")\n    ///          .args(&[\"set-ver\", \"major\", \"minor\",\"patch\"])\n    ///          .required(true))\n    /// # ;\n    /// ```\n    /// [`ArgGroup`]: ./struct.ArgGroup.html\n    pub fn group(mut self, group: ArgGroup<'a>) -> Self {\n        self.p.add_group(group);\n        self\n    }\n\n    /// Adds multiple [`ArgGroup`]s to the [`App`] at once.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, ArgGroup};\n    /// App::new(\"app\")\n    ///     .args_from_usage(\n    ///         \"--set-ver [ver] 'set the version manually'\n    ///          --major         'auto increase major'\n    ///          --minor         'auto increase minor'\n    ///          --patch         'auto increase patch'\n    ///          -c [FILE]       'a config file'\n    ///          -i [IFACE]      'an interface'\")\n    ///     .groups(&[\n    ///         ArgGroup::with_name(\"vers\")\n    ///             .args(&[\"set-ver\", \"major\", \"minor\",\"patch\"])\n    ///             .required(true),\n    ///         ArgGroup::with_name(\"input\")\n    ///             .args(&[\"c\", \"i\"])\n    ///     ])\n    /// # ;\n    /// ```\n    /// [`ArgGroup`]: ./struct.ArgGroup.html\n    /// [`App`]: ./struct.App.html\n    pub fn groups(mut self, groups: &[ArgGroup<'a>]) -> Self {\n        for g in groups {\n            self = self.group(g.into());\n        }\n        self\n    }\n\n    /// Adds a [`SubCommand`] to the list of valid possibilities. Subcommands are effectively\n    /// sub-[`App`]s, because they can contain their own arguments, subcommands, version, usage,\n    /// etc. They also function just like [`App`]s, in that they get their own auto generated help,\n    /// version, and usage.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand};\n    /// App::new(\"myprog\")\n    ///     .subcommand(SubCommand::with_name(\"config\")\n    ///         .about(\"Controls configuration features\")\n    ///         .arg_from_usage(\"<config> 'Required configuration file to use'\"))\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`App`]: ./struct.App.html\n    pub fn subcommand(mut self, subcmd: App<'a, 'b>) -> Self {\n        self.p.add_subcommand(subcmd);\n        self\n    }\n\n    /// Adds multiple subcommands to the list of valid possibilities by iterating over an\n    /// [`IntoIterator`] of [`SubCommand`]s\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, SubCommand};\n    /// # App::new(\"myprog\")\n    /// .subcommands( vec![\n    ///        SubCommand::with_name(\"config\").about(\"Controls configuration functionality\")\n    ///                                 .arg(Arg::with_name(\"config_file\").index(1)),\n    ///        SubCommand::with_name(\"debug\").about(\"Controls debug functionality\")])\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`IntoIterator`]: https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\n    pub fn subcommands<I>(mut self, subcmds: I) -> Self\n    where\n        I: IntoIterator<Item = App<'a, 'b>>,\n    {\n        for subcmd in subcmds {\n            self.p.add_subcommand(subcmd);\n        }\n        self\n    }\n\n    /// Allows custom ordering of [`SubCommand`]s within the help message. Subcommands with a lower\n    /// value will be displayed first in the help message. This is helpful when one would like to\n    /// emphasise frequently used subcommands, or prioritize those towards the top of the list.\n    /// Duplicate values **are** allowed. Subcommands with duplicate display orders will be\n    /// displayed in alphabetical order.\n    ///\n    /// **NOTE:** The default is 999 for all subcommands.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, SubCommand};\n    /// let m = App::new(\"cust-ord\")\n    ///     .subcommand(SubCommand::with_name(\"alpha\") // typically subcommands are grouped\n    ///                                                // alphabetically by name. Subcommands\n    ///                                                // without a display_order have a value of\n    ///                                                // 999 and are displayed alphabetically with\n    ///                                                // all other 999 subcommands\n    ///         .about(\"Some help and text\"))\n    ///     .subcommand(SubCommand::with_name(\"beta\")\n    ///         .display_order(1)   // In order to force this subcommand to appear *first*\n    ///                             // all we have to do is give it a value lower than 999.\n    ///                             // Any other subcommands with a value of 1 will be displayed\n    ///                             // alphabetically with this one...then 2 values, then 3, etc.\n    ///         .about(\"I should be first!\"))\n    ///     .get_matches_from(vec![\n    ///         \"cust-ord\", \"--help\"\n    ///     ]);\n    /// ```\n    ///\n    /// The above example displays the following help message\n    ///\n    /// ```text\n    /// cust-ord\n    ///\n    /// USAGE:\n    ///     cust-ord [FLAGS] [OPTIONS]\n    ///\n    /// FLAGS:\n    ///     -h, --help       Prints help information\n    ///     -V, --version    Prints version information\n    ///\n    /// SUBCOMMANDS:\n    ///     beta    I should be first!\n    ///     alpha   Some help and text\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    pub fn display_order(mut self, ord: usize) -> Self {\n        self.p.meta.disp_ord = ord;\n        self\n    }\n\n    /// Prints the full help message to [`io::stdout()`] using a [`BufWriter`] using the same\n    /// method as if someone ran `-h` to request the help message\n    ///\n    /// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" help messages\n    /// depending on if the user ran [`-h` (short)] or [`--help` (long)]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::App;\n    /// let mut app = App::new(\"myprog\");\n    /// app.print_help();\n    /// ```\n    /// [`io::stdout()`]: https://doc.rust-lang.org/std/io/fn.stdout.html\n    /// [`BufWriter`]: https://doc.rust-lang.org/std/io/struct.BufWriter.html\n    /// [`-h` (short)]: ./struct.Arg.html#method.help\n    /// [`--help` (long)]: ./struct.Arg.html#method.long_help\n    pub fn print_help(&mut self) -> ClapResult<()> {\n        // If there are global arguments, or settings we need to propagate them down to subcommands\n        // before parsing incase we run into a subcommand\n        self.p.propagate_globals();\n        self.p.propagate_settings();\n        self.p.derive_display_order();\n\n        self.p.create_help_and_version();\n        let out = io::stdout();\n        let mut buf_w = BufWriter::new(out.lock());\n        self.write_help(&mut buf_w)\n    }\n\n    /// Prints the full help message to [`io::stdout()`] using a [`BufWriter`] using the same\n    /// method as if someone ran `--help` to request the help message\n    ///\n    /// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" help messages\n    /// depending on if the user ran [`-h` (short)] or [`--help` (long)]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::App;\n    /// let mut app = App::new(\"myprog\");\n    /// app.print_long_help();\n    /// ```\n    /// [`io::stdout()`]: https://doc.rust-lang.org/std/io/fn.stdout.html\n    /// [`BufWriter`]: https://doc.rust-lang.org/std/io/struct.BufWriter.html\n    /// [`-h` (short)]: ./struct.Arg.html#method.help\n    /// [`--help` (long)]: ./struct.Arg.html#method.long_help\n    pub fn print_long_help(&mut self) -> ClapResult<()> {\n        let out = io::stdout();\n        let mut buf_w = BufWriter::new(out.lock());\n        self.write_long_help(&mut buf_w)\n    }\n\n    /// Writes the full help message to the user to a [`io::Write`] object in the same method as if\n    /// the user ran `-h`\n    ///\n    /// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" help messages\n    /// depending on if the user ran [`-h` (short)] or [`--help` (long)]\n    ///\n    /// **NOTE:** There is a known bug where this method does not write propagated global arguments\n    /// or autogenerated arguments (i.e. the default help/version args). Prefer\n    /// [`App::write_long_help`] instead if possible!\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::App;\n    /// use std::io;\n    /// let mut app = App::new(\"myprog\");\n    /// let mut out = io::stdout();\n    /// app.write_help(&mut out).expect(\"failed to write to stdout\");\n    /// ```\n    /// [`io::Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n    /// [`-h` (short)]: ./struct.Arg.html#method.help\n    /// [`--help` (long)]: ./struct.Arg.html#method.long_help\n    pub fn write_help<W: Write>(&self, w: &mut W) -> ClapResult<()> {\n        // PENDING ISSUE: 808\n        //      https://github.com/clap-rs/clap/issues/808\n        // If there are global arguments, or settings we need to propagate them down to subcommands\n        // before parsing incase we run into a subcommand\n        // self.p.propagate_globals();\n        // self.p.propagate_settings();\n        // self.p.derive_display_order();\n        // self.p.create_help_and_version();\n\n        Help::write_app_help(w, self, false)\n    }\n\n    /// Writes the full help message to the user to a [`io::Write`] object in the same method as if\n    /// the user ran `--help`\n    ///\n    /// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" help messages\n    /// depending on if the user ran [`-h` (short)] or [`--help` (long)]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::App;\n    /// use std::io;\n    /// let mut app = App::new(\"myprog\");\n    /// let mut out = io::stdout();\n    /// app.write_long_help(&mut out).expect(\"failed to write to stdout\");\n    /// ```\n    /// [`io::Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n    /// [`-h` (short)]: ./struct.Arg.html#method.help\n    /// [`--help` (long)]: ./struct.Arg.html#method.long_help\n    pub fn write_long_help<W: Write>(&mut self, w: &mut W) -> ClapResult<()> {\n        // If there are global arguments, or settings we need to propagate them down to subcommands\n        // before parsing incase we run into a subcommand\n        self.p.propagate_globals();\n        self.p.propagate_settings();\n        self.p.derive_display_order();\n        self.p.create_help_and_version();\n\n        Help::write_app_help(w, self, true)\n    }\n\n    /// Writes the version message to the user to a [`io::Write`] object as if the user ran `-V`.\n    ///\n    /// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" version messages\n    /// depending on if the user ran [`-V` (short)] or [`--version` (long)]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::App;\n    /// use std::io;\n    /// let mut app = App::new(\"myprog\");\n    /// let mut out = io::stdout();\n    /// app.write_version(&mut out).expect(\"failed to write to stdout\");\n    /// ```\n    /// [`io::Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n    /// [`-V` (short)]: ./struct.App.html#method.version\n    /// [`--version` (long)]: ./struct.App.html#method.long_version\n    pub fn write_version<W: Write>(&self, w: &mut W) -> ClapResult<()> {\n        self.p.write_version(w, false).map_err(From::from)\n    }\n\n    /// Writes the version message to the user to a [`io::Write`] object\n    ///\n    /// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" version messages\n    /// depending on if the user ran [`-V` (short)] or [`--version` (long)]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::App;\n    /// use std::io;\n    /// let mut app = App::new(\"myprog\");\n    /// let mut out = io::stdout();\n    /// app.write_long_version(&mut out).expect(\"failed to write to stdout\");\n    /// ```\n    /// [`io::Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n    /// [`-V` (short)]: ./struct.App.html#method.version\n    /// [`--version` (long)]: ./struct.App.html#method.long_version\n    pub fn write_long_version<W: Write>(&self, w: &mut W) -> ClapResult<()> {\n        self.p.write_version(w, true).map_err(From::from)\n    }\n\n    /// Generate a completions file for a specified shell at compile time.\n    ///\n    /// **NOTE:** to generate the file at compile time you must use a `build.rs` \"Build Script\"\n    ///\n    /// # Examples\n    ///\n    /// The following example generates a bash completion script via a `build.rs` script. In this\n    /// simple example, we'll demo a very small application with only a single subcommand and two\n    /// args. Real applications could be many multiple levels deep in subcommands, and have tens or\n    /// potentially hundreds of arguments.\n    ///\n    /// First, it helps if we separate out our `App` definition into a separate file. Whether you\n    /// do this as a function, or bare App definition is a matter of personal preference.\n    ///\n    /// ```\n    /// // src/cli.rs\n    ///\n    /// use clap::{App, Arg, SubCommand};\n    ///\n    /// pub fn build_cli() -> App<'static, 'static> {\n    ///     App::new(\"compl\")\n    ///         .about(\"Tests completions\")\n    ///         .arg(Arg::with_name(\"file\")\n    ///             .help(\"some input file\"))\n    ///         .subcommand(SubCommand::with_name(\"test\")\n    ///             .about(\"tests things\")\n    ///             .arg(Arg::with_name(\"case\")\n    ///                 .long(\"case\")\n    ///                 .takes_value(true)\n    ///                 .help(\"the case to test\")))\n    /// }\n    /// ```\n    ///\n    /// In our regular code, we can simply call this `build_cli()` function, then call\n    /// `get_matches()`, or any of the other normal methods directly after. For example:\n    ///\n    /// ```ignore\n    /// // src/main.rs\n    ///\n    /// mod cli;\n    ///\n    /// fn main() {\n    ///     let m = cli::build_cli().get_matches();\n    ///\n    ///     // normal logic continues...\n    /// }\n    /// ```\n    ///\n    /// Next, we set up our `Cargo.toml` to use a `build.rs` build script.\n    ///\n    /// ```toml\n    /// # Cargo.toml\n    /// build = \"build.rs\"\n    ///\n    /// [build-dependencies]\n    /// clap = \"2.23\"\n    /// ```\n    ///\n    /// Next, we place a `build.rs` in our project root.\n    ///\n    /// ```ignore\n    /// extern crate clap;\n    ///\n    /// use clap::Shell;\n    ///\n    /// include!(\"src/cli.rs\");\n    ///\n    /// fn main() {\n    ///     let outdir = match env::var_os(\"OUT_DIR\") {\n    ///         None => return,\n    ///         Some(outdir) => outdir,\n    ///     };\n    ///     let mut app = build_cli();\n    ///     app.gen_completions(\"myapp\",      // We need to specify the bin name manually\n    ///                         Shell::Bash,  // Then say which shell to build completions for\n    ///                         outdir);      // Then say where write the completions to\n    /// }\n    /// ```\n    /// Now, once we compile there will be a `{bin_name}.bash` file in the directory.\n    /// Assuming we compiled with debug mode, it would be somewhere similar to\n    /// `<project>/target/debug/build/myapp-<hash>/out/myapp.bash`.\n    ///\n    /// Fish shell completions will use the file format `{bin_name}.fish`\n    pub fn gen_completions<T: Into<OsString>, S: Into<String>>(\n        &mut self,\n        bin_name: S,\n        for_shell: Shell,\n        out_dir: T,\n    ) {\n        self.p.meta.bin_name = Some(bin_name.into());\n        self.p.gen_completions(for_shell, out_dir.into());\n    }\n\n    /// Generate a completions file for a specified shell at runtime.  Until `cargo install` can\n    /// install extra files like a completion script, this may be used e.g. in a command that\n    /// outputs the contents of the completion script, to be redirected into a file by the user.\n    ///\n    /// # Examples\n    ///\n    /// Assuming a separate `cli.rs` like the [example above](./struct.App.html#method.gen_completions),\n    /// we can let users generate a completion script using a command:\n    ///\n    /// ```ignore\n    /// // src/main.rs\n    ///\n    /// mod cli;\n    /// use std::io;\n    ///\n    /// fn main() {\n    ///     let matches = cli::build_cli().get_matches();\n    ///\n    ///     if matches.is_present(\"generate-bash-completions\") {\n    ///         cli::build_cli().gen_completions_to(\"myapp\", Shell::Bash, &mut io::stdout());\n    ///     }\n    ///\n    ///     // normal logic continues...\n    /// }\n    ///\n    /// ```\n    ///\n    /// Usage:\n    ///\n    /// ```shell\n    /// $ myapp generate-bash-completions > /usr/share/bash-completion/completions/myapp.bash\n    /// ```\n    pub fn gen_completions_to<W: Write, S: Into<String>>(\n        &mut self,\n        bin_name: S,\n        for_shell: Shell,\n        buf: &mut W,\n    ) {\n        self.p.meta.bin_name = Some(bin_name.into());\n        self.p.gen_completions_to(for_shell, buf);\n    }\n\n    /// Starts the parsing process, upon a failed parse an error will be displayed to the user and\n    /// the process will exit with the appropriate error code. By default this method gets all user\n    /// provided arguments from [`env::args_os`] in order to allow for invalid UTF-8 code points,\n    /// which are legal on many platforms.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// let matches = App::new(\"myprog\")\n    ///     // Args and options go here...\n    ///     .get_matches();\n    /// ```\n    /// [`env::args_os`]: https://doc.rust-lang.org/std/env/fn.args_os.html\n    pub fn get_matches(self) -> ArgMatches<'a> {\n        self.get_matches_from(&mut env::args_os())\n    }\n\n    /// Starts the parsing process. This method will return a [`clap::Result`] type instead of exiting\n    /// the process on failed parse. By default this method gets matches from [`env::args_os`]\n    ///\n    /// **NOTE:** This method WILL NOT exit when `--help` or `--version` (or short versions) are\n    /// used. It will return a [`clap::Error`], where the [`kind`] is a\n    /// [`ErrorKind::HelpDisplayed`] or [`ErrorKind::VersionDisplayed`] respectively. You must call\n    /// [`Error::exit`] or perform a [`std::process::exit`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// let matches = App::new(\"myprog\")\n    ///     // Args and options go here...\n    ///     .get_matches_safe()\n    ///     .unwrap_or_else( |e| e.exit() );\n    /// ```\n    /// [`env::args_os`]: https://doc.rust-lang.org/std/env/fn.args_os.html\n    /// [`ErrorKind::HelpDisplayed`]: ./enum.ErrorKind.html#variant.HelpDisplayed\n    /// [`ErrorKind::VersionDisplayed`]: ./enum.ErrorKind.html#variant.VersionDisplayed\n    /// [`Error::exit`]: ./struct.Error.html#method.exit\n    /// [`std::process::exit`]: https://doc.rust-lang.org/std/process/fn.exit.html\n    /// [`clap::Result`]: ./type.Result.html\n    /// [`clap::Error`]: ./struct.Error.html\n    /// [`kind`]: ./struct.Error.html\n    pub fn get_matches_safe(self) -> ClapResult<ArgMatches<'a>> {\n        // Start the parsing\n        self.get_matches_from_safe(&mut env::args_os())\n    }\n\n    /// Starts the parsing process. Like [`App::get_matches`] this method does not return a [`clap::Result`]\n    /// and will automatically exit with an error message. This method, however, lets you specify\n    /// what iterator to use when performing matches, such as a [`Vec`] of your making.\n    ///\n    /// **NOTE:** The first argument will be parsed as the binary name unless\n    /// [`AppSettings::NoBinaryName`] is used\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// let arg_vec = vec![\"my_prog\", \"some\", \"args\", \"to\", \"parse\"];\n    ///\n    /// let matches = App::new(\"myprog\")\n    ///     // Args and options go here...\n    ///     .get_matches_from(arg_vec);\n    /// ```\n    /// [`App::get_matches`]: ./struct.App.html#method.get_matches\n    /// [`clap::Result`]: ./type.Result.html\n    /// [`Vec`]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n    /// [`AppSettings::NoBinaryName`]: ./enum.AppSettings.html#variant.NoBinaryName\n    pub fn get_matches_from<I, T>(mut self, itr: I) -> ArgMatches<'a>\n    where\n        I: IntoIterator<Item = T>,\n        T: Into<OsString> + Clone,\n    {\n        self.get_matches_from_safe_borrow(itr).unwrap_or_else(|e| {\n            // Otherwise, write to stderr and exit\n            if e.use_stderr() {\n                wlnerr!(\"{}\", e.message);\n                if self.p.is_set(AppSettings::WaitOnError) {\n                    wlnerr!(\"\\nPress [ENTER] / [RETURN] to continue...\");\n                    let mut s = String::new();\n                    let i = io::stdin();\n                    i.lock().read_line(&mut s).unwrap();\n                }\n                drop(self);\n                drop(e);\n                process::exit(1);\n            }\n\n            drop(self);\n            e.exit()\n        })\n    }\n\n    /// Starts the parsing process. A combination of [`App::get_matches_from`], and\n    /// [`App::get_matches_safe`]\n    ///\n    /// **NOTE:** This method WILL NOT exit when `--help` or `--version` (or short versions) are\n    /// used. It will return a [`clap::Error`], where the [`kind`] is a [`ErrorKind::HelpDisplayed`]\n    /// or [`ErrorKind::VersionDisplayed`] respectively. You must call [`Error::exit`] or\n    /// perform a [`std::process::exit`] yourself.\n    ///\n    /// **NOTE:** The first argument will be parsed as the binary name unless\n    /// [`AppSettings::NoBinaryName`] is used\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// let arg_vec = vec![\"my_prog\", \"some\", \"args\", \"to\", \"parse\"];\n    ///\n    /// let matches = App::new(\"myprog\")\n    ///     // Args and options go here...\n    ///     .get_matches_from_safe(arg_vec)\n    ///     .unwrap_or_else( |e| { panic!(\"An error occurs: {}\", e) });\n    /// ```\n    /// [`App::get_matches_from`]: ./struct.App.html#method.get_matches_from\n    /// [`App::get_matches_safe`]: ./struct.App.html#method.get_matches_safe\n    /// [`ErrorKind::HelpDisplayed`]: ./enum.ErrorKind.html#variant.HelpDisplayed\n    /// [`ErrorKind::VersionDisplayed`]: ./enum.ErrorKind.html#variant.VersionDisplayed\n    /// [`Error::exit`]: ./struct.Error.html#method.exit\n    /// [`std::process::exit`]: https://doc.rust-lang.org/std/process/fn.exit.html\n    /// [`clap::Error`]: ./struct.Error.html\n    /// [`Error::exit`]: ./struct.Error.html#method.exit\n    /// [`kind`]: ./struct.Error.html\n    /// [`AppSettings::NoBinaryName`]: ./enum.AppSettings.html#variant.NoBinaryName\n    pub fn get_matches_from_safe<I, T>(mut self, itr: I) -> ClapResult<ArgMatches<'a>>\n    where\n        I: IntoIterator<Item = T>,\n        T: Into<OsString> + Clone,\n    {\n        self.get_matches_from_safe_borrow(itr)\n    }\n\n    /// Starts the parsing process without consuming the [`App`] struct `self`. This is normally not\n    /// the desired functionality, instead prefer [`App::get_matches_from_safe`] which *does*\n    /// consume `self`.\n    ///\n    /// **NOTE:** The first argument will be parsed as the binary name unless\n    /// [`AppSettings::NoBinaryName`] is used\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg};\n    /// let arg_vec = vec![\"my_prog\", \"some\", \"args\", \"to\", \"parse\"];\n    ///\n    /// let mut app = App::new(\"myprog\");\n    ///     // Args and options go here...\n    /// let matches = app.get_matches_from_safe_borrow(arg_vec)\n    ///     .unwrap_or_else( |e| { panic!(\"An error occurs: {}\", e) });\n    /// ```\n    /// [`App`]: ./struct.App.html\n    /// [`App::get_matches_from_safe`]: ./struct.App.html#method.get_matches_from_safe\n    /// [`AppSettings::NoBinaryName`]: ./enum.AppSettings.html#variant.NoBinaryName\n    pub fn get_matches_from_safe_borrow<I, T>(&mut self, itr: I) -> ClapResult<ArgMatches<'a>>\n    where\n        I: IntoIterator<Item = T>,\n        T: Into<OsString> + Clone,\n    {\n        // If there are global arguments, or settings we need to propagate them down to subcommands\n        // before parsing incase we run into a subcommand\n        if !self.p.is_set(AppSettings::Propagated) {\n            self.p.propagate_globals();\n            self.p.propagate_settings();\n            self.p.derive_display_order();\n            self.p.set(AppSettings::Propagated);\n        }\n\n        let mut matcher = ArgMatcher::new();\n\n        let mut it = itr.into_iter();\n        // Get the name of the program (argument 1 of env::args()) and determine the\n        // actual file\n        // that was used to execute the program. This is because a program called\n        // ./target/release/my_prog -a\n        // will have two arguments, './target/release/my_prog', '-a' but we don't want\n        // to display\n        // the full path when displaying help messages and such\n        if !self.p.is_set(AppSettings::NoBinaryName) {\n            if let Some(name) = it.next() {\n                let bn_os = name.into();\n                let p = Path::new(&*bn_os);\n                if let Some(f) = p.file_name() {\n                    if let Some(s) = f.to_os_string().to_str() {\n                        if self.p.meta.bin_name.is_none() {\n                            self.p.meta.bin_name = Some(s.to_owned());\n                        }\n                    }\n                }\n            }\n        }\n\n        // do the real parsing\n        if let Err(e) = self.p.get_matches_with(&mut matcher, &mut it.peekable()) {\n            return Err(e);\n        }\n\n        let global_arg_vec: Vec<&str> = (&self).p.global_args.iter().map(|ga| ga.b.name).collect();\n        matcher.propagate_globals(&global_arg_vec);\n\n        Ok(matcher.into())\n    }\n}","impl<'a, 'b> Clone for App<'a, 'b> {\n    fn clone(&self) -> Self {\n        App { p: self.p.clone() }\n    }\n}","impl<'b, 'c> DispOrder for App<'b, 'c> {\n    fn disp_ord(&self) -> usize {\n        999\n    }\n}","impl<'n, 'e> AnyArg<'n, 'e> for App<'n, 'e> {\n    fn name(&self) -> &'n str {\n        \"\"\n    }\n    fn overrides(&self) -> Option<&[&'e str]> {\n        None\n    }\n    fn requires(&self) -> Option<&[(Option<&'e str>, &'n str)]> {\n        None\n    }\n    fn blacklist(&self) -> Option<&[&'e str]> {\n        None\n    }\n    fn required_unless(&self) -> Option<&[&'e str]> {\n        None\n    }\n    fn val_names(&self) -> Option<&VecMap<&'e str>> {\n        None\n    }\n    fn is_set(&self, _: ArgSettings) -> bool {\n        false\n    }\n    fn val_terminator(&self) -> Option<&'e str> {\n        None\n    }\n    fn set(&mut self, _: ArgSettings) {\n        unreachable!(\"App struct does not support AnyArg::set, this is a bug!\")\n    }\n    fn has_switch(&self) -> bool {\n        false\n    }\n    fn max_vals(&self) -> Option<u64> {\n        None\n    }\n    fn num_vals(&self) -> Option<u64> {\n        None\n    }\n    fn possible_vals(&self) -> Option<&[&'e str]> {\n        None\n    }\n    fn validator(&self) -> Option<&Rc<Fn(String) -> StdResult<(), String>>> {\n        None\n    }\n    fn validator_os(&self) -> Option<&Rc<Fn(&OsStr) -> StdResult<(), OsString>>> {\n        None\n    }\n    fn min_vals(&self) -> Option<u64> {\n        None\n    }\n    fn short(&self) -> Option<char> {\n        None\n    }\n    fn long(&self) -> Option<&'e str> {\n        None\n    }\n    fn val_delim(&self) -> Option<char> {\n        None\n    }\n    fn takes_value(&self) -> bool {\n        true\n    }\n    fn help(&self) -> Option<&'e str> {\n        self.p.meta.about\n    }\n    fn long_help(&self) -> Option<&'e str> {\n        self.p.meta.long_about\n    }\n    fn default_val(&self) -> Option<&'e OsStr> {\n        None\n    }\n    fn default_vals_ifs(&self) -> Option<map::Values<(&'n str, Option<&'e OsStr>, &'e OsStr)>> {\n        None\n    }\n    fn env<'s>(&'s self) -> Option<(&'n OsStr, Option<&'s OsString>)> {\n        None\n    }\n    fn longest_filter(&self) -> bool {\n        true\n    }\n    fn aliases(&self) -> Option<Vec<&'e str>> {\n        if let Some(ref aliases) = self.p.meta.aliases {\n            let vis_aliases: Vec<_> = aliases\n                .iter()\n                .filter_map(|&(n, v)| if v { Some(n) } else { None })\n                .collect();\n            if vis_aliases.is_empty() {\n                None\n            } else {\n                Some(vis_aliases)\n            }\n        } else {\n            None\n        }\n    }\n}","impl<'n, 'e> fmt::Display for App<'n, 'e> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.p.meta.name)\n    }\n}"],"app::help::Help":["impl<'a> Help<'a> {\n    /// Create a new `Help` instance.\n    #[cfg_attr(feature = \"cargo-clippy\", allow(too_many_arguments))]\n    pub fn new(\n        w: &'a mut Write,\n        next_line_help: bool,\n        hide_pv: bool,\n        color: bool,\n        cizer: Colorizer,\n        term_w: Option<usize>,\n        max_w: Option<usize>,\n        use_long: bool,\n    ) -> Self {\n        debugln!(\"Help::new;\");\n        Help {\n            writer: w,\n            next_line_help: next_line_help,\n            hide_pv: hide_pv,\n            term_w: match term_w {\n                Some(width) => {\n                    if width == 0 {\n                        usize::MAX\n                    } else {\n                        width\n                    }\n                }\n                None => cmp::min(\n                    term_size::dimensions().map_or(120, |(w, _)| w),\n                    match max_w {\n                        None | Some(0) => usize::MAX,\n                        Some(mw) => mw,\n                    },\n                ),\n            },\n            color: color,\n            cizer: cizer,\n            longest: 0,\n            force_next_line: false,\n            use_long: use_long,\n        }\n    }\n\n    /// Reads help settings from an App\n    /// and write its help to the wrapped stream.\n    pub fn write_app_help(w: &'a mut Write, app: &App, use_long: bool) -> ClapResult<()> {\n        debugln!(\"Help::write_app_help;\");\n        Self::write_parser_help(w, &app.p, use_long)\n    }\n\n    /// Reads help settings from a Parser\n    /// and write its help to the wrapped stream.\n    pub fn write_parser_help(w: &'a mut Write, parser: &Parser, use_long: bool) -> ClapResult<()> {\n        debugln!(\"Help::write_parser_help;\");\n        Self::_write_parser_help(w, parser, false, use_long)\n    }\n\n    /// Reads help settings from a Parser\n    /// and write its help to the wrapped stream which will be stderr. This method prevents\n    /// formatting when required.\n    pub fn write_parser_help_to_stderr(w: &'a mut Write, parser: &Parser) -> ClapResult<()> {\n        debugln!(\"Help::write_parser_help;\");\n        Self::_write_parser_help(w, parser, true, false)\n    }\n\n    #[doc(hidden)]\n    pub fn _write_parser_help(\n        w: &'a mut Write,\n        parser: &Parser,\n        stderr: bool,\n        use_long: bool,\n    ) -> ClapResult<()> {\n        debugln!(\"Help::write_parser_help;\");\n        let nlh = parser.is_set(AppSettings::NextLineHelp);\n        let hide_v = parser.is_set(AppSettings::HidePossibleValuesInHelp);\n        let color = parser.is_set(AppSettings::ColoredHelp);\n        let cizer = Colorizer::new(ColorizerOption {\n            use_stderr: stderr,\n            when: parser.color(),\n        });\n        Self::new(\n            w,\n            nlh,\n            hide_v,\n            color,\n            cizer,\n            parser.meta.term_w,\n            parser.meta.max_w,\n            use_long,\n        )\n        .write_help(parser)\n    }\n\n    /// Writes the parser help to the wrapped stream.\n    pub fn write_help(&mut self, parser: &Parser) -> ClapResult<()> {\n        debugln!(\"Help::write_help;\");\n        if let Some(h) = parser.meta.help_str {\n            write!(self.writer, \"{}\", h).map_err(Error::from)?;\n        } else if let Some(tmpl) = parser.meta.template {\n            self.write_templated_help(parser, tmpl)?;\n        } else {\n            self.write_default_help(parser)?;\n        }\n        Ok(())\n    }\n}","impl<'a> Help<'a> {\n    /// Write help to stream for the parser in the format defined by the template.\n    ///\n    /// Tags arg given inside curly brackets:\n    /// Valid tags are:\n    ///     * `{bin}`         - Binary name.\n    ///     * `{version}`     - Version number.\n    ///     * `{author}`      - Author information.\n    ///     * `{usage}`       - Automatically generated or given usage string.\n    ///     * `{all-args}`    - Help for all arguments (options, flags, positionals arguments,\n    ///                         and subcommands) including titles.\n    ///     * `{unified}`     - Unified help for options and flags.\n    ///     * `{flags}`       - Help for flags.\n    ///     * `{options}`     - Help for options.\n    ///     * `{positionals}` - Help for positionals arguments.\n    ///     * `{subcommands}` - Help for subcommands.\n    ///     * `{after-help}`  - Info to be displayed after the help message.\n    ///     * `{before-help}` - Info to be displayed before the help message.\n    ///\n    /// The template system is, on purpose, very simple. Therefore the tags have to written\n    /// in the lowercase and without spacing.\n    fn write_templated_help(&mut self, parser: &Parser, template: &str) -> ClapResult<()> {\n        debugln!(\"Help::write_templated_help;\");\n        let mut tmplr = Cursor::new(&template);\n        let mut tag_buf = Cursor::new(vec![0u8; 15]);\n\n        // The strategy is to copy the template from the reader to wrapped stream\n        // until a tag is found. Depending on its value, the appropriate content is copied\n        // to the wrapped stream.\n        // The copy from template is then resumed, repeating this sequence until reading\n        // the complete template.\n\n        loop {\n            let tag_length = match copy_and_capture(&mut tmplr, &mut self.writer, &mut tag_buf) {\n                None => return Ok(()),\n                Some(Err(e)) => return Err(Error::from(e)),\n                Some(Ok(val)) if val > 0 => val,\n                _ => continue,\n            };\n\n            debugln!(\"Help::write_template_help:iter: tag_buf={};\", unsafe {\n                String::from_utf8_unchecked(\n                    tag_buf.get_ref()[0..tag_length]\n                        .iter()\n                        .map(|&i| i)\n                        .collect::<Vec<_>>(),\n                )\n            });\n            match &tag_buf.get_ref()[0..tag_length] {\n                b\"?\" => {\n                    self.writer.write_all(b\"Could not decode tag name\")?;\n                }\n                b\"bin\" => {\n                    self.write_bin_name(parser)?;\n                }\n                b\"version\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.version.unwrap_or(\"unknown version\")\n                    )?;\n                }\n                b\"author\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.author.unwrap_or(\"unknown author\")\n                    )?;\n                }\n                b\"about\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.about.unwrap_or(\"unknown about\")\n                    )?;\n                }\n                b\"long-about\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.long_about.unwrap_or(\"unknown about\")\n                    )?;\n                }\n                b\"usage\" => {\n                    write!(self.writer, \"{}\", usage::create_usage_no_title(parser, &[]))?;\n                }\n                b\"all-args\" => {\n                    self.write_all_args(parser)?;\n                }\n                b\"unified\" => {\n                    let opts_flags = parser\n                        .flags()\n                        .map(as_arg_trait)\n                        .chain(parser.opts().map(as_arg_trait));\n                    self.write_args(opts_flags)?;\n                }\n                b\"flags\" => {\n                    self.write_args(parser.flags().map(as_arg_trait))?;\n                }\n                b\"options\" => {\n                    self.write_args(parser.opts().map(as_arg_trait))?;\n                }\n                b\"positionals\" => {\n                    self.write_args(parser.positionals().map(as_arg_trait))?;\n                }\n                b\"subcommands\" => {\n                    self.write_subcommands(parser)?;\n                }\n                b\"after-help\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.more_help.unwrap_or(\"unknown after-help\")\n                    )?;\n                }\n                b\"before-help\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.pre_help.unwrap_or(\"unknown before-help\")\n                    )?;\n                }\n                // Unknown tag, write it back.\n                r => {\n                    self.writer.write_all(b\"{\")?;\n                    self.writer.write_all(r)?;\n                    self.writer.write_all(b\"}\")?;\n                }\n            }\n        }\n    }\n}","impl<'a> Help<'a> {\n    /// Writes help for all arguments (options, flags, args, subcommands)\n    /// including titles of a Parser Object to the wrapped stream.\n    #[cfg_attr(feature = \"lints\", allow(useless_let_if_seq))]\n    #[cfg_attr(feature = \"cargo-clippy\", allow(useless_let_if_seq))]\n    pub fn write_all_args(&mut self, parser: &Parser) -> ClapResult<()> {\n        debugln!(\"Help::write_all_args;\");\n        let flags = parser.has_flags();\n        let pos = parser\n            .positionals()\n            .filter(|arg| !arg.is_set(ArgSettings::Hidden))\n            .count()\n            > 0;\n        let opts = parser.has_opts();\n        let subcmds = parser.has_visible_subcommands();\n\n        let unified_help = parser.is_set(AppSettings::UnifiedHelpMessage);\n\n        let mut first = true;\n\n        if unified_help && (flags || opts) {\n            let opts_flags = parser\n                .flags()\n                .map(as_arg_trait)\n                .chain(parser.opts().map(as_arg_trait));\n            color!(self, \"OPTIONS:\\n\", warning)?;\n            self.write_args(opts_flags)?;\n            first = false;\n        } else {\n            if flags {\n                color!(self, \"FLAGS:\\n\", warning)?;\n                self.write_args(parser.flags().map(as_arg_trait))?;\n                first = false;\n            }\n            if opts {\n                if !first {\n                    self.writer.write_all(b\"\\n\\n\")?;\n                }\n                color!(self, \"OPTIONS:\\n\", warning)?;\n                self.write_args(parser.opts().map(as_arg_trait))?;\n                first = false;\n            }\n        }\n\n        if pos {\n            if !first {\n                self.writer.write_all(b\"\\n\\n\")?;\n            }\n            color!(self, \"ARGS:\\n\", warning)?;\n            self.write_args_unsorted(parser.positionals().map(as_arg_trait))?;\n            first = false;\n        }\n\n        if subcmds {\n            if !first {\n                self.writer.write_all(b\"\\n\\n\")?;\n            }\n            color!(self, \"SUBCOMMANDS:\\n\", warning)?;\n            self.write_subcommands(parser)?;\n        }\n\n        Ok(())\n    }\n\n    /// Writes help for subcommands of a Parser Object to the wrapped stream.\n    fn write_subcommands(&mut self, parser: &Parser) -> io::Result<()> {\n        debugln!(\"Help::write_subcommands;\");\n        // The shortest an arg can legally be is 2 (i.e. '-x')\n        self.longest = 2;\n        let mut ord_m = VecMap::new();\n        for sc in parser\n            .subcommands\n            .iter()\n            .filter(|s| !s.p.is_set(AppSettings::Hidden))\n        {\n            let btm = ord_m.entry(sc.p.meta.disp_ord).or_insert(BTreeMap::new());\n            self.longest = cmp::max(self.longest, str_width(sc.p.meta.name.as_str()));\n            //self.longest = cmp::max(self.longest, sc.p.meta.name.len());\n            btm.insert(sc.p.meta.name.clone(), sc.clone());\n        }\n\n        let mut first = true;\n        for btm in ord_m.values() {\n            for sc in btm.values() {\n                if first {\n                    first = false;\n                } else {\n                    self.writer.write_all(b\"\\n\")?;\n                }\n                self.write_arg(sc)?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes version of a Parser Object to the wrapped stream.\n    fn write_version(&mut self, parser: &Parser) -> io::Result<()> {\n        debugln!(\"Help::write_version;\");\n        write!(self.writer, \"{}\", parser.meta.version.unwrap_or(\"\"))?;\n        Ok(())\n    }\n\n    /// Writes binary name of a Parser Object to the wrapped stream.\n    fn write_bin_name(&mut self, parser: &Parser) -> io::Result<()> {\n        debugln!(\"Help::write_bin_name;\");\n        macro_rules! write_name {\n            () => {{\n                let mut name = parser.meta.name.clone();\n                name = name.replace(\"{n}\", \"\\n\");\n                color!(self, wrap_help(&name, self.term_w), good)?;\n            }};\n        }\n        if let Some(bn) = parser.meta.bin_name.as_ref() {\n            if bn.contains(' ') {\n                // Incase we're dealing with subcommands i.e. git mv is translated to git-mv\n                color!(self, bn.replace(\" \", \"-\"), good)?\n            } else {\n                write_name!();\n            }\n        } else {\n            write_name!();\n        }\n        Ok(())\n    }\n\n    /// Writes default help for a Parser Object to the wrapped stream.\n    pub fn write_default_help(&mut self, parser: &Parser) -> ClapResult<()> {\n        debugln!(\"Help::write_default_help;\");\n        if let Some(h) = parser.meta.pre_help {\n            self.write_before_after_help(h)?;\n            self.writer.write_all(b\"\\n\\n\")?;\n        }\n\n        macro_rules! write_thing {\n            ($thing:expr) => {{\n                let mut owned_thing = $thing.to_owned();\n                owned_thing = owned_thing.replace(\"{n}\", \"\\n\");\n                write!(self.writer, \"{}\\n\", wrap_help(&owned_thing, self.term_w))?\n            }};\n        }\n        // Print the version\n        self.write_bin_name(parser)?;\n        self.writer.write_all(b\" \")?;\n        self.write_version(parser)?;\n        self.writer.write_all(b\"\\n\")?;\n        if let Some(author) = parser.meta.author {\n            write_thing!(author)\n        }\n        // if self.use_long {\n        //     if let Some(about) = parser.meta.long_about {\n        //         debugln!(\"Help::write_default_help: writing long about\");\n        //         write_thing!(about)\n        //     } else if let Some(about) = parser.meta.about {\n        //         debugln!(\"Help::write_default_help: writing about\");\n        //         write_thing!(about)\n        //     }\n        // } else\n        if let Some(about) = parser.meta.long_about {\n            debugln!(\"Help::write_default_help: writing long about\");\n            write_thing!(about)\n        } else if let Some(about) = parser.meta.about {\n            debugln!(\"Help::write_default_help: writing about\");\n            write_thing!(about)\n        }\n\n        color!(self, \"\\nUSAGE:\", warning)?;\n        write!(\n            self.writer,\n            \"\\n{}{}\\n\\n\",\n            TAB,\n            usage::create_usage_no_title(parser, &[])\n        )?;\n\n        let flags = parser.has_flags();\n        let pos = parser.has_positionals();\n        let opts = parser.has_opts();\n        let subcmds = parser.has_subcommands();\n\n        if flags || opts || pos || subcmds {\n            self.write_all_args(parser)?;\n        }\n\n        if let Some(h) = parser.meta.more_help {\n            if flags || opts || pos || subcmds {\n                self.writer.write_all(b\"\\n\\n\")?;\n            }\n            self.write_before_after_help(h)?;\n        }\n\n        self.writer.flush().map_err(Error::from)\n    }\n}","impl<'a> Help<'a> {\n    /// Writes help for each argument in the order they were declared to the wrapped stream.\n    fn write_args_unsorted<'b: 'd, 'c: 'd, 'd, I: 'd>(&mut self, args: I) -> io::Result<()>\n    where\n        I: Iterator<Item = &'d ArgWithOrder<'b, 'c>>,\n    {\n        debugln!(\"Help::write_args_unsorted;\");\n        // The shortest an arg can legally be is 2 (i.e. '-x')\n        self.longest = 2;\n        let mut arg_v = Vec::with_capacity(10);\n        let use_long = self.use_long;\n        for arg in args.filter(|arg| should_show_arg(use_long, *arg)) {\n            if arg.longest_filter() {\n                self.longest = cmp::max(self.longest, str_width(arg.to_string().as_str()));\n            }\n            arg_v.push(arg)\n        }\n        let mut first = true;\n        for arg in arg_v {\n            if first {\n                first = false;\n            } else {\n                self.writer.write_all(b\"\\n\")?;\n            }\n            self.write_arg(arg.as_base())?;\n        }\n        Ok(())\n    }\n\n    /// Sorts arguments by length and display order and write their help to the wrapped stream.\n    fn write_args<'b: 'd, 'c: 'd, 'd, I: 'd>(&mut self, args: I) -> io::Result<()>\n    where\n        I: Iterator<Item = &'d ArgWithOrder<'b, 'c>>,\n    {\n        debugln!(\"Help::write_args;\");\n        // The shortest an arg can legally be is 2 (i.e. '-x')\n        self.longest = 2;\n        let mut ord_m = VecMap::new();\n        let use_long = self.use_long;\n        // Determine the longest\n        for arg in args.filter(|arg| {\n            // If it's NextLineHelp, but we don't care to compute how long because it may be\n            // NextLineHelp on purpose *because* it's so long and would throw off all other\n            // args alignment\n            should_show_arg(use_long, *arg)\n        }) {\n            if arg.longest_filter() {\n                debugln!(\"Help::write_args: Current Longest...{}\", self.longest);\n                self.longest = cmp::max(self.longest, str_width(arg.to_string().as_str()));\n                debugln!(\"Help::write_args: New Longest...{}\", self.longest);\n            }\n            let btm = ord_m.entry(arg.disp_ord()).or_insert(BTreeMap::new());\n            btm.insert(arg.name(), arg);\n        }\n        let mut first = true;\n        for btm in ord_m.values() {\n            for arg in btm.values() {\n                if first {\n                    first = false;\n                } else {\n                    self.writer.write_all(b\"\\n\")?;\n                }\n                self.write_arg(arg.as_base())?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes help for an argument to the wrapped stream.\n    fn write_arg<'b, 'c>(&mut self, arg: &ArgWithDisplay<'b, 'c>) -> io::Result<()> {\n        debugln!(\"Help::write_arg;\");\n        self.short(arg)?;\n        self.long(arg)?;\n        let spec_vals = self.val(arg)?;\n        self.help(arg, &*spec_vals)?;\n        Ok(())\n    }\n\n    /// Writes argument's short command to the wrapped stream.\n    fn short<'b, 'c>(&mut self, arg: &ArgWithDisplay<'b, 'c>) -> io::Result<()> {\n        debugln!(\"Help::short;\");\n        write!(self.writer, \"{}\", TAB)?;\n        if let Some(s) = arg.short() {\n            color!(self, \"-{}\", s, good)\n        } else if arg.has_switch() {\n            write!(self.writer, \"{}\", TAB)\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Writes argument's long command to the wrapped stream.\n    fn long<'b, 'c>(&mut self, arg: &ArgWithDisplay<'b, 'c>) -> io::Result<()> {\n        debugln!(\"Help::long;\");\n        if !arg.has_switch() {\n            return Ok(());\n        }\n        if arg.takes_value() {\n            if let Some(l) = arg.long() {\n                if arg.short().is_some() {\n                    write!(self.writer, \", \")?;\n                }\n                color!(self, \"--{}\", l, good)?\n            }\n\n            let sep = if arg.is_set(ArgSettings::RequireEquals) {\n                \"=\"\n            } else {\n                \" \"\n            };\n            write!(self.writer, \"{}\", sep)?;\n        } else if let Some(l) = arg.long() {\n            if arg.short().is_some() {\n                write!(self.writer, \", \")?;\n            }\n            color!(self, \"--{}\", l, good)?;\n        }\n        Ok(())\n    }\n\n    /// Writes argument's possible values to the wrapped stream.\n    fn val<'b, 'c>(&mut self, arg: &ArgWithDisplay<'b, 'c>) -> Result<String, io::Error> {\n        debugln!(\"Help::val: arg={}\", arg);\n        if arg.takes_value() {\n            let delim = if arg.is_set(ArgSettings::RequireDelimiter) {\n                arg.val_delim().expect(INTERNAL_ERROR_MSG)\n            } else {\n                ' '\n            };\n            if let Some(vec) = arg.val_names() {\n                let mut it = vec.iter().peekable();\n                while let Some((_, val)) = it.next() {\n                    color!(self, \"<{}>\", val, good)?;\n                    if it.peek().is_some() {\n                        write!(self.writer, \"{}\", delim)?;\n                    }\n                }\n                let num = vec.len();\n                if arg.is_set(ArgSettings::Multiple) && num == 1 {\n                    color!(self, \"...\", good)?;\n                }\n            } else if let Some(num) = arg.num_vals() {\n                let mut it = (0..num).peekable();\n                while let Some(_) = it.next() {\n                    color!(self, \"<{}>\", arg.name(), good)?;\n                    if it.peek().is_some() {\n                        write!(self.writer, \"{}\", delim)?;\n                    }\n                }\n                if arg.is_set(ArgSettings::Multiple) && num == 1 {\n                    color!(self, \"...\", good)?;\n                }\n            } else if arg.has_switch() {\n                color!(self, \"<{}>\", arg.name(), good)?;\n                if arg.is_set(ArgSettings::Multiple) {\n                    color!(self, \"...\", good)?;\n                }\n            } else {\n                color!(self, \"{}\", arg, good)?;\n            }\n        }\n\n        let spec_vals = self.spec_vals(arg);\n        let h = arg.help().unwrap_or(\"\");\n        let h_w = str_width(h) + str_width(&*spec_vals);\n        let nlh = self.next_line_help || arg.is_set(ArgSettings::NextLineHelp);\n        let taken = self.longest + 12;\n        self.force_next_line = !nlh\n            && self.term_w >= taken\n            && (taken as f32 / self.term_w as f32) > 0.40\n            && h_w > (self.term_w - taken);\n\n        debug!(\"Help::val: Has switch...\");\n        if arg.has_switch() {\n            sdebugln!(\"Yes\");\n            debugln!(\"Help::val: force_next_line...{:?}\", self.force_next_line);\n            debugln!(\"Help::val: nlh...{:?}\", nlh);\n            debugln!(\"Help::val: taken...{}\", taken);\n            debugln!(\n                \"Help::val: help_width > (width - taken)...{} > ({} - {})\",\n                h_w,\n                self.term_w,\n                taken\n            );\n            debugln!(\"Help::val: longest...{}\", self.longest);\n            debug!(\"Help::val: next_line...\");\n            if !(nlh || self.force_next_line) {\n                sdebugln!(\"No\");\n                let self_len = str_width(arg.to_string().as_str());\n                // subtract ourself\n                let mut spcs = self.longest - self_len;\n                // Since we're writing spaces from the tab point we first need to know if we\n                // had a long and short, or just short\n                if arg.long().is_some() {\n                    // Only account 4 after the val\n                    spcs += 4;\n                } else {\n                    // Only account for ', --' + 4 after the val\n                    spcs += 8;\n                }\n\n                write_nspaces!(self.writer, spcs);\n            } else {\n                sdebugln!(\"Yes\");\n            }\n        } else if !(nlh || self.force_next_line) {\n            sdebugln!(\"No, and not next_line\");\n            write_nspaces!(\n                self.writer,\n                self.longest + 4 - (str_width(arg.to_string().as_str()))\n            );\n        } else {\n            sdebugln!(\"No\");\n        }\n        Ok(spec_vals)\n    }\n\n    fn write_before_after_help(&mut self, h: &str) -> io::Result<()> {\n        debugln!(\"Help::write_before_after_help;\");\n        let mut help = String::from(h);\n        // determine if our help fits or needs to wrap\n        debugln!(\n            \"Help::write_before_after_help: Term width...{}\",\n            self.term_w\n        );\n        let too_long = str_width(h) >= self.term_w;\n\n        debug!(\"Help::write_before_after_help: Too long...\");\n        if too_long || h.contains(\"{n}\") {\n            sdebugln!(\"Yes\");\n            debugln!(\"Help::write_before_after_help: help: {}\", help);\n            debugln!(\n                \"Help::write_before_after_help: help width: {}\",\n                str_width(&*help)\n            );\n            // Determine how many newlines we need to insert\n            debugln!(\n                \"Help::write_before_after_help: Usable space: {}\",\n                self.term_w\n            );\n            help = wrap_help(&help.replace(\"{n}\", \"\\n\"), self.term_w);\n        } else {\n            sdebugln!(\"No\");\n        }\n        write!(self.writer, \"{}\", help)?;\n        Ok(())\n    }\n\n    /// Writes argument's help to the wrapped stream.\n    fn help<'b, 'c>(&mut self, arg: &ArgWithDisplay<'b, 'c>, spec_vals: &str) -> io::Result<()> {\n        debugln!(\"Help::help;\");\n        let h = if self.use_long && arg.name() != \"\" {\n            arg.long_help().unwrap_or_else(|| arg.help().unwrap_or(\"\"))\n        } else {\n            arg.help().unwrap_or_else(|| arg.long_help().unwrap_or(\"\"))\n        };\n        let mut help = String::from(h) + spec_vals;\n        let nlh = self.next_line_help\n            || arg.is_set(ArgSettings::NextLineHelp)\n            || (self.use_long && arg.name() != \"\");\n        debugln!(\"Help::help: Next Line...{:?}\", nlh);\n\n        let spcs = if nlh || self.force_next_line {\n            12 // \"tab\" * 3\n        } else {\n            self.longest + 12\n        };\n\n        let too_long = spcs + str_width(h) + str_width(&*spec_vals) >= self.term_w;\n\n        // Is help on next line, if so then indent\n        if nlh || self.force_next_line {\n            write!(self.writer, \"\\n{}{}{}\", TAB, TAB, TAB)?;\n        }\n\n        debug!(\"Help::help: Too long...\");\n        if too_long && spcs <= self.term_w || h.contains(\"{n}\") {\n            sdebugln!(\"Yes\");\n            debugln!(\"Help::help: help...{}\", help);\n            debugln!(\"Help::help: help width...{}\", str_width(&*help));\n            // Determine how many newlines we need to insert\n            let avail_chars = self.term_w - spcs;\n            debugln!(\"Help::help: Usable space...{}\", avail_chars);\n            help = wrap_help(&help.replace(\"{n}\", \"\\n\"), avail_chars);\n        } else {\n            sdebugln!(\"No\");\n        }\n        if let Some(part) = help.lines().next() {\n            write!(self.writer, \"{}\", part)?;\n        }\n        for part in help.lines().skip(1) {\n            write!(self.writer, \"\\n\")?;\n            if nlh || self.force_next_line {\n                write!(self.writer, \"{}{}{}\", TAB, TAB, TAB)?;\n            } else if arg.has_switch() {\n                write_nspaces!(self.writer, self.longest + 12);\n            } else {\n                write_nspaces!(self.writer, self.longest + 8);\n            }\n            write!(self.writer, \"{}\", part)?;\n        }\n        if !help.contains('\\n') && (nlh || self.force_next_line) {\n            write!(self.writer, \"\\n\")?;\n        }\n        Ok(())\n    }\n\n    fn spec_vals(&self, a: &ArgWithDisplay) -> String {\n        debugln!(\"Help::spec_vals: a={}\", a);\n        let mut spec_vals = vec![];\n        if let Some(ref env) = a.env() {\n            debugln!(\n                \"Help::spec_vals: Found environment variable...[{:?}:{:?}]\",\n                env.0,\n                env.1\n            );\n            let env_val = if !a.is_set(ArgSettings::HideEnvValues) {\n                format!(\n                    \"={}\",\n                    env.1.map_or(Cow::Borrowed(\"\"), |val| val.to_string_lossy())\n                )\n            } else {\n                String::new()\n            };\n            let env_info = format!(\" [env: {}{}]\", env.0.to_string_lossy(), env_val);\n            spec_vals.push(env_info);\n        }\n        if !a.is_set(ArgSettings::HideDefaultValue) {\n            if let Some(pv) = a.default_val() {\n                debugln!(\"Help::spec_vals: Found default value...[{:?}]\", pv);\n                spec_vals.push(format!(\n                    \" [default: {}]\",\n                    if self.color {\n                        self.cizer.good(pv.to_string_lossy())\n                    } else {\n                        Format::None(pv.to_string_lossy())\n                    }\n                ));\n            }\n        }\n        if let Some(ref aliases) = a.aliases() {\n            debugln!(\"Help::spec_vals: Found aliases...{:?}\", aliases);\n            spec_vals.push(format!(\n                \" [aliases: {}]\",\n                if self.color {\n                    aliases\n                        .iter()\n                        .map(|v| format!(\"{}\", self.cizer.good(v)))\n                        .collect::<Vec<_>>()\n                        .join(\", \")\n                } else {\n                    aliases.join(\", \")\n                }\n            ));\n        }\n        if !self.hide_pv && !a.is_set(ArgSettings::HidePossibleValues) {\n            if let Some(pv) = a.possible_vals() {\n                debugln!(\"Help::spec_vals: Found possible vals...{:?}\", pv);\n                spec_vals.push(if self.color {\n                    format!(\n                        \" [possible values: {}]\",\n                        pv.iter()\n                            .map(|v| format!(\"{}\", self.cizer.good(v)))\n                            .collect::<Vec<_>>()\n                            .join(\", \")\n                    )\n                } else {\n                    format!(\" [possible values: {}]\", pv.join(\", \"))\n                });\n            }\n        }\n        spec_vals.join(\" \")\n    }\n}"],"app::meta::AppMeta":["Clone","Default","impl<'b> AppMeta<'b> {\n    pub fn new() -> Self {\n        Default::default()\n    }\n    pub fn with_name(s: String) -> Self {\n        AppMeta {\n            name: s,\n            disp_ord: 999,\n            ..Default::default()\n        }\n    }\n}"],"app::parser::ParseResult":["Clone","Copy","Debug","PartialEq"],"app::parser::Parser":["Clone","Default","impl<'a, 'b> Parser<'a, 'b>\nwhere\n    'a: 'b,\n{\n    pub fn with_name(n: String) -> Self {\n        Parser {\n            meta: AppMeta::with_name(n),\n            g_settings: AppFlags::zeroed(),\n            cur_idx: Cell::new(0),\n            ..Default::default()\n        }\n    }\n\n    pub fn help_short(&mut self, s: &str) {\n        let c = s\n            .trim_left_matches(|c| c == '-')\n            .chars()\n            .nth(0)\n            .unwrap_or('h');\n        self.help_short = Some(c);\n    }\n\n    pub fn version_short(&mut self, s: &str) {\n        let c = s\n            .trim_left_matches(|c| c == '-')\n            .chars()\n            .nth(0)\n            .unwrap_or('V');\n        self.version_short = Some(c);\n    }\n\n    pub fn gen_completions_to<W: Write>(&mut self, for_shell: Shell, buf: &mut W) {\n        if !self.is_set(AS::Propagated) {\n            self.propagate_help_version();\n            self.build_bin_names();\n            self.propagate_globals();\n            self.propagate_settings();\n            self.set(AS::Propagated);\n        }\n\n        ComplGen::new(self).generate(for_shell, buf)\n    }\n\n    pub fn gen_completions(&mut self, for_shell: Shell, od: OsString) {\n        use std::error::Error;\n\n        let out_dir = PathBuf::from(od);\n        let name = &*self.meta.bin_name.as_ref().unwrap().clone();\n        let file_name = match for_shell {\n            Shell::Bash => format!(\"{}.bash\", name),\n            Shell::Fish => format!(\"{}.fish\", name),\n            Shell::Zsh => format!(\"_{}\", name),\n            Shell::PowerShell => format!(\"_{}.ps1\", name),\n            Shell::Elvish => format!(\"{}.elv\", name),\n        };\n\n        let mut file = match File::create(out_dir.join(file_name)) {\n            Err(why) => panic!(\"couldn't create completion file: {}\", why.description()),\n            Ok(file) => file,\n        };\n        self.gen_completions_to(for_shell, &mut file)\n    }\n\n    #[inline]\n    fn app_debug_asserts(&self) -> bool {\n        assert!(self.verify_positionals());\n        let should_err = self.groups.iter().all(|g| {\n            g.args.iter().all(|arg| {\n                (self.flags.iter().any(|f| &f.b.name == arg)\n                    || self.opts.iter().any(|o| &o.b.name == arg)\n                    || self.positionals.values().any(|p| &p.b.name == arg)\n                    || self.groups.iter().any(|g| &g.name == arg))\n            })\n        });\n        let g = self.groups.iter().find(|g| {\n            g.args.iter().any(|arg| {\n                !(self.flags.iter().any(|f| &f.b.name == arg)\n                    || self.opts.iter().any(|o| &o.b.name == arg)\n                    || self.positionals.values().any(|p| &p.b.name == arg)\n                    || self.groups.iter().any(|g| &g.name == arg))\n            })\n        });\n        assert!(\n            should_err,\n            \"The group '{}' contains the arg '{}' that doesn't actually exist.\",\n            g.unwrap().name,\n            g.unwrap()\n                .args\n                .iter()\n                .find(|arg| !(self.flags.iter().any(|f| &&f.b.name == arg)\n                    || self.opts.iter().any(|o| &&o.b.name == arg)\n                    || self.positionals.values().any(|p| &&p.b.name == arg)\n                    || self.groups.iter().any(|g| &&g.name == arg)))\n                .unwrap()\n        );\n        true\n    }\n\n    #[inline]\n    fn debug_asserts(&self, a: &Arg) -> bool {\n        assert!(\n            !arg_names!(self).any(|name| name == a.b.name),\n            format!(\"Non-unique argument name: {} is already in use\", a.b.name)\n        );\n        if let Some(l) = a.s.long {\n            assert!(\n                !self.contains_long(l),\n                \"Argument long must be unique\\n\\n\\t--{} is already in use\",\n                l\n            );\n        }\n        if let Some(s) = a.s.short {\n            assert!(\n                !self.contains_short(s),\n                \"Argument short must be unique\\n\\n\\t-{} is already in use\",\n                s\n            );\n        }\n        let i = if a.index.is_none() {\n            (self.positionals.len() + 1)\n        } else {\n            a.index.unwrap() as usize\n        };\n        assert!(\n            !self.positionals.contains_key(i),\n            \"Argument \\\"{}\\\" has the same index as another positional \\\n             argument\\n\\n\\tPerhaps try .multiple(true) to allow one positional argument \\\n             to take multiple values\",\n            a.b.name\n        );\n        assert!(\n            !(a.is_set(ArgSettings::Required) && a.is_set(ArgSettings::Global)),\n            \"Global arguments cannot be required.\\n\\n\\t'{}' is marked as \\\n             global and required\",\n            a.b.name\n        );\n        if a.b.is_set(ArgSettings::Last) {\n            assert!(\n                !self\n                    .positionals\n                    .values()\n                    .any(|p| p.b.is_set(ArgSettings::Last)),\n                \"Only one positional argument may have last(true) set. Found two.\"\n            );\n            assert!(a.s.long.is_none(),\n                    \"Flags or Options may not have last(true) set. {} has both a long and last(true) set.\",\n                    a.b.name);\n            assert!(a.s.short.is_none(),\n                    \"Flags or Options may not have last(true) set. {} has both a short and last(true) set.\",\n                    a.b.name);\n        }\n        true\n    }\n\n    #[inline]\n    fn add_conditional_reqs(&mut self, a: &Arg<'a, 'b>) {\n        if let Some(ref r_ifs) = a.r_ifs {\n            for &(arg, val) in r_ifs {\n                self.r_ifs.push((arg, val, a.b.name));\n            }\n        }\n    }\n\n    #[inline]\n    fn add_arg_groups(&mut self, a: &Arg<'a, 'b>) {\n        if let Some(ref grps) = a.b.groups {\n            for g in grps {\n                let mut found = false;\n                if let Some(ref mut ag) = self.groups.iter_mut().find(|grp| &grp.name == g) {\n                    ag.args.push(a.b.name);\n                    found = true;\n                }\n                if !found {\n                    let mut ag = ArgGroup::with_name(g);\n                    ag.args.push(a.b.name);\n                    self.groups.push(ag);\n                }\n            }\n        }\n    }\n\n    #[inline]\n    fn add_reqs(&mut self, a: &Arg<'a, 'b>) {\n        if a.is_set(ArgSettings::Required) {\n            // If the arg is required, add all it's requirements to master required list\n            self.required.push(a.b.name);\n            if let Some(ref areqs) = a.b.requires {\n                for name in areqs\n                    .iter()\n                    .filter(|&&(val, _)| val.is_none())\n                    .map(|&(_, name)| name)\n                {\n                    self.required.push(name);\n                }\n            }\n        }\n    }\n\n    #[inline]\n    fn implied_settings(&mut self, a: &Arg<'a, 'b>) {\n        if a.is_set(ArgSettings::Last) {\n            // if an arg has `Last` set, we need to imply DontCollapseArgsInUsage so that args\n            // in the usage string don't get confused or left out.\n            self.set(AS::DontCollapseArgsInUsage);\n            self.set(AS::ContainsLast);\n        }\n        if let Some(l) = a.s.long {\n            if l == \"version\" {\n                self.unset(AS::NeedsLongVersion);\n            } else if l == \"help\" {\n                self.unset(AS::NeedsLongHelp);\n            }\n        }\n    }\n\n    // actually adds the arguments\n    pub fn add_arg(&mut self, a: Arg<'a, 'b>) {\n        // if it's global we have to clone anyways\n        if a.is_set(ArgSettings::Global) {\n            return self.add_arg_ref(&a);\n        }\n        debug_assert!(self.debug_asserts(&a));\n        self.add_conditional_reqs(&a);\n        self.add_arg_groups(&a);\n        self.add_reqs(&a);\n        self.implied_settings(&a);\n        if a.index.is_some() || (a.s.short.is_none() && a.s.long.is_none()) {\n            let i = if a.index.is_none() {\n                (self.positionals.len() + 1)\n            } else {\n                a.index.unwrap() as usize\n            };\n            self.positionals\n                .insert(i, PosBuilder::from_arg(a, i as u64));\n        } else if a.is_set(ArgSettings::TakesValue) {\n            let mut ob = OptBuilder::from(a);\n            ob.s.unified_ord = self.flags.len() + self.opts.len();\n            self.opts.push(ob);\n        } else {\n            let mut fb = FlagBuilder::from(a);\n            fb.s.unified_ord = self.flags.len() + self.opts.len();\n            self.flags.push(fb);\n        }\n    }\n    // actually adds the arguments but from a borrow (which means we have to do some cloning)\n    pub fn add_arg_ref(&mut self, a: &Arg<'a, 'b>) {\n        debug_assert!(self.debug_asserts(a));\n        self.add_conditional_reqs(a);\n        self.add_arg_groups(a);\n        self.add_reqs(a);\n        self.implied_settings(a);\n        if a.index.is_some() || (a.s.short.is_none() && a.s.long.is_none()) {\n            let i = if a.index.is_none() {\n                (self.positionals.len() + 1)\n            } else {\n                a.index.unwrap() as usize\n            };\n            let pb = PosBuilder::from_arg_ref(a, i as u64);\n            self.positionals.insert(i, pb);\n        } else if a.is_set(ArgSettings::TakesValue) {\n            let mut ob = OptBuilder::from(a);\n            ob.s.unified_ord = self.flags.len() + self.opts.len();\n            self.opts.push(ob);\n        } else {\n            let mut fb = FlagBuilder::from(a);\n            fb.s.unified_ord = self.flags.len() + self.opts.len();\n            self.flags.push(fb);\n        }\n        if a.is_set(ArgSettings::Global) {\n            self.global_args.push(a.into());\n        }\n    }\n\n    pub fn add_group(&mut self, group: ArgGroup<'a>) {\n        if group.required {\n            self.required.push(group.name);\n            if let Some(ref reqs) = group.requires {\n                self.required.extend_from_slice(reqs);\n            }\n            //            if let Some(ref bl) = group.conflicts {\n            //                self.blacklist.extend_from_slice(bl);\n            //            }\n        }\n        if self.groups.iter().any(|g| g.name == group.name) {\n            let grp = self\n                .groups\n                .iter_mut()\n                .find(|g| g.name == group.name)\n                .expect(INTERNAL_ERROR_MSG);\n            grp.args.extend_from_slice(&group.args);\n            grp.requires = group.requires.clone();\n            grp.conflicts = group.conflicts.clone();\n            grp.required = group.required;\n        } else {\n            self.groups.push(group);\n        }\n    }\n\n    pub fn add_subcommand(&mut self, mut subcmd: App<'a, 'b>) {\n        debugln!(\n            \"Parser::add_subcommand: term_w={:?}, name={}\",\n            self.meta.term_w,\n            subcmd.p.meta.name\n        );\n        subcmd.p.meta.term_w = self.meta.term_w;\n        if subcmd.p.meta.name == \"help\" {\n            self.unset(AS::NeedsSubcommandHelp);\n        }\n\n        self.subcommands.push(subcmd);\n    }\n\n    pub fn propagate_settings(&mut self) {\n        debugln!(\n            \"Parser::propagate_settings: self={}, g_settings={:#?}\",\n            self.meta.name,\n            self.g_settings\n        );\n        for sc in &mut self.subcommands {\n            debugln!(\n                \"Parser::propagate_settings: sc={}, settings={:#?}, g_settings={:#?}\",\n                sc.p.meta.name,\n                sc.p.settings,\n                sc.p.g_settings\n            );\n            // We have to create a new scope in order to tell rustc the borrow of `sc` is\n            // done and to recursively call this method\n            {\n                let vsc = self.settings.is_set(AS::VersionlessSubcommands);\n                let gv = self.settings.is_set(AS::GlobalVersion);\n\n                if vsc {\n                    sc.p.set(AS::DisableVersion);\n                }\n                if gv && sc.p.meta.version.is_none() && self.meta.version.is_some() {\n                    sc.p.set(AS::GlobalVersion);\n                    sc.p.meta.version = Some(self.meta.version.unwrap());\n                }\n                sc.p.settings = sc.p.settings | self.g_settings;\n                sc.p.g_settings = sc.p.g_settings | self.g_settings;\n                sc.p.meta.term_w = self.meta.term_w;\n                sc.p.meta.max_w = self.meta.max_w;\n            }\n            sc.p.propagate_settings();\n        }\n    }\n\n    #[cfg_attr(feature = \"lints\", allow(needless_borrow))]\n    pub fn derive_display_order(&mut self) {\n        if self.is_set(AS::DeriveDisplayOrder) {\n            let unified = self.is_set(AS::UnifiedHelpMessage);\n            for (i, o) in self\n                .opts\n                .iter_mut()\n                .enumerate()\n                .filter(|&(_, ref o)| o.s.disp_ord == 999)\n            {\n                o.s.disp_ord = if unified { o.s.unified_ord } else { i };\n            }\n            for (i, f) in self\n                .flags\n                .iter_mut()\n                .enumerate()\n                .filter(|&(_, ref f)| f.s.disp_ord == 999)\n            {\n                f.s.disp_ord = if unified { f.s.unified_ord } else { i };\n            }\n            for (i, sc) in &mut self\n                .subcommands\n                .iter_mut()\n                .enumerate()\n                .filter(|&(_, ref sc)| sc.p.meta.disp_ord == 999)\n            {\n                sc.p.meta.disp_ord = i;\n            }\n        }\n        for sc in &mut self.subcommands {\n            sc.p.derive_display_order();\n        }\n    }\n\n    pub fn required(&self) -> Iter<&str> {\n        self.required.iter()\n    }\n\n    #[cfg_attr(feature = \"lints\", allow(needless_borrow))]\n    #[inline]\n    pub fn has_args(&self) -> bool {\n        !(self.flags.is_empty() && self.opts.is_empty() && self.positionals.is_empty())\n    }\n\n    #[inline]\n    pub fn has_opts(&self) -> bool {\n        !self.opts.is_empty()\n    }\n\n    #[inline]\n    pub fn has_flags(&self) -> bool {\n        !self.flags.is_empty()\n    }\n\n    #[inline]\n    pub fn has_positionals(&self) -> bool {\n        !self.positionals.is_empty()\n    }\n\n    #[inline]\n    pub fn has_subcommands(&self) -> bool {\n        !self.subcommands.is_empty()\n    }\n\n    #[inline]\n    pub fn has_visible_opts(&self) -> bool {\n        if self.opts.is_empty() {\n            return false;\n        }\n        self.opts.iter().any(|o| !o.is_set(ArgSettings::Hidden))\n    }\n\n    #[inline]\n    pub fn has_visible_flags(&self) -> bool {\n        if self.flags.is_empty() {\n            return false;\n        }\n        self.flags.iter().any(|f| !f.is_set(ArgSettings::Hidden))\n    }\n\n    #[inline]\n    pub fn has_visible_positionals(&self) -> bool {\n        if self.positionals.is_empty() {\n            return false;\n        }\n        self.positionals\n            .values()\n            .any(|p| !p.is_set(ArgSettings::Hidden))\n    }\n\n    #[inline]\n    pub fn has_visible_subcommands(&self) -> bool {\n        self.has_subcommands()\n            && self\n                .subcommands\n                .iter()\n                .filter(|sc| sc.p.meta.name != \"help\")\n                .any(|sc| !sc.p.is_set(AS::Hidden))\n    }\n\n    #[inline]\n    pub fn is_set(&self, s: AS) -> bool {\n        self.settings.is_set(s)\n    }\n\n    #[inline]\n    pub fn set(&mut self, s: AS) {\n        self.settings.set(s)\n    }\n\n    #[inline]\n    pub fn unset(&mut self, s: AS) {\n        self.settings.unset(s)\n    }\n\n    #[cfg_attr(feature = \"lints\", allow(block_in_if_condition_stmt))]\n    pub fn verify_positionals(&self) -> bool {\n        // Because you must wait until all arguments have been supplied, this is the first chance\n        // to make assertions on positional argument indexes\n        //\n        // First we verify that the index highest supplied index, is equal to the number of\n        // positional arguments to verify there are no gaps (i.e. supplying an index of 1 and 3\n        // but no 2)\n        if let Some((idx, p)) = self.positionals.iter().rev().next() {\n            assert!(\n                !(idx != self.positionals.len()),\n                \"Found positional argument \\\"{}\\\" whose index is {} but there \\\n                 are only {} positional arguments defined\",\n                p.b.name,\n                idx,\n                self.positionals.len()\n            );\n        }\n\n        // Next we verify that only the highest index has a .multiple(true) (if any)\n        if self.positionals.values().any(|a| {\n            a.b.is_set(ArgSettings::Multiple) && (a.index as usize != self.positionals.len())\n        }) {\n            let mut it = self.positionals.values().rev();\n            let last = it.next().unwrap();\n            let second_to_last = it.next().unwrap();\n            // Either the final positional is required\n            // Or the second to last has a terminator or .last(true) set\n            let ok = last.is_set(ArgSettings::Required)\n                || (second_to_last.v.terminator.is_some()\n                    || second_to_last.b.is_set(ArgSettings::Last))\n                || last.is_set(ArgSettings::Last);\n            assert!(\n                ok,\n                \"When using a positional argument with .multiple(true) that is *not the \\\n                 last* positional argument, the last positional argument (i.e the one \\\n                 with the highest index) *must* have .required(true) or .last(true) set.\"\n            );\n            let ok = second_to_last.is_set(ArgSettings::Multiple) || last.is_set(ArgSettings::Last);\n            assert!(\n                ok,\n                \"Only the last positional argument, or second to last positional \\\n                 argument may be set to .multiple(true)\"\n            );\n\n            let count = self\n                .positionals\n                .values()\n                .filter(|p| p.b.settings.is_set(ArgSettings::Multiple) && p.v.num_vals.is_none())\n                .count();\n            let ok = count <= 1\n                || (last.is_set(ArgSettings::Last)\n                    && last.is_set(ArgSettings::Multiple)\n                    && second_to_last.is_set(ArgSettings::Multiple)\n                    && count == 2);\n            assert!(\n                ok,\n                \"Only one positional argument with .multiple(true) set is allowed per \\\n                 command, unless the second one also has .last(true) set\"\n            );\n        }\n\n        if self.is_set(AS::AllowMissingPositional) {\n            // Check that if a required positional argument is found, all positions with a lower\n            // index are also required.\n            let mut found = false;\n            let mut foundx2 = false;\n            for p in self.positionals.values().rev() {\n                if foundx2 && !p.b.settings.is_set(ArgSettings::Required) {\n                    assert!(\n                        p.b.is_set(ArgSettings::Required),\n                        \"Found positional argument which is not required with a lower \\\n                         index than a required positional argument by two or more: {:?} \\\n                         index {}\",\n                        p.b.name,\n                        p.index\n                    );\n                } else if p.b.is_set(ArgSettings::Required) && !p.b.is_set(ArgSettings::Last) {\n                    // Args that .last(true) don't count since they can be required and have\n                    // positionals with a lower index that aren't required\n                    // Imagine: prog <req1> [opt1] -- <req2>\n                    // Both of these are valid invocations:\n                    //      $ prog r1 -- r2\n                    //      $ prog r1 o1 -- r2\n                    if found {\n                        foundx2 = true;\n                        continue;\n                    }\n                    found = true;\n                    continue;\n                } else {\n                    found = false;\n                }\n            }\n        } else {\n            // Check that if a required positional argument is found, all positions with a lower\n            // index are also required\n            let mut found = false;\n            for p in self.positionals.values().rev() {\n                if found {\n                    assert!(\n                        p.b.is_set(ArgSettings::Required),\n                        \"Found positional argument which is not required with a lower \\\n                         index than a required positional argument: {:?} index {}\",\n                        p.b.name,\n                        p.index\n                    );\n                } else if p.b.is_set(ArgSettings::Required) && !p.b.is_set(ArgSettings::Last) {\n                    // Args that .last(true) don't count since they can be required and have\n                    // positionals with a lower index that aren't required\n                    // Imagine: prog <req1> [opt1] -- <req2>\n                    // Both of these are valid invocations:\n                    //      $ prog r1 -- r2\n                    //      $ prog r1 o1 -- r2\n                    found = true;\n                    continue;\n                }\n            }\n        }\n        if self\n            .positionals\n            .values()\n            .any(|p| p.b.is_set(ArgSettings::Last) && p.b.is_set(ArgSettings::Required))\n            && self.has_subcommands()\n            && !self.is_set(AS::SubcommandsNegateReqs)\n        {\n            panic!(\n                \"Having a required positional argument with .last(true) set *and* child \\\n                 subcommands without setting SubcommandsNegateReqs isn't compatible.\"\n            );\n        }\n\n        true\n    }\n\n    pub fn propagate_globals(&mut self) {\n        for sc in &mut self.subcommands {\n            // We have to create a new scope in order to tell rustc the borrow of `sc` is\n            // done and to recursively call this method\n            {\n                for a in &self.global_args {\n                    sc.p.add_arg_ref(a);\n                }\n            }\n            sc.p.propagate_globals();\n        }\n    }\n\n    // Checks if the arg matches a subcommand name, or any of it's aliases (if defined)\n    fn possible_subcommand(&self, arg_os: &OsStr) -> (bool, Option<&str>) {\n        #[cfg(any(target_os = \"windows\", target_arch = \"wasm32\"))]\n        use osstringext::OsStrExt3;\n        #[cfg(not(any(target_os = \"windows\", target_arch = \"wasm32\")))]\n        use std::os::unix::ffi::OsStrExt;\n        debugln!(\"Parser::possible_subcommand: arg={:?}\", arg_os);\n        fn starts(h: &str, n: &OsStr) -> bool {\n            let n_bytes = n.as_bytes();\n            let h_bytes = OsStr::new(h).as_bytes();\n\n            h_bytes.starts_with(n_bytes)\n        }\n\n        if self.is_set(AS::ArgsNegateSubcommands) && self.is_set(AS::ValidArgFound) {\n            return (false, None);\n        }\n        if !self.is_set(AS::InferSubcommands) {\n            if let Some(sc) = find_subcmd!(self, arg_os) {\n                return (true, Some(&sc.p.meta.name));\n            }\n        } else {\n            let v = self\n                .subcommands\n                .iter()\n                .filter(|s| {\n                    starts(&s.p.meta.name[..], &*arg_os)\n                        || (s.p.meta.aliases.is_some()\n                            && s.p\n                                .meta\n                                .aliases\n                                .as_ref()\n                                .unwrap()\n                                .iter()\n                                .filter(|&&(a, _)| starts(a, &*arg_os))\n                                .count()\n                                == 1)\n                })\n                .map(|sc| &sc.p.meta.name)\n                .collect::<Vec<_>>();\n\n            for sc in &v {\n                if OsStr::new(sc) == arg_os {\n                    return (true, Some(sc));\n                }\n            }\n\n            if v.len() == 1 {\n                return (true, Some(v[0]));\n            }\n        }\n        (false, None)\n    }\n\n    fn parse_help_subcommand<I, T>(&self, it: &mut I) -> ClapResult<ParseResult<'a>>\n    where\n        I: Iterator<Item = T>,\n        T: Into<OsString>,\n    {\n        debugln!(\"Parser::parse_help_subcommand;\");\n        let cmds: Vec<OsString> = it.map(|c| c.into()).collect();\n        let mut help_help = false;\n        let mut bin_name = self\n            .meta\n            .bin_name\n            .as_ref()\n            .unwrap_or(&self.meta.name)\n            .clone();\n        let mut sc = {\n            let mut sc: &Parser = self;\n            for (i, cmd) in cmds.iter().enumerate() {\n                if &*cmd.to_string_lossy() == \"help\" {\n                    // cmd help help\n                    help_help = true;\n                }\n                if let Some(c) = sc\n                    .subcommands\n                    .iter()\n                    .find(|s| &*s.p.meta.name == cmd)\n                    .map(|sc| &sc.p)\n                {\n                    sc = c;\n                    if i == cmds.len() - 1 {\n                        break;\n                    }\n                } else if let Some(c) = sc\n                    .subcommands\n                    .iter()\n                    .find(|s| {\n                        if let Some(ref als) = s.p.meta.aliases {\n                            als.iter().any(|&(a, _)| a == &*cmd.to_string_lossy())\n                        } else {\n                            false\n                        }\n                    })\n                    .map(|sc| &sc.p)\n                {\n                    sc = c;\n                    if i == cmds.len() - 1 {\n                        break;\n                    }\n                } else {\n                    return Err(Error::unrecognized_subcommand(\n                        cmd.to_string_lossy().into_owned(),\n                        self.meta.bin_name.as_ref().unwrap_or(&self.meta.name),\n                        self.color(),\n                    ));\n                }\n                bin_name = format!(\"{} {}\", bin_name, &*sc.meta.name);\n            }\n            sc.clone()\n        };\n        if help_help {\n            let mut pb = PosBuilder::new(\"subcommand\", 1);\n            pb.b.help = Some(\"The subcommand whose help message to display\");\n            pb.set(ArgSettings::Multiple);\n            sc.positionals.insert(1, pb);\n            sc.settings = sc.settings | self.g_settings;\n        } else {\n            sc.create_help_and_version();\n        }\n        if sc.meta.bin_name != self.meta.bin_name {\n            sc.meta.bin_name = Some(format!(\"{} {}\", bin_name, sc.meta.name));\n        }\n        Err(sc._help(false))\n    }\n\n    // allow wrong self convention due to self.valid_neg_num = true and it's a private method\n    #[cfg_attr(feature = \"lints\", allow(wrong_self_convention))]\n    fn is_new_arg(&mut self, arg_os: &OsStr, needs_val_of: ParseResult) -> bool {\n        debugln!(\"Parser::is_new_arg:{:?}:{:?}\", arg_os, needs_val_of);\n        let app_wide_settings = if self.is_set(AS::AllowLeadingHyphen) {\n            true\n        } else if self.is_set(AS::AllowNegativeNumbers) {\n            let a = arg_os.to_string_lossy();\n            if a.parse::<i64>().is_ok() || a.parse::<f64>().is_ok() {\n                self.set(AS::ValidNegNumFound);\n                true\n            } else {\n                false\n            }\n        } else {\n            false\n        };\n        let arg_allows_tac = match needs_val_of {\n            ParseResult::Opt(name) => {\n                let o = self\n                    .opts\n                    .iter()\n                    .find(|o| o.b.name == name)\n                    .expect(INTERNAL_ERROR_MSG);\n                (o.is_set(ArgSettings::AllowLeadingHyphen) || app_wide_settings)\n            }\n            ParseResult::Pos(name) => {\n                let p = self\n                    .positionals\n                    .values()\n                    .find(|p| p.b.name == name)\n                    .expect(INTERNAL_ERROR_MSG);\n                (p.is_set(ArgSettings::AllowLeadingHyphen) || app_wide_settings)\n            }\n            ParseResult::ValuesDone => return true,\n            _ => false,\n        };\n        debugln!(\"Parser::is_new_arg: arg_allows_tac={:?}\", arg_allows_tac);\n\n        // Is this a new argument, or values from a previous option?\n        let mut ret = if arg_os.starts_with(b\"--\") {\n            debugln!(\"Parser::is_new_arg: -- found\");\n            if arg_os.len() == 2 && !arg_allows_tac {\n                return true; // We have to return true so override everything else\n            } else if arg_allows_tac {\n                return false;\n            }\n            true\n        } else if arg_os.starts_with(b\"-\") {\n            debugln!(\"Parser::is_new_arg: - found\");\n            // a singe '-' by itself is a value and typically means \"stdin\" on unix systems\n            !(arg_os.len() == 1)\n        } else {\n            debugln!(\"Parser::is_new_arg: probably value\");\n            false\n        };\n\n        ret = ret && !arg_allows_tac;\n\n        debugln!(\"Parser::is_new_arg: starts_new_arg={:?}\", ret);\n        ret\n    }\n\n    // The actual parsing function\n    #[cfg_attr(feature = \"lints\", allow(while_let_on_iterator, collapsible_if))]\n    pub fn get_matches_with<I, T>(\n        &mut self,\n        matcher: &mut ArgMatcher<'a>,\n        it: &mut Peekable<I>,\n    ) -> ClapResult<()>\n    where\n        I: Iterator<Item = T>,\n        T: Into<OsString> + Clone,\n    {\n        debugln!(\"Parser::get_matches_with;\");\n        // Verify all positional assertions pass\n        debug_assert!(self.app_debug_asserts());\n        if self.positionals.values().any(|a| {\n            a.b.is_set(ArgSettings::Multiple) && (a.index as usize != self.positionals.len())\n        }) && self\n            .positionals\n            .values()\n            .last()\n            .map_or(false, |p| !p.is_set(ArgSettings::Last))\n        {\n            self.settings.set(AS::LowIndexMultiplePositional);\n        }\n        let has_args = self.has_args();\n\n        // Next we create the `--help` and `--version` arguments and add them if\n        // necessary\n        self.create_help_and_version();\n\n        let mut subcmd_name: Option<String> = None;\n        let mut needs_val_of: ParseResult<'a> = ParseResult::NotFound;\n        let mut pos_counter = 1;\n        let mut sc_is_external = false;\n        while let Some(arg) = it.next() {\n            let arg_os = arg.into();\n            debugln!(\n                \"Parser::get_matches_with: Begin parsing '{:?}' ({:?})\",\n                arg_os,\n                &*arg_os.as_bytes()\n            );\n\n            self.unset(AS::ValidNegNumFound);\n            // Is this a new argument, or values from a previous option?\n            let starts_new_arg = self.is_new_arg(&arg_os, needs_val_of);\n            if !self.is_set(AS::TrailingValues)\n                && arg_os.starts_with(b\"--\")\n                && arg_os.len() == 2\n                && starts_new_arg\n            {\n                debugln!(\"Parser::get_matches_with: setting TrailingVals=true\");\n                self.set(AS::TrailingValues);\n                continue;\n            }\n\n            // Has the user already passed '--'? Meaning only positional args follow\n            if !self.is_set(AS::TrailingValues) {\n                // Does the arg match a subcommand name, or any of it's aliases (if defined)\n                {\n                    match needs_val_of {\n                        ParseResult::Opt(_) | ParseResult::Pos(_) => (),\n                        _ => {\n                            let (is_match, sc_name) = self.possible_subcommand(&arg_os);\n                            debugln!(\n                                \"Parser::get_matches_with: possible_sc={:?}, sc={:?}\",\n                                is_match,\n                                sc_name\n                            );\n                            if is_match {\n                                let sc_name = sc_name.expect(INTERNAL_ERROR_MSG);\n                                if sc_name == \"help\" && self.is_set(AS::NeedsSubcommandHelp) {\n                                    self.parse_help_subcommand(it)?;\n                                }\n                                subcmd_name = Some(sc_name.to_owned());\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if starts_new_arg {\n                    let check_all = self.is_set(AS::AllArgsOverrideSelf);\n                    {\n                        let any_arg = find_any_by_name!(self, self.cache.unwrap_or(\"\"));\n                        matcher.process_arg_overrides(\n                            any_arg,\n                            &mut self.overrides,\n                            &mut self.required,\n                            check_all,\n                        );\n                    }\n\n                    if arg_os.starts_with(b\"--\") {\n                        needs_val_of = self.parse_long_arg(matcher, &arg_os, it)?;\n                        debugln!(\n                            \"Parser:get_matches_with: After parse_long_arg {:?}\",\n                            needs_val_of\n                        );\n                        match needs_val_of {\n                            ParseResult::Flag | ParseResult::Opt(..) | ParseResult::ValuesDone => {\n                                continue\n                            }\n                            _ => (),\n                        }\n                    } else if arg_os.starts_with(b\"-\") && arg_os.len() != 1 {\n                        // Try to parse short args like normal, if AllowLeadingHyphen or\n                        // AllowNegativeNumbers is set, parse_short_arg will *not* throw\n                        // an error, and instead return Ok(None)\n                        needs_val_of = self.parse_short_arg(matcher, &arg_os)?;\n                        // If it's None, we then check if one of those two AppSettings was set\n                        debugln!(\n                            \"Parser:get_matches_with: After parse_short_arg {:?}\",\n                            needs_val_of\n                        );\n                        match needs_val_of {\n                            ParseResult::MaybeNegNum => {\n                                if !(arg_os.to_string_lossy().parse::<i64>().is_ok()\n                                    || arg_os.to_string_lossy().parse::<f64>().is_ok())\n                                {\n                                    return Err(Error::unknown_argument(\n                                        &*arg_os.to_string_lossy(),\n                                        \"\",\n                                        &*usage::create_error_usage(self, matcher, None),\n                                        self.color(),\n                                    ));\n                                }\n                            }\n                            ParseResult::Opt(..) | ParseResult::Flag | ParseResult::ValuesDone => {\n                                continue\n                            }\n                            _ => (),\n                        }\n                    }\n                } else {\n                    if let ParseResult::Opt(name) = needs_val_of {\n                        // Check to see if parsing a value from a previous arg\n                        let arg = self\n                            .opts\n                            .iter()\n                            .find(|o| o.b.name == name)\n                            .expect(INTERNAL_ERROR_MSG);\n                        // get the OptBuilder so we can check the settings\n                        needs_val_of = self.add_val_to_arg(arg, &arg_os, matcher)?;\n                        // get the next value from the iterator\n                        continue;\n                    }\n                }\n            }\n\n            if !(self.is_set(AS::ArgsNegateSubcommands) && self.is_set(AS::ValidArgFound))\n                && !self.is_set(AS::InferSubcommands)\n                && !self.is_set(AS::AllowExternalSubcommands)\n            {\n                if let Some(cdate) =\n                    suggestions::did_you_mean(&*arg_os.to_string_lossy(), sc_names!(self))\n                {\n                    return Err(Error::invalid_subcommand(\n                        arg_os.to_string_lossy().into_owned(),\n                        cdate,\n                        self.meta.bin_name.as_ref().unwrap_or(&self.meta.name),\n                        &*usage::create_error_usage(self, matcher, None),\n                        self.color(),\n                    ));\n                }\n            }\n\n            let low_index_mults = self.is_set(AS::LowIndexMultiplePositional)\n                && pos_counter == (self.positionals.len() - 1);\n            let missing_pos = self.is_set(AS::AllowMissingPositional)\n                && (pos_counter == (self.positionals.len() - 1)\n                    && !self.is_set(AS::TrailingValues));\n            debugln!(\n                \"Parser::get_matches_with: Positional counter...{}\",\n                pos_counter\n            );\n            debugln!(\n                \"Parser::get_matches_with: Low index multiples...{:?}\",\n                low_index_mults\n            );\n            if low_index_mults || missing_pos {\n                if let Some(na) = it.peek() {\n                    let n = (*na).clone().into();\n                    needs_val_of = if needs_val_of != ParseResult::ValuesDone {\n                        if let Some(p) = self.positionals.get(pos_counter) {\n                            ParseResult::Pos(p.b.name)\n                        } else {\n                            ParseResult::ValuesDone\n                        }\n                    } else {\n                        ParseResult::ValuesDone\n                    };\n                    let sc_match = { self.possible_subcommand(&n).0 };\n                    if self.is_new_arg(&n, needs_val_of)\n                        || sc_match\n                        || suggestions::did_you_mean(&n.to_string_lossy(), sc_names!(self))\n                            .is_some()\n                    {\n                        debugln!(\"Parser::get_matches_with: Bumping the positional counter...\");\n                        pos_counter += 1;\n                    }\n                } else {\n                    debugln!(\"Parser::get_matches_with: Bumping the positional counter...\");\n                    pos_counter += 1;\n                }\n            } else if (self.is_set(AS::AllowMissingPositional) && self.is_set(AS::TrailingValues))\n                || (self.is_set(AS::ContainsLast) && self.is_set(AS::TrailingValues))\n            {\n                // Came to -- and one postional has .last(true) set, so we go immediately\n                // to the last (highest index) positional\n                debugln!(\"Parser::get_matches_with: .last(true) and --, setting last pos\");\n                pos_counter = self.positionals.len();\n            }\n            if let Some(p) = self.positionals.get(pos_counter) {\n                if p.is_set(ArgSettings::Last) && !self.is_set(AS::TrailingValues) {\n                    return Err(Error::unknown_argument(\n                        &*arg_os.to_string_lossy(),\n                        \"\",\n                        &*usage::create_error_usage(self, matcher, None),\n                        self.color(),\n                    ));\n                }\n                if !self.is_set(AS::TrailingValues)\n                    && (self.is_set(AS::TrailingVarArg) && pos_counter == self.positionals.len())\n                {\n                    self.settings.set(AS::TrailingValues);\n                }\n                if self.cache.map_or(true, |name| name != p.b.name) {\n                    let check_all = self.is_set(AS::AllArgsOverrideSelf);\n                    {\n                        let any_arg = find_any_by_name!(self, self.cache.unwrap_or(\"\"));\n                        matcher.process_arg_overrides(\n                            any_arg,\n                            &mut self.overrides,\n                            &mut self.required,\n                            check_all,\n                        );\n                    }\n                    self.cache = Some(p.b.name);\n                }\n                let _ = self.add_val_to_arg(p, &arg_os, matcher)?;\n\n                matcher.inc_occurrence_of(p.b.name);\n                let _ = self\n                    .groups_for_arg(p.b.name)\n                    .and_then(|vec| Some(matcher.inc_occurrences_of(&*vec)));\n\n                self.settings.set(AS::ValidArgFound);\n                // Only increment the positional counter if it doesn't allow multiples\n                if !p.b.settings.is_set(ArgSettings::Multiple) {\n                    pos_counter += 1;\n                }\n                self.settings.set(AS::ValidArgFound);\n            } else if self.is_set(AS::AllowExternalSubcommands) {\n                // Get external subcommand name\n                let sc_name = match arg_os.to_str() {\n                    Some(s) => s.to_string(),\n                    None => {\n                        if !self.is_set(AS::StrictUtf8) {\n                            return Err(Error::invalid_utf8(\n                                &*usage::create_error_usage(self, matcher, None),\n                                self.color(),\n                            ));\n                        }\n                        arg_os.to_string_lossy().into_owned()\n                    }\n                };\n\n                // Collect the external subcommand args\n                let mut sc_m = ArgMatcher::new();\n                while let Some(v) = it.next() {\n                    let a = v.into();\n                    if a.to_str().is_none() && !self.is_set(AS::StrictUtf8) {\n                        return Err(Error::invalid_utf8(\n                            &*usage::create_error_usage(self, matcher, None),\n                            self.color(),\n                        ));\n                    }\n                    sc_m.add_val_to(\"\", &a);\n                }\n\n                matcher.subcommand(SubCommand {\n                    name: sc_name,\n                    matches: sc_m.into(),\n                });\n                sc_is_external = true;\n            } else if !((self.is_set(AS::AllowLeadingHyphen)\n                || self.is_set(AS::AllowNegativeNumbers))\n                && arg_os.starts_with(b\"-\"))\n                && !self.is_set(AS::InferSubcommands)\n            {\n                return Err(Error::unknown_argument(\n                    &*arg_os.to_string_lossy(),\n                    \"\",\n                    &*usage::create_error_usage(self, matcher, None),\n                    self.color(),\n                ));\n            } else if !has_args || self.is_set(AS::InferSubcommands) && self.has_subcommands() {\n                if let Some(cdate) =\n                    suggestions::did_you_mean(&*arg_os.to_string_lossy(), sc_names!(self))\n                {\n                    return Err(Error::invalid_subcommand(\n                        arg_os.to_string_lossy().into_owned(),\n                        cdate,\n                        self.meta.bin_name.as_ref().unwrap_or(&self.meta.name),\n                        &*usage::create_error_usage(self, matcher, None),\n                        self.color(),\n                    ));\n                } else {\n                    return Err(Error::unrecognized_subcommand(\n                        arg_os.to_string_lossy().into_owned(),\n                        self.meta.bin_name.as_ref().unwrap_or(&self.meta.name),\n                        self.color(),\n                    ));\n                }\n            } else {\n                return Err(Error::unknown_argument(\n                    &*arg_os.to_string_lossy(),\n                    \"\",\n                    &*usage::create_error_usage(self, matcher, None),\n                    self.color(),\n                ));\n            }\n        }\n\n        if !sc_is_external {\n            if let Some(ref pos_sc_name) = subcmd_name {\n                let sc_name = {\n                    find_subcmd!(self, pos_sc_name)\n                        .expect(INTERNAL_ERROR_MSG)\n                        .p\n                        .meta\n                        .name\n                        .clone()\n                };\n                self.parse_subcommand(&*sc_name, matcher, it)?;\n            } else if self.is_set(AS::SubcommandRequired) {\n                let bn = self.meta.bin_name.as_ref().unwrap_or(&self.meta.name);\n                return Err(Error::missing_subcommand(\n                    bn,\n                    &usage::create_error_usage(self, matcher, None),\n                    self.color(),\n                ));\n            } else if self.is_set(AS::SubcommandRequiredElseHelp) {\n                debugln!(\"Parser::get_matches_with: SubcommandRequiredElseHelp=true\");\n                let mut out = vec![];\n                self.write_help_err(&mut out)?;\n                return Err(Error {\n                    message: String::from_utf8_lossy(&*out).into_owned(),\n                    kind: ErrorKind::MissingArgumentOrSubcommand,\n                    info: None,\n                });\n            }\n        }\n\n        // In case the last arg was new, we  need to process it's overrides\n        let check_all = self.is_set(AS::AllArgsOverrideSelf);\n        {\n            let any_arg = find_any_by_name!(self, self.cache.unwrap_or(\"\"));\n            matcher.process_arg_overrides(\n                any_arg,\n                &mut self.overrides,\n                &mut self.required,\n                check_all,\n            );\n        }\n\n        self.remove_overrides(matcher);\n\n        Validator::new(self).validate(needs_val_of, subcmd_name, matcher)\n    }\n\n    fn remove_overrides(&mut self, matcher: &mut ArgMatcher) {\n        debugln!(\"Parser::remove_overrides:{:?};\", self.overrides);\n        for &(overr, name) in &self.overrides {\n            debugln!(\"Parser::remove_overrides:iter:({},{});\", overr, name);\n            if matcher.is_present(overr) {\n                debugln!(\n                    \"Parser::remove_overrides:iter:({},{}): removing {};\",\n                    overr,\n                    name,\n                    name\n                );\n                matcher.remove(name);\n                for i in (0..self.required.len()).rev() {\n                    debugln!(\n                        \"Parser::remove_overrides:iter:({},{}): removing required {};\",\n                        overr,\n                        name,\n                        name\n                    );\n                    if self.required[i] == name {\n                        self.required.swap_remove(i);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    fn propagate_help_version(&mut self) {\n        debugln!(\"Parser::propagate_help_version;\");\n        self.create_help_and_version();\n        for sc in &mut self.subcommands {\n            sc.p.propagate_help_version();\n        }\n    }\n\n    fn build_bin_names(&mut self) {\n        debugln!(\"Parser::build_bin_names;\");\n        for sc in &mut self.subcommands {\n            debug!(\"Parser::build_bin_names:iter: bin_name set...\");\n            if sc.p.meta.bin_name.is_none() {\n                sdebugln!(\"No\");\n                let bin_name = format!(\n                    \"{}{}{}\",\n                    self.meta\n                        .bin_name\n                        .as_ref()\n                        .unwrap_or(&self.meta.name.clone()),\n                    if self.meta.bin_name.is_some() {\n                        \" \"\n                    } else {\n                        \"\"\n                    },\n                    &*sc.p.meta.name\n                );\n                debugln!(\n                    \"Parser::build_bin_names:iter: Setting bin_name of {} to {}\",\n                    self.meta.name,\n                    bin_name\n                );\n                sc.p.meta.bin_name = Some(bin_name);\n            } else {\n                sdebugln!(\"yes ({:?})\", sc.p.meta.bin_name);\n            }\n            debugln!(\n                \"Parser::build_bin_names:iter: Calling build_bin_names from...{}\",\n                sc.p.meta.name\n            );\n            sc.p.build_bin_names();\n        }\n    }\n\n    fn parse_subcommand<I, T>(\n        &mut self,\n        sc_name: &str,\n        matcher: &mut ArgMatcher<'a>,\n        it: &mut Peekable<I>,\n    ) -> ClapResult<()>\n    where\n        I: Iterator<Item = T>,\n        T: Into<OsString> + Clone,\n    {\n        use std::fmt::Write;\n        debugln!(\"Parser::parse_subcommand;\");\n        let mut mid_string = String::new();\n        if !self.is_set(AS::SubcommandsNegateReqs) {\n            let mut hs: Vec<&str> = self.required.iter().map(|n| &**n).collect();\n            for k in matcher.arg_names() {\n                hs.push(k);\n            }\n            let reqs = usage::get_required_usage_from(self, &hs, Some(matcher), None, false);\n\n            for s in &reqs {\n                write!(&mut mid_string, \" {}\", s).expect(INTERNAL_ERROR_MSG);\n            }\n        }\n        mid_string.push_str(\" \");\n        if let Some(ref mut sc) = self\n            .subcommands\n            .iter_mut()\n            .find(|s| s.p.meta.name == sc_name)\n        {\n            let mut sc_matcher = ArgMatcher::new();\n            // bin_name should be parent's bin_name + [<reqs>] + the sc's name separated by\n            // a space\n            sc.p.meta.usage = Some(format!(\n                \"{}{}{}\",\n                self.meta.bin_name.as_ref().unwrap_or(&String::new()),\n                if self.meta.bin_name.is_some() {\n                    &*mid_string\n                } else {\n                    \"\"\n                },\n                &*sc.p.meta.name\n            ));\n            sc.p.meta.bin_name = Some(format!(\n                \"{}{}{}\",\n                self.meta.bin_name.as_ref().unwrap_or(&String::new()),\n                if self.meta.bin_name.is_some() {\n                    \" \"\n                } else {\n                    \"\"\n                },\n                &*sc.p.meta.name\n            ));\n            debugln!(\n                \"Parser::parse_subcommand: About to parse sc={}\",\n                sc.p.meta.name\n            );\n            debugln!(\"Parser::parse_subcommand: sc settings={:#?}\", sc.p.settings);\n            sc.p.get_matches_with(&mut sc_matcher, it)?;\n            matcher.subcommand(SubCommand {\n                name: sc.p.meta.name.clone(),\n                matches: sc_matcher.into(),\n            });\n        }\n        Ok(())\n    }\n\n    pub fn groups_for_arg(&self, name: &str) -> Option<Vec<&'a str>> {\n        debugln!(\"Parser::groups_for_arg: name={}\", name);\n\n        if self.groups.is_empty() {\n            debugln!(\"Parser::groups_for_arg: No groups defined\");\n            return None;\n        }\n        let mut res = vec![];\n        debugln!(\"Parser::groups_for_arg: Searching through groups...\");\n        for grp in &self.groups {\n            for a in &grp.args {\n                if a == &name {\n                    sdebugln!(\"\\tFound '{}'\", grp.name);\n                    res.push(&*grp.name);\n                }\n            }\n        }\n        if res.is_empty() {\n            return None;\n        }\n\n        Some(res)\n    }\n\n    pub fn args_in_group(&self, group: &str) -> Vec<String> {\n        debug_assert!(self.app_debug_asserts());\n\n        let mut g_vec = vec![];\n        let mut args = vec![];\n\n        for n in &self\n            .groups\n            .iter()\n            .find(|g| g.name == group)\n            .expect(INTERNAL_ERROR_MSG)\n            .args\n        {\n            if let Some(f) = self.flags.iter().find(|f| &f.b.name == n) {\n                args.push(f.to_string());\n            } else if let Some(f) = self.opts.iter().find(|o| &o.b.name == n) {\n                args.push(f.to_string());\n            } else if let Some(p) = self.positionals.values().find(|p| &p.b.name == n) {\n                args.push(p.b.name.to_owned());\n            } else {\n                g_vec.push(*n);\n            }\n        }\n\n        for av in g_vec.iter().map(|g| self.args_in_group(g)) {\n            args.extend(av);\n        }\n        args.dedup();\n        args.iter().map(ToOwned::to_owned).collect()\n    }\n\n    pub fn arg_names_in_group(&self, group: &str) -> Vec<&'a str> {\n        let mut g_vec = vec![];\n        let mut args = vec![];\n\n        for n in &self\n            .groups\n            .iter()\n            .find(|g| g.name == group)\n            .expect(INTERNAL_ERROR_MSG)\n            .args\n        {\n            if self.groups.iter().any(|g| g.name == *n) {\n                args.extend(self.arg_names_in_group(n));\n                g_vec.push(*n);\n            } else if !args.contains(n) {\n                args.push(*n);\n            }\n        }\n\n        args.iter().map(|s| *s).collect()\n    }\n\n    pub fn create_help_and_version(&mut self) {\n        debugln!(\"Parser::create_help_and_version;\");\n        // name is \"hclap_help\" because flags are sorted by name\n        if !self.is_set(AS::DisableHelpFlags) && !self.contains_long(\"help\") {\n            debugln!(\"Parser::create_help_and_version: Building --help\");\n            if self.help_short.is_none() && !self.contains_short('h') {\n                self.help_short = Some('h');\n            }\n            let arg = FlagBuilder {\n                b: Base {\n                    name: \"hclap_help\",\n                    help: self.help_message.or(Some(\"Prints help information\")),\n                    ..Default::default()\n                },\n                s: Switched {\n                    short: self.help_short,\n                    long: Some(\"help\"),\n                    ..Default::default()\n                },\n            };\n            self.flags.push(arg);\n        }\n        if !self.is_set(AS::DisableVersion) && !self.contains_long(\"version\") {\n            debugln!(\"Parser::create_help_and_version: Building --version\");\n            if self.version_short.is_none() && !self.contains_short('V') {\n                self.version_short = Some('V');\n            }\n            // name is \"vclap_version\" because flags are sorted by name\n            let arg = FlagBuilder {\n                b: Base {\n                    name: \"vclap_version\",\n                    help: self.version_message.or(Some(\"Prints version information\")),\n                    ..Default::default()\n                },\n                s: Switched {\n                    short: self.version_short,\n                    long: Some(\"version\"),\n                    ..Default::default()\n                },\n            };\n            self.flags.push(arg);\n        }\n        if !self.subcommands.is_empty()\n            && !self.is_set(AS::DisableHelpSubcommand)\n            && self.is_set(AS::NeedsSubcommandHelp)\n        {\n            debugln!(\"Parser::create_help_and_version: Building help\");\n            self.subcommands.push(\n                App::new(\"help\")\n                    .about(\"Prints this message or the help of the given subcommand(s)\"),\n            );\n        }\n    }\n\n    // Retrieves the names of all args the user has supplied thus far, except required ones\n    // because those will be listed in self.required\n    fn check_for_help_and_version_str(&self, arg: &OsStr) -> ClapResult<()> {\n        debugln!(\"Parser::check_for_help_and_version_str;\");\n        debug!(\n            \"Parser::check_for_help_and_version_str: Checking if --{} is help or version...\",\n            arg.to_str().unwrap()\n        );\n        if arg == \"help\" && self.is_set(AS::NeedsLongHelp) {\n            sdebugln!(\"Help\");\n            return Err(self._help(true));\n        }\n        if arg == \"version\" && self.is_set(AS::NeedsLongVersion) {\n            sdebugln!(\"Version\");\n            return Err(self._version(true));\n        }\n        sdebugln!(\"Neither\");\n\n        Ok(())\n    }\n\n    fn check_for_help_and_version_char(&self, arg: char) -> ClapResult<()> {\n        debugln!(\"Parser::check_for_help_and_version_char;\");\n        debug!(\n            \"Parser::check_for_help_and_version_char: Checking if -{} is help or version...\",\n            arg\n        );\n        if let Some(h) = self.help_short {\n            if arg == h && self.is_set(AS::NeedsLongHelp) {\n                sdebugln!(\"Help\");\n                return Err(self._help(false));\n            }\n        }\n        if let Some(v) = self.version_short {\n            if arg == v && self.is_set(AS::NeedsLongVersion) {\n                sdebugln!(\"Version\");\n                return Err(self._version(false));\n            }\n        }\n        sdebugln!(\"Neither\");\n        Ok(())\n    }\n\n    fn use_long_help(&self) -> bool {\n        // In this case, both must be checked. This allows the retention of\n        // original formatting, but also ensures that the actual -h or --help\n        // specified by the user is sent through. If HiddenShortHelp is not included,\n        // then items specified with hidden_short_help will also be hidden.\n        let should_long = |v: &Base| {\n            v.long_help.is_some()\n                || v.is_set(ArgSettings::HiddenLongHelp)\n                || v.is_set(ArgSettings::HiddenShortHelp)\n        };\n\n        self.meta.long_about.is_some()\n            || self.flags.iter().any(|f| should_long(&f.b))\n            || self.opts.iter().any(|o| should_long(&o.b))\n            || self.positionals.values().any(|p| should_long(&p.b))\n            || self\n                .subcommands\n                .iter()\n                .any(|s| s.p.meta.long_about.is_some())\n    }\n\n    fn _help(&self, mut use_long: bool) -> Error {\n        debugln!(\"Parser::_help: use_long={:?}\", use_long);\n        use_long = use_long && self.use_long_help();\n        let mut buf = vec![];\n        match Help::write_parser_help(&mut buf, self, use_long) {\n            Err(e) => e,\n            _ => Error {\n                message: String::from_utf8(buf).unwrap_or_default(),\n                kind: ErrorKind::HelpDisplayed,\n                info: None,\n            },\n        }\n    }\n\n    fn _version(&self, use_long: bool) -> Error {\n        debugln!(\"Parser::_version: \");\n        let out = io::stdout();\n        let mut buf_w = BufWriter::new(out.lock());\n        match self.print_version(&mut buf_w, use_long) {\n            Err(e) => e,\n            _ => Error {\n                message: String::new(),\n                kind: ErrorKind::VersionDisplayed,\n                info: None,\n            },\n        }\n    }\n\n    fn parse_long_arg<I, T>(\n        &mut self,\n        matcher: &mut ArgMatcher<'a>,\n        full_arg: &OsStr,\n        it: &mut Peekable<I>,\n    ) -> ClapResult<ParseResult<'a>>\n    where\n        I: Iterator<Item = T>,\n        T: Into<OsString> + Clone,\n    {\n        // maybe here lifetime should be 'a\n        debugln!(\"Parser::parse_long_arg;\");\n\n        // Update the current index\n        self.cur_idx.set(self.cur_idx.get() + 1);\n\n        let mut val = None;\n        debug!(\"Parser::parse_long_arg: Does it contain '='...\");\n        let arg = if full_arg.contains_byte(b'=') {\n            let (p0, p1) = full_arg.trim_left_matches(b'-').split_at_byte(b'=');\n            sdebugln!(\"Yes '{:?}'\", p1);\n            val = Some(p1);\n            p0\n        } else {\n            sdebugln!(\"No\");\n            full_arg.trim_left_matches(b'-')\n        };\n\n        if let Some(opt) = find_opt_by_long!(@os self, arg) {\n            debugln!(\n                \"Parser::parse_long_arg: Found valid opt '{}'\",\n                opt.to_string()\n            );\n            self.settings.set(AS::ValidArgFound);\n            let ret = self.parse_opt(val, opt, val.is_some(), matcher)?;\n            if self.cache.map_or(true, |name| name != opt.b.name) {\n                self.cache = Some(opt.b.name);\n            }\n\n            return Ok(ret);\n        } else if let Some(flag) = find_flag_by_long!(@os self, arg) {\n            debugln!(\n                \"Parser::parse_long_arg: Found valid flag '{}'\",\n                flag.to_string()\n            );\n            self.settings.set(AS::ValidArgFound);\n            // Only flags could be help or version, and we need to check the raw long\n            // so this is the first point to check\n            self.check_for_help_and_version_str(arg)?;\n\n            self.parse_flag(flag, matcher)?;\n\n            // Handle conflicts, requirements, etc.\n            if self.cache.map_or(true, |name| name != flag.b.name) {\n                self.cache = Some(flag.b.name);\n            }\n\n            return Ok(ParseResult::Flag);\n        } else if self.is_set(AS::AllowLeadingHyphen) {\n            return Ok(ParseResult::MaybeHyphenValue);\n        } else if self.is_set(AS::ValidNegNumFound) {\n            return Ok(ParseResult::MaybeNegNum);\n        }\n\n        debugln!(\"Parser::parse_long_arg: Didn't match anything\");\n\n        let args_rest: Vec<_> = it.map(|x| x.clone().into()).collect();\n        let args_rest2: Vec<_> = args_rest\n            .iter()\n            .map(|x| x.to_str().expect(INVALID_UTF8))\n            .collect();\n        self.did_you_mean_error(arg.to_str().expect(INVALID_UTF8), matcher, &args_rest2[..])\n            .map(|_| ParseResult::NotFound)\n    }\n\n    #[cfg_attr(feature = \"lints\", allow(len_zero))]\n    fn parse_short_arg(\n        &mut self,\n        matcher: &mut ArgMatcher<'a>,\n        full_arg: &OsStr,\n    ) -> ClapResult<ParseResult<'a>> {\n        debugln!(\"Parser::parse_short_arg: full_arg={:?}\", full_arg);\n        let arg_os = full_arg.trim_left_matches(b'-');\n        let arg = arg_os.to_string_lossy();\n\n        // If AllowLeadingHyphen is set, we want to ensure `-val` gets parsed as `-val` and not\n        // `-v` `-a` `-l` assuming `v` `a` and `l` are all, or mostly, valid shorts.\n        if self.is_set(AS::AllowLeadingHyphen) {\n            if arg.chars().any(|c| !self.contains_short(c)) {\n                debugln!(\n                    \"Parser::parse_short_arg: LeadingHyphenAllowed yet -{} isn't valid\",\n                    arg\n                );\n                return Ok(ParseResult::MaybeHyphenValue);\n            }\n        } else if self.is_set(AS::ValidNegNumFound) {\n            // TODO: Add docs about having AllowNegativeNumbers and `-2` as a valid short\n            // May be better to move this to *after* not finding a valid flag/opt?\n            debugln!(\"Parser::parse_short_arg: Valid negative num...\");\n            return Ok(ParseResult::MaybeNegNum);\n        }\n\n        let mut ret = ParseResult::NotFound;\n        for c in arg.chars() {\n            debugln!(\"Parser::parse_short_arg:iter:{}\", c);\n\n            // update each index because `-abcd` is four indices to clap\n            self.cur_idx.set(self.cur_idx.get() + 1);\n\n            // Check for matching short options, and return the name if there is no trailing\n            // concatenated value: -oval\n            // Option: -o\n            // Value: val\n            if let Some(opt) = find_opt_by_short!(self, c) {\n                debugln!(\"Parser::parse_short_arg:iter:{}: Found valid opt\", c);\n                self.settings.set(AS::ValidArgFound);\n                // Check for trailing concatenated value\n                let p: Vec<_> = arg.splitn(2, c).collect();\n                debugln!(\n                    \"Parser::parse_short_arg:iter:{}: p[0]={:?}, p[1]={:?}\",\n                    c,\n                    p[0].as_bytes(),\n                    p[1].as_bytes()\n                );\n                let i = p[0].as_bytes().len() + 1;\n                let val = if p[1].as_bytes().len() > 0 {\n                    debugln!(\n                        \"Parser::parse_short_arg:iter:{}: val={:?} (bytes), val={:?} (ascii)\",\n                        c,\n                        arg_os.split_at(i).1.as_bytes(),\n                        arg_os.split_at(i).1\n                    );\n                    Some(arg_os.split_at(i).1)\n                } else {\n                    None\n                };\n\n                // Default to \"we're expecting a value later\"\n                let ret = self.parse_opt(val, opt, false, matcher)?;\n\n                if self.cache.map_or(true, |name| name != opt.b.name) {\n                    self.cache = Some(opt.b.name);\n                }\n\n                return Ok(ret);\n            } else if let Some(flag) = find_flag_by_short!(self, c) {\n                debugln!(\"Parser::parse_short_arg:iter:{}: Found valid flag\", c);\n                self.settings.set(AS::ValidArgFound);\n                // Only flags can be help or version\n                self.check_for_help_and_version_char(c)?;\n                ret = self.parse_flag(flag, matcher)?;\n\n                // Handle conflicts, requirements, overrides, etc.\n                // Must be called here due to mutabililty\n                if self.cache.map_or(true, |name| name != flag.b.name) {\n                    self.cache = Some(flag.b.name);\n                }\n            } else {\n                let arg = format!(\"-{}\", c);\n                return Err(Error::unknown_argument(\n                    &*arg,\n                    \"\",\n                    &*usage::create_error_usage(self, matcher, None),\n                    self.color(),\n                ));\n            }\n        }\n        Ok(ret)\n    }\n\n    fn parse_opt(\n        &self,\n        val: Option<&OsStr>,\n        opt: &OptBuilder<'a, 'b>,\n        had_eq: bool,\n        matcher: &mut ArgMatcher<'a>,\n    ) -> ClapResult<ParseResult<'a>> {\n        debugln!(\"Parser::parse_opt; opt={}, val={:?}\", opt.b.name, val);\n        debugln!(\"Parser::parse_opt; opt.settings={:?}\", opt.b.settings);\n        let mut has_eq = false;\n        let no_val = val.is_none();\n        let empty_vals = opt.is_set(ArgSettings::EmptyValues);\n        let min_vals_zero = opt.v.min_vals.unwrap_or(1) == 0;\n        let needs_eq = opt.is_set(ArgSettings::RequireEquals);\n\n        debug!(\"Parser::parse_opt; Checking for val...\");\n        if let Some(fv) = val {\n            has_eq = fv.starts_with(&[b'=']) || had_eq;\n            let v = fv.trim_left_matches(b'=');\n            if !empty_vals && (v.len() == 0 || (needs_eq && !has_eq)) {\n                sdebugln!(\"Found Empty - Error\");\n                return Err(Error::empty_value(\n                    opt,\n                    &*usage::create_error_usage(self, matcher, None),\n                    self.color(),\n                ));\n            }\n            sdebugln!(\"Found - {:?}, len: {}\", v, v.len());\n            debugln!(\n                \"Parser::parse_opt: {:?} contains '='...{:?}\",\n                fv,\n                fv.starts_with(&[b'='])\n            );\n            self.add_val_to_arg(opt, v, matcher)?;\n        } else if needs_eq && !(empty_vals || min_vals_zero) {\n            sdebugln!(\"None, but requires equals...Error\");\n            return Err(Error::empty_value(\n                opt,\n                &*usage::create_error_usage(self, matcher, None),\n                self.color(),\n            ));\n        } else {\n            sdebugln!(\"None\");\n        }\n\n        matcher.inc_occurrence_of(opt.b.name);\n        // Increment or create the group \"args\"\n        self.groups_for_arg(opt.b.name)\n            .and_then(|vec| Some(matcher.inc_occurrences_of(&*vec)));\n\n        let needs_delim = opt.is_set(ArgSettings::RequireDelimiter);\n        let mult = opt.is_set(ArgSettings::Multiple);\n        if no_val && min_vals_zero && !has_eq && needs_eq {\n            debugln!(\"Parser::parse_opt: More arg vals not required...\");\n            return Ok(ParseResult::ValuesDone);\n        } else if no_val || (mult && !needs_delim) && !has_eq && matcher.needs_more_vals(opt) {\n            debugln!(\"Parser::parse_opt: More arg vals required...\");\n            return Ok(ParseResult::Opt(opt.b.name));\n        }\n        debugln!(\"Parser::parse_opt: More arg vals not required...\");\n        Ok(ParseResult::ValuesDone)\n    }\n\n    fn add_val_to_arg<A>(\n        &self,\n        arg: &A,\n        val: &OsStr,\n        matcher: &mut ArgMatcher<'a>,\n    ) -> ClapResult<ParseResult<'a>>\n    where\n        A: AnyArg<'a, 'b> + Display,\n    {\n        debugln!(\"Parser::add_val_to_arg; arg={}, val={:?}\", arg.name(), val);\n        debugln!(\n            \"Parser::add_val_to_arg; trailing_vals={:?}, DontDelimTrailingVals={:?}\",\n            self.is_set(AS::TrailingValues),\n            self.is_set(AS::DontDelimitTrailingValues)\n        );\n        if !(self.is_set(AS::TrailingValues) && self.is_set(AS::DontDelimitTrailingValues)) {\n            if let Some(delim) = arg.val_delim() {\n                if val.is_empty() {\n                    Ok(self.add_single_val_to_arg(arg, val, matcher)?)\n                } else {\n                    let mut iret = ParseResult::ValuesDone;\n                    for v in val.split(delim as u32 as u8) {\n                        iret = self.add_single_val_to_arg(arg, v, matcher)?;\n                    }\n                    // If there was a delimiter used, we're not looking for more values\n                    if val.contains_byte(delim as u32 as u8)\n                        || arg.is_set(ArgSettings::RequireDelimiter)\n                    {\n                        iret = ParseResult::ValuesDone;\n                    }\n                    Ok(iret)\n                }\n            } else {\n                self.add_single_val_to_arg(arg, val, matcher)\n            }\n        } else {\n            self.add_single_val_to_arg(arg, val, matcher)\n        }\n    }\n\n    fn add_single_val_to_arg<A>(\n        &self,\n        arg: &A,\n        v: &OsStr,\n        matcher: &mut ArgMatcher<'a>,\n    ) -> ClapResult<ParseResult<'a>>\n    where\n        A: AnyArg<'a, 'b> + Display,\n    {\n        debugln!(\"Parser::add_single_val_to_arg;\");\n        debugln!(\"Parser::add_single_val_to_arg: adding val...{:?}\", v);\n\n        // update the current index because each value is a distinct index to clap\n        self.cur_idx.set(self.cur_idx.get() + 1);\n\n        // @TODO @docs @p4: docs for indices should probably note that a terminator isn't a value\n        // and therefore not reported in indices\n        if let Some(t) = arg.val_terminator() {\n            if t == v {\n                return Ok(ParseResult::ValuesDone);\n            }\n        }\n\n        matcher.add_val_to(arg.name(), v);\n        matcher.add_index_to(arg.name(), self.cur_idx.get());\n\n        // Increment or create the group \"args\"\n        if let Some(grps) = self.groups_for_arg(arg.name()) {\n            for grp in grps {\n                matcher.add_val_to(&*grp, v);\n            }\n        }\n\n        if matcher.needs_more_vals(arg) {\n            return Ok(ParseResult::Opt(arg.name()));\n        }\n        Ok(ParseResult::ValuesDone)\n    }\n\n    fn parse_flag(\n        &self,\n        flag: &FlagBuilder<'a, 'b>,\n        matcher: &mut ArgMatcher<'a>,\n    ) -> ClapResult<ParseResult<'a>> {\n        debugln!(\"Parser::parse_flag;\");\n\n        matcher.inc_occurrence_of(flag.b.name);\n        matcher.add_index_to(flag.b.name, self.cur_idx.get());\n\n        // Increment or create the group \"args\"\n        self.groups_for_arg(flag.b.name)\n            .and_then(|vec| Some(matcher.inc_occurrences_of(&*vec)));\n\n        Ok(ParseResult::Flag)\n    }\n\n    fn did_you_mean_error(\n        &self,\n        arg: &str,\n        matcher: &mut ArgMatcher<'a>,\n        args_rest: &[&str],\n    ) -> ClapResult<()> {\n        // Didn't match a flag or option\n        let suffix =\n            suggestions::did_you_mean_flag_suffix(arg, &args_rest, longs!(self), &self.subcommands);\n\n        // Add the arg to the matches to build a proper usage string\n        if let Some(name) = suffix.1 {\n            if let Some(opt) = find_opt_by_long!(self, name) {\n                self.groups_for_arg(&*opt.b.name)\n                    .and_then(|grps| Some(matcher.inc_occurrences_of(&*grps)));\n                matcher.insert(&*opt.b.name);\n            } else if let Some(flg) = find_flag_by_long!(self, name) {\n                self.groups_for_arg(&*flg.b.name)\n                    .and_then(|grps| Some(matcher.inc_occurrences_of(&*grps)));\n                matcher.insert(&*flg.b.name);\n            }\n        }\n\n        let used_arg = format!(\"--{}\", arg);\n        Err(Error::unknown_argument(\n            &*used_arg,\n            &*suffix.0,\n            &*usage::create_error_usage(self, matcher, None),\n            self.color(),\n        ))\n    }\n\n    // Prints the version to the user and exits if quit=true\n    fn print_version<W: Write>(&self, w: &mut W, use_long: bool) -> ClapResult<()> {\n        self.write_version(w, use_long)?;\n        w.flush().map_err(Error::from)\n    }\n\n    pub fn write_version<W: Write>(&self, w: &mut W, use_long: bool) -> io::Result<()> {\n        let ver = if use_long {\n            self.meta\n                .long_version\n                .unwrap_or_else(|| self.meta.version.unwrap_or(\"\"))\n        } else {\n            self.meta\n                .version\n                .unwrap_or_else(|| self.meta.long_version.unwrap_or(\"\"))\n        };\n        if let Some(bn) = self.meta.bin_name.as_ref() {\n            if bn.contains(' ') {\n                // Incase we're dealing with subcommands i.e. git mv is translated to git-mv\n                write!(w, \"{} {}\", bn.replace(\" \", \"-\"), ver)\n            } else {\n                write!(w, \"{} {}\", &self.meta.name[..], ver)\n            }\n        } else {\n            write!(w, \"{} {}\", &self.meta.name[..], ver)\n        }\n    }\n\n    pub fn print_help(&self) -> ClapResult<()> {\n        let out = io::stdout();\n        let mut buf_w = BufWriter::new(out.lock());\n        self.write_help(&mut buf_w)\n    }\n\n    pub fn write_help<W: Write>(&self, w: &mut W) -> ClapResult<()> {\n        Help::write_parser_help(w, self, false)\n    }\n\n    pub fn write_long_help<W: Write>(&self, w: &mut W) -> ClapResult<()> {\n        Help::write_parser_help(w, self, true)\n    }\n\n    pub fn write_help_err<W: Write>(&self, w: &mut W) -> ClapResult<()> {\n        Help::write_parser_help_to_stderr(w, self)\n    }\n\n    pub fn add_defaults(&mut self, matcher: &mut ArgMatcher<'a>) -> ClapResult<()> {\n        debugln!(\"Parser::add_defaults;\");\n        macro_rules! add_val {\n            (@default $_self:ident, $a:ident, $m:ident) => {\n                if let Some(ref val) = $a.v.default_val {\n                    debugln!(\"Parser::add_defaults:iter:{}: has default vals\", $a.b.name);\n                    if $m.get($a.b.name).map(|ma| ma.vals.len()).map(|len| len == 0).unwrap_or(false) {\n                        debugln!(\"Parser::add_defaults:iter:{}: has no user defined vals\", $a.b.name);\n                        $_self.add_val_to_arg($a, OsStr::new(val), $m)?;\n\n                        if $_self.cache.map_or(true, |name| name != $a.name()) {\n                            $_self.cache = Some($a.name());\n                        }\n                    } else if $m.get($a.b.name).is_some() {\n                        debugln!(\"Parser::add_defaults:iter:{}: has user defined vals\", $a.b.name);\n                    } else {\n                        debugln!(\"Parser::add_defaults:iter:{}: wasn't used\", $a.b.name);\n\n                        $_self.add_val_to_arg($a, OsStr::new(val), $m)?;\n\n                        if $_self.cache.map_or(true, |name| name != $a.name()) {\n                            $_self.cache = Some($a.name());\n                        }\n                    }\n                } else {\n                    debugln!(\"Parser::add_defaults:iter:{}: doesn't have default vals\", $a.b.name);\n                }\n            };\n            ($_self:ident, $a:ident, $m:ident) => {\n                if let Some(ref vm) = $a.v.default_vals_ifs {\n                    sdebugln!(\" has conditional defaults\");\n                    let mut done = false;\n                    if $m.get($a.b.name).is_none() {\n                        for &(arg, val, default) in vm.values() {\n                            let add = if let Some(a) = $m.get(arg) {\n                                if let Some(v) = val {\n                                    a.vals.iter().any(|value| v == value)\n                                } else {\n                                    true\n                                }\n                            } else {\n                                false\n                            };\n                            if add {\n                                $_self.add_val_to_arg($a, OsStr::new(default), $m)?;\n                                if $_self.cache.map_or(true, |name| name != $a.name()) {\n                                    $_self.cache = Some($a.name());\n                                }\n                                done = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if done {\n                        continue; // outer loop (outside macro)\n                    }\n                } else {\n                    sdebugln!(\" doesn't have conditional defaults\");\n                }\n                add_val!(@default $_self, $a, $m)\n            };\n        }\n\n        for o in &self.opts {\n            debug!(\"Parser::add_defaults:iter:{}:\", o.b.name);\n            add_val!(self, o, matcher);\n        }\n        for p in self.positionals.values() {\n            debug!(\"Parser::add_defaults:iter:{}:\", p.b.name);\n            add_val!(self, p, matcher);\n        }\n        Ok(())\n    }\n\n    pub fn add_env(&mut self, matcher: &mut ArgMatcher<'a>) -> ClapResult<()> {\n        macro_rules! add_val {\n            ($_self:ident, $a:ident, $m:ident) => {\n                if let Some(ref val) = $a.v.env {\n                    if $m\n                        .get($a.b.name)\n                        .map(|ma| ma.vals.len())\n                        .map(|len| len == 0)\n                        .unwrap_or(false)\n                    {\n                        if let Some(ref val) = val.1 {\n                            $_self.add_val_to_arg($a, OsStr::new(val), $m)?;\n\n                            if $_self.cache.map_or(true, |name| name != $a.name()) {\n                                $_self.cache = Some($a.name());\n                            }\n                        }\n                    } else {\n                        if let Some(ref val) = val.1 {\n                            $_self.add_val_to_arg($a, OsStr::new(val), $m)?;\n\n                            if $_self.cache.map_or(true, |name| name != $a.name()) {\n                                $_self.cache = Some($a.name());\n                            }\n                        }\n                    }\n                }\n            };\n        }\n\n        for o in &self.opts {\n            add_val!(self, o, matcher);\n        }\n        for p in self.positionals.values() {\n            add_val!(self, p, matcher);\n        }\n        Ok(())\n    }\n\n    pub fn flags(&self) -> Iter<FlagBuilder<'a, 'b>> {\n        self.flags.iter()\n    }\n\n    pub fn opts(&self) -> Iter<OptBuilder<'a, 'b>> {\n        self.opts.iter()\n    }\n\n    pub fn positionals(&self) -> map::Values<PosBuilder<'a, 'b>> {\n        self.positionals.values()\n    }\n\n    pub fn subcommands(&self) -> Iter<App> {\n        self.subcommands.iter()\n    }\n\n    // Should we color the output? None=determined by output location, true=yes, false=no\n    #[doc(hidden)]\n    pub fn color(&self) -> ColorWhen {\n        debugln!(\"Parser::color;\");\n        debug!(\"Parser::color: Color setting...\");\n        if self.is_set(AS::ColorNever) {\n            sdebugln!(\"Never\");\n            ColorWhen::Never\n        } else if self.is_set(AS::ColorAlways) {\n            sdebugln!(\"Always\");\n            ColorWhen::Always\n        } else {\n            sdebugln!(\"Auto\");\n            ColorWhen::Auto\n        }\n    }\n\n    pub fn find_any_arg(&self, name: &str) -> Option<&AnyArg<'a, 'b>> {\n        if let Some(f) = find_by_name!(self, name, flags, iter) {\n            return Some(f);\n        }\n        if let Some(o) = find_by_name!(self, name, opts, iter) {\n            return Some(o);\n        }\n        if let Some(p) = find_by_name!(self, name, positionals, values) {\n            return Some(p);\n        }\n        None\n    }\n\n    /// Check is a given string matches the binary name for this parser\n    fn is_bin_name(&self, value: &str) -> bool {\n        self.meta\n            .bin_name\n            .as_ref()\n            .and_then(|name| Some(value == name))\n            .unwrap_or(false)\n    }\n\n    /// Check is a given string is an alias for this parser\n    fn is_alias(&self, value: &str) -> bool {\n        self.meta\n            .aliases\n            .as_ref()\n            .and_then(|aliases| {\n                for alias in aliases {\n                    if alias.0 == value {\n                        return Some(true);\n                    }\n                }\n                Some(false)\n            })\n            .unwrap_or(false)\n    }\n\n    // Only used for completion scripts due to bin_name messiness\n    #[cfg_attr(feature = \"lints\", allow(block_in_if_condition_stmt))]\n    pub fn find_subcommand(&'b self, sc: &str) -> Option<&'b App<'a, 'b>> {\n        debugln!(\"Parser::find_subcommand: sc={}\", sc);\n        debugln!(\n            \"Parser::find_subcommand: Currently in Parser...{}\",\n            self.meta.bin_name.as_ref().unwrap()\n        );\n        for s in &self.subcommands {\n            if s.p.is_bin_name(sc) {\n                return Some(s);\n            }\n            // XXX: why do we split here?\n            // isn't `sc` supposed to be single word already?\n            let last = sc.split(' ').rev().next().expect(INTERNAL_ERROR_MSG);\n            if s.p.is_alias(last) {\n                return Some(s);\n            }\n\n            if let Some(app) = s.p.find_subcommand(sc) {\n                return Some(app);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn contains_long(&self, l: &str) -> bool {\n        longs!(self).any(|al| al == &l)\n    }\n\n    #[inline]\n    fn contains_short(&self, s: char) -> bool {\n        shorts!(self).any(|arg_s| arg_s == &s)\n    }\n}"],"app::settings::AppFlags":["Clone","Copy","Debug","PartialEq","impl AppFlags {\n    pub fn new() -> Self {\n        AppFlags::default()\n    }\n    pub fn zeroed() -> Self {\n        AppFlags(Flags::empty())\n    }\n\n    impl_settings! { AppSettings,\n        ArgRequiredElseHelp => Flags::A_REQUIRED_ELSE_HELP,\n        ArgsNegateSubcommands => Flags::ARGS_NEGATE_SCS,\n        AllArgsOverrideSelf => Flags::ARGS_OVERRIDE_SELF,\n        AllowExternalSubcommands => Flags::ALLOW_UNK_SC,\n        AllowInvalidUtf8 => Flags::UTF8_NONE,\n        AllowLeadingHyphen => Flags::LEADING_HYPHEN,\n        AllowNegativeNumbers => Flags::ALLOW_NEG_NUMS,\n        AllowMissingPositional => Flags::ALLOW_MISSING_POS,\n        ColoredHelp => Flags::COLORED_HELP,\n        ColorAlways => Flags::COLOR_ALWAYS,\n        ColorAuto => Flags::COLOR_AUTO,\n        ColorNever => Flags::COLOR_NEVER,\n        DontDelimitTrailingValues => Flags::DONT_DELIM_TRAIL,\n        DontCollapseArgsInUsage => Flags::DONT_COLLAPSE_ARGS,\n        DeriveDisplayOrder => Flags::DERIVE_DISP_ORDER,\n        DisableHelpFlags => Flags::DISABLE_HELP_FLAGS,\n        DisableHelpSubcommand => Flags::DISABLE_HELP_SC,\n        DisableVersion => Flags::DISABLE_VERSION,\n        GlobalVersion => Flags::GLOBAL_VERSION,\n        HidePossibleValuesInHelp => Flags::NO_POS_VALUES,\n        Hidden => Flags::HIDDEN,\n        LowIndexMultiplePositional => Flags::LOW_INDEX_MUL_POS,\n        NeedsLongHelp => Flags::NEEDS_LONG_HELP,\n        NeedsLongVersion => Flags::NEEDS_LONG_VERSION,\n        NeedsSubcommandHelp => Flags::NEEDS_SC_HELP,\n        NoBinaryName => Flags::NO_BIN_NAME,\n        PropagateGlobalValuesDown=> Flags::PROPAGATE_VALS_DOWN,\n        StrictUtf8 => Flags::UTF8_STRICT,\n        SubcommandsNegateReqs => Flags::SC_NEGATE_REQS,\n        SubcommandRequired => Flags::SC_REQUIRED,\n        SubcommandRequiredElseHelp => Flags::SC_REQUIRED_ELSE_HELP,\n        TrailingVarArg => Flags::TRAILING_VARARG,\n        UnifiedHelpMessage => Flags::UNIFIED_HELP,\n        NextLineHelp => Flags::NEXT_LINE_HELP,\n        VersionlessSubcommands => Flags::VERSIONLESS_SC,\n        WaitOnError => Flags::WAIT_ON_ERROR,\n        TrailingValues => Flags::TRAILING_VALUES,\n        ValidNegNumFound => Flags::VALID_NEG_NUM_FOUND,\n        Propagated => Flags::PROPAGATED,\n        ValidArgFound => Flags::VALID_ARG_FOUND,\n        InferSubcommands => Flags::INFER_SUBCOMMANDS,\n        ContainsLast => Flags::CONTAINS_LAST\n    }\n}","impl BitOr for AppFlags {\n    type Output = Self;\n    fn bitor(self, rhs: Self) -> Self {\n        AppFlags(self.0 | rhs.0)\n    }\n}","impl Default for AppFlags {\n    fn default() -> Self {\n        AppFlags(\n            Flags::NEEDS_LONG_VERSION\n                | Flags::NEEDS_LONG_HELP\n                | Flags::NEEDS_SC_HELP\n                | Flags::UTF8_NONE\n                | Flags::COLOR_AUTO,\n        )\n    }\n}"],"app::settings::AppSettings":["Clone","Copy","Debug","PartialEq","impl FromStr for AppSettings {\n    type Err = String;\n    fn from_str(s: &str) -> Result<Self, <Self as FromStr>::Err> {\n        match &*s.to_ascii_lowercase() {\n            \"disablehelpflags\" => Ok(AppSettings::DisableHelpFlags),\n            \"argrequiredelsehelp\" => Ok(AppSettings::ArgRequiredElseHelp),\n            \"argsnegatesubcommands\" => Ok(AppSettings::ArgsNegateSubcommands),\n            \"allowinvalidutf8\" => Ok(AppSettings::AllowInvalidUtf8),\n            \"allowleadinghyphen\" => Ok(AppSettings::AllowLeadingHyphen),\n            \"allowexternalsubcommands\" => Ok(AppSettings::AllowExternalSubcommands),\n            \"allownegativenumbers\" => Ok(AppSettings::AllowNegativeNumbers),\n            \"colorauto\" => Ok(AppSettings::ColorAuto),\n            \"coloralways\" => Ok(AppSettings::ColorAlways),\n            \"colornever\" => Ok(AppSettings::ColorNever),\n            \"coloredhelp\" => Ok(AppSettings::ColoredHelp),\n            \"derivedisplayorder\" => Ok(AppSettings::DeriveDisplayOrder),\n            \"dontcollapseargsinusage\" => Ok(AppSettings::DontCollapseArgsInUsage),\n            \"dontdelimittrailingvalues\" => Ok(AppSettings::DontDelimitTrailingValues),\n            \"disablehelpsubcommand\" => Ok(AppSettings::DisableHelpSubcommand),\n            \"disableversion\" => Ok(AppSettings::DisableVersion),\n            \"globalversion\" => Ok(AppSettings::GlobalVersion),\n            \"hidden\" => Ok(AppSettings::Hidden),\n            \"hidepossiblevaluesinhelp\" => Ok(AppSettings::HidePossibleValuesInHelp),\n            \"infersubcommands\" => Ok(AppSettings::InferSubcommands),\n            \"lowindexmultiplepositional\" => Ok(AppSettings::LowIndexMultiplePositional),\n            \"nobinaryname\" => Ok(AppSettings::NoBinaryName),\n            \"nextlinehelp\" => Ok(AppSettings::NextLineHelp),\n            \"strictutf8\" => Ok(AppSettings::StrictUtf8),\n            \"subcommandsnegatereqs\" => Ok(AppSettings::SubcommandsNegateReqs),\n            \"subcommandrequired\" => Ok(AppSettings::SubcommandRequired),\n            \"subcommandrequiredelsehelp\" => Ok(AppSettings::SubcommandRequiredElseHelp),\n            \"trailingvararg\" => Ok(AppSettings::TrailingVarArg),\n            \"unifiedhelpmessage\" => Ok(AppSettings::UnifiedHelpMessage),\n            \"versionlesssubcommands\" => Ok(AppSettings::VersionlessSubcommands),\n            \"waitonerror\" => Ok(AppSettings::WaitOnError),\n            \"validnegnumfound\" => Ok(AppSettings::ValidNegNumFound),\n            \"validargfound\" => Ok(AppSettings::ValidArgFound),\n            \"propagated\" => Ok(AppSettings::Propagated),\n            \"trailingvalues\" => Ok(AppSettings::TrailingValues),\n            _ => Err(\"unknown AppSetting, cannot convert from str\".to_owned()),\n        }\n    }\n}"],"app::settings::Flags":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }","impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::Debug for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                // This convoluted approach is to handle #[cfg]-based flag\n                // omission correctly. For example it needs to support:\n                //\n                //    #[cfg(unix)] const A: Flag = /* ... */;\n                //    #[cfg(windows)] const B: Flag = /* ... */;\n\n                // Unconditionally define a check for every flag, even disabled\n                // ones.\n                #[allow(non_snake_case)]\n                trait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }\n\n                // Conditionally override the check for just those flags that\n                // are not #[cfg]ed away.\n                #[allow(non_snake_case)]\n                impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }","impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }","impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }","impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }","impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }","impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }","impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }","impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }","impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }","impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }","impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }","impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }","impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }","impl __BitFlags for $BitFlags {\n            $(\n                __impl_bitflags! {\n                    #[allow(deprecated)]\n                    $(? #[$attr $($args)*])*\n                    const $Flag: $T = Self::$Flag.bits;\n                }\n            )+\n        }"],"app::validator::Validator":["impl<'a, 'b, 'z> Validator<'a, 'b, 'z> {\n    pub fn new(p: &'z mut Parser<'a, 'b>) -> Self {\n        Validator(p)\n    }\n\n    pub fn validate(\n        &mut self,\n        needs_val_of: ParseResult<'a>,\n        subcmd_name: Option<String>,\n        matcher: &mut ArgMatcher<'a>,\n    ) -> ClapResult<()> {\n        debugln!(\"Validator::validate;\");\n        let mut reqs_validated = false;\n        self.0.add_env(matcher)?;\n        self.0.add_defaults(matcher)?;\n        if let ParseResult::Opt(a) = needs_val_of {\n            debugln!(\"Validator::validate: needs_val_of={:?}\", a);\n            let o = {\n                self.0\n                    .opts\n                    .iter()\n                    .find(|o| o.b.name == a)\n                    .expect(INTERNAL_ERROR_MSG)\n                    .clone()\n            };\n            self.validate_required(matcher)?;\n            reqs_validated = true;\n            let should_err = if let Some(v) = matcher.0.args.get(&*o.b.name) {\n                v.vals.is_empty() && !(o.v.min_vals.is_some() && o.v.min_vals.unwrap() == 0)\n            } else {\n                true\n            };\n            if should_err {\n                return Err(Error::empty_value(\n                    &o,\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n        }\n\n        if matcher.is_empty()\n            && matcher.subcommand_name().is_none()\n            && self.0.is_set(AS::ArgRequiredElseHelp)\n        {\n            let mut out = vec![];\n            self.0.write_help_err(&mut out)?;\n            return Err(Error {\n                message: String::from_utf8_lossy(&*out).into_owned(),\n                kind: ErrorKind::MissingArgumentOrSubcommand,\n                info: None,\n            });\n        }\n        self.validate_blacklist(matcher)?;\n        if !(self.0.is_set(AS::SubcommandsNegateReqs) && subcmd_name.is_some()) && !reqs_validated {\n            self.validate_required(matcher)?;\n        }\n        self.validate_matched_args(matcher)?;\n        matcher.usage(usage::create_usage_with_title(self.0, &[]));\n\n        Ok(())\n    }\n\n    fn validate_arg_values<A>(\n        &self,\n        arg: &A,\n        ma: &MatchedArg,\n        matcher: &ArgMatcher<'a>,\n    ) -> ClapResult<()>\n    where\n        A: AnyArg<'a, 'b> + Display,\n    {\n        debugln!(\"Validator::validate_arg_values: arg={:?}\", arg.name());\n        for val in &ma.vals {\n            if self.0.is_set(AS::StrictUtf8) && val.to_str().is_none() {\n                debugln!(\n                    \"Validator::validate_arg_values: invalid UTF-8 found in val {:?}\",\n                    val\n                );\n                return Err(Error::invalid_utf8(\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n            if let Some(p_vals) = arg.possible_vals() {\n                debugln!(\"Validator::validate_arg_values: possible_vals={:?}\", p_vals);\n                let val_str = val.to_string_lossy();\n                let ok = if arg.is_set(ArgSettings::CaseInsensitive) {\n                    p_vals.iter().any(|pv| pv.eq_ignore_ascii_case(&*val_str))\n                } else {\n                    p_vals.contains(&&*val_str)\n                };\n                if !ok {\n                    return Err(Error::invalid_value(\n                        val_str,\n                        p_vals,\n                        arg,\n                        &*usage::create_error_usage(self.0, matcher, None),\n                        self.0.color(),\n                    ));\n                }\n            }\n            if !arg.is_set(ArgSettings::EmptyValues)\n                && val.is_empty()\n                && matcher.contains(&*arg.name())\n            {\n                debugln!(\"Validator::validate_arg_values: illegal empty val found\");\n                return Err(Error::empty_value(\n                    arg,\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n            if let Some(vtor) = arg.validator() {\n                debug!(\"Validator::validate_arg_values: checking validator...\");\n                if let Err(e) = vtor(val.to_string_lossy().into_owned()) {\n                    sdebugln!(\"error\");\n                    return Err(Error::value_validation(Some(arg), e, self.0.color()));\n                } else {\n                    sdebugln!(\"good\");\n                }\n            }\n            if let Some(vtor) = arg.validator_os() {\n                debug!(\"Validator::validate_arg_values: checking validator_os...\");\n                if let Err(e) = vtor(val) {\n                    sdebugln!(\"error\");\n                    return Err(Error::value_validation(\n                        Some(arg),\n                        (*e).to_string_lossy().to_string(),\n                        self.0.color(),\n                    ));\n                } else {\n                    sdebugln!(\"good\");\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn build_err(&self, name: &str, matcher: &ArgMatcher) -> ClapResult<()> {\n        debugln!(\"build_err!: name={}\", name);\n        let mut c_with = find_from!(self.0, &name, blacklist, matcher);\n        c_with = c_with.or(self\n            .0\n            .find_any_arg(name)\n            .map_or(None, |aa| aa.blacklist())\n            .map_or(None, |bl| bl.iter().find(|arg| matcher.contains(arg)))\n            .map_or(None, |an| self.0.find_any_arg(an))\n            .map_or(None, |aa| Some(format!(\"{}\", aa))));\n        debugln!(\"build_err!: '{:?}' conflicts with '{}'\", c_with, &name);\n        //        matcher.remove(&name);\n        let usg = usage::create_error_usage(self.0, matcher, None);\n        if let Some(f) = find_by_name!(self.0, name, flags, iter) {\n            debugln!(\"build_err!: It was a flag...\");\n            Err(Error::argument_conflict(f, c_with, &*usg, self.0.color()))\n        } else if let Some(o) = find_by_name!(self.0, name, opts, iter) {\n            debugln!(\"build_err!: It was an option...\");\n            Err(Error::argument_conflict(o, c_with, &*usg, self.0.color()))\n        } else {\n            match find_by_name!(self.0, name, positionals, values) {\n                Some(p) => {\n                    debugln!(\"build_err!: It was a positional...\");\n                    Err(Error::argument_conflict(p, c_with, &*usg, self.0.color()))\n                }\n                None => panic!(INTERNAL_ERROR_MSG),\n            }\n        }\n    }\n\n    fn validate_blacklist(&self, matcher: &mut ArgMatcher) -> ClapResult<()> {\n        debugln!(\"Validator::validate_blacklist;\");\n        let mut conflicts: Vec<&str> = vec![];\n        for (&name, _) in matcher.iter() {\n            debugln!(\"Validator::validate_blacklist:iter:{};\", name);\n            if let Some(grps) = self.0.groups_for_arg(name) {\n                for grp in &grps {\n                    if let Some(g) = self.0.groups.iter().find(|g| &g.name == grp) {\n                        if !g.multiple {\n                            for arg in &g.args {\n                                if arg == &name {\n                                    continue;\n                                }\n                                conflicts.push(arg);\n                            }\n                        }\n                        if let Some(ref gc) = g.conflicts {\n                            conflicts.extend(&*gc);\n                        }\n                    }\n                }\n            }\n            if let Some(arg) = find_any_by_name!(self.0, name) {\n                if let Some(bl) = arg.blacklist() {\n                    for conf in bl {\n                        if matcher.get(conf).is_some() {\n                            conflicts.push(conf);\n                        }\n                    }\n                }\n            } else {\n                debugln!(\"Validator::validate_blacklist:iter:{}:group;\", name);\n                let args = self.0.arg_names_in_group(name);\n                for arg in &args {\n                    debugln!(\n                        \"Validator::validate_blacklist:iter:{}:group:iter:{};\",\n                        name,\n                        arg\n                    );\n                    if let Some(bl) = find_any_by_name!(self.0, *arg).unwrap().blacklist() {\n                        for conf in bl {\n                            if matcher.get(conf).is_some() {\n                                conflicts.push(conf);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        for name in &conflicts {\n            debugln!(\n                \"Validator::validate_blacklist:iter:{}: Checking blacklisted arg\",\n                name\n            );\n            let mut should_err = false;\n            if self.0.groups.iter().any(|g| &g.name == name) {\n                debugln!(\n                    \"Validator::validate_blacklist:iter:{}: groups contains it...\",\n                    name\n                );\n                for n in self.0.arg_names_in_group(name) {\n                    debugln!(\n                        \"Validator::validate_blacklist:iter:{}:iter:{}: looking in group...\",\n                        name,\n                        n\n                    );\n                    if matcher.contains(n) {\n                        debugln!(\n                            \"Validator::validate_blacklist:iter:{}:iter:{}: matcher contains it...\",\n                            name,\n                            n\n                        );\n                        return self.build_err(n, matcher);\n                    }\n                }\n            } else if let Some(ma) = matcher.get(name) {\n                debugln!(\n                    \"Validator::validate_blacklist:iter:{}: matcher contains it...\",\n                    name\n                );\n                should_err = ma.occurs > 0;\n            }\n            if should_err {\n                return self.build_err(*name, matcher);\n            }\n        }\n        Ok(())\n    }\n\n    fn validate_matched_args(&self, matcher: &mut ArgMatcher<'a>) -> ClapResult<()> {\n        debugln!(\"Validator::validate_matched_args;\");\n        for (name, ma) in matcher.iter() {\n            debugln!(\n                \"Validator::validate_matched_args:iter:{}: vals={:#?}\",\n                name,\n                ma.vals\n            );\n            if let Some(opt) = find_by_name!(self.0, *name, opts, iter) {\n                self.validate_arg_num_vals(opt, ma, matcher)?;\n                self.validate_arg_values(opt, ma, matcher)?;\n                self.validate_arg_requires(opt, ma, matcher)?;\n                self.validate_arg_num_occurs(opt, ma, matcher)?;\n            } else if let Some(flag) = find_by_name!(self.0, *name, flags, iter) {\n                self.validate_arg_requires(flag, ma, matcher)?;\n                self.validate_arg_num_occurs(flag, ma, matcher)?;\n            } else if let Some(pos) = find_by_name!(self.0, *name, positionals, values) {\n                self.validate_arg_num_vals(pos, ma, matcher)?;\n                self.validate_arg_num_occurs(pos, ma, matcher)?;\n                self.validate_arg_values(pos, ma, matcher)?;\n                self.validate_arg_requires(pos, ma, matcher)?;\n            } else {\n                let grp = self\n                    .0\n                    .groups\n                    .iter()\n                    .find(|g| &g.name == name)\n                    .expect(INTERNAL_ERROR_MSG);\n                if let Some(ref g_reqs) = grp.requires {\n                    if g_reqs.iter().any(|&n| !matcher.contains(n)) {\n                        return self.missing_required_error(matcher, None);\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn validate_arg_num_occurs<A>(\n        &self,\n        a: &A,\n        ma: &MatchedArg,\n        matcher: &ArgMatcher,\n    ) -> ClapResult<()>\n    where\n        A: AnyArg<'a, 'b> + Display,\n    {\n        debugln!(\"Validator::validate_arg_num_occurs: a={};\", a.name());\n        if ma.occurs > 1 && !a.is_set(ArgSettings::Multiple) {\n            // Not the first time, and we don't allow multiples\n            return Err(Error::unexpected_multiple_usage(\n                a,\n                &*usage::create_error_usage(self.0, matcher, None),\n                self.0.color(),\n            ));\n        }\n        Ok(())\n    }\n\n    fn validate_arg_num_vals<A>(\n        &self,\n        a: &A,\n        ma: &MatchedArg,\n        matcher: &ArgMatcher,\n    ) -> ClapResult<()>\n    where\n        A: AnyArg<'a, 'b> + Display,\n    {\n        debugln!(\"Validator::validate_arg_num_vals:{}\", a.name());\n        if let Some(num) = a.num_vals() {\n            debugln!(\"Validator::validate_arg_num_vals: num_vals set...{}\", num);\n            let should_err = if a.is_set(ArgSettings::Multiple) {\n                ((ma.vals.len() as u64) % num) != 0\n            } else {\n                num != (ma.vals.len() as u64)\n            };\n            if should_err {\n                debugln!(\"Validator::validate_arg_num_vals: Sending error WrongNumberOfValues\");\n                return Err(Error::wrong_number_of_values(\n                    a,\n                    num,\n                    if a.is_set(ArgSettings::Multiple) {\n                        (ma.vals.len() % num as usize)\n                    } else {\n                        ma.vals.len()\n                    },\n                    if ma.vals.len() == 1\n                        || (a.is_set(ArgSettings::Multiple) && (ma.vals.len() % num as usize) == 1)\n                    {\n                        \"as\"\n                    } else {\n                        \"ere\"\n                    },\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n        }\n        if let Some(num) = a.max_vals() {\n            debugln!(\"Validator::validate_arg_num_vals: max_vals set...{}\", num);\n            if (ma.vals.len() as u64) > num {\n                debugln!(\"Validator::validate_arg_num_vals: Sending error TooManyValues\");\n                return Err(Error::too_many_values(\n                    ma.vals\n                        .iter()\n                        .last()\n                        .expect(INTERNAL_ERROR_MSG)\n                        .to_str()\n                        .expect(INVALID_UTF8),\n                    a,\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n        }\n        let min_vals_zero = if let Some(num) = a.min_vals() {\n            debugln!(\"Validator::validate_arg_num_vals: min_vals set: {}\", num);\n            if (ma.vals.len() as u64) < num && num != 0 {\n                debugln!(\"Validator::validate_arg_num_vals: Sending error TooFewValues\");\n                return Err(Error::too_few_values(\n                    a,\n                    num,\n                    ma.vals.len(),\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n            num == 0\n        } else {\n            false\n        };\n        // Issue 665 (https://github.com/clap-rs/clap/issues/665)\n        // Issue 1105 (https://github.com/clap-rs/clap/issues/1105)\n        if a.takes_value() && !min_vals_zero && ma.vals.is_empty() {\n            return Err(Error::empty_value(\n                a,\n                &*usage::create_error_usage(self.0, matcher, None),\n                self.0.color(),\n            ));\n        }\n        Ok(())\n    }\n\n    fn validate_arg_requires<A>(\n        &self,\n        a: &A,\n        ma: &MatchedArg,\n        matcher: &ArgMatcher,\n    ) -> ClapResult<()>\n    where\n        A: AnyArg<'a, 'b> + Display,\n    {\n        debugln!(\"Validator::validate_arg_requires:{};\", a.name());\n        if let Some(a_reqs) = a.requires() {\n            for &(val, name) in a_reqs.iter().filter(|&&(val, _)| val.is_some()) {\n                let missing_req =\n                    |v| v == val.expect(INTERNAL_ERROR_MSG) && !matcher.contains(name);\n                if ma.vals.iter().any(missing_req) {\n                    return self.missing_required_error(matcher, None);\n                }\n            }\n            for &(_, name) in a_reqs.iter().filter(|&&(val, _)| val.is_none()) {\n                if !matcher.contains(name) {\n                    return self.missing_required_error(matcher, Some(name));\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn validate_required(&mut self, matcher: &ArgMatcher) -> ClapResult<()> {\n        debugln!(\n            \"Validator::validate_required: required={:?};\",\n            self.0.required\n        );\n\n        let mut should_err = false;\n        let mut to_rem = Vec::new();\n        for name in &self.0.required {\n            debugln!(\"Validator::validate_required:iter:{}:\", name);\n            if matcher.contains(name) {\n                continue;\n            }\n            if to_rem.contains(name) {\n                continue;\n            } else if let Some(a) = find_any_by_name!(self.0, *name) {\n                if self.is_missing_required_ok(a, matcher) {\n                    to_rem.push(a.name());\n                    if let Some(reqs) = a.requires() {\n                        for r in reqs\n                            .iter()\n                            .filter(|&&(val, _)| val.is_none())\n                            .map(|&(_, name)| name)\n                        {\n                            to_rem.push(r);\n                        }\n                    }\n                    continue;\n                }\n            }\n            should_err = true;\n            break;\n        }\n        if should_err {\n            for r in &to_rem {\n                'inner: for i in (0..self.0.required.len()).rev() {\n                    if &self.0.required[i] == r {\n                        self.0.required.swap_remove(i);\n                        break 'inner;\n                    }\n                }\n            }\n            return self.missing_required_error(matcher, None);\n        }\n\n        // Validate the conditionally required args\n        for &(a, v, r) in &self.0.r_ifs {\n            if let Some(ma) = matcher.get(a) {\n                if matcher.get(r).is_none() && ma.vals.iter().any(|val| val == v) {\n                    return self.missing_required_error(matcher, Some(r));\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn validate_arg_conflicts(&self, a: &AnyArg, matcher: &ArgMatcher) -> Option<bool> {\n        debugln!(\"Validator::validate_arg_conflicts: a={:?};\", a.name());\n        a.blacklist().map(|bl| {\n            bl.iter().any(|conf| {\n                matcher.contains(conf)\n                    || self\n                        .0\n                        .groups\n                        .iter()\n                        .find(|g| &g.name == conf)\n                        .map_or(false, |g| g.args.iter().any(|arg| matcher.contains(arg)))\n            })\n        })\n    }\n\n    fn validate_required_unless(&self, a: &AnyArg, matcher: &ArgMatcher) -> Option<bool> {\n        debugln!(\"Validator::validate_required_unless: a={:?};\", a.name());\n        macro_rules! check {\n            ($how:ident, $_self:expr, $a:ident, $m:ident) => {{\n                $a.required_unless().map(|ru| {\n                    ru.iter().$how(|n| {\n                        $m.contains(n) || {\n                            if let Some(grp) = $_self.groups.iter().find(|g| &g.name == n) {\n                                grp.args.iter().any(|arg| $m.contains(arg))\n                            } else {\n                                false\n                            }\n                        }\n                    })\n                })\n            }};\n        }\n        if a.is_set(ArgSettings::RequiredUnlessAll) {\n            check!(all, self.0, a, matcher)\n        } else {\n            check!(any, self.0, a, matcher)\n        }\n    }\n\n    fn missing_required_error(&self, matcher: &ArgMatcher, extra: Option<&str>) -> ClapResult<()> {\n        debugln!(\"Validator::missing_required_error: extra={:?}\", extra);\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: self.0.color(),\n        });\n        let mut reqs = self.0.required.iter().map(|&r| &*r).collect::<Vec<_>>();\n        if let Some(r) = extra {\n            reqs.push(r);\n        }\n        reqs.retain(|n| !matcher.contains(n));\n        reqs.dedup();\n        debugln!(\"Validator::missing_required_error: reqs={:#?}\", reqs);\n        let req_args =\n            usage::get_required_usage_from(self.0, &reqs[..], Some(matcher), extra, true)\n                .iter()\n                .fold(String::new(), |acc, s| {\n                    acc + &format!(\"\\n    {}\", c.error(s))[..]\n                });\n        debugln!(\n            \"Validator::missing_required_error: req_args={:#?}\",\n            req_args\n        );\n        Err(Error::missing_required_argument(\n            &*req_args,\n            &*usage::create_error_usage(self.0, matcher, extra),\n            self.0.color(),\n        ))\n    }\n\n    #[inline]\n    fn is_missing_required_ok(&self, a: &AnyArg, matcher: &ArgMatcher) -> bool {\n        debugln!(\"Validator::is_missing_required_ok: a={}\", a.name());\n        self.validate_arg_conflicts(a, matcher).unwrap_or(false)\n            || self.validate_required_unless(a, matcher).unwrap_or(false)\n    }\n}"],"args::arg::Arg":["Clone","Default","impl<'a, 'b, 'z> From<&'z Arg<'a, 'b>> for Arg<'a, 'b> {\n    fn from(a: &'z Arg<'a, 'b>) -> Self {\n        Arg {\n            b: a.b.clone(),\n            v: a.v.clone(),\n            s: a.s.clone(),\n            index: a.index,\n            r_ifs: a.r_ifs.clone(),\n        }\n    }\n}","impl<'a, 'b> Arg<'a, 'b> {\n    /// Creates a new instance of [`Arg`] using a unique string name. The name will be used to get\n    /// information about whether or not the argument was used at runtime, get values, set\n    /// relationships with other args, etc..\n    ///\n    /// **NOTE:** In the case of arguments that take values (i.e. [`Arg::takes_value(true)`])\n    /// and positional arguments (i.e. those without a preceding `-` or `--`) the name will also\n    /// be displayed when the user prints the usage/help information of the program.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"config\")\n    /// # ;\n    /// ```\n    /// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n    /// [`Arg`]: ./struct.Arg.html\n    pub fn with_name(n: &'a str) -> Self {\n        Arg {\n            b: Base::new(n),\n            ..Default::default()\n        }\n    }\n\n    /// Creates a new instance of [`Arg`] from a .yml (YAML) file.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// # #[macro_use]\n    /// # extern crate clap;\n    /// # use clap::Arg;\n    /// # fn main() {\n    /// let yml = load_yaml!(\"arg.yml\");\n    /// let arg = Arg::from_yaml(yml);\n    /// # }\n    /// ```\n    /// [`Arg`]: ./struct.Arg.html\n    #[cfg(feature = \"yaml\")]\n    pub fn from_yaml(y: &BTreeMap<Yaml, Yaml>) -> Arg {\n        // We WANT this to panic on error...so expect() is good.\n        let name_yml = y.keys().nth(0).unwrap();\n        let name_str = name_yml.as_str().unwrap();\n        let mut a = Arg::with_name(name_str);\n        let arg_settings = y.get(name_yml).unwrap().as_hash().unwrap();\n\n        for (k, v) in arg_settings.iter() {\n            a = match k.as_str().unwrap() {\n                \"short\" => yaml_to_str!(a, v, short),\n                \"long\" => yaml_to_str!(a, v, long),\n                \"aliases\" => yaml_vec_or_str!(v, a, alias),\n                \"help\" => yaml_to_str!(a, v, help),\n                \"long_help\" => yaml_to_str!(a, v, long_help),\n                \"required\" => yaml_to_bool!(a, v, required),\n                \"required_if\" => yaml_tuple2!(a, v, required_if),\n                \"required_ifs\" => yaml_tuple2!(a, v, required_if),\n                \"takes_value\" => yaml_to_bool!(a, v, takes_value),\n                \"index\" => yaml_to_u64!(a, v, index),\n                \"global\" => yaml_to_bool!(a, v, global),\n                \"multiple\" => yaml_to_bool!(a, v, multiple),\n                \"hidden\" => yaml_to_bool!(a, v, hidden),\n                \"next_line_help\" => yaml_to_bool!(a, v, next_line_help),\n                \"empty_values\" => yaml_to_bool!(a, v, empty_values),\n                \"group\" => yaml_to_str!(a, v, group),\n                \"number_of_values\" => yaml_to_u64!(a, v, number_of_values),\n                \"max_values\" => yaml_to_u64!(a, v, max_values),\n                \"min_values\" => yaml_to_u64!(a, v, min_values),\n                \"value_name\" => yaml_to_str!(a, v, value_name),\n                \"use_delimiter\" => yaml_to_bool!(a, v, use_delimiter),\n                \"allow_hyphen_values\" => yaml_to_bool!(a, v, allow_hyphen_values),\n                \"last\" => yaml_to_bool!(a, v, last),\n                \"require_delimiter\" => yaml_to_bool!(a, v, require_delimiter),\n                \"value_delimiter\" => yaml_to_str!(a, v, value_delimiter),\n                \"required_unless\" => yaml_to_str!(a, v, required_unless),\n                \"display_order\" => yaml_to_usize!(a, v, display_order),\n                \"default_value\" => yaml_to_str!(a, v, default_value),\n                \"default_value_if\" => yaml_tuple3!(a, v, default_value_if),\n                \"default_value_ifs\" => yaml_tuple3!(a, v, default_value_if),\n                \"env\" => yaml_to_str!(a, v, env),\n                \"value_names\" => yaml_vec_or_str!(v, a, value_name),\n                \"groups\" => yaml_vec_or_str!(v, a, group),\n                \"requires\" => yaml_vec_or_str!(v, a, requires),\n                \"requires_if\" => yaml_tuple2!(a, v, requires_if),\n                \"requires_ifs\" => yaml_tuple2!(a, v, requires_if),\n                \"conflicts_with\" => yaml_vec_or_str!(v, a, conflicts_with),\n                \"overrides_with\" => yaml_vec_or_str!(v, a, overrides_with),\n                \"possible_values\" => yaml_vec_or_str!(v, a, possible_value),\n                \"case_insensitive\" => yaml_to_bool!(a, v, case_insensitive),\n                \"required_unless_one\" => yaml_vec_or_str!(v, a, required_unless),\n                \"required_unless_all\" => {\n                    a = yaml_vec_or_str!(v, a, required_unless);\n                    a.setb(ArgSettings::RequiredUnlessAll);\n                    a\n                }\n                s => panic!(\n                    \"Unknown Arg setting '{}' in YAML file for arg '{}'\",\n                    s, name_str\n                ),\n            }\n        }\n\n        a\n    }\n\n    /// Creates a new instance of [`Arg`] from a usage string. Allows creation of basic settings\n    /// for the [`Arg`]. The syntax is flexible, but there are some rules to follow.\n    ///\n    /// **NOTE**: Not all settings may be set using the usage string method. Some properties are\n    /// only available via the builder pattern.\n    ///\n    /// **NOTE**: Only ASCII values are officially supported in [`Arg::from_usage`] strings. Some\n    /// UTF-8 codepoints may work just fine, but this is not guaranteed.\n    ///\n    /// # Syntax\n    ///\n    /// Usage strings typically following the form:\n    ///\n    /// ```notrust\n    /// [explicit name] [short] [long] [value names] [help string]\n    /// ```\n    ///\n    /// This is not a hard rule as the attributes can appear in other orders. There are also\n    /// several additional sigils which denote additional settings. Below are the details of each\n    /// portion of the string.\n    ///\n    /// ### Explicit Name\n    ///\n    /// This is an optional field, if it's omitted the argument will use one of the additional\n    /// fields as the name using the following priority order:\n    ///\n    ///  * Explicit Name (This always takes precedence when present)\n    ///  * Long\n    ///  * Short\n    ///  * Value Name\n    ///\n    /// `clap` determines explicit names as the first string of characters between either `[]` or\n    /// `<>` where `[]` has the dual notation of meaning the argument is optional, and `<>` meaning\n    /// the argument is required.\n    ///\n    /// Explicit names may be followed by:\n    ///  * The multiple denotation `...`\n    ///\n    /// Example explicit names as follows (`ename` for an optional argument, and `rname` for a\n    /// required argument):\n    ///\n    /// ```notrust\n    /// [ename] -s, --long 'some flag'\n    /// <rname> -r, --longer 'some other flag'\n    /// ```\n    ///\n    /// ### Short\n    ///\n    /// This is set by placing a single character after a leading `-`.\n    ///\n    /// Shorts may be followed by\n    ///  * The multiple denotation `...`\n    ///  * An optional comma `,` which is cosmetic only\n    ///  * Value notation\n    ///\n    /// Example shorts are as follows (`-s`, and `-r`):\n    ///\n    /// ```notrust\n    /// -s, --long 'some flag'\n    /// <rname> -r [val], --longer 'some option'\n    /// ```\n    ///\n    /// ### Long\n    ///\n    /// This is set by placing a word (no spaces) after a leading `--`.\n    ///\n    /// Shorts may be followed by\n    ///  * The multiple denotation `...`\n    ///  * Value notation\n    ///\n    /// Example longs are as follows (`--some`, and `--rapid`):\n    ///\n    /// ```notrust\n    /// -s, --some 'some flag'\n    /// --rapid=[FILE] 'some option'\n    /// ```\n    ///\n    /// ### Values (Value Notation)\n    ///\n    /// This is set by placing a word(s) between `[]` or `<>` optionally after `=` (although this\n    /// is cosmetic only and does not affect functionality). If an explicit name has **not** been\n    /// set, using `<>` will denote a required argument, and `[]` will denote an optional argument\n    ///\n    /// Values may be followed by\n    ///  * The multiple denotation `...`\n    ///  * More Value notation\n    ///\n    /// More than one value will also implicitly set the arguments number of values, i.e. having\n    /// two values, `--option [val1] [val2]` specifies that in order for option to be satisified it\n    /// must receive exactly two values\n    ///\n    /// Example values are as follows (`FILE`, and `SPEED`):\n    ///\n    /// ```notrust\n    /// -s, --some [FILE] 'some option'\n    /// --rapid=<SPEED>... 'some required multiple option'\n    /// ```\n    ///\n    /// ### Help String\n    ///\n    /// The help string is denoted between a pair of single quotes `''` and may contain any\n    /// characters.\n    ///\n    /// Example help strings are as follows:\n    ///\n    /// ```notrust\n    /// -s, --some [FILE] 'some option'\n    /// --rapid=<SPEED>... 'some required multiple option'\n    /// ```\n    ///\n    /// ### Additional Sigils\n    ///\n    /// Multiple notation `...` (three consecutive dots/periods) specifies that this argument may\n    /// be used multiple times. Do not confuse multiple occurrences (`...`) with multiple values.\n    /// `--option val1 val2` is a single occurrence with multiple values. `--flag --flag` is\n    /// multiple occurrences (and then you can obviously have instances of both as well)\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// App::new(\"prog\")\n    ///     .args(&[\n    ///         Arg::from_usage(\"--config <FILE> 'a required file for the configuration and no short'\"),\n    ///         Arg::from_usage(\"-d, --debug... 'turns on debugging information and allows multiples'\"),\n    ///         Arg::from_usage(\"[input] 'an optional input file to use'\")\n    /// ])\n    /// # ;\n    /// ```\n    /// [`Arg`]: ./struct.Arg.html\n    /// [`Arg::from_usage`]: ./struct.Arg.html#method.from_usage\n    pub fn from_usage(u: &'a str) -> Self {\n        let parser = UsageParser::from_usage(u);\n        parser.parse()\n    }\n\n    /// Sets the short version of the argument without the preceding `-`.\n    ///\n    /// By default `clap` automatically assigns `V` and `h` to the auto-generated `version` and\n    /// `help` arguments respectively. You may use the uppercase `V` or lowercase `h` for your own\n    /// arguments, in which case `clap` simply will not assign those to the auto-generated\n    /// `version` or `help` arguments.\n    ///\n    /// **NOTE:** Any leading `-` characters will be stripped, and only the first\n    /// non `-` character will be used as the [`short`] version\n    ///\n    /// # Examples\n    ///\n    /// To set [`short`] use a single valid UTF-8 code point. If you supply a leading `-` such as\n    /// `-c`, the `-` will be stripped.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"config\")\n    ///     .short(\"c\")\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`short`] allows using the argument via a single hyphen (`-`) such as `-c`\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"config\")\n    ///         .short(\"c\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-c\"\n    ///     ]);\n    ///\n    /// assert!(m.is_present(\"config\"));\n    /// ```\n    /// [`short`]: ./struct.Arg.html#method.short\n    pub fn short<S: AsRef<str>>(mut self, s: S) -> Self {\n        self.s.short = s.as_ref().trim_left_matches(|c| c == '-').chars().nth(0);\n        self\n    }\n\n    /// Sets the long version of the argument without the preceding `--`.\n    ///\n    /// By default `clap` automatically assigns `version` and `help` to the auto-generated\n    /// `version` and `help` arguments respectively. You may use the word `version` or `help` for\n    /// the long form of your own arguments, in which case `clap` simply will not assign those to\n    /// the auto-generated `version` or `help` arguments.\n    ///\n    /// **NOTE:** Any leading `-` characters will be stripped\n    ///\n    /// # Examples\n    ///\n    /// To set `long` use a word containing valid UTF-8 codepoints. If you supply a double leading\n    /// `--` such as `--config` they will be stripped. Hyphens in the middle of the word, however,\n    /// will *not* be stripped (i.e. `config-file` is allowed)\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"cfg\")\n    ///     .long(\"config\")\n    /// # ;\n    /// ```\n    ///\n    /// Setting `long` allows using the argument via a double hyphen (`--`) such as `--config`\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .long(\"config\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--config\"\n    ///     ]);\n    ///\n    /// assert!(m.is_present(\"cfg\"));\n    /// ```\n    pub fn long(mut self, l: &'b str) -> Self {\n        self.s.long = Some(l.trim_left_matches(|c| c == '-'));\n        self\n    }\n\n    /// Allows adding a [`Arg`] alias, which function as \"hidden\" arguments that\n    /// automatically dispatch as if this argument was used. This is more efficient, and easier\n    /// than creating multiple hidden arguments as one only needs to check for the existence of\n    /// this command, and not all variants.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///             .arg(Arg::with_name(\"test\")\n    ///             .long(\"test\")\n    ///             .alias(\"alias\")\n    ///             .takes_value(true))\n    ///        .get_matches_from(vec![\n    ///             \"prog\", \"--alias\", \"cool\"\n    ///         ]);\n    /// assert!(m.is_present(\"test\"));\n    /// assert_eq!(m.value_of(\"test\"), Some(\"cool\"));\n    /// ```\n    /// [`Arg`]: ./struct.Arg.html\n    pub fn alias<S: Into<&'b str>>(mut self, name: S) -> Self {\n        if let Some(ref mut als) = self.s.aliases {\n            als.push((name.into(), false));\n        } else {\n            self.s.aliases = Some(vec![(name.into(), false)]);\n        }\n        self\n    }\n\n    /// Allows adding [`Arg`] aliases, which function as \"hidden\" arguments that\n    /// automatically dispatch as if this argument was used. This is more efficient, and easier\n    /// than creating multiple hidden subcommands as one only needs to check for the existence of\n    /// this command, and not all variants.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///             .arg(Arg::with_name(\"test\")\n    ///                     .long(\"test\")\n    ///                     .aliases(&[\"do-stuff\", \"do-tests\", \"tests\"])\n    ///                     .help(\"the file to add\")\n    ///                     .required(false))\n    ///             .get_matches_from(vec![\n    ///                 \"prog\", \"--do-tests\"\n    ///             ]);\n    /// assert!(m.is_present(\"test\"));\n    /// ```\n    /// [`Arg`]: ./struct.Arg.html\n    pub fn aliases(mut self, names: &[&'b str]) -> Self {\n        if let Some(ref mut als) = self.s.aliases {\n            for n in names {\n                als.push((n, false));\n            }\n        } else {\n            self.s.aliases = Some(names.iter().map(|n| (*n, false)).collect::<Vec<_>>());\n        }\n        self\n    }\n\n    /// Allows adding a [`Arg`] alias that functions exactly like those defined with\n    /// [`Arg::alias`], except that they are visible inside the help message.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///             .arg(Arg::with_name(\"test\")\n    ///                 .visible_alias(\"something-awesome\")\n    ///                 .long(\"test\")\n    ///                 .takes_value(true))\n    ///        .get_matches_from(vec![\n    ///             \"prog\", \"--something-awesome\", \"coffee\"\n    ///         ]);\n    /// assert!(m.is_present(\"test\"));\n    /// assert_eq!(m.value_of(\"test\"), Some(\"coffee\"));\n    /// ```\n    /// [`Arg`]: ./struct.Arg.html\n    /// [`App::alias`]: ./struct.Arg.html#method.alias\n    pub fn visible_alias<S: Into<&'b str>>(mut self, name: S) -> Self {\n        if let Some(ref mut als) = self.s.aliases {\n            als.push((name.into(), true));\n        } else {\n            self.s.aliases = Some(vec![(name.into(), true)]);\n        }\n        self\n    }\n\n    /// Allows adding multiple [`Arg`] aliases that functions exactly like those defined\n    /// with [`Arg::aliases`], except that they are visible inside the help message.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///             .arg(Arg::with_name(\"test\")\n    ///                 .long(\"test\")\n    ///                 .visible_aliases(&[\"something\", \"awesome\", \"cool\"]))\n    ///        .get_matches_from(vec![\n    ///             \"prog\", \"--awesome\"\n    ///         ]);\n    /// assert!(m.is_present(\"test\"));\n    /// ```\n    /// [`Arg`]: ./struct.Arg.html\n    /// [`App::aliases`]: ./struct.Arg.html#method.aliases\n    pub fn visible_aliases(mut self, names: &[&'b str]) -> Self {\n        if let Some(ref mut als) = self.s.aliases {\n            for n in names {\n                als.push((n, true));\n            }\n        } else {\n            self.s.aliases = Some(names.iter().map(|n| (*n, true)).collect::<Vec<_>>());\n        }\n        self\n    }\n\n    /// Sets the short help text of the argument that will be displayed to the user when they print\n    /// the help information with `-h`. Typically, this is a short (one line) description of the\n    /// arg.\n    ///\n    /// **NOTE:** If only `Arg::help` is provided, and not [`Arg::long_help`] but the user requests\n    /// `--help` clap will still display the contents of `help` appropriately\n    ///\n    /// **NOTE:** Only `Arg::help` is used in completion script generation in order to be concise\n    ///\n    /// # Examples\n    ///\n    /// Any valid UTF-8 is allowed in the help text. The one exception is when one wishes to\n    /// include a newline in the help text and have the following text be properly aligned with all\n    /// the other help text.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"config\")\n    ///     .help(\"The config file used by the myprog\")\n    /// # ;\n    /// ```\n    ///\n    /// Setting `help` displays a short message to the side of the argument when the user passes\n    /// `-h` or `--help` (by default).\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .long(\"config\")\n    ///         .help(\"Some help text describing the --config arg\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--help\"\n    ///     ]);\n    /// ```\n    ///\n    /// The above example displays\n    ///\n    /// ```notrust\n    /// helptest\n    ///\n    /// USAGE:\n    ///    helptest [FLAGS]\n    ///\n    /// FLAGS:\n    ///     --config     Some help text describing the --config arg\n    /// -h, --help       Prints help information\n    /// -V, --version    Prints version information\n    /// ```\n    /// [`Arg::long_help`]: ./struct.Arg.html#method.long_help\n    pub fn help(mut self, h: &'b str) -> Self {\n        self.b.help = Some(h);\n        self\n    }\n\n    /// Sets the long help text of the argument that will be displayed to the user when they print\n    /// the help information with `--help`. Typically this a more detailed (multi-line) message\n    /// that describes the arg.\n    ///\n    /// **NOTE:** If only `long_help` is provided, and not [`Arg::help`] but the user requests `-h`\n    /// clap will still display the contents of `long_help` appropriately\n    ///\n    /// **NOTE:** Only [`Arg::help`] is used in completion script generation in order to be concise\n    ///\n    /// # Examples\n    ///\n    /// Any valid UTF-8 is allowed in the help text. The one exception is when one wishes to\n    /// include a newline in the help text and have the following text be properly aligned with all\n    /// the other help text.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"config\")\n    ///     .long_help(\n    /// \"The config file used by the myprog must be in JSON format\n    /// with only valid keys and may not contain other nonsense\n    /// that cannot be read by this program. Obviously I'm going on\n    /// and on, so I'll stop now.\")\n    /// # ;\n    /// ```\n    ///\n    /// Setting `help` displays a short message to the side of the argument when the user passes\n    /// `-h` or `--help` (by default).\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .long(\"config\")\n    ///         .long_help(\n    /// \"The config file used by the myprog must be in JSON format\n    /// with only valid keys and may not contain other nonsense\n    /// that cannot be read by this program. Obviously I'm going on\n    /// and on, so I'll stop now.\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--help\"\n    ///     ]);\n    /// ```\n    ///\n    /// The above example displays\n    ///\n    /// ```notrust\n    /// helptest\n    ///\n    /// USAGE:\n    ///    helptest [FLAGS]\n    ///\n    /// FLAGS:\n    ///    --config\n    ///         The config file used by the myprog must be in JSON format\n    ///         with only valid keys and may not contain other nonsense\n    ///         that cannot be read by this program. Obviously I'm going on\n    ///         and on, so I'll stop now.\n    ///\n    /// -h, --help\n    ///         Prints help information\n    ///\n    /// -V, --version\n    ///         Prints version information\n    /// ```\n    /// [`Arg::help`]: ./struct.Arg.html#method.help\n    pub fn long_help(mut self, h: &'b str) -> Self {\n        self.b.long_help = Some(h);\n        self\n    }\n\n    /// Specifies that this arg is the last, or final, positional argument (i.e. has the highest\n    /// index) and is *only* able to be accessed via the `--` syntax (i.e. `$ prog args --\n    /// last_arg`). Even, if no other arguments are left to parse, if the user omits the `--` syntax\n    /// they will receive an [`UnknownArgument`] error. Setting an argument to `.last(true)` also\n    /// allows one to access this arg early using the `--` syntax. Accessing an arg early, even with\n    /// the `--` syntax is otherwise not possible.\n    ///\n    /// **NOTE:** This will change the usage string to look like `$ prog [FLAGS] [-- <ARG>]` if\n    /// `ARG` is marked as `.last(true)`.\n    ///\n    /// **NOTE:** This setting will imply [`AppSettings::DontCollapseArgsInUsage`] because failing\n    /// to set this can make the usage string very confusing.\n    ///\n    /// **NOTE**: This setting only applies to positional arguments, and has no affect on FLAGS /\n    /// OPTIONS\n    ///\n    /// **CAUTION:** Setting an argument to `.last(true)` *and* having child subcommands is not\n    /// recommended with the exception of *also* using [`AppSettings::ArgsNegateSubcommands`]\n    /// (or [`AppSettings::SubcommandsNegateReqs`] if the argument marked `.last(true)` is also\n    /// marked [`.required(true)`])\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"args\")\n    ///     .last(true)\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::last(true)`] ensures the arg has the highest [index] of all positional args\n    /// and requires that the `--` syntax be used to access it early.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"first\"))\n    ///     .arg(Arg::with_name(\"second\"))\n    ///     .arg(Arg::with_name(\"third\").last(true))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"one\", \"--\", \"three\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok());\n    /// let m = res.unwrap();\n    /// assert_eq!(m.value_of(\"third\"), Some(\"three\"));\n    /// assert!(m.value_of(\"second\").is_none());\n    /// ```\n    ///\n    /// Even if the positional argument marked `.last(true)` is the only argument left to parse,\n    /// failing to use the `--` syntax results in an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"first\"))\n    ///     .arg(Arg::with_name(\"second\"))\n    ///     .arg(Arg::with_name(\"third\").last(true))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"one\", \"two\", \"three\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::UnknownArgument);\n    /// ```\n    /// [`Arg::last(true)`]: ./struct.Arg.html#method.last\n    /// [index]: ./struct.Arg.html#method.index\n    /// [`AppSettings::DontCollapseArgsInUsage`]: ./enum.AppSettings.html#variant.DontCollapseArgsInUsage\n    /// [`AppSettings::ArgsNegateSubcommands`]: ./enum.AppSettings.html#variant.ArgsNegateSubcommands\n    /// [`AppSettings::SubcommandsNegateReqs`]: ./enum.AppSettings.html#variant.SubcommandsNegateReqs\n    /// [`.required(true)`]: ./struct.Arg.html#method.required\n    /// [`UnknownArgument`]: ./enum.ErrorKind.html#variant.UnknownArgument\n    pub fn last(self, l: bool) -> Self {\n        if l {\n            self.set(ArgSettings::Last)\n        } else {\n            self.unset(ArgSettings::Last)\n        }\n    }\n\n    /// Sets whether or not the argument is required by default. Required by default means it is\n    /// required, when no other conflicting rules have been evaluated. Conflicting rules take\n    /// precedence over being required. **Default:** `false`\n    ///\n    /// **NOTE:** Flags (i.e. not positional, or arguments that take values) cannot be required by\n    /// default. This is simply because if a flag should be required, it should simply be implied\n    /// as no additional information is required from user. Flags by their very nature are simply\n    /// yes/no, or true/false.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .required(true)\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::required(true)`] requires that the argument be used at runtime.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .required(true)\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--config\", \"file.conf\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok());\n    /// ```\n    ///\n    /// Setting [`Arg::required(true)`] and *not* supplying that argument is an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .required(true)\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [`Arg::required(true)`]: ./struct.Arg.html#method.required\n    pub fn required(self, r: bool) -> Self {\n        if r {\n            self.set(ArgSettings::Required)\n        } else {\n            self.unset(ArgSettings::Required)\n        }\n    }\n\n    /// Requires that options use the `--option=val` syntax (i.e. an equals between the option and\n    /// associated value) **Default:** `false`\n    ///\n    /// **NOTE:** This setting also removes the default of allowing empty values and implies\n    /// [`Arg::empty_values(false)`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .long(\"config\")\n    ///     .takes_value(true)\n    ///     .require_equals(true)\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::require_equals(true)`] requires that the option have an equals sign between\n    /// it and the associated value.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .require_equals(true)\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--config=file.conf\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok());\n    /// ```\n    ///\n    /// Setting [`Arg::require_equals(true)`] and *not* supplying the equals will cause an error\n    /// unless [`Arg::empty_values(true)`] is set.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .require_equals(true)\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--config\", \"file.conf\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::EmptyValue);\n    /// ```\n    /// [`Arg::require_equals(true)`]: ./struct.Arg.html#method.require_equals\n    /// [`Arg::empty_values(true)`]: ./struct.Arg.html#method.empty_values\n    /// [`Arg::empty_values(false)`]: ./struct.Arg.html#method.empty_values\n    pub fn require_equals(mut self, r: bool) -> Self {\n        if r {\n            self.unsetb(ArgSettings::EmptyValues);\n            self.set(ArgSettings::RequireEquals)\n        } else {\n            self.unset(ArgSettings::RequireEquals)\n        }\n    }\n\n    /// Allows values which start with a leading hyphen (`-`)\n    ///\n    /// **WARNING**: Take caution when using this setting combined with [`Arg::multiple(true)`], as\n    /// this becomes ambiguous `$ prog --arg -- -- val`. All three `--, --, val` will be values\n    /// when the user may have thought the second `--` would constitute the normal, \"Only\n    /// positional args follow\" idiom. To fix this, consider using [`Arg::number_of_values(1)`]\n    ///\n    /// **WARNING**: When building your CLIs, consider the effects of allowing leading hyphens and\n    /// the user passing in a value that matches a valid short. For example `prog -opt -F` where\n    /// `-F` is supposed to be a value, yet `-F` is *also* a valid short for another arg. Care should\n    /// should be taken when designing these args. This is compounded by the ability to \"stack\"\n    /// short args. I.e. if `-val` is supposed to be a value, but `-v`, `-a`, and `-l` are all valid\n    /// shorts.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"pattern\")\n    ///     .allow_hyphen_values(true)\n    /// # ;\n    /// ```\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"pat\")\n    ///         .allow_hyphen_values(true)\n    ///         .takes_value(true)\n    ///         .long(\"pattern\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--pattern\", \"-file\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"pat\"), Some(\"-file\"));\n    /// ```\n    ///\n    /// Not setting [`Arg::allow_hyphen_values(true)`] and supplying a value which starts with a\n    /// hyphen is an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"pat\")\n    ///         .takes_value(true)\n    ///         .long(\"pattern\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--pattern\", \"-file\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::UnknownArgument);\n    /// ```\n    /// [`Arg::allow_hyphen_values(true)`]: ./struct.Arg.html#method.allow_hyphen_values\n    /// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n    /// [`Arg::number_of_values(1)`]: ./struct.Arg.html#method.number_of_values\n    pub fn allow_hyphen_values(self, a: bool) -> Self {\n        if a {\n            self.set(ArgSettings::AllowLeadingHyphen)\n        } else {\n            self.unset(ArgSettings::AllowLeadingHyphen)\n        }\n    }\n    /// Sets an arg that override this arg's required setting. (i.e. this arg will be required\n    /// unless this other argument is present).\n    ///\n    /// **Pro Tip:** Using [`Arg::required_unless`] implies [`Arg::required`] and is therefore not\n    /// mandatory to also set.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .required_unless(\"debug\")\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::required_unless(name)`] requires that the argument be used at runtime\n    /// *unless* `name` is present. In the following example, the required argument is *not*\n    /// provided, but it's not an error because the `unless` arg has been supplied.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .required_unless(\"dbg\")\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"dbg\")\n    ///         .long(\"debug\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--debug\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok());\n    /// ```\n    ///\n    /// Setting [`Arg::required_unless(name)`] and *not* supplying `name` or this arg is an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .required_unless(\"dbg\")\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"dbg\")\n    ///         .long(\"debug\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [`Arg::required_unless`]: ./struct.Arg.html#method.required_unless\n    /// [`Arg::required`]: ./struct.Arg.html#method.required\n    /// [`Arg::required_unless(name)`]: ./struct.Arg.html#method.required_unless\n    pub fn required_unless(mut self, name: &'a str) -> Self {\n        if let Some(ref mut vec) = self.b.r_unless {\n            vec.push(name);\n        } else {\n            self.b.r_unless = Some(vec![name]);\n        }\n        self.required(true)\n    }\n\n    /// Sets args that override this arg's required setting. (i.e. this arg will be required unless\n    /// all these other arguments are present).\n    ///\n    /// **NOTE:** If you wish for this argument to only be required if *one of* these args are\n    /// present see [`Arg::required_unless_one`]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .required_unless_all(&[\"cfg\", \"dbg\"])\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::required_unless_all(names)`] requires that the argument be used at runtime\n    /// *unless* *all* the args in `names` are present. In the following example, the required\n    /// argument is *not* provided, but it's not an error because all the `unless` args have been\n    /// supplied.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .required_unless_all(&[\"dbg\", \"infile\"])\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"dbg\")\n    ///         .long(\"debug\"))\n    ///     .arg(Arg::with_name(\"infile\")\n    ///         .short(\"i\")\n    ///         .takes_value(true))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--debug\", \"-i\", \"file\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok());\n    /// ```\n    ///\n    /// Setting [`Arg::required_unless_all(names)`] and *not* supplying *all* of `names` or this\n    /// arg is an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .required_unless_all(&[\"dbg\", \"infile\"])\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"dbg\")\n    ///         .long(\"debug\"))\n    ///     .arg(Arg::with_name(\"infile\")\n    ///         .short(\"i\")\n    ///         .takes_value(true))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [`Arg::required_unless_one`]: ./struct.Arg.html#method.required_unless_one\n    /// [`Arg::required_unless_all(names)`]: ./struct.Arg.html#method.required_unless_all\n    pub fn required_unless_all(mut self, names: &[&'a str]) -> Self {\n        if let Some(ref mut vec) = self.b.r_unless {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.b.r_unless = Some(names.iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self.setb(ArgSettings::RequiredUnlessAll);\n        self.required(true)\n    }\n\n    /// Sets args that override this arg's [required] setting. (i.e. this arg will be required\n    /// unless *at least one of* these other arguments are present).\n    ///\n    /// **NOTE:** If you wish for this argument to only be required if *all of* these args are\n    /// present see [`Arg::required_unless_all`]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .required_unless_all(&[\"cfg\", \"dbg\"])\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::required_unless_one(names)`] requires that the argument be used at runtime\n    /// *unless* *at least one of* the args in `names` are present. In the following example, the\n    /// required argument is *not* provided, but it's not an error because one the `unless` args\n    /// have been supplied.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .required_unless_one(&[\"dbg\", \"infile\"])\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"dbg\")\n    ///         .long(\"debug\"))\n    ///     .arg(Arg::with_name(\"infile\")\n    ///         .short(\"i\")\n    ///         .takes_value(true))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--debug\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok());\n    /// ```\n    ///\n    /// Setting [`Arg::required_unless_one(names)`] and *not* supplying *at least one of* `names`\n    /// or this arg is an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .required_unless_one(&[\"dbg\", \"infile\"])\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"dbg\")\n    ///         .long(\"debug\"))\n    ///     .arg(Arg::with_name(\"infile\")\n    ///         .short(\"i\")\n    ///         .takes_value(true))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [required]: ./struct.Arg.html#method.required\n    /// [`Arg::required_unless_one(names)`]: ./struct.Arg.html#method.required_unless_one\n    /// [`Arg::required_unless_all`]: ./struct.Arg.html#method.required_unless_all\n    pub fn required_unless_one(mut self, names: &[&'a str]) -> Self {\n        if let Some(ref mut vec) = self.b.r_unless {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.b.r_unless = Some(names.iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self.required(true)\n    }\n\n    /// Sets a conflicting argument by name. I.e. when using this argument,\n    /// the following argument can't be present and vice versa.\n    ///\n    /// **NOTE:** Conflicting rules take precedence over being required by default. Conflict rules\n    /// only need to be set for one of the two arguments, they do not need to be set for each.\n    ///\n    /// **NOTE:** Defining a conflict is two-way, but does *not* need to defined for both arguments\n    /// (i.e. if A conflicts with B, defining A.conflicts_with(B) is sufficient. You do not need\n    /// need to also do B.conflicts_with(A))\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .conflicts_with(\"debug\")\n    /// # ;\n    /// ```\n    ///\n    /// Setting conflicting argument, and having both arguments present at runtime is an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .takes_value(true)\n    ///         .conflicts_with(\"debug\")\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .long(\"debug\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--debug\", \"--config\", \"file.conf\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::ArgumentConflict);\n    /// ```\n    pub fn conflicts_with(mut self, name: &'a str) -> Self {\n        if let Some(ref mut vec) = self.b.blacklist {\n            vec.push(name);\n        } else {\n            self.b.blacklist = Some(vec![name]);\n        }\n        self\n    }\n\n    /// The same as [`Arg::conflicts_with`] but allows specifying multiple two-way conlicts per\n    /// argument.\n    ///\n    /// **NOTE:** Conflicting rules take precedence over being required by default. Conflict rules\n    /// only need to be set for one of the two arguments, they do not need to be set for each.\n    ///\n    /// **NOTE:** Defining a conflict is two-way, but does *not* need to defined for both arguments\n    /// (i.e. if A conflicts with B, defining A.conflicts_with(B) is sufficient. You do not need\n    /// need to also do B.conflicts_with(A))\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .conflicts_with_all(&[\"debug\", \"input\"])\n    /// # ;\n    /// ```\n    ///\n    /// Setting conflicting argument, and having any of the arguments present at runtime with a\n    /// conflicting argument is an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .takes_value(true)\n    ///         .conflicts_with_all(&[\"debug\", \"input\"])\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .long(\"debug\"))\n    ///     .arg(Arg::with_name(\"input\")\n    ///         .index(1))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--config\", \"file.conf\", \"file.txt\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::ArgumentConflict);\n    /// ```\n    /// [`Arg::conflicts_with`]: ./struct.Arg.html#method.conflicts_with\n    pub fn conflicts_with_all(mut self, names: &[&'a str]) -> Self {\n        if let Some(ref mut vec) = self.b.blacklist {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.b.blacklist = Some(names.iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self\n    }\n\n    /// Sets a overridable argument by name. I.e. this argument and the following argument\n    /// will override each other in POSIX style (whichever argument was specified at runtime\n    /// **last** \"wins\")\n    ///\n    /// **NOTE:** When an argument is overridden it is essentially as if it never was used, any\n    /// conflicts, requirements, etc. are evaluated **after** all \"overrides\" have been removed\n    ///\n    /// **WARNING:** Positional arguments cannot override themselves (or we would never be able\n    /// to advance to the next positional). If a positional agument lists itself as an override,\n    /// it is simply ignored.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::from_usage(\"-f, --flag 'some flag'\")\n    ///         .conflicts_with(\"debug\"))\n    ///     .arg(Arg::from_usage(\"-d, --debug 'other flag'\"))\n    ///     .arg(Arg::from_usage(\"-c, --color 'third flag'\")\n    ///         .overrides_with(\"flag\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-f\", \"-d\", \"-c\"]);\n    ///             //    ^~~~~~~~~~~~^~~~~ flag is overridden by color\n    ///\n    /// assert!(m.is_present(\"color\"));\n    /// assert!(m.is_present(\"debug\")); // even though flag conflicts with debug, it's as if flag\n    ///                                 // was never used because it was overridden with color\n    /// assert!(!m.is_present(\"flag\"));\n    /// ```\n    /// Care must be taken when using this setting, and having an arg override with itself. This\n    /// is common practice when supporting things like shell aliases, config files, etc.\n    /// However, when combined with multiple values, it can get dicy.\n    /// Here is how clap handles such situations:\n    ///\n    /// When a flag overrides itself, it's as if the flag was only ever used once (essentially\n    /// preventing a \"Unexpected multiple usage\" error):\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"posix\")\n    ///             .arg(Arg::from_usage(\"--flag  'some flag'\").overrides_with(\"flag\"))\n    ///             .get_matches_from(vec![\"posix\", \"--flag\", \"--flag\"]);\n    /// assert!(m.is_present(\"flag\"));\n    /// assert_eq!(m.occurrences_of(\"flag\"), 1);\n    /// ```\n    /// Making a arg `multiple(true)` and override itself is essentially meaningless. Therefore\n    /// clap ignores an override of self if it's a flag and it already accepts multiple occurrences.\n    ///\n    /// ```\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"posix\")\n    ///             .arg(Arg::from_usage(\"--flag...  'some flag'\").overrides_with(\"flag\"))\n    ///             .get_matches_from(vec![\"\", \"--flag\", \"--flag\", \"--flag\", \"--flag\"]);\n    /// assert!(m.is_present(\"flag\"));\n    /// assert_eq!(m.occurrences_of(\"flag\"), 4);\n    /// ```\n    /// Now notice with options (which *do not* set `multiple(true)`), it's as if only the last\n    /// occurrence happened.\n    ///\n    /// ```\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"posix\")\n    ///             .arg(Arg::from_usage(\"--opt [val] 'some option'\").overrides_with(\"opt\"))\n    ///             .get_matches_from(vec![\"\", \"--opt=some\", \"--opt=other\"]);\n    /// assert!(m.is_present(\"opt\"));\n    /// assert_eq!(m.occurrences_of(\"opt\"), 1);\n    /// assert_eq!(m.value_of(\"opt\"), Some(\"other\"));\n    /// ```\n    ///\n    /// Just like flags, options with `multiple(true)` set, will ignore the \"override self\" setting.\n    ///\n    /// ```\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"posix\")\n    ///             .arg(Arg::from_usage(\"--opt [val]... 'some option'\")\n    ///                 .overrides_with(\"opt\"))\n    ///             .get_matches_from(vec![\"\", \"--opt\", \"first\", \"over\", \"--opt\", \"other\", \"val\"]);\n    /// assert!(m.is_present(\"opt\"));\n    /// assert_eq!(m.occurrences_of(\"opt\"), 2);\n    /// assert_eq!(m.values_of(\"opt\").unwrap().collect::<Vec<_>>(), &[\"first\", \"over\", \"other\", \"val\"]);\n    /// ```\n    ///\n    /// A safe thing to do if you'd like to support an option which supports multiple values, but\n    /// also is \"overridable\" by itself, is to use `use_delimiter(false)` and *not* use\n    /// `multiple(true)` while telling users to seperate values with a comma (i.e. `val1,val2`)\n    ///\n    /// ```\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"posix\")\n    ///             .arg(Arg::from_usage(\"--opt [val] 'some option'\")\n    ///                 .overrides_with(\"opt\")\n    ///                 .use_delimiter(false))\n    ///             .get_matches_from(vec![\"\", \"--opt=some,other\", \"--opt=one,two\"]);\n    /// assert!(m.is_present(\"opt\"));\n    /// assert_eq!(m.occurrences_of(\"opt\"), 1);\n    /// assert_eq!(m.values_of(\"opt\").unwrap().collect::<Vec<_>>(), &[\"one,two\"]);\n    /// ```\n    pub fn overrides_with(mut self, name: &'a str) -> Self {\n        if let Some(ref mut vec) = self.b.overrides {\n            vec.push(name);\n        } else {\n            self.b.overrides = Some(vec![name]);\n        }\n        self\n    }\n\n    /// Sets multiple mutually overridable arguments by name. I.e. this argument and the following\n    /// argument will override each other in POSIX style (whichever argument was specified at\n    /// runtime **last** \"wins\")\n    ///\n    /// **NOTE:** When an argument is overridden it is essentially as if it never was used, any\n    /// conflicts, requirements, etc. are evaluated **after** all \"overrides\" have been removed\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::from_usage(\"-f, --flag 'some flag'\")\n    ///         .conflicts_with(\"color\"))\n    ///     .arg(Arg::from_usage(\"-d, --debug 'other flag'\"))\n    ///     .arg(Arg::from_usage(\"-c, --color 'third flag'\")\n    ///         .overrides_with_all(&[\"flag\", \"debug\"]))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-f\", \"-d\", \"-c\"]);\n    ///             //    ^~~~~~^~~~~~~~~ flag and debug are overridden by color\n    ///\n    /// assert!(m.is_present(\"color\")); // even though flag conflicts with color, it's as if flag\n    ///                                 // and debug were never used because they were overridden\n    ///                                 // with color\n    /// assert!(!m.is_present(\"debug\"));\n    /// assert!(!m.is_present(\"flag\"));\n    /// ```\n    pub fn overrides_with_all(mut self, names: &[&'a str]) -> Self {\n        if let Some(ref mut vec) = self.b.overrides {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.b.overrides = Some(names.iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self\n    }\n\n    /// Sets an argument by name that is required when this one is present I.e. when\n    /// using this argument, the following argument *must* be present.\n    ///\n    /// **NOTE:** [Conflicting] rules and [override] rules take precedence over being required\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .requires(\"input\")\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::requires(name)`] requires that the argument be used at runtime if the\n    /// defining argument is used. If the defining argument isn't used, the other argument isn't\n    /// required\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .takes_value(true)\n    ///         .requires(\"input\")\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"input\")\n    ///         .index(1))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok()); // We didn't use cfg, so input wasn't required\n    /// ```\n    ///\n    /// Setting [`Arg::requires(name)`] and *not* supplying that argument is an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .takes_value(true)\n    ///         .requires(\"input\")\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"input\")\n    ///         .index(1))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--config\", \"file.conf\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [`Arg::requires(name)`]: ./struct.Arg.html#method.requires\n    /// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n    /// [override]: ./struct.Arg.html#method.overrides_with\n    pub fn requires(mut self, name: &'a str) -> Self {\n        if let Some(ref mut vec) = self.b.requires {\n            vec.push((None, name));\n        } else {\n            let mut vec = vec![];\n            vec.push((None, name));\n            self.b.requires = Some(vec);\n        }\n        self\n    }\n\n    /// Allows a conditional requirement. The requirement will only become valid if this arg's value\n    /// equals `val`.\n    ///\n    /// **NOTE:** If using YAML the values should be laid out as follows\n    ///\n    /// ```yaml\n    /// requires_if:\n    ///     - [val, arg]\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .requires_if(\"val\", \"arg\")\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::requires_if(val, arg)`] requires that the `arg` be used at runtime if the\n    /// defining argument's value is equal to `val`. If the defining argument is anything other than\n    /// `val`, the other argument isn't required.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .takes_value(true)\n    ///         .requires_if(\"my.cfg\", \"other\")\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"other\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--config\", \"some.cfg\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok()); // We didn't use --config=my.cfg, so other wasn't required\n    /// ```\n    ///\n    /// Setting [`Arg::requires_if(val, arg)`] and setting the value to `val` but *not* supplying\n    /// `arg` is an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .takes_value(true)\n    ///         .requires_if(\"my.cfg\", \"input\")\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"input\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--config\", \"my.cfg\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [`Arg::requires(name)`]: ./struct.Arg.html#method.requires\n    /// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n    /// [override]: ./struct.Arg.html#method.overrides_with\n    pub fn requires_if(mut self, val: &'b str, arg: &'a str) -> Self {\n        if let Some(ref mut vec) = self.b.requires {\n            vec.push((Some(val), arg));\n        } else {\n            self.b.requires = Some(vec![(Some(val), arg)]);\n        }\n        self\n    }\n\n    /// Allows multiple conditional requirements. The requirement will only become valid if this arg's value\n    /// equals `val`.\n    ///\n    /// **NOTE:** If using YAML the values should be laid out as follows\n    ///\n    /// ```yaml\n    /// requires_if:\n    ///     - [val, arg]\n    ///     - [val2, arg2]\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .requires_ifs(&[\n    ///         (\"val\", \"arg\"),\n    ///         (\"other_val\", \"arg2\"),\n    ///     ])\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::requires_ifs(&[\"val\", \"arg\"])`] requires that the `arg` be used at runtime if the\n    /// defining argument's value is equal to `val`. If the defining argument's value is anything other\n    /// than `val`, `arg` isn't required.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .takes_value(true)\n    ///         .requires_ifs(&[\n    ///             (\"special.conf\", \"opt\"),\n    ///             (\"other.conf\", \"other\"),\n    ///         ])\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"opt\")\n    ///         .long(\"option\")\n    ///         .takes_value(true))\n    ///     .arg(Arg::with_name(\"other\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--config\", \"special.conf\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err()); // We  used --config=special.conf so --option <val> is required\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [`Arg::requires(name)`]: ./struct.Arg.html#method.requires\n    /// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n    /// [override]: ./struct.Arg.html#method.overrides_with\n    pub fn requires_ifs(mut self, ifs: &[(&'b str, &'a str)]) -> Self {\n        if let Some(ref mut vec) = self.b.requires {\n            for &(val, arg) in ifs {\n                vec.push((Some(val), arg));\n            }\n        } else {\n            let mut vec = vec![];\n            for &(val, arg) in ifs {\n                vec.push((Some(val), arg));\n            }\n            self.b.requires = Some(vec);\n        }\n        self\n    }\n\n    /// Allows specifying that an argument is [required] conditionally. The requirement will only\n    /// become valid if the specified `arg`'s value equals `val`.\n    ///\n    /// **NOTE:** If using YAML the values should be laid out as follows\n    ///\n    /// ```yaml\n    /// required_if:\n    ///     - [arg, val]\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .required_if(\"other_arg\", \"value\")\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::required_if(arg, val)`] makes this arg required if the `arg` is used at\n    /// runtime and it's value is equal to `val`. If the `arg`'s value is anything other than `val`,\n    /// this argument isn't required.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .takes_value(true)\n    ///         .required_if(\"other\", \"special\")\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"other\")\n    ///         .long(\"other\")\n    ///         .takes_value(true))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--other\", \"not-special\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok()); // We didn't use --other=special, so \"cfg\" wasn't required\n    /// ```\n    ///\n    /// Setting [`Arg::required_if(arg, val)`] and having `arg` used with a value of `val` but *not*\n    /// using this arg is an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .takes_value(true)\n    ///         .required_if(\"other\", \"special\")\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"other\")\n    ///         .long(\"other\")\n    ///         .takes_value(true))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--other\", \"special\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [`Arg::requires(name)`]: ./struct.Arg.html#method.requires\n    /// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n    /// [required]: ./struct.Arg.html#method.required\n    pub fn required_if(mut self, arg: &'a str, val: &'b str) -> Self {\n        if let Some(ref mut vec) = self.r_ifs {\n            vec.push((arg, val));\n        } else {\n            self.r_ifs = Some(vec![(arg, val)]);\n        }\n        self\n    }\n\n    /// Allows specifying that an argument is [required] based on multiple conditions. The\n    /// conditions are set up in a `(arg, val)` style tuple. The requirement will only become valid\n    /// if one of the specified `arg`'s value equals it's corresponding `val`.\n    ///\n    /// **NOTE:** If using YAML the values should be laid out as follows\n    ///\n    /// ```yaml\n    /// required_if:\n    ///     - [arg, val]\n    ///     - [arg2, val2]\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .required_ifs(&[\n    ///         (\"extra\", \"val\"),\n    ///         (\"option\", \"spec\")\n    ///     ])\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::required_ifs(&[(arg, val)])`] makes this arg required if any of the `arg`s\n    /// are used at runtime and it's corresponding value is equal to `val`. If the `arg`'s value is\n    /// anything other than `val`, this argument isn't required.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .required_ifs(&[\n    ///             (\"extra\", \"val\"),\n    ///             (\"option\", \"spec\")\n    ///         ])\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"extra\")\n    ///         .takes_value(true)\n    ///         .long(\"extra\"))\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .takes_value(true)\n    ///         .long(\"option\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--option\", \"other\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok()); // We didn't use --option=spec, or --extra=val so \"cfg\" isn't required\n    /// ```\n    ///\n    /// Setting [`Arg::required_ifs(&[(arg, val)])`] and having any of the `arg`s used with it's\n    /// value of `val` but *not* using this arg is an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .required_ifs(&[\n    ///             (\"extra\", \"val\"),\n    ///             (\"option\", \"spec\")\n    ///         ])\n    ///         .takes_value(true)\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"extra\")\n    ///         .takes_value(true)\n    ///         .long(\"extra\"))\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .takes_value(true)\n    ///         .long(\"option\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--option\", \"spec\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [`Arg::requires(name)`]: ./struct.Arg.html#method.requires\n    /// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n    /// [required]: ./struct.Arg.html#method.required\n    pub fn required_ifs(mut self, ifs: &[(&'a str, &'b str)]) -> Self {\n        if let Some(ref mut vec) = self.r_ifs {\n            for r_if in ifs {\n                vec.push((r_if.0, r_if.1));\n            }\n        } else {\n            let mut vec = vec![];\n            for r_if in ifs {\n                vec.push((r_if.0, r_if.1));\n            }\n            self.r_ifs = Some(vec);\n        }\n        self\n    }\n\n    /// Sets multiple arguments by names that are required when this one is present I.e. when\n    /// using this argument, the following arguments *must* be present.\n    ///\n    /// **NOTE:** [Conflicting] rules and [override] rules take precedence over being required\n    /// by default.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::Arg;\n    /// Arg::with_name(\"config\")\n    ///     .requires_all(&[\"input\", \"output\"])\n    /// # ;\n    /// ```\n    ///\n    /// Setting [`Arg::requires_all(&[arg, arg2])`] requires that all the arguments be used at\n    /// runtime if the defining argument is used. If the defining argument isn't used, the other\n    /// argument isn't required\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .takes_value(true)\n    ///         .requires(\"input\")\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"input\")\n    ///         .index(1))\n    ///     .arg(Arg::with_name(\"output\")\n    ///         .index(2))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok()); // We didn't use cfg, so input and output weren't required\n    /// ```\n    ///\n    /// Setting [`Arg::requires_all(&[arg, arg2])`] and *not* supplying all the arguments is an\n    /// error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .takes_value(true)\n    ///         .requires_all(&[\"input\", \"output\"])\n    ///         .long(\"config\"))\n    ///     .arg(Arg::with_name(\"input\")\n    ///         .index(1))\n    ///     .arg(Arg::with_name(\"output\")\n    ///         .index(2))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--config\", \"file.conf\", \"in.txt\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// // We didn't use output\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n    /// [override]: ./struct.Arg.html#method.overrides_with\n    /// [`Arg::requires_all(&[arg, arg2])`]: ./struct.Arg.html#method.requires_all\n    pub fn requires_all(mut self, names: &[&'a str]) -> Self {\n        if let Some(ref mut vec) = self.b.requires {\n            for s in names {\n                vec.push((None, s));\n            }\n        } else {\n            let mut vec = vec![];\n            for s in names {\n                vec.push((None, *s));\n            }\n            self.b.requires = Some(vec);\n        }\n        self\n    }\n\n    /// Specifies that the argument takes a value at run time.\n    ///\n    /// **NOTE:** values for arguments may be specified in any of the following methods\n    ///\n    /// * Using a space such as `-o value` or `--option value`\n    /// * Using an equals and no space such as `-o=value` or `--option=value`\n    /// * Use a short and no space such as `-ovalue`\n    ///\n    /// **NOTE:** By default, args which allow [multiple values] are delimited by commas, meaning\n    /// `--option=val1,val2,val3` is three values for the `--option` argument. If you wish to\n    /// change the delimiter to another character you can use [`Arg::value_delimiter(char)`],\n    /// alternatively you can turn delimiting values **OFF** by using [`Arg::use_delimiter(false)`]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"config\")\n    ///     .takes_value(true)\n    /// # ;\n    /// ```\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"mode\")\n    ///         .long(\"mode\")\n    ///         .takes_value(true))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--mode\", \"fast\"\n    ///     ]);\n    ///\n    /// assert!(m.is_present(\"mode\"));\n    /// assert_eq!(m.value_of(\"mode\"), Some(\"fast\"));\n    /// ```\n    /// [`Arg::value_delimiter(char)`]: ./struct.Arg.html#method.value_delimiter\n    /// [`Arg::use_delimiter(false)`]: ./struct.Arg.html#method.use_delimiter\n    /// [multiple values]: ./struct.Arg.html#method.multiple\n    pub fn takes_value(self, tv: bool) -> Self {\n        if tv {\n            self.set(ArgSettings::TakesValue)\n        } else {\n            self.unset(ArgSettings::TakesValue)\n        }\n    }\n\n    /// Specifies if the possible values of an argument should be displayed in the help text or\n    /// not. Defaults to `false` (i.e. show possible values)\n    ///\n    /// This is useful for args with many values, or ones which are explained elsewhere in the\n    /// help text.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"config\")\n    ///     .hide_possible_values(true)\n    /// # ;\n    /// ```\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"mode\")\n    ///         .long(\"mode\")\n    ///         .possible_values(&[\"fast\", \"slow\"])\n    ///         .takes_value(true)\n    ///         .hide_possible_values(true));\n    ///\n    /// ```\n    ///\n    /// If we were to run the above program with `--help` the `[values: fast, slow]` portion of\n    /// the help text would be omitted.\n    pub fn hide_possible_values(self, hide: bool) -> Self {\n        if hide {\n            self.set(ArgSettings::HidePossibleValues)\n        } else {\n            self.unset(ArgSettings::HidePossibleValues)\n        }\n    }\n\n    /// Specifies if the default value of an argument should be displayed in the help text or\n    /// not. Defaults to `false` (i.e. show default value)\n    ///\n    /// This is useful when default behavior of an arg is explained elsewhere in the help text.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"config\")\n    ///     .hide_default_value(true)\n    /// # ;\n    /// ```\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"connect\")\n    ///     .arg(Arg::with_name(\"host\")\n    ///         .long(\"host\")\n    ///         .default_value(\"localhost\")\n    ///         .hide_default_value(true));\n    ///\n    /// ```\n    ///\n    /// If we were to run the above program with `--help` the `[default: localhost]` portion of\n    /// the help text would be omitted.\n    pub fn hide_default_value(self, hide: bool) -> Self {\n        if hide {\n            self.set(ArgSettings::HideDefaultValue)\n        } else {\n            self.unset(ArgSettings::HideDefaultValue)\n        }\n    }\n\n    /// Specifies the index of a positional argument **starting at** 1.\n    ///\n    /// **NOTE:** The index refers to position according to **other positional argument**. It does\n    /// not define position in the argument list as a whole.\n    ///\n    /// **NOTE:** If no [`Arg::short`], or [`Arg::long`] have been defined, you can optionally\n    /// leave off the `index` method, and the index will be assigned in order of evaluation.\n    /// Utilizing the `index` method allows for setting indexes out of order\n    ///\n    /// **NOTE:** When utilized with [`Arg::multiple(true)`], only the **last** positional argument\n    /// may be defined as multiple (i.e. with the highest index)\n    ///\n    /// # Panics\n    ///\n    /// Although not in this method directly, [`App`] will [`panic!`] if indexes are skipped (such\n    /// as defining `index(1)` and `index(3)` but not `index(2)`, or a positional argument is\n    /// defined as multiple and is not the highest index\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"config\")\n    ///     .index(1)\n    /// # ;\n    /// ```\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"mode\")\n    ///         .index(1))\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .long(\"debug\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--debug\", \"fast\"\n    ///     ]);\n    ///\n    /// assert!(m.is_present(\"mode\"));\n    /// assert_eq!(m.value_of(\"mode\"), Some(\"fast\")); // notice index(1) means \"first positional\"\n    ///                                               // *not* first argument\n    /// ```\n    /// [`Arg::short`]: ./struct.Arg.html#method.short\n    /// [`Arg::long`]: ./struct.Arg.html#method.long\n    /// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n    /// [`App`]: ./struct.App.html\n    /// [`panic!`]: https://doc.rust-lang.org/std/macro.panic!.html\n    pub fn index(mut self, idx: u64) -> Self {\n        self.index = Some(idx);\n        self\n    }\n\n    /// Specifies that the argument may appear more than once. For flags, this results\n    /// in the number of occurrences of the flag being recorded. For example `-ddd` or `-d -d -d`\n    /// would count as three occurrences. For options there is a distinct difference in multiple\n    /// occurrences vs multiple values.\n    ///\n    /// For example, `--opt val1 val2` is one occurrence, but two values. Whereas\n    /// `--opt val1 --opt val2` is two occurrences.\n    ///\n    /// **WARNING:**\n    ///\n    /// Setting `multiple(true)` for an [option] with no other details, allows multiple values\n    /// **and** multiple occurrences because it isn't possible to have more occurrences than values\n    /// for options. Because multiple values are allowed, `--option val1 val2 val3` is perfectly\n    /// valid, be careful when designing a CLI where positional arguments are expected after a\n    /// option which accepts multiple values, as `clap` will continue parsing *values* until it\n    /// reaches the max or specific number of values defined, or another flag or option.\n    ///\n    /// **Pro Tip**:\n    ///\n    /// It's possible to define an option which allows multiple occurrences, but only one value per\n    /// occurrence. To do this use [`Arg::number_of_values(1)`] in coordination with\n    /// [`Arg::multiple(true)`].\n    ///\n    /// **WARNING:**\n    ///\n    /// When using args with `multiple(true)` on [options] or [positionals] (i.e. those args that\n    /// accept values) and [subcommands], one needs to consider the possibility of an argument value\n    /// being the same as a valid subcommand. By default `clap` will parse the argument in question\n    /// as a value *only if* a value is possible at that moment. Otherwise it will be parsed as a\n    /// subcommand. In effect, this means using `multiple(true)` with no additional parameters and\n    /// a possible value that coincides with a subcommand name, the subcommand cannot be called\n    /// unless another argument is passed first.\n    ///\n    /// As an example, consider a CLI with an option `--ui-paths=<paths>...` and subcommand `signer`\n    ///\n    /// The following would be parsed as values to `--ui-paths`.\n    ///\n    /// ```notrust\n    /// $ program --ui-paths path1 path2 signer\n    /// ```\n    ///\n    /// This is because `--ui-paths` accepts multiple values. `clap` will continue parsing values\n    /// until another argument is reached and it knows `--ui-paths` is done.\n    ///\n    /// By adding additional parameters to `--ui-paths` we can solve this issue. Consider adding\n    /// [`Arg::number_of_values(1)`] as discussed above. The following are all valid, and `signer`\n    /// is parsed as both a subcommand and a value in the second case.\n    ///\n    /// ```notrust\n    /// $ program --ui-paths path1 signer\n    /// $ program --ui-paths path1 --ui-paths signer signer\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"debug\")\n    ///     .short(\"d\")\n    ///     .multiple(true)\n    /// # ;\n    /// ```\n    /// An example with flags\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"verbose\")\n    ///         .multiple(true)\n    ///         .short(\"v\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-v\", \"-v\", \"-v\"    // note, -vvv would have same result\n    ///     ]);\n    ///\n    /// assert!(m.is_present(\"verbose\"));\n    /// assert_eq!(m.occurrences_of(\"verbose\"), 3);\n    /// ```\n    ///\n    /// An example with options\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .multiple(true)\n    ///         .takes_value(true)\n    ///         .short(\"F\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-F\", \"file1\", \"file2\", \"file3\"\n    ///     ]);\n    ///\n    /// assert!(m.is_present(\"file\"));\n    /// assert_eq!(m.occurrences_of(\"file\"), 1); // notice only one occurrence\n    /// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n    /// assert_eq!(files, [\"file1\", \"file2\", \"file3\"]);\n    /// ```\n    /// This is functionally equivalent to the example above\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .multiple(true)\n    ///         .takes_value(true)\n    ///         .short(\"F\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-F\", \"file1\", \"-F\", \"file2\", \"-F\", \"file3\"\n    ///     ]);\n    /// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n    /// assert_eq!(files, [\"file1\", \"file2\", \"file3\"]);\n    ///\n    /// assert!(m.is_present(\"file\"));\n    /// assert_eq!(m.occurrences_of(\"file\"), 3); // Notice 3 occurrences\n    /// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n    /// assert_eq!(files, [\"file1\", \"file2\", \"file3\"]);\n    /// ```\n    ///\n    /// A common mistake is to define an option which allows multiples, and a positional argument\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .multiple(true)\n    ///         .takes_value(true)\n    ///         .short(\"F\"))\n    ///     .arg(Arg::with_name(\"word\")\n    ///         .index(1))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-F\", \"file1\", \"file2\", \"file3\", \"word\"\n    ///     ]);\n    ///\n    /// assert!(m.is_present(\"file\"));\n    /// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n    /// assert_eq!(files, [\"file1\", \"file2\", \"file3\", \"word\"]); // wait...what?!\n    /// assert!(!m.is_present(\"word\")); // but we clearly used word!\n    /// ```\n    /// The problem is clap doesn't know when to stop parsing values for \"files\". This is further\n    /// compounded by if we'd said `word -F file1 file2` it would have worked fine, so it would\n    /// appear to only fail sometimes...not good!\n    ///\n    /// A solution for the example above is to specify that `-F` only accepts one value, but is\n    /// allowed to appear multiple times\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .multiple(true)\n    ///         .takes_value(true)\n    ///         .number_of_values(1)\n    ///         .short(\"F\"))\n    ///     .arg(Arg::with_name(\"word\")\n    ///         .index(1))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-F\", \"file1\", \"-F\", \"file2\", \"-F\", \"file3\", \"word\"\n    ///     ]);\n    ///\n    /// assert!(m.is_present(\"file\"));\n    /// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n    /// assert_eq!(files, [\"file1\", \"file2\", \"file3\"]);\n    /// assert!(m.is_present(\"word\"));\n    /// assert_eq!(m.value_of(\"word\"), Some(\"word\"));\n    /// ```\n    /// As a final example, notice if we define [`Arg::number_of_values(1)`] and try to run the\n    /// problem example above, it would have been a runtime error with a pretty message to the\n    /// user :)\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .multiple(true)\n    ///         .takes_value(true)\n    ///         .number_of_values(1)\n    ///         .short(\"F\"))\n    ///     .arg(Arg::with_name(\"word\")\n    ///         .index(1))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"-F\", \"file1\", \"file2\", \"file3\", \"word\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::UnknownArgument);\n    /// ```\n    /// [option]: ./struct.Arg.html#method.takes_value\n    /// [options]: ./struct.Arg.html#method.takes_value\n    /// [subcommands]: ./struct.SubCommand.html\n    /// [positionals]: ./struct.Arg.html#method.index\n    /// [`Arg::number_of_values(1)`]: ./struct.Arg.html#method.number_of_values\n    /// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n    pub fn multiple(self, multi: bool) -> Self {\n        if multi {\n            self.set(ArgSettings::Multiple)\n        } else {\n            self.unset(ArgSettings::Multiple)\n        }\n    }\n\n    /// Specifies a value that *stops* parsing multiple values of a give argument. By default when\n    /// one sets [`multiple(true)`] on an argument, clap will continue parsing values for that\n    /// argument until it reaches another valid argument, or one of the other more specific settings\n    /// for multiple values is used (such as [`min_values`], [`max_values`] or\n    /// [`number_of_values`]).\n    ///\n    /// **NOTE:** This setting only applies to [options] and [positional arguments]\n    ///\n    /// **NOTE:** When the terminator is passed in on the command line, it is **not** stored as one\n    /// of the values\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"vals\")\n    ///     .takes_value(true)\n    ///     .multiple(true)\n    ///     .value_terminator(\";\")\n    /// # ;\n    /// ```\n    /// The following example uses two arguments, a sequence of commands, and the location in which\n    /// to perform them\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cmds\")\n    ///         .multiple(true)\n    ///         .allow_hyphen_values(true)\n    ///         .value_terminator(\";\"))\n    ///     .arg(Arg::with_name(\"location\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"find\", \"-type\", \"f\", \"-name\", \"special\", \";\", \"/home/clap\"\n    ///     ]);\n    /// let cmds: Vec<_> = m.values_of(\"cmds\").unwrap().collect();\n    /// assert_eq!(&cmds, &[\"find\", \"-type\", \"f\", \"-name\", \"special\"]);\n    /// assert_eq!(m.value_of(\"location\"), Some(\"/home/clap\"));\n    /// ```\n    /// [options]: ./struct.Arg.html#method.takes_value\n    /// [positional arguments]: ./struct.Arg.html#method.index\n    /// [`multiple(true)`]: ./struct.Arg.html#method.multiple\n    /// [`min_values`]: ./struct.Arg.html#method.min_values\n    /// [`number_of_values`]: ./struct.Arg.html#method.number_of_values\n    /// [`max_values`]: ./struct.Arg.html#method.max_values\n    pub fn value_terminator(mut self, term: &'b str) -> Self {\n        self.setb(ArgSettings::TakesValue);\n        self.v.terminator = Some(term);\n        self\n    }\n\n    /// Specifies that an argument can be matched to all child [`SubCommand`]s.\n    ///\n    /// **NOTE:** Global arguments *only* propagate down, **not** up (to parent commands), however\n    /// their values once a user uses them will be propagated back up to parents. In effect, this\n    /// means one should *define* all global arguments at the top level, however it doesn't matter\n    /// where the user *uses* the global argument.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"debug\")\n    ///     .short(\"d\")\n    ///     .global(true)\n    /// # ;\n    /// ```\n    ///\n    /// For example, assume an application with two subcommands, and you'd like to define a\n    /// `--verbose` flag that can be called on any of the subcommands and parent, but you don't\n    /// want to clutter the source with three duplicate [`Arg`] definitions.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, SubCommand};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"verb\")\n    ///         .long(\"verbose\")\n    ///         .short(\"v\")\n    ///         .global(true))\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .subcommand(SubCommand::with_name(\"do-stuff\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"do-stuff\", \"--verbose\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.subcommand_name(), Some(\"do-stuff\"));\n    /// let sub_m = m.subcommand_matches(\"do-stuff\").unwrap();\n    /// assert!(sub_m.is_present(\"verb\"));\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [required]: ./struct.Arg.html#method.required\n    /// [`ArgMatches`]: ./struct.ArgMatches.html\n    /// [`ArgMatches::is_present(\"flag\")`]: ./struct.ArgMatches.html#method.is_present\n    /// [`Arg`]: ./struct.Arg.html\n    pub fn global(self, g: bool) -> Self {\n        if g {\n            self.set(ArgSettings::Global)\n        } else {\n            self.unset(ArgSettings::Global)\n        }\n    }\n\n    /// Allows an argument to accept explicitly empty values. An empty value must be specified at\n    /// the command line with an explicit `\"\"`, or `''`\n    ///\n    /// **NOTE:** Defaults to `true` (Explicitly empty values are allowed)\n    ///\n    /// **NOTE:** Implicitly sets [`Arg::takes_value(true)`] when set to `false`\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"file\")\n    ///     .long(\"file\")\n    ///     .empty_values(false)\n    /// # ;\n    /// ```\n    /// The default is to allow empty values, such as `--option \"\"` would be an empty value. But\n    /// we can change to make empty values become an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .long(\"config\")\n    ///         .short(\"v\")\n    ///         .empty_values(false))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--config=\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::EmptyValue);\n    /// ```\n    /// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n    pub fn empty_values(mut self, ev: bool) -> Self {\n        if ev {\n            self.set(ArgSettings::EmptyValues)\n        } else {\n            self = self.set(ArgSettings::TakesValue);\n            self.unset(ArgSettings::EmptyValues)\n        }\n    }\n\n    /// Hides an argument from help message output.\n    ///\n    /// **NOTE:** Implicitly sets [`Arg::hidden_short_help(true)`] and [`Arg::hidden_long_help(true)`]\n    /// when set to true\n    ///\n    /// **NOTE:** This does **not** hide the argument from usage strings on error\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"debug\")\n    ///     .hidden(true)\n    /// # ;\n    /// ```\n    /// Setting `hidden(true)` will hide the argument when displaying help text\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .long(\"config\")\n    ///         .hidden(true)\n    ///         .help(\"Some help text describing the --config arg\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--help\"\n    ///     ]);\n    /// ```\n    ///\n    /// The above example displays\n    ///\n    /// ```notrust\n    /// helptest\n    ///\n    /// USAGE:\n    ///    helptest [FLAGS]\n    ///\n    /// FLAGS:\n    /// -h, --help       Prints help information\n    /// -V, --version    Prints version information\n    /// ```\n    /// [`Arg::hidden_short_help(true)`]: ./struct.Arg.html#method.hidden_short_help\n    /// [`Arg::hidden_long_help(true)`]: ./struct.Arg.html#method.hidden_long_help\n    pub fn hidden(self, h: bool) -> Self {\n        if h {\n            self.set(ArgSettings::Hidden)\n        } else {\n            self.unset(ArgSettings::Hidden)\n        }\n    }\n\n    /// Specifies a list of possible values for this argument. At runtime, `clap` verifies that\n    /// only one of the specified values was used, or fails with an error message.\n    ///\n    /// **NOTE:** This setting only applies to [options] and [positional arguments]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"mode\")\n    ///     .takes_value(true)\n    ///     .possible_values(&[\"fast\", \"slow\", \"medium\"])\n    /// # ;\n    /// ```\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"mode\")\n    ///         .long(\"mode\")\n    ///         .takes_value(true)\n    ///         .possible_values(&[\"fast\", \"slow\", \"medium\"]))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--mode\", \"fast\"\n    ///     ]);\n    /// assert!(m.is_present(\"mode\"));\n    /// assert_eq!(m.value_of(\"mode\"), Some(\"fast\"));\n    /// ```\n    ///\n    /// The next example shows a failed parse from using a value which wasn't defined as one of the\n    /// possible values.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"mode\")\n    ///         .long(\"mode\")\n    ///         .takes_value(true)\n    ///         .possible_values(&[\"fast\", \"slow\", \"medium\"]))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--mode\", \"wrong\"\n    ///     ]);\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::InvalidValue);\n    /// ```\n    /// [options]: ./struct.Arg.html#method.takes_value\n    /// [positional arguments]: ./struct.Arg.html#method.index\n    pub fn possible_values(mut self, names: &[&'b str]) -> Self {\n        if let Some(ref mut vec) = self.v.possible_vals {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.v.possible_vals = Some(names.iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self\n    }\n\n    /// Specifies a possible value for this argument, one at a time. At runtime, `clap` verifies\n    /// that only one of the specified values was used, or fails with error message.\n    ///\n    /// **NOTE:** This setting only applies to [options] and [positional arguments]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"mode\")\n    ///     .takes_value(true)\n    ///     .possible_value(\"fast\")\n    ///     .possible_value(\"slow\")\n    ///     .possible_value(\"medium\")\n    /// # ;\n    /// ```\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"mode\")\n    ///         .long(\"mode\")\n    ///         .takes_value(true)\n    ///         .possible_value(\"fast\")\n    ///         .possible_value(\"slow\")\n    ///         .possible_value(\"medium\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--mode\", \"fast\"\n    ///     ]);\n    /// assert!(m.is_present(\"mode\"));\n    /// assert_eq!(m.value_of(\"mode\"), Some(\"fast\"));\n    /// ```\n    ///\n    /// The next example shows a failed parse from using a value which wasn't defined as one of the\n    /// possible values.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"mode\")\n    ///         .long(\"mode\")\n    ///         .takes_value(true)\n    ///         .possible_value(\"fast\")\n    ///         .possible_value(\"slow\")\n    ///         .possible_value(\"medium\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"--mode\", \"wrong\"\n    ///     ]);\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::InvalidValue);\n    /// ```\n    /// [options]: ./struct.Arg.html#method.takes_value\n    /// [positional arguments]: ./struct.Arg.html#method.index\n    pub fn possible_value(mut self, name: &'b str) -> Self {\n        if let Some(ref mut vec) = self.v.possible_vals {\n            vec.push(name);\n        } else {\n            self.v.possible_vals = Some(vec![name]);\n        }\n        self\n    }\n\n    /// When used with [`Arg::possible_values`] it allows the argument value to pass validation even if\n    /// the case differs from that of the specified `possible_value`.\n    ///\n    /// **Pro Tip:** Use this setting with [`arg_enum!`]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// # use std::ascii::AsciiExt;\n    /// let m = App::new(\"pv\")\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .long(\"--option\")\n    ///         .takes_value(true)\n    ///         .possible_value(\"test123\")\n    ///         .case_insensitive(true))\n    ///     .get_matches_from(vec![\n    ///         \"pv\", \"--option\", \"TeSt123\",\n    ///     ]);\n    ///\n    /// assert!(m.value_of(\"option\").unwrap().eq_ignore_ascii_case(\"test123\"));\n    /// ```\n    ///\n    /// This setting also works when multiple values can be defined:\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"pv\")\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .short(\"-o\")\n    ///         .long(\"--option\")\n    ///         .takes_value(true)\n    ///         .possible_value(\"test123\")\n    ///         .possible_value(\"test321\")\n    ///         .multiple(true)\n    ///         .case_insensitive(true))\n    ///     .get_matches_from(vec![\n    ///         \"pv\", \"--option\", \"TeSt123\", \"teST123\", \"tESt321\"\n    ///     ]);\n    ///\n    /// let matched_vals = m.values_of(\"option\").unwrap().collect::<Vec<_>>();\n    /// assert_eq!(&*matched_vals, &[\"TeSt123\", \"teST123\", \"tESt321\"]);\n    /// ```\n    /// [`Arg::case_insensitive(true)`]: ./struct.Arg.html#method.possible_values\n    /// [`arg_enum!`]: ./macro.arg_enum.html\n    pub fn case_insensitive(self, ci: bool) -> Self {\n        if ci {\n            self.set(ArgSettings::CaseInsensitive)\n        } else {\n            self.unset(ArgSettings::CaseInsensitive)\n        }\n    }\n\n    /// Specifies the name of the [`ArgGroup`] the argument belongs to.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"debug\")\n    ///     .long(\"debug\")\n    ///     .group(\"mode\")\n    /// # ;\n    /// ```\n    ///\n    /// Multiple arguments can be a member of a single group and then the group checked as if it\n    /// was one of said arguments.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .long(\"debug\")\n    ///         .group(\"mode\"))\n    ///     .arg(Arg::with_name(\"verbose\")\n    ///         .long(\"verbose\")\n    ///         .group(\"mode\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--debug\"\n    ///     ]);\n    /// assert!(m.is_present(\"mode\"));\n    /// ```\n    /// [`ArgGroup`]: ./struct.ArgGroup.html\n    pub fn group(mut self, name: &'a str) -> Self {\n        if let Some(ref mut vec) = self.b.groups {\n            vec.push(name);\n        } else {\n            self.b.groups = Some(vec![name]);\n        }\n        self\n    }\n\n    /// Specifies the names of multiple [`ArgGroup`]'s the argument belongs to.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"debug\")\n    ///     .long(\"debug\")\n    ///     .groups(&[\"mode\", \"verbosity\"])\n    /// # ;\n    /// ```\n    ///\n    /// Arguments can be members of multiple groups and then the group checked as if it\n    /// was one of said arguments.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .long(\"debug\")\n    ///         .groups(&[\"mode\", \"verbosity\"]))\n    ///     .arg(Arg::with_name(\"verbose\")\n    ///         .long(\"verbose\")\n    ///         .groups(&[\"mode\", \"verbosity\"]))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--debug\"\n    ///     ]);\n    /// assert!(m.is_present(\"mode\"));\n    /// assert!(m.is_present(\"verbosity\"));\n    /// ```\n    /// [`ArgGroup`]: ./struct.ArgGroup.html\n    pub fn groups(mut self, names: &[&'a str]) -> Self {\n        if let Some(ref mut vec) = self.b.groups {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.b.groups = Some(names.into_iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self\n    }\n\n    /// Specifies how many values are required to satisfy this argument. For example, if you had a\n    /// `-f <file>` argument where you wanted exactly 3 'files' you would set\n    /// `.number_of_values(3)`, and this argument wouldn't be satisfied unless the user provided\n    /// 3 and only 3 values.\n    ///\n    /// **NOTE:** Does *not* require [`Arg::multiple(true)`] to be set. Setting\n    /// [`Arg::multiple(true)`] would allow `-f <file> <file> <file> -f <file> <file> <file>` where\n    /// as *not* setting [`Arg::multiple(true)`] would only allow one occurrence of this argument.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"file\")\n    ///     .short(\"f\")\n    ///     .number_of_values(3)\n    /// # ;\n    /// ```\n    ///\n    /// Not supplying the correct number of values is an error\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .takes_value(true)\n    ///         .number_of_values(2)\n    ///         .short(\"F\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"-F\", \"file1\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::WrongNumberOfValues);\n    /// ```\n    /// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n    pub fn number_of_values(mut self, qty: u64) -> Self {\n        self.setb(ArgSettings::TakesValue);\n        self.v.num_vals = Some(qty);\n        self\n    }\n\n    /// Allows one to perform a custom validation on the argument value. You provide a closure\n    /// which accepts a [`String`] value, and return a [`Result`] where the [`Err(String)`] is a\n    /// message displayed to the user.\n    ///\n    /// **NOTE:** The error message does *not* need to contain the `error:` portion, only the\n    /// message as all errors will appear as\n    /// `error: Invalid value for '<arg>': <YOUR MESSAGE>` where `<arg>` is replaced by the actual\n    /// arg, and `<YOUR MESSAGE>` is the `String` you return as the error.\n    ///\n    /// **NOTE:** There is a small performance hit for using validators, as they are implemented\n    /// with [`Rc`] pointers. And the value to be checked will be allocated an extra time in order\n    /// to to be passed to the closure. This performance hit is extremely minimal in the grand\n    /// scheme of things.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// fn has_at(v: String) -> Result<(), String> {\n    ///     if v.contains(\"@\") { return Ok(()); }\n    ///     Err(String::from(\"The value did not contain the required @ sigil\"))\n    /// }\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .index(1)\n    ///         .validator(has_at))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"some@file\"\n    ///     ]);\n    /// assert!(res.is_ok());\n    /// assert_eq!(res.unwrap().value_of(\"file\"), Some(\"some@file\"));\n    /// ```\n    /// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html\n    /// [`Result`]: https://doc.rust-lang.org/std/result/enum.Result.html\n    /// [`Err(String)`]: https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err\n    /// [`Rc`]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n    pub fn validator<F>(mut self, f: F) -> Self\n    where\n        F: Fn(String) -> Result<(), String> + 'static,\n    {\n        self.v.validator = Some(Rc::new(f));\n        self\n    }\n\n    /// Works identically to Validator but is intended to be used with values that could\n    /// contain non UTF-8 formatted strings.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(not(unix), doc = \" ```ignore\")]\n    #[cfg_attr(unix, doc = \" ```rust\")]\n    /// # use clap::{App, Arg};\n    /// # use std::ffi::{OsStr, OsString};\n    /// # use std::os::unix::ffi::OsStrExt;\n    /// fn has_ampersand(v: &OsStr) -> Result<(), OsString> {\n    ///     if v.as_bytes().iter().any(|b| *b == b'&') { return Ok(()); }\n    ///     Err(OsString::from(\"The value did not contain the required & sigil\"))\n    /// }\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .index(1)\n    ///         .validator_os(has_ampersand))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"Fish & chips\"\n    ///     ]);\n    /// assert!(res.is_ok());\n    /// assert_eq!(res.unwrap().value_of(\"file\"), Some(\"Fish & chips\"));\n    /// ```\n    /// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html\n    /// [`OsStr`]: https://doc.rust-lang.org/std/ffi/struct.OsStr.html\n    /// [`OsString`]: https://doc.rust-lang.org/std/ffi/struct.OsString.html\n    /// [`Result`]: https://doc.rust-lang.org/std/result/enum.Result.html\n    /// [`Err(String)`]: https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err\n    /// [`Rc`]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n    pub fn validator_os<F>(mut self, f: F) -> Self\n    where\n        F: Fn(&OsStr) -> Result<(), OsString> + 'static,\n    {\n        self.v.validator_os = Some(Rc::new(f));\n        self\n    }\n\n    /// Specifies the *maximum* number of values are for this argument. For example, if you had a\n    /// `-f <file>` argument where you wanted up to 3 'files' you would set `.max_values(3)`, and\n    /// this argument would be satisfied if the user provided, 1, 2, or 3 values.\n    ///\n    /// **NOTE:** This does *not* implicitly set [`Arg::multiple(true)`]. This is because\n    /// `-o val -o val` is multiple occurrences but a single value and `-o val1 val2` is a single\n    /// occurrence with multiple values. For positional arguments this **does** set\n    /// [`Arg::multiple(true)`] because there is no way to determine the difference between multiple\n    /// occurrences and multiple values.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"file\")\n    ///     .short(\"f\")\n    ///     .max_values(3)\n    /// # ;\n    /// ```\n    ///\n    /// Supplying less than the maximum number of values is allowed\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .takes_value(true)\n    ///         .max_values(3)\n    ///         .short(\"F\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"-F\", \"file1\", \"file2\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok());\n    /// let m = res.unwrap();\n    /// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n    /// assert_eq!(files, [\"file1\", \"file2\"]);\n    /// ```\n    ///\n    /// Supplying more than the maximum number of values is an error\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .takes_value(true)\n    ///         .max_values(2)\n    ///         .short(\"F\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"-F\", \"file1\", \"file2\", \"file3\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::TooManyValues);\n    /// ```\n    /// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n    pub fn max_values(mut self, qty: u64) -> Self {\n        self.setb(ArgSettings::TakesValue);\n        self.v.max_vals = Some(qty);\n        self\n    }\n\n    /// Specifies the *minimum* number of values for this argument. For example, if you had a\n    /// `-f <file>` argument where you wanted at least 2 'files' you would set\n    /// `.min_values(2)`, and this argument would be satisfied if the user provided, 2 or more\n    /// values.\n    ///\n    /// **NOTE:** This does not implicitly set [`Arg::multiple(true)`]. This is because\n    /// `-o val -o val` is multiple occurrences but a single value and `-o val1 val2` is a single\n    /// occurrence with multiple values. For positional arguments this **does** set\n    /// [`Arg::multiple(true)`] because there is no way to determine the difference between multiple\n    /// occurrences and multiple values.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"file\")\n    ///     .short(\"f\")\n    ///     .min_values(3)\n    /// # ;\n    /// ```\n    ///\n    /// Supplying more than the minimum number of values is allowed\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .takes_value(true)\n    ///         .min_values(2)\n    ///         .short(\"F\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"-F\", \"file1\", \"file2\", \"file3\"\n    ///     ]);\n    ///\n    /// assert!(res.is_ok());\n    /// let m = res.unwrap();\n    /// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n    /// assert_eq!(files, [\"file1\", \"file2\", \"file3\"]);\n    /// ```\n    ///\n    /// Supplying less than the minimum number of values is an error\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"file\")\n    ///         .takes_value(true)\n    ///         .min_values(2)\n    ///         .short(\"F\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"-F\", \"file1\"\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::TooFewValues);\n    /// ```\n    /// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n    pub fn min_values(mut self, qty: u64) -> Self {\n        self.v.min_vals = Some(qty);\n        self.set(ArgSettings::TakesValue)\n    }\n\n    /// Specifies whether or not an argument should allow grouping of multiple values via a\n    /// delimiter. I.e. should `--option=val1,val2,val3` be parsed as three values (`val1`, `val2`,\n    /// and `val3`) or as a single value (`val1,val2,val3`). Defaults to using `,` (comma) as the\n    /// value delimiter for all arguments that accept values (options and positional arguments)\n    ///\n    /// **NOTE:** The default is `false`. When set to `true` the default [`Arg::value_delimiter`]\n    /// is the comma `,`.\n    ///\n    /// # Examples\n    ///\n    /// The following example shows the default behavior.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let delims = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .long(\"option\")\n    ///         .use_delimiter(true)\n    ///         .takes_value(true))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--option=val1,val2,val3\",\n    ///     ]);\n    ///\n    /// assert!(delims.is_present(\"option\"));\n    /// assert_eq!(delims.occurrences_of(\"option\"), 1);\n    /// assert_eq!(delims.values_of(\"option\").unwrap().collect::<Vec<_>>(), [\"val1\", \"val2\", \"val3\"]);\n    /// ```\n    /// The next example shows the difference when turning delimiters off. This is the default\n    /// behavior\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let nodelims = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .long(\"option\")\n    ///         .use_delimiter(false)\n    ///         .takes_value(true))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--option=val1,val2,val3\",\n    ///     ]);\n    ///\n    /// assert!(nodelims.is_present(\"option\"));\n    /// assert_eq!(nodelims.occurrences_of(\"option\"), 1);\n    /// assert_eq!(nodelims.value_of(\"option\").unwrap(), \"val1,val2,val3\");\n    /// ```\n    /// [`Arg::value_delimiter`]: ./struct.Arg.html#method.value_delimiter\n    pub fn use_delimiter(mut self, d: bool) -> Self {\n        if d {\n            if self.v.val_delim.is_none() {\n                self.v.val_delim = Some(',');\n            }\n            self.setb(ArgSettings::TakesValue);\n            self.setb(ArgSettings::UseValueDelimiter);\n            self.unset(ArgSettings::ValueDelimiterNotSet)\n        } else {\n            self.v.val_delim = None;\n            self.unsetb(ArgSettings::UseValueDelimiter);\n            self.unset(ArgSettings::ValueDelimiterNotSet)\n        }\n    }\n\n    /// Specifies that *multiple values* may only be set using the delimiter. This means if an\n    /// if an option is encountered, and no delimiter is found, it automatically assumed that no\n    /// additional values for that option follow. This is unlike the default, where it is generally\n    /// assumed that more values will follow regardless of whether or not a delimiter is used.\n    ///\n    /// **NOTE:** The default is `false`.\n    ///\n    /// **NOTE:** Setting this to true implies [`Arg::use_delimiter(true)`]\n    ///\n    /// **NOTE:** It's a good idea to inform the user that use of a delimiter is required, either\n    /// through help text or other means.\n    ///\n    /// # Examples\n    ///\n    /// These examples demonstrate what happens when `require_delimiter(true)` is used. Notice\n    /// everything works in this first example, as we use a delimiter, as expected.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let delims = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"opt\")\n    ///         .short(\"o\")\n    ///         .takes_value(true)\n    ///         .multiple(true)\n    ///         .require_delimiter(true))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-o\", \"val1,val2,val3\",\n    ///     ]);\n    ///\n    /// assert!(delims.is_present(\"opt\"));\n    /// assert_eq!(delims.values_of(\"opt\").unwrap().collect::<Vec<_>>(), [\"val1\", \"val2\", \"val3\"]);\n    /// ```\n    /// In this next example, we will *not* use a delimiter. Notice it's now an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"opt\")\n    ///         .short(\"o\")\n    ///         .takes_value(true)\n    ///         .multiple(true)\n    ///         .require_delimiter(true))\n    ///     .get_matches_from_safe(vec![\n    ///         \"prog\", \"-o\", \"val1\", \"val2\", \"val3\",\n    ///     ]);\n    ///\n    /// assert!(res.is_err());\n    /// let err = res.unwrap_err();\n    /// assert_eq!(err.kind, ErrorKind::UnknownArgument);\n    /// ```\n    /// What's happening is `-o` is getting `val1`, and because delimiters are required yet none\n    /// were present, it stops parsing `-o`. At this point it reaches `val2` and because no\n    /// positional arguments have been defined, it's an error of an unexpected argument.\n    ///\n    /// In this final example, we contrast the above with `clap`'s default behavior where the above\n    /// is *not* an error.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let delims = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"opt\")\n    ///         .short(\"o\")\n    ///         .takes_value(true)\n    ///         .multiple(true))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-o\", \"val1\", \"val2\", \"val3\",\n    ///     ]);\n    ///\n    /// assert!(delims.is_present(\"opt\"));\n    /// assert_eq!(delims.values_of(\"opt\").unwrap().collect::<Vec<_>>(), [\"val1\", \"val2\", \"val3\"]);\n    /// ```\n    /// [`Arg::use_delimiter(true)`]: ./struct.Arg.html#method.use_delimiter\n    pub fn require_delimiter(mut self, d: bool) -> Self {\n        if d {\n            self = self.use_delimiter(true);\n            self.unsetb(ArgSettings::ValueDelimiterNotSet);\n            self.setb(ArgSettings::UseValueDelimiter);\n            self.set(ArgSettings::RequireDelimiter)\n        } else {\n            self = self.use_delimiter(false);\n            self.unsetb(ArgSettings::UseValueDelimiter);\n            self.unset(ArgSettings::RequireDelimiter)\n        }\n    }\n\n    /// Specifies the separator to use when values are clumped together, defaults to `,` (comma).\n    ///\n    /// **NOTE:** implicitly sets [`Arg::use_delimiter(true)`]\n    ///\n    /// **NOTE:** implicitly sets [`Arg::takes_value(true)`]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"config\")\n    ///         .short(\"c\")\n    ///         .long(\"config\")\n    ///         .value_delimiter(\";\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--config=val1;val2;val3\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.values_of(\"config\").unwrap().collect::<Vec<_>>(), [\"val1\", \"val2\", \"val3\"])\n    /// ```\n    /// [`Arg::use_delimiter(true)`]: ./struct.Arg.html#method.use_delimiter\n    /// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n    pub fn value_delimiter(mut self, d: &str) -> Self {\n        self.unsetb(ArgSettings::ValueDelimiterNotSet);\n        self.setb(ArgSettings::TakesValue);\n        self.setb(ArgSettings::UseValueDelimiter);\n        self.v.val_delim = Some(\n            d.chars()\n                .nth(0)\n                .expect(\"Failed to get value_delimiter from arg\"),\n        );\n        self\n    }\n\n    /// Specify multiple names for values of option arguments. These names are cosmetic only, used\n    /// for help and usage strings only. The names are **not** used to access arguments. The values\n    /// of the arguments are accessed in numeric order (i.e. if you specify two names `one` and\n    /// `two` `one` will be the first matched value, `two` will be the second).\n    ///\n    /// This setting can be very helpful when describing the type of input the user should be\n    /// using, such as `FILE`, `INTERFACE`, etc. Although not required, it's somewhat convention to\n    /// use all capital letters for the value name.\n    ///\n    /// **Pro Tip:** It may help to use [`Arg::next_line_help(true)`] if there are long, or\n    /// multiple value names in order to not throw off the help text alignment of all options.\n    ///\n    /// **NOTE:** This implicitly sets [`Arg::number_of_values`] if the number of value names is\n    /// greater than one. I.e. be aware that the number of \"names\" you set for the values, will be\n    /// the *exact* number of values required to satisfy this argument\n    ///\n    /// **NOTE:** implicitly sets [`Arg::takes_value(true)`]\n    ///\n    /// **NOTE:** Does *not* require or imply [`Arg::multiple(true)`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"speed\")\n    ///     .short(\"s\")\n    ///     .value_names(&[\"fast\", \"slow\"])\n    /// # ;\n    /// ```\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"io\")\n    ///         .long(\"io-files\")\n    ///         .value_names(&[\"INFILE\", \"OUTFILE\"]))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--help\"\n    ///     ]);\n    /// ```\n    /// Running the above program produces the following output\n    ///\n    /// ```notrust\n    /// valnames\n    ///\n    /// USAGE:\n    ///    valnames [FLAGS] [OPTIONS]\n    ///\n    /// FLAGS:\n    ///     -h, --help       Prints help information\n    ///     -V, --version    Prints version information\n    ///\n    /// OPTIONS:\n    ///     --io-files <INFILE> <OUTFILE>    Some help text\n    /// ```\n    /// [`Arg::next_line_help(true)`]: ./struct.Arg.html#method.next_line_help\n    /// [`Arg::number_of_values`]: ./struct.Arg.html#method.number_of_values\n    /// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n    /// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n    pub fn value_names(mut self, names: &[&'b str]) -> Self {\n        self.setb(ArgSettings::TakesValue);\n        if self.is_set(ArgSettings::ValueDelimiterNotSet) {\n            self.unsetb(ArgSettings::ValueDelimiterNotSet);\n            self.setb(ArgSettings::UseValueDelimiter);\n        }\n        if let Some(ref mut vals) = self.v.val_names {\n            let mut l = vals.len();\n            for s in names {\n                vals.insert(l, s);\n                l += 1;\n            }\n        } else {\n            let mut vm = VecMap::new();\n            for (i, n) in names.iter().enumerate() {\n                vm.insert(i, *n);\n            }\n            self.v.val_names = Some(vm);\n        }\n        self\n    }\n\n    /// Specifies the name for value of [option] or [positional] arguments inside of help\n    /// documentation. This name is cosmetic only, the name is **not** used to access arguments.\n    /// This setting can be very helpful when describing the type of input the user should be\n    /// using, such as `FILE`, `INTERFACE`, etc. Although not required, it's somewhat convention to\n    /// use all capital letters for the value name.\n    ///\n    /// **NOTE:** implicitly sets [`Arg::takes_value(true)`]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"cfg\")\n    ///     .long(\"config\")\n    ///     .value_name(\"FILE\")\n    /// # ;\n    /// ```\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"config\")\n    ///         .long(\"config\")\n    ///         .value_name(\"FILE\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--help\"\n    ///     ]);\n    /// ```\n    /// Running the above program produces the following output\n    ///\n    /// ```notrust\n    /// valnames\n    ///\n    /// USAGE:\n    ///    valnames [FLAGS] [OPTIONS]\n    ///\n    /// FLAGS:\n    ///     -h, --help       Prints help information\n    ///     -V, --version    Prints version information\n    ///\n    /// OPTIONS:\n    ///     --config <FILE>     Some help text\n    /// ```\n    /// [option]: ./struct.Arg.html#method.takes_value\n    /// [positional]: ./struct.Arg.html#method.index\n    /// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n    pub fn value_name(mut self, name: &'b str) -> Self {\n        self.setb(ArgSettings::TakesValue);\n        if let Some(ref mut vals) = self.v.val_names {\n            let l = vals.len();\n            vals.insert(l, name);\n        } else {\n            let mut vm = VecMap::new();\n            vm.insert(0, name);\n            self.v.val_names = Some(vm);\n        }\n        self\n    }\n\n    /// Specifies the value of the argument when *not* specified at runtime.\n    ///\n    /// **NOTE:** If the user *does not* use this argument at runtime, [`ArgMatches::occurrences_of`]\n    /// will return `0` even though the [`ArgMatches::value_of`] will return the default specified.\n    ///\n    /// **NOTE:** If the user *does not* use this argument at runtime [`ArgMatches::is_present`] will\n    /// still return `true`. If you wish to determine whether the argument was used at runtime or\n    /// not, consider [`ArgMatches::occurrences_of`] which will return `0` if the argument was *not*\n    /// used at runtime.\n    ///\n    /// **NOTE:** This setting is perfectly compatible with [`Arg::default_value_if`] but slightly\n    /// different. `Arg::default_value` *only* takes affect when the user has not provided this arg\n    /// at runtime. `Arg::default_value_if` however only takes affect when the user has not provided\n    /// a value at runtime **and** these other conditions are met as well. If you have set\n    /// `Arg::default_value` and `Arg::default_value_if`, and the user **did not** provide a this\n    /// arg at runtime, nor did were the conditions met for `Arg::default_value_if`, the\n    /// `Arg::default_value` will be applied.\n    ///\n    /// **NOTE:** This implicitly sets [`Arg::takes_value(true)`].\n    ///\n    /// **NOTE:** This setting effectively disables `AppSettings::ArgRequiredElseHelp` if used in\n    /// conjunction as it ensures that some argument will always be present.\n    ///\n    /// # Examples\n    ///\n    /// First we use the default value without providing any value at runtime.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"opt\")\n    ///         .long(\"myopt\")\n    ///         .default_value(\"myval\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"opt\"), Some(\"myval\"));\n    /// assert!(m.is_present(\"opt\"));\n    /// assert_eq!(m.occurrences_of(\"opt\"), 0);\n    /// ```\n    ///\n    /// Next we provide a value at runtime to override the default.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"opt\")\n    ///         .long(\"myopt\")\n    ///         .default_value(\"myval\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--myopt=non_default\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"opt\"), Some(\"non_default\"));\n    /// assert!(m.is_present(\"opt\"));\n    /// assert_eq!(m.occurrences_of(\"opt\"), 1);\n    /// ```\n    /// [`ArgMatches::occurrences_of`]: ./struct.ArgMatches.html#method.occurrences_of\n    /// [`ArgMatches::value_of`]: ./struct.ArgMatches.html#method.value_of\n    /// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n    /// [`ArgMatches::is_present`]: ./struct.ArgMatches.html#method.is_present\n    /// [`Arg::default_value_if`]: ./struct.Arg.html#method.default_value_if\n    pub fn default_value(self, val: &'a str) -> Self {\n        self.default_value_os(OsStr::from_bytes(val.as_bytes()))\n    }\n\n    /// Provides a default value in the exact same manner as [`Arg::default_value`]\n    /// only using [`OsStr`]s instead.\n    /// [`Arg::default_value`]: ./struct.Arg.html#method.default_value\n    /// [`OsStr`]: https://doc.rust-lang.org/std/ffi/struct.OsStr.html\n    pub fn default_value_os(mut self, val: &'a OsStr) -> Self {\n        self.setb(ArgSettings::TakesValue);\n        self.v.default_val = Some(val);\n        self\n    }\n\n    /// Specifies the value of the argument if `arg` has been used at runtime. If `val` is set to\n    /// `None`, `arg` only needs to be present. If `val` is set to `\"some-val\"` then `arg` must be\n    /// present at runtime **and** have the value `val`.\n    ///\n    /// **NOTE:** This setting is perfectly compatible with [`Arg::default_value`] but slightly\n    /// different. `Arg::default_value` *only* takes affect when the user has not provided this arg\n    /// at runtime. This setting however only takes affect when the user has not provided a value at\n    /// runtime **and** these other conditions are met as well. If you have set `Arg::default_value`\n    /// and `Arg::default_value_if`, and the user **did not** provide a this arg at runtime, nor did\n    /// were the conditions met for `Arg::default_value_if`, the `Arg::default_value` will be\n    /// applied.\n    ///\n    /// **NOTE:** This implicitly sets [`Arg::takes_value(true)`].\n    ///\n    /// **NOTE:** If using YAML the values should be laid out as follows (`None` can be represented\n    /// as `null` in YAML)\n    ///\n    /// ```yaml\n    /// default_value_if:\n    ///     - [arg, val, default]\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// First we use the default value only if another arg is present at runtime.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .long(\"flag\"))\n    ///     .arg(Arg::with_name(\"other\")\n    ///         .long(\"other\")\n    ///         .default_value_if(\"flag\", None, \"default\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--flag\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"other\"), Some(\"default\"));\n    /// ```\n    ///\n    /// Next we run the same test, but without providing `--flag`.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .long(\"flag\"))\n    ///     .arg(Arg::with_name(\"other\")\n    ///         .long(\"other\")\n    ///         .default_value_if(\"flag\", None, \"default\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"other\"), None);\n    /// ```\n    ///\n    /// Now lets only use the default value if `--opt` contains the value `special`.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"opt\")\n    ///         .takes_value(true)\n    ///         .long(\"opt\"))\n    ///     .arg(Arg::with_name(\"other\")\n    ///         .long(\"other\")\n    ///         .default_value_if(\"opt\", Some(\"special\"), \"default\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--opt\", \"special\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"other\"), Some(\"default\"));\n    /// ```\n    ///\n    /// We can run the same test and provide any value *other than* `special` and we won't get a\n    /// default value.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"opt\")\n    ///         .takes_value(true)\n    ///         .long(\"opt\"))\n    ///     .arg(Arg::with_name(\"other\")\n    ///         .long(\"other\")\n    ///         .default_value_if(\"opt\", Some(\"special\"), \"default\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--opt\", \"hahaha\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"other\"), None);\n    /// ```\n    /// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n    /// [`Arg::default_value`]: ./struct.Arg.html#method.default_value\n    pub fn default_value_if(self, arg: &'a str, val: Option<&'b str>, default: &'b str) -> Self {\n        self.default_value_if_os(\n            arg,\n            val.map(str::as_bytes).map(OsStr::from_bytes),\n            OsStr::from_bytes(default.as_bytes()),\n        )\n    }\n\n    /// Provides a conditional default value in the exact same manner as [`Arg::default_value_if`]\n    /// only using [`OsStr`]s instead.\n    /// [`Arg::default_value_if`]: ./struct.Arg.html#method.default_value_if\n    /// [`OsStr`]: https://doc.rust-lang.org/std/ffi/struct.OsStr.html\n    pub fn default_value_if_os(\n        mut self,\n        arg: &'a str,\n        val: Option<&'b OsStr>,\n        default: &'b OsStr,\n    ) -> Self {\n        self.setb(ArgSettings::TakesValue);\n        if let Some(ref mut vm) = self.v.default_vals_ifs {\n            let l = vm.len();\n            vm.insert(l, (arg, val, default));\n        } else {\n            let mut vm = VecMap::new();\n            vm.insert(0, (arg, val, default));\n            self.v.default_vals_ifs = Some(vm);\n        }\n        self\n    }\n\n    /// Specifies multiple values and conditions in the same manner as [`Arg::default_value_if`].\n    /// The method takes a slice of tuples in the `(arg, Option<val>, default)` format.\n    ///\n    /// **NOTE**: The conditions are stored in order and evaluated in the same order. I.e. the first\n    /// if multiple conditions are true, the first one found will be applied and the ultimate value.\n    ///\n    /// **NOTE:** If using YAML the values should be laid out as follows\n    ///\n    /// ```yaml\n    /// default_value_if:\n    ///     - [arg, val, default]\n    ///     - [arg2, null, default2]\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// First we use the default value only if another arg is present at runtime.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .long(\"flag\"))\n    ///     .arg(Arg::with_name(\"opt\")\n    ///         .long(\"opt\")\n    ///         .takes_value(true))\n    ///     .arg(Arg::with_name(\"other\")\n    ///         .long(\"other\")\n    ///         .default_value_ifs(&[\n    ///             (\"flag\", None, \"default\"),\n    ///             (\"opt\", Some(\"channal\"), \"chan\"),\n    ///         ]))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--opt\", \"channal\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"other\"), Some(\"chan\"));\n    /// ```\n    ///\n    /// Next we run the same test, but without providing `--flag`.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .long(\"flag\"))\n    ///     .arg(Arg::with_name(\"other\")\n    ///         .long(\"other\")\n    ///         .default_value_ifs(&[\n    ///             (\"flag\", None, \"default\"),\n    ///             (\"opt\", Some(\"channal\"), \"chan\"),\n    ///         ]))\n    ///     .get_matches_from(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"other\"), None);\n    /// ```\n    ///\n    /// We can also see that these values are applied in order, and if more than one condition is\n    /// true, only the first evaluated \"wins\"\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .long(\"flag\"))\n    ///     .arg(Arg::with_name(\"opt\")\n    ///         .long(\"opt\")\n    ///         .takes_value(true))\n    ///     .arg(Arg::with_name(\"other\")\n    ///         .long(\"other\")\n    ///         .default_value_ifs(&[\n    ///             (\"flag\", None, \"default\"),\n    ///             (\"opt\", Some(\"channal\"), \"chan\"),\n    ///         ]))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--opt\", \"channal\", \"--flag\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"other\"), Some(\"default\"));\n    /// ```\n    /// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n    /// [`Arg::default_value`]: ./struct.Arg.html#method.default_value\n    pub fn default_value_ifs(mut self, ifs: &[(&'a str, Option<&'b str>, &'b str)]) -> Self {\n        for &(arg, val, default) in ifs {\n            self = self.default_value_if_os(\n                arg,\n                val.map(str::as_bytes).map(OsStr::from_bytes),\n                OsStr::from_bytes(default.as_bytes()),\n            );\n        }\n        self\n    }\n\n    /// Provides multiple conditional default values in the exact same manner as\n    /// [`Arg::default_value_ifs`] only using [`OsStr`]s instead.\n    /// [`Arg::default_value_ifs`]: ./struct.Arg.html#method.default_value_ifs\n    /// [`OsStr`]: https://doc.rust-lang.org/std/ffi/struct.OsStr.html\n    #[cfg_attr(feature = \"lints\", allow(explicit_counter_loop))]\n    pub fn default_value_ifs_os(mut self, ifs: &[(&'a str, Option<&'b OsStr>, &'b OsStr)]) -> Self {\n        for &(arg, val, default) in ifs {\n            self = self.default_value_if_os(arg, val, default);\n        }\n        self\n    }\n\n    /// Specifies that if the value is not passed in as an argument, that it should be retrieved\n    /// from the environment, if available. If it is not present in the environment, then default\n    /// rules will apply.\n    ///\n    /// **NOTE:** If the user *does not* use this argument at runtime, [`ArgMatches::occurrences_of`]\n    /// will return `0` even though the [`ArgMatches::value_of`] will return the default specified.\n    ///\n    /// **NOTE:** If the user *does not* use this argument at runtime [`ArgMatches::is_present`] will\n    /// return `true` if the variable is present in the environment . If you wish to determine whether\n    /// the argument was used at runtime or not, consider [`ArgMatches::occurrences_of`] which will\n    /// return `0` if the argument was *not* used at runtime.\n    ///\n    /// **NOTE:** This implicitly sets [`Arg::takes_value(true)`].\n    ///\n    /// **NOTE:** If [`Arg::multiple(true)`] is set then [`Arg::use_delimiter(true)`] should also be\n    /// set. Otherwise, only a single argument will be returned from the environment variable. The\n    /// default delimiter is `,` and follows all the other delimiter rules.\n    ///\n    /// # Examples\n    ///\n    /// In this example, we show the variable coming from the environment:\n    ///\n    /// ```rust\n    /// # use std::env;\n    /// # use clap::{App, Arg};\n    ///\n    /// env::set_var(\"MY_FLAG\", \"env\");\n    ///\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .long(\"flag\")\n    ///         .env(\"MY_FLAG\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"flag\"), Some(\"env\"));\n    /// ```\n    ///\n    /// In this example, we show the variable coming from an option on the CLI:\n    ///\n    /// ```rust\n    /// # use std::env;\n    /// # use clap::{App, Arg};\n    ///\n    /// env::set_var(\"MY_FLAG\", \"env\");\n    ///\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .long(\"flag\")\n    ///         .env(\"MY_FLAG\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--flag\", \"opt\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"flag\"), Some(\"opt\"));\n    /// ```\n    ///\n    /// In this example, we show the variable coming from the environment even with the\n    /// presence of a default:\n    ///\n    /// ```rust\n    /// # use std::env;\n    /// # use clap::{App, Arg};\n    ///\n    /// env::set_var(\"MY_FLAG\", \"env\");\n    ///\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .long(\"flag\")\n    ///         .env(\"MY_FLAG\")\n    ///         .default_value(\"default\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"flag\"), Some(\"env\"));\n    /// ```\n    ///\n    /// In this example, we show the use of multiple values in a single environment variable:\n    ///\n    /// ```rust\n    /// # use std::env;\n    /// # use clap::{App, Arg};\n    ///\n    /// env::set_var(\"MY_FLAG_MULTI\", \"env1,env2\");\n    ///\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .long(\"flag\")\n    ///         .env(\"MY_FLAG_MULTI\")\n    ///         .multiple(true)\n    ///         .use_delimiter(true))\n    ///     .get_matches_from(vec![\n    ///         \"prog\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.values_of(\"flag\").unwrap().collect::<Vec<_>>(), vec![\"env1\", \"env2\"]);\n    /// ```\n    /// [`ArgMatches::occurrences_of`]: ./struct.ArgMatches.html#method.occurrences_of\n    /// [`ArgMatches::value_of`]: ./struct.ArgMatches.html#method.value_of\n    /// [`ArgMatches::is_present`]: ./struct.ArgMatches.html#method.is_present\n    /// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n    /// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n    /// [`Arg::use_delimiter(true)`]: ./struct.Arg.html#method.use_delimiter\n    pub fn env(self, name: &'a str) -> Self {\n        self.env_os(OsStr::new(name))\n    }\n\n    /// Specifies that if the value is not passed in as an argument, that it should be retrieved\n    /// from the environment if available in the exact same manner as [`Arg::env`] only using\n    /// [`OsStr`]s instead.\n    pub fn env_os(mut self, name: &'a OsStr) -> Self {\n        self.setb(ArgSettings::TakesValue);\n\n        self.v.env = Some((name, env::var_os(name)));\n        self\n    }\n\n    /// @TODO @p2 @docs @release: write docs\n    pub fn hide_env_values(self, hide: bool) -> Self {\n        if hide {\n            self.set(ArgSettings::HideEnvValues)\n        } else {\n            self.unset(ArgSettings::HideEnvValues)\n        }\n    }\n\n    /// When set to `true` the help string will be displayed on the line after the argument and\n    /// indented once. This can be helpful for arguments with very long or complex help messages.\n    /// This can also be helpful for arguments with very long flag names, or many/long value names.\n    ///\n    /// **NOTE:** To apply this setting to all arguments consider using\n    /// [`AppSettings::NextLineHelp`]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"opt\")\n    ///         .long(\"long-option-flag\")\n    ///         .short(\"o\")\n    ///         .takes_value(true)\n    ///         .value_names(&[\"value1\", \"value2\"])\n    ///         .help(\"Some really long help and complex\\n\\\n    ///                help that makes more sense to be\\n\\\n    ///                on a line after the option\")\n    ///         .next_line_help(true))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--help\"\n    ///     ]);\n    /// ```\n    ///\n    /// The above example displays the following help message\n    ///\n    /// ```notrust\n    /// nlh\n    ///\n    /// USAGE:\n    ///     nlh [FLAGS] [OPTIONS]\n    ///\n    /// FLAGS:\n    ///     -h, --help       Prints help information\n    ///     -V, --version    Prints version information\n    ///\n    /// OPTIONS:\n    ///     -o, --long-option-flag <value1> <value2>\n    ///         Some really long help and complex\n    ///         help that makes more sense to be\n    ///         on a line after the option\n    /// ```\n    /// [`AppSettings::NextLineHelp`]: ./enum.AppSettings.html#variant.NextLineHelp\n    pub fn next_line_help(mut self, nlh: bool) -> Self {\n        if nlh {\n            self.setb(ArgSettings::NextLineHelp);\n        } else {\n            self.unsetb(ArgSettings::NextLineHelp);\n        }\n        self\n    }\n\n    /// Allows custom ordering of args within the help message. Args with a lower value will be\n    /// displayed first in the help message. This is helpful when one would like to emphasise\n    /// frequently used args, or prioritize those towards the top of the list. Duplicate values\n    /// **are** allowed. Args with duplicate display orders will be displayed in alphabetical\n    /// order.\n    ///\n    /// **NOTE:** The default is 999 for all arguments.\n    ///\n    /// **NOTE:** This setting is ignored for [positional arguments] which are always displayed in\n    /// [index] order.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"a\") // Typically args are grouped alphabetically by name.\n    ///                              // Args without a display_order have a value of 999 and are\n    ///                              // displayed alphabetically with all other 999 valued args.\n    ///         .long(\"long-option\")\n    ///         .short(\"o\")\n    ///         .takes_value(true)\n    ///         .help(\"Some help and text\"))\n    ///     .arg(Arg::with_name(\"b\")\n    ///         .long(\"other-option\")\n    ///         .short(\"O\")\n    ///         .takes_value(true)\n    ///         .display_order(1)   // In order to force this arg to appear *first*\n    ///                             // all we have to do is give it a value lower than 999.\n    ///                             // Any other args with a value of 1 will be displayed\n    ///                             // alphabetically with this one...then 2 values, then 3, etc.\n    ///         .help(\"I should be first!\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--help\"\n    ///     ]);\n    /// ```\n    ///\n    /// The above example displays the following help message\n    ///\n    /// ```notrust\n    /// cust-ord\n    ///\n    /// USAGE:\n    ///     cust-ord [FLAGS] [OPTIONS]\n    ///\n    /// FLAGS:\n    ///     -h, --help       Prints help information\n    ///     -V, --version    Prints version information\n    ///\n    /// OPTIONS:\n    ///     -O, --other-option <b>    I should be first!\n    ///     -o, --long-option <a>     Some help and text\n    /// ```\n    /// [positional arguments]: ./struct.Arg.html#method.index\n    /// [index]: ./struct.Arg.html#method.index\n    pub fn display_order(mut self, ord: usize) -> Self {\n        self.s.disp_ord = ord;\n        self\n    }\n\n    /// Indicates that all parameters passed after this should not be parsed\n    /// individually, but rather passed in their entirety. It is worth noting\n    /// that setting this requires all values to come after a `--` to indicate they\n    /// should all be captured. For example:\n    ///\n    /// ```notrust\n    /// --foo something -- -v -v -v -b -b -b --baz -q -u -x\n    /// ```\n    /// Will result in everything after `--` to be considered one raw argument. This behavior\n    /// may not be exactly what you are expecting and using [`AppSettings::TrailingVarArg`]\n    /// may be more appropriate.\n    ///\n    /// **NOTE:** Implicitly sets [`Arg::multiple(true)`], [`Arg::allow_hyphen_values(true)`], and\n    /// [`Arg::last(true)`] when set to `true`\n    ///\n    /// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n    /// [`Arg::allow_hyphen_values(true)`]: ./struct.Arg.html#method.allow_hyphen_values\n    /// [`Arg::last(true)`]: ./struct.Arg.html#method.last\n    /// [`AppSettings::TrailingVarArg`]: ./enum.AppSettings.html#variant.TrailingVarArg\n    pub fn raw(self, raw: bool) -> Self {\n        self.multiple(raw).allow_hyphen_values(raw).last(raw)\n    }\n\n    /// Hides an argument from short help message output.\n    ///\n    /// **NOTE:** This does **not** hide the argument from usage strings on error\n    ///\n    /// **NOTE:** Setting this option will cause next-line-help output style to be used\n    /// when long help (`--help`) is called.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"debug\")\n    ///     .hidden_short_help(true)\n    /// # ;\n    /// ```\n    /// Setting `hidden_short_help(true)` will hide the argument when displaying short help text\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .long(\"config\")\n    ///         .hidden_short_help(true)\n    ///         .help(\"Some help text describing the --config arg\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-h\"\n    ///     ]);\n    /// ```\n    ///\n    /// The above example displays\n    ///\n    /// ```notrust\n    /// helptest\n    ///\n    /// USAGE:\n    ///    helptest [FLAGS]\n    ///\n    /// FLAGS:\n    /// -h, --help       Prints help information\n    /// -V, --version    Prints version information\n    /// ```\n    ///\n    /// However, when --help is called\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .long(\"config\")\n    ///         .hidden_short_help(true)\n    ///         .help(\"Some help text describing the --config arg\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--help\"\n    ///     ]);\n    /// ```\n    ///\n    /// Then the following would be displayed\n    ///\n    /// ```notrust\n    /// helptest\n    ///\n    /// USAGE:\n    ///    helptest [FLAGS]\n    ///\n    /// FLAGS:\n    ///     --config     Some help text describing the --config arg\n    /// -h, --help       Prints help information\n    /// -V, --version    Prints version information\n    /// ```\n    pub fn hidden_short_help(self, hide: bool) -> Self {\n        if hide {\n            self.set(ArgSettings::HiddenShortHelp)\n        } else {\n            self.unset(ArgSettings::HiddenShortHelp)\n        }\n    }\n\n    /// Hides an argument from long help message output.\n    ///\n    /// **NOTE:** This does **not** hide the argument from usage strings on error\n    ///\n    /// **NOTE:** Setting this option will cause next-line-help output style to be used\n    /// when long help (`--help`) is called.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// Arg::with_name(\"debug\")\n    ///     .hidden_long_help(true)\n    /// # ;\n    /// ```\n    /// Setting `hidden_long_help(true)` will hide the argument when displaying long help text\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .long(\"config\")\n    ///         .hidden_long_help(true)\n    ///         .help(\"Some help text describing the --config arg\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--help\"\n    ///     ]);\n    /// ```\n    ///\n    /// The above example displays\n    ///\n    /// ```notrust\n    /// helptest\n    ///\n    /// USAGE:\n    ///    helptest [FLAGS]\n    ///\n    /// FLAGS:\n    /// -h, --help       Prints help information\n    /// -V, --version    Prints version information\n    /// ```\n    ///\n    /// However, when -h is called\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"cfg\")\n    ///         .long(\"config\")\n    ///         .hidden_long_help(true)\n    ///         .help(\"Some help text describing the --config arg\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"-h\"\n    ///     ]);\n    /// ```\n    ///\n    /// Then the following would be displayed\n    ///\n    /// ```notrust\n    /// helptest\n    ///\n    /// USAGE:\n    ///    helptest [FLAGS]\n    ///\n    /// FLAGS:\n    ///     --config     Some help text describing the --config arg\n    /// -h, --help       Prints help information\n    /// -V, --version    Prints version information\n    /// ```\n    pub fn hidden_long_help(self, hide: bool) -> Self {\n        if hide {\n            self.set(ArgSettings::HiddenLongHelp)\n        } else {\n            self.unset(ArgSettings::HiddenLongHelp)\n        }\n    }\n\n    /// Checks if one of the [`ArgSettings`] settings is set for the argument.\n    ///\n    /// [`ArgSettings`]: ./enum.ArgSettings.html\n    pub fn is_set(&self, s: ArgSettings) -> bool {\n        self.b.is_set(s)\n    }\n\n    /// Sets one of the [`ArgSettings`] settings for the argument.\n    ///\n    /// [`ArgSettings`]: ./enum.ArgSettings.html\n    pub fn set(mut self, s: ArgSettings) -> Self {\n        self.setb(s);\n        self\n    }\n\n    /// Unsets one of the [`ArgSettings`] settings for the argument.\n    ///\n    /// [`ArgSettings`]: ./enum.ArgSettings.html\n    pub fn unset(mut self, s: ArgSettings) -> Self {\n        self.unsetb(s);\n        self\n    }\n\n    #[doc(hidden)]\n    pub fn setb(&mut self, s: ArgSettings) {\n        self.b.set(s);\n    }\n\n    #[doc(hidden)]\n    pub fn unsetb(&mut self, s: ArgSettings) {\n        self.b.unset(s);\n    }\n}","impl<'n, 'e> PartialEq for Arg<'n, 'e> {\n    fn eq(&self, other: &Arg<'n, 'e>) -> bool {\n        self.b == other.b\n    }\n}"],"args::arg_builder::base::Base":["Clone","Debug","Default","impl<'n, 'e, 'z> From<&'z Arg<'n, 'e>> for Base<'n, 'e> {\n    fn from(a: &'z Arg<'n, 'e>) -> Self {\n        a.b.clone()\n    }\n}","impl<'n, 'e> Base<'n, 'e> {\n    pub fn new(name: &'n str) -> Self {\n        Base {\n            name: name,\n            ..Default::default()\n        }\n    }\n\n    pub fn set(&mut self, s: ArgSettings) {\n        self.settings.set(s);\n    }\n    pub fn unset(&mut self, s: ArgSettings) {\n        self.settings.unset(s);\n    }\n    pub fn is_set(&self, s: ArgSettings) -> bool {\n        self.settings.is_set(s)\n    }\n}","impl<'n, 'e> PartialEq for Base<'n, 'e> {\n    fn eq(&self, other: &Base<'n, 'e>) -> bool {\n        self.name == other.name\n    }\n}"],"args::arg_builder::flag::FlagBuilder":["Clone","Debug","Default","impl<'a, 'b, 'z> From<&'z Arg<'a, 'b>> for FlagBuilder<'a, 'b> {\n    fn from(a: &'z Arg<'a, 'b>) -> Self {\n        FlagBuilder {\n            b: Base::from(a),\n            s: Switched::from(a),\n        }\n    }\n}","impl<'a, 'b> From<Arg<'a, 'b>> for FlagBuilder<'a, 'b> {\n    fn from(mut a: Arg<'a, 'b>) -> Self {\n        FlagBuilder {\n            b: mem::replace(&mut a.b, Base::default()),\n            s: mem::replace(&mut a.s, Switched::default()),\n        }\n    }\n}","impl<'n, 'e> AnyArg<'n, 'e> for FlagBuilder<'n, 'e> {\n    fn name(&self) -> &'n str {\n        self.b.name\n    }\n    fn overrides(&self) -> Option<&[&'e str]> {\n        self.b.overrides.as_ref().map(|o| &o[..])\n    }\n    fn requires(&self) -> Option<&[(Option<&'e str>, &'n str)]> {\n        self.b.requires.as_ref().map(|o| &o[..])\n    }\n    fn blacklist(&self) -> Option<&[&'e str]> {\n        self.b.blacklist.as_ref().map(|o| &o[..])\n    }\n    fn required_unless(&self) -> Option<&[&'e str]> {\n        self.b.r_unless.as_ref().map(|o| &o[..])\n    }\n    fn is_set(&self, s: ArgSettings) -> bool {\n        self.b.settings.is_set(s)\n    }\n    fn has_switch(&self) -> bool {\n        true\n    }\n    fn takes_value(&self) -> bool {\n        false\n    }\n    fn set(&mut self, s: ArgSettings) {\n        self.b.settings.set(s)\n    }\n    fn max_vals(&self) -> Option<u64> {\n        None\n    }\n    fn val_names(&self) -> Option<&VecMap<&'e str>> {\n        None\n    }\n    fn num_vals(&self) -> Option<u64> {\n        None\n    }\n    fn possible_vals(&self) -> Option<&[&'e str]> {\n        None\n    }\n    fn validator(&self) -> Option<&Rc<Fn(String) -> StdResult<(), String>>> {\n        None\n    }\n    fn validator_os(&self) -> Option<&Rc<Fn(&OsStr) -> StdResult<(), OsString>>> {\n        None\n    }\n    fn min_vals(&self) -> Option<u64> {\n        None\n    }\n    fn short(&self) -> Option<char> {\n        self.s.short\n    }\n    fn long(&self) -> Option<&'e str> {\n        self.s.long\n    }\n    fn val_delim(&self) -> Option<char> {\n        None\n    }\n    fn help(&self) -> Option<&'e str> {\n        self.b.help\n    }\n    fn long_help(&self) -> Option<&'e str> {\n        self.b.long_help\n    }\n    fn val_terminator(&self) -> Option<&'e str> {\n        None\n    }\n    fn default_val(&self) -> Option<&'e OsStr> {\n        None\n    }\n    fn default_vals_ifs(&self) -> Option<map::Values<(&'n str, Option<&'e OsStr>, &'e OsStr)>> {\n        None\n    }\n    fn env<'s>(&'s self) -> Option<(&'n OsStr, Option<&'s OsString>)> {\n        None\n    }\n    fn longest_filter(&self) -> bool {\n        self.s.long.is_some()\n    }\n    fn aliases(&self) -> Option<Vec<&'e str>> {\n        if let Some(ref aliases) = self.s.aliases {\n            let vis_aliases: Vec<_> = aliases\n                .iter()\n                .filter_map(|&(n, v)| if v { Some(n) } else { None })\n                .collect();\n            if vis_aliases.is_empty() {\n                None\n            } else {\n                Some(vis_aliases)\n            }\n        } else {\n            None\n        }\n    }\n}","impl<'n, 'e> DispOrder for FlagBuilder<'n, 'e> {\n    fn disp_ord(&self) -> usize {\n        self.s.disp_ord\n    }\n}","impl<'n, 'e> Display for FlagBuilder<'n, 'e> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        if let Some(l) = self.s.long {\n            write!(f, \"--{}\", l)?;\n        } else {\n            write!(f, \"-{}\", self.s.short.unwrap())?;\n        }\n\n        Ok(())\n    }\n}","impl<'n, 'e> FlagBuilder<'n, 'e> {\n    pub fn new(name: &'n str) -> Self {\n        FlagBuilder {\n            b: Base::new(name),\n            ..Default::default()\n        }\n    }\n}","impl<'n, 'e> PartialEq for FlagBuilder<'n, 'e> {\n    fn eq(&self, other: &FlagBuilder<'n, 'e>) -> bool {\n        self.b == other.b\n    }\n}"],"args::arg_builder::option::OptBuilder":["Clone","Default","impl<'n, 'e, 'z> From<&'z Arg<'n, 'e>> for OptBuilder<'n, 'e> {\n    fn from(a: &'z Arg<'n, 'e>) -> Self {\n        OptBuilder {\n            b: Base::from(a),\n            s: Switched::from(a),\n            v: Valued::from(a),\n        }\n    }\n}","impl<'n, 'e> AnyArg<'n, 'e> for OptBuilder<'n, 'e> {\n    fn name(&self) -> &'n str {\n        self.b.name\n    }\n    fn overrides(&self) -> Option<&[&'e str]> {\n        self.b.overrides.as_ref().map(|o| &o[..])\n    }\n    fn requires(&self) -> Option<&[(Option<&'e str>, &'n str)]> {\n        self.b.requires.as_ref().map(|o| &o[..])\n    }\n    fn blacklist(&self) -> Option<&[&'e str]> {\n        self.b.blacklist.as_ref().map(|o| &o[..])\n    }\n    fn required_unless(&self) -> Option<&[&'e str]> {\n        self.b.r_unless.as_ref().map(|o| &o[..])\n    }\n    fn val_names(&self) -> Option<&VecMap<&'e str>> {\n        self.v.val_names.as_ref()\n    }\n    fn is_set(&self, s: ArgSettings) -> bool {\n        self.b.settings.is_set(s)\n    }\n    fn has_switch(&self) -> bool {\n        true\n    }\n    fn set(&mut self, s: ArgSettings) {\n        self.b.settings.set(s)\n    }\n    fn max_vals(&self) -> Option<u64> {\n        self.v.max_vals\n    }\n    fn val_terminator(&self) -> Option<&'e str> {\n        self.v.terminator\n    }\n    fn num_vals(&self) -> Option<u64> {\n        self.v.num_vals\n    }\n    fn possible_vals(&self) -> Option<&[&'e str]> {\n        self.v.possible_vals.as_ref().map(|o| &o[..])\n    }\n    fn validator(&self) -> Option<&Rc<Fn(String) -> StdResult<(), String>>> {\n        self.v.validator.as_ref()\n    }\n    fn validator_os(&self) -> Option<&Rc<Fn(&OsStr) -> StdResult<(), OsString>>> {\n        self.v.validator_os.as_ref()\n    }\n    fn min_vals(&self) -> Option<u64> {\n        self.v.min_vals\n    }\n    fn short(&self) -> Option<char> {\n        self.s.short\n    }\n    fn long(&self) -> Option<&'e str> {\n        self.s.long\n    }\n    fn val_delim(&self) -> Option<char> {\n        self.v.val_delim\n    }\n    fn takes_value(&self) -> bool {\n        true\n    }\n    fn help(&self) -> Option<&'e str> {\n        self.b.help\n    }\n    fn long_help(&self) -> Option<&'e str> {\n        self.b.long_help\n    }\n    fn default_val(&self) -> Option<&'e OsStr> {\n        self.v.default_val\n    }\n    fn default_vals_ifs(&self) -> Option<map::Values<(&'n str, Option<&'e OsStr>, &'e OsStr)>> {\n        self.v.default_vals_ifs.as_ref().map(|vm| vm.values())\n    }\n    fn env<'s>(&'s self) -> Option<(&'n OsStr, Option<&'s OsString>)> {\n        self.v\n            .env\n            .as_ref()\n            .map(|&(key, ref value)| (key, value.as_ref()))\n    }\n    fn longest_filter(&self) -> bool {\n        true\n    }\n    fn aliases(&self) -> Option<Vec<&'e str>> {\n        if let Some(ref aliases) = self.s.aliases {\n            let vis_aliases: Vec<_> = aliases\n                .iter()\n                .filter_map(|&(n, v)| if v { Some(n) } else { None })\n                .collect();\n            if vis_aliases.is_empty() {\n                None\n            } else {\n                Some(vis_aliases)\n            }\n        } else {\n            None\n        }\n    }\n}","impl<'n, 'e> DispOrder for OptBuilder<'n, 'e> {\n    fn disp_ord(&self) -> usize {\n        self.s.disp_ord\n    }\n}","impl<'n, 'e> Display for OptBuilder<'n, 'e> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        debugln!(\"OptBuilder::fmt:{}\", self.b.name);\n        let sep = if self.b.is_set(ArgSettings::RequireEquals) {\n            \"=\"\n        } else {\n            \" \"\n        };\n        // Write the name such --long or -l\n        if let Some(l) = self.s.long {\n            write!(f, \"--{}{}\", l, sep)?;\n        } else {\n            write!(f, \"-{}{}\", self.s.short.unwrap(), sep)?;\n        }\n        let delim = if self.is_set(ArgSettings::RequireDelimiter) {\n            self.v.val_delim.expect(INTERNAL_ERROR_MSG)\n        } else {\n            ' '\n        };\n\n        // Write the values such as <name1> <name2>\n        if let Some(ref vec) = self.v.val_names {\n            let mut it = vec.iter().peekable();\n            while let Some((_, val)) = it.next() {\n                write!(f, \"<{}>\", val)?;\n                if it.peek().is_some() {\n                    write!(f, \"{}\", delim)?;\n                }\n            }\n            let num = vec.len();\n            if self.is_set(ArgSettings::Multiple) && num == 1 {\n                write!(f, \"...\")?;\n            }\n        } else if let Some(num) = self.v.num_vals {\n            let mut it = (0..num).peekable();\n            while let Some(_) = it.next() {\n                write!(f, \"<{}>\", self.b.name)?;\n                if it.peek().is_some() {\n                    write!(f, \"{}\", delim)?;\n                }\n            }\n            if self.is_set(ArgSettings::Multiple) && num == 1 {\n                write!(f, \"...\")?;\n            }\n        } else {\n            write!(\n                f,\n                \"<{}>{}\",\n                self.b.name,\n                if self.is_set(ArgSettings::Multiple) {\n                    \"...\"\n                } else {\n                    \"\"\n                }\n            )?;\n        }\n\n        Ok(())\n    }\n}","impl<'n, 'e> From<Arg<'n, 'e>> for OptBuilder<'n, 'e> {\n    fn from(mut a: Arg<'n, 'e>) -> Self {\n        a.v.fill_in();\n        OptBuilder {\n            b: mem::replace(&mut a.b, Base::default()),\n            s: mem::replace(&mut a.s, Switched::default()),\n            v: mem::replace(&mut a.v, Valued::default()),\n        }\n    }\n}","impl<'n, 'e> OptBuilder<'n, 'e> {\n    pub fn new(name: &'n str) -> Self {\n        OptBuilder {\n            b: Base::new(name),\n            ..Default::default()\n        }\n    }\n}","impl<'n, 'e> PartialEq for OptBuilder<'n, 'e> {\n    fn eq(&self, other: &OptBuilder<'n, 'e>) -> bool {\n        self.b == other.b\n    }\n}"],"args::arg_builder::positional::PosBuilder":["Clone","Default","impl<'n, 'e> AnyArg<'n, 'e> for PosBuilder<'n, 'e> {\n    fn name(&self) -> &'n str {\n        self.b.name\n    }\n    fn overrides(&self) -> Option<&[&'e str]> {\n        self.b.overrides.as_ref().map(|o| &o[..])\n    }\n    fn requires(&self) -> Option<&[(Option<&'e str>, &'n str)]> {\n        self.b.requires.as_ref().map(|o| &o[..])\n    }\n    fn blacklist(&self) -> Option<&[&'e str]> {\n        self.b.blacklist.as_ref().map(|o| &o[..])\n    }\n    fn required_unless(&self) -> Option<&[&'e str]> {\n        self.b.r_unless.as_ref().map(|o| &o[..])\n    }\n    fn val_names(&self) -> Option<&VecMap<&'e str>> {\n        self.v.val_names.as_ref()\n    }\n    fn is_set(&self, s: ArgSettings) -> bool {\n        self.b.settings.is_set(s)\n    }\n    fn set(&mut self, s: ArgSettings) {\n        self.b.settings.set(s)\n    }\n    fn has_switch(&self) -> bool {\n        false\n    }\n    fn max_vals(&self) -> Option<u64> {\n        self.v.max_vals\n    }\n    fn val_terminator(&self) -> Option<&'e str> {\n        self.v.terminator\n    }\n    fn num_vals(&self) -> Option<u64> {\n        self.v.num_vals\n    }\n    fn possible_vals(&self) -> Option<&[&'e str]> {\n        self.v.possible_vals.as_ref().map(|o| &o[..])\n    }\n    fn validator(&self) -> Option<&Rc<Fn(String) -> StdResult<(), String>>> {\n        self.v.validator.as_ref()\n    }\n    fn validator_os(&self) -> Option<&Rc<Fn(&OsStr) -> StdResult<(), OsString>>> {\n        self.v.validator_os.as_ref()\n    }\n    fn min_vals(&self) -> Option<u64> {\n        self.v.min_vals\n    }\n    fn short(&self) -> Option<char> {\n        None\n    }\n    fn long(&self) -> Option<&'e str> {\n        None\n    }\n    fn val_delim(&self) -> Option<char> {\n        self.v.val_delim\n    }\n    fn takes_value(&self) -> bool {\n        true\n    }\n    fn help(&self) -> Option<&'e str> {\n        self.b.help\n    }\n    fn long_help(&self) -> Option<&'e str> {\n        self.b.long_help\n    }\n    fn default_vals_ifs(&self) -> Option<map::Values<(&'n str, Option<&'e OsStr>, &'e OsStr)>> {\n        self.v.default_vals_ifs.as_ref().map(|vm| vm.values())\n    }\n    fn default_val(&self) -> Option<&'e OsStr> {\n        self.v.default_val\n    }\n    fn env<'s>(&'s self) -> Option<(&'n OsStr, Option<&'s OsString>)> {\n        self.v\n            .env\n            .as_ref()\n            .map(|&(key, ref value)| (key, value.as_ref()))\n    }\n    fn longest_filter(&self) -> bool {\n        true\n    }\n    fn aliases(&self) -> Option<Vec<&'e str>> {\n        None\n    }\n}","impl<'n, 'e> DispOrder for PosBuilder<'n, 'e> {\n    fn disp_ord(&self) -> usize {\n        self.index as usize\n    }\n}","impl<'n, 'e> Display for PosBuilder<'n, 'e> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        let mut delim = String::new();\n        delim.push(if self.is_set(ArgSettings::RequireDelimiter) {\n            self.v.val_delim.expect(INTERNAL_ERROR_MSG)\n        } else {\n            ' '\n        });\n        if let Some(ref names) = self.v.val_names {\n            write!(\n                f,\n                \"{}\",\n                names\n                    .values()\n                    .map(|n| format!(\"<{}>\", n))\n                    .collect::<Vec<_>>()\n                    .join(&*delim)\n            )?;\n        } else {\n            write!(f, \"<{}>\", self.b.name)?;\n        }\n        if self.b.settings.is_set(ArgSettings::Multiple)\n            && (self.v.val_names.is_none() || self.v.val_names.as_ref().unwrap().len() == 1)\n        {\n            write!(f, \"...\")?;\n        }\n\n        Ok(())\n    }\n}","impl<'n, 'e> PartialEq for PosBuilder<'n, 'e> {\n    fn eq(&self, other: &PosBuilder<'n, 'e>) -> bool {\n        self.b == other.b\n    }\n}","impl<'n, 'e> PosBuilder<'n, 'e> {\n    pub fn new(name: &'n str, idx: u64) -> Self {\n        PosBuilder {\n            b: Base::new(name),\n            index: idx,\n            ..Default::default()\n        }\n    }\n\n    pub fn from_arg_ref(a: &Arg<'n, 'e>, idx: u64) -> Self {\n        let mut pb = PosBuilder {\n            b: Base::from(a),\n            v: Valued::from(a),\n            index: idx,\n        };\n        if a.v.max_vals.is_some()\n            || a.v.min_vals.is_some()\n            || (a.v.num_vals.is_some() && a.v.num_vals.unwrap() > 1)\n        {\n            pb.b.settings.set(ArgSettings::Multiple);\n        }\n        pb\n    }\n\n    pub fn from_arg(mut a: Arg<'n, 'e>, idx: u64) -> Self {\n        if a.v.max_vals.is_some()\n            || a.v.min_vals.is_some()\n            || (a.v.num_vals.is_some() && a.v.num_vals.unwrap() > 1)\n        {\n            a.b.settings.set(ArgSettings::Multiple);\n        }\n        PosBuilder {\n            b: mem::replace(&mut a.b, Base::default()),\n            v: mem::replace(&mut a.v, Valued::default()),\n            index: idx,\n        }\n    }\n\n    pub fn multiple_str(&self) -> &str {\n        let mult_vals = self\n            .v\n            .val_names\n            .as_ref()\n            .map_or(true, |names| names.len() < 2);\n        if self.is_set(ArgSettings::Multiple) && mult_vals {\n            \"...\"\n        } else {\n            \"\"\n        }\n    }\n\n    pub fn name_no_brackets(&self) -> Cow<str> {\n        debugln!(\"PosBuilder::name_no_brackets;\");\n        let mut delim = String::new();\n        delim.push(if self.is_set(ArgSettings::RequireDelimiter) {\n            self.v.val_delim.expect(INTERNAL_ERROR_MSG)\n        } else {\n            ' '\n        });\n        if let Some(ref names) = self.v.val_names {\n            debugln!(\"PosBuilder:name_no_brackets: val_names={:#?}\", names);\n            if names.len() > 1 {\n                Cow::Owned(\n                    names\n                        .values()\n                        .map(|n| format!(\"<{}>\", n))\n                        .collect::<Vec<_>>()\n                        .join(&*delim),\n                )\n            } else {\n                Cow::Borrowed(names.values().next().expect(INTERNAL_ERROR_MSG))\n            }\n        } else {\n            debugln!(\"PosBuilder:name_no_brackets: just name\");\n            Cow::Borrowed(self.b.name)\n        }\n    }\n}"],"args::arg_builder::switched::Switched":["Debug","impl<'e> Clone for Switched<'e> {\n    fn clone(&self) -> Self {\n        Switched {\n            short: self.short,\n            long: self.long,\n            aliases: self.aliases.clone(),\n            disp_ord: self.disp_ord,\n            unified_ord: self.unified_ord,\n        }\n    }\n}","impl<'e> Default for Switched<'e> {\n    fn default() -> Self {\n        Switched {\n            short: None,\n            long: None,\n            aliases: None,\n            disp_ord: 999,\n            unified_ord: 999,\n        }\n    }\n}","impl<'n, 'e, 'z> From<&'z Arg<'n, 'e>> for Switched<'e> {\n    fn from(a: &'z Arg<'n, 'e>) -> Self {\n        a.s.clone()\n    }\n}"],"args::arg_builder::valued::Valued":["Clone","impl<'n, 'e, 'z> From<&'z Arg<'n, 'e>> for Valued<'n, 'e> {\n    fn from(a: &'z Arg<'n, 'e>) -> Self {\n        let mut v = a.v.clone();\n        if let Some(ref vec) = a.v.val_names {\n            if vec.len() > 1 {\n                v.num_vals = Some(vec.len() as u64);\n            }\n        }\n        v\n    }\n}","impl<'n, 'e> Default for Valued<'n, 'e> {\n    fn default() -> Self {\n        Valued {\n            possible_vals: None,\n            num_vals: None,\n            min_vals: None,\n            max_vals: None,\n            val_names: None,\n            validator: None,\n            validator_os: None,\n            val_delim: None,\n            default_val: None,\n            default_vals_ifs: None,\n            env: None,\n            terminator: None,\n        }\n    }\n}","impl<'n, 'e> Valued<'n, 'e> {\n    pub fn fill_in(&mut self) {\n        if let Some(ref vec) = self.val_names {\n            if vec.len() > 1 {\n                self.num_vals = Some(vec.len() as u64);\n            }\n        }\n    }\n}"],"args::arg_matcher::ArgMatcher":["impl<'a> ArgMatcher<'a> {\n    pub fn new() -> Self {\n        ArgMatcher::default()\n    }\n\n    pub fn process_arg_overrides<'b>(\n        &mut self,\n        a: Option<&AnyArg<'a, 'b>>,\n        overrides: &mut Vec<(&'b str, &'a str)>,\n        required: &mut Vec<&'a str>,\n        check_all: bool,\n    ) {\n        debugln!(\n            \"ArgMatcher::process_arg_overrides:{:?};\",\n            a.map_or(None, |a| Some(a.name()))\n        );\n        if let Some(aa) = a {\n            let mut self_done = false;\n            if let Some(a_overrides) = aa.overrides() {\n                for overr in a_overrides {\n                    debugln!(\"ArgMatcher::process_arg_overrides:iter:{};\", overr);\n                    if overr == &aa.name() {\n                        self_done = true;\n                        self.handle_self_overrides(a);\n                    } else if self.is_present(overr) {\n                        debugln!(\n                            \"ArgMatcher::process_arg_overrides:iter:{}: removing from matches;\",\n                            overr\n                        );\n                        self.remove(overr);\n                        for i in (0..required.len()).rev() {\n                            if &required[i] == overr {\n                                debugln!(\n                                    \"ArgMatcher::process_arg_overrides:iter:{}: removing required;\",\n                                    overr\n                                );\n                                required.swap_remove(i);\n                                break;\n                            }\n                        }\n                        overrides.push((overr, aa.name()));\n                    } else {\n                        overrides.push((overr, aa.name()));\n                    }\n                }\n            }\n            if check_all && !self_done {\n                self.handle_self_overrides(a);\n            }\n        }\n    }\n\n    pub fn handle_self_overrides<'b>(&mut self, a: Option<&AnyArg<'a, 'b>>) {\n        debugln!(\n            \"ArgMatcher::handle_self_overrides:{:?};\",\n            a.map_or(None, |a| Some(a.name()))\n        );\n        if let Some(aa) = a {\n            if !aa.has_switch() || aa.is_set(ArgSettings::Multiple) {\n                // positional args can't override self or else we would never advance to the next\n\n                // Also flags with --multiple set are ignored otherwise we could never have more\n                // than one\n                return;\n            }\n            if let Some(ma) = self.get_mut(aa.name()) {\n                if ma.vals.len() > 1 {\n                    // swap_remove(0) would be O(1) but does not preserve order, which\n                    // we need\n                    ma.vals.remove(0);\n                    ma.occurs = 1;\n                } else if !aa.takes_value() && ma.occurs > 1 {\n                    ma.occurs = 1;\n                }\n            }\n        }\n    }\n\n    pub fn is_present(&self, name: &str) -> bool {\n        self.0.is_present(name)\n    }\n\n    pub fn propagate_globals(&mut self, global_arg_vec: &[&'a str]) {\n        debugln!(\n            \"ArgMatcher::get_global_values: global_arg_vec={:?}\",\n            global_arg_vec\n        );\n        let mut vals_map = HashMap::new();\n        self.fill_in_global_values(global_arg_vec, &mut vals_map);\n    }\n\n    fn fill_in_global_values(\n        &mut self,\n        global_arg_vec: &[&'a str],\n        vals_map: &mut HashMap<&'a str, MatchedArg>,\n    ) {\n        for global_arg in global_arg_vec {\n            if let Some(ma) = self.get(global_arg) {\n                // We have to check if the parent's global arg wasn't used but still exists\n                // such as from a default value.\n                //\n                // For example, `myprog subcommand --global-arg=value` where --global-arg defines\n                // a default value of `other` myprog would have an existing MatchedArg for\n                // --global-arg where the value is `other`, however the occurs will be 0.\n                let to_update = if let Some(parent_ma) = vals_map.get(global_arg) {\n                    if parent_ma.occurs > 0 && ma.occurs == 0 {\n                        parent_ma.clone()\n                    } else {\n                        ma.clone()\n                    }\n                } else {\n                    ma.clone()\n                };\n                vals_map.insert(global_arg, to_update);\n            }\n        }\n        if let Some(ref mut sc) = self.0.subcommand {\n            let mut am = ArgMatcher(mem::replace(&mut sc.matches, ArgMatches::new()));\n            am.fill_in_global_values(global_arg_vec, vals_map);\n            mem::swap(&mut am.0, &mut sc.matches);\n        }\n\n        for (name, matched_arg) in vals_map.into_iter() {\n            self.0.args.insert(name, matched_arg.clone());\n        }\n    }\n\n    pub fn get_mut(&mut self, arg: &str) -> Option<&mut MatchedArg> {\n        self.0.args.get_mut(arg)\n    }\n\n    pub fn get(&self, arg: &str) -> Option<&MatchedArg> {\n        self.0.args.get(arg)\n    }\n\n    pub fn remove(&mut self, arg: &str) {\n        self.0.args.remove(arg);\n    }\n\n    pub fn remove_all(&mut self, args: &[&str]) {\n        for &arg in args {\n            self.0.args.remove(arg);\n        }\n    }\n\n    pub fn insert(&mut self, name: &'a str) {\n        self.0.args.insert(name, MatchedArg::new());\n    }\n\n    pub fn contains(&self, arg: &str) -> bool {\n        self.0.args.contains_key(arg)\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.0.args.is_empty()\n    }\n\n    pub fn usage(&mut self, usage: String) {\n        self.0.usage = Some(usage);\n    }\n\n    pub fn arg_names(&'a self) -> Vec<&'a str> {\n        self.0.args.keys().map(Deref::deref).collect()\n    }\n\n    pub fn entry(&mut self, arg: &'a str) -> Entry<&'a str, MatchedArg> {\n        self.0.args.entry(arg)\n    }\n\n    pub fn subcommand(&mut self, sc: SubCommand<'a>) {\n        self.0.subcommand = Some(Box::new(sc));\n    }\n\n    pub fn subcommand_name(&self) -> Option<&str> {\n        self.0.subcommand_name()\n    }\n\n    pub fn iter(&self) -> Iter<&str, MatchedArg> {\n        self.0.args.iter()\n    }\n\n    pub fn inc_occurrence_of(&mut self, arg: &'a str) {\n        debugln!(\"ArgMatcher::inc_occurrence_of: arg={}\", arg);\n        if let Some(a) = self.get_mut(arg) {\n            a.occurs += 1;\n            return;\n        }\n        debugln!(\"ArgMatcher::inc_occurrence_of: first instance\");\n        self.insert(arg);\n    }\n\n    pub fn inc_occurrences_of(&mut self, args: &[&'a str]) {\n        debugln!(\"ArgMatcher::inc_occurrences_of: args={:?}\", args);\n        for arg in args {\n            self.inc_occurrence_of(arg);\n        }\n    }\n\n    pub fn add_val_to(&mut self, arg: &'a str, val: &OsStr) {\n        let ma = self.entry(arg).or_insert(MatchedArg {\n            occurs: 0,\n            indices: Vec::with_capacity(1),\n            vals: Vec::with_capacity(1),\n        });\n        ma.vals.push(val.to_owned());\n    }\n\n    pub fn add_index_to(&mut self, arg: &'a str, idx: usize) {\n        let ma = self.entry(arg).or_insert(MatchedArg {\n            occurs: 0,\n            indices: Vec::with_capacity(1),\n            vals: Vec::new(),\n        });\n        ma.indices.push(idx);\n    }\n\n    pub fn needs_more_vals<'b, A>(&self, o: &A) -> bool\n    where\n        A: AnyArg<'a, 'b>,\n    {\n        debugln!(\"ArgMatcher::needs_more_vals: o={}\", o.name());\n        if let Some(ma) = self.get(o.name()) {\n            if let Some(num) = o.num_vals() {\n                debugln!(\"ArgMatcher::needs_more_vals: num_vals...{}\", num);\n                return if o.is_set(ArgSettings::Multiple) {\n                    ((ma.vals.len() as u64) % num) != 0\n                } else {\n                    num != (ma.vals.len() as u64)\n                };\n            } else if let Some(num) = o.max_vals() {\n                debugln!(\"ArgMatcher::needs_more_vals: max_vals...{}\", num);\n                return !((ma.vals.len() as u64) > num);\n            } else if o.min_vals().is_some() {\n                debugln!(\"ArgMatcher::needs_more_vals: min_vals...true\");\n                return true;\n            }\n            return o.is_set(ArgSettings::Multiple);\n        }\n        true\n    }\n}","impl<'a> Default for ArgMatcher<'a> {\n    fn default() -> Self {\n        ArgMatcher(ArgMatches::default())\n    }\n}","impl<'a> Into<ArgMatches<'a>> for ArgMatcher<'a> {\n    fn into(self) -> ArgMatches<'a> {\n        self.0\n    }\n}"],"args::arg_matches::ArgMatches":["Clone","Debug","impl<'a> ArgMatches<'a> {\n    #[doc(hidden)]\n    pub fn new() -> Self {\n        ArgMatches {\n            ..Default::default()\n        }\n    }\n\n    /// Gets the value of a specific [option] or [positional] argument (i.e. an argument that takes\n    /// an additional value at runtime). If the option wasn't present at runtime\n    /// it returns `None`.\n    ///\n    /// *NOTE:* If getting a value for an option or positional argument that allows multiples,\n    /// prefer [`ArgMatches::values_of`] as `ArgMatches::value_of` will only return the *first*\n    /// value.\n    ///\n    /// # Panics\n    ///\n    /// This method will [`panic!`] if the value contains invalid UTF-8 code points.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myapp\")\n    ///     .arg(Arg::with_name(\"output\")\n    ///         .takes_value(true))\n    ///     .get_matches_from(vec![\"myapp\", \"something\"]);\n    ///\n    /// assert_eq!(m.value_of(\"output\"), Some(\"something\"));\n    /// ```\n    /// [option]: ./struct.Arg.html#method.takes_value\n    /// [positional]: ./struct.Arg.html#method.index\n    /// [`ArgMatches::values_of`]: ./struct.ArgMatches.html#method.values_of\n    /// [`panic!`]: https://doc.rust-lang.org/std/macro.panic!.html\n    pub fn value_of<S: AsRef<str>>(&self, name: S) -> Option<&str> {\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            if let Some(v) = arg.vals.get(0) {\n                return Some(v.to_str().expect(INVALID_UTF8));\n            }\n        }\n        None\n    }\n\n    /// Gets the lossy value of a specific argument. If the argument wasn't present at runtime\n    /// it returns `None`. A lossy value is one which contains invalid UTF-8 code points, those\n    /// invalid points will be replaced with `\\u{FFFD}`\n    ///\n    /// *NOTE:* If getting a value for an option or positional argument that allows multiples,\n    /// prefer [`Arg::values_of_lossy`] as `value_of_lossy()` will only return the *first* value.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(not(unix), doc = \" ```ignore\")]\n    #[cfg_attr(unix, doc = \" ```\")]\n    /// # use clap::{App, Arg};\n    /// use std::ffi::OsString;\n    /// use std::os::unix::ffi::{OsStrExt,OsStringExt};\n    ///\n    /// let m = App::new(\"utf8\")\n    ///     .arg(Arg::from_usage(\"<arg> 'some arg'\"))\n    ///     .get_matches_from(vec![OsString::from(\"myprog\"),\n    ///                             // \"Hi {0xe9}!\"\n    ///                             OsString::from_vec(vec![b'H', b'i', b' ', 0xe9, b'!'])]);\n    /// assert_eq!(&*m.value_of_lossy(\"arg\").unwrap(), \"Hi \\u{FFFD}!\");\n    /// ```\n    /// [`Arg::values_of_lossy`]: ./struct.ArgMatches.html#method.values_of_lossy\n    pub fn value_of_lossy<S: AsRef<str>>(&'a self, name: S) -> Option<Cow<'a, str>> {\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            if let Some(v) = arg.vals.get(0) {\n                return Some(v.to_string_lossy());\n            }\n        }\n        None\n    }\n\n    /// Gets the OS version of a string value of a specific argument. If the option wasn't present\n    /// at runtime it returns `None`. An OS value on Unix-like systems is any series of bytes,\n    /// regardless of whether or not they contain valid UTF-8 code points. Since [`String`]s in\n    /// Rust are guaranteed to be valid UTF-8, a valid filename on a Unix system as an argument\n    /// value may contain invalid UTF-8 code points.\n    ///\n    /// *NOTE:* If getting a value for an option or positional argument that allows multiples,\n    /// prefer [`ArgMatches::values_of_os`] as `Arg::value_of_os` will only return the *first*\n    /// value.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(not(unix), doc = \" ```ignore\")]\n    #[cfg_attr(unix, doc = \" ```\")]\n    /// # use clap::{App, Arg};\n    /// use std::ffi::OsString;\n    /// use std::os::unix::ffi::{OsStrExt,OsStringExt};\n    ///\n    /// let m = App::new(\"utf8\")\n    ///     .arg(Arg::from_usage(\"<arg> 'some arg'\"))\n    ///     .get_matches_from(vec![OsString::from(\"myprog\"),\n    ///                             // \"Hi {0xe9}!\"\n    ///                             OsString::from_vec(vec![b'H', b'i', b' ', 0xe9, b'!'])]);\n    /// assert_eq!(&*m.value_of_os(\"arg\").unwrap().as_bytes(), [b'H', b'i', b' ', 0xe9, b'!']);\n    /// ```\n    /// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html\n    /// [`ArgMatches::values_of_os`]: ./struct.ArgMatches.html#method.values_of_os\n    pub fn value_of_os<S: AsRef<str>>(&self, name: S) -> Option<&OsStr> {\n        self.args\n            .get(name.as_ref())\n            .and_then(|arg| arg.vals.get(0).map(|v| v.as_os_str()))\n    }\n\n    /// Gets a [`Values`] struct which implements [`Iterator`] for values of a specific argument\n    /// (i.e. an argument that takes multiple values at runtime). If the option wasn't present at\n    /// runtime it returns `None`\n    ///\n    /// # Panics\n    ///\n    /// This method will panic if any of the values contain invalid UTF-8 code points.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"output\")\n    ///         .multiple(true)\n    ///         .short(\"o\")\n    ///         .takes_value(true))\n    ///     .get_matches_from(vec![\n    ///         \"myprog\", \"-o\", \"val1\", \"val2\", \"val3\"\n    ///     ]);\n    /// let vals: Vec<&str> = m.values_of(\"output\").unwrap().collect();\n    /// assert_eq!(vals, [\"val1\", \"val2\", \"val3\"]);\n    /// ```\n    /// [`Values`]: ./struct.Values.html\n    /// [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n    pub fn values_of<S: AsRef<str>>(&'a self, name: S) -> Option<Values<'a>> {\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            fn to_str_slice(o: &OsString) -> &str {\n                o.to_str().expect(INVALID_UTF8)\n            }\n            let to_str_slice: fn(&OsString) -> &str = to_str_slice; // coerce to fn pointer\n            return Some(Values {\n                iter: arg.vals.iter().map(to_str_slice),\n            });\n        }\n        None\n    }\n\n    /// Gets the lossy values of a specific argument. If the option wasn't present at runtime\n    /// it returns `None`. A lossy value is one where if it contains invalid UTF-8 code points,\n    /// those invalid points will be replaced with `\\u{FFFD}`\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(not(unix), doc = \" ```ignore\")]\n    #[cfg_attr(unix, doc = \" ```\")]\n    /// # use clap::{App, Arg};\n    /// use std::ffi::OsString;\n    /// use std::os::unix::ffi::OsStringExt;\n    ///\n    /// let m = App::new(\"utf8\")\n    ///     .arg(Arg::from_usage(\"<arg>... 'some arg'\"))\n    ///     .get_matches_from(vec![OsString::from(\"myprog\"),\n    ///                             // \"Hi\"\n    ///                             OsString::from_vec(vec![b'H', b'i']),\n    ///                             // \"{0xe9}!\"\n    ///                             OsString::from_vec(vec![0xe9, b'!'])]);\n    /// let mut itr = m.values_of_lossy(\"arg\").unwrap().into_iter();\n    /// assert_eq!(&itr.next().unwrap()[..], \"Hi\");\n    /// assert_eq!(&itr.next().unwrap()[..], \"\\u{FFFD}!\");\n    /// assert_eq!(itr.next(), None);\n    /// ```\n    pub fn values_of_lossy<S: AsRef<str>>(&'a self, name: S) -> Option<Vec<String>> {\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            return Some(\n                arg.vals\n                    .iter()\n                    .map(|v| v.to_string_lossy().into_owned())\n                    .collect(),\n            );\n        }\n        None\n    }\n\n    /// Gets a [`OsValues`] struct which is implements [`Iterator`] for [`OsString`] values of a\n    /// specific argument. If the option wasn't present at runtime it returns `None`. An OS value\n    /// on Unix-like systems is any series of bytes, regardless of whether or not they contain\n    /// valid UTF-8 code points. Since [`String`]s in Rust are guaranteed to be valid UTF-8, a valid\n    /// filename as an argument value on Linux (for example) may contain invalid UTF-8 code points.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(not(unix), doc = \" ```ignore\")]\n    #[cfg_attr(unix, doc = \" ```\")]\n    /// # use clap::{App, Arg};\n    /// use std::ffi::{OsStr,OsString};\n    /// use std::os::unix::ffi::{OsStrExt,OsStringExt};\n    ///\n    /// let m = App::new(\"utf8\")\n    ///     .arg(Arg::from_usage(\"<arg>... 'some arg'\"))\n    ///     .get_matches_from(vec![OsString::from(\"myprog\"),\n    ///                                 // \"Hi\"\n    ///                                 OsString::from_vec(vec![b'H', b'i']),\n    ///                                 // \"{0xe9}!\"\n    ///                                 OsString::from_vec(vec![0xe9, b'!'])]);\n    ///\n    /// let mut itr = m.values_of_os(\"arg\").unwrap().into_iter();\n    /// assert_eq!(itr.next(), Some(OsStr::new(\"Hi\")));\n    /// assert_eq!(itr.next(), Some(OsStr::from_bytes(&[0xe9, b'!'])));\n    /// assert_eq!(itr.next(), None);\n    /// ```\n    /// [`OsValues`]: ./struct.OsValues.html\n    /// [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n    /// [`OsString`]: https://doc.rust-lang.org/std/ffi/struct.OsString.html\n    /// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html\n    pub fn values_of_os<S: AsRef<str>>(&'a self, name: S) -> Option<OsValues<'a>> {\n        fn to_str_slice(o: &OsString) -> &OsStr {\n            &*o\n        }\n        let to_str_slice: fn(&'a OsString) -> &'a OsStr = to_str_slice; // coerce to fn pointer\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            return Some(OsValues {\n                iter: arg.vals.iter().map(to_str_slice),\n            });\n        }\n        None\n    }\n\n    /// Returns `true` if an argument was present at runtime, otherwise `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .short(\"d\"))\n    ///     .get_matches_from(vec![\n    ///         \"myprog\", \"-d\"\n    ///     ]);\n    ///\n    /// assert!(m.is_present(\"debug\"));\n    /// ```\n    pub fn is_present<S: AsRef<str>>(&self, name: S) -> bool {\n        if let Some(ref sc) = self.subcommand {\n            if sc.name == name.as_ref() {\n                return true;\n            }\n        }\n        self.args.contains_key(name.as_ref())\n    }\n\n    /// Returns the number of times an argument was used at runtime. If an argument isn't present\n    /// it will return `0`.\n    ///\n    /// **NOTE:** This returns the number of times the argument was used, *not* the number of\n    /// values. For example, `-o val1 val2 val3 -o val4` would return `2` (2 occurrences, but 4\n    /// values).\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .short(\"d\")\n    ///         .multiple(true))\n    ///     .get_matches_from(vec![\n    ///         \"myprog\", \"-d\", \"-d\", \"-d\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.occurrences_of(\"debug\"), 3);\n    /// ```\n    ///\n    /// This next example shows that counts actual uses of the argument, not just `-`'s\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .short(\"d\")\n    ///         .multiple(true))\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .get_matches_from(vec![\n    ///         \"myprog\", \"-ddfd\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.occurrences_of(\"debug\"), 3);\n    /// assert_eq!(m.occurrences_of(\"flag\"), 1);\n    /// ```\n    pub fn occurrences_of<S: AsRef<str>>(&self, name: S) -> u64 {\n        self.args.get(name.as_ref()).map_or(0, |a| a.occurs)\n    }\n\n    /// Gets the starting index of the argument in respect to all other arguments. Indices are\n    /// similar to argv indices, but are not exactly 1:1.\n    ///\n    /// For flags (i.e. those arguments which don't have an associated value), indices refer\n    /// to occurrence of the switch, such as `-f`, or `--flag`. However, for options the indices\n    /// refer to the *values* `-o val` would therefore not represent two distinct indices, only the\n    /// index for `val` would be recorded. This is by design.\n    ///\n    /// Besides the flag/option descrepancy, the primary difference between an argv index and clap\n    /// index, is that clap continues counting once all arguments have properly seperated, whereas\n    /// an argv index does not.\n    ///\n    /// The examples should clear this up.\n    ///\n    /// *NOTE:* If an argument is allowed multiple times, this method will only give the *first*\n    /// index.\n    ///\n    /// # Examples\n    ///\n    /// The argv indices are listed in the comments below. See how they correspond to the clap\n    /// indices. Note that if it's not listed in a clap index, this is becuase it's not saved in\n    /// in an `ArgMatches` struct for querying.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myapp\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .short(\"o\")\n    ///         .takes_value(true))\n    ///     .get_matches_from(vec![\"myapp\", \"-f\", \"-o\", \"val\"]);\n    ///             // ARGV idices: ^0       ^1    ^2    ^3\n    ///             // clap idices:          ^1          ^3\n    ///\n    /// assert_eq!(m.index_of(\"flag\"), Some(1));\n    /// assert_eq!(m.index_of(\"option\"), Some(3));\n    /// ```\n    ///\n    /// Now notice, if we use one of the other styles of options:\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myapp\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .short(\"o\")\n    ///         .takes_value(true))\n    ///     .get_matches_from(vec![\"myapp\", \"-f\", \"-o=val\"]);\n    ///             // ARGV idices: ^0       ^1    ^2\n    ///             // clap idices:          ^1       ^3\n    ///\n    /// assert_eq!(m.index_of(\"flag\"), Some(1));\n    /// assert_eq!(m.index_of(\"option\"), Some(3));\n    /// ```\n    ///\n    /// Things become much more complicated, or clear if we look at a more complex combination of\n    /// flags. Let's also throw in the final option style for good measure.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myapp\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"flag2\")\n    ///         .short(\"F\"))\n    ///     .arg(Arg::with_name(\"flag3\")\n    ///         .short(\"z\"))\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .short(\"o\")\n    ///         .takes_value(true))\n    ///     .get_matches_from(vec![\"myapp\", \"-fzF\", \"-oval\"]);\n    ///             // ARGV idices: ^0      ^1       ^2\n    ///             // clap idices:         ^1,2,3    ^5\n    ///             //\n    ///             // clap sees the above as 'myapp -f -z -F -o val'\n    ///             //                         ^0    ^1 ^2 ^3 ^4 ^5\n    /// assert_eq!(m.index_of(\"flag\"), Some(1));\n    /// assert_eq!(m.index_of(\"flag2\"), Some(3));\n    /// assert_eq!(m.index_of(\"flag3\"), Some(2));\n    /// assert_eq!(m.index_of(\"option\"), Some(5));\n    /// ```\n    ///\n    /// One final combination of flags/options to see how they combine:\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myapp\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"flag2\")\n    ///         .short(\"F\"))\n    ///     .arg(Arg::with_name(\"flag3\")\n    ///         .short(\"z\"))\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .short(\"o\")\n    ///         .takes_value(true)\n    ///         .multiple(true))\n    ///     .get_matches_from(vec![\"myapp\", \"-fzFoval\"]);\n    ///             // ARGV idices: ^0       ^1\n    ///             // clap idices:          ^1,2,3^5\n    ///             //\n    ///             // clap sees the above as 'myapp -f -z -F -o val'\n    ///             //                         ^0    ^1 ^2 ^3 ^4 ^5\n    /// assert_eq!(m.index_of(\"flag\"), Some(1));\n    /// assert_eq!(m.index_of(\"flag2\"), Some(3));\n    /// assert_eq!(m.index_of(\"flag3\"), Some(2));\n    /// assert_eq!(m.index_of(\"option\"), Some(5));\n    /// ```\n    ///\n    /// The last part to mention is when values are sent in multiple groups with a [delimiter].\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myapp\")\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .short(\"o\")\n    ///         .takes_value(true)\n    ///         .multiple(true))\n    ///     .get_matches_from(vec![\"myapp\", \"-o=val1,val2,val3\"]);\n    ///             // ARGV idices: ^0       ^1\n    ///             // clap idices:             ^2   ^3   ^4\n    ///             //\n    ///             // clap sees the above as 'myapp -o val1 val2 val3'\n    ///             //                         ^0    ^1 ^2   ^3   ^4\n    /// assert_eq!(m.index_of(\"option\"), Some(2));\n    /// ```\n    /// [`ArgMatches`]: ./struct.ArgMatches.html\n    /// [delimiter]: ./struct.Arg.html#method.value_delimiter\n    pub fn index_of<S: AsRef<str>>(&self, name: S) -> Option<usize> {\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            if let Some(i) = arg.indices.get(0) {\n                return Some(*i);\n            }\n        }\n        None\n    }\n\n    /// Gets all indices of the argument in respect to all other arguments. Indices are\n    /// similar to argv indices, but are not exactly 1:1.\n    ///\n    /// For flags (i.e. those arguments which don't have an associated value), indices refer\n    /// to occurrence of the switch, such as `-f`, or `--flag`. However, for options the indices\n    /// refer to the *values* `-o val` would therefore not represent two distinct indices, only the\n    /// index for `val` would be recorded. This is by design.\n    ///\n    /// *NOTE:* For more information about how clap indices compare to argv indices, see\n    /// [`ArgMatches::index_of`]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myapp\")\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .short(\"o\")\n    ///         .takes_value(true)\n    ///         .use_delimiter(true)\n    ///         .multiple(true))\n    ///     .get_matches_from(vec![\"myapp\", \"-o=val1,val2,val3\"]);\n    ///             // ARGV idices: ^0       ^1\n    ///             // clap idices:             ^2   ^3   ^4\n    ///             //\n    ///             // clap sees the above as 'myapp -o val1 val2 val3'\n    ///             //                         ^0    ^1 ^2   ^3   ^4\n    /// assert_eq!(m.indices_of(\"option\").unwrap().collect::<Vec<_>>(), &[2, 3, 4]);\n    /// ```\n    ///\n    /// Another quick example is when flags and options are used together\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myapp\")\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .short(\"o\")\n    ///         .takes_value(true)\n    ///         .multiple(true))\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\")\n    ///         .multiple(true))\n    ///     .get_matches_from(vec![\"myapp\", \"-o\", \"val1\", \"-f\", \"-o\", \"val2\", \"-f\"]);\n    ///             // ARGV idices: ^0       ^1    ^2      ^3    ^4    ^5      ^6\n    ///             // clap idices:                ^2      ^3          ^5      ^6\n    ///\n    /// assert_eq!(m.indices_of(\"option\").unwrap().collect::<Vec<_>>(), &[2, 5]);\n    /// assert_eq!(m.indices_of(\"flag\").unwrap().collect::<Vec<_>>(), &[3, 6]);\n    /// ```\n    ///\n    /// One final example, which is an odd case; if we *don't* use  value delimiter as we did with\n    /// the first example above instead of `val1`, `val2` and `val3` all being distinc values, they\n    /// would all be a single value of `val1,val2,val3`, in which case case they'd only receive a\n    /// single index.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg};\n    /// let m = App::new(\"myapp\")\n    ///     .arg(Arg::with_name(\"option\")\n    ///         .short(\"o\")\n    ///         .takes_value(true)\n    ///         .multiple(true))\n    ///     .get_matches_from(vec![\"myapp\", \"-o=val1,val2,val3\"]);\n    ///             // ARGV idices: ^0       ^1\n    ///             // clap idices:             ^2\n    ///             //\n    ///             // clap sees the above as 'myapp -o \"val1,val2,val3\"'\n    ///             //                         ^0    ^1  ^2\n    /// assert_eq!(m.indices_of(\"option\").unwrap().collect::<Vec<_>>(), &[2]);\n    /// ```\n    /// [`ArgMatches`]: ./struct.ArgMatches.html\n    /// [`ArgMatches::index_of`]: ./struct.ArgMatches.html#method.index_of\n    /// [delimiter]: ./struct.Arg.html#method.value_delimiter\n    pub fn indices_of<S: AsRef<str>>(&'a self, name: S) -> Option<Indices<'a>> {\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            fn to_usize(i: &usize) -> usize {\n                *i\n            }\n            let to_usize: fn(&usize) -> usize = to_usize; // coerce to fn pointer\n            return Some(Indices {\n                iter: arg.indices.iter().map(to_usize),\n            });\n        }\n        None\n    }\n\n    /// Because [`Subcommand`]s are essentially \"sub-[`App`]s\" they have their own [`ArgMatches`]\n    /// as well. This method returns the [`ArgMatches`] for a particular subcommand or `None` if\n    /// the subcommand wasn't present at runtime.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, SubCommand};\n    /// let app_m = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .short(\"d\"))\n    ///     .subcommand(SubCommand::with_name(\"test\")\n    ///         .arg(Arg::with_name(\"opt\")\n    ///             .long(\"option\")\n    ///             .takes_value(true)))\n    ///     .get_matches_from(vec![\n    ///         \"myprog\", \"-d\", \"test\", \"--option\", \"val\"\n    ///     ]);\n    ///\n    /// // Both parent commands, and child subcommands can have arguments present at the same times\n    /// assert!(app_m.is_present(\"debug\"));\n    ///\n    /// // Get the subcommand's ArgMatches instance\n    /// if let Some(sub_m) = app_m.subcommand_matches(\"test\") {\n    ///     // Use the struct like normal\n    ///     assert_eq!(sub_m.value_of(\"opt\"), Some(\"val\"));\n    /// }\n    /// ```\n    /// [`Subcommand`]: ./struct.SubCommand.html\n    /// [`App`]: ./struct.App.html\n    /// [`ArgMatches`]: ./struct.ArgMatches.html\n    pub fn subcommand_matches<S: AsRef<str>>(&self, name: S) -> Option<&ArgMatches<'a>> {\n        if let Some(ref s) = self.subcommand {\n            if s.name == name.as_ref() {\n                return Some(&s.matches);\n            }\n        }\n        None\n    }\n\n    /// Because [`Subcommand`]s are essentially \"sub-[`App`]s\" they have their own [`ArgMatches`]\n    /// as well.But simply getting the sub-[`ArgMatches`] doesn't help much if we don't also know\n    /// which subcommand was actually used. This method returns the name of the subcommand that was\n    /// used at runtime, or `None` if one wasn't.\n    ///\n    /// *NOTE*: Subcommands form a hierarchy, where multiple subcommands can be used at runtime,\n    /// but only a single subcommand from any group of sibling commands may used at once.\n    ///\n    /// An ASCII art depiction may help explain this better...Using a fictional version of `git` as\n    /// the demo subject. Imagine the following are all subcommands of `git` (note, the author is\n    /// aware these aren't actually all subcommands in the real `git` interface, but it makes\n    /// explanation easier)\n    ///\n    /// ```notrust\n    ///              Top Level App (git)                         TOP\n    ///                              |\n    ///       -----------------------------------------\n    ///      /             |                \\          \\\n    ///   clone          push              add       commit      LEVEL 1\n    ///     |           /    \\            /    \\       |\n    ///    url      origin   remote    ref    name   message     LEVEL 2\n    ///             /                  /\\\n    ///          path            remote  local                   LEVEL 3\n    /// ```\n    ///\n    /// Given the above fictional subcommand hierarchy, valid runtime uses would be (not an all\n    /// inclusive list, and not including argument options per command for brevity and clarity):\n    ///\n    /// ```sh\n    /// $ git clone url\n    /// $ git push origin path\n    /// $ git add ref local\n    /// $ git commit message\n    /// ```\n    ///\n    /// Notice only one command per \"level\" may be used. You could not, for example, do `$ git\n    /// clone url push origin path`\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand};\n    ///  let app_m = App::new(\"git\")\n    ///      .subcommand(SubCommand::with_name(\"clone\"))\n    ///      .subcommand(SubCommand::with_name(\"push\"))\n    ///      .subcommand(SubCommand::with_name(\"commit\"))\n    ///      .get_matches();\n    ///\n    /// match app_m.subcommand_name() {\n    ///     Some(\"clone\")  => {}, // clone was used\n    ///     Some(\"push\")   => {}, // push was used\n    ///     Some(\"commit\") => {}, // commit was used\n    ///     _              => {}, // Either no subcommand or one not tested for...\n    /// }\n    /// ```\n    /// [`Subcommand`]: ./struct.SubCommand.html\n    /// [`App`]: ./struct.App.html\n    /// [`ArgMatches`]: ./struct.ArgMatches.html\n    pub fn subcommand_name(&self) -> Option<&str> {\n        self.subcommand.as_ref().map(|sc| &sc.name[..])\n    }\n\n    /// This brings together [`ArgMatches::subcommand_matches`] and [`ArgMatches::subcommand_name`]\n    /// by returning a tuple with both pieces of information.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand};\n    ///  let app_m = App::new(\"git\")\n    ///      .subcommand(SubCommand::with_name(\"clone\"))\n    ///      .subcommand(SubCommand::with_name(\"push\"))\n    ///      .subcommand(SubCommand::with_name(\"commit\"))\n    ///      .get_matches();\n    ///\n    /// match app_m.subcommand() {\n    ///     (\"clone\",  Some(sub_m)) => {}, // clone was used\n    ///     (\"push\",   Some(sub_m)) => {}, // push was used\n    ///     (\"commit\", Some(sub_m)) => {}, // commit was used\n    ///     _                       => {}, // Either no subcommand or one not tested for...\n    /// }\n    /// ```\n    ///\n    /// Another useful scenario is when you want to support third party, or external, subcommands.\n    /// In these cases you can't know the subcommand name ahead of time, so use a variable instead\n    /// with pattern matching!\n    ///\n    /// ```rust\n    /// # use clap::{App, AppSettings};\n    /// // Assume there is an external subcommand named \"subcmd\"\n    /// let app_m = App::new(\"myprog\")\n    ///     .setting(AppSettings::AllowExternalSubcommands)\n    ///     .get_matches_from(vec![\n    ///         \"myprog\", \"subcmd\", \"--option\", \"value\", \"-fff\", \"--flag\"\n    ///     ]);\n    ///\n    /// // All trailing arguments will be stored under the subcommand's sub-matches using an empty\n    /// // string argument name\n    /// match app_m.subcommand() {\n    ///     (external, Some(sub_m)) => {\n    ///          let ext_args: Vec<&str> = sub_m.values_of(\"\").unwrap().collect();\n    ///          assert_eq!(external, \"subcmd\");\n    ///          assert_eq!(ext_args, [\"--option\", \"value\", \"-fff\", \"--flag\"]);\n    ///     },\n    ///     _ => {},\n    /// }\n    /// ```\n    /// [`ArgMatches::subcommand_matches`]: ./struct.ArgMatches.html#method.subcommand_matches\n    /// [`ArgMatches::subcommand_name`]: ./struct.ArgMatches.html#method.subcommand_name\n    pub fn subcommand(&self) -> (&str, Option<&ArgMatches<'a>>) {\n        self.subcommand\n            .as_ref()\n            .map_or((\"\", None), |sc| (&sc.name[..], Some(&sc.matches)))\n    }\n\n    /// Returns a string slice of the usage statement for the [`App`] or [`SubCommand`]\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand};\n    /// let app_m = App::new(\"myprog\")\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .get_matches();\n    ///\n    /// println!(\"{}\", app_m.usage());\n    /// ```\n    /// [`Subcommand`]: ./struct.SubCommand.html\n    /// [`App`]: ./struct.App.html\n    pub fn usage(&self) -> &str {\n        self.usage.as_ref().map_or(\"\", |u| &u[..])\n    }\n}","impl<'a> Default for ArgMatches<'a> {\n    fn default() -> Self {\n        ArgMatches {\n            args: HashMap::new(),\n            subcommand: None,\n            usage: None,\n        }\n    }\n}"],"args::arg_matches::Indices":["Clone","Debug","impl<'a> Default for Indices<'a> {\n    fn default() -> Self {\n        static EMPTY: [usize; 0] = [];\n        // This is never called because the iterator is empty:\n        fn to_usize(_: &usize) -> usize {\n            unreachable!()\n        };\n        Indices {\n            iter: EMPTY[..].iter().map(to_usize),\n        }\n    }\n}","impl<'a> DoubleEndedIterator for Indices<'a> {\n    fn next_back(&mut self) -> Option<usize> {\n        self.iter.next_back()\n    }\n}","impl<'a> ExactSizeIterator for Indices<'a> {}","impl<'a> Iterator for Indices<'a> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}"],"args::arg_matches::OsValues":["Clone","Debug","impl<'a> Default for OsValues<'a> {\n    fn default() -> Self {\n        static EMPTY: [OsString; 0] = [];\n        // This is never called because the iterator is empty:\n        fn to_str_slice(_: &OsString) -> &OsStr {\n            unreachable!()\n        };\n        OsValues {\n            iter: EMPTY[..].iter().map(to_str_slice),\n        }\n    }\n}","impl<'a> DoubleEndedIterator for OsValues<'a> {\n    fn next_back(&mut self) -> Option<&'a OsStr> {\n        self.iter.next_back()\n    }\n}","impl<'a> ExactSizeIterator for OsValues<'a> {}","impl<'a> Iterator for OsValues<'a> {\n    type Item = &'a OsStr;\n\n    fn next(&mut self) -> Option<&'a OsStr> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}"],"args::arg_matches::Values":["Clone","Debug","impl<'a> Default for Values<'a> {\n    fn default() -> Self {\n        static EMPTY: [OsString; 0] = [];\n        // This is never called because the iterator is empty:\n        fn to_str_slice(_: &OsString) -> &str {\n            unreachable!()\n        };\n        Values {\n            iter: EMPTY[..].iter().map(to_str_slice),\n        }\n    }\n}","impl<'a> DoubleEndedIterator for Values<'a> {\n    fn next_back(&mut self) -> Option<&'a str> {\n        self.iter.next_back()\n    }\n}","impl<'a> ExactSizeIterator for Values<'a> {}","impl<'a> Iterator for Values<'a> {\n    type Item = &'a str;\n\n    fn next(&mut self) -> Option<&'a str> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}"],"args::group::ArgGroup":["Default","impl<'a, 'z> From<&'z ArgGroup<'a>> for ArgGroup<'a> {\n    fn from(g: &'z ArgGroup<'a>) -> Self {\n        ArgGroup {\n            name: g.name,\n            required: g.required,\n            args: g.args.clone(),\n            requires: g.requires.clone(),\n            conflicts: g.conflicts.clone(),\n            multiple: g.multiple,\n        }\n    }\n}","impl<'a> ArgGroup<'a> {\n    /// Creates a new instance of `ArgGroup` using a unique string name. The name will be used to\n    /// get values from the group or refer to the group inside of conflict and requirement rules.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, ArgGroup};\n    /// ArgGroup::with_name(\"config\")\n    /// # ;\n    /// ```\n    pub fn with_name(n: &'a str) -> Self {\n        ArgGroup {\n            name: n,\n            required: false,\n            args: vec![],\n            requires: None,\n            conflicts: None,\n            multiple: false,\n        }\n    }\n\n    /// Creates a new instance of `ArgGroup` from a .yml (YAML) file.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// # #[macro_use]\n    /// # extern crate clap;\n    /// # use clap::ArgGroup;\n    /// # fn main() {\n    /// let yml = load_yaml!(\"group.yml\");\n    /// let ag = ArgGroup::from_yaml(yml);\n    /// # }\n    /// ```\n    #[cfg(feature = \"yaml\")]\n    pub fn from_yaml(y: &'a Yaml) -> ArgGroup<'a> {\n        ArgGroup::from(y.as_hash().unwrap())\n    }\n\n    /// Adds an [argument] to this group by name\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ArgGroup};\n    /// let m = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"color\")\n    ///         .short(\"c\"))\n    ///     .group(ArgGroup::with_name(\"req_flags\")\n    ///         .arg(\"flag\")\n    ///         .arg(\"color\"))\n    ///     .get_matches_from(vec![\"myprog\", \"-f\"]);\n    /// // maybe we don't know which of the two flags was used...\n    /// assert!(m.is_present(\"req_flags\"));\n    /// // but we can also check individually if needed\n    /// assert!(m.is_present(\"flag\"));\n    /// ```\n    /// [argument]: ./struct.Arg.html\n    #[cfg_attr(feature = \"lints\", allow(should_assert_eq))]\n    pub fn arg(mut self, n: &'a str) -> Self {\n        assert!(\n            self.name != n,\n            \"ArgGroup '{}' can not have same name as arg inside it\",\n            &*self.name\n        );\n        self.args.push(n);\n        self\n    }\n\n    /// Adds multiple [arguments] to this group by name\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ArgGroup};\n    /// let m = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"color\")\n    ///         .short(\"c\"))\n    ///     .group(ArgGroup::with_name(\"req_flags\")\n    ///         .args(&[\"flag\", \"color\"]))\n    ///     .get_matches_from(vec![\"myprog\", \"-f\"]);\n    /// // maybe we don't know which of the two flags was used...\n    /// assert!(m.is_present(\"req_flags\"));\n    /// // but we can also check individually if needed\n    /// assert!(m.is_present(\"flag\"));\n    /// ```\n    /// [arguments]: ./struct.Arg.html\n    pub fn args(mut self, ns: &[&'a str]) -> Self {\n        for n in ns {\n            self = self.arg(n);\n        }\n        self\n    }\n\n    /// Allows more than one of the ['Arg']s in this group to be used. (Default: `false`)\n    ///\n    /// # Examples\n    ///\n    /// Notice in this example we use *both* the `-f` and `-c` flags which are both part of the\n    /// group\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ArgGroup};\n    /// let m = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"color\")\n    ///         .short(\"c\"))\n    ///     .group(ArgGroup::with_name(\"req_flags\")\n    ///         .args(&[\"flag\", \"color\"])\n    ///         .multiple(true))\n    ///     .get_matches_from(vec![\"myprog\", \"-f\", \"-c\"]);\n    /// // maybe we don't know which of the two flags was used...\n    /// assert!(m.is_present(\"req_flags\"));\n    /// ```\n    /// In this next example, we show the default behavior (i.e. `multiple(false)) which will throw\n    /// an error if more than one of the args in the group was used.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ArgGroup, ErrorKind};\n    /// let result = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"color\")\n    ///         .short(\"c\"))\n    ///     .group(ArgGroup::with_name(\"req_flags\")\n    ///         .args(&[\"flag\", \"color\"]))\n    ///     .get_matches_from_safe(vec![\"myprog\", \"-f\", \"-c\"]);\n    /// // Because we used both args in the group it's an error\n    /// assert!(result.is_err());\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind, ErrorKind::ArgumentConflict);\n    /// ```\n    /// ['Arg']: ./struct.Arg.html\n    pub fn multiple(mut self, m: bool) -> Self {\n        self.multiple = m;\n        self\n    }\n\n    /// Sets the group as required or not. A required group will be displayed in the usage string\n    /// of the application in the format `<arg|arg2|arg3>`. A required `ArgGroup` simply states\n    /// that one argument from this group *must* be present at runtime (unless\n    /// conflicting with another argument).\n    ///\n    /// **NOTE:** This setting only applies to the current [`App`] / [`SubCommand`], and not\n    /// globally.\n    ///\n    /// **NOTE:** By default, [`ArgGroup::multiple`] is set to `false` which when combined with\n    /// `ArgGroup::required(true)` states, \"One and *only one* arg must be used from this group.\n    /// Use of more than one arg is an error.\" Vice setting `ArgGroup::multiple(true)` which\n    /// states, '*At least* one arg from this group must be used. Using multiple is OK.\"\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ArgGroup, ErrorKind};\n    /// let result = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"color\")\n    ///         .short(\"c\"))\n    ///     .group(ArgGroup::with_name(\"req_flags\")\n    ///         .args(&[\"flag\", \"color\"])\n    ///         .required(true))\n    ///     .get_matches_from_safe(vec![\"myprog\"]);\n    /// // Because we didn't use any of the args in the group, it's an error\n    /// assert!(result.is_err());\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [`App`]: ./struct.App.html\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`ArgGroup::multiple`]: ./struct.ArgGroup.html#method.multiple\n    pub fn required(mut self, r: bool) -> Self {\n        self.required = r;\n        self\n    }\n\n    /// Sets the requirement rules of this group. This is not to be confused with a\n    /// [required group]. Requirement rules function just like [argument requirement rules], you\n    /// can name other arguments or groups that must be present when any one of the arguments from\n    /// this group is used.\n    ///\n    /// **NOTE:** The name provided may be an argument, or group name\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ArgGroup, ErrorKind};\n    /// let result = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"color\")\n    ///         .short(\"c\"))\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .short(\"d\"))\n    ///     .group(ArgGroup::with_name(\"req_flags\")\n    ///         .args(&[\"flag\", \"color\"])\n    ///         .requires(\"debug\"))\n    ///     .get_matches_from_safe(vec![\"myprog\", \"-c\"]);\n    /// // because we used an arg from the group, and the group requires \"-d\" to be used, it's an\n    /// // error\n    /// assert!(result.is_err());\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [required group]: ./struct.ArgGroup.html#method.required\n    /// [argument requirement rules]: ./struct.Arg.html#method.requires\n    pub fn requires(mut self, n: &'a str) -> Self {\n        if let Some(ref mut reqs) = self.requires {\n            reqs.push(n);\n        } else {\n            self.requires = Some(vec![n]);\n        }\n        self\n    }\n\n    /// Sets the requirement rules of this group. This is not to be confused with a\n    /// [required group]. Requirement rules function just like [argument requirement rules], you\n    /// can name other arguments or groups that must be present when one of the arguments from this\n    /// group is used.\n    ///\n    /// **NOTE:** The names provided may be an argument, or group name\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ArgGroup, ErrorKind};\n    /// let result = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"color\")\n    ///         .short(\"c\"))\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .short(\"d\"))\n    ///     .arg(Arg::with_name(\"verb\")\n    ///         .short(\"v\"))\n    ///     .group(ArgGroup::with_name(\"req_flags\")\n    ///         .args(&[\"flag\", \"color\"])\n    ///         .requires_all(&[\"debug\", \"verb\"]))\n    ///     .get_matches_from_safe(vec![\"myprog\", \"-c\", \"-d\"]);\n    /// // because we used an arg from the group, and the group requires \"-d\" and \"-v\" to be used,\n    /// // yet we only used \"-d\" it's an error\n    /// assert!(result.is_err());\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    /// [required group]: ./struct.ArgGroup.html#method.required\n    /// [argument requirement rules]: ./struct.Arg.html#method.requires_all\n    pub fn requires_all(mut self, ns: &[&'a str]) -> Self {\n        for n in ns {\n            self = self.requires(n);\n        }\n        self\n    }\n\n    /// Sets the exclusion rules of this group. Exclusion (aka conflict) rules function just like\n    /// [argument exclusion rules], you can name other arguments or groups that must *not* be\n    /// present when one of the arguments from this group are used.\n    ///\n    /// **NOTE:** The name provided may be an argument, or group name\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ArgGroup, ErrorKind};\n    /// let result = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"color\")\n    ///         .short(\"c\"))\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .short(\"d\"))\n    ///     .group(ArgGroup::with_name(\"req_flags\")\n    ///         .args(&[\"flag\", \"color\"])\n    ///         .conflicts_with(\"debug\"))\n    ///     .get_matches_from_safe(vec![\"myprog\", \"-c\", \"-d\"]);\n    /// // because we used an arg from the group, and the group conflicts with \"-d\", it's an error\n    /// assert!(result.is_err());\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind, ErrorKind::ArgumentConflict);\n    /// ```\n    /// [argument exclusion rules]: ./struct.Arg.html#method.conflicts_with\n    pub fn conflicts_with(mut self, n: &'a str) -> Self {\n        if let Some(ref mut confs) = self.conflicts {\n            confs.push(n);\n        } else {\n            self.conflicts = Some(vec![n]);\n        }\n        self\n    }\n\n    /// Sets the exclusion rules of this group. Exclusion rules function just like\n    /// [argument exclusion rules], you can name other arguments or groups that must *not* be\n    /// present when one of the arguments from this group are used.\n    ///\n    /// **NOTE:** The names provided may be an argument, or group name\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ArgGroup, ErrorKind};\n    /// let result = App::new(\"myprog\")\n    ///     .arg(Arg::with_name(\"flag\")\n    ///         .short(\"f\"))\n    ///     .arg(Arg::with_name(\"color\")\n    ///         .short(\"c\"))\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .short(\"d\"))\n    ///     .arg(Arg::with_name(\"verb\")\n    ///         .short(\"v\"))\n    ///     .group(ArgGroup::with_name(\"req_flags\")\n    ///         .args(&[\"flag\", \"color\"])\n    ///         .conflicts_with_all(&[\"debug\", \"verb\"]))\n    ///     .get_matches_from_safe(vec![\"myprog\", \"-c\", \"-v\"]);\n    /// // because we used an arg from the group, and the group conflicts with either \"-v\" or \"-d\"\n    /// // it's an error\n    /// assert!(result.is_err());\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind, ErrorKind::ArgumentConflict);\n    /// ```\n    /// [argument exclusion rules]: ./struct.Arg.html#method.conflicts_with_all\n    pub fn conflicts_with_all(mut self, ns: &[&'a str]) -> Self {\n        for n in ns {\n            self = self.conflicts_with(n);\n        }\n        self\n    }\n}","impl<'a> Clone for ArgGroup<'a> {\n    fn clone(&self) -> Self {\n        ArgGroup {\n            name: self.name,\n            required: self.required,\n            args: self.args.clone(),\n            requires: self.requires.clone(),\n            conflicts: self.conflicts.clone(),\n            multiple: self.multiple,\n        }\n    }\n}","impl<'a> Debug for ArgGroup<'a> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        write!(\n            f,\n            \"{{\\n\\\n             \\tname: {:?},\\n\\\n             \\targs: {:?},\\n\\\n             \\trequired: {:?},\\n\\\n             \\trequires: {:?},\\n\\\n             \\tconflicts: {:?},\\n\\\n             }}\",\n            self.name, self.args, self.required, self.requires, self.conflicts\n        )\n    }\n}"],"args::matched_arg::MatchedArg":["Clone","Debug","impl Default for MatchedArg {\n    fn default() -> Self {\n        MatchedArg {\n            occurs: 1,\n            indices: Vec::new(),\n            vals: Vec::new(),\n        }\n    }\n}","impl MatchedArg {\n    pub fn new() -> Self {\n        MatchedArg::default()\n    }\n}"],"args::settings::ArgFlags":["Clone","Copy","Debug","impl ArgFlags {\n    pub fn new() -> Self {\n        ArgFlags::default()\n    }\n\n    impl_settings! {ArgSettings,\n        Required => Flags::REQUIRED,\n        Multiple => Flags::MULTIPLE,\n        EmptyValues => Flags::EMPTY_VALS,\n        Global => Flags::GLOBAL,\n        Hidden => Flags::HIDDEN,\n        TakesValue => Flags::TAKES_VAL,\n        UseValueDelimiter => Flags::USE_DELIM,\n        NextLineHelp => Flags::NEXT_LINE_HELP,\n        RequiredUnlessAll => Flags::R_UNLESS_ALL,\n        RequireDelimiter => Flags::REQ_DELIM,\n        ValueDelimiterNotSet => Flags::DELIM_NOT_SET,\n        HidePossibleValues => Flags::HIDE_POS_VALS,\n        AllowLeadingHyphen => Flags::ALLOW_TAC_VALS,\n        RequireEquals => Flags::REQUIRE_EQUALS,\n        Last => Flags::LAST,\n        CaseInsensitive => Flags::CASE_INSENSITIVE,\n        HideEnvValues => Flags::HIDE_ENV_VALS,\n        HideDefaultValue => Flags::HIDE_DEFAULT_VAL,\n        HiddenShortHelp => Flags::HIDDEN_SHORT_H,\n        HiddenLongHelp => Flags::HIDDEN_LONG_H\n    }\n}","impl Default for ArgFlags {\n    fn default() -> Self {\n        ArgFlags(Flags::EMPTY_VALS | Flags::DELIM_NOT_SET)\n    }\n}"],"args::settings::ArgSettings":["Clone","Copy","Debug","PartialEq","impl FromStr for ArgSettings {\n    type Err = String;\n    fn from_str(s: &str) -> Result<Self, <Self as FromStr>::Err> {\n        match &*s.to_ascii_lowercase() {\n            \"required\" => Ok(ArgSettings::Required),\n            \"multiple\" => Ok(ArgSettings::Multiple),\n            \"global\" => Ok(ArgSettings::Global),\n            \"emptyvalues\" => Ok(ArgSettings::EmptyValues),\n            \"hidden\" => Ok(ArgSettings::Hidden),\n            \"takesvalue\" => Ok(ArgSettings::TakesValue),\n            \"usevaluedelimiter\" => Ok(ArgSettings::UseValueDelimiter),\n            \"nextlinehelp\" => Ok(ArgSettings::NextLineHelp),\n            \"requiredunlessall\" => Ok(ArgSettings::RequiredUnlessAll),\n            \"requiredelimiter\" => Ok(ArgSettings::RequireDelimiter),\n            \"valuedelimiternotset\" => Ok(ArgSettings::ValueDelimiterNotSet),\n            \"hidepossiblevalues\" => Ok(ArgSettings::HidePossibleValues),\n            \"allowleadinghyphen\" => Ok(ArgSettings::AllowLeadingHyphen),\n            \"requireequals\" => Ok(ArgSettings::RequireEquals),\n            \"last\" => Ok(ArgSettings::Last),\n            \"hidedefaultvalue\" => Ok(ArgSettings::HideDefaultValue),\n            \"caseinsensitive\" => Ok(ArgSettings::CaseInsensitive),\n            \"hideenvvalues\" => Ok(ArgSettings::HideEnvValues),\n            \"hiddenshorthelp\" => Ok(ArgSettings::HiddenShortHelp),\n            \"hiddenlonghelp\" => Ok(ArgSettings::HiddenLongHelp),\n            _ => Err(\"unknown ArgSetting, cannot convert from str\".to_owned()),\n        }\n    }\n}"],"args::settings::Flags":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }","impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::Debug for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                // This convoluted approach is to handle #[cfg]-based flag\n                // omission correctly. For example it needs to support:\n                //\n                //    #[cfg(unix)] const A: Flag = /* ... */;\n                //    #[cfg(windows)] const B: Flag = /* ... */;\n\n                // Unconditionally define a check for every flag, even disabled\n                // ones.\n                #[allow(non_snake_case)]\n                trait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }\n\n                // Conditionally override the check for just those flags that\n                // are not #[cfg]ed away.\n                #[allow(non_snake_case)]\n                impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }","impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }","impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }","impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }","impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }","impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }","impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }","impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }","impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }","impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }","impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }","impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }","impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }","impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }","impl __BitFlags for $BitFlags {\n            $(\n                __impl_bitflags! {\n                    #[allow(deprecated)]\n                    $(? #[$attr $($args)*])*\n                    const $Flag: $T = Self::$Flag.bits;\n                }\n            )+\n        }"],"args::subcommand::SubCommand":["Clone","Debug","impl<'a> SubCommand<'a> {\n    /// Creates a new instance of a subcommand requiring a name. The name will be displayed\n    /// to the user when they print version or help and usage information.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, SubCommand};\n    /// App::new(\"myprog\")\n    ///     .subcommand(\n    ///         SubCommand::with_name(\"config\"))\n    /// # ;\n    /// ```\n    pub fn with_name<'b>(name: &str) -> App<'a, 'b> {\n        App::new(name)\n    }\n\n    /// Creates a new instance of a subcommand from a YAML (.yml) document\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// # #[macro_use]\n    /// # extern crate clap;\n    /// # use clap::Subcommand;\n    /// # fn main() {\n    /// let sc_yaml = load_yaml!(\"test_subcommand.yml\");\n    /// let sc = SubCommand::from_yaml(sc_yaml);\n    /// # }\n    /// ```\n    #[cfg(feature = \"yaml\")]\n    pub fn from_yaml(yaml: &Yaml) -> App {\n        App::from_yaml(yaml)\n    }\n}"],"completions::ComplGen":["impl<'a, 'b> ComplGen<'a, 'b> {\n    pub fn new(p: &'b Parser<'a, 'b>) -> Self {\n        ComplGen { p: p }\n    }\n\n    pub fn generate<W: Write>(&self, for_shell: Shell, buf: &mut W) {\n        match for_shell {\n            Shell::Bash => BashGen::new(self.p).generate_to(buf),\n            Shell::Fish => FishGen::new(self.p).generate_to(buf),\n            Shell::Zsh => ZshGen::new(self.p).generate_to(buf),\n            Shell::PowerShell => PowerShellGen::new(self.p).generate_to(buf),\n            Shell::Elvish => ElvishGen::new(self.p).generate_to(buf),\n        }\n    }\n}"],"completions::bash::BashGen":["impl<'a, 'b> BashGen<'a, 'b> {\n    pub fn new(p: &'b Parser<'a, 'b>) -> Self {\n        BashGen { p: p }\n    }\n\n    pub fn generate_to<W: Write>(&self, buf: &mut W) {\n        w!(\n            buf,\n            format!(\n                r#\"_{name}() {{\n    local i cur prev opts cmds\n    COMPREPLY=()\n    cur=\"${{COMP_WORDS[COMP_CWORD]}}\"\n    prev=\"${{COMP_WORDS[COMP_CWORD-1]}}\"\n    cmd=\"\"\n    opts=\"\"\n\n    for i in ${{COMP_WORDS[@]}}\n    do\n        case \"${{i}}\" in\n            {name})\n                cmd=\"{name}\"\n                ;;\n            {subcmds}\n            *)\n                ;;\n        esac\n    done\n\n    case \"${{cmd}}\" in\n        {name})\n            opts=\"{name_opts}\"\n            if [[ ${{cur}} == -* || ${{COMP_CWORD}} -eq 1 ]] ; then\n                COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )\n                return 0\n            fi\n            case \"${{prev}}\" in\n                {name_opts_details}\n                *)\n                    COMPREPLY=()\n                    ;;\n            esac\n            COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )\n            return 0\n            ;;\n        {subcmd_details}\n    esac\n}}\n\ncomplete -F _{name} -o bashdefault -o default {name}\n\"#,\n                name = self.p.meta.bin_name.as_ref().unwrap(),\n                name_opts = self.all_options_for_path(self.p.meta.bin_name.as_ref().unwrap()),\n                name_opts_details =\n                    self.option_details_for_path(self.p.meta.bin_name.as_ref().unwrap()),\n                subcmds = self.all_subcommands(),\n                subcmd_details = self.subcommand_details()\n            )\n            .as_bytes()\n        );\n    }\n\n    fn all_subcommands(&self) -> String {\n        debugln!(\"BashGen::all_subcommands;\");\n        let mut subcmds = String::new();\n        let scs = completions::all_subcommand_names(self.p);\n\n        for sc in &scs {\n            subcmds = format!(\n                r#\"{}\n            {name})\n                cmd+=\"__{fn_name}\"\n                ;;\"#,\n                subcmds,\n                name = sc,\n                fn_name = sc.replace(\"-\", \"__\")\n            );\n        }\n\n        subcmds\n    }\n\n    fn subcommand_details(&self) -> String {\n        debugln!(\"BashGen::subcommand_details;\");\n        let mut subcmd_dets = String::new();\n        let mut scs = completions::get_all_subcommand_paths(self.p, true);\n        scs.sort();\n        scs.dedup();\n\n        for sc in &scs {\n            subcmd_dets = format!(\n                r#\"{}\n        {subcmd})\n            opts=\"{sc_opts}\"\n            if [[ ${{cur}} == -* || ${{COMP_CWORD}} -eq {level} ]] ; then\n                COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )\n                return 0\n            fi\n            case \"${{prev}}\" in\n                {opts_details}\n                *)\n                    COMPREPLY=()\n                    ;;\n            esac\n            COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )\n            return 0\n            ;;\"#,\n                subcmd_dets,\n                subcmd = sc.replace(\"-\", \"__\"),\n                sc_opts = self.all_options_for_path(&*sc),\n                level = sc.split(\"__\").map(|_| 1).fold(0, |acc, n| acc + n),\n                opts_details = self.option_details_for_path(&*sc)\n            );\n        }\n\n        subcmd_dets\n    }\n\n    fn option_details_for_path(&self, path: &str) -> String {\n        debugln!(\"BashGen::option_details_for_path: path={}\", path);\n        let mut p = self.p;\n        for sc in path.split(\"__\").skip(1) {\n            debugln!(\"BashGen::option_details_for_path:iter: sc={}\", sc);\n            p = &find_subcmd!(p, sc).unwrap().p;\n        }\n        let mut opts = String::new();\n        for o in p.opts() {\n            if let Some(l) = o.s.long {\n                opts = format!(\n                    \"{}\n                --{})\n                    COMPREPLY=({})\n                    return 0\n                    ;;\",\n                    opts,\n                    l,\n                    self.vals_for(o)\n                );\n            }\n            if let Some(s) = o.s.short {\n                opts = format!(\n                    \"{}\n                    -{})\n                    COMPREPLY=({})\n                    return 0\n                    ;;\",\n                    opts,\n                    s,\n                    self.vals_for(o)\n                );\n            }\n        }\n        opts\n    }\n\n    fn vals_for(&self, o: &OptBuilder) -> String {\n        debugln!(\"BashGen::vals_for: o={}\", o.b.name);\n        use args::AnyArg;\n        if let Some(vals) = o.possible_vals() {\n            format!(r#\"$(compgen -W \"{}\" -- \"${{cur}}\")\"#, vals.join(\" \"))\n        } else {\n            String::from(r#\"$(compgen -f \"${cur}\")\"#)\n        }\n    }\n\n    fn all_options_for_path(&self, path: &str) -> String {\n        debugln!(\"BashGen::all_options_for_path: path={}\", path);\n        let mut p = self.p;\n        for sc in path.split(\"__\").skip(1) {\n            debugln!(\"BashGen::all_options_for_path:iter: sc={}\", sc);\n            p = &find_subcmd!(p, sc).unwrap().p;\n        }\n        let mut opts = shorts!(p).fold(String::new(), |acc, s| format!(\"{} -{}\", acc, s));\n        opts = format!(\n            \"{} {}\",\n            opts,\n            longs!(p).fold(String::new(), |acc, l| format!(\"{} --{}\", acc, l))\n        );\n        opts = format!(\n            \"{} {}\",\n            opts,\n            p.positionals\n                .values()\n                .fold(String::new(), |acc, p| format!(\"{} {}\", acc, p))\n        );\n        opts = format!(\n            \"{} {}\",\n            opts,\n            p.subcommands\n                .iter()\n                .fold(String::new(), |acc, s| format!(\"{} {}\", acc, s.p.meta.name))\n        );\n        for sc in &p.subcommands {\n            if let Some(ref aliases) = sc.p.meta.aliases {\n                opts = format!(\n                    \"{} {}\",\n                    opts,\n                    aliases\n                        .iter()\n                        .map(|&(n, _)| n)\n                        .fold(String::new(), |acc, a| format!(\"{} {}\", acc, a))\n                );\n            }\n        }\n        opts\n    }\n}"],"completions::elvish::ElvishGen":["impl<'a, 'b> ElvishGen<'a, 'b> {\n    pub fn new(p: &'b Parser<'a, 'b>) -> Self {\n        ElvishGen { p: p }\n    }\n\n    pub fn generate_to<W: Write>(&self, buf: &mut W) {\n        let bin_name = self.p.meta.bin_name.as_ref().unwrap();\n\n        let mut names = vec![];\n        let subcommands_cases = generate_inner(self.p, \"\", &mut names);\n\n        let result = format!(\n            r#\"\nedit:completion:arg-completer[{bin_name}] = [@words]{{\n    fn spaces [n]{{\n        repeat $n ' ' | joins ''\n    }}\n    fn cand [text desc]{{\n        edit:complex-candidate $text &display-suffix=' '(spaces (- 14 (wcswidth $text)))$desc\n    }}\n    command = '{bin_name}'\n    for word $words[1:-1] {{\n        if (has-prefix $word '-') {{\n            break\n        }}\n        command = $command';'$word\n    }}\n    completions = [{subcommands_cases}\n    ]\n    $completions[$command]\n}}\n\"#,\n            bin_name = bin_name,\n            subcommands_cases = subcommands_cases\n        );\n\n        w!(buf, result.as_bytes());\n    }\n}"],"completions::fish::FishGen":["impl<'a, 'b> FishGen<'a, 'b> {\n    pub fn new(p: &'b Parser<'a, 'b>) -> Self {\n        FishGen { p: p }\n    }\n\n    pub fn generate_to<W: Write>(&self, buf: &mut W) {\n        let command = self.p.meta.bin_name.as_ref().unwrap();\n        let mut buffer = String::new();\n        gen_fish_inner(command, self, command, &mut buffer);\n        w!(buf, buffer.as_bytes());\n    }\n}"],"completions::powershell::PowerShellGen":["impl<'a, 'b> PowerShellGen<'a, 'b> {\n    pub fn new(p: &'b Parser<'a, 'b>) -> Self {\n        PowerShellGen { p: p }\n    }\n\n    pub fn generate_to<W: Write>(&self, buf: &mut W) {\n        let bin_name = self.p.meta.bin_name.as_ref().unwrap();\n\n        let mut names = vec![];\n        let subcommands_cases = generate_inner(self.p, \"\", &mut names);\n\n        let result = format!(\n            r#\"\nusing namespace System.Management.Automation\nusing namespace System.Management.Automation.Language\n\nRegister-ArgumentCompleter -Native -CommandName '{bin_name}' -ScriptBlock {{\n    param($wordToComplete, $commandAst, $cursorPosition)\n\n    $commandElements = $commandAst.CommandElements\n    $command = @(\n        '{bin_name}'\n        for ($i = 1; $i -lt $commandElements.Count; $i++) {{\n            $element = $commandElements[$i]\n            if ($element -isnot [StringConstantExpressionAst] -or\n                $element.StringConstantType -ne [StringConstantType]::BareWord -or\n                $element.Value.StartsWith('-')) {{\n                break\n        }}\n        $element.Value\n    }}) -join ';'\n\n    $completions = @(switch ($command) {{{subcommands_cases}\n    }})\n\n    $completions.Where{{ $_.CompletionText -like \"$wordToComplete*\" }} |\n        Sort-Object -Property ListItemText\n}}\n\"#,\n            bin_name = bin_name,\n            subcommands_cases = subcommands_cases\n        );\n\n        w!(buf, result.as_bytes());\n    }\n}"],"completions::shell::Shell":["Clone","Copy","Debug","impl FromStr for Shell {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"ZSH\" | _ if s.eq_ignore_ascii_case(\"zsh\") => Ok(Shell::Zsh),\n            \"FISH\" | _ if s.eq_ignore_ascii_case(\"fish\") => Ok(Shell::Fish),\n            \"BASH\" | _ if s.eq_ignore_ascii_case(\"bash\") => Ok(Shell::Bash),\n            \"POWERSHELL\" | _ if s.eq_ignore_ascii_case(\"powershell\") => Ok(Shell::PowerShell),\n            \"ELVISH\" | _ if s.eq_ignore_ascii_case(\"elvish\") => Ok(Shell::Elvish),\n            _ => Err(String::from(\n                \"[valid values: bash, fish, zsh, powershell, elvish]\",\n            )),\n        }\n    }\n}","impl Shell {\n    /// A list of possible variants in `&'static str` form\n    pub fn variants() -> [&'static str; 5] {\n        [\"zsh\", \"bash\", \"fish\", \"powershell\", \"elvish\"]\n    }\n}","impl fmt::Display for Shell {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Shell::Bash => write!(f, \"BASH\"),\n            Shell::Fish => write!(f, \"FISH\"),\n            Shell::Zsh => write!(f, \"ZSH\"),\n            Shell::PowerShell => write!(f, \"POWERSHELL\"),\n            Shell::Elvish => write!(f, \"ELVISH\"),\n        }\n    }\n}"],"completions::zsh::ZshGen":["impl<'a, 'b> ZshGen<'a, 'b> {\n    pub fn new(p: &'b Parser<'a, 'b>) -> Self {\n        debugln!(\"ZshGen::new;\");\n        ZshGen { p: p }\n    }\n\n    pub fn generate_to<W: Write>(&self, buf: &mut W) {\n        debugln!(\"ZshGen::generate_to;\");\n        w!(\n            buf,\n            format!(\n                \"\\\n#compdef {name}\n\nautoload -U is-at-least\n\n_{name}() {{\n    typeset -A opt_args\n    typeset -a _arguments_options\n    local ret=1\n\n    if is-at-least 5.2; then\n        _arguments_options=(-s -S -C)\n    else\n        _arguments_options=(-s -C)\n    fi\n\n    local context curcontext=\\\"$curcontext\\\" state line\n    {initial_args}\n    {subcommands}\n}}\n\n{subcommand_details}\n\n_{name} \\\"$@\\\"\",\n                name = self.p.meta.bin_name.as_ref().unwrap(),\n                initial_args = get_args_of(self.p),\n                subcommands = get_subcommands_of(self.p),\n                subcommand_details = subcommand_details(self.p)\n            )\n            .as_bytes()\n        );\n    }\n}"],"errors::Error":["Debug","impl Display for Error {\n    fn fmt(&self, f: &mut std_fmt::Formatter) -> std_fmt::Result {\n        writeln!(f, \"{}\", self.message)\n    }\n}","impl Error {\n    /// Should the message be written to `stdout` or not\n    pub fn use_stderr(&self) -> bool {\n        match self.kind {\n            ErrorKind::HelpDisplayed | ErrorKind::VersionDisplayed => false,\n            _ => true,\n        }\n    }\n\n    /// Prints the error to `stderr` and exits with a status of `1`\n    pub fn exit(&self) -> ! {\n        if self.use_stderr() {\n            wlnerr!(\"{}\", self.message);\n            process::exit(1);\n        }\n        let out = io::stdout();\n        writeln!(&mut out.lock(), \"{}\", self.message).expect(\"Error writing Error to stdout\");\n        process::exit(0);\n    }\n\n    #[doc(hidden)]\n    pub fn write_to<W: Write>(&self, w: &mut W) -> io::Result<()> {\n        write!(w, \"{}\", self.message)\n    }\n\n    #[doc(hidden)]\n    pub fn argument_conflict<O, U>(\n        arg: &AnyArg,\n        other: Option<O>,\n        usage: U,\n        color: ColorWhen,\n    ) -> Self\n    where\n        O: Into<String>,\n        U: Display,\n    {\n        let mut v = vec![arg.name().to_owned()];\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' cannot be used with {}\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(&*arg.to_string()),\n                match other {\n                    Some(name) => {\n                        let n = name.into();\n                        v.push(n.clone());\n                        c.warning(format!(\"'{}'\", n))\n                    }\n                    None => c.none(\"one or more of the other specified arguments\".to_owned()),\n                },\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::ArgumentConflict,\n            info: Some(v),\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn empty_value<U>(arg: &AnyArg, usage: U, color: ColorWhen) -> Self\n    where\n        U: Display,\n    {\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' requires a value but none was supplied\\\n                 \\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(arg.to_string()),\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::EmptyValue,\n            info: Some(vec![arg.name().to_owned()]),\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn invalid_value<B, G, U>(\n        bad_val: B,\n        good_vals: &[G],\n        arg: &AnyArg,\n        usage: U,\n        color: ColorWhen,\n    ) -> Self\n    where\n        B: AsRef<str>,\n        G: AsRef<str> + Display,\n        U: Display,\n    {\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        let suffix = suggestions::did_you_mean_value_suffix(bad_val.as_ref(), good_vals.iter());\n\n        let mut sorted = vec![];\n        for v in good_vals {\n            let val = format!(\"{}\", c.good(v));\n            sorted.push(val);\n        }\n        sorted.sort();\n        let valid_values = sorted.join(\", \");\n        Error {\n            message: format!(\n                \"{} '{}' isn't a valid value for '{}'\\n\\t\\\n                 [possible values: {}]\\n\\\n                 {}\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(bad_val.as_ref()),\n                c.warning(arg.to_string()),\n                valid_values,\n                suffix.0,\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::InvalidValue,\n            info: Some(vec![arg.name().to_owned(), bad_val.as_ref().to_owned()]),\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn invalid_subcommand<S, D, N, U>(\n        subcmd: S,\n        did_you_mean: D,\n        name: N,\n        usage: U,\n        color: ColorWhen,\n    ) -> Self\n    where\n        S: Into<String>,\n        D: AsRef<str> + Display,\n        N: Display,\n        U: Display,\n    {\n        let s = subcmd.into();\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The subcommand '{}' wasn't recognized\\n\\t\\\n                 Did you mean '{}'?\\n\\n\\\n                 If you believe you received this message in error, try \\\n                 re-running with '{} {} {}'\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(&*s),\n                c.good(did_you_mean.as_ref()),\n                name,\n                c.good(\"--\"),\n                &*s,\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::InvalidSubcommand,\n            info: Some(vec![s]),\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn unrecognized_subcommand<S, N>(subcmd: S, name: N, color: ColorWhen) -> Self\n    where\n        S: Into<String>,\n        N: Display,\n    {\n        let s = subcmd.into();\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The subcommand '{}' wasn't recognized\\n\\n\\\n                 {}\\n\\t\\\n                 {} help <subcommands>...\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(&*s),\n                c.warning(\"USAGE:\"),\n                name,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::UnrecognizedSubcommand,\n            info: Some(vec![s]),\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn missing_required_argument<R, U>(required: R, usage: U, color: ColorWhen) -> Self\n    where\n        R: Display,\n        U: Display,\n    {\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The following required arguments were not provided:{}\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                required,\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::MissingRequiredArgument,\n            info: None,\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn missing_subcommand<N, U>(name: N, usage: U, color: ColorWhen) -> Self\n    where\n        N: AsRef<str> + Display,\n        U: Display,\n    {\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} '{}' requires a subcommand, but one was not provided\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(name),\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::MissingSubcommand,\n            info: None,\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn invalid_utf8<U>(usage: U, color: ColorWhen) -> Self\n    where\n        U: Display,\n    {\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} Invalid UTF-8 was detected in one or more arguments\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::InvalidUtf8,\n            info: None,\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn too_many_values<V, U>(val: V, arg: &AnyArg, usage: U, color: ColorWhen) -> Self\n    where\n        V: AsRef<str> + Display + ToOwned,\n        U: Display,\n    {\n        let v = val.as_ref();\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The value '{}' was provided to '{}', but it wasn't expecting \\\n                 any more values\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(v),\n                c.warning(arg.to_string()),\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::TooManyValues,\n            info: Some(vec![arg.name().to_owned(), v.to_owned()]),\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn too_few_values<U>(\n        arg: &AnyArg,\n        min_vals: u64,\n        curr_vals: usize,\n        usage: U,\n        color: ColorWhen,\n    ) -> Self\n    where\n        U: Display,\n    {\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' requires at least {} values, but only {} w{} \\\n                 provided\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(arg.to_string()),\n                c.warning(min_vals.to_string()),\n                c.warning(curr_vals.to_string()),\n                if curr_vals > 1 { \"ere\" } else { \"as\" },\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::TooFewValues,\n            info: Some(vec![arg.name().to_owned()]),\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn value_validation(arg: Option<&AnyArg>, err: String, color: ColorWhen) -> Self {\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} Invalid value{}: {}\",\n                c.error(\"error:\"),\n                if let Some(a) = arg {\n                    format!(\" for '{}'\", c.warning(a.to_string()))\n                } else {\n                    \"\".to_string()\n                },\n                err\n            ),\n            kind: ErrorKind::ValueValidation,\n            info: None,\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn value_validation_auto(err: String) -> Self {\n        let n: Option<&AnyArg> = None;\n        Error::value_validation(n, err, ColorWhen::Auto)\n    }\n\n    #[doc(hidden)]\n    pub fn wrong_number_of_values<S, U>(\n        arg: &AnyArg,\n        num_vals: u64,\n        curr_vals: usize,\n        suffix: S,\n        usage: U,\n        color: ColorWhen,\n    ) -> Self\n    where\n        S: Display,\n        U: Display,\n    {\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' requires {} values, but {} w{} \\\n                 provided\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(arg.to_string()),\n                c.warning(num_vals.to_string()),\n                c.warning(curr_vals.to_string()),\n                suffix,\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::WrongNumberOfValues,\n            info: Some(vec![arg.name().to_owned()]),\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn unexpected_multiple_usage<U>(arg: &AnyArg, usage: U, color: ColorWhen) -> Self\n    where\n        U: Display,\n    {\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' was provided more than once, but cannot \\\n                 be used multiple times\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(arg.to_string()),\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::UnexpectedMultipleUsage,\n            info: Some(vec![arg.name().to_owned()]),\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn unknown_argument<A, U>(arg: A, did_you_mean: &str, usage: U, color: ColorWhen) -> Self\n    where\n        A: Into<String>,\n        U: Display,\n    {\n        let a = arg.into();\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} Found argument '{}' which wasn't expected, or isn't valid in \\\n                 this context{}\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(&*a),\n                if did_you_mean.is_empty() {\n                    \"\\n\".to_owned()\n                } else {\n                    format!(\"{}\\n\", did_you_mean)\n                },\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::UnknownArgument,\n            info: Some(vec![a]),\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn io_error(e: &Error, color: ColorWhen) -> Self {\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\"{} {}\", c.error(\"error:\"), e.description()),\n            kind: ErrorKind::Io,\n            info: None,\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn argument_not_found_auto<A>(arg: A) -> Self\n    where\n        A: Into<String>,\n    {\n        let a = arg.into();\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: ColorWhen::Auto,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' wasn't found\",\n                c.error(\"error:\"),\n                a.clone()\n            ),\n            kind: ErrorKind::ArgumentNotFound,\n            info: Some(vec![a]),\n        }\n    }\n\n    /// Create an error with a custom description.\n    ///\n    /// This can be used in combination with `Error::exit` to exit your program\n    /// with a custom error message.\n    pub fn with_description(description: &str, kind: ErrorKind) -> Self {\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: ColorWhen::Auto,\n        });\n        Error {\n            message: format!(\"{} {}\", c.error(\"error:\"), description),\n            kind: kind,\n            info: None,\n        }\n    }\n}","impl From<io::Error> for Error {\n    fn from(e: io::Error) -> Self {\n        Error::with_description(e.description(), ErrorKind::Io)\n    }\n}","impl From<std_fmt::Error> for Error {\n    fn from(e: std_fmt::Error) -> Self {\n        Error::with_description(e.description(), ErrorKind::Format)\n    }\n}","impl StdError for Error {\n    fn description(&self) -> &str {\n        &*self.message\n    }\n}"],"errors::ErrorKind":["Clone","Copy","Debug","PartialEq"],"fmt::ColorWhen":["Clone","Copy","Debug","PartialEq"],"fmt::Colorizer":["impl Colorizer {\n    pub fn new(option: ColorizerOption) -> Colorizer {\n        let is_a_tty = is_a_tty(option.use_stderr);\n        let is_term_dumb = is_term_dumb();\n        Colorizer {\n            when: match option.when {\n                ColorWhen::Auto if is_a_tty && !is_term_dumb => ColorWhen::Auto,\n                ColorWhen::Auto => ColorWhen::Never,\n                when => when,\n            },\n        }\n    }\n\n    pub fn good<T>(&self, msg: T) -> Format<T>\n    where\n        T: fmt::Display + AsRef<str>,\n    {\n        debugln!(\"Colorizer::good;\");\n        color!(self, Good, msg)\n    }\n\n    pub fn warning<T>(&self, msg: T) -> Format<T>\n    where\n        T: fmt::Display + AsRef<str>,\n    {\n        debugln!(\"Colorizer::warning;\");\n        color!(self, Warning, msg)\n    }\n\n    pub fn error<T>(&self, msg: T) -> Format<T>\n    where\n        T: fmt::Display + AsRef<str>,\n    {\n        debugln!(\"Colorizer::error;\");\n        color!(self, Error, msg)\n    }\n\n    pub fn none<T>(&self, msg: T) -> Format<T>\n    where\n        T: fmt::Display + AsRef<str>,\n    {\n        debugln!(\"Colorizer::none;\");\n        Format::None(msg)\n    }\n}","impl Default for Colorizer {\n    fn default() -> Self {\n        Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: ColorWhen::Auto,\n        })\n    }\n}"],"fmt::Format":["Debug","impl<T: AsRef<str>> Format<T> {\n    fn format(&self) -> ANSIString {\n        match *self {\n            Format::Error(ref e) => Red.bold().paint(e.as_ref()),\n            Format::Warning(ref e) => Yellow.paint(e.as_ref()),\n            Format::Good(ref e) => Green.paint(e.as_ref()),\n            Format::None(ref e) => ANSIString::from(e.as_ref()),\n        }\n    }\n}","impl<T: AsRef<str>> fmt::Display for Format<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", &self.format())\n    }\n}"],"osstringext::OsSplit":["Clone","Debug","impl<'a> Iterator for OsSplit<'a> {\n    type Item = &'a OsStr;\n\n    fn next(&mut self) -> Option<&'a OsStr> {\n        debugln!(\"OsSplit::next: self={:?}\", self);\n        if self.pos == self.val.len() {\n            return None;\n        }\n        let start = self.pos;\n        for b in &self.val[start..] {\n            self.pos += 1;\n            if *b == self.sep {\n                return Some(OsStr::from_bytes(&self.val[start..self.pos - 1]));\n            }\n        }\n        Some(OsStr::from_bytes(&self.val[start..]))\n    }\n}"],"std::ffi::OsStr":["impl OsStrExt2 for OsStr {\n    fn starts_with(&self, s: &[u8]) -> bool {\n        #[cfg(target_os = \"windows\")]\n        {\n            // On Windows, the as_bytes() method will panic if the OsStr\n            // contains invalid Unicode. To avoid this, we use a\n            // Windows-specific starts-with function that doesn't rely on\n            // as_bytes(). This is necessary for Windows command line\n            // applications to handle non-Unicode arguments successfully. This\n            // allows common cases like `clap.exe [invalid]` to succeed, though\n            // cases that require string splitting will still fail, like\n            // `clap.exe --arg=[invalid]`. Note that this entire module is\n            // replaced in Clap 3.x, so this workaround is specific to the 2.x\n            // branch.\n            return windows_osstr_starts_with(self, s);\n        }\n        self.as_bytes().starts_with(s)\n    }\n\n    fn contains_byte(&self, byte: u8) -> bool {\n        for b in self.as_bytes() {\n            if b == &byte {\n                return true;\n            }\n        }\n        false\n    }\n\n    fn split_at_byte(&self, byte: u8) -> (&OsStr, &OsStr) {\n        for (i, b) in self.as_bytes().iter().enumerate() {\n            if b == &byte {\n                return (\n                    OsStr::from_bytes(&self.as_bytes()[..i]),\n                    OsStr::from_bytes(&self.as_bytes()[i + 1..]),\n                );\n            }\n        }\n        (\n            &*self,\n            OsStr::from_bytes(&self.as_bytes()[self.len()..self.len()]),\n        )\n    }\n\n    fn trim_left_matches(&self, byte: u8) -> &OsStr {\n        let mut found = false;\n        for (i, b) in self.as_bytes().iter().enumerate() {\n            if b != &byte {\n                return OsStr::from_bytes(&self.as_bytes()[i..]);\n            } else {\n                found = true;\n            }\n        }\n        if found {\n            return OsStr::from_bytes(&self.as_bytes()[self.len()..]);\n        }\n        &*self\n    }\n\n    fn split_at(&self, i: usize) -> (&OsStr, &OsStr) {\n        (\n            OsStr::from_bytes(&self.as_bytes()[..i]),\n            OsStr::from_bytes(&self.as_bytes()[i..]),\n        )\n    }\n\n    fn split(&self, b: u8) -> OsSplit {\n        OsSplit {\n            sep: b,\n            val: self.as_bytes(),\n            pos: 0,\n        }\n    }\n}"],"usage_parser::UsageParser":["Debug","impl<'a> UsageParser<'a> {\n    fn new(usage: &'a str) -> Self {\n        debugln!(\"UsageParser::new: usage={:?}\", usage);\n        UsageParser {\n            usage: usage,\n            pos: 0,\n            start: 0,\n            prev: UsageToken::Unknown,\n            explicit_name_set: false,\n        }\n    }\n\n    pub fn from_usage(usage: &'a str) -> Self {\n        debugln!(\"UsageParser::from_usage;\");\n        UsageParser::new(usage)\n    }\n\n    pub fn parse(mut self) -> Arg<'a, 'a> {\n        debugln!(\"UsageParser::parse;\");\n        let mut arg = Arg::default();\n        loop {\n            debugln!(\"UsageParser::parse:iter: pos={};\", self.pos);\n            self.stop_at(token);\n            if let Some(&c) = self.usage.as_bytes().get(self.pos) {\n                match c {\n                    b'-' => self.short_or_long(&mut arg),\n                    b'.' => self.multiple(&mut arg),\n                    b'\\'' => self.help(&mut arg),\n                    _ => self.name(&mut arg),\n                }\n            } else {\n                break;\n            }\n        }\n        debug_assert!(\n            !arg.b.name.is_empty(),\n            format!(\n                \"No name found for Arg when parsing usage string: {}\",\n                self.usage\n            )\n        );\n        arg.v.num_vals = match arg.v.val_names {\n            Some(ref v) if v.len() >= 2 => Some(v.len() as u64),\n            _ => None,\n        };\n        debugln!(\"UsageParser::parse: vals...{:?}\", arg.v.val_names);\n        arg\n    }\n\n    fn name(&mut self, arg: &mut Arg<'a, 'a>) {\n        debugln!(\"UsageParser::name;\");\n        if *self\n            .usage\n            .as_bytes()\n            .get(self.pos)\n            .expect(INTERNAL_ERROR_MSG)\n            == b'<'\n            && !self.explicit_name_set\n        {\n            arg.setb(ArgSettings::Required);\n        }\n        self.pos += 1;\n        self.stop_at(name_end);\n        let name = &self.usage[self.start..self.pos];\n        if self.prev == UsageToken::Unknown {\n            debugln!(\"UsageParser::name: setting name...{}\", name);\n            arg.b.name = name;\n            if arg.s.long.is_none() && arg.s.short.is_none() {\n                debugln!(\"UsageParser::name: explicit name set...\");\n                self.explicit_name_set = true;\n                self.prev = UsageToken::Name;\n            }\n        } else {\n            debugln!(\"UsageParser::name: setting val name...{}\", name);\n            if let Some(ref mut v) = arg.v.val_names {\n                let len = v.len();\n                v.insert(len, name);\n            } else {\n                let mut v = VecMap::new();\n                v.insert(0, name);\n                arg.v.val_names = Some(v);\n                arg.setb(ArgSettings::TakesValue);\n            }\n            self.prev = UsageToken::ValName;\n        }\n    }\n\n    fn stop_at<F>(&mut self, f: F)\n    where\n        F: Fn(u8) -> bool,\n    {\n        debugln!(\"UsageParser::stop_at;\");\n        self.start = self.pos;\n        self.pos += self.usage[self.start..]\n            .bytes()\n            .take_while(|&b| f(b))\n            .count();\n    }\n\n    fn short_or_long(&mut self, arg: &mut Arg<'a, 'a>) {\n        debugln!(\"UsageParser::short_or_long;\");\n        self.pos += 1;\n        if *self\n            .usage\n            .as_bytes()\n            .get(self.pos)\n            .expect(INTERNAL_ERROR_MSG)\n            == b'-'\n        {\n            self.pos += 1;\n            self.long(arg);\n            return;\n        }\n        self.short(arg)\n    }\n\n    fn long(&mut self, arg: &mut Arg<'a, 'a>) {\n        debugln!(\"UsageParser::long;\");\n        self.stop_at(long_end);\n        let name = &self.usage[self.start..self.pos];\n        if !self.explicit_name_set {\n            debugln!(\"UsageParser::long: setting name...{}\", name);\n            arg.b.name = name;\n        }\n        debugln!(\"UsageParser::long: setting long...{}\", name);\n        arg.s.long = Some(name);\n        self.prev = UsageToken::Long;\n    }\n\n    fn short(&mut self, arg: &mut Arg<'a, 'a>) {\n        debugln!(\"UsageParser::short;\");\n        let start = &self.usage[self.pos..];\n        let short = start.chars().nth(0).expect(INTERNAL_ERROR_MSG);\n        debugln!(\"UsageParser::short: setting short...{}\", short);\n        arg.s.short = Some(short);\n        if arg.b.name.is_empty() {\n            // --long takes precedence but doesn't set self.explicit_name_set\n            let name = &start[..short.len_utf8()];\n            debugln!(\"UsageParser::short: setting name...{}\", name);\n            arg.b.name = name;\n        }\n        self.prev = UsageToken::Short;\n    }\n\n    // \"something...\"\n    fn multiple(&mut self, arg: &mut Arg) {\n        debugln!(\"UsageParser::multiple;\");\n        let mut dot_counter = 1;\n        let start = self.pos;\n        let mut bytes = self.usage[start..].bytes();\n        while bytes.next() == Some(b'.') {\n            dot_counter += 1;\n            self.pos += 1;\n            if dot_counter == 3 {\n                debugln!(\"UsageParser::multiple: setting multiple\");\n                arg.setb(ArgSettings::Multiple);\n                if arg.is_set(ArgSettings::TakesValue) {\n                    arg.setb(ArgSettings::UseValueDelimiter);\n                    arg.unsetb(ArgSettings::ValueDelimiterNotSet);\n                    if arg.v.val_delim.is_none() {\n                        arg.v.val_delim = Some(',');\n                    }\n                }\n                self.prev = UsageToken::Multiple;\n                self.pos += 1;\n                break;\n            }\n        }\n    }\n\n    fn help(&mut self, arg: &mut Arg<'a, 'a>) {\n        debugln!(\"UsageParser::help;\");\n        self.stop_at(help_start);\n        self.start = self.pos + 1;\n        self.pos = self.usage.len() - 1;\n        debugln!(\n            \"UsageParser::help: setting help...{}\",\n            &self.usage[self.start..self.pos]\n        );\n        arg.b.help = Some(&self.usage[self.start..self.pos]);\n        self.pos += 1; // Move to next byte to keep from thinking ending ' is a start\n        self.prev = UsageToken::Help;\n    }\n}"],"usage_parser::UsageToken":["Debug","PartialEq"]},"single_path_import":{"app::App":"App","app::settings::AppSettings":"app::AppSettings","args::any_arg::AnyArg":"args::AnyArg","args::any_arg::DispOrder":"args::DispOrder","args::arg::Arg":"args::Arg","args::arg_builder::base::Base":"args::arg_builder::Base","args::arg_builder::flag::FlagBuilder":"args::arg_builder::FlagBuilder","args::arg_builder::option::OptBuilder":"args::arg_builder::OptBuilder","args::arg_builder::positional::PosBuilder":"args::arg_builder::PosBuilder","args::arg_builder::switched::Switched":"args::arg_builder::Switched","args::arg_builder::valued::Valued":"args::arg_builder::Valued","args::arg_matcher::ArgMatcher":"args::ArgMatcher","args::arg_matches::ArgMatches":"args::ArgMatches","args::arg_matches::OsValues":"args::OsValues","args::arg_matches::Values":"args::Values","args::group::ArgGroup":"args::ArgGroup","args::matched_arg::MatchedArg":"args::MatchedArg","args::settings::ArgFlags":"args::ArgFlags","args::settings::ArgSettings":"args::ArgSettings","args::subcommand::SubCommand":"args::SubCommand","completions::shell::Shell":"completions::Shell","errors::Error":"Error","errors::ErrorKind":"ErrorKind","errors::Result":"Result","fmt::Format":"Format","vec_map::Values":"map::Values","vec_map::VecMap":"map::VecMap"},"srcs":{"<&'z T as args::any_arg::AnyArg<'n, 'e>>::aliases":["fn aliases(&self) -> Option<Vec<&'e str>>{\n        (*self).aliases()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::blacklist":["fn blacklist(&self) -> Option<&[&'e str]>{\n        (*self).blacklist()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::default_val":["fn default_val(&self) -> Option<&'e OsStr>{\n        (*self).default_val()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["fn default_vals_ifs(&self) -> Option<map::Values<(&'n str, Option<&'e OsStr>, &'e OsStr)>>{\n        (*self).default_vals_ifs()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::env":["fn env<'s>(&'s self) -> Option<(&'n OsStr, Option<&'s OsString>)>{\n        (*self).env()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::has_switch":["fn has_switch(&self) -> bool{\n        (*self).has_switch()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::help":["fn help(&self) -> Option<&'e str>{\n        (*self).help()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::is_set":["fn is_set(&self, a: ArgSettings) -> bool{\n        (*self).is_set(a)\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::long":["fn long(&self) -> Option<&'e str>{\n        (*self).long()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::long_help":["fn long_help(&self) -> Option<&'e str>{\n        (*self).long_help()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["fn longest_filter(&self) -> bool{\n        (*self).longest_filter()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::max_vals":["fn max_vals(&self) -> Option<u64>{\n        (*self).max_vals()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::min_vals":["fn min_vals(&self) -> Option<u64>{\n        (*self).min_vals()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::name":["fn name(&self) -> &'n str{\n        (*self).name()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::num_vals":["fn num_vals(&self) -> Option<u64>{\n        (*self).num_vals()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::overrides":["fn overrides(&self) -> Option<&[&'e str]>{\n        (*self).overrides()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["fn possible_vals(&self) -> Option<&[&'e str]>{\n        (*self).possible_vals()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::required_unless":["fn required_unless(&self) -> Option<&[&'e str]>{\n        (*self).required_unless()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::requires":["fn requires(&self) -> Option<&[(Option<&'e str>, &'n str)]>{\n        (*self).requires()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::set":["fn set(&mut self, _: ArgSettings){\n        panic!(INTERNAL_ERROR_MSG)\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::short":["fn short(&self) -> Option<char>{\n        (*self).short()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::takes_value":["fn takes_value(&self) -> bool{\n        (*self).takes_value()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::val_delim":["fn val_delim(&self) -> Option<char>{\n        (*self).val_delim()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::val_names":["fn val_names(&self) -> Option<&VecMap<&'e str>>{\n        (*self).val_names()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["fn val_terminator(&self) -> Option<&'e str>{\n        (*self).val_terminator()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::validator":["fn validator(&self) -> Option<&Rc<Fn(String) -> Result<(), String>>>{\n        (*self).validator()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::validator_os":["fn validator_os(&self) -> Option<&Rc<Fn(&OsStr) -> Result<(), OsString>>>{\n        (*self).validator_os()\n    }","Real(LocalPath(\"src/args/any_arg.rs\"))"],"<T as app::help::ArgWithOrder<'b, 'c>>::as_base":["fn as_base(&self) -> &ArgWithDisplay<'b, 'c>{\n        self\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"<app::App<'a, 'b> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        App { p: self.p.clone() }\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["fn aliases(&self) -> Option<Vec<&'e str>>{\n        if let Some(ref aliases) = self.p.meta.aliases {\n            let vis_aliases: Vec<_> = aliases\n                .iter()\n                .filter_map(|&(n, v)| if v { Some(n) } else { None })\n                .collect();\n            if vis_aliases.is_empty() {\n                None\n            } else {\n                Some(vis_aliases)\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["fn blacklist(&self) -> Option<&[&'e str]>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["fn default_val(&self) -> Option<&'e OsStr>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["fn default_vals_ifs(&self) -> Option<map::Values<(&'n str, Option<&'e OsStr>, &'e OsStr)>>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["fn env<'s>(&'s self) -> Option<(&'n OsStr, Option<&'s OsString>)>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["fn has_switch(&self) -> bool{\n        false\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["fn help(&self) -> Option<&'e str>{\n        self.p.meta.about\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["fn is_set(&self, _: ArgSettings) -> bool{\n        false\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["fn long(&self) -> Option<&'e str>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["fn long_help(&self) -> Option<&'e str>{\n        self.p.meta.long_about\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["fn longest_filter(&self) -> bool{\n        true\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["fn max_vals(&self) -> Option<u64>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["fn min_vals(&self) -> Option<u64>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["fn name(&self) -> &'n str{\n        \"\"\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["fn num_vals(&self) -> Option<u64>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["fn overrides(&self) -> Option<&[&'e str]>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["fn possible_vals(&self) -> Option<&[&'e str]>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["fn required_unless(&self) -> Option<&[&'e str]>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["fn requires(&self) -> Option<&[(Option<&'e str>, &'n str)]>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["fn set(&mut self, _: ArgSettings){\n        unreachable!(\"App struct does not support AnyArg::set, this is a bug!\")\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["fn short(&self) -> Option<char>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["fn takes_value(&self) -> bool{\n        true\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["fn val_delim(&self) -> Option<char>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["fn val_names(&self) -> Option<&VecMap<&'e str>>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["fn val_terminator(&self) -> Option<&'e str>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["fn validator(&self) -> Option<&Rc<Fn(String) -> StdResult<(), String>>>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["fn validator_os(&self) -> Option<&Rc<Fn(&OsStr) -> StdResult<(), OsString>>>{\n        None\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::App<'n, 'e> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"{}\", self.p.meta.name)\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"<app::settings::AppFlags as std::default::Default>::default":["fn default() -> Self{\n        AppFlags(\n            Flags::NEEDS_LONG_VERSION\n                | Flags::NEEDS_LONG_HELP\n                | Flags::NEEDS_SC_HELP\n                | Flags::UTF8_NONE\n                | Flags::COLOR_AUTO,\n        )\n    }","Real(LocalPath(\"src/app/settings.rs\"))"],"<app::settings::AppFlags as std::ops::BitOr>::bitor":["fn bitor(self, rhs: Self) -> Self{\n        AppFlags(self.0 | rhs.0)\n    }","Real(LocalPath(\"src/app/settings.rs\"))"],"<app::settings::AppSettings as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Self, <Self as FromStr>::Err>{\n        match &*s.to_ascii_lowercase() {\n            \"disablehelpflags\" => Ok(AppSettings::DisableHelpFlags),\n            \"argrequiredelsehelp\" => Ok(AppSettings::ArgRequiredElseHelp),\n            \"argsnegatesubcommands\" => Ok(AppSettings::ArgsNegateSubcommands),\n            \"allowinvalidutf8\" => Ok(AppSettings::AllowInvalidUtf8),\n            \"allowleadinghyphen\" => Ok(AppSettings::AllowLeadingHyphen),\n            \"allowexternalsubcommands\" => Ok(AppSettings::AllowExternalSubcommands),\n            \"allownegativenumbers\" => Ok(AppSettings::AllowNegativeNumbers),\n            \"colorauto\" => Ok(AppSettings::ColorAuto),\n            \"coloralways\" => Ok(AppSettings::ColorAlways),\n            \"colornever\" => Ok(AppSettings::ColorNever),\n            \"coloredhelp\" => Ok(AppSettings::ColoredHelp),\n            \"derivedisplayorder\" => Ok(AppSettings::DeriveDisplayOrder),\n            \"dontcollapseargsinusage\" => Ok(AppSettings::DontCollapseArgsInUsage),\n            \"dontdelimittrailingvalues\" => Ok(AppSettings::DontDelimitTrailingValues),\n            \"disablehelpsubcommand\" => Ok(AppSettings::DisableHelpSubcommand),\n            \"disableversion\" => Ok(AppSettings::DisableVersion),\n            \"globalversion\" => Ok(AppSettings::GlobalVersion),\n            \"hidden\" => Ok(AppSettings::Hidden),\n            \"hidepossiblevaluesinhelp\" => Ok(AppSettings::HidePossibleValuesInHelp),\n            \"infersubcommands\" => Ok(AppSettings::InferSubcommands),\n            \"lowindexmultiplepositional\" => Ok(AppSettings::LowIndexMultiplePositional),\n            \"nobinaryname\" => Ok(AppSettings::NoBinaryName),\n            \"nextlinehelp\" => Ok(AppSettings::NextLineHelp),\n            \"strictutf8\" => Ok(AppSettings::StrictUtf8),\n            \"subcommandsnegatereqs\" => Ok(AppSettings::SubcommandsNegateReqs),\n            \"subcommandrequired\" => Ok(AppSettings::SubcommandRequired),\n            \"subcommandrequiredelsehelp\" => Ok(AppSettings::SubcommandRequiredElseHelp),\n            \"trailingvararg\" => Ok(AppSettings::TrailingVarArg),\n            \"unifiedhelpmessage\" => Ok(AppSettings::UnifiedHelpMessage),\n            \"versionlesssubcommands\" => Ok(AppSettings::VersionlessSubcommands),\n            \"waitonerror\" => Ok(AppSettings::WaitOnError),\n            \"validnegnumfound\" => Ok(AppSettings::ValidNegNumFound),\n            \"validargfound\" => Ok(AppSettings::ValidArgFound),\n            \"propagated\" => Ok(AppSettings::Propagated),\n            \"trailingvalues\" => Ok(AppSettings::TrailingValues),\n            _ => Err(\"unknown AppSetting, cannot convert from str\".to_owned()),\n        }\n    }","Real(LocalPath(\"src/app/settings.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_MISSING_POS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_NEG_NUMS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_UNK_SC":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ARGS_NEGATE_SCS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ARGS_OVERRIDE_SELF":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::A_REQUIRED_ELSE_HELP":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLORED_HELP":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLOR_ALWAYS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLOR_AUTO":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLOR_NEVER":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::CONTAINS_LAST":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DERIVE_DISP_ORDER":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DISABLE_HELP_FLAGS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DISABLE_HELP_SC":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DISABLE_VERSION":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DONT_COLLAPSE_ARGS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DONT_DELIM_TRAIL":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::GLOBAL_VERSION":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::INFER_SUBCOMMANDS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::LEADING_HYPHEN":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::LOW_INDEX_MUL_POS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEEDS_LONG_HELP":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEEDS_LONG_VERSION":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEEDS_SC_HELP":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEXT_LINE_HELP":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NO_BIN_NAME":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NO_POS_VALUES":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::PROPAGATED":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::PROPAGATE_VALS_DOWN":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::SC_NEGATE_REQS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::SC_REQUIRED":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::SC_REQUIRED_ELSE_HELP":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::TRAILING_VALUES":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::TRAILING_VARARG":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::UNIFIED_HELP":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::UTF8_NONE":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::UTF8_STRICT":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::VALID_ARG_FOUND":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::VALID_NEG_NUM_FOUND":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::VERSIONLESS_SC":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::WAIT_ON_ERROR":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Binary>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                // This convoluted approach is to handle #[cfg]-based flag\n                // omission correctly. For example it needs to support:\n                //\n                //    #[cfg(unix)] const A: Flag = /* ... */;\n                //    #[cfg(windows)] const B: Flag = /* ... */;\n\n                // Unconditionally define a check for every flag, even disabled\n                // ones.\n                #[allow(non_snake_case)]\n                trait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }\n\n                // Conditionally override the check for just those flags that\n                // are not #[cfg]ed away.\n                #[allow(non_snake_case)]\n                impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags":["#[allow(non_snake_case)]\ntrait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_MISSING_POS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_NEG_NUMS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_UNK_SC":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ARGS_NEGATE_SCS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ARGS_OVERRIDE_SELF":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::A_REQUIRED_ELSE_HELP":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLORED_HELP":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLOR_ALWAYS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLOR_AUTO":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLOR_NEVER":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::CONTAINS_LAST":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DERIVE_DISP_ORDER":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DISABLE_HELP_FLAGS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DISABLE_HELP_SC":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DISABLE_VERSION":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DONT_COLLAPSE_ARGS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DONT_DELIM_TRAIL":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::GLOBAL_VERSION":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::INFER_SUBCOMMANDS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::LEADING_HYPHEN":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::LOW_INDEX_MUL_POS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEEDS_LONG_HELP":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEEDS_LONG_VERSION":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEEDS_SC_HELP":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEXT_LINE_HELP":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NO_BIN_NAME":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NO_POS_VALUES":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::PROPAGATED":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::PROPAGATE_VALS_DOWN":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::SC_NEGATE_REQS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::SC_REQUIRED":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::SC_REQUIRED_ELSE_HELP":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::TRAILING_VALUES":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::TRAILING_VARARG":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::UNIFIED_HELP":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::UTF8_NONE":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::UTF8_STRICT":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::VALID_ARG_FOUND":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::VALID_NEG_NUM_FOUND":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::VERSIONLESS_SC":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::WAIT_ON_ERROR":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::LowerHex>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::Octal>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::fmt::UpperHex>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::iter::Extend<app::settings::Flags>>::extend":["fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T){\n                for item in iterator {\n                    self.insert(item)\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::iter::FromIterator<app::settings::Flags>>::from_iter":["fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self{\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::ops::BitAnd>::bitand":["/// Returns the intersection between the two sets of flags.\n#[inline]\nfn bitand(self, other: Self) -> Self{\n                Self { bits: self.bits & other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::ops::BitAndAssign>::bitand_assign":["/// Disables all flags disabled in the set.\n#[inline]\nfn bitand_assign(&mut self, other: Self){\n                self.bits &= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::ops::BitOr>::bitor":["/// Returns the union of the two sets of flags.\n#[inline]\nfn bitor(self, other: $BitFlags) -> Self{\n                Self { bits: self.bits | other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::ops::BitOrAssign>::bitor_assign":["/// Adds the set of flags.\n#[inline]\nfn bitor_assign(&mut self, other: Self){\n                self.bits |= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::ops::BitXor>::bitxor":["/// Returns the left flags, but with all the right flags toggled.\n#[inline]\nfn bitxor(self, other: Self) -> Self{\n                Self { bits: self.bits ^ other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::ops::BitXorAssign>::bitxor_assign":["/// Toggles the set of flags.\n#[inline]\nfn bitxor_assign(&mut self, other: Self){\n                self.bits ^= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::ops::Not>::not":["/// Returns the complement of this set of flags.\n#[inline]\nfn not(self) -> Self{\n                Self { bits: !self.bits } & Self::all()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::ops::Sub>::sub":["/// Returns the set difference of the two sets of flags.\n#[inline]\nfn sub(self, other: Self) -> Self{\n                Self { bits: self.bits & !other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<app::settings::Flags as std::ops::SubAssign>::sub_assign":["/// Disables all flags enabled in the set.\n#[inline]\nfn sub_assign(&mut self, other: Self){\n                self.bits &= !other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::arg::Arg<'a, 'b> as std::convert::From<&'z args::arg::Arg<'a, 'b>>>::from":["fn from(a: &'z Arg<'a, 'b>) -> Self{\n        Arg {\n            b: a.b.clone(),\n            v: a.v.clone(),\n            s: a.s.clone(),\n            index: a.index,\n            r_ifs: a.r_ifs.clone(),\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"<args::arg::Arg<'n, 'e> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Arg<'n, 'e>) -> bool{\n        self.b == other.b\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"<args::arg_builder::base::Base<'n, 'e> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Base<'n, 'e>) -> bool{\n        self.name == other.name\n    }","Real(LocalPath(\"src/args/arg_builder/base.rs\"))"],"<args::arg_builder::base::Base<'n, 'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["fn from(a: &'z Arg<'n, 'e>) -> Self{\n        a.b.clone()\n    }","Real(LocalPath(\"src/args/arg_builder/base.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'a, 'b> as std::convert::From<&'z args::arg::Arg<'a, 'b>>>::from":["fn from(a: &'z Arg<'a, 'b>) -> Self{\n        FlagBuilder {\n            b: Base::from(a),\n            s: Switched::from(a),\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'a, 'b> as std::convert::From<args::arg::Arg<'a, 'b>>>::from":["fn from(mut a: Arg<'a, 'b>) -> Self{\n        FlagBuilder {\n            b: mem::replace(&mut a.b, Base::default()),\n            s: mem::replace(&mut a.s, Switched::default()),\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["fn aliases(&self) -> Option<Vec<&'e str>>{\n        if let Some(ref aliases) = self.s.aliases {\n            let vis_aliases: Vec<_> = aliases\n                .iter()\n                .filter_map(|&(n, v)| if v { Some(n) } else { None })\n                .collect();\n            if vis_aliases.is_empty() {\n                None\n            } else {\n                Some(vis_aliases)\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["fn blacklist(&self) -> Option<&[&'e str]>{\n        self.b.blacklist.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["fn default_val(&self) -> Option<&'e OsStr>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["fn default_vals_ifs(&self) -> Option<map::Values<(&'n str, Option<&'e OsStr>, &'e OsStr)>>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["fn env<'s>(&'s self) -> Option<(&'n OsStr, Option<&'s OsString>)>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["fn has_switch(&self) -> bool{\n        true\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["fn help(&self) -> Option<&'e str>{\n        self.b.help\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["fn is_set(&self, s: ArgSettings) -> bool{\n        self.b.settings.is_set(s)\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["fn long(&self) -> Option<&'e str>{\n        self.s.long\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["fn long_help(&self) -> Option<&'e str>{\n        self.b.long_help\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["fn longest_filter(&self) -> bool{\n        self.s.long.is_some()\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["fn max_vals(&self) -> Option<u64>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["fn min_vals(&self) -> Option<u64>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["fn name(&self) -> &'n str{\n        self.b.name\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["fn num_vals(&self) -> Option<u64>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["fn overrides(&self) -> Option<&[&'e str]>{\n        self.b.overrides.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["fn possible_vals(&self) -> Option<&[&'e str]>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["fn required_unless(&self) -> Option<&[&'e str]>{\n        self.b.r_unless.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["fn requires(&self) -> Option<&[(Option<&'e str>, &'n str)]>{\n        self.b.requires.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["fn set(&mut self, s: ArgSettings){\n        self.b.settings.set(s)\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["fn short(&self) -> Option<char>{\n        self.s.short\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["fn takes_value(&self) -> bool{\n        false\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["fn val_delim(&self) -> Option<char>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["fn val_names(&self) -> Option<&VecMap<&'e str>>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["fn val_terminator(&self) -> Option<&'e str>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["fn validator(&self) -> Option<&Rc<Fn(String) -> StdResult<(), String>>>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["fn validator_os(&self) -> Option<&Rc<Fn(&OsStr) -> StdResult<(), OsString>>>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::DispOrder>::disp_ord":["fn disp_ord(&self) -> usize{\n        self.s.disp_ord\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &FlagBuilder<'n, 'e>) -> bool{\n        self.b == other.b\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut Formatter) -> Result{\n        if let Some(l) = self.s.long {\n            write!(f, \"--{}\", l)?;\n        } else {\n            write!(f, \"-{}\", self.s.short.unwrap())?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["fn aliases(&self) -> Option<Vec<&'e str>>{\n        if let Some(ref aliases) = self.s.aliases {\n            let vis_aliases: Vec<_> = aliases\n                .iter()\n                .filter_map(|&(n, v)| if v { Some(n) } else { None })\n                .collect();\n            if vis_aliases.is_empty() {\n                None\n            } else {\n                Some(vis_aliases)\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["fn blacklist(&self) -> Option<&[&'e str]>{\n        self.b.blacklist.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["fn default_val(&self) -> Option<&'e OsStr>{\n        self.v.default_val\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["fn default_vals_ifs(&self) -> Option<map::Values<(&'n str, Option<&'e OsStr>, &'e OsStr)>>{\n        self.v.default_vals_ifs.as_ref().map(|vm| vm.values())\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["fn env<'s>(&'s self) -> Option<(&'n OsStr, Option<&'s OsString>)>{\n        self.v\n            .env\n            .as_ref()\n            .map(|&(key, ref value)| (key, value.as_ref()))\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["fn has_switch(&self) -> bool{\n        true\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["fn help(&self) -> Option<&'e str>{\n        self.b.help\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["fn is_set(&self, s: ArgSettings) -> bool{\n        self.b.settings.is_set(s)\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["fn long(&self) -> Option<&'e str>{\n        self.s.long\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["fn long_help(&self) -> Option<&'e str>{\n        self.b.long_help\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["fn longest_filter(&self) -> bool{\n        true\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["fn max_vals(&self) -> Option<u64>{\n        self.v.max_vals\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["fn min_vals(&self) -> Option<u64>{\n        self.v.min_vals\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["fn name(&self) -> &'n str{\n        self.b.name\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["fn num_vals(&self) -> Option<u64>{\n        self.v.num_vals\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["fn overrides(&self) -> Option<&[&'e str]>{\n        self.b.overrides.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["fn possible_vals(&self) -> Option<&[&'e str]>{\n        self.v.possible_vals.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["fn required_unless(&self) -> Option<&[&'e str]>{\n        self.b.r_unless.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["fn requires(&self) -> Option<&[(Option<&'e str>, &'n str)]>{\n        self.b.requires.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["fn set(&mut self, s: ArgSettings){\n        self.b.settings.set(s)\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["fn short(&self) -> Option<char>{\n        self.s.short\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["fn takes_value(&self) -> bool{\n        true\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["fn val_delim(&self) -> Option<char>{\n        self.v.val_delim\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["fn val_names(&self) -> Option<&VecMap<&'e str>>{\n        self.v.val_names.as_ref()\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["fn val_terminator(&self) -> Option<&'e str>{\n        self.v.terminator\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["fn validator(&self) -> Option<&Rc<Fn(String) -> StdResult<(), String>>>{\n        self.v.validator.as_ref()\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["fn validator_os(&self) -> Option<&Rc<Fn(&OsStr) -> StdResult<(), OsString>>>{\n        self.v.validator_os.as_ref()\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::DispOrder>::disp_ord":["fn disp_ord(&self) -> usize{\n        self.s.disp_ord\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &OptBuilder<'n, 'e>) -> bool{\n        self.b == other.b\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["fn from(a: &'z Arg<'n, 'e>) -> Self{\n        OptBuilder {\n            b: Base::from(a),\n            s: Switched::from(a),\n            v: Valued::from(a),\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::convert::From<args::arg::Arg<'n, 'e>>>::from":["fn from(mut a: Arg<'n, 'e>) -> Self{\n        a.v.fill_in();\n        OptBuilder {\n            b: mem::replace(&mut a.b, Base::default()),\n            s: mem::replace(&mut a.s, Switched::default()),\n            v: mem::replace(&mut a.v, Valued::default()),\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut Formatter) -> Result{\n        debugln!(\"OptBuilder::fmt:{}\", self.b.name);\n        let sep = if self.b.is_set(ArgSettings::RequireEquals) {\n            \"=\"\n        } else {\n            \" \"\n        };\n        // Write the name such --long or -l\n        if let Some(l) = self.s.long {\n            write!(f, \"--{}{}\", l, sep)?;\n        } else {\n            write!(f, \"-{}{}\", self.s.short.unwrap(), sep)?;\n        }\n        let delim = if self.is_set(ArgSettings::RequireDelimiter) {\n            self.v.val_delim.expect(INTERNAL_ERROR_MSG)\n        } else {\n            ' '\n        };\n\n        // Write the values such as <name1> <name2>\n        if let Some(ref vec) = self.v.val_names {\n            let mut it = vec.iter().peekable();\n            while let Some((_, val)) = it.next() {\n                write!(f, \"<{}>\", val)?;\n                if it.peek().is_some() {\n                    write!(f, \"{}\", delim)?;\n                }\n            }\n            let num = vec.len();\n            if self.is_set(ArgSettings::Multiple) && num == 1 {\n                write!(f, \"...\")?;\n            }\n        } else if let Some(num) = self.v.num_vals {\n            let mut it = (0..num).peekable();\n            while let Some(_) = it.next() {\n                write!(f, \"<{}>\", self.b.name)?;\n                if it.peek().is_some() {\n                    write!(f, \"{}\", delim)?;\n                }\n            }\n            if self.is_set(ArgSettings::Multiple) && num == 1 {\n                write!(f, \"...\")?;\n            }\n        } else {\n            write!(\n                f,\n                \"<{}>{}\",\n                self.b.name,\n                if self.is_set(ArgSettings::Multiple) {\n                    \"...\"\n                } else {\n                    \"\"\n                }\n            )?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["fn aliases(&self) -> Option<Vec<&'e str>>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["fn blacklist(&self) -> Option<&[&'e str]>{\n        self.b.blacklist.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["fn default_val(&self) -> Option<&'e OsStr>{\n        self.v.default_val\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["fn default_vals_ifs(&self) -> Option<map::Values<(&'n str, Option<&'e OsStr>, &'e OsStr)>>{\n        self.v.default_vals_ifs.as_ref().map(|vm| vm.values())\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["fn env<'s>(&'s self) -> Option<(&'n OsStr, Option<&'s OsString>)>{\n        self.v\n            .env\n            .as_ref()\n            .map(|&(key, ref value)| (key, value.as_ref()))\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["fn has_switch(&self) -> bool{\n        false\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["fn help(&self) -> Option<&'e str>{\n        self.b.help\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["fn is_set(&self, s: ArgSettings) -> bool{\n        self.b.settings.is_set(s)\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["fn long(&self) -> Option<&'e str>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["fn long_help(&self) -> Option<&'e str>{\n        self.b.long_help\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["fn longest_filter(&self) -> bool{\n        true\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["fn max_vals(&self) -> Option<u64>{\n        self.v.max_vals\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["fn min_vals(&self) -> Option<u64>{\n        self.v.min_vals\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["fn name(&self) -> &'n str{\n        self.b.name\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["fn num_vals(&self) -> Option<u64>{\n        self.v.num_vals\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["fn overrides(&self) -> Option<&[&'e str]>{\n        self.b.overrides.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["fn possible_vals(&self) -> Option<&[&'e str]>{\n        self.v.possible_vals.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["fn required_unless(&self) -> Option<&[&'e str]>{\n        self.b.r_unless.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["fn requires(&self) -> Option<&[(Option<&'e str>, &'n str)]>{\n        self.b.requires.as_ref().map(|o| &o[..])\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["fn set(&mut self, s: ArgSettings){\n        self.b.settings.set(s)\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["fn short(&self) -> Option<char>{\n        None\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["fn takes_value(&self) -> bool{\n        true\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["fn val_delim(&self) -> Option<char>{\n        self.v.val_delim\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["fn val_names(&self) -> Option<&VecMap<&'e str>>{\n        self.v.val_names.as_ref()\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["fn val_terminator(&self) -> Option<&'e str>{\n        self.v.terminator\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["fn validator(&self) -> Option<&Rc<Fn(String) -> StdResult<(), String>>>{\n        self.v.validator.as_ref()\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["fn validator_os(&self) -> Option<&Rc<Fn(&OsStr) -> StdResult<(), OsString>>>{\n        self.v.validator_os.as_ref()\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::DispOrder>::disp_ord":["fn disp_ord(&self) -> usize{\n        self.index as usize\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &PosBuilder<'n, 'e>) -> bool{\n        self.b == other.b\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut Formatter) -> Result{\n        let mut delim = String::new();\n        delim.push(if self.is_set(ArgSettings::RequireDelimiter) {\n            self.v.val_delim.expect(INTERNAL_ERROR_MSG)\n        } else {\n            ' '\n        });\n        if let Some(ref names) = self.v.val_names {\n            write!(\n                f,\n                \"{}\",\n                names\n                    .values()\n                    .map(|n| format!(\"<{}>\", n))\n                    .collect::<Vec<_>>()\n                    .join(&*delim)\n            )?;\n        } else {\n            write!(f, \"<{}>\", self.b.name)?;\n        }\n        if self.b.settings.is_set(ArgSettings::Multiple)\n            && (self.v.val_names.is_none() || self.v.val_names.as_ref().unwrap().len() == 1)\n        {\n            write!(f, \"...\")?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"<args::arg_builder::switched::Switched<'e> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        Switched {\n            short: self.short,\n            long: self.long,\n            aliases: self.aliases.clone(),\n            disp_ord: self.disp_ord,\n            unified_ord: self.unified_ord,\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/switched.rs\"))"],"<args::arg_builder::switched::Switched<'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["fn from(a: &'z Arg<'n, 'e>) -> Self{\n        a.s.clone()\n    }","Real(LocalPath(\"src/args/arg_builder/switched.rs\"))"],"<args::arg_builder::switched::Switched<'e> as std::default::Default>::default":["fn default() -> Self{\n        Switched {\n            short: None,\n            long: None,\n            aliases: None,\n            disp_ord: 999,\n            unified_ord: 999,\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/switched.rs\"))"],"<args::arg_builder::valued::Valued<'n, 'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["fn from(a: &'z Arg<'n, 'e>) -> Self{\n        let mut v = a.v.clone();\n        if let Some(ref vec) = a.v.val_names {\n            if vec.len() > 1 {\n                v.num_vals = Some(vec.len() as u64);\n            }\n        }\n        v\n    }","Real(LocalPath(\"src/args/arg_builder/valued.rs\"))"],"<args::arg_builder::valued::Valued<'n, 'e> as std::default::Default>::default":["fn default() -> Self{\n        Valued {\n            possible_vals: None,\n            num_vals: None,\n            min_vals: None,\n            max_vals: None,\n            val_names: None,\n            validator: None,\n            validator_os: None,\n            val_delim: None,\n            default_val: None,\n            default_vals_ifs: None,\n            env: None,\n            terminator: None,\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/valued.rs\"))"],"<args::arg_matcher::ArgMatcher<'a> as std::convert::Into<args::arg_matches::ArgMatches<'a>>>::into":["fn into(self) -> ArgMatches<'a>{\n        self.0\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"<args::arg_matcher::ArgMatcher<'a> as std::default::Default>::default":["fn default() -> Self{\n        ArgMatcher(ArgMatches::default())\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"<args::arg_matches::ArgMatches<'a> as std::default::Default>::default":["fn default() -> Self{\n        ArgMatches {\n            args: HashMap::new(),\n            subcommand: None,\n            usage: None,\n        }\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::Indices<'a> as std::default::Default>::default":["fn default() -> Self{\n        static EMPTY: [usize; 0] = [];\n        // This is never called because the iterator is empty:\n        fn to_usize(_: &usize) -> usize {\n            unreachable!()\n        };\n        Indices {\n            iter: EMPTY[..].iter().map(to_usize),\n        }\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::Indices<'a> as std::default::Default>::default::to_usize":["fn to_usize(_: &usize) -> usize{\n            unreachable!()\n        }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::Indices<'a> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<usize>{\n        self.iter.next_back()\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::Indices<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<usize>{\n        self.iter.next()\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::Indices<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::OsValues<'a> as std::default::Default>::default":["fn default() -> Self{\n        static EMPTY: [OsString; 0] = [];\n        // This is never called because the iterator is empty:\n        fn to_str_slice(_: &OsString) -> &OsStr {\n            unreachable!()\n        };\n        OsValues {\n            iter: EMPTY[..].iter().map(to_str_slice),\n        }\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::OsValues<'a> as std::default::Default>::default::to_str_slice":["fn to_str_slice(_: &OsString) -> &OsStr{\n            unreachable!()\n        }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::OsValues<'a> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<&'a OsStr>{\n        self.iter.next_back()\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::OsValues<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a OsStr>{\n        self.iter.next()\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::OsValues<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::Values<'a> as std::default::Default>::default":["fn default() -> Self{\n        static EMPTY: [OsString; 0] = [];\n        // This is never called because the iterator is empty:\n        fn to_str_slice(_: &OsString) -> &str {\n            unreachable!()\n        };\n        Values {\n            iter: EMPTY[..].iter().map(to_str_slice),\n        }\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::Values<'a> as std::default::Default>::default::to_str_slice":["fn to_str_slice(_: &OsString) -> &str{\n            unreachable!()\n        }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::Values<'a> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<&'a str>{\n        self.iter.next_back()\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::Values<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a str>{\n        self.iter.next()\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::arg_matches::Values<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"<args::group::ArgGroup<'a> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        ArgGroup {\n            name: self.name,\n            required: self.required,\n            args: self.args.clone(),\n            requires: self.requires.clone(),\n            conflicts: self.conflicts.clone(),\n            multiple: self.multiple,\n        }\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"<args::group::ArgGroup<'a> as std::convert::From<&'z args::group::ArgGroup<'a>>>::from":["fn from(g: &'z ArgGroup<'a>) -> Self{\n        ArgGroup {\n            name: g.name,\n            required: g.required,\n            args: g.args.clone(),\n            requires: g.requires.clone(),\n            conflicts: g.conflicts.clone(),\n            multiple: g.multiple,\n        }\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"<args::group::ArgGroup<'a> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut Formatter) -> Result{\n        write!(\n            f,\n            \"{{\\n\\\n             \\tname: {:?},\\n\\\n             \\targs: {:?},\\n\\\n             \\trequired: {:?},\\n\\\n             \\trequires: {:?},\\n\\\n             \\tconflicts: {:?},\\n\\\n             }}\",\n            self.name, self.args, self.required, self.requires, self.conflicts\n        )\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"<args::matched_arg::MatchedArg as std::default::Default>::default":["fn default() -> Self{\n        MatchedArg {\n            occurs: 1,\n            indices: Vec::new(),\n            vals: Vec::new(),\n        }\n    }","Real(LocalPath(\"src/args/matched_arg.rs\"))"],"<args::settings::ArgFlags as std::default::Default>::default":["fn default() -> Self{\n        ArgFlags(Flags::EMPTY_VALS | Flags::DELIM_NOT_SET)\n    }","Real(LocalPath(\"src/args/settings.rs\"))"],"<args::settings::ArgSettings as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Self, <Self as FromStr>::Err>{\n        match &*s.to_ascii_lowercase() {\n            \"required\" => Ok(ArgSettings::Required),\n            \"multiple\" => Ok(ArgSettings::Multiple),\n            \"global\" => Ok(ArgSettings::Global),\n            \"emptyvalues\" => Ok(ArgSettings::EmptyValues),\n            \"hidden\" => Ok(ArgSettings::Hidden),\n            \"takesvalue\" => Ok(ArgSettings::TakesValue),\n            \"usevaluedelimiter\" => Ok(ArgSettings::UseValueDelimiter),\n            \"nextlinehelp\" => Ok(ArgSettings::NextLineHelp),\n            \"requiredunlessall\" => Ok(ArgSettings::RequiredUnlessAll),\n            \"requiredelimiter\" => Ok(ArgSettings::RequireDelimiter),\n            \"valuedelimiternotset\" => Ok(ArgSettings::ValueDelimiterNotSet),\n            \"hidepossiblevalues\" => Ok(ArgSettings::HidePossibleValues),\n            \"allowleadinghyphen\" => Ok(ArgSettings::AllowLeadingHyphen),\n            \"requireequals\" => Ok(ArgSettings::RequireEquals),\n            \"last\" => Ok(ArgSettings::Last),\n            \"hidedefaultvalue\" => Ok(ArgSettings::HideDefaultValue),\n            \"caseinsensitive\" => Ok(ArgSettings::CaseInsensitive),\n            \"hideenvvalues\" => Ok(ArgSettings::HideEnvValues),\n            \"hiddenshorthelp\" => Ok(ArgSettings::HiddenShortHelp),\n            \"hiddenlonghelp\" => Ok(ArgSettings::HiddenLongHelp),\n            _ => Err(\"unknown ArgSetting, cannot convert from str\".to_owned()),\n        }\n    }","Real(LocalPath(\"src/args/settings.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_TAC_VALS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::CASE_INSENSITIVE":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DELIM_NOT_SET":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::EMPTY_VALS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::GLOBAL":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN_LONG_H":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN_SHORT_H":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDE_DEFAULT_VAL":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDE_ENV_VALS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDE_POS_VALS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::LAST":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::MULTIPLE":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEXT_LINE_HELP":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::REQUIRED":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::REQUIRE_EQUALS":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::REQ_DELIM":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::R_UNLESS_ALL":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::TAKES_VAL":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::USE_DELIM":["#[$filtered]\n#[$filtered]\nbool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }\n        }\n        impl $crate::_core::fmt::Binary for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::Octal for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::LowerHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }\n        }\n        impl $crate::_core::fmt::UpperHex for $BitFlags {\n            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }\n        }\n\n        #[allow(dead_code)]\n        impl $BitFlags {\n            $(\n                $(#[$attr $($args)*])*\n                pub const $Flag: Self = Self { bits: $value };\n            )*\n\n            /// Returns an empty set of flags.\n            #[inline]\n            pub const fn empty() -> Self {\n                Self { bits: 0 }\n            }\n\n            /// Returns the set containing all flags.\n            #[inline]\n            pub const fn all() -> Self {\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }\n\n            /// Returns the raw value of the flags currently stored.\n            #[inline]\n            pub const fn bits(&self) -> $T {\n                self.bits\n            }\n\n            /// Convert from underlying bit representation, unless that\n            /// representation contains bits that do not correspond to a flag.\n            #[inline]\n            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }\n\n            /// Convert from underlying bit representation, dropping any bits\n            /// that do not correspond to flags.\n            #[inline]\n            pub const fn from_bits_truncate(bits: $T) -> Self {\n                Self { bits: bits & Self::all().bits }\n            }\n\n            /// Convert from underlying bit representation, preserving all\n            /// bits (even those not corresponding to a defined flag).\n            ///\n            /// # Safety\n            ///\n            /// The caller of the `bitflags!` macro can chose to allow or\n            /// disallow extra bits for their bitflags type.\n            ///\n            /// The caller of `from_bits_unchecked()` has to ensure that\n            /// all bits correspond to a defined flag or that extra bits\n            /// are valid for this bitflags type.\n            #[inline]\n            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n                Self { bits }\n            }\n\n            /// Returns `true` if no flags are currently stored.\n            #[inline]\n            pub const fn is_empty(&self) -> bool {\n                self.bits() == Self::empty().bits()\n            }\n\n            /// Returns `true` if all flags are currently set.\n            #[inline]\n            pub const fn is_all(&self) -> bool {\n                Self::all().bits | self.bits == self.bits\n            }\n\n            /// Returns `true` if there are flags common to both `self` and `other`.\n            #[inline]\n            pub const fn intersects(&self, other: Self) -> bool {\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }\n\n            /// Returns `true` if all of the flags in `other` are contained within `self`.\n            #[inline]\n            pub const fn contains(&self, other: Self) -> bool {\n                (self.bits & other.bits) == other.bits\n            }\n\n            /// Inserts the specified flags in-place.\n            #[inline]\n            pub fn insert(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n\n            /// Removes the specified flags in-place.\n            #[inline]\n            pub fn remove(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n\n            /// Toggles the specified flags in-place.\n            #[inline]\n            pub fn toggle(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n\n            /// Inserts or removes the specified flags depending on the passed value.\n            #[inline]\n            pub fn set(&mut self, other: Self, value: bool) {\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }\n\n            /// Returns the intersection between the flags in `self` and\n            /// `other`.\n            ///\n            /// Specifically, the returned set contains only the flags which are\n            /// present in *both* `self` *and* `other`.\n            ///\n            /// This is equivalent to using the `&` operator (e.g.\n            /// [`ops::BitAnd`]), as in `flags & other`.\n            ///\n            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n            #[inline]\n            #[must_use]\n            pub const fn intersection(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n\n            /// Returns the union of between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags which are\n            /// present in *either* `self` *or* `other`, including any which are\n            /// present in both (see [`Self::symmetric_difference`] if that\n            /// is undesirable).\n            ///\n            /// This is equivalent to using the `|` operator (e.g.\n            /// [`ops::BitOr`]), as in `flags | other`.\n            ///\n            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n            #[inline]\n            #[must_use]\n            pub const fn union(self, other: Self) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n\n            /// Returns the difference between the flags in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains all flags present in\n            /// `self`, except for the ones present in `other`.\n            ///\n            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n            /// `flags & !other` (and this syntax is also supported).\n            ///\n            /// This is equivalent to using the `-` operator (e.g.\n            /// [`ops::Sub`]), as in `flags - other`.\n            ///\n            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n            #[inline]\n            #[must_use]\n            pub const fn difference(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n\n            /// Returns the [symmetric difference][sym-diff] between the flags\n            /// in `self` and `other`.\n            ///\n            /// Specifically, the returned set contains the flags present which\n            /// are present in `self` or `other`, but that are not present in\n            /// both. Equivalently, it contains the flags present in *exactly\n            /// one* of the sets `self` and `other`.\n            ///\n            /// This is equivalent to using the `^` operator (e.g.\n            /// [`ops::BitXor`]), as in `flags ^ other`.\n            ///\n            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n            #[inline]\n            #[must_use]\n            pub const fn symmetric_difference(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n\n            /// Returns the complement of this set of flags.\n            ///\n            /// Specifically, the returned set contains all the flags which are\n            /// not set in `self`, but which are allowed for this type.\n            ///\n            /// Alternatively, it can be thought of as the set difference\n            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n            ///\n            /// This is equivalent to using the `!` operator (e.g.\n            /// [`ops::Not`]), as in `!flags`.\n            ///\n            /// [`Self::all()`]: Self::all\n            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n            #[inline]\n            #[must_use]\n            pub const fn complement(self) -> Self {\n                Self::from_bits_truncate(!self.bits)\n            }\n\n        }\n\n        impl $crate::_core::ops::BitOr for $BitFlags {\n            type Output = Self;\n\n            /// Returns the union of the two sets of flags.\n            #[inline]\n            fn bitor(self, other: $BitFlags) -> Self {\n                Self { bits: self.bits | other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitOrAssign for $BitFlags {\n            /// Adds the set of flags.\n            #[inline]\n            fn bitor_assign(&mut self, other: Self) {\n                self.bits |= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitXor for $BitFlags {\n            type Output = Self;\n\n            /// Returns the left flags, but with all the right flags toggled.\n            #[inline]\n            fn bitxor(self, other: Self) -> Self {\n                Self { bits: self.bits ^ other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitXorAssign for $BitFlags {\n            /// Toggles the set of flags.\n            #[inline]\n            fn bitxor_assign(&mut self, other: Self) {\n                self.bits ^= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::BitAnd for $BitFlags {\n            type Output = Self;\n\n            /// Returns the intersection between the two sets of flags.\n            #[inline]\n            fn bitand(self, other: Self) -> Self {\n                Self { bits: self.bits & other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::BitAndAssign for $BitFlags {\n            /// Disables all flags disabled in the set.\n            #[inline]\n            fn bitand_assign(&mut self, other: Self) {\n                self.bits &= other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Sub for $BitFlags {\n            type Output = Self;\n\n            /// Returns the set difference of the two sets of flags.\n            #[inline]\n            fn sub(self, other: Self) -> Self {\n                Self { bits: self.bits & !other.bits }\n            }\n        }\n\n        impl $crate::_core::ops::SubAssign for $BitFlags {\n            /// Disables all flags enabled in the set.\n            #[inline]\n            fn sub_assign(&mut self, other: Self) {\n                self.bits &= !other.bits;\n            }\n        }\n\n        impl $crate::_core::ops::Not for $BitFlags {\n            type Output = Self;\n\n            /// Returns the complement of this set of flags.\n            #[inline]\n            fn not(self) -> Self {\n                Self { bits: !self.bits } & Self::all()\n            }\n        }\n\n        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {\n            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                for item in iterator {\n                    self.insert(item)\n                }\n            }\n        }\n\n        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {\n            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }\n        }\n    };\n\n    // Every attribute that the user writes on a const is applied to the\n    // corresponding const that we generate, but within the implementation of\n    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n    // particular, including a #[deprecated] attribute on those items would fail\n    // to compile.\n    // https://github.com/bitflags/bitflags/issues/109\n    //\n    // Input:\n    //\n    //     ? #[cfg(feature = \"advanced\")]\n    //     ? #[deprecated(note = \"Use something else.\")]\n    //     ? #[doc = r\"High quality documentation.\"]\n    //     fn f() -> i32 { /* ... */ }\n    //\n    // Output:\n    //\n    //     #[cfg(feature = \"advanced\")]\n    //     fn f() -> i32 { /* ... */ }\n    (\n        $(#[$filtered:meta])*\n        ? #[cfg $($cfgargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            #[cfg $($cfgargs)*]\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        // $next != `cfg`\n        ? #[$next:ident $($nextargs:tt)*]\n        $(? #[$rest:ident $($restargs:tt)*])*\n        fn $($item:tt)*\n    ) => {\n        __impl_bitflags! {\n            $(#[$filtered])*\n            // $next filtered out\n            $(? #[$rest $($restargs)*])*\n            fn $($item)*\n        }\n    };\n    (\n        $(#[$filtered:meta])*\n        fn $($item:tt)*\n    ) => {\n        $(#[$filtered])*\n        fn{\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Binary>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::Binary::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                // This convoluted approach is to handle #[cfg]-based flag\n                // omission correctly. For example it needs to support:\n                //\n                //    #[cfg(unix)] const A: Flag = /* ... */;\n                //    #[cfg(windows)] const B: Flag = /* ... */;\n\n                // Unconditionally define a check for every flag, even disabled\n                // ones.\n                #[allow(non_snake_case)]\n                trait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }\n\n                // Conditionally override the check for just those flags that\n                // are not #[cfg]ed away.\n                #[allow(non_snake_case)]\n                impl __BitFlags for $BitFlags {\n                    $(\n                        __impl_bitflags! {\n                            #[allow(deprecated)]\n                            #[inline]\n                            $(? #[$attr $($args)*])*\n                            fn $Flag(&self) -> bool {\n                                if Self::$Flag.bits == 0 && self.bits != 0 {\n                                    false\n                                } else {\n                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n                                }\n                            }\n                        }\n                    )*\n                }\n\n                let mut first = true;\n                $(\n                    if <Self as __BitFlags>::$Flag(self) {\n                        if !first {\n                            f.write_str(\" | \")?;\n                        }\n                        first = false;\n                        f.write_str($crate::_core::stringify!($Flag))?;\n                    }\n                )*\n                let extra_bits = self.bits & !Self::all().bits();\n                if extra_bits != 0 {\n                    if !first {\n                        f.write_str(\" | \")?;\n                    }\n                    first = false;\n                    f.write_str(\"0x\")?;\n                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n                }\n                if first {\n                    f.write_str(\"(empty)\")?;\n                }\n                Ok(())\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags":["#[allow(non_snake_case)]\ntrait __BitFlags {\n                    $(\n                        #[inline]\n                        fn $Flag(&self) -> bool { false }\n                    )*\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_TAC_VALS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::CASE_INSENSITIVE":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DELIM_NOT_SET":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::EMPTY_VALS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::GLOBAL":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN_LONG_H":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN_SHORT_H":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDE_DEFAULT_VAL":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDE_ENV_VALS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDE_POS_VALS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::LAST":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::MULTIPLE":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEXT_LINE_HELP":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::REQUIRED":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::REQUIRE_EQUALS":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::REQ_DELIM":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::R_UNLESS_ALL":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::TAKES_VAL":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::USE_DELIM":["#[inline]\nfn $Flag(&self) -> bool{ false }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::LowerHex>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::Octal>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::Octal::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::fmt::UpperHex>::fmt":["fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result{\n                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::iter::Extend<args::settings::Flags>>::extend":["fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T){\n                for item in iterator {\n                    self.insert(item)\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::iter::FromIterator<args::settings::Flags>>::from_iter":["fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self{\n                let mut result = Self::empty();\n                result.extend(iterator);\n                result\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::ops::BitAnd>::bitand":["/// Returns the intersection between the two sets of flags.\n#[inline]\nfn bitand(self, other: Self) -> Self{\n                Self { bits: self.bits & other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::ops::BitAndAssign>::bitand_assign":["/// Disables all flags disabled in the set.\n#[inline]\nfn bitand_assign(&mut self, other: Self){\n                self.bits &= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::ops::BitOr>::bitor":["/// Returns the union of the two sets of flags.\n#[inline]\nfn bitor(self, other: $BitFlags) -> Self{\n                Self { bits: self.bits | other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::ops::BitOrAssign>::bitor_assign":["/// Adds the set of flags.\n#[inline]\nfn bitor_assign(&mut self, other: Self){\n                self.bits |= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::ops::BitXor>::bitxor":["/// Returns the left flags, but with all the right flags toggled.\n#[inline]\nfn bitxor(self, other: Self) -> Self{\n                Self { bits: self.bits ^ other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::ops::BitXorAssign>::bitxor_assign":["/// Toggles the set of flags.\n#[inline]\nfn bitxor_assign(&mut self, other: Self){\n                self.bits ^= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::ops::Not>::not":["/// Returns the complement of this set of flags.\n#[inline]\nfn not(self) -> Self{\n                Self { bits: !self.bits } & Self::all()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::ops::Sub>::sub":["/// Returns the set difference of the two sets of flags.\n#[inline]\nfn sub(self, other: Self) -> Self{\n                Self { bits: self.bits & !other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<args::settings::Flags as std::ops::SubAssign>::sub_assign":["/// Disables all flags enabled in the set.\n#[inline]\nfn sub_assign(&mut self, other: Self){\n                self.bits &= !other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"<completions::shell::Shell as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match *self {\n            Shell::Bash => write!(f, \"BASH\"),\n            Shell::Fish => write!(f, \"FISH\"),\n            Shell::Zsh => write!(f, \"ZSH\"),\n            Shell::PowerShell => write!(f, \"POWERSHELL\"),\n            Shell::Elvish => write!(f, \"ELVISH\"),\n        }\n    }","Real(LocalPath(\"src/completions/shell.rs\"))"],"<completions::shell::Shell as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Self, Self::Err>{\n        match s {\n            \"ZSH\" | _ if s.eq_ignore_ascii_case(\"zsh\") => Ok(Shell::Zsh),\n            \"FISH\" | _ if s.eq_ignore_ascii_case(\"fish\") => Ok(Shell::Fish),\n            \"BASH\" | _ if s.eq_ignore_ascii_case(\"bash\") => Ok(Shell::Bash),\n            \"POWERSHELL\" | _ if s.eq_ignore_ascii_case(\"powershell\") => Ok(Shell::PowerShell),\n            \"ELVISH\" | _ if s.eq_ignore_ascii_case(\"elvish\") => Ok(Shell::Elvish),\n            _ => Err(String::from(\n                \"[valid values: bash, fish, zsh, powershell, elvish]\",\n            )),\n        }\n    }","Real(LocalPath(\"src/completions/shell.rs\"))"],"<errors::Error as std::convert::From<std::fmt::Error>>::from":["fn from(e: std_fmt::Error) -> Self{\n        Error::with_description(e.description(), ErrorKind::Format)\n    }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::Error as std::convert::From<std::io::Error>>::from":["fn from(e: io::Error) -> Self{\n        Error::with_description(e.description(), ErrorKind::Io)\n    }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::Error as std::error::Error>::description":["fn description(&self) -> &str{\n        &*self.message\n    }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std_fmt::Formatter) -> std_fmt::Result{\n        writeln!(f, \"{}\", self.message)\n    }","Real(LocalPath(\"src/errors.rs\"))"],"<fmt::Colorizer as std::default::Default>::default":["fn default() -> Self{\n        Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: ColorWhen::Auto,\n        })\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"<fmt::Format<T> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"{}\", &self.format())\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"<osstringext::OsSplit<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a OsStr>{\n        debugln!(\"OsSplit::next: self={:?}\", self);\n        if self.pos == self.val.len() {\n            return None;\n        }\n        let start = self.pos;\n        for b in &self.val[start..] {\n            self.pos += 1;\n            if *b == self.sep {\n                return Some(OsStr::from_bytes(&self.val[start..self.pos - 1]));\n            }\n        }\n        Some(OsStr::from_bytes(&self.val[start..]))\n    }","Real(LocalPath(\"src/osstringext.rs\"))"],"<std::ffi::OsStr as osstringext::OsStrExt2>::contains_byte":["fn contains_byte(&self, byte: u8) -> bool{\n        for b in self.as_bytes() {\n            if b == &byte {\n                return true;\n            }\n        }\n        false\n    }","Real(LocalPath(\"src/osstringext.rs\"))"],"<std::ffi::OsStr as osstringext::OsStrExt2>::split":["fn split(&self, b: u8) -> OsSplit{\n        OsSplit {\n            sep: b,\n            val: self.as_bytes(),\n            pos: 0,\n        }\n    }","Real(LocalPath(\"src/osstringext.rs\"))"],"<std::ffi::OsStr as osstringext::OsStrExt2>::split_at":["fn split_at(&self, i: usize) -> (&OsStr, &OsStr){\n        (\n            OsStr::from_bytes(&self.as_bytes()[..i]),\n            OsStr::from_bytes(&self.as_bytes()[i..]),\n        )\n    }","Real(LocalPath(\"src/osstringext.rs\"))"],"<std::ffi::OsStr as osstringext::OsStrExt2>::split_at_byte":["fn split_at_byte(&self, byte: u8) -> (&OsStr, &OsStr){\n        for (i, b) in self.as_bytes().iter().enumerate() {\n            if b == &byte {\n                return (\n                    OsStr::from_bytes(&self.as_bytes()[..i]),\n                    OsStr::from_bytes(&self.as_bytes()[i + 1..]),\n                );\n            }\n        }\n        (\n            &*self,\n            OsStr::from_bytes(&self.as_bytes()[self.len()..self.len()]),\n        )\n    }","Real(LocalPath(\"src/osstringext.rs\"))"],"<std::ffi::OsStr as osstringext::OsStrExt2>::starts_with":["fn starts_with(&self, s: &[u8]) -> bool{\n        #[cfg(target_os = \"windows\")]\n        {\n            // On Windows, the as_bytes() method will panic if the OsStr\n            // contains invalid Unicode. To avoid this, we use a\n            // Windows-specific starts-with function that doesn't rely on\n            // as_bytes(). This is necessary for Windows command line\n            // applications to handle non-Unicode arguments successfully. This\n            // allows common cases like `clap.exe [invalid]` to succeed, though\n            // cases that require string splitting will still fail, like\n            // `clap.exe --arg=[invalid]`. Note that this entire module is\n            // replaced in Clap 3.x, so this workaround is specific to the 2.x\n            // branch.\n            return windows_osstr_starts_with(self, s);\n        }\n        self.as_bytes().starts_with(s)\n    }","Real(LocalPath(\"src/osstringext.rs\"))"],"<std::ffi::OsStr as osstringext::OsStrExt2>::trim_left_matches":["fn trim_left_matches(&self, byte: u8) -> &OsStr{\n        let mut found = false;\n        for (i, b) in self.as_bytes().iter().enumerate() {\n            if b != &byte {\n                return OsStr::from_bytes(&self.as_bytes()[i..]);\n            } else {\n                found = true;\n            }\n        }\n        if found {\n            return OsStr::from_bytes(&self.as_bytes()[self.len()..]);\n        }\n        &*self\n    }","Real(LocalPath(\"src/osstringext.rs\"))"],"<str as strext::_StrExt>::_is_char_boundary":["#[inline]\nfn _is_char_boundary(&self, index: usize) -> bool{\n        if index == self.len() {\n            return true;\n        }\n        match self.as_bytes().get(index) {\n            None => false,\n            Some(&b) => b < 128 || b >= 192,\n        }\n    }","Real(LocalPath(\"src/strext.rs\"))"],"app::App":["/// Used to create a representation of a command line program and all possible command line\n/// arguments. Application settings are set using the \"builder pattern\" with the\n/// [`App::get_matches`] family of methods being the terminal methods that starts the\n/// runtime-parsing process. These methods then return information about the user supplied\n/// arguments (or lack there of).\n///\n/// **NOTE:** There aren't any mandatory \"options\" that one must set. The \"options\" may\n/// also appear in any order (so long as one of the [`App::get_matches`] methods is the last method\n/// called).\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// let m = App::new(\"My Program\")\n///     .author(\"Me, me@mail.com\")\n///     .version(\"1.0.2\")\n///     .about(\"Explains in brief what the program does\")\n///     .arg(\n///         Arg::with_name(\"in_file\").index(1)\n///     )\n///     .after_help(\"Longer explanation to appear after the options when \\\n///                  displaying the help information from --help or -h\")\n///     .get_matches();\n///\n/// // Your program logic starts here...\n/// ```\n/// [`App::get_matches`]: ./struct.App.html#method.get_matches\n#[allow(missing_debug_implementations)]\npub struct App<'a, 'b>\nwhere\n    'a: 'b,\n{\n    #[doc(hidden)]\n    pub p: Parser<'a, 'b>,\n}","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::about":["/// Sets a string describing what the program does. This will be displayed when displaying help\n/// information with `-h`.\n///\n/// **NOTE:** If only `about` is provided, and not [`App::long_about`] but the user requests\n/// `--help` clap will still display the contents of `about` appropriately\n///\n/// **NOTE:** Only [`App::about`] is used in completion script generation in order to be\n/// concise\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .about(\"Does really amazing things to great people\")\n/// # ;\n/// ```\n/// [`App::long_about`]: ./struct.App.html#method.long_about\npub fn about<S: Into<&'b str>>(mut self, about: S) -> Self{\n        self.p.meta.about = Some(about.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::after_help":["/// Adds additional help information to be displayed in addition to auto-generated help. This\n/// information is displayed **after** the auto-generated help information. This is often used\n/// to describe how to use the arguments, or caveats to be noted.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::App;\n/// App::new(\"myprog\")\n///     .after_help(\"Does really amazing things to great people...but be careful with -R\")\n/// # ;\n/// ```\npub fn after_help<S: Into<&'b str>>(mut self, help: S) -> Self{\n        self.p.meta.more_help = Some(help.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::alias":["/// Allows adding a [`SubCommand`] alias, which function as \"hidden\" subcommands that\n/// automatically dispatch as if this subcommand was used. This is more efficient, and easier\n/// than creating multiple hidden subcommands as one only needs to check for the existence of\n/// this command, and not all variants.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg, SubCommand};\n/// let m = App::new(\"myprog\")\n///             .subcommand(SubCommand::with_name(\"test\")\n///                 .alias(\"do-stuff\"))\n///             .get_matches_from(vec![\"myprog\", \"do-stuff\"]);\n/// assert_eq!(m.subcommand_name(), Some(\"test\"));\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\npub fn alias<S: Into<&'b str>>(mut self, name: S) -> Self{\n        if let Some(ref mut als) = self.p.meta.aliases {\n            als.push((name.into(), false));\n        } else {\n            self.p.meta.aliases = Some(vec![(name.into(), false)]);\n        }\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::aliases":["/// Allows adding [`SubCommand`] aliases, which function as \"hidden\" subcommands that\n/// automatically dispatch as if this subcommand was used. This is more efficient, and easier\n/// than creating multiple hidden subcommands as one only needs to check for the existence of\n/// this command, and not all variants.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, SubCommand};\n/// let m = App::new(\"myprog\")\n///             .subcommand(SubCommand::with_name(\"test\")\n///                 .aliases(&[\"do-stuff\", \"do-tests\", \"tests\"]))\n///                 .arg(Arg::with_name(\"input\")\n///                             .help(\"the file to add\")\n///                             .index(1)\n///                             .required(false))\n///             .get_matches_from(vec![\"myprog\", \"do-tests\"]);\n/// assert_eq!(m.subcommand_name(), Some(\"test\"));\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\npub fn aliases(mut self, names: &[&'b str]) -> Self{\n        if let Some(ref mut als) = self.p.meta.aliases {\n            for n in names {\n                als.push((n, false));\n            }\n        } else {\n            self.p.meta.aliases = Some(names.iter().map(|n| (*n, false)).collect::<Vec<_>>());\n        }\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::arg":["/// Adds an [argument] to the list of valid possibilities.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     // Adding a single \"flag\" argument with a short and help text, using Arg::with_name()\n///     .arg(\n///         Arg::with_name(\"debug\")\n///            .short(\"d\")\n///            .help(\"turns on debugging mode\")\n///     )\n///     // Adding a single \"option\" argument with a short, a long, and help text using the less\n///     // verbose Arg::from_usage()\n///     .arg(\n///         Arg::from_usage(\"-c --config=[CONFIG] 'Optionally sets a config file to use'\")\n///     )\n/// # ;\n/// ```\n/// [argument]: ./struct.Arg.html\npub fn arg<A: Into<Arg<'a, 'b>>>(mut self, a: A) -> Self{\n        self.p.add_arg(a.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::arg_from_usage":["/// A convenience method for adding a single [argument] from a usage type string. The string\n/// used follows the same rules and syntax as [`Arg::from_usage`]\n///\n/// **NOTE:** The downside to using this method is that you can not set any additional\n/// properties of the [`Arg`] other than what [`Arg::from_usage`] supports.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .arg_from_usage(\"-c --config=<FILE> 'Sets a configuration file to use'\")\n/// # ;\n/// ```\n/// [argument]: ./struct.Arg.html\n/// [`Arg`]: ./struct.Arg.html\n/// [`Arg::from_usage`]: ./struct.Arg.html#method.from_usage\npub fn arg_from_usage(mut self, usage: &'a str) -> Self{\n        self.p.add_arg(Arg::from_usage(usage));\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::args":["/// Adds multiple [arguments] to the list of valid possibilities\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .args(\n///         &[Arg::from_usage(\"[debug] -d 'turns on debugging info'\"),\n///          Arg::with_name(\"input\").index(1).help(\"the input file to use\")]\n///     )\n/// # ;\n/// ```\n/// [arguments]: ./struct.Arg.html\npub fn args(mut self, args: &[Arg<'a, 'b>]) -> Self{\n        for arg in args {\n            self.p.add_arg_ref(arg);\n        }\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::args_from_usage":["/// Adds multiple [arguments] at once from a usage string, one per line. See\n/// [`Arg::from_usage`] for details on the syntax and rules supported.\n///\n/// **NOTE:** Like [`App::arg_from_usage`] the downside is you only set properties for the\n/// [`Arg`]s which [`Arg::from_usage`] supports.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .args_from_usage(\n///         \"-c --config=[FILE] 'Sets a configuration file to use'\n///          [debug]... -d 'Sets the debugging level'\n///          <FILE> 'The input file to use'\"\n///     )\n/// # ;\n/// ```\n/// [arguments]: ./struct.Arg.html\n/// [`Arg::from_usage`]: ./struct.Arg.html#method.from_usage\n/// [`App::arg_from_usage`]: ./struct.App.html#method.arg_from_usage\n/// [`Arg`]: ./struct.Arg.html\npub fn args_from_usage(mut self, usage: &'a str) -> Self{\n        for line in usage.lines() {\n            let l = line.trim();\n            if l.is_empty() {\n                continue;\n            }\n            self.p.add_arg(Arg::from_usage(l));\n        }\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::author":["/// Sets a string of author(s) that will be displayed to the user when they\n/// request the help information with `--help` or `-h`.\n///\n/// **Pro-tip:** Use `clap`s convenience macro [`crate_authors!`] to automatically set your\n/// application's author(s) to the same thing as your crate at compile time. See the [`examples/`]\n/// directory for more information\n///\n/// See the [`examples/`]\n/// directory for more information\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///      .author(\"Me, me@mymain.com\")\n/// # ;\n/// ```\n/// [`crate_authors!`]: ./macro.crate_authors!.html\n/// [`examples/`]: https://github.com/clap-rs/clap/tree/v2.33.1/examples\npub fn author<S: Into<&'b str>>(mut self, author: S) -> Self{\n        self.p.meta.author = Some(author.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::before_help":["/// Adds additional help information to be displayed in addition to auto-generated help. This\n/// information is displayed **before** the auto-generated help information. This is often used\n/// for header information.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::App;\n/// App::new(\"myprog\")\n///     .before_help(\"Some info I'd like to appear before the help info\")\n/// # ;\n/// ```\npub fn before_help<S: Into<&'b str>>(mut self, help: S) -> Self{\n        self.p.meta.pre_help = Some(help.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::bin_name":["/// Overrides the system-determined binary name. This should only be used when absolutely\n/// necessary, such as when the binary name for your application is misleading, or perhaps\n/// *not* how the user should invoke your program.\n///\n/// **Pro-tip:** When building things such as third party `cargo` subcommands, this setting\n/// **should** be used!\n///\n/// **NOTE:** This command **should not** be used for [`SubCommand`]s.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"My Program\")\n///      .bin_name(\"my_binary\")\n/// # ;\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\npub fn bin_name<S: Into<String>>(mut self, name: S) -> Self{\n        self.p.meta.bin_name = Some(name.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::display_order":["/// Allows custom ordering of [`SubCommand`]s within the help message. Subcommands with a lower\n/// value will be displayed first in the help message. This is helpful when one would like to\n/// emphasise frequently used subcommands, or prioritize those towards the top of the list.\n/// Duplicate values **are** allowed. Subcommands with duplicate display orders will be\n/// displayed in alphabetical order.\n///\n/// **NOTE:** The default is 999 for all subcommands.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, SubCommand};\n/// let m = App::new(\"cust-ord\")\n///     .subcommand(SubCommand::with_name(\"alpha\") // typically subcommands are grouped\n///                                                // alphabetically by name. Subcommands\n///                                                // without a display_order have a value of\n///                                                // 999 and are displayed alphabetically with\n///                                                // all other 999 subcommands\n///         .about(\"Some help and text\"))\n///     .subcommand(SubCommand::with_name(\"beta\")\n///         .display_order(1)   // In order to force this subcommand to appear *first*\n///                             // all we have to do is give it a value lower than 999.\n///                             // Any other subcommands with a value of 1 will be displayed\n///                             // alphabetically with this one...then 2 values, then 3, etc.\n///         .about(\"I should be first!\"))\n///     .get_matches_from(vec![\n///         \"cust-ord\", \"--help\"\n///     ]);\n/// ```\n///\n/// The above example displays the following help message\n///\n/// ```text\n/// cust-ord\n///\n/// USAGE:\n///     cust-ord [FLAGS] [OPTIONS]\n///\n/// FLAGS:\n///     -h, --help       Prints help information\n///     -V, --version    Prints version information\n///\n/// SUBCOMMANDS:\n///     beta    I should be first!\n///     alpha   Some help and text\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\npub fn display_order(mut self, ord: usize) -> Self{\n        self.p.meta.disp_ord = ord;\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::gen_completions":["/// Generate a completions file for a specified shell at compile time.\n///\n/// **NOTE:** to generate the file at compile time you must use a `build.rs` \"Build Script\"\n///\n/// # Examples\n///\n/// The following example generates a bash completion script via a `build.rs` script. In this\n/// simple example, we'll demo a very small application with only a single subcommand and two\n/// args. Real applications could be many multiple levels deep in subcommands, and have tens or\n/// potentially hundreds of arguments.\n///\n/// First, it helps if we separate out our `App` definition into a separate file. Whether you\n/// do this as a function, or bare App definition is a matter of personal preference.\n///\n/// ```\n/// // src/cli.rs\n///\n/// use clap::{App, Arg, SubCommand};\n///\n/// pub fn build_cli() -> App<'static, 'static> {\n///     App::new(\"compl\")\n///         .about(\"Tests completions\")\n///         .arg(Arg::with_name(\"file\")\n///             .help(\"some input file\"))\n///         .subcommand(SubCommand::with_name(\"test\")\n///             .about(\"tests things\")\n///             .arg(Arg::with_name(\"case\")\n///                 .long(\"case\")\n///                 .takes_value(true)\n///                 .help(\"the case to test\")))\n/// }\n/// ```\n///\n/// In our regular code, we can simply call this `build_cli()` function, then call\n/// `get_matches()`, or any of the other normal methods directly after. For example:\n///\n/// ```ignore\n/// // src/main.rs\n///\n/// mod cli;\n///\n/// fn main() {\n///     let m = cli::build_cli().get_matches();\n///\n///     // normal logic continues...\n/// }\n/// ```\n///\n/// Next, we set up our `Cargo.toml` to use a `build.rs` build script.\n///\n/// ```toml\n/// # Cargo.toml\n/// build = \"build.rs\"\n///\n/// [build-dependencies]\n/// clap = \"2.23\"\n/// ```\n///\n/// Next, we place a `build.rs` in our project root.\n///\n/// ```ignore\n/// extern crate clap;\n///\n/// use clap::Shell;\n///\n/// include!(\"src/cli.rs\");\n///\n/// fn main() {\n///     let outdir = match env::var_os(\"OUT_DIR\") {\n///         None => return,\n///         Some(outdir) => outdir,\n///     };\n///     let mut app = build_cli();\n///     app.gen_completions(\"myapp\",      // We need to specify the bin name manually\n///                         Shell::Bash,  // Then say which shell to build completions for\n///                         outdir);      // Then say where write the completions to\n/// }\n/// ```\n/// Now, once we compile there will be a `{bin_name}.bash` file in the directory.\n/// Assuming we compiled with debug mode, it would be somewhere similar to\n/// `<project>/target/debug/build/myapp-<hash>/out/myapp.bash`.\n///\n/// Fish shell completions will use the file format `{bin_name}.fish`\npub fn gen_completions<T: Into<OsString>, S: Into<String>>(\n        &mut self,\n        bin_name: S,\n        for_shell: Shell,\n        out_dir: T,\n    ){\n        self.p.meta.bin_name = Some(bin_name.into());\n        self.p.gen_completions(for_shell, out_dir.into());\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::gen_completions_to":["/// Generate a completions file for a specified shell at runtime.  Until `cargo install` can\n/// install extra files like a completion script, this may be used e.g. in a command that\n/// outputs the contents of the completion script, to be redirected into a file by the user.\n///\n/// # Examples\n///\n/// Assuming a separate `cli.rs` like the [example above](./struct.App.html#method.gen_completions),\n/// we can let users generate a completion script using a command:\n///\n/// ```ignore\n/// // src/main.rs\n///\n/// mod cli;\n/// use std::io;\n///\n/// fn main() {\n///     let matches = cli::build_cli().get_matches();\n///\n///     if matches.is_present(\"generate-bash-completions\") {\n///         cli::build_cli().gen_completions_to(\"myapp\", Shell::Bash, &mut io::stdout());\n///     }\n///\n///     // normal logic continues...\n/// }\n///\n/// ```\n///\n/// Usage:\n///\n/// ```shell\n/// $ myapp generate-bash-completions > /usr/share/bash-completion/completions/myapp.bash\n/// ```\npub fn gen_completions_to<W: Write, S: Into<String>>(\n        &mut self,\n        bin_name: S,\n        for_shell: Shell,\n        buf: &mut W,\n    ){\n        self.p.meta.bin_name = Some(bin_name.into());\n        self.p.gen_completions_to(for_shell, buf);\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::get_bin_name":["/// Get the name of the binary\npub fn get_bin_name(&self) -> Option<&str>{\n        self.p.meta.bin_name.as_ref().map(|s| s.as_str())\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::get_matches":["/// Starts the parsing process, upon a failed parse an error will be displayed to the user and\n/// the process will exit with the appropriate error code. By default this method gets all user\n/// provided arguments from [`env::args_os`] in order to allow for invalid UTF-8 code points,\n/// which are legal on many platforms.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// let matches = App::new(\"myprog\")\n///     // Args and options go here...\n///     .get_matches();\n/// ```\n/// [`env::args_os`]: https://doc.rust-lang.org/std/env/fn.args_os.html\npub fn get_matches(self) -> ArgMatches<'a>{\n        self.get_matches_from(&mut env::args_os())\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::get_matches_from":["/// Starts the parsing process. Like [`App::get_matches`] this method does not return a [`clap::Result`]\n/// and will automatically exit with an error message. This method, however, lets you specify\n/// what iterator to use when performing matches, such as a [`Vec`] of your making.\n///\n/// **NOTE:** The first argument will be parsed as the binary name unless\n/// [`AppSettings::NoBinaryName`] is used\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// let arg_vec = vec![\"my_prog\", \"some\", \"args\", \"to\", \"parse\"];\n///\n/// let matches = App::new(\"myprog\")\n///     // Args and options go here...\n///     .get_matches_from(arg_vec);\n/// ```\n/// [`App::get_matches`]: ./struct.App.html#method.get_matches\n/// [`clap::Result`]: ./type.Result.html\n/// [`Vec`]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n/// [`AppSettings::NoBinaryName`]: ./enum.AppSettings.html#variant.NoBinaryName\npub fn get_matches_from<I, T>(mut self, itr: I) -> ArgMatches<'a>\n    where\n        I: IntoIterator<Item = T>,\n        T: Into<OsString> + Clone,{\n        self.get_matches_from_safe_borrow(itr).unwrap_or_else(|e| {\n            // Otherwise, write to stderr and exit\n            if e.use_stderr() {\n                wlnerr!(\"{}\", e.message);\n                if self.p.is_set(AppSettings::WaitOnError) {\n                    wlnerr!(\"\\nPress [ENTER] / [RETURN] to continue...\");\n                    let mut s = String::new();\n                    let i = io::stdin();\n                    i.lock().read_line(&mut s).unwrap();\n                }\n                drop(self);\n                drop(e);\n                process::exit(1);\n            }\n\n            drop(self);\n            e.exit()\n        })\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::get_matches_from_safe":["/// Starts the parsing process. A combination of [`App::get_matches_from`], and\n/// [`App::get_matches_safe`]\n///\n/// **NOTE:** This method WILL NOT exit when `--help` or `--version` (or short versions) are\n/// used. It will return a [`clap::Error`], where the [`kind`] is a [`ErrorKind::HelpDisplayed`]\n/// or [`ErrorKind::VersionDisplayed`] respectively. You must call [`Error::exit`] or\n/// perform a [`std::process::exit`] yourself.\n///\n/// **NOTE:** The first argument will be parsed as the binary name unless\n/// [`AppSettings::NoBinaryName`] is used\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// let arg_vec = vec![\"my_prog\", \"some\", \"args\", \"to\", \"parse\"];\n///\n/// let matches = App::new(\"myprog\")\n///     // Args and options go here...\n///     .get_matches_from_safe(arg_vec)\n///     .unwrap_or_else( |e| { panic!(\"An error occurs: {}\", e) });\n/// ```\n/// [`App::get_matches_from`]: ./struct.App.html#method.get_matches_from\n/// [`App::get_matches_safe`]: ./struct.App.html#method.get_matches_safe\n/// [`ErrorKind::HelpDisplayed`]: ./enum.ErrorKind.html#variant.HelpDisplayed\n/// [`ErrorKind::VersionDisplayed`]: ./enum.ErrorKind.html#variant.VersionDisplayed\n/// [`Error::exit`]: ./struct.Error.html#method.exit\n/// [`std::process::exit`]: https://doc.rust-lang.org/std/process/fn.exit.html\n/// [`clap::Error`]: ./struct.Error.html\n/// [`Error::exit`]: ./struct.Error.html#method.exit\n/// [`kind`]: ./struct.Error.html\n/// [`AppSettings::NoBinaryName`]: ./enum.AppSettings.html#variant.NoBinaryName\npub fn get_matches_from_safe<I, T>(mut self, itr: I) -> ClapResult<ArgMatches<'a>>\n    where\n        I: IntoIterator<Item = T>,\n        T: Into<OsString> + Clone,{\n        self.get_matches_from_safe_borrow(itr)\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::get_matches_from_safe_borrow":["/// Starts the parsing process without consuming the [`App`] struct `self`. This is normally not\n/// the desired functionality, instead prefer [`App::get_matches_from_safe`] which *does*\n/// consume `self`.\n///\n/// **NOTE:** The first argument will be parsed as the binary name unless\n/// [`AppSettings::NoBinaryName`] is used\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// let arg_vec = vec![\"my_prog\", \"some\", \"args\", \"to\", \"parse\"];\n///\n/// let mut app = App::new(\"myprog\");\n///     // Args and options go here...\n/// let matches = app.get_matches_from_safe_borrow(arg_vec)\n///     .unwrap_or_else( |e| { panic!(\"An error occurs: {}\", e) });\n/// ```\n/// [`App`]: ./struct.App.html\n/// [`App::get_matches_from_safe`]: ./struct.App.html#method.get_matches_from_safe\n/// [`AppSettings::NoBinaryName`]: ./enum.AppSettings.html#variant.NoBinaryName\npub fn get_matches_from_safe_borrow<I, T>(&mut self, itr: I) -> ClapResult<ArgMatches<'a>>\n    where\n        I: IntoIterator<Item = T>,\n        T: Into<OsString> + Clone,{\n        // If there are global arguments, or settings we need to propagate them down to subcommands\n        // before parsing incase we run into a subcommand\n        if !self.p.is_set(AppSettings::Propagated) {\n            self.p.propagate_globals();\n            self.p.propagate_settings();\n            self.p.derive_display_order();\n            self.p.set(AppSettings::Propagated);\n        }\n\n        let mut matcher = ArgMatcher::new();\n\n        let mut it = itr.into_iter();\n        // Get the name of the program (argument 1 of env::args()) and determine the\n        // actual file\n        // that was used to execute the program. This is because a program called\n        // ./target/release/my_prog -a\n        // will have two arguments, './target/release/my_prog', '-a' but we don't want\n        // to display\n        // the full path when displaying help messages and such\n        if !self.p.is_set(AppSettings::NoBinaryName) {\n            if let Some(name) = it.next() {\n                let bn_os = name.into();\n                let p = Path::new(&*bn_os);\n                if let Some(f) = p.file_name() {\n                    if let Some(s) = f.to_os_string().to_str() {\n                        if self.p.meta.bin_name.is_none() {\n                            self.p.meta.bin_name = Some(s.to_owned());\n                        }\n                    }\n                }\n            }\n        }\n\n        // do the real parsing\n        if let Err(e) = self.p.get_matches_with(&mut matcher, &mut it.peekable()) {\n            return Err(e);\n        }\n\n        let global_arg_vec: Vec<&str> = (&self).p.global_args.iter().map(|ga| ga.b.name).collect();\n        matcher.propagate_globals(&global_arg_vec);\n\n        Ok(matcher.into())\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::get_matches_safe":["/// Starts the parsing process. This method will return a [`clap::Result`] type instead of exiting\n/// the process on failed parse. By default this method gets matches from [`env::args_os`]\n///\n/// **NOTE:** This method WILL NOT exit when `--help` or `--version` (or short versions) are\n/// used. It will return a [`clap::Error`], where the [`kind`] is a\n/// [`ErrorKind::HelpDisplayed`] or [`ErrorKind::VersionDisplayed`] respectively. You must call\n/// [`Error::exit`] or perform a [`std::process::exit`].\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// let matches = App::new(\"myprog\")\n///     // Args and options go here...\n///     .get_matches_safe()\n///     .unwrap_or_else( |e| e.exit() );\n/// ```\n/// [`env::args_os`]: https://doc.rust-lang.org/std/env/fn.args_os.html\n/// [`ErrorKind::HelpDisplayed`]: ./enum.ErrorKind.html#variant.HelpDisplayed\n/// [`ErrorKind::VersionDisplayed`]: ./enum.ErrorKind.html#variant.VersionDisplayed\n/// [`Error::exit`]: ./struct.Error.html#method.exit\n/// [`std::process::exit`]: https://doc.rust-lang.org/std/process/fn.exit.html\n/// [`clap::Result`]: ./type.Result.html\n/// [`clap::Error`]: ./struct.Error.html\n/// [`kind`]: ./struct.Error.html\npub fn get_matches_safe(self) -> ClapResult<ArgMatches<'a>>{\n        // Start the parsing\n        self.get_matches_from_safe(&mut env::args_os())\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::get_name":["/// Get the name of the app\npub fn get_name(&self) -> &str{\n        &self.p.meta.name\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::global_setting":["/// Enables a single setting that is propagated down through all child [`SubCommand`]s.\n///\n/// See [`AppSettings`] for a full list of possibilities and examples.\n///\n/// **NOTE**: The setting is *only* propagated *down* and not up through parent commands.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg, AppSettings};\n/// App::new(\"myprog\")\n///     .global_setting(AppSettings::SubcommandRequired)\n/// # ;\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [`AppSettings`]: ./enum.AppSettings.html\npub fn global_setting(mut self, setting: AppSettings) -> Self{\n        self.p.set(setting);\n        self.p.g_settings.set(setting);\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::global_settings":["/// Enables multiple settings which are propagated *down* through all child [`SubCommand`]s.\n///\n/// See [`AppSettings`] for a full list of possibilities and examples.\n///\n/// **NOTE**: The setting is *only* propagated *down* and not up through parent commands.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg, AppSettings};\n/// App::new(\"myprog\")\n///     .global_settings(&[AppSettings::SubcommandRequired,\n///                  AppSettings::ColoredHelp])\n/// # ;\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [`AppSettings`]: ./enum.AppSettings.html\npub fn global_settings(mut self, settings: &[AppSettings]) -> Self{\n        for s in settings {\n            self.p.set(*s);\n            self.p.g_settings.set(*s)\n        }\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::group":["/// Adds an [`ArgGroup`] to the application. [`ArgGroup`]s are a family of related arguments.\n/// By placing them in a logical group, you can build easier requirement and exclusion rules.\n/// For instance, you can make an entire [`ArgGroup`] required, meaning that one (and *only*\n/// one) argument from that group must be present at runtime.\n///\n/// You can also do things such as name an [`ArgGroup`] as a conflict to another argument.\n/// Meaning any of the arguments that belong to that group will cause a failure if present with\n/// the conflicting argument.\n///\n/// Another added benefit of [`ArgGroup`]s is that you can extract a value from a group instead\n/// of determining exactly which argument was used.\n///\n/// Finally, using [`ArgGroup`]s to ensure exclusion between arguments is another very common\n/// use\n///\n/// # Examples\n///\n/// The following example demonstrates using an [`ArgGroup`] to ensure that one, and only one,\n/// of the arguments from the specified group is present at runtime.\n///\n/// ```no_run\n/// # use clap::{App, ArgGroup};\n/// App::new(\"app\")\n///     .args_from_usage(\n///         \"--set-ver [ver] 'set the version manually'\n///          --major         'auto increase major'\n///          --minor         'auto increase minor'\n///          --patch         'auto increase patch'\")\n///     .group(ArgGroup::with_name(\"vers\")\n///          .args(&[\"set-ver\", \"major\", \"minor\",\"patch\"])\n///          .required(true))\n/// # ;\n/// ```\n/// [`ArgGroup`]: ./struct.ArgGroup.html\npub fn group(mut self, group: ArgGroup<'a>) -> Self{\n        self.p.add_group(group);\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::groups":["/// Adds multiple [`ArgGroup`]s to the [`App`] at once.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, ArgGroup};\n/// App::new(\"app\")\n///     .args_from_usage(\n///         \"--set-ver [ver] 'set the version manually'\n///          --major         'auto increase major'\n///          --minor         'auto increase minor'\n///          --patch         'auto increase patch'\n///          -c [FILE]       'a config file'\n///          -i [IFACE]      'an interface'\")\n///     .groups(&[\n///         ArgGroup::with_name(\"vers\")\n///             .args(&[\"set-ver\", \"major\", \"minor\",\"patch\"])\n///             .required(true),\n///         ArgGroup::with_name(\"input\")\n///             .args(&[\"c\", \"i\"])\n///     ])\n/// # ;\n/// ```\n/// [`ArgGroup`]: ./struct.ArgGroup.html\n/// [`App`]: ./struct.App.html\npub fn groups(mut self, groups: &[ArgGroup<'a>]) -> Self{\n        for g in groups {\n            self = self.group(g.into());\n        }\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::help":["/// Sets a custom help message and overrides the auto-generated one. This should only be used\n/// when the auto-generated message does not suffice.\n///\n/// This will be displayed to the user when they use `--help` or `-h`\n///\n/// **NOTE:** This replaces the **entire** help message, so nothing will be auto-generated.\n///\n/// **NOTE:** This **only** replaces the help message for the current command, meaning if you\n/// are using subcommands, those help messages will still be auto-generated unless you\n/// specify a [`Arg::help`] for them as well.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myapp\")\n///     .help(\"myapp v1.0\\n\\\n///            Does awesome things\\n\\\n///            (C) me@mail.com\\n\\n\\\n///\n///            USAGE: myapp <opts> <command>\\n\\n\\\n///\n///            Options:\\n\\\n///            -h, --help       Display this message\\n\\\n///            -V, --version    Display version info\\n\\\n///            -s <stuff>       Do something with stuff\\n\\\n///            -v               Be verbose\\n\\n\\\n///\n///            Commmands:\\n\\\n///            help             Prints this message\\n\\\n///            work             Do some work\")\n/// # ;\n/// ```\n/// [`Arg::help`]: ./struct.Arg.html#method.help\npub fn help<S: Into<&'b str>>(mut self, help: S) -> Self{\n        self.p.meta.help_str = Some(help.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::help_message":["/// Sets the help text for the auto-generated `help` argument.\n///\n/// By default `clap` sets this to `\"Prints help information\"`, but if you're using a\n/// different convention for your help messages and would prefer a different phrasing you can\n/// override it.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .help_message(\"Print help information\") // Perhaps you want imperative help messages\n///\n/// # ;\n/// ```\npub fn help_message<S: Into<&'a str>>(mut self, s: S) -> Self{\n        self.p.help_message = Some(s.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::help_short":["/// Sets the [`short`] for the auto-generated `help` argument.\n///\n/// By default `clap` automatically assigns `h`, but this can be overridden if you have a\n/// different argument which you'd prefer to use the `-h` short with. This can be done by\n/// defining your own argument with a lowercase `h` as the [`short`].\n///\n/// `clap` lazily generates these `help` arguments **after** you've defined any arguments of\n/// your own.\n///\n/// **NOTE:** Any leading `-` characters will be stripped, and only the first\n/// non `-` character will be used as the [`short`] version\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .help_short(\"H\") // Using an uppercase `H` instead of the default lowercase `h`\n/// # ;\n/// ```\n/// [`short`]: ./struct.Arg.html#method.short\npub fn help_short<S: AsRef<str> + 'b>(mut self, s: S) -> Self{\n        self.p.help_short(s.as_ref());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::long_about":["/// Sets a string describing what the program does. This will be displayed when displaying help\n/// information.\n///\n/// **NOTE:** If only `long_about` is provided, and not [`App::about`] but the user requests\n/// `-h` clap will still display the contents of `long_about` appropriately\n///\n/// **NOTE:** Only [`App::about`] is used in completion script generation in order to be\n/// concise\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .long_about(\n/// \"Does really amazing things to great people. Now let's talk a little\n///  more in depth about how this subcommand really works. It may take about\n///  a few lines of text, but that's ok!\")\n/// # ;\n/// ```\n/// [`App::about`]: ./struct.App.html#method.about\npub fn long_about<S: Into<&'b str>>(mut self, about: S) -> Self{\n        self.p.meta.long_about = Some(about.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::long_version":["/// Sets a string of the version number to be displayed when displaying version or help\n/// information with `--version`.\n///\n/// **NOTE:** If only `long_version` is provided, and not [`App::version`] but the user\n/// requests `-V` clap will still display the contents of `long_version` appropriately\n///\n/// **Pro-tip:** Use `clap`s convenience macro [`crate_version!`] to automatically set your\n/// application's version to the same thing as your crate at compile time. See the [`examples/`]\n/// directory for more information\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .long_version(\n/// \"v0.1.24\n///  commit: abcdef89726d\n///  revision: 123\n///  release: 2\n///  binary: myprog\")\n/// # ;\n/// ```\n/// [`crate_version!`]: ./macro.crate_version!.html\n/// [`examples/`]: https://github.com/clap-rs/clap/tree/v2.33.1/examples\n/// [`App::version`]: ./struct.App.html#method.version\npub fn long_version<S: Into<&'b str>>(mut self, ver: S) -> Self{\n        self.p.meta.long_version = Some(ver.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::max_term_width":["/// Sets the max terminal width at which to wrap help messages. Using `0` will ignore terminal\n/// widths and use source formatting.\n///\n/// `clap` automatically tries to determine the terminal width on Unix, Linux, macOS and Windows\n/// if the `wrap_help` cargo \"feature\" has been used while compiling, but one might want to\n/// limit the size (e.g. when the terminal is running fullscreen).\n///\n/// **NOTE:** This setting applies globally and *not* on a per-command basis.\n///\n/// **NOTE:** This setting must be set **before** any subcommands are added!\n///\n/// # Platform Specific\n///\n/// Only Unix, Linux, macOS and Windows support automatic determination of terminal width.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::App;\n/// App::new(\"myprog\")\n///     .max_term_width(100)\n/// # ;\n/// ```\npub fn max_term_width(mut self, w: usize) -> Self{\n        self.p.meta.max_w = Some(w);\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::name":["/// Sets the program's name. This will be displayed when displaying help information.\n///\n/// **Pro-top:** This function is particularly useful when configuring a program via\n/// [`App::from_yaml`] in conjunction with the [`crate_name!`] macro to derive the program's\n/// name from its `Cargo.toml`.\n///\n/// # Examples\n/// ```ignore\n/// # #[macro_use]\n/// # extern crate clap;\n/// # use clap::App;\n/// # fn main() {\n/// let yml = load_yaml!(\"app.yml\");\n/// let app = App::from_yaml(yml)\n///     .name(crate_name!());\n///\n/// // continued logic goes here, such as `app.get_matches()` etc.\n/// # }\n/// ```\n///\n/// [`App::from_yaml`]: ./struct.App.html#method.from_yaml\n/// [`crate_name!`]: ./macro.crate_name.html\npub fn name<S: Into<String>>(mut self, name: S) -> Self{\n        self.p.meta.name = name.into();\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::new":["/// Creates a new instance of an application requiring a name. The name may be, but doesn't\n/// have to be same as the binary. The name will be displayed to the user when they request to\n/// print version or help and usage information.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// let prog = App::new(\"My Program\")\n/// # ;\n/// ```\npub fn new<S: Into<String>>(n: S) -> Self{\n        App {\n            p: Parser::with_name(n.into()),\n        }\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::print_help":["/// Prints the full help message to [`io::stdout()`] using a [`BufWriter`] using the same\n/// method as if someone ran `-h` to request the help message\n///\n/// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" help messages\n/// depending on if the user ran [`-h` (short)] or [`--help` (long)]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::App;\n/// let mut app = App::new(\"myprog\");\n/// app.print_help();\n/// ```\n/// [`io::stdout()`]: https://doc.rust-lang.org/std/io/fn.stdout.html\n/// [`BufWriter`]: https://doc.rust-lang.org/std/io/struct.BufWriter.html\n/// [`-h` (short)]: ./struct.Arg.html#method.help\n/// [`--help` (long)]: ./struct.Arg.html#method.long_help\npub fn print_help(&mut self) -> ClapResult<()>{\n        // If there are global arguments, or settings we need to propagate them down to subcommands\n        // before parsing incase we run into a subcommand\n        self.p.propagate_globals();\n        self.p.propagate_settings();\n        self.p.derive_display_order();\n\n        self.p.create_help_and_version();\n        let out = io::stdout();\n        let mut buf_w = BufWriter::new(out.lock());\n        self.write_help(&mut buf_w)\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::print_long_help":["/// Prints the full help message to [`io::stdout()`] using a [`BufWriter`] using the same\n/// method as if someone ran `--help` to request the help message\n///\n/// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" help messages\n/// depending on if the user ran [`-h` (short)] or [`--help` (long)]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::App;\n/// let mut app = App::new(\"myprog\");\n/// app.print_long_help();\n/// ```\n/// [`io::stdout()`]: https://doc.rust-lang.org/std/io/fn.stdout.html\n/// [`BufWriter`]: https://doc.rust-lang.org/std/io/struct.BufWriter.html\n/// [`-h` (short)]: ./struct.Arg.html#method.help\n/// [`--help` (long)]: ./struct.Arg.html#method.long_help\npub fn print_long_help(&mut self) -> ClapResult<()>{\n        let out = io::stdout();\n        let mut buf_w = BufWriter::new(out.lock());\n        self.write_long_help(&mut buf_w)\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::set_term_width":["/// Sets the terminal width at which to wrap help messages. Defaults to `120`. Using `0` will\n/// ignore terminal widths and use source formatting.\n///\n/// `clap` automatically tries to determine the terminal width on Unix, Linux, macOS and Windows\n/// if the `wrap_help` cargo \"feature\" has been used while compiling. If the terminal width\n/// cannot be determined, `clap` defaults to `120`.\n///\n/// **NOTE:** This setting applies globally and *not* on a per-command basis.\n///\n/// **NOTE:** This setting must be set **before** any subcommands are added!\n///\n/// # Platform Specific\n///\n/// Only Unix, Linux, macOS and Windows support automatic determination of terminal width.\n/// Even on those platforms, this setting is useful if for any reason the terminal width\n/// cannot be determined.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::App;\n/// App::new(\"myprog\")\n///     .set_term_width(80)\n/// # ;\n/// ```\npub fn set_term_width(mut self, width: usize) -> Self{\n        self.p.meta.term_w = Some(width);\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::setting":["/// Enables a single command, or [`SubCommand`], level settings.\n///\n/// See [`AppSettings`] for a full list of possibilities and examples.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg, AppSettings};\n/// App::new(\"myprog\")\n///     .setting(AppSettings::SubcommandRequired)\n///     .setting(AppSettings::WaitOnError)\n/// # ;\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [`AppSettings`]: ./enum.AppSettings.html\npub fn setting(mut self, setting: AppSettings) -> Self{\n        self.p.set(setting);\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::settings":["/// Enables multiple command, or [`SubCommand`], level settings\n///\n/// See [`AppSettings`] for a full list of possibilities and examples.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg, AppSettings};\n/// App::new(\"myprog\")\n///     .settings(&[AppSettings::SubcommandRequired,\n///                  AppSettings::WaitOnError])\n/// # ;\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [`AppSettings`]: ./enum.AppSettings.html\npub fn settings(mut self, settings: &[AppSettings]) -> Self{\n        for s in settings {\n            self.p.set(*s);\n        }\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::subcommand":["/// Adds a [`SubCommand`] to the list of valid possibilities. Subcommands are effectively\n/// sub-[`App`]s, because they can contain their own arguments, subcommands, version, usage,\n/// etc. They also function just like [`App`]s, in that they get their own auto generated help,\n/// version, and usage.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg, SubCommand};\n/// App::new(\"myprog\")\n///     .subcommand(SubCommand::with_name(\"config\")\n///         .about(\"Controls configuration features\")\n///         .arg_from_usage(\"<config> 'Required configuration file to use'\"))\n/// # ;\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [`App`]: ./struct.App.html\npub fn subcommand(mut self, subcmd: App<'a, 'b>) -> Self{\n        self.p.add_subcommand(subcmd);\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::subcommands":["/// Adds multiple subcommands to the list of valid possibilities by iterating over an\n/// [`IntoIterator`] of [`SubCommand`]s\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, SubCommand};\n/// # App::new(\"myprog\")\n/// .subcommands( vec![\n///        SubCommand::with_name(\"config\").about(\"Controls configuration functionality\")\n///                                 .arg(Arg::with_name(\"config_file\").index(1)),\n///        SubCommand::with_name(\"debug\").about(\"Controls debug functionality\")])\n/// # ;\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [`IntoIterator`]: https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\npub fn subcommands<I>(mut self, subcmds: I) -> Self\n    where\n        I: IntoIterator<Item = App<'a, 'b>>,{\n        for subcmd in subcmds {\n            self.p.add_subcommand(subcmd);\n        }\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::template":["/// Sets the help template to be used, overriding the default format.\n///\n/// Tags arg given inside curly brackets.\n///\n/// Valid tags are:\n///\n///   * `{bin}`         - Binary name.\n///   * `{version}`     - Version number.\n///   * `{author}`      - Author information.\n///   * `{about}`       - General description (from [`App::about`])\n///   * `{usage}`       - Automatically generated or given usage string.\n///   * `{all-args}`    - Help for all arguments (options, flags, positionals arguments,\n///                       and subcommands) including titles.\n///   * `{unified}`     - Unified help for options and flags. Note, you must *also* set\n///                       [`AppSettings::UnifiedHelpMessage`] to fully merge both options and\n///                       flags, otherwise the ordering is \"best effort\"\n///   * `{flags}`       - Help for flags.\n///   * `{options}`     - Help for options.\n///   * `{positionals}` - Help for positionals arguments.\n///   * `{subcommands}` - Help for subcommands.\n///   * `{after-help}`  - Help from [`App::after_help`]\n///   * `{before-help}`  - Help from [`App::before_help`]\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .version(\"1.0\")\n///     .template(\"{bin} ({version}) - {usage}\")\n/// # ;\n/// ```\n/// **NOTE:** The template system is, on purpose, very simple. Therefore the tags have to be\n/// written in lowercase and without spacing.\n///\n/// [`App::about`]: ./struct.App.html#method.about\n/// [`App::after_help`]: ./struct.App.html#method.after_help\n/// [`App::before_help`]: ./struct.App.html#method.before_help\n/// [`AppSettings::UnifiedHelpMessage`]: ./enum.AppSettings.html#variant.UnifiedHelpMessage\npub fn template<S: Into<&'b str>>(mut self, s: S) -> Self{\n        self.p.meta.template = Some(s.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::unset_setting":["/// Disables a single command, or [`SubCommand`], level setting.\n///\n/// See [`AppSettings`] for a full list of possibilities and examples.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, AppSettings};\n/// App::new(\"myprog\")\n///     .unset_setting(AppSettings::ColorAuto)\n/// # ;\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [`AppSettings`]: ./enum.AppSettings.html\npub fn unset_setting(mut self, setting: AppSettings) -> Self{\n        self.p.unset(setting);\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::unset_settings":["/// Disables multiple command, or [`SubCommand`], level settings.\n///\n/// See [`AppSettings`] for a full list of possibilities and examples.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, AppSettings};\n/// App::new(\"myprog\")\n///     .unset_settings(&[AppSettings::ColorAuto,\n///                       AppSettings::AllowInvalidUtf8])\n/// # ;\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [`AppSettings`]: ./enum.AppSettings.html\npub fn unset_settings(mut self, settings: &[AppSettings]) -> Self{\n        for s in settings {\n            self.p.unset(*s);\n        }\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::usage":["/// Sets a custom usage string to override the auto-generated usage string.\n///\n/// This will be displayed to the user when errors are found in argument parsing, or when you\n/// call [`ArgMatches::usage`]\n///\n/// **CAUTION:** Using this setting disables `clap`s \"context-aware\" usage strings. After this\n/// setting is set, this will be the only usage string displayed to the user!\n///\n/// **NOTE:** You do not need to specify the \"USAGE: \\n\\t\" portion, as that will\n/// still be applied by `clap`, you only need to specify the portion starting\n/// with the binary name.\n///\n/// **NOTE:** This will not replace the entire help message, *only* the portion\n/// showing the usage.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .usage(\"myapp [-clDas] <some_file>\")\n/// # ;\n/// ```\n/// [`ArgMatches::usage`]: ./struct.ArgMatches.html#method.usage\npub fn usage<S: Into<&'b str>>(mut self, usage: S) -> Self{\n        self.p.meta.usage_str = Some(usage.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::version":["/// Sets a string of the version number to be displayed when displaying version or help\n/// information with `-V`.\n///\n/// **NOTE:** If only `version` is provided, and not [`App::long_version`] but the user\n/// requests `--version` clap will still display the contents of `version` appropriately\n///\n/// **Pro-tip:** Use `clap`s convenience macro [`crate_version!`] to automatically set your\n/// application's version to the same thing as your crate at compile time. See the [`examples/`]\n/// directory for more information\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .version(\"v0.1.24\")\n/// # ;\n/// ```\n/// [`crate_version!`]: ./macro.crate_version!.html\n/// [`examples/`]: https://github.com/clap-rs/clap/tree/v2.33.1/examples\n/// [`App::long_version`]: ./struct.App.html#method.long_version\npub fn version<S: Into<&'b str>>(mut self, ver: S) -> Self{\n        self.p.meta.version = Some(ver.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::version_message":["/// Sets the help text for the auto-generated `version` argument.\n///\n/// By default `clap` sets this to `\"Prints version information\"`, but if you're using a\n/// different convention for your help messages and would prefer a different phrasing then you\n/// can change it.\n///\n/// # Examples\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .version_message(\"Print version information\") // Perhaps you want imperative help messages\n/// # ;\n/// ```\npub fn version_message<S: Into<&'a str>>(mut self, s: S) -> Self{\n        self.p.version_message = Some(s.into());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::version_short":["/// Sets the [`short`] for the auto-generated `version` argument.\n///\n/// By default `clap` automatically assigns `V`, but this can be overridden if you have a\n/// different argument which you'd prefer to use the `-V` short with. This can be done by\n/// defining your own argument with an uppercase `V` as the [`short`].\n///\n/// `clap` lazily generates these `version` arguments **after** you've defined any arguments of\n/// your own.\n///\n/// **NOTE:** Any leading `-` characters will be stripped, and only the first\n/// non `-` character will be used as the `short` version\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// App::new(\"myprog\")\n///     .version_short(\"v\") // Using a lowercase `v` instead of the default capital `V`\n/// # ;\n/// ```\n/// [`short`]: ./struct.Arg.html#method.short\npub fn version_short<S: AsRef<str>>(mut self, s: S) -> Self{\n        self.p.version_short(s.as_ref());\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::visible_alias":["/// Allows adding a [`SubCommand`] alias that functions exactly like those defined with\n/// [`App::alias`], except that they are visible inside the help message.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg, SubCommand};\n/// let m = App::new(\"myprog\")\n///             .subcommand(SubCommand::with_name(\"test\")\n///                 .visible_alias(\"do-stuff\"))\n///             .get_matches_from(vec![\"myprog\", \"do-stuff\"]);\n/// assert_eq!(m.subcommand_name(), Some(\"test\"));\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [`App::alias`]: ./struct.App.html#method.alias\npub fn visible_alias<S: Into<&'b str>>(mut self, name: S) -> Self{\n        if let Some(ref mut als) = self.p.meta.aliases {\n            als.push((name.into(), true));\n        } else {\n            self.p.meta.aliases = Some(vec![(name.into(), true)]);\n        }\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::visible_aliases":["/// Allows adding multiple [`SubCommand`] aliases that functions exactly like those defined\n/// with [`App::aliases`], except that they are visible inside the help message.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg, SubCommand};\n/// let m = App::new(\"myprog\")\n///             .subcommand(SubCommand::with_name(\"test\")\n///                 .visible_aliases(&[\"do-stuff\", \"tests\"]))\n///             .get_matches_from(vec![\"myprog\", \"do-stuff\"]);\n/// assert_eq!(m.subcommand_name(), Some(\"test\"));\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [`App::aliases`]: ./struct.App.html#method.aliases\npub fn visible_aliases(mut self, names: &[&'b str]) -> Self{\n        if let Some(ref mut als) = self.p.meta.aliases {\n            for n in names {\n                als.push((n, true));\n            }\n        } else {\n            self.p.meta.aliases = Some(names.iter().map(|n| (*n, true)).collect::<Vec<_>>());\n        }\n        self\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::with_defaults":["/// Creates a new instance of an application requiring a name, but uses the [`crate_authors!`]\n/// and [`crate_version!`] macros to fill in the [`App::author`] and [`App::version`] fields.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// let prog = App::with_defaults(\"My Program\")\n/// # ;\n/// ```\n/// [`crate_authors!`]: ./macro.crate_authors!.html\n/// [`crate_version!`]: ./macro.crate_version!.html\n/// [`App::author`]: ./struct.App.html#method.author\n/// [`App::version`]: ./struct.App.html#method.author\n#[deprecated(\n        since = \"2.14.1\",\n        note = \"Can never work; use explicit App::author() and App::version() calls instead\"\n    )]\npub fn with_defaults<S: Into<String>>(n: S) -> Self{\n        let mut a = App {\n            p: Parser::with_name(n.into()),\n        };\n        a.p.meta.author = Some(\"Kevin K. <kbknapp@gmail.com>\");\n        a.p.meta.version = Some(\"2.19.2\");\n        a\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::write_help":["/// Writes the full help message to the user to a [`io::Write`] object in the same method as if\n/// the user ran `-h`\n///\n/// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" help messages\n/// depending on if the user ran [`-h` (short)] or [`--help` (long)]\n///\n/// **NOTE:** There is a known bug where this method does not write propagated global arguments\n/// or autogenerated arguments (i.e. the default help/version args). Prefer\n/// [`App::write_long_help`] instead if possible!\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::App;\n/// use std::io;\n/// let mut app = App::new(\"myprog\");\n/// let mut out = io::stdout();\n/// app.write_help(&mut out).expect(\"failed to write to stdout\");\n/// ```\n/// [`io::Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n/// [`-h` (short)]: ./struct.Arg.html#method.help\n/// [`--help` (long)]: ./struct.Arg.html#method.long_help\npub fn write_help<W: Write>(&self, w: &mut W) -> ClapResult<()>{\n        // PENDING ISSUE: 808\n        //      https://github.com/clap-rs/clap/issues/808\n        // If there are global arguments, or settings we need to propagate them down to subcommands\n        // before parsing incase we run into a subcommand\n        // self.p.propagate_globals();\n        // self.p.propagate_settings();\n        // self.p.derive_display_order();\n        // self.p.create_help_and_version();\n\n        Help::write_app_help(w, self, false)\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::write_long_help":["/// Writes the full help message to the user to a [`io::Write`] object in the same method as if\n/// the user ran `--help`\n///\n/// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" help messages\n/// depending on if the user ran [`-h` (short)] or [`--help` (long)]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::App;\n/// use std::io;\n/// let mut app = App::new(\"myprog\");\n/// let mut out = io::stdout();\n/// app.write_long_help(&mut out).expect(\"failed to write to stdout\");\n/// ```\n/// [`io::Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n/// [`-h` (short)]: ./struct.Arg.html#method.help\n/// [`--help` (long)]: ./struct.Arg.html#method.long_help\npub fn write_long_help<W: Write>(&mut self, w: &mut W) -> ClapResult<()>{\n        // If there are global arguments, or settings we need to propagate them down to subcommands\n        // before parsing incase we run into a subcommand\n        self.p.propagate_globals();\n        self.p.propagate_settings();\n        self.p.derive_display_order();\n        self.p.create_help_and_version();\n\n        Help::write_app_help(w, self, true)\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::write_long_version":["/// Writes the version message to the user to a [`io::Write`] object\n///\n/// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" version messages\n/// depending on if the user ran [`-V` (short)] or [`--version` (long)]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::App;\n/// use std::io;\n/// let mut app = App::new(\"myprog\");\n/// let mut out = io::stdout();\n/// app.write_long_version(&mut out).expect(\"failed to write to stdout\");\n/// ```\n/// [`io::Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n/// [`-V` (short)]: ./struct.App.html#method.version\n/// [`--version` (long)]: ./struct.App.html#method.long_version\npub fn write_long_version<W: Write>(&self, w: &mut W) -> ClapResult<()>{\n        self.p.write_version(w, true).map_err(From::from)\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::App::<'a, 'b>::write_version":["/// Writes the version message to the user to a [`io::Write`] object as if the user ran `-V`.\n///\n/// **NOTE:** clap has the ability to distinguish between \"short\" and \"long\" version messages\n/// depending on if the user ran [`-V` (short)] or [`--version` (long)]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::App;\n/// use std::io;\n/// let mut app = App::new(\"myprog\");\n/// let mut out = io::stdout();\n/// app.write_version(&mut out).expect(\"failed to write to stdout\");\n/// ```\n/// [`io::Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n/// [`-V` (short)]: ./struct.App.html#method.version\n/// [`--version` (long)]: ./struct.App.html#method.long_version\npub fn write_version<W: Write>(&self, w: &mut W) -> ClapResult<()>{\n        self.p.write_version(w, false).map_err(From::from)\n    }","Real(LocalPath(\"src/app/mod.rs\"))"],"app::help::<impl args::any_arg::DispOrder for app::App<'b, 'c>>::disp_ord":["fn disp_ord(&self) -> usize{\n        999\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::ArgWithDisplay":["trait ArgWithDisplay<'b, 'c>: AnyArg<'b, 'c> + Display {}","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::ArgWithOrder":["trait ArgWithOrder<'b, 'c>: ArgWithDisplay<'b, 'c> + DispOrder {\n    fn as_base(&self) -> &ArgWithDisplay<'b, 'c>;\n}","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::CopyUntilResult":["/// Possible results for a copying function that stops when a given\n/// byte was found.\nenum CopyUntilResult {\n    DelimiterFound(usize),\n    DelimiterNotFound(usize),\n    ReaderEmpty,\n    ReadError(io::Error),\n    WriteError(io::Error),\n}","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help":["/// `clap` Help Writer.\n///\n/// Wraps a writer stream providing different methods to generate help for `clap` objects.\npub struct Help<'a> {\n    writer: &'a mut Write,\n    next_line_help: bool,\n    hide_pv: bool,\n    term_w: usize,\n    color: bool,\n    cizer: Colorizer,\n    longest: usize,\n    force_next_line: bool,\n    use_long: bool,\n}","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::_write_parser_help":["#[doc(hidden)]\npub fn _write_parser_help(\n        w: &'a mut Write,\n        parser: &Parser,\n        stderr: bool,\n        use_long: bool,\n    ) -> ClapResult<()>{\n        debugln!(\"Help::write_parser_help;\");\n        let nlh = parser.is_set(AppSettings::NextLineHelp);\n        let hide_v = parser.is_set(AppSettings::HidePossibleValuesInHelp);\n        let color = parser.is_set(AppSettings::ColoredHelp);\n        let cizer = Colorizer::new(ColorizerOption {\n            use_stderr: stderr,\n            when: parser.color(),\n        });\n        Self::new(\n            w,\n            nlh,\n            hide_v,\n            color,\n            cizer,\n            parser.meta.term_w,\n            parser.meta.max_w,\n            use_long,\n        )\n        .write_help(parser)\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::help":["/// Writes argument's help to the wrapped stream.\nfn help<'b, 'c>(&mut self, arg: &ArgWithDisplay<'b, 'c>, spec_vals: &str) -> io::Result<()>{\n        debugln!(\"Help::help;\");\n        let h = if self.use_long && arg.name() != \"\" {\n            arg.long_help().unwrap_or_else(|| arg.help().unwrap_or(\"\"))\n        } else {\n            arg.help().unwrap_or_else(|| arg.long_help().unwrap_or(\"\"))\n        };\n        let mut help = String::from(h) + spec_vals;\n        let nlh = self.next_line_help\n            || arg.is_set(ArgSettings::NextLineHelp)\n            || (self.use_long && arg.name() != \"\");\n        debugln!(\"Help::help: Next Line...{:?}\", nlh);\n\n        let spcs = if nlh || self.force_next_line {\n            12 // \"tab\" * 3\n        } else {\n            self.longest + 12\n        };\n\n        let too_long = spcs + str_width(h) + str_width(&*spec_vals) >= self.term_w;\n\n        // Is help on next line, if so then indent\n        if nlh || self.force_next_line {\n            write!(self.writer, \"\\n{}{}{}\", TAB, TAB, TAB)?;\n        }\n\n        debug!(\"Help::help: Too long...\");\n        if too_long && spcs <= self.term_w || h.contains(\"{n}\") {\n            sdebugln!(\"Yes\");\n            debugln!(\"Help::help: help...{}\", help);\n            debugln!(\"Help::help: help width...{}\", str_width(&*help));\n            // Determine how many newlines we need to insert\n            let avail_chars = self.term_w - spcs;\n            debugln!(\"Help::help: Usable space...{}\", avail_chars);\n            help = wrap_help(&help.replace(\"{n}\", \"\\n\"), avail_chars);\n        } else {\n            sdebugln!(\"No\");\n        }\n        if let Some(part) = help.lines().next() {\n            write!(self.writer, \"{}\", part)?;\n        }\n        for part in help.lines().skip(1) {\n            write!(self.writer, \"\\n\")?;\n            if nlh || self.force_next_line {\n                write!(self.writer, \"{}{}{}\", TAB, TAB, TAB)?;\n            } else if arg.has_switch() {\n                write_nspaces!(self.writer, self.longest + 12);\n            } else {\n                write_nspaces!(self.writer, self.longest + 8);\n            }\n            write!(self.writer, \"{}\", part)?;\n        }\n        if !help.contains('\\n') && (nlh || self.force_next_line) {\n            write!(self.writer, \"\\n\")?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::long":["/// Writes argument's long command to the wrapped stream.\nfn long<'b, 'c>(&mut self, arg: &ArgWithDisplay<'b, 'c>) -> io::Result<()>{\n        debugln!(\"Help::long;\");\n        if !arg.has_switch() {\n            return Ok(());\n        }\n        if arg.takes_value() {\n            if let Some(l) = arg.long() {\n                if arg.short().is_some() {\n                    write!(self.writer, \", \")?;\n                }\n                color!(self, \"--{}\", l, good)?\n            }\n\n            let sep = if arg.is_set(ArgSettings::RequireEquals) {\n                \"=\"\n            } else {\n                \" \"\n            };\n            write!(self.writer, \"{}\", sep)?;\n        } else if let Some(l) = arg.long() {\n            if arg.short().is_some() {\n                write!(self.writer, \", \")?;\n            }\n            color!(self, \"--{}\", l, good)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::new":["/// Create a new `Help` instance.\npub fn new(\n        w: &'a mut Write,\n        next_line_help: bool,\n        hide_pv: bool,\n        color: bool,\n        cizer: Colorizer,\n        term_w: Option<usize>,\n        max_w: Option<usize>,\n        use_long: bool,\n    ) -> Self{\n        debugln!(\"Help::new;\");\n        Help {\n            writer: w,\n            next_line_help: next_line_help,\n            hide_pv: hide_pv,\n            term_w: match term_w {\n                Some(width) => {\n                    if width == 0 {\n                        usize::MAX\n                    } else {\n                        width\n                    }\n                }\n                None => cmp::min(\n                    term_size::dimensions().map_or(120, |(w, _)| w),\n                    match max_w {\n                        None | Some(0) => usize::MAX,\n                        Some(mw) => mw,\n                    },\n                ),\n            },\n            color: color,\n            cizer: cizer,\n            longest: 0,\n            force_next_line: false,\n            use_long: use_long,\n        }\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::short":["/// Writes argument's short command to the wrapped stream.\nfn short<'b, 'c>(&mut self, arg: &ArgWithDisplay<'b, 'c>) -> io::Result<()>{\n        debugln!(\"Help::short;\");\n        write!(self.writer, \"{}\", TAB)?;\n        if let Some(s) = arg.short() {\n            color!(self, \"-{}\", s, good)\n        } else if arg.has_switch() {\n            write!(self.writer, \"{}\", TAB)\n        } else {\n            Ok(())\n        }\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::spec_vals":["fn spec_vals(&self, a: &ArgWithDisplay) -> String{\n        debugln!(\"Help::spec_vals: a={}\", a);\n        let mut spec_vals = vec![];\n        if let Some(ref env) = a.env() {\n            debugln!(\n                \"Help::spec_vals: Found environment variable...[{:?}:{:?}]\",\n                env.0,\n                env.1\n            );\n            let env_val = if !a.is_set(ArgSettings::HideEnvValues) {\n                format!(\n                    \"={}\",\n                    env.1.map_or(Cow::Borrowed(\"\"), |val| val.to_string_lossy())\n                )\n            } else {\n                String::new()\n            };\n            let env_info = format!(\" [env: {}{}]\", env.0.to_string_lossy(), env_val);\n            spec_vals.push(env_info);\n        }\n        if !a.is_set(ArgSettings::HideDefaultValue) {\n            if let Some(pv) = a.default_val() {\n                debugln!(\"Help::spec_vals: Found default value...[{:?}]\", pv);\n                spec_vals.push(format!(\n                    \" [default: {}]\",\n                    if self.color {\n                        self.cizer.good(pv.to_string_lossy())\n                    } else {\n                        Format::None(pv.to_string_lossy())\n                    }\n                ));\n            }\n        }\n        if let Some(ref aliases) = a.aliases() {\n            debugln!(\"Help::spec_vals: Found aliases...{:?}\", aliases);\n            spec_vals.push(format!(\n                \" [aliases: {}]\",\n                if self.color {\n                    aliases\n                        .iter()\n                        .map(|v| format!(\"{}\", self.cizer.good(v)))\n                        .collect::<Vec<_>>()\n                        .join(\", \")\n                } else {\n                    aliases.join(\", \")\n                }\n            ));\n        }\n        if !self.hide_pv && !a.is_set(ArgSettings::HidePossibleValues) {\n            if let Some(pv) = a.possible_vals() {\n                debugln!(\"Help::spec_vals: Found possible vals...{:?}\", pv);\n                spec_vals.push(if self.color {\n                    format!(\n                        \" [possible values: {}]\",\n                        pv.iter()\n                            .map(|v| format!(\"{}\", self.cizer.good(v)))\n                            .collect::<Vec<_>>()\n                            .join(\", \")\n                    )\n                } else {\n                    format!(\" [possible values: {}]\", pv.join(\", \"))\n                });\n            }\n        }\n        spec_vals.join(\" \")\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::val":["/// Writes argument's possible values to the wrapped stream.\nfn val<'b, 'c>(&mut self, arg: &ArgWithDisplay<'b, 'c>) -> Result<String, io::Error>{\n        debugln!(\"Help::val: arg={}\", arg);\n        if arg.takes_value() {\n            let delim = if arg.is_set(ArgSettings::RequireDelimiter) {\n                arg.val_delim().expect(INTERNAL_ERROR_MSG)\n            } else {\n                ' '\n            };\n            if let Some(vec) = arg.val_names() {\n                let mut it = vec.iter().peekable();\n                while let Some((_, val)) = it.next() {\n                    color!(self, \"<{}>\", val, good)?;\n                    if it.peek().is_some() {\n                        write!(self.writer, \"{}\", delim)?;\n                    }\n                }\n                let num = vec.len();\n                if arg.is_set(ArgSettings::Multiple) && num == 1 {\n                    color!(self, \"...\", good)?;\n                }\n            } else if let Some(num) = arg.num_vals() {\n                let mut it = (0..num).peekable();\n                while let Some(_) = it.next() {\n                    color!(self, \"<{}>\", arg.name(), good)?;\n                    if it.peek().is_some() {\n                        write!(self.writer, \"{}\", delim)?;\n                    }\n                }\n                if arg.is_set(ArgSettings::Multiple) && num == 1 {\n                    color!(self, \"...\", good)?;\n                }\n            } else if arg.has_switch() {\n                color!(self, \"<{}>\", arg.name(), good)?;\n                if arg.is_set(ArgSettings::Multiple) {\n                    color!(self, \"...\", good)?;\n                }\n            } else {\n                color!(self, \"{}\", arg, good)?;\n            }\n        }\n\n        let spec_vals = self.spec_vals(arg);\n        let h = arg.help().unwrap_or(\"\");\n        let h_w = str_width(h) + str_width(&*spec_vals);\n        let nlh = self.next_line_help || arg.is_set(ArgSettings::NextLineHelp);\n        let taken = self.longest + 12;\n        self.force_next_line = !nlh\n            && self.term_w >= taken\n            && (taken as f32 / self.term_w as f32) > 0.40\n            && h_w > (self.term_w - taken);\n\n        debug!(\"Help::val: Has switch...\");\n        if arg.has_switch() {\n            sdebugln!(\"Yes\");\n            debugln!(\"Help::val: force_next_line...{:?}\", self.force_next_line);\n            debugln!(\"Help::val: nlh...{:?}\", nlh);\n            debugln!(\"Help::val: taken...{}\", taken);\n            debugln!(\n                \"Help::val: help_width > (width - taken)...{} > ({} - {})\",\n                h_w,\n                self.term_w,\n                taken\n            );\n            debugln!(\"Help::val: longest...{}\", self.longest);\n            debug!(\"Help::val: next_line...\");\n            if !(nlh || self.force_next_line) {\n                sdebugln!(\"No\");\n                let self_len = str_width(arg.to_string().as_str());\n                // subtract ourself\n                let mut spcs = self.longest - self_len;\n                // Since we're writing spaces from the tab point we first need to know if we\n                // had a long and short, or just short\n                if arg.long().is_some() {\n                    // Only account 4 after the val\n                    spcs += 4;\n                } else {\n                    // Only account for ', --' + 4 after the val\n                    spcs += 8;\n                }\n\n                write_nspaces!(self.writer, spcs);\n            } else {\n                sdebugln!(\"Yes\");\n            }\n        } else if !(nlh || self.force_next_line) {\n            sdebugln!(\"No, and not next_line\");\n            write_nspaces!(\n                self.writer,\n                self.longest + 4 - (str_width(arg.to_string().as_str()))\n            );\n        } else {\n            sdebugln!(\"No\");\n        }\n        Ok(spec_vals)\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_all_args":["/// Writes help for all arguments (options, flags, args, subcommands)\n/// including titles of a Parser Object to the wrapped stream.\npub fn write_all_args(&mut self, parser: &Parser) -> ClapResult<()>{\n        debugln!(\"Help::write_all_args;\");\n        let flags = parser.has_flags();\n        let pos = parser\n            .positionals()\n            .filter(|arg| !arg.is_set(ArgSettings::Hidden))\n            .count()\n            > 0;\n        let opts = parser.has_opts();\n        let subcmds = parser.has_visible_subcommands();\n\n        let unified_help = parser.is_set(AppSettings::UnifiedHelpMessage);\n\n        let mut first = true;\n\n        if unified_help && (flags || opts) {\n            let opts_flags = parser\n                .flags()\n                .map(as_arg_trait)\n                .chain(parser.opts().map(as_arg_trait));\n            color!(self, \"OPTIONS:\\n\", warning)?;\n            self.write_args(opts_flags)?;\n            first = false;\n        } else {\n            if flags {\n                color!(self, \"FLAGS:\\n\", warning)?;\n                self.write_args(parser.flags().map(as_arg_trait))?;\n                first = false;\n            }\n            if opts {\n                if !first {\n                    self.writer.write_all(b\"\\n\\n\")?;\n                }\n                color!(self, \"OPTIONS:\\n\", warning)?;\n                self.write_args(parser.opts().map(as_arg_trait))?;\n                first = false;\n            }\n        }\n\n        if pos {\n            if !first {\n                self.writer.write_all(b\"\\n\\n\")?;\n            }\n            color!(self, \"ARGS:\\n\", warning)?;\n            self.write_args_unsorted(parser.positionals().map(as_arg_trait))?;\n            first = false;\n        }\n\n        if subcmds {\n            if !first {\n                self.writer.write_all(b\"\\n\\n\")?;\n            }\n            color!(self, \"SUBCOMMANDS:\\n\", warning)?;\n            self.write_subcommands(parser)?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_app_help":["/// Reads help settings from an App\n/// and write its help to the wrapped stream.\npub fn write_app_help(w: &'a mut Write, app: &App, use_long: bool) -> ClapResult<()>{\n        debugln!(\"Help::write_app_help;\");\n        Self::write_parser_help(w, &app.p, use_long)\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_arg":["/// Writes help for an argument to the wrapped stream.\nfn write_arg<'b, 'c>(&mut self, arg: &ArgWithDisplay<'b, 'c>) -> io::Result<()>{\n        debugln!(\"Help::write_arg;\");\n        self.short(arg)?;\n        self.long(arg)?;\n        let spec_vals = self.val(arg)?;\n        self.help(arg, &*spec_vals)?;\n        Ok(())\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_args":["/// Sorts arguments by length and display order and write their help to the wrapped stream.\nfn write_args<'b: 'd, 'c: 'd, 'd, I: 'd>(&mut self, args: I) -> io::Result<()>\n    where\n        I: Iterator<Item = &'d ArgWithOrder<'b, 'c>>,{\n        debugln!(\"Help::write_args;\");\n        // The shortest an arg can legally be is 2 (i.e. '-x')\n        self.longest = 2;\n        let mut ord_m = VecMap::new();\n        let use_long = self.use_long;\n        // Determine the longest\n        for arg in args.filter(|arg| {\n            // If it's NextLineHelp, but we don't care to compute how long because it may be\n            // NextLineHelp on purpose *because* it's so long and would throw off all other\n            // args alignment\n            should_show_arg(use_long, *arg)\n        }) {\n            if arg.longest_filter() {\n                debugln!(\"Help::write_args: Current Longest...{}\", self.longest);\n                self.longest = cmp::max(self.longest, str_width(arg.to_string().as_str()));\n                debugln!(\"Help::write_args: New Longest...{}\", self.longest);\n            }\n            let btm = ord_m.entry(arg.disp_ord()).or_insert(BTreeMap::new());\n            btm.insert(arg.name(), arg);\n        }\n        let mut first = true;\n        for btm in ord_m.values() {\n            for arg in btm.values() {\n                if first {\n                    first = false;\n                } else {\n                    self.writer.write_all(b\"\\n\")?;\n                }\n                self.write_arg(arg.as_base())?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_args_unsorted":["/// Writes help for each argument in the order they were declared to the wrapped stream.\nfn write_args_unsorted<'b: 'd, 'c: 'd, 'd, I: 'd>(&mut self, args: I) -> io::Result<()>\n    where\n        I: Iterator<Item = &'d ArgWithOrder<'b, 'c>>,{\n        debugln!(\"Help::write_args_unsorted;\");\n        // The shortest an arg can legally be is 2 (i.e. '-x')\n        self.longest = 2;\n        let mut arg_v = Vec::with_capacity(10);\n        let use_long = self.use_long;\n        for arg in args.filter(|arg| should_show_arg(use_long, *arg)) {\n            if arg.longest_filter() {\n                self.longest = cmp::max(self.longest, str_width(arg.to_string().as_str()));\n            }\n            arg_v.push(arg)\n        }\n        let mut first = true;\n        for arg in arg_v {\n            if first {\n                first = false;\n            } else {\n                self.writer.write_all(b\"\\n\")?;\n            }\n            self.write_arg(arg.as_base())?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_before_after_help":["fn write_before_after_help(&mut self, h: &str) -> io::Result<()>{\n        debugln!(\"Help::write_before_after_help;\");\n        let mut help = String::from(h);\n        // determine if our help fits or needs to wrap\n        debugln!(\n            \"Help::write_before_after_help: Term width...{}\",\n            self.term_w\n        );\n        let too_long = str_width(h) >= self.term_w;\n\n        debug!(\"Help::write_before_after_help: Too long...\");\n        if too_long || h.contains(\"{n}\") {\n            sdebugln!(\"Yes\");\n            debugln!(\"Help::write_before_after_help: help: {}\", help);\n            debugln!(\n                \"Help::write_before_after_help: help width: {}\",\n                str_width(&*help)\n            );\n            // Determine how many newlines we need to insert\n            debugln!(\n                \"Help::write_before_after_help: Usable space: {}\",\n                self.term_w\n            );\n            help = wrap_help(&help.replace(\"{n}\", \"\\n\"), self.term_w);\n        } else {\n            sdebugln!(\"No\");\n        }\n        write!(self.writer, \"{}\", help)?;\n        Ok(())\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_bin_name":["/// Writes binary name of a Parser Object to the wrapped stream.\nfn write_bin_name(&mut self, parser: &Parser) -> io::Result<()>{\n        debugln!(\"Help::write_bin_name;\");\n        macro_rules! write_name {\n            () => {{\n                let mut name = parser.meta.name.clone();\n                name = name.replace(\"{n}\", \"\\n\");\n                color!(self, wrap_help(&name, self.term_w), good)?;\n            }};\n        }\n        if let Some(bn) = parser.meta.bin_name.as_ref() {\n            if bn.contains(' ') {\n                // Incase we're dealing with subcommands i.e. git mv is translated to git-mv\n                color!(self, bn.replace(\" \", \"-\"), good)?\n            } else {\n                write_name!();\n            }\n        } else {\n            write_name!();\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_default_help":["/// Writes default help for a Parser Object to the wrapped stream.\npub fn write_default_help(&mut self, parser: &Parser) -> ClapResult<()>{\n        debugln!(\"Help::write_default_help;\");\n        if let Some(h) = parser.meta.pre_help {\n            self.write_before_after_help(h)?;\n            self.writer.write_all(b\"\\n\\n\")?;\n        }\n\n        macro_rules! write_thing {\n            ($thing:expr) => {{\n                let mut owned_thing = $thing.to_owned();\n                owned_thing = owned_thing.replace(\"{n}\", \"\\n\");\n                write!(self.writer, \"{}\\n\", wrap_help(&owned_thing, self.term_w))?\n            }};\n        }\n        // Print the version\n        self.write_bin_name(parser)?;\n        self.writer.write_all(b\" \")?;\n        self.write_version(parser)?;\n        self.writer.write_all(b\"\\n\")?;\n        if let Some(author) = parser.meta.author {\n            write_thing!(author)\n        }\n        // if self.use_long {\n        //     if let Some(about) = parser.meta.long_about {\n        //         debugln!(\"Help::write_default_help: writing long about\");\n        //         write_thing!(about)\n        //     } else if let Some(about) = parser.meta.about {\n        //         debugln!(\"Help::write_default_help: writing about\");\n        //         write_thing!(about)\n        //     }\n        // } else\n        if let Some(about) = parser.meta.long_about {\n            debugln!(\"Help::write_default_help: writing long about\");\n            write_thing!(about)\n        } else if let Some(about) = parser.meta.about {\n            debugln!(\"Help::write_default_help: writing about\");\n            write_thing!(about)\n        }\n\n        color!(self, \"\\nUSAGE:\", warning)?;\n        write!(\n            self.writer,\n            \"\\n{}{}\\n\\n\",\n            TAB,\n            usage::create_usage_no_title(parser, &[])\n        )?;\n\n        let flags = parser.has_flags();\n        let pos = parser.has_positionals();\n        let opts = parser.has_opts();\n        let subcmds = parser.has_subcommands();\n\n        if flags || opts || pos || subcmds {\n            self.write_all_args(parser)?;\n        }\n\n        if let Some(h) = parser.meta.more_help {\n            if flags || opts || pos || subcmds {\n                self.writer.write_all(b\"\\n\\n\")?;\n            }\n            self.write_before_after_help(h)?;\n        }\n\n        self.writer.flush().map_err(Error::from)\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_help":["/// Writes the parser help to the wrapped stream.\npub fn write_help(&mut self, parser: &Parser) -> ClapResult<()>{\n        debugln!(\"Help::write_help;\");\n        if let Some(h) = parser.meta.help_str {\n            write!(self.writer, \"{}\", h).map_err(Error::from)?;\n        } else if let Some(tmpl) = parser.meta.template {\n            self.write_templated_help(parser, tmpl)?;\n        } else {\n            self.write_default_help(parser)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_parser_help":["/// Reads help settings from a Parser\n/// and write its help to the wrapped stream.\npub fn write_parser_help(w: &'a mut Write, parser: &Parser, use_long: bool) -> ClapResult<()>{\n        debugln!(\"Help::write_parser_help;\");\n        Self::_write_parser_help(w, parser, false, use_long)\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_parser_help_to_stderr":["/// Reads help settings from a Parser\n/// and write its help to the wrapped stream which will be stderr. This method prevents\n/// formatting when required.\npub fn write_parser_help_to_stderr(w: &'a mut Write, parser: &Parser) -> ClapResult<()>{\n        debugln!(\"Help::write_parser_help;\");\n        Self::_write_parser_help(w, parser, true, false)\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_subcommands":["/// Writes help for subcommands of a Parser Object to the wrapped stream.\nfn write_subcommands(&mut self, parser: &Parser) -> io::Result<()>{\n        debugln!(\"Help::write_subcommands;\");\n        // The shortest an arg can legally be is 2 (i.e. '-x')\n        self.longest = 2;\n        let mut ord_m = VecMap::new();\n        for sc in parser\n            .subcommands\n            .iter()\n            .filter(|s| !s.p.is_set(AppSettings::Hidden))\n        {\n            let btm = ord_m.entry(sc.p.meta.disp_ord).or_insert(BTreeMap::new());\n            self.longest = cmp::max(self.longest, str_width(sc.p.meta.name.as_str()));\n            //self.longest = cmp::max(self.longest, sc.p.meta.name.len());\n            btm.insert(sc.p.meta.name.clone(), sc.clone());\n        }\n\n        let mut first = true;\n        for btm in ord_m.values() {\n            for sc in btm.values() {\n                if first {\n                    first = false;\n                } else {\n                    self.writer.write_all(b\"\\n\")?;\n                }\n                self.write_arg(sc)?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_templated_help":["/// Write help to stream for the parser in the format defined by the template.\n///\n/// Tags arg given inside curly brackets:\n/// Valid tags are:\n///     * `{bin}`         - Binary name.\n///     * `{version}`     - Version number.\n///     * `{author}`      - Author information.\n///     * `{usage}`       - Automatically generated or given usage string.\n///     * `{all-args}`    - Help for all arguments (options, flags, positionals arguments,\n///                         and subcommands) including titles.\n///     * `{unified}`     - Unified help for options and flags.\n///     * `{flags}`       - Help for flags.\n///     * `{options}`     - Help for options.\n///     * `{positionals}` - Help for positionals arguments.\n///     * `{subcommands}` - Help for subcommands.\n///     * `{after-help}`  - Info to be displayed after the help message.\n///     * `{before-help}` - Info to be displayed before the help message.\n///\n/// The template system is, on purpose, very simple. Therefore the tags have to written\n/// in the lowercase and without spacing.\nfn write_templated_help(&mut self, parser: &Parser, template: &str) -> ClapResult<()>{\n        debugln!(\"Help::write_templated_help;\");\n        let mut tmplr = Cursor::new(&template);\n        let mut tag_buf = Cursor::new(vec![0u8; 15]);\n\n        // The strategy is to copy the template from the reader to wrapped stream\n        // until a tag is found. Depending on its value, the appropriate content is copied\n        // to the wrapped stream.\n        // The copy from template is then resumed, repeating this sequence until reading\n        // the complete template.\n\n        loop {\n            let tag_length = match copy_and_capture(&mut tmplr, &mut self.writer, &mut tag_buf) {\n                None => return Ok(()),\n                Some(Err(e)) => return Err(Error::from(e)),\n                Some(Ok(val)) if val > 0 => val,\n                _ => continue,\n            };\n\n            debugln!(\"Help::write_template_help:iter: tag_buf={};\", unsafe {\n                String::from_utf8_unchecked(\n                    tag_buf.get_ref()[0..tag_length]\n                        .iter()\n                        .map(|&i| i)\n                        .collect::<Vec<_>>(),\n                )\n            });\n            match &tag_buf.get_ref()[0..tag_length] {\n                b\"?\" => {\n                    self.writer.write_all(b\"Could not decode tag name\")?;\n                }\n                b\"bin\" => {\n                    self.write_bin_name(parser)?;\n                }\n                b\"version\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.version.unwrap_or(\"unknown version\")\n                    )?;\n                }\n                b\"author\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.author.unwrap_or(\"unknown author\")\n                    )?;\n                }\n                b\"about\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.about.unwrap_or(\"unknown about\")\n                    )?;\n                }\n                b\"long-about\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.long_about.unwrap_or(\"unknown about\")\n                    )?;\n                }\n                b\"usage\" => {\n                    write!(self.writer, \"{}\", usage::create_usage_no_title(parser, &[]))?;\n                }\n                b\"all-args\" => {\n                    self.write_all_args(parser)?;\n                }\n                b\"unified\" => {\n                    let opts_flags = parser\n                        .flags()\n                        .map(as_arg_trait)\n                        .chain(parser.opts().map(as_arg_trait));\n                    self.write_args(opts_flags)?;\n                }\n                b\"flags\" => {\n                    self.write_args(parser.flags().map(as_arg_trait))?;\n                }\n                b\"options\" => {\n                    self.write_args(parser.opts().map(as_arg_trait))?;\n                }\n                b\"positionals\" => {\n                    self.write_args(parser.positionals().map(as_arg_trait))?;\n                }\n                b\"subcommands\" => {\n                    self.write_subcommands(parser)?;\n                }\n                b\"after-help\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.more_help.unwrap_or(\"unknown after-help\")\n                    )?;\n                }\n                b\"before-help\" => {\n                    write!(\n                        self.writer,\n                        \"{}\",\n                        parser.meta.pre_help.unwrap_or(\"unknown before-help\")\n                    )?;\n                }\n                // Unknown tag, write it back.\n                r => {\n                    self.writer.write_all(b\"{\")?;\n                    self.writer.write_all(r)?;\n                    self.writer.write_all(b\"}\")?;\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::Help::<'a>::write_version":["/// Writes version of a Parser Object to the wrapped stream.\nfn write_version(&mut self, parser: &Parser) -> io::Result<()>{\n        debugln!(\"Help::write_version;\");\n        write!(self.writer, \"{}\", parser.meta.version.unwrap_or(\"\"))?;\n        Ok(())\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::as_arg_trait":["fn as_arg_trait<'a, 'b, T: ArgWithOrder<'a, 'b>>(x: &T) -> &ArgWithOrder<'a, 'b>{\n    x\n}","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::copy_and_capture":["/// Copies the contents of a reader into a writer until a {tag} is found,\n/// copying the tag content to a buffer and returning its size.\n/// In addition to errors, there are three possible outputs:\n///   - `None`: The reader was consumed.\n///   - `Some(Ok(0))`: No tag was captured but the reader still contains data.\n///   - `Some(Ok(length>0))`: a tag with `length` was captured to the `tag_buffer`.\nfn copy_and_capture<R: Read, W: Write>(\n    r: &mut R,\n    w: &mut W,\n    tag_buffer: &mut Cursor<Vec<u8>>,\n) -> Option<io::Result<usize>>{\n    use self::CopyUntilResult::*;\n    debugln!(\"copy_and_capture;\");\n\n    // Find the opening byte.\n    match copy_until(r, w, b'{') {\n        // The end of the reader was reached without finding the opening tag.\n        // (either with or without having copied data to the writer)\n        // Return None indicating that we are done.\n        ReaderEmpty | DelimiterNotFound(_) => None,\n\n        // Something went wrong.\n        ReadError(e) | WriteError(e) => Some(Err(e)),\n\n        // The opening byte was found.\n        // (either with or without having copied data to the writer)\n        DelimiterFound(_) => {\n            // Lets reset the buffer first and find out how long it is.\n            tag_buffer.set_position(0);\n            let buffer_size = tag_buffer.get_ref().len();\n\n            // Find the closing byte,limiting the reader to the length of the buffer.\n            let mut rb = r.take(buffer_size as u64);\n            match copy_until(&mut rb, tag_buffer, b'}') {\n                // We were already at the end of the reader.\n                // Return None indicating that we are done.\n                ReaderEmpty => None,\n\n                // The closing tag was found.\n                // Return the tag_length.\n                DelimiterFound(tag_length) => Some(Ok(tag_length)),\n\n                // The end of the reader was found without finding the closing tag.\n                // Write the opening byte and captured text to the writer.\n                // Return 0 indicating that nothing was captured but the reader still contains data.\n                DelimiterNotFound(not_tag_length) => match w.write(b\"{\") {\n                    Err(e) => Some(Err(e)),\n                    _ => match w.write(&tag_buffer.get_ref()[0..not_tag_length]) {\n                        Err(e) => Some(Err(e)),\n                        _ => Some(Ok(0)),\n                    },\n                },\n\n                ReadError(e) | WriteError(e) => Some(Err(e)),\n            }\n        }\n    }\n}","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::copy_until":["/// Copies the contents of a reader into a writer until a delimiter byte is found.\n/// On success, the total number of bytes that were\n/// copied from reader to writer is returned.\nfn copy_until<R: Read, W: Write>(r: &mut R, w: &mut W, delimiter_byte: u8) -> CopyUntilResult{\n    debugln!(\"copy_until;\");\n\n    let mut count = 0;\n    for wb in r.bytes() {\n        match wb {\n            Ok(b) => {\n                if b == delimiter_byte {\n                    return CopyUntilResult::DelimiterFound(count);\n                }\n                match w.write(&[b]) {\n                    Ok(c) => count += c,\n                    Err(e) => return CopyUntilResult::WriteError(e),\n                }\n            }\n            Err(e) => return CopyUntilResult::ReadError(e),\n        }\n    }\n    if count > 0 {\n        CopyUntilResult::DelimiterNotFound(count)\n    } else {\n        CopyUntilResult::ReaderEmpty\n    }\n}","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::should_show_arg":["fn should_show_arg(use_long: bool, arg: &ArgWithOrder) -> bool{\n    if arg.is_set(ArgSettings::Hidden) {\n        return false;\n    }\n\n    (!arg.is_set(ArgSettings::HiddenLongHelp) && use_long)\n        || (!arg.is_set(ArgSettings::HiddenShortHelp) && !use_long)\n        || arg.is_set(ArgSettings::NextLineHelp)\n}","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::str_width":["fn str_width(s: &str) -> usize{\n    UnicodeWidthStr::width(s)\n}","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::term_size::dimensions":["pub fn dimensions() -> Option<(usize, usize)>{\n        None\n    }","Real(LocalPath(\"src/app/help.rs\"))"],"app::help::wrap_help":["fn wrap_help(help: &str, avail_chars: usize) -> String{\n    let wrapper = textwrap::Wrapper::new(avail_chars).break_words(false);\n    help.lines()\n        .map(|line| wrapper.fill(line))\n        .collect::<Vec<String>>()\n        .join(\"\\n\")\n}","Real(LocalPath(\"src/app/help.rs\"))"],"app::meta::AppMeta":["#[doc(hidden)]\n#[allow(missing_debug_implementations)]\npub struct AppMeta<'b> {\n    pub name: String,\n    pub bin_name: Option<String>,\n    pub author: Option<&'b str>,\n    pub version: Option<&'b str>,\n    pub long_version: Option<&'b str>,\n    pub about: Option<&'b str>,\n    pub long_about: Option<&'b str>,\n    pub more_help: Option<&'b str>,\n    pub pre_help: Option<&'b str>,\n    pub aliases: Option<Vec<(&'b str, bool)>>, // (name, visible)\n    pub usage_str: Option<&'b str>,\n    pub usage: Option<String>,\n    pub help_str: Option<&'b str>,\n    pub disp_ord: usize,\n    pub term_w: Option<usize>,\n    pub max_w: Option<usize>,\n    pub template: Option<&'b str>,\n}","Real(LocalPath(\"src/app/meta.rs\"))"],"app::meta::AppMeta::<'b>::new":["pub fn new() -> Self{\n        Default::default()\n    }","Real(LocalPath(\"src/app/meta.rs\"))"],"app::meta::AppMeta::<'b>::with_name":["pub fn with_name(s: String) -> Self{\n        AppMeta {\n            name: s,\n            disp_ord: 999,\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"src/app/meta.rs\"))"],"app::parser::ParseResult":["#[doc(hidden)]\npub enum ParseResult<'a> {\n    Flag,\n    Opt(&'a str),\n    Pos(&'a str),\n    MaybeHyphenValue,\n    MaybeNegNum,\n    NotFound,\n    ValuesDone,\n}","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser":["#[allow(missing_debug_implementations)]\n#[doc(hidden)]\npub struct Parser<'a, 'b>\nwhere\n    'a: 'b,\n{\n    pub meta: AppMeta<'b>,\n    settings: AppFlags,\n    pub g_settings: AppFlags,\n    pub flags: Vec<FlagBuilder<'a, 'b>>,\n    pub opts: Vec<OptBuilder<'a, 'b>>,\n    pub positionals: VecMap<PosBuilder<'a, 'b>>,\n    pub subcommands: Vec<App<'a, 'b>>,\n    pub groups: Vec<ArgGroup<'a>>,\n    pub global_args: Vec<Arg<'a, 'b>>,\n    pub required: Vec<&'a str>,\n    pub r_ifs: Vec<(&'a str, &'b str, &'a str)>,\n    pub overrides: Vec<(&'b str, &'a str)>,\n    help_short: Option<char>,\n    version_short: Option<char>,\n    cache: Option<&'a str>,\n    pub help_message: Option<&'a str>,\n    pub version_message: Option<&'a str>,\n    cur_idx: Cell<usize>,\n}","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::_help":["fn _help(&self, mut use_long: bool) -> Error{\n        debugln!(\"Parser::_help: use_long={:?}\", use_long);\n        use_long = use_long && self.use_long_help();\n        let mut buf = vec![];\n        match Help::write_parser_help(&mut buf, self, use_long) {\n            Err(e) => e,\n            _ => Error {\n                message: String::from_utf8(buf).unwrap_or_default(),\n                kind: ErrorKind::HelpDisplayed,\n                info: None,\n            },\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::_version":["fn _version(&self, use_long: bool) -> Error{\n        debugln!(\"Parser::_version: \");\n        let out = io::stdout();\n        let mut buf_w = BufWriter::new(out.lock());\n        match self.print_version(&mut buf_w, use_long) {\n            Err(e) => e,\n            _ => Error {\n                message: String::new(),\n                kind: ErrorKind::VersionDisplayed,\n                info: None,\n            },\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::add_arg":["pub fn add_arg(&mut self, a: Arg<'a, 'b>){\n        // if it's global we have to clone anyways\n        if a.is_set(ArgSettings::Global) {\n            return self.add_arg_ref(&a);\n        }\n        debug_assert!(self.debug_asserts(&a));\n        self.add_conditional_reqs(&a);\n        self.add_arg_groups(&a);\n        self.add_reqs(&a);\n        self.implied_settings(&a);\n        if a.index.is_some() || (a.s.short.is_none() && a.s.long.is_none()) {\n            let i = if a.index.is_none() {\n                (self.positionals.len() + 1)\n            } else {\n                a.index.unwrap() as usize\n            };\n            self.positionals\n                .insert(i, PosBuilder::from_arg(a, i as u64));\n        } else if a.is_set(ArgSettings::TakesValue) {\n            let mut ob = OptBuilder::from(a);\n            ob.s.unified_ord = self.flags.len() + self.opts.len();\n            self.opts.push(ob);\n        } else {\n            let mut fb = FlagBuilder::from(a);\n            fb.s.unified_ord = self.flags.len() + self.opts.len();\n            self.flags.push(fb);\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::add_arg_groups":["#[inline]\nfn add_arg_groups(&mut self, a: &Arg<'a, 'b>){\n        if let Some(ref grps) = a.b.groups {\n            for g in grps {\n                let mut found = false;\n                if let Some(ref mut ag) = self.groups.iter_mut().find(|grp| &grp.name == g) {\n                    ag.args.push(a.b.name);\n                    found = true;\n                }\n                if !found {\n                    let mut ag = ArgGroup::with_name(g);\n                    ag.args.push(a.b.name);\n                    self.groups.push(ag);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::add_arg_ref":["pub fn add_arg_ref(&mut self, a: &Arg<'a, 'b>){\n        debug_assert!(self.debug_asserts(a));\n        self.add_conditional_reqs(a);\n        self.add_arg_groups(a);\n        self.add_reqs(a);\n        self.implied_settings(a);\n        if a.index.is_some() || (a.s.short.is_none() && a.s.long.is_none()) {\n            let i = if a.index.is_none() {\n                (self.positionals.len() + 1)\n            } else {\n                a.index.unwrap() as usize\n            };\n            let pb = PosBuilder::from_arg_ref(a, i as u64);\n            self.positionals.insert(i, pb);\n        } else if a.is_set(ArgSettings::TakesValue) {\n            let mut ob = OptBuilder::from(a);\n            ob.s.unified_ord = self.flags.len() + self.opts.len();\n            self.opts.push(ob);\n        } else {\n            let mut fb = FlagBuilder::from(a);\n            fb.s.unified_ord = self.flags.len() + self.opts.len();\n            self.flags.push(fb);\n        }\n        if a.is_set(ArgSettings::Global) {\n            self.global_args.push(a.into());\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::add_conditional_reqs":["#[inline]\nfn add_conditional_reqs(&mut self, a: &Arg<'a, 'b>){\n        if let Some(ref r_ifs) = a.r_ifs {\n            for &(arg, val) in r_ifs {\n                self.r_ifs.push((arg, val, a.b.name));\n            }\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::add_defaults":["pub fn add_defaults(&mut self, matcher: &mut ArgMatcher<'a>) -> ClapResult<()>{\n        debugln!(\"Parser::add_defaults;\");\n        macro_rules! add_val {\n            (@default $_self:ident, $a:ident, $m:ident) => {\n                if let Some(ref val) = $a.v.default_val {\n                    debugln!(\"Parser::add_defaults:iter:{}: has default vals\", $a.b.name);\n                    if $m.get($a.b.name).map(|ma| ma.vals.len()).map(|len| len == 0).unwrap_or(false) {\n                        debugln!(\"Parser::add_defaults:iter:{}: has no user defined vals\", $a.b.name);\n                        $_self.add_val_to_arg($a, OsStr::new(val), $m)?;\n\n                        if $_self.cache.map_or(true, |name| name != $a.name()) {\n                            $_self.cache = Some($a.name());\n                        }\n                    } else if $m.get($a.b.name).is_some() {\n                        debugln!(\"Parser::add_defaults:iter:{}: has user defined vals\", $a.b.name);\n                    } else {\n                        debugln!(\"Parser::add_defaults:iter:{}: wasn't used\", $a.b.name);\n\n                        $_self.add_val_to_arg($a, OsStr::new(val), $m)?;\n\n                        if $_self.cache.map_or(true, |name| name != $a.name()) {\n                            $_self.cache = Some($a.name());\n                        }\n                    }\n                } else {\n                    debugln!(\"Parser::add_defaults:iter:{}: doesn't have default vals\", $a.b.name);\n                }\n            };\n            ($_self:ident, $a:ident, $m:ident) => {\n                if let Some(ref vm) = $a.v.default_vals_ifs {\n                    sdebugln!(\" has conditional defaults\");\n                    let mut done = false;\n                    if $m.get($a.b.name).is_none() {\n                        for &(arg, val, default) in vm.values() {\n                            let add = if let Some(a) = $m.get(arg) {\n                                if let Some(v) = val {\n                                    a.vals.iter().any(|value| v == value)\n                                } else {\n                                    true\n                                }\n                            } else {\n                                false\n                            };\n                            if add {\n                                $_self.add_val_to_arg($a, OsStr::new(default), $m)?;\n                                if $_self.cache.map_or(true, |name| name != $a.name()) {\n                                    $_self.cache = Some($a.name());\n                                }\n                                done = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if done {\n                        continue; // outer loop (outside macro)\n                    }\n                } else {\n                    sdebugln!(\" doesn't have conditional defaults\");\n                }\n                add_val!(@default $_self, $a, $m)\n            };\n        }\n\n        for o in &self.opts {\n            debug!(\"Parser::add_defaults:iter:{}:\", o.b.name);\n            add_val!(self, o, matcher);\n        }\n        for p in self.positionals.values() {\n            debug!(\"Parser::add_defaults:iter:{}:\", p.b.name);\n            add_val!(self, p, matcher);\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::add_env":["pub fn add_env(&mut self, matcher: &mut ArgMatcher<'a>) -> ClapResult<()>{\n        macro_rules! add_val {\n            ($_self:ident, $a:ident, $m:ident) => {\n                if let Some(ref val) = $a.v.env {\n                    if $m\n                        .get($a.b.name)\n                        .map(|ma| ma.vals.len())\n                        .map(|len| len == 0)\n                        .unwrap_or(false)\n                    {\n                        if let Some(ref val) = val.1 {\n                            $_self.add_val_to_arg($a, OsStr::new(val), $m)?;\n\n                            if $_self.cache.map_or(true, |name| name != $a.name()) {\n                                $_self.cache = Some($a.name());\n                            }\n                        }\n                    } else {\n                        if let Some(ref val) = val.1 {\n                            $_self.add_val_to_arg($a, OsStr::new(val), $m)?;\n\n                            if $_self.cache.map_or(true, |name| name != $a.name()) {\n                                $_self.cache = Some($a.name());\n                            }\n                        }\n                    }\n                }\n            };\n        }\n\n        for o in &self.opts {\n            add_val!(self, o, matcher);\n        }\n        for p in self.positionals.values() {\n            add_val!(self, p, matcher);\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::add_group":["pub fn add_group(&mut self, group: ArgGroup<'a>){\n        if group.required {\n            self.required.push(group.name);\n            if let Some(ref reqs) = group.requires {\n                self.required.extend_from_slice(reqs);\n            }\n            //            if let Some(ref bl) = group.conflicts {\n            //                self.blacklist.extend_from_slice(bl);\n            //            }\n        }\n        if self.groups.iter().any(|g| g.name == group.name) {\n            let grp = self\n                .groups\n                .iter_mut()\n                .find(|g| g.name == group.name)\n                .expect(INTERNAL_ERROR_MSG);\n            grp.args.extend_from_slice(&group.args);\n            grp.requires = group.requires.clone();\n            grp.conflicts = group.conflicts.clone();\n            grp.required = group.required;\n        } else {\n            self.groups.push(group);\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::add_reqs":["#[inline]\nfn add_reqs(&mut self, a: &Arg<'a, 'b>){\n        if a.is_set(ArgSettings::Required) {\n            // If the arg is required, add all it's requirements to master required list\n            self.required.push(a.b.name);\n            if let Some(ref areqs) = a.b.requires {\n                for name in areqs\n                    .iter()\n                    .filter(|&&(val, _)| val.is_none())\n                    .map(|&(_, name)| name)\n                {\n                    self.required.push(name);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::add_single_val_to_arg":["fn add_single_val_to_arg<A>(\n        &self,\n        arg: &A,\n        v: &OsStr,\n        matcher: &mut ArgMatcher<'a>,\n    ) -> ClapResult<ParseResult<'a>>\n    where\n        A: AnyArg<'a, 'b> + Display,{\n        debugln!(\"Parser::add_single_val_to_arg;\");\n        debugln!(\"Parser::add_single_val_to_arg: adding val...{:?}\", v);\n\n        // update the current index because each value is a distinct index to clap\n        self.cur_idx.set(self.cur_idx.get() + 1);\n\n        // @TODO @docs @p4: docs for indices should probably note that a terminator isn't a value\n        // and therefore not reported in indices\n        if let Some(t) = arg.val_terminator() {\n            if t == v {\n                return Ok(ParseResult::ValuesDone);\n            }\n        }\n\n        matcher.add_val_to(arg.name(), v);\n        matcher.add_index_to(arg.name(), self.cur_idx.get());\n\n        // Increment or create the group \"args\"\n        if let Some(grps) = self.groups_for_arg(arg.name()) {\n            for grp in grps {\n                matcher.add_val_to(&*grp, v);\n            }\n        }\n\n        if matcher.needs_more_vals(arg) {\n            return Ok(ParseResult::Opt(arg.name()));\n        }\n        Ok(ParseResult::ValuesDone)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::add_subcommand":["pub fn add_subcommand(&mut self, mut subcmd: App<'a, 'b>){\n        debugln!(\n            \"Parser::add_subcommand: term_w={:?}, name={}\",\n            self.meta.term_w,\n            subcmd.p.meta.name\n        );\n        subcmd.p.meta.term_w = self.meta.term_w;\n        if subcmd.p.meta.name == \"help\" {\n            self.unset(AS::NeedsSubcommandHelp);\n        }\n\n        self.subcommands.push(subcmd);\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::add_val_to_arg":["fn add_val_to_arg<A>(\n        &self,\n        arg: &A,\n        val: &OsStr,\n        matcher: &mut ArgMatcher<'a>,\n    ) -> ClapResult<ParseResult<'a>>\n    where\n        A: AnyArg<'a, 'b> + Display,{\n        debugln!(\"Parser::add_val_to_arg; arg={}, val={:?}\", arg.name(), val);\n        debugln!(\n            \"Parser::add_val_to_arg; trailing_vals={:?}, DontDelimTrailingVals={:?}\",\n            self.is_set(AS::TrailingValues),\n            self.is_set(AS::DontDelimitTrailingValues)\n        );\n        if !(self.is_set(AS::TrailingValues) && self.is_set(AS::DontDelimitTrailingValues)) {\n            if let Some(delim) = arg.val_delim() {\n                if val.is_empty() {\n                    Ok(self.add_single_val_to_arg(arg, val, matcher)?)\n                } else {\n                    let mut iret = ParseResult::ValuesDone;\n                    for v in val.split(delim as u32 as u8) {\n                        iret = self.add_single_val_to_arg(arg, v, matcher)?;\n                    }\n                    // If there was a delimiter used, we're not looking for more values\n                    if val.contains_byte(delim as u32 as u8)\n                        || arg.is_set(ArgSettings::RequireDelimiter)\n                    {\n                        iret = ParseResult::ValuesDone;\n                    }\n                    Ok(iret)\n                }\n            } else {\n                self.add_single_val_to_arg(arg, val, matcher)\n            }\n        } else {\n            self.add_single_val_to_arg(arg, val, matcher)\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::app_debug_asserts":["#[inline]\nfn app_debug_asserts(&self) -> bool{\n        assert!(self.verify_positionals());\n        let should_err = self.groups.iter().all(|g| {\n            g.args.iter().all(|arg| {\n                (self.flags.iter().any(|f| &f.b.name == arg)\n                    || self.opts.iter().any(|o| &o.b.name == arg)\n                    || self.positionals.values().any(|p| &p.b.name == arg)\n                    || self.groups.iter().any(|g| &g.name == arg))\n            })\n        });\n        let g = self.groups.iter().find(|g| {\n            g.args.iter().any(|arg| {\n                !(self.flags.iter().any(|f| &f.b.name == arg)\n                    || self.opts.iter().any(|o| &o.b.name == arg)\n                    || self.positionals.values().any(|p| &p.b.name == arg)\n                    || self.groups.iter().any(|g| &g.name == arg))\n            })\n        });\n        assert!(\n            should_err,\n            \"The group '{}' contains the arg '{}' that doesn't actually exist.\",\n            g.unwrap().name,\n            g.unwrap()\n                .args\n                .iter()\n                .find(|arg| !(self.flags.iter().any(|f| &&f.b.name == arg)\n                    || self.opts.iter().any(|o| &&o.b.name == arg)\n                    || self.positionals.values().any(|p| &&p.b.name == arg)\n                    || self.groups.iter().any(|g| &&g.name == arg)))\n                .unwrap()\n        );\n        true\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::arg_names_in_group":["pub fn arg_names_in_group(&self, group: &str) -> Vec<&'a str>{\n        let mut g_vec = vec![];\n        let mut args = vec![];\n\n        for n in &self\n            .groups\n            .iter()\n            .find(|g| g.name == group)\n            .expect(INTERNAL_ERROR_MSG)\n            .args\n        {\n            if self.groups.iter().any(|g| g.name == *n) {\n                args.extend(self.arg_names_in_group(n));\n                g_vec.push(*n);\n            } else if !args.contains(n) {\n                args.push(*n);\n            }\n        }\n\n        args.iter().map(|s| *s).collect()\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::args_in_group":["pub fn args_in_group(&self, group: &str) -> Vec<String>{\n        debug_assert!(self.app_debug_asserts());\n\n        let mut g_vec = vec![];\n        let mut args = vec![];\n\n        for n in &self\n            .groups\n            .iter()\n            .find(|g| g.name == group)\n            .expect(INTERNAL_ERROR_MSG)\n            .args\n        {\n            if let Some(f) = self.flags.iter().find(|f| &f.b.name == n) {\n                args.push(f.to_string());\n            } else if let Some(f) = self.opts.iter().find(|o| &o.b.name == n) {\n                args.push(f.to_string());\n            } else if let Some(p) = self.positionals.values().find(|p| &p.b.name == n) {\n                args.push(p.b.name.to_owned());\n            } else {\n                g_vec.push(*n);\n            }\n        }\n\n        for av in g_vec.iter().map(|g| self.args_in_group(g)) {\n            args.extend(av);\n        }\n        args.dedup();\n        args.iter().map(ToOwned::to_owned).collect()\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::build_bin_names":["fn build_bin_names(&mut self){\n        debugln!(\"Parser::build_bin_names;\");\n        for sc in &mut self.subcommands {\n            debug!(\"Parser::build_bin_names:iter: bin_name set...\");\n            if sc.p.meta.bin_name.is_none() {\n                sdebugln!(\"No\");\n                let bin_name = format!(\n                    \"{}{}{}\",\n                    self.meta\n                        .bin_name\n                        .as_ref()\n                        .unwrap_or(&self.meta.name.clone()),\n                    if self.meta.bin_name.is_some() {\n                        \" \"\n                    } else {\n                        \"\"\n                    },\n                    &*sc.p.meta.name\n                );\n                debugln!(\n                    \"Parser::build_bin_names:iter: Setting bin_name of {} to {}\",\n                    self.meta.name,\n                    bin_name\n                );\n                sc.p.meta.bin_name = Some(bin_name);\n            } else {\n                sdebugln!(\"yes ({:?})\", sc.p.meta.bin_name);\n            }\n            debugln!(\n                \"Parser::build_bin_names:iter: Calling build_bin_names from...{}\",\n                sc.p.meta.name\n            );\n            sc.p.build_bin_names();\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::check_for_help_and_version_char":["fn check_for_help_and_version_char(&self, arg: char) -> ClapResult<()>{\n        debugln!(\"Parser::check_for_help_and_version_char;\");\n        debug!(\n            \"Parser::check_for_help_and_version_char: Checking if -{} is help or version...\",\n            arg\n        );\n        if let Some(h) = self.help_short {\n            if arg == h && self.is_set(AS::NeedsLongHelp) {\n                sdebugln!(\"Help\");\n                return Err(self._help(false));\n            }\n        }\n        if let Some(v) = self.version_short {\n            if arg == v && self.is_set(AS::NeedsLongVersion) {\n                sdebugln!(\"Version\");\n                return Err(self._version(false));\n            }\n        }\n        sdebugln!(\"Neither\");\n        Ok(())\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::check_for_help_and_version_str":["fn check_for_help_and_version_str(&self, arg: &OsStr) -> ClapResult<()>{\n        debugln!(\"Parser::check_for_help_and_version_str;\");\n        debug!(\n            \"Parser::check_for_help_and_version_str: Checking if --{} is help or version...\",\n            arg.to_str().unwrap()\n        );\n        if arg == \"help\" && self.is_set(AS::NeedsLongHelp) {\n            sdebugln!(\"Help\");\n            return Err(self._help(true));\n        }\n        if arg == \"version\" && self.is_set(AS::NeedsLongVersion) {\n            sdebugln!(\"Version\");\n            return Err(self._version(true));\n        }\n        sdebugln!(\"Neither\");\n\n        Ok(())\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::color":["#[doc(hidden)]\npub fn color(&self) -> ColorWhen{\n        debugln!(\"Parser::color;\");\n        debug!(\"Parser::color: Color setting...\");\n        if self.is_set(AS::ColorNever) {\n            sdebugln!(\"Never\");\n            ColorWhen::Never\n        } else if self.is_set(AS::ColorAlways) {\n            sdebugln!(\"Always\");\n            ColorWhen::Always\n        } else {\n            sdebugln!(\"Auto\");\n            ColorWhen::Auto\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::contains_long":["#[inline]\nfn contains_long(&self, l: &str) -> bool{\n        longs!(self).any(|al| al == &l)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::contains_short":["#[inline]\nfn contains_short(&self, s: char) -> bool{\n        shorts!(self).any(|arg_s| arg_s == &s)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::create_help_and_version":["pub fn create_help_and_version(&mut self){\n        debugln!(\"Parser::create_help_and_version;\");\n        // name is \"hclap_help\" because flags are sorted by name\n        if !self.is_set(AS::DisableHelpFlags) && !self.contains_long(\"help\") {\n            debugln!(\"Parser::create_help_and_version: Building --help\");\n            if self.help_short.is_none() && !self.contains_short('h') {\n                self.help_short = Some('h');\n            }\n            let arg = FlagBuilder {\n                b: Base {\n                    name: \"hclap_help\",\n                    help: self.help_message.or(Some(\"Prints help information\")),\n                    ..Default::default()\n                },\n                s: Switched {\n                    short: self.help_short,\n                    long: Some(\"help\"),\n                    ..Default::default()\n                },\n            };\n            self.flags.push(arg);\n        }\n        if !self.is_set(AS::DisableVersion) && !self.contains_long(\"version\") {\n            debugln!(\"Parser::create_help_and_version: Building --version\");\n            if self.version_short.is_none() && !self.contains_short('V') {\n                self.version_short = Some('V');\n            }\n            // name is \"vclap_version\" because flags are sorted by name\n            let arg = FlagBuilder {\n                b: Base {\n                    name: \"vclap_version\",\n                    help: self.version_message.or(Some(\"Prints version information\")),\n                    ..Default::default()\n                },\n                s: Switched {\n                    short: self.version_short,\n                    long: Some(\"version\"),\n                    ..Default::default()\n                },\n            };\n            self.flags.push(arg);\n        }\n        if !self.subcommands.is_empty()\n            && !self.is_set(AS::DisableHelpSubcommand)\n            && self.is_set(AS::NeedsSubcommandHelp)\n        {\n            debugln!(\"Parser::create_help_and_version: Building help\");\n            self.subcommands.push(\n                App::new(\"help\")\n                    .about(\"Prints this message or the help of the given subcommand(s)\"),\n            );\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::debug_asserts":["#[inline]\nfn debug_asserts(&self, a: &Arg) -> bool{\n        assert!(\n            !arg_names!(self).any(|name| name == a.b.name),\n            format!(\"Non-unique argument name: {} is already in use\", a.b.name)\n        );\n        if let Some(l) = a.s.long {\n            assert!(\n                !self.contains_long(l),\n                \"Argument long must be unique\\n\\n\\t--{} is already in use\",\n                l\n            );\n        }\n        if let Some(s) = a.s.short {\n            assert!(\n                !self.contains_short(s),\n                \"Argument short must be unique\\n\\n\\t-{} is already in use\",\n                s\n            );\n        }\n        let i = if a.index.is_none() {\n            (self.positionals.len() + 1)\n        } else {\n            a.index.unwrap() as usize\n        };\n        assert!(\n            !self.positionals.contains_key(i),\n            \"Argument \\\"{}\\\" has the same index as another positional \\\n             argument\\n\\n\\tPerhaps try .multiple(true) to allow one positional argument \\\n             to take multiple values\",\n            a.b.name\n        );\n        assert!(\n            !(a.is_set(ArgSettings::Required) && a.is_set(ArgSettings::Global)),\n            \"Global arguments cannot be required.\\n\\n\\t'{}' is marked as \\\n             global and required\",\n            a.b.name\n        );\n        if a.b.is_set(ArgSettings::Last) {\n            assert!(\n                !self\n                    .positionals\n                    .values()\n                    .any(|p| p.b.is_set(ArgSettings::Last)),\n                \"Only one positional argument may have last(true) set. Found two.\"\n            );\n            assert!(a.s.long.is_none(),\n                    \"Flags or Options may not have last(true) set. {} has both a long and last(true) set.\",\n                    a.b.name);\n            assert!(a.s.short.is_none(),\n                    \"Flags or Options may not have last(true) set. {} has both a short and last(true) set.\",\n                    a.b.name);\n        }\n        true\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::derive_display_order":["pub fn derive_display_order(&mut self){\n        if self.is_set(AS::DeriveDisplayOrder) {\n            let unified = self.is_set(AS::UnifiedHelpMessage);\n            for (i, o) in self\n                .opts\n                .iter_mut()\n                .enumerate()\n                .filter(|&(_, ref o)| o.s.disp_ord == 999)\n            {\n                o.s.disp_ord = if unified { o.s.unified_ord } else { i };\n            }\n            for (i, f) in self\n                .flags\n                .iter_mut()\n                .enumerate()\n                .filter(|&(_, ref f)| f.s.disp_ord == 999)\n            {\n                f.s.disp_ord = if unified { f.s.unified_ord } else { i };\n            }\n            for (i, sc) in &mut self\n                .subcommands\n                .iter_mut()\n                .enumerate()\n                .filter(|&(_, ref sc)| sc.p.meta.disp_ord == 999)\n            {\n                sc.p.meta.disp_ord = i;\n            }\n        }\n        for sc in &mut self.subcommands {\n            sc.p.derive_display_order();\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::did_you_mean_error":["fn did_you_mean_error(\n        &self,\n        arg: &str,\n        matcher: &mut ArgMatcher<'a>,\n        args_rest: &[&str],\n    ) -> ClapResult<()>{\n        // Didn't match a flag or option\n        let suffix =\n            suggestions::did_you_mean_flag_suffix(arg, &args_rest, longs!(self), &self.subcommands);\n\n        // Add the arg to the matches to build a proper usage string\n        if let Some(name) = suffix.1 {\n            if let Some(opt) = find_opt_by_long!(self, name) {\n                self.groups_for_arg(&*opt.b.name)\n                    .and_then(|grps| Some(matcher.inc_occurrences_of(&*grps)));\n                matcher.insert(&*opt.b.name);\n            } else if let Some(flg) = find_flag_by_long!(self, name) {\n                self.groups_for_arg(&*flg.b.name)\n                    .and_then(|grps| Some(matcher.inc_occurrences_of(&*grps)));\n                matcher.insert(&*flg.b.name);\n            }\n        }\n\n        let used_arg = format!(\"--{}\", arg);\n        Err(Error::unknown_argument(\n            &*used_arg,\n            &*suffix.0,\n            &*usage::create_error_usage(self, matcher, None),\n            self.color(),\n        ))\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::find_any_arg":["pub fn find_any_arg(&self, name: &str) -> Option<&AnyArg<'a, 'b>>{\n        if let Some(f) = find_by_name!(self, name, flags, iter) {\n            return Some(f);\n        }\n        if let Some(o) = find_by_name!(self, name, opts, iter) {\n            return Some(o);\n        }\n        if let Some(p) = find_by_name!(self, name, positionals, values) {\n            return Some(p);\n        }\n        None\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::find_subcommand":["pub fn find_subcommand(&'b self, sc: &str) -> Option<&'b App<'a, 'b>>{\n        debugln!(\"Parser::find_subcommand: sc={}\", sc);\n        debugln!(\n            \"Parser::find_subcommand: Currently in Parser...{}\",\n            self.meta.bin_name.as_ref().unwrap()\n        );\n        for s in &self.subcommands {\n            if s.p.is_bin_name(sc) {\n                return Some(s);\n            }\n            // XXX: why do we split here?\n            // isn't `sc` supposed to be single word already?\n            let last = sc.split(' ').rev().next().expect(INTERNAL_ERROR_MSG);\n            if s.p.is_alias(last) {\n                return Some(s);\n            }\n\n            if let Some(app) = s.p.find_subcommand(sc) {\n                return Some(app);\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::flags":["pub fn flags(&self) -> Iter<FlagBuilder<'a, 'b>>{\n        self.flags.iter()\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::gen_completions":["pub fn gen_completions(&mut self, for_shell: Shell, od: OsString){\n        use std::error::Error;\n\n        let out_dir = PathBuf::from(od);\n        let name = &*self.meta.bin_name.as_ref().unwrap().clone();\n        let file_name = match for_shell {\n            Shell::Bash => format!(\"{}.bash\", name),\n            Shell::Fish => format!(\"{}.fish\", name),\n            Shell::Zsh => format!(\"_{}\", name),\n            Shell::PowerShell => format!(\"_{}.ps1\", name),\n            Shell::Elvish => format!(\"{}.elv\", name),\n        };\n\n        let mut file = match File::create(out_dir.join(file_name)) {\n            Err(why) => panic!(\"couldn't create completion file: {}\", why.description()),\n            Ok(file) => file,\n        };\n        self.gen_completions_to(for_shell, &mut file)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::gen_completions_to":["pub fn gen_completions_to<W: Write>(&mut self, for_shell: Shell, buf: &mut W){\n        if !self.is_set(AS::Propagated) {\n            self.propagate_help_version();\n            self.build_bin_names();\n            self.propagate_globals();\n            self.propagate_settings();\n            self.set(AS::Propagated);\n        }\n\n        ComplGen::new(self).generate(for_shell, buf)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::get_matches_with":["pub fn get_matches_with<I, T>(\n        &mut self,\n        matcher: &mut ArgMatcher<'a>,\n        it: &mut Peekable<I>,\n    ) -> ClapResult<()>\n    where\n        I: Iterator<Item = T>,\n        T: Into<OsString> + Clone,{\n        debugln!(\"Parser::get_matches_with;\");\n        // Verify all positional assertions pass\n        debug_assert!(self.app_debug_asserts());\n        if self.positionals.values().any(|a| {\n            a.b.is_set(ArgSettings::Multiple) && (a.index as usize != self.positionals.len())\n        }) && self\n            .positionals\n            .values()\n            .last()\n            .map_or(false, |p| !p.is_set(ArgSettings::Last))\n        {\n            self.settings.set(AS::LowIndexMultiplePositional);\n        }\n        let has_args = self.has_args();\n\n        // Next we create the `--help` and `--version` arguments and add them if\n        // necessary\n        self.create_help_and_version();\n\n        let mut subcmd_name: Option<String> = None;\n        let mut needs_val_of: ParseResult<'a> = ParseResult::NotFound;\n        let mut pos_counter = 1;\n        let mut sc_is_external = false;\n        while let Some(arg) = it.next() {\n            let arg_os = arg.into();\n            debugln!(\n                \"Parser::get_matches_with: Begin parsing '{:?}' ({:?})\",\n                arg_os,\n                &*arg_os.as_bytes()\n            );\n\n            self.unset(AS::ValidNegNumFound);\n            // Is this a new argument, or values from a previous option?\n            let starts_new_arg = self.is_new_arg(&arg_os, needs_val_of);\n            if !self.is_set(AS::TrailingValues)\n                && arg_os.starts_with(b\"--\")\n                && arg_os.len() == 2\n                && starts_new_arg\n            {\n                debugln!(\"Parser::get_matches_with: setting TrailingVals=true\");\n                self.set(AS::TrailingValues);\n                continue;\n            }\n\n            // Has the user already passed '--'? Meaning only positional args follow\n            if !self.is_set(AS::TrailingValues) {\n                // Does the arg match a subcommand name, or any of it's aliases (if defined)\n                {\n                    match needs_val_of {\n                        ParseResult::Opt(_) | ParseResult::Pos(_) => (),\n                        _ => {\n                            let (is_match, sc_name) = self.possible_subcommand(&arg_os);\n                            debugln!(\n                                \"Parser::get_matches_with: possible_sc={:?}, sc={:?}\",\n                                is_match,\n                                sc_name\n                            );\n                            if is_match {\n                                let sc_name = sc_name.expect(INTERNAL_ERROR_MSG);\n                                if sc_name == \"help\" && self.is_set(AS::NeedsSubcommandHelp) {\n                                    self.parse_help_subcommand(it)?;\n                                }\n                                subcmd_name = Some(sc_name.to_owned());\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if starts_new_arg {\n                    let check_all = self.is_set(AS::AllArgsOverrideSelf);\n                    {\n                        let any_arg = find_any_by_name!(self, self.cache.unwrap_or(\"\"));\n                        matcher.process_arg_overrides(\n                            any_arg,\n                            &mut self.overrides,\n                            &mut self.required,\n                            check_all,\n                        );\n                    }\n\n                    if arg_os.starts_with(b\"--\") {\n                        needs_val_of = self.parse_long_arg(matcher, &arg_os, it)?;\n                        debugln!(\n                            \"Parser:get_matches_with: After parse_long_arg {:?}\",\n                            needs_val_of\n                        );\n                        match needs_val_of {\n                            ParseResult::Flag | ParseResult::Opt(..) | ParseResult::ValuesDone => {\n                                continue\n                            }\n                            _ => (),\n                        }\n                    } else if arg_os.starts_with(b\"-\") && arg_os.len() != 1 {\n                        // Try to parse short args like normal, if AllowLeadingHyphen or\n                        // AllowNegativeNumbers is set, parse_short_arg will *not* throw\n                        // an error, and instead return Ok(None)\n                        needs_val_of = self.parse_short_arg(matcher, &arg_os)?;\n                        // If it's None, we then check if one of those two AppSettings was set\n                        debugln!(\n                            \"Parser:get_matches_with: After parse_short_arg {:?}\",\n                            needs_val_of\n                        );\n                        match needs_val_of {\n                            ParseResult::MaybeNegNum => {\n                                if !(arg_os.to_string_lossy().parse::<i64>().is_ok()\n                                    || arg_os.to_string_lossy().parse::<f64>().is_ok())\n                                {\n                                    return Err(Error::unknown_argument(\n                                        &*arg_os.to_string_lossy(),\n                                        \"\",\n                                        &*usage::create_error_usage(self, matcher, None),\n                                        self.color(),\n                                    ));\n                                }\n                            }\n                            ParseResult::Opt(..) | ParseResult::Flag | ParseResult::ValuesDone => {\n                                continue\n                            }\n                            _ => (),\n                        }\n                    }\n                } else {\n                    if let ParseResult::Opt(name) = needs_val_of {\n                        // Check to see if parsing a value from a previous arg\n                        let arg = self\n                            .opts\n                            .iter()\n                            .find(|o| o.b.name == name)\n                            .expect(INTERNAL_ERROR_MSG);\n                        // get the OptBuilder so we can check the settings\n                        needs_val_of = self.add_val_to_arg(arg, &arg_os, matcher)?;\n                        // get the next value from the iterator\n                        continue;\n                    }\n                }\n            }\n\n            if !(self.is_set(AS::ArgsNegateSubcommands) && self.is_set(AS::ValidArgFound))\n                && !self.is_set(AS::InferSubcommands)\n                && !self.is_set(AS::AllowExternalSubcommands)\n            {\n                if let Some(cdate) =\n                    suggestions::did_you_mean(&*arg_os.to_string_lossy(), sc_names!(self))\n                {\n                    return Err(Error::invalid_subcommand(\n                        arg_os.to_string_lossy().into_owned(),\n                        cdate,\n                        self.meta.bin_name.as_ref().unwrap_or(&self.meta.name),\n                        &*usage::create_error_usage(self, matcher, None),\n                        self.color(),\n                    ));\n                }\n            }\n\n            let low_index_mults = self.is_set(AS::LowIndexMultiplePositional)\n                && pos_counter == (self.positionals.len() - 1);\n            let missing_pos = self.is_set(AS::AllowMissingPositional)\n                && (pos_counter == (self.positionals.len() - 1)\n                    && !self.is_set(AS::TrailingValues));\n            debugln!(\n                \"Parser::get_matches_with: Positional counter...{}\",\n                pos_counter\n            );\n            debugln!(\n                \"Parser::get_matches_with: Low index multiples...{:?}\",\n                low_index_mults\n            );\n            if low_index_mults || missing_pos {\n                if let Some(na) = it.peek() {\n                    let n = (*na).clone().into();\n                    needs_val_of = if needs_val_of != ParseResult::ValuesDone {\n                        if let Some(p) = self.positionals.get(pos_counter) {\n                            ParseResult::Pos(p.b.name)\n                        } else {\n                            ParseResult::ValuesDone\n                        }\n                    } else {\n                        ParseResult::ValuesDone\n                    };\n                    let sc_match = { self.possible_subcommand(&n).0 };\n                    if self.is_new_arg(&n, needs_val_of)\n                        || sc_match\n                        || suggestions::did_you_mean(&n.to_string_lossy(), sc_names!(self))\n                            .is_some()\n                    {\n                        debugln!(\"Parser::get_matches_with: Bumping the positional counter...\");\n                        pos_counter += 1;\n                    }\n                } else {\n                    debugln!(\"Parser::get_matches_with: Bumping the positional counter...\");\n                    pos_counter += 1;\n                }\n            } else if (self.is_set(AS::AllowMissingPositional) && self.is_set(AS::TrailingValues))\n                || (self.is_set(AS::ContainsLast) && self.is_set(AS::TrailingValues))\n            {\n                // Came to -- and one postional has .last(true) set, so we go immediately\n                // to the last (highest index) positional\n                debugln!(\"Parser::get_matches_with: .last(true) and --, setting last pos\");\n                pos_counter = self.positionals.len();\n            }\n            if let Some(p) = self.positionals.get(pos_counter) {\n                if p.is_set(ArgSettings::Last) && !self.is_set(AS::TrailingValues) {\n                    return Err(Error::unknown_argument(\n                        &*arg_os.to_string_lossy(),\n                        \"\",\n                        &*usage::create_error_usage(self, matcher, None),\n                        self.color(),\n                    ));\n                }\n                if !self.is_set(AS::TrailingValues)\n                    && (self.is_set(AS::TrailingVarArg) && pos_counter == self.positionals.len())\n                {\n                    self.settings.set(AS::TrailingValues);\n                }\n                if self.cache.map_or(true, |name| name != p.b.name) {\n                    let check_all = self.is_set(AS::AllArgsOverrideSelf);\n                    {\n                        let any_arg = find_any_by_name!(self, self.cache.unwrap_or(\"\"));\n                        matcher.process_arg_overrides(\n                            any_arg,\n                            &mut self.overrides,\n                            &mut self.required,\n                            check_all,\n                        );\n                    }\n                    self.cache = Some(p.b.name);\n                }\n                let _ = self.add_val_to_arg(p, &arg_os, matcher)?;\n\n                matcher.inc_occurrence_of(p.b.name);\n                let _ = self\n                    .groups_for_arg(p.b.name)\n                    .and_then(|vec| Some(matcher.inc_occurrences_of(&*vec)));\n\n                self.settings.set(AS::ValidArgFound);\n                // Only increment the positional counter if it doesn't allow multiples\n                if !p.b.settings.is_set(ArgSettings::Multiple) {\n                    pos_counter += 1;\n                }\n                self.settings.set(AS::ValidArgFound);\n            } else if self.is_set(AS::AllowExternalSubcommands) {\n                // Get external subcommand name\n                let sc_name = match arg_os.to_str() {\n                    Some(s) => s.to_string(),\n                    None => {\n                        if !self.is_set(AS::StrictUtf8) {\n                            return Err(Error::invalid_utf8(\n                                &*usage::create_error_usage(self, matcher, None),\n                                self.color(),\n                            ));\n                        }\n                        arg_os.to_string_lossy().into_owned()\n                    }\n                };\n\n                // Collect the external subcommand args\n                let mut sc_m = ArgMatcher::new();\n                while let Some(v) = it.next() {\n                    let a = v.into();\n                    if a.to_str().is_none() && !self.is_set(AS::StrictUtf8) {\n                        return Err(Error::invalid_utf8(\n                            &*usage::create_error_usage(self, matcher, None),\n                            self.color(),\n                        ));\n                    }\n                    sc_m.add_val_to(\"\", &a);\n                }\n\n                matcher.subcommand(SubCommand {\n                    name: sc_name,\n                    matches: sc_m.into(),\n                });\n                sc_is_external = true;\n            } else if !((self.is_set(AS::AllowLeadingHyphen)\n                || self.is_set(AS::AllowNegativeNumbers))\n                && arg_os.starts_with(b\"-\"))\n                && !self.is_set(AS::InferSubcommands)\n            {\n                return Err(Error::unknown_argument(\n                    &*arg_os.to_string_lossy(),\n                    \"\",\n                    &*usage::create_error_usage(self, matcher, None),\n                    self.color(),\n                ));\n            } else if !has_args || self.is_set(AS::InferSubcommands) && self.has_subcommands() {\n                if let Some(cdate) =\n                    suggestions::did_you_mean(&*arg_os.to_string_lossy(), sc_names!(self))\n                {\n                    return Err(Error::invalid_subcommand(\n                        arg_os.to_string_lossy().into_owned(),\n                        cdate,\n                        self.meta.bin_name.as_ref().unwrap_or(&self.meta.name),\n                        &*usage::create_error_usage(self, matcher, None),\n                        self.color(),\n                    ));\n                } else {\n                    return Err(Error::unrecognized_subcommand(\n                        arg_os.to_string_lossy().into_owned(),\n                        self.meta.bin_name.as_ref().unwrap_or(&self.meta.name),\n                        self.color(),\n                    ));\n                }\n            } else {\n                return Err(Error::unknown_argument(\n                    &*arg_os.to_string_lossy(),\n                    \"\",\n                    &*usage::create_error_usage(self, matcher, None),\n                    self.color(),\n                ));\n            }\n        }\n\n        if !sc_is_external {\n            if let Some(ref pos_sc_name) = subcmd_name {\n                let sc_name = {\n                    find_subcmd!(self, pos_sc_name)\n                        .expect(INTERNAL_ERROR_MSG)\n                        .p\n                        .meta\n                        .name\n                        .clone()\n                };\n                self.parse_subcommand(&*sc_name, matcher, it)?;\n            } else if self.is_set(AS::SubcommandRequired) {\n                let bn = self.meta.bin_name.as_ref().unwrap_or(&self.meta.name);\n                return Err(Error::missing_subcommand(\n                    bn,\n                    &usage::create_error_usage(self, matcher, None),\n                    self.color(),\n                ));\n            } else if self.is_set(AS::SubcommandRequiredElseHelp) {\n                debugln!(\"Parser::get_matches_with: SubcommandRequiredElseHelp=true\");\n                let mut out = vec![];\n                self.write_help_err(&mut out)?;\n                return Err(Error {\n                    message: String::from_utf8_lossy(&*out).into_owned(),\n                    kind: ErrorKind::MissingArgumentOrSubcommand,\n                    info: None,\n                });\n            }\n        }\n\n        // In case the last arg was new, we  need to process it's overrides\n        let check_all = self.is_set(AS::AllArgsOverrideSelf);\n        {\n            let any_arg = find_any_by_name!(self, self.cache.unwrap_or(\"\"));\n            matcher.process_arg_overrides(\n                any_arg,\n                &mut self.overrides,\n                &mut self.required,\n                check_all,\n            );\n        }\n\n        self.remove_overrides(matcher);\n\n        Validator::new(self).validate(needs_val_of, subcmd_name, matcher)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::get_matches_with::as_trait_obj":["fn as_trait_obj<'a, 'b, T: AnyArg<'a, 'b>>(x: &T) -> &AnyArg<'a, 'b>{\n            x\n        }","Real(LocalPath(\"src/macros.rs\"))"],"app::parser::Parser::<'a, 'b>::groups_for_arg":["pub fn groups_for_arg(&self, name: &str) -> Option<Vec<&'a str>>{\n        debugln!(\"Parser::groups_for_arg: name={}\", name);\n\n        if self.groups.is_empty() {\n            debugln!(\"Parser::groups_for_arg: No groups defined\");\n            return None;\n        }\n        let mut res = vec![];\n        debugln!(\"Parser::groups_for_arg: Searching through groups...\");\n        for grp in &self.groups {\n            for a in &grp.args {\n                if a == &name {\n                    sdebugln!(\"\\tFound '{}'\", grp.name);\n                    res.push(&*grp.name);\n                }\n            }\n        }\n        if res.is_empty() {\n            return None;\n        }\n\n        Some(res)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::has_args":["#[inline]\npub fn has_args(&self) -> bool{\n        !(self.flags.is_empty() && self.opts.is_empty() && self.positionals.is_empty())\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::has_flags":["#[inline]\npub fn has_flags(&self) -> bool{\n        !self.flags.is_empty()\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::has_opts":["#[inline]\npub fn has_opts(&self) -> bool{\n        !self.opts.is_empty()\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::has_positionals":["#[inline]\npub fn has_positionals(&self) -> bool{\n        !self.positionals.is_empty()\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::has_subcommands":["#[inline]\npub fn has_subcommands(&self) -> bool{\n        !self.subcommands.is_empty()\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::has_visible_flags":["#[inline]\npub fn has_visible_flags(&self) -> bool{\n        if self.flags.is_empty() {\n            return false;\n        }\n        self.flags.iter().any(|f| !f.is_set(ArgSettings::Hidden))\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::has_visible_opts":["#[inline]\npub fn has_visible_opts(&self) -> bool{\n        if self.opts.is_empty() {\n            return false;\n        }\n        self.opts.iter().any(|o| !o.is_set(ArgSettings::Hidden))\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::has_visible_positionals":["#[inline]\npub fn has_visible_positionals(&self) -> bool{\n        if self.positionals.is_empty() {\n            return false;\n        }\n        self.positionals\n            .values()\n            .any(|p| !p.is_set(ArgSettings::Hidden))\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::has_visible_subcommands":["#[inline]\npub fn has_visible_subcommands(&self) -> bool{\n        self.has_subcommands()\n            && self\n                .subcommands\n                .iter()\n                .filter(|sc| sc.p.meta.name != \"help\")\n                .any(|sc| !sc.p.is_set(AS::Hidden))\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::help_short":["pub fn help_short(&mut self, s: &str){\n        let c = s\n            .trim_left_matches(|c| c == '-')\n            .chars()\n            .nth(0)\n            .unwrap_or('h');\n        self.help_short = Some(c);\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::implied_settings":["#[inline]\nfn implied_settings(&mut self, a: &Arg<'a, 'b>){\n        if a.is_set(ArgSettings::Last) {\n            // if an arg has `Last` set, we need to imply DontCollapseArgsInUsage so that args\n            // in the usage string don't get confused or left out.\n            self.set(AS::DontCollapseArgsInUsage);\n            self.set(AS::ContainsLast);\n        }\n        if let Some(l) = a.s.long {\n            if l == \"version\" {\n                self.unset(AS::NeedsLongVersion);\n            } else if l == \"help\" {\n                self.unset(AS::NeedsLongHelp);\n            }\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::is_alias":["/// Check is a given string is an alias for this parser\nfn is_alias(&self, value: &str) -> bool{\n        self.meta\n            .aliases\n            .as_ref()\n            .and_then(|aliases| {\n                for alias in aliases {\n                    if alias.0 == value {\n                        return Some(true);\n                    }\n                }\n                Some(false)\n            })\n            .unwrap_or(false)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::is_bin_name":["/// Check is a given string matches the binary name for this parser\nfn is_bin_name(&self, value: &str) -> bool{\n        self.meta\n            .bin_name\n            .as_ref()\n            .and_then(|name| Some(value == name))\n            .unwrap_or(false)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::is_new_arg":["fn is_new_arg(&mut self, arg_os: &OsStr, needs_val_of: ParseResult) -> bool{\n        debugln!(\"Parser::is_new_arg:{:?}:{:?}\", arg_os, needs_val_of);\n        let app_wide_settings = if self.is_set(AS::AllowLeadingHyphen) {\n            true\n        } else if self.is_set(AS::AllowNegativeNumbers) {\n            let a = arg_os.to_string_lossy();\n            if a.parse::<i64>().is_ok() || a.parse::<f64>().is_ok() {\n                self.set(AS::ValidNegNumFound);\n                true\n            } else {\n                false\n            }\n        } else {\n            false\n        };\n        let arg_allows_tac = match needs_val_of {\n            ParseResult::Opt(name) => {\n                let o = self\n                    .opts\n                    .iter()\n                    .find(|o| o.b.name == name)\n                    .expect(INTERNAL_ERROR_MSG);\n                (o.is_set(ArgSettings::AllowLeadingHyphen) || app_wide_settings)\n            }\n            ParseResult::Pos(name) => {\n                let p = self\n                    .positionals\n                    .values()\n                    .find(|p| p.b.name == name)\n                    .expect(INTERNAL_ERROR_MSG);\n                (p.is_set(ArgSettings::AllowLeadingHyphen) || app_wide_settings)\n            }\n            ParseResult::ValuesDone => return true,\n            _ => false,\n        };\n        debugln!(\"Parser::is_new_arg: arg_allows_tac={:?}\", arg_allows_tac);\n\n        // Is this a new argument, or values from a previous option?\n        let mut ret = if arg_os.starts_with(b\"--\") {\n            debugln!(\"Parser::is_new_arg: -- found\");\n            if arg_os.len() == 2 && !arg_allows_tac {\n                return true; // We have to return true so override everything else\n            } else if arg_allows_tac {\n                return false;\n            }\n            true\n        } else if arg_os.starts_with(b\"-\") {\n            debugln!(\"Parser::is_new_arg: - found\");\n            // a singe '-' by itself is a value and typically means \"stdin\" on unix systems\n            !(arg_os.len() == 1)\n        } else {\n            debugln!(\"Parser::is_new_arg: probably value\");\n            false\n        };\n\n        ret = ret && !arg_allows_tac;\n\n        debugln!(\"Parser::is_new_arg: starts_new_arg={:?}\", ret);\n        ret\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::is_set":["#[inline]\npub fn is_set(&self, s: AS) -> bool{\n        self.settings.is_set(s)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::opts":["pub fn opts(&self) -> Iter<OptBuilder<'a, 'b>>{\n        self.opts.iter()\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::parse_flag":["fn parse_flag(\n        &self,\n        flag: &FlagBuilder<'a, 'b>,\n        matcher: &mut ArgMatcher<'a>,\n    ) -> ClapResult<ParseResult<'a>>{\n        debugln!(\"Parser::parse_flag;\");\n\n        matcher.inc_occurrence_of(flag.b.name);\n        matcher.add_index_to(flag.b.name, self.cur_idx.get());\n\n        // Increment or create the group \"args\"\n        self.groups_for_arg(flag.b.name)\n            .and_then(|vec| Some(matcher.inc_occurrences_of(&*vec)));\n\n        Ok(ParseResult::Flag)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::parse_help_subcommand":["fn parse_help_subcommand<I, T>(&self, it: &mut I) -> ClapResult<ParseResult<'a>>\n    where\n        I: Iterator<Item = T>,\n        T: Into<OsString>,{\n        debugln!(\"Parser::parse_help_subcommand;\");\n        let cmds: Vec<OsString> = it.map(|c| c.into()).collect();\n        let mut help_help = false;\n        let mut bin_name = self\n            .meta\n            .bin_name\n            .as_ref()\n            .unwrap_or(&self.meta.name)\n            .clone();\n        let mut sc = {\n            let mut sc: &Parser = self;\n            for (i, cmd) in cmds.iter().enumerate() {\n                if &*cmd.to_string_lossy() == \"help\" {\n                    // cmd help help\n                    help_help = true;\n                }\n                if let Some(c) = sc\n                    .subcommands\n                    .iter()\n                    .find(|s| &*s.p.meta.name == cmd)\n                    .map(|sc| &sc.p)\n                {\n                    sc = c;\n                    if i == cmds.len() - 1 {\n                        break;\n                    }\n                } else if let Some(c) = sc\n                    .subcommands\n                    .iter()\n                    .find(|s| {\n                        if let Some(ref als) = s.p.meta.aliases {\n                            als.iter().any(|&(a, _)| a == &*cmd.to_string_lossy())\n                        } else {\n                            false\n                        }\n                    })\n                    .map(|sc| &sc.p)\n                {\n                    sc = c;\n                    if i == cmds.len() - 1 {\n                        break;\n                    }\n                } else {\n                    return Err(Error::unrecognized_subcommand(\n                        cmd.to_string_lossy().into_owned(),\n                        self.meta.bin_name.as_ref().unwrap_or(&self.meta.name),\n                        self.color(),\n                    ));\n                }\n                bin_name = format!(\"{} {}\", bin_name, &*sc.meta.name);\n            }\n            sc.clone()\n        };\n        if help_help {\n            let mut pb = PosBuilder::new(\"subcommand\", 1);\n            pb.b.help = Some(\"The subcommand whose help message to display\");\n            pb.set(ArgSettings::Multiple);\n            sc.positionals.insert(1, pb);\n            sc.settings = sc.settings | self.g_settings;\n        } else {\n            sc.create_help_and_version();\n        }\n        if sc.meta.bin_name != self.meta.bin_name {\n            sc.meta.bin_name = Some(format!(\"{} {}\", bin_name, sc.meta.name));\n        }\n        Err(sc._help(false))\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::parse_long_arg":["fn parse_long_arg<I, T>(\n        &mut self,\n        matcher: &mut ArgMatcher<'a>,\n        full_arg: &OsStr,\n        it: &mut Peekable<I>,\n    ) -> ClapResult<ParseResult<'a>>\n    where\n        I: Iterator<Item = T>,\n        T: Into<OsString> + Clone,{\n        // maybe here lifetime should be 'a\n        debugln!(\"Parser::parse_long_arg;\");\n\n        // Update the current index\n        self.cur_idx.set(self.cur_idx.get() + 1);\n\n        let mut val = None;\n        debug!(\"Parser::parse_long_arg: Does it contain '='...\");\n        let arg = if full_arg.contains_byte(b'=') {\n            let (p0, p1) = full_arg.trim_left_matches(b'-').split_at_byte(b'=');\n            sdebugln!(\"Yes '{:?}'\", p1);\n            val = Some(p1);\n            p0\n        } else {\n            sdebugln!(\"No\");\n            full_arg.trim_left_matches(b'-')\n        };\n\n        if let Some(opt) = find_opt_by_long!(@os self, arg) {\n            debugln!(\n                \"Parser::parse_long_arg: Found valid opt '{}'\",\n                opt.to_string()\n            );\n            self.settings.set(AS::ValidArgFound);\n            let ret = self.parse_opt(val, opt, val.is_some(), matcher)?;\n            if self.cache.map_or(true, |name| name != opt.b.name) {\n                self.cache = Some(opt.b.name);\n            }\n\n            return Ok(ret);\n        } else if let Some(flag) = find_flag_by_long!(@os self, arg) {\n            debugln!(\n                \"Parser::parse_long_arg: Found valid flag '{}'\",\n                flag.to_string()\n            );\n            self.settings.set(AS::ValidArgFound);\n            // Only flags could be help or version, and we need to check the raw long\n            // so this is the first point to check\n            self.check_for_help_and_version_str(arg)?;\n\n            self.parse_flag(flag, matcher)?;\n\n            // Handle conflicts, requirements, etc.\n            if self.cache.map_or(true, |name| name != flag.b.name) {\n                self.cache = Some(flag.b.name);\n            }\n\n            return Ok(ParseResult::Flag);\n        } else if self.is_set(AS::AllowLeadingHyphen) {\n            return Ok(ParseResult::MaybeHyphenValue);\n        } else if self.is_set(AS::ValidNegNumFound) {\n            return Ok(ParseResult::MaybeNegNum);\n        }\n\n        debugln!(\"Parser::parse_long_arg: Didn't match anything\");\n\n        let args_rest: Vec<_> = it.map(|x| x.clone().into()).collect();\n        let args_rest2: Vec<_> = args_rest\n            .iter()\n            .map(|x| x.to_str().expect(INVALID_UTF8))\n            .collect();\n        self.did_you_mean_error(arg.to_str().expect(INVALID_UTF8), matcher, &args_rest2[..])\n            .map(|_| ParseResult::NotFound)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::parse_opt":["fn parse_opt(\n        &self,\n        val: Option<&OsStr>,\n        opt: &OptBuilder<'a, 'b>,\n        had_eq: bool,\n        matcher: &mut ArgMatcher<'a>,\n    ) -> ClapResult<ParseResult<'a>>{\n        debugln!(\"Parser::parse_opt; opt={}, val={:?}\", opt.b.name, val);\n        debugln!(\"Parser::parse_opt; opt.settings={:?}\", opt.b.settings);\n        let mut has_eq = false;\n        let no_val = val.is_none();\n        let empty_vals = opt.is_set(ArgSettings::EmptyValues);\n        let min_vals_zero = opt.v.min_vals.unwrap_or(1) == 0;\n        let needs_eq = opt.is_set(ArgSettings::RequireEquals);\n\n        debug!(\"Parser::parse_opt; Checking for val...\");\n        if let Some(fv) = val {\n            has_eq = fv.starts_with(&[b'=']) || had_eq;\n            let v = fv.trim_left_matches(b'=');\n            if !empty_vals && (v.len() == 0 || (needs_eq && !has_eq)) {\n                sdebugln!(\"Found Empty - Error\");\n                return Err(Error::empty_value(\n                    opt,\n                    &*usage::create_error_usage(self, matcher, None),\n                    self.color(),\n                ));\n            }\n            sdebugln!(\"Found - {:?}, len: {}\", v, v.len());\n            debugln!(\n                \"Parser::parse_opt: {:?} contains '='...{:?}\",\n                fv,\n                fv.starts_with(&[b'='])\n            );\n            self.add_val_to_arg(opt, v, matcher)?;\n        } else if needs_eq && !(empty_vals || min_vals_zero) {\n            sdebugln!(\"None, but requires equals...Error\");\n            return Err(Error::empty_value(\n                opt,\n                &*usage::create_error_usage(self, matcher, None),\n                self.color(),\n            ));\n        } else {\n            sdebugln!(\"None\");\n        }\n\n        matcher.inc_occurrence_of(opt.b.name);\n        // Increment or create the group \"args\"\n        self.groups_for_arg(opt.b.name)\n            .and_then(|vec| Some(matcher.inc_occurrences_of(&*vec)));\n\n        let needs_delim = opt.is_set(ArgSettings::RequireDelimiter);\n        let mult = opt.is_set(ArgSettings::Multiple);\n        if no_val && min_vals_zero && !has_eq && needs_eq {\n            debugln!(\"Parser::parse_opt: More arg vals not required...\");\n            return Ok(ParseResult::ValuesDone);\n        } else if no_val || (mult && !needs_delim) && !has_eq && matcher.needs_more_vals(opt) {\n            debugln!(\"Parser::parse_opt: More arg vals required...\");\n            return Ok(ParseResult::Opt(opt.b.name));\n        }\n        debugln!(\"Parser::parse_opt: More arg vals not required...\");\n        Ok(ParseResult::ValuesDone)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::parse_short_arg":["fn parse_short_arg(\n        &mut self,\n        matcher: &mut ArgMatcher<'a>,\n        full_arg: &OsStr,\n    ) -> ClapResult<ParseResult<'a>>{\n        debugln!(\"Parser::parse_short_arg: full_arg={:?}\", full_arg);\n        let arg_os = full_arg.trim_left_matches(b'-');\n        let arg = arg_os.to_string_lossy();\n\n        // If AllowLeadingHyphen is set, we want to ensure `-val` gets parsed as `-val` and not\n        // `-v` `-a` `-l` assuming `v` `a` and `l` are all, or mostly, valid shorts.\n        if self.is_set(AS::AllowLeadingHyphen) {\n            if arg.chars().any(|c| !self.contains_short(c)) {\n                debugln!(\n                    \"Parser::parse_short_arg: LeadingHyphenAllowed yet -{} isn't valid\",\n                    arg\n                );\n                return Ok(ParseResult::MaybeHyphenValue);\n            }\n        } else if self.is_set(AS::ValidNegNumFound) {\n            // TODO: Add docs about having AllowNegativeNumbers and `-2` as a valid short\n            // May be better to move this to *after* not finding a valid flag/opt?\n            debugln!(\"Parser::parse_short_arg: Valid negative num...\");\n            return Ok(ParseResult::MaybeNegNum);\n        }\n\n        let mut ret = ParseResult::NotFound;\n        for c in arg.chars() {\n            debugln!(\"Parser::parse_short_arg:iter:{}\", c);\n\n            // update each index because `-abcd` is four indices to clap\n            self.cur_idx.set(self.cur_idx.get() + 1);\n\n            // Check for matching short options, and return the name if there is no trailing\n            // concatenated value: -oval\n            // Option: -o\n            // Value: val\n            if let Some(opt) = find_opt_by_short!(self, c) {\n                debugln!(\"Parser::parse_short_arg:iter:{}: Found valid opt\", c);\n                self.settings.set(AS::ValidArgFound);\n                // Check for trailing concatenated value\n                let p: Vec<_> = arg.splitn(2, c).collect();\n                debugln!(\n                    \"Parser::parse_short_arg:iter:{}: p[0]={:?}, p[1]={:?}\",\n                    c,\n                    p[0].as_bytes(),\n                    p[1].as_bytes()\n                );\n                let i = p[0].as_bytes().len() + 1;\n                let val = if p[1].as_bytes().len() > 0 {\n                    debugln!(\n                        \"Parser::parse_short_arg:iter:{}: val={:?} (bytes), val={:?} (ascii)\",\n                        c,\n                        arg_os.split_at(i).1.as_bytes(),\n                        arg_os.split_at(i).1\n                    );\n                    Some(arg_os.split_at(i).1)\n                } else {\n                    None\n                };\n\n                // Default to \"we're expecting a value later\"\n                let ret = self.parse_opt(val, opt, false, matcher)?;\n\n                if self.cache.map_or(true, |name| name != opt.b.name) {\n                    self.cache = Some(opt.b.name);\n                }\n\n                return Ok(ret);\n            } else if let Some(flag) = find_flag_by_short!(self, c) {\n                debugln!(\"Parser::parse_short_arg:iter:{}: Found valid flag\", c);\n                self.settings.set(AS::ValidArgFound);\n                // Only flags can be help or version\n                self.check_for_help_and_version_char(c)?;\n                ret = self.parse_flag(flag, matcher)?;\n\n                // Handle conflicts, requirements, overrides, etc.\n                // Must be called here due to mutabililty\n                if self.cache.map_or(true, |name| name != flag.b.name) {\n                    self.cache = Some(flag.b.name);\n                }\n            } else {\n                let arg = format!(\"-{}\", c);\n                return Err(Error::unknown_argument(\n                    &*arg,\n                    \"\",\n                    &*usage::create_error_usage(self, matcher, None),\n                    self.color(),\n                ));\n            }\n        }\n        Ok(ret)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::parse_subcommand":["fn parse_subcommand<I, T>(\n        &mut self,\n        sc_name: &str,\n        matcher: &mut ArgMatcher<'a>,\n        it: &mut Peekable<I>,\n    ) -> ClapResult<()>\n    where\n        I: Iterator<Item = T>,\n        T: Into<OsString> + Clone,{\n        use std::fmt::Write;\n        debugln!(\"Parser::parse_subcommand;\");\n        let mut mid_string = String::new();\n        if !self.is_set(AS::SubcommandsNegateReqs) {\n            let mut hs: Vec<&str> = self.required.iter().map(|n| &**n).collect();\n            for k in matcher.arg_names() {\n                hs.push(k);\n            }\n            let reqs = usage::get_required_usage_from(self, &hs, Some(matcher), None, false);\n\n            for s in &reqs {\n                write!(&mut mid_string, \" {}\", s).expect(INTERNAL_ERROR_MSG);\n            }\n        }\n        mid_string.push_str(\" \");\n        if let Some(ref mut sc) = self\n            .subcommands\n            .iter_mut()\n            .find(|s| s.p.meta.name == sc_name)\n        {\n            let mut sc_matcher = ArgMatcher::new();\n            // bin_name should be parent's bin_name + [<reqs>] + the sc's name separated by\n            // a space\n            sc.p.meta.usage = Some(format!(\n                \"{}{}{}\",\n                self.meta.bin_name.as_ref().unwrap_or(&String::new()),\n                if self.meta.bin_name.is_some() {\n                    &*mid_string\n                } else {\n                    \"\"\n                },\n                &*sc.p.meta.name\n            ));\n            sc.p.meta.bin_name = Some(format!(\n                \"{}{}{}\",\n                self.meta.bin_name.as_ref().unwrap_or(&String::new()),\n                if self.meta.bin_name.is_some() {\n                    \" \"\n                } else {\n                    \"\"\n                },\n                &*sc.p.meta.name\n            ));\n            debugln!(\n                \"Parser::parse_subcommand: About to parse sc={}\",\n                sc.p.meta.name\n            );\n            debugln!(\"Parser::parse_subcommand: sc settings={:#?}\", sc.p.settings);\n            sc.p.get_matches_with(&mut sc_matcher, it)?;\n            matcher.subcommand(SubCommand {\n                name: sc.p.meta.name.clone(),\n                matches: sc_matcher.into(),\n            });\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::positionals":["pub fn positionals(&self) -> map::Values<PosBuilder<'a, 'b>>{\n        self.positionals.values()\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::possible_subcommand":["fn possible_subcommand(&self, arg_os: &OsStr) -> (bool, Option<&str>){\n        #[cfg(any(target_os = \"windows\", target_arch = \"wasm32\"))]\n        use osstringext::OsStrExt3;\n        #[cfg(not(any(target_os = \"windows\", target_arch = \"wasm32\")))]\n        use std::os::unix::ffi::OsStrExt;\n        debugln!(\"Parser::possible_subcommand: arg={:?}\", arg_os);\n        fn starts(h: &str, n: &OsStr) -> bool {\n            let n_bytes = n.as_bytes();\n            let h_bytes = OsStr::new(h).as_bytes();\n\n            h_bytes.starts_with(n_bytes)\n        }\n\n        if self.is_set(AS::ArgsNegateSubcommands) && self.is_set(AS::ValidArgFound) {\n            return (false, None);\n        }\n        if !self.is_set(AS::InferSubcommands) {\n            if let Some(sc) = find_subcmd!(self, arg_os) {\n                return (true, Some(&sc.p.meta.name));\n            }\n        } else {\n            let v = self\n                .subcommands\n                .iter()\n                .filter(|s| {\n                    starts(&s.p.meta.name[..], &*arg_os)\n                        || (s.p.meta.aliases.is_some()\n                            && s.p\n                                .meta\n                                .aliases\n                                .as_ref()\n                                .unwrap()\n                                .iter()\n                                .filter(|&&(a, _)| starts(a, &*arg_os))\n                                .count()\n                                == 1)\n                })\n                .map(|sc| &sc.p.meta.name)\n                .collect::<Vec<_>>();\n\n            for sc in &v {\n                if OsStr::new(sc) == arg_os {\n                    return (true, Some(sc));\n                }\n            }\n\n            if v.len() == 1 {\n                return (true, Some(v[0]));\n            }\n        }\n        (false, None)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::possible_subcommand::starts":["fn starts(h: &str, n: &OsStr) -> bool{\n            let n_bytes = n.as_bytes();\n            let h_bytes = OsStr::new(h).as_bytes();\n\n            h_bytes.starts_with(n_bytes)\n        }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::print_help":["pub fn print_help(&self) -> ClapResult<()>{\n        let out = io::stdout();\n        let mut buf_w = BufWriter::new(out.lock());\n        self.write_help(&mut buf_w)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::print_version":["fn print_version<W: Write>(&self, w: &mut W, use_long: bool) -> ClapResult<()>{\n        self.write_version(w, use_long)?;\n        w.flush().map_err(Error::from)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::propagate_globals":["pub fn propagate_globals(&mut self){\n        for sc in &mut self.subcommands {\n            // We have to create a new scope in order to tell rustc the borrow of `sc` is\n            // done and to recursively call this method\n            {\n                for a in &self.global_args {\n                    sc.p.add_arg_ref(a);\n                }\n            }\n            sc.p.propagate_globals();\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::propagate_help_version":["fn propagate_help_version(&mut self){\n        debugln!(\"Parser::propagate_help_version;\");\n        self.create_help_and_version();\n        for sc in &mut self.subcommands {\n            sc.p.propagate_help_version();\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::propagate_settings":["pub fn propagate_settings(&mut self){\n        debugln!(\n            \"Parser::propagate_settings: self={}, g_settings={:#?}\",\n            self.meta.name,\n            self.g_settings\n        );\n        for sc in &mut self.subcommands {\n            debugln!(\n                \"Parser::propagate_settings: sc={}, settings={:#?}, g_settings={:#?}\",\n                sc.p.meta.name,\n                sc.p.settings,\n                sc.p.g_settings\n            );\n            // We have to create a new scope in order to tell rustc the borrow of `sc` is\n            // done and to recursively call this method\n            {\n                let vsc = self.settings.is_set(AS::VersionlessSubcommands);\n                let gv = self.settings.is_set(AS::GlobalVersion);\n\n                if vsc {\n                    sc.p.set(AS::DisableVersion);\n                }\n                if gv && sc.p.meta.version.is_none() && self.meta.version.is_some() {\n                    sc.p.set(AS::GlobalVersion);\n                    sc.p.meta.version = Some(self.meta.version.unwrap());\n                }\n                sc.p.settings = sc.p.settings | self.g_settings;\n                sc.p.g_settings = sc.p.g_settings | self.g_settings;\n                sc.p.meta.term_w = self.meta.term_w;\n                sc.p.meta.max_w = self.meta.max_w;\n            }\n            sc.p.propagate_settings();\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::remove_overrides":["fn remove_overrides(&mut self, matcher: &mut ArgMatcher){\n        debugln!(\"Parser::remove_overrides:{:?};\", self.overrides);\n        for &(overr, name) in &self.overrides {\n            debugln!(\"Parser::remove_overrides:iter:({},{});\", overr, name);\n            if matcher.is_present(overr) {\n                debugln!(\n                    \"Parser::remove_overrides:iter:({},{}): removing {};\",\n                    overr,\n                    name,\n                    name\n                );\n                matcher.remove(name);\n                for i in (0..self.required.len()).rev() {\n                    debugln!(\n                        \"Parser::remove_overrides:iter:({},{}): removing required {};\",\n                        overr,\n                        name,\n                        name\n                    );\n                    if self.required[i] == name {\n                        self.required.swap_remove(i);\n                        break;\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::required":["pub fn required(&self) -> Iter<&str>{\n        self.required.iter()\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::set":["#[inline]\npub fn set(&mut self, s: AS){\n        self.settings.set(s)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::subcommands":["pub fn subcommands(&self) -> Iter<App>{\n        self.subcommands.iter()\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::unset":["#[inline]\npub fn unset(&mut self, s: AS){\n        self.settings.unset(s)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::use_long_help":["fn use_long_help(&self) -> bool{\n        // In this case, both must be checked. This allows the retention of\n        // original formatting, but also ensures that the actual -h or --help\n        // specified by the user is sent through. If HiddenShortHelp is not included,\n        // then items specified with hidden_short_help will also be hidden.\n        let should_long = |v: &Base| {\n            v.long_help.is_some()\n                || v.is_set(ArgSettings::HiddenLongHelp)\n                || v.is_set(ArgSettings::HiddenShortHelp)\n        };\n\n        self.meta.long_about.is_some()\n            || self.flags.iter().any(|f| should_long(&f.b))\n            || self.opts.iter().any(|o| should_long(&o.b))\n            || self.positionals.values().any(|p| should_long(&p.b))\n            || self\n                .subcommands\n                .iter()\n                .any(|s| s.p.meta.long_about.is_some())\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::verify_positionals":["pub fn verify_positionals(&self) -> bool{\n        // Because you must wait until all arguments have been supplied, this is the first chance\n        // to make assertions on positional argument indexes\n        //\n        // First we verify that the index highest supplied index, is equal to the number of\n        // positional arguments to verify there are no gaps (i.e. supplying an index of 1 and 3\n        // but no 2)\n        if let Some((idx, p)) = self.positionals.iter().rev().next() {\n            assert!(\n                !(idx != self.positionals.len()),\n                \"Found positional argument \\\"{}\\\" whose index is {} but there \\\n                 are only {} positional arguments defined\",\n                p.b.name,\n                idx,\n                self.positionals.len()\n            );\n        }\n\n        // Next we verify that only the highest index has a .multiple(true) (if any)\n        if self.positionals.values().any(|a| {\n            a.b.is_set(ArgSettings::Multiple) && (a.index as usize != self.positionals.len())\n        }) {\n            let mut it = self.positionals.values().rev();\n            let last = it.next().unwrap();\n            let second_to_last = it.next().unwrap();\n            // Either the final positional is required\n            // Or the second to last has a terminator or .last(true) set\n            let ok = last.is_set(ArgSettings::Required)\n                || (second_to_last.v.terminator.is_some()\n                    || second_to_last.b.is_set(ArgSettings::Last))\n                || last.is_set(ArgSettings::Last);\n            assert!(\n                ok,\n                \"When using a positional argument with .multiple(true) that is *not the \\\n                 last* positional argument, the last positional argument (i.e the one \\\n                 with the highest index) *must* have .required(true) or .last(true) set.\"\n            );\n            let ok = second_to_last.is_set(ArgSettings::Multiple) || last.is_set(ArgSettings::Last);\n            assert!(\n                ok,\n                \"Only the last positional argument, or second to last positional \\\n                 argument may be set to .multiple(true)\"\n            );\n\n            let count = self\n                .positionals\n                .values()\n                .filter(|p| p.b.settings.is_set(ArgSettings::Multiple) && p.v.num_vals.is_none())\n                .count();\n            let ok = count <= 1\n                || (last.is_set(ArgSettings::Last)\n                    && last.is_set(ArgSettings::Multiple)\n                    && second_to_last.is_set(ArgSettings::Multiple)\n                    && count == 2);\n            assert!(\n                ok,\n                \"Only one positional argument with .multiple(true) set is allowed per \\\n                 command, unless the second one also has .last(true) set\"\n            );\n        }\n\n        if self.is_set(AS::AllowMissingPositional) {\n            // Check that if a required positional argument is found, all positions with a lower\n            // index are also required.\n            let mut found = false;\n            let mut foundx2 = false;\n            for p in self.positionals.values().rev() {\n                if foundx2 && !p.b.settings.is_set(ArgSettings::Required) {\n                    assert!(\n                        p.b.is_set(ArgSettings::Required),\n                        \"Found positional argument which is not required with a lower \\\n                         index than a required positional argument by two or more: {:?} \\\n                         index {}\",\n                        p.b.name,\n                        p.index\n                    );\n                } else if p.b.is_set(ArgSettings::Required) && !p.b.is_set(ArgSettings::Last) {\n                    // Args that .last(true) don't count since they can be required and have\n                    // positionals with a lower index that aren't required\n                    // Imagine: prog <req1> [opt1] -- <req2>\n                    // Both of these are valid invocations:\n                    //      $ prog r1 -- r2\n                    //      $ prog r1 o1 -- r2\n                    if found {\n                        foundx2 = true;\n                        continue;\n                    }\n                    found = true;\n                    continue;\n                } else {\n                    found = false;\n                }\n            }\n        } else {\n            // Check that if a required positional argument is found, all positions with a lower\n            // index are also required\n            let mut found = false;\n            for p in self.positionals.values().rev() {\n                if found {\n                    assert!(\n                        p.b.is_set(ArgSettings::Required),\n                        \"Found positional argument which is not required with a lower \\\n                         index than a required positional argument: {:?} index {}\",\n                        p.b.name,\n                        p.index\n                    );\n                } else if p.b.is_set(ArgSettings::Required) && !p.b.is_set(ArgSettings::Last) {\n                    // Args that .last(true) don't count since they can be required and have\n                    // positionals with a lower index that aren't required\n                    // Imagine: prog <req1> [opt1] -- <req2>\n                    // Both of these are valid invocations:\n                    //      $ prog r1 -- r2\n                    //      $ prog r1 o1 -- r2\n                    found = true;\n                    continue;\n                }\n            }\n        }\n        if self\n            .positionals\n            .values()\n            .any(|p| p.b.is_set(ArgSettings::Last) && p.b.is_set(ArgSettings::Required))\n            && self.has_subcommands()\n            && !self.is_set(AS::SubcommandsNegateReqs)\n        {\n            panic!(\n                \"Having a required positional argument with .last(true) set *and* child \\\n                 subcommands without setting SubcommandsNegateReqs isn't compatible.\"\n            );\n        }\n\n        true\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::version_short":["pub fn version_short(&mut self, s: &str){\n        let c = s\n            .trim_left_matches(|c| c == '-')\n            .chars()\n            .nth(0)\n            .unwrap_or('V');\n        self.version_short = Some(c);\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::with_name":["pub fn with_name(n: String) -> Self{\n        Parser {\n            meta: AppMeta::with_name(n),\n            g_settings: AppFlags::zeroed(),\n            cur_idx: Cell::new(0),\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::write_help":["pub fn write_help<W: Write>(&self, w: &mut W) -> ClapResult<()>{\n        Help::write_parser_help(w, self, false)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::write_help_err":["pub fn write_help_err<W: Write>(&self, w: &mut W) -> ClapResult<()>{\n        Help::write_parser_help_to_stderr(w, self)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::write_long_help":["pub fn write_long_help<W: Write>(&self, w: &mut W) -> ClapResult<()>{\n        Help::write_parser_help(w, self, true)\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::parser::Parser::<'a, 'b>::write_version":["pub fn write_version<W: Write>(&self, w: &mut W, use_long: bool) -> io::Result<()>{\n        let ver = if use_long {\n            self.meta\n                .long_version\n                .unwrap_or_else(|| self.meta.version.unwrap_or(\"\"))\n        } else {\n            self.meta\n                .version\n                .unwrap_or_else(|| self.meta.long_version.unwrap_or(\"\"))\n        };\n        if let Some(bn) = self.meta.bin_name.as_ref() {\n            if bn.contains(' ') {\n                // Incase we're dealing with subcommands i.e. git mv is translated to git-mv\n                write!(w, \"{} {}\", bn.replace(\" \", \"-\"), ver)\n            } else {\n                write!(w, \"{} {}\", &self.meta.name[..], ver)\n            }\n        } else {\n            write!(w, \"{} {}\", &self.meta.name[..], ver)\n        }\n    }","Real(LocalPath(\"src/app/parser.rs\"))"],"app::settings::AppFlags":["#[doc(hidden)]\npub struct AppFlags(Flags);","Real(LocalPath(\"src/app/settings.rs\"))"],"app::settings::AppFlags::is_set":["pub fn is_set(&self, s: $n) -> bool{\n            match s {\n                $($n::$v => self.0.contains($c)),+\n            }\n        }","Real(LocalPath(\"src/macros.rs\"))"],"app::settings::AppFlags::new":["pub fn new() -> Self{\n        AppFlags::default()\n    }","Real(LocalPath(\"src/app/settings.rs\"))"],"app::settings::AppFlags::set":["pub fn set(&mut self, s: $n){\n            match s {\n                $($n::$v => self.0.insert($c)),+\n            }\n        }","Real(LocalPath(\"src/macros.rs\"))"],"app::settings::AppFlags::unset":["pub fn unset(&mut self, s: $n){\n            match s {\n                $($n::$v => self.0.remove($c)),+\n            }\n        }","Real(LocalPath(\"src/macros.rs\"))"],"app::settings::AppFlags::zeroed":["pub fn zeroed() -> Self{\n        AppFlags(Flags::empty())\n    }","Real(LocalPath(\"src/app/settings.rs\"))"],"app::settings::AppSettings":["/// Application level settings, which affect how [`App`] operates\n///\n/// **NOTE:** When these settings are used, they apply only to current command, and are *not*\n/// propagated down or up through child or parent subcommands\n///\n/// [`App`]: ./struct.App.html\npub enum AppSettings {\n    /// Specifies that any invalid UTF-8 code points should *not* be treated as an error.\n    /// This is the default behavior of `clap`.\n    ///\n    /// **NOTE:** Using argument values with invalid UTF-8 code points requires using\n    /// [`ArgMatches::os_value_of`], [`ArgMatches::os_values_of`], [`ArgMatches::lossy_value_of`],\n    /// or [`ArgMatches::lossy_values_of`] for those particular arguments which may contain invalid\n    /// UTF-8 values\n    ///\n    /// **NOTE:** This rule only applies to  argument values, as flags, options, and\n    /// [`SubCommand`]s themselves only allow valid UTF-8 code points.\n    ///\n    /// # Platform Specific\n    ///\n    /// Non Windows systems only\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(not(unix), doc = \" ```ignore\")]\n    #[cfg_attr(unix, doc = \" ```\")]\n    /// # use clap::{App, AppSettings};\n    /// use std::ffi::OsString;\n    /// use std::os::unix::ffi::{OsStrExt,OsStringExt};\n    ///\n    /// let r = App::new(\"myprog\")\n    ///   //.setting(AppSettings::AllowInvalidUtf8)\n    ///     .arg_from_usage(\"<arg> 'some positional arg'\")\n    ///     .get_matches_from_safe(\n    ///         vec![\n    ///             OsString::from(\"myprog\"),\n    ///             OsString::from_vec(vec![0xe9])]);\n    ///\n    /// assert!(r.is_ok());\n    /// let m = r.unwrap();\n    /// assert_eq!(m.value_of_os(\"arg\").unwrap().as_bytes(), &[0xe9]);\n    /// ```\n    /// [`ArgMatches::os_value_of`]: ./struct.ArgMatches.html#method.os_value_of\n    /// [`ArgMatches::os_values_of`]: ./struct.ArgMatches.html#method.os_values_of\n    /// [`ArgMatches::lossy_value_of`]: ./struct.ArgMatches.html#method.lossy_value_of\n    /// [`ArgMatches::lossy_values_of`]: ./struct.ArgMatches.html#method.lossy_values_of\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    AllowInvalidUtf8,\n\n    /// Essentially sets [`Arg::overrides_with(\"itself\")`] for all arguments.\n    ///\n    /// **WARNING:** Positional arguments cannot override themselves (or we would never be able\n    /// to advance to the next positional). This setting ignores positional arguments.\n    /// [`Arg::overrides_with(\"itself\")`]: ./struct.Arg.html#method.overrides_with\n    AllArgsOverrideSelf,\n\n    /// Specifies that leading hyphens are allowed in argument *values*, such as negative numbers\n    /// like `-10`. (which would otherwise be parsed as another flag or option)\n    ///\n    /// **NOTE:** Use this setting with caution as it silences certain circumstances which would\n    /// otherwise be an error (such as accidentally forgetting to specify a value for leading\n    /// option). It is preferred to set this on a per argument basis, via [`Arg::allow_hyphen_values`]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{Arg, App, AppSettings};\n    /// // Imagine you needed to represent negative numbers as well, such as -10\n    /// let m = App::new(\"nums\")\n    ///     .setting(AppSettings::AllowLeadingHyphen)\n    ///     .arg(Arg::with_name(\"neg\").index(1))\n    ///     .get_matches_from(vec![\n    ///         \"nums\", \"-20\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"neg\"), Some(\"-20\"));\n    /// # ;\n    /// ```\n    /// [`Arg::allow_hyphen_values`]: ./struct.Arg.html#method.allow_hyphen_values\n    AllowLeadingHyphen,\n\n    /// Allows negative numbers to pass as values. This is similar to\n    /// `AllowLeadingHyphen` except that it only allows numbers, all\n    /// other undefined leading hyphens will fail to parse.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings};\n    /// let res = App::new(\"myprog\")\n    ///     .version(\"v1.1\")\n    ///     .setting(AppSettings::AllowNegativeNumbers)\n    ///     .arg(Arg::with_name(\"num\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"myprog\", \"-20\"\n    ///     ]);\n    /// assert!(res.is_ok());\n    /// let m = res.unwrap();\n    /// assert_eq!(m.value_of(\"num\").unwrap(), \"-20\");\n    /// ```\n    /// [`AllowLeadingHyphen`]: ./enum.AppSettings.html#variant.AllowLeadingHyphen\n    AllowNegativeNumbers,\n\n    /// Allows one to implement two styles of CLIs where positionals can be used out of order.\n    ///\n    /// The first example is a CLI where the second to last positional argument is optional, but\n    /// the final positional argument is required. Such as `$ prog [optional] <required>` where one\n    /// of the two following usages is allowed:\n    ///\n    /// * `$ prog [optional] <required>`\n    /// * `$ prog <required>`\n    ///\n    /// This would otherwise not be allowed. This is useful when `[optional]` has a default value.\n    ///\n    /// **Note:** when using this style of \"missing positionals\" the final positional *must* be\n    /// [required] if `--` will not be used to skip to the final positional argument.\n    ///\n    /// **Note:** This style also only allows a single positional argument to be \"skipped\" without\n    /// the use of `--`. To skip more than one, see the second example.\n    ///\n    /// The second example is when one wants to skip multiple optional positional arguments, and use\n    /// of the `--` operator is OK (but not required if all arguments will be specified anyways).\n    ///\n    /// For example, imagine a CLI which has three positional arguments `[foo] [bar] [baz]...` where\n    /// `baz` accepts multiple values (similar to man `ARGS...` style training arguments).\n    ///\n    /// With this setting the following invocations are possible:\n    ///\n    /// * `$ prog foo bar baz1 baz2 baz3`\n    /// * `$ prog foo -- baz1 baz2 baz3`\n    /// * `$ prog -- baz1 baz2 baz3`\n    ///\n    /// # Examples\n    ///\n    /// Style number one from above:\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings};\n    /// // Assume there is an external subcommand named \"subcmd\"\n    /// let m = App::new(\"myprog\")\n    ///     .setting(AppSettings::AllowMissingPositional)\n    ///     .arg(Arg::with_name(\"arg1\"))\n    ///     .arg(Arg::with_name(\"arg2\")\n    ///         .required(true))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"other\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"arg1\"), None);\n    /// assert_eq!(m.value_of(\"arg2\"), Some(\"other\"));\n    /// ```\n    ///\n    /// Now the same example, but using a default value for the first optional positional argument\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings};\n    /// // Assume there is an external subcommand named \"subcmd\"\n    /// let m = App::new(\"myprog\")\n    ///     .setting(AppSettings::AllowMissingPositional)\n    ///     .arg(Arg::with_name(\"arg1\")\n    ///         .default_value(\"something\"))\n    ///     .arg(Arg::with_name(\"arg2\")\n    ///         .required(true))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"other\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"arg1\"), Some(\"something\"));\n    /// assert_eq!(m.value_of(\"arg2\"), Some(\"other\"));\n    /// ```\n    /// Style number two from above:\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings};\n    /// // Assume there is an external subcommand named \"subcmd\"\n    /// let m = App::new(\"myprog\")\n    ///     .setting(AppSettings::AllowMissingPositional)\n    ///     .arg(Arg::with_name(\"foo\"))\n    ///     .arg(Arg::with_name(\"bar\"))\n    ///     .arg(Arg::with_name(\"baz\").multiple(true))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"foo\", \"bar\", \"baz1\", \"baz2\", \"baz3\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"foo\"), Some(\"foo\"));\n    /// assert_eq!(m.value_of(\"bar\"), Some(\"bar\"));\n    /// assert_eq!(m.values_of(\"baz\").unwrap().collect::<Vec<_>>(), &[\"baz1\", \"baz2\", \"baz3\"]);\n    /// ```\n    ///\n    /// Now notice if we don't specify `foo` or `baz` but use the `--` operator.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings};\n    /// // Assume there is an external subcommand named \"subcmd\"\n    /// let m = App::new(\"myprog\")\n    ///     .setting(AppSettings::AllowMissingPositional)\n    ///     .arg(Arg::with_name(\"foo\"))\n    ///     .arg(Arg::with_name(\"bar\"))\n    ///     .arg(Arg::with_name(\"baz\").multiple(true))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"--\", \"baz1\", \"baz2\", \"baz3\"\n    ///     ]);\n    ///\n    /// assert_eq!(m.value_of(\"foo\"), None);\n    /// assert_eq!(m.value_of(\"bar\"), None);\n    /// assert_eq!(m.values_of(\"baz\").unwrap().collect::<Vec<_>>(), &[\"baz1\", \"baz2\", \"baz3\"]);\n    /// ```\n    /// [required]: ./struct.Arg.html#method.required\n    AllowMissingPositional,\n\n    /// Specifies that an unexpected positional argument,\n    /// which would otherwise cause a [`ErrorKind::UnknownArgument`] error,\n    /// should instead be treated as a [`SubCommand`] within the [`ArgMatches`] struct.\n    ///\n    /// **NOTE:** Use this setting with caution,\n    /// as a truly unexpected argument (i.e. one that is *NOT* an external subcommand)\n    /// will **not** cause an error and instead be treated as a potential subcommand.\n    /// One should check for such cases manually and inform the user appropriately.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, AppSettings};\n    /// // Assume there is an external subcommand named \"subcmd\"\n    /// let m = App::new(\"myprog\")\n    ///     .setting(AppSettings::AllowExternalSubcommands)\n    ///     .get_matches_from(vec![\n    ///         \"myprog\", \"subcmd\", \"--option\", \"value\", \"-fff\", \"--flag\"\n    ///     ]);\n    ///\n    /// // All trailing arguments will be stored under the subcommand's sub-matches using an empty\n    /// // string argument name\n    /// match m.subcommand() {\n    ///     (external, Some(ext_m)) => {\n    ///          let ext_args: Vec<&str> = ext_m.values_of(\"\").unwrap().collect();\n    ///          assert_eq!(external, \"subcmd\");\n    ///          assert_eq!(ext_args, [\"--option\", \"value\", \"-fff\", \"--flag\"]);\n    ///     },\n    ///     _ => {},\n    /// }\n    /// ```\n    /// [`ErrorKind::UnknownArgument`]: ./enum.ErrorKind.html#variant.UnknownArgument\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`ArgMatches`]: ./struct.ArgMatches.html\n    AllowExternalSubcommands,\n\n    /// Specifies that use of a valid [argument] negates [subcommands] being used after. By default\n    /// `clap` allows arguments between subcommands such as\n    /// `<cmd> [cmd_args] <cmd2> [cmd2_args] <cmd3> [cmd3_args]`. This setting disables that\n    /// functionality and says that arguments can only follow the *final* subcommand. For instance\n    /// using this setting makes only the following invocations possible:\n    ///\n    /// * `<cmd> <cmd2> <cmd3> [cmd3_args]`\n    /// * `<cmd> <cmd2> [cmd2_args]`\n    /// * `<cmd> [cmd_args]`\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::ArgsNegateSubcommands)\n    /// # ;\n    /// ```\n    /// [subcommands]: ./struct.SubCommand.html\n    /// [argument]: ./struct.Arg.html\n    ArgsNegateSubcommands,\n\n    /// Specifies that the help text should be displayed (and then exit gracefully),\n    /// if no arguments are present at runtime (i.e. an empty run such as, `$ myprog`.\n    ///\n    /// **NOTE:** [`SubCommand`]s count as arguments\n    ///\n    /// **NOTE:** Setting [`Arg::default_value`] effectively disables this option as it will\n    /// ensure that some argument is always present.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::ArgRequiredElseHelp)\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`Arg::default_value`]: ./struct.Arg.html#method.default_value\n    ArgRequiredElseHelp,\n\n    /// Uses colorized help messages.\n    ///\n    /// **NOTE:** Must be compiled with the `color` cargo feature\n    ///\n    /// # Platform Specific\n    ///\n    /// This setting only applies to Unix, Linux, and macOS (i.e. non-Windows platforms)\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::ColoredHelp)\n    ///     .get_matches();\n    /// ```\n    ColoredHelp,\n\n    /// Enables colored output only when the output is going to a terminal or TTY.\n    ///\n    /// **NOTE:** This is the default behavior of `clap`.\n    ///\n    /// **NOTE:** Must be compiled with the `color` cargo feature.\n    ///\n    /// # Platform Specific\n    ///\n    /// This setting only applies to Unix, Linux, and macOS (i.e. non-Windows platforms).\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::ColorAuto)\n    ///     .get_matches();\n    /// ```\n    ColorAuto,\n\n    /// Enables colored output regardless of whether or not the output is going to a terminal/TTY.\n    ///\n    /// **NOTE:** Must be compiled with the `color` cargo feature.\n    ///\n    /// # Platform Specific\n    ///\n    /// This setting only applies to Unix, Linux, and macOS (i.e. non-Windows platforms).\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::ColorAlways)\n    ///     .get_matches();\n    /// ```\n    ColorAlways,\n\n    /// Disables colored output no matter if the output is going to a terminal/TTY, or not.\n    ///\n    /// **NOTE:** Must be compiled with the `color` cargo feature\n    ///\n    /// # Platform Specific\n    ///\n    /// This setting only applies to Unix, Linux, and macOS (i.e. non-Windows platforms)\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::ColorNever)\n    ///     .get_matches();\n    /// ```\n    ColorNever,\n\n    /// Disables the automatic collapsing of positional args into `[ARGS]` inside the usage string\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::DontCollapseArgsInUsage)\n    ///     .get_matches();\n    /// ```\n    DontCollapseArgsInUsage,\n\n    /// Disables the automatic delimiting of values when `--` or [`AppSettings::TrailingVarArg`]\n    /// was used.\n    ///\n    /// **NOTE:** The same thing can be done manually by setting the final positional argument to\n    /// [`Arg::use_delimiter(false)`]. Using this setting is safer, because it's easier to locate\n    /// when making changes.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::DontDelimitTrailingValues)\n    ///     .get_matches();\n    /// ```\n    /// [`AppSettings::TrailingVarArg`]: ./enum.AppSettings.html#variant.TrailingVarArg\n    /// [`Arg::use_delimiter(false)`]: ./struct.Arg.html#method.use_delimiter\n    DontDelimitTrailingValues,\n\n    /// Disables `-h` and `--help` [`App`] without affecting any of the [`SubCommand`]s\n    /// (Defaults to `false`; application *does* have help flags)\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, AppSettings, ErrorKind};\n    /// let res = App::new(\"myprog\")\n    ///     .setting(AppSettings::DisableHelpFlags)\n    ///     .get_matches_from_safe(vec![\n    ///         \"myprog\", \"-h\"\n    ///     ]);\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::UnknownArgument);\n    /// ```\n    ///\n    /// ```rust\n    /// # use clap::{App, SubCommand, AppSettings, ErrorKind};\n    /// let res = App::new(\"myprog\")\n    ///     .setting(AppSettings::DisableHelpFlags)\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"myprog\", \"test\", \"-h\"\n    ///     ]);\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::HelpDisplayed);\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`App`]: ./struct.App.html\n    DisableHelpFlags,\n\n    /// Disables the `help` subcommand\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, AppSettings, ErrorKind, SubCommand};\n    /// let res = App::new(\"myprog\")\n    ///     .version(\"v1.1\")\n    ///     .setting(AppSettings::DisableHelpSubcommand)\n    ///     // Normally, creating a subcommand causes a `help` subcommand to automatically\n    ///     // be generated as well\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"myprog\", \"help\"\n    ///     ]);\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::UnknownArgument);\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    DisableHelpSubcommand,\n\n    /// Disables `-V` and `--version` [`App`] without affecting any of the [`SubCommand`]s\n    /// (Defaults to `false`; application *does* have a version flag)\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, AppSettings, ErrorKind};\n    /// let res = App::new(\"myprog\")\n    ///     .version(\"v1.1\")\n    ///     .setting(AppSettings::DisableVersion)\n    ///     .get_matches_from_safe(vec![\n    ///         \"myprog\", \"-V\"\n    ///     ]);\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::UnknownArgument);\n    /// ```\n    ///\n    /// ```rust\n    /// # use clap::{App, SubCommand, AppSettings, ErrorKind};\n    /// let res = App::new(\"myprog\")\n    ///     .version(\"v1.1\")\n    ///     .setting(AppSettings::DisableVersion)\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"myprog\", \"test\", \"-V\"\n    ///     ]);\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::VersionDisplayed);\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`App`]: ./struct.App.html\n    DisableVersion,\n\n    /// Displays the arguments and [`SubCommand`]s in the help message in the order that they were\n    /// declared in, and not alphabetically which is the default.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::DeriveDisplayOrder)\n    ///     .get_matches();\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    DeriveDisplayOrder,\n\n    /// Specifies to use the version of the current command for all child [`SubCommand`]s.\n    /// (Defaults to `false`; subcommands have independent version strings from their parents.)\n    ///\n    /// **NOTE:** The version for the current command **and** this setting must be set **prior** to\n    /// adding any child subcommands\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .version(\"v1.1\")\n    ///     .setting(AppSettings::GlobalVersion)\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .get_matches();\n    /// // running `$ myprog test --version` will display\n    /// // \"myprog-test v1.1\"\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    GlobalVersion,\n\n    /// Specifies that this [`SubCommand`] should be hidden from help messages\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings, SubCommand};\n    /// App::new(\"myprog\")\n    ///     .subcommand(SubCommand::with_name(\"test\")\n    ///     .setting(AppSettings::Hidden))\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    Hidden,\n\n    /// Tells `clap` *not* to print possible values when displaying help information.\n    /// This can be useful if there are many values, or they are explained elsewhere.\n    HidePossibleValuesInHelp,\n\n    /// Tries to match unknown args to partial [`subcommands`] or their [aliases]. For example to\n    /// match a subcommand named `test`, one could use `t`, `te`, `tes`, and `test`.\n    ///\n    /// **NOTE:** The match *must not* be ambiguous at all in order to succeed. i.e. to match `te`\n    /// to `test` there could not also be a subcommand or alias `temp` because both start with `te`\n    ///\n    /// **CAUTION:** This setting can interfere with [positional/free arguments], take care when\n    /// designing CLIs which allow inferred subcommands and have potential positional/free\n    /// arguments whose values could start with the same characters as subcommands. If this is the\n    /// case, it's recommended to use settings such as [`AppSeettings::ArgsNegateSubcommands`] in\n    /// conjunction with this setting.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand, AppSettings};\n    /// let m = App::new(\"prog\")\n    ///     .setting(AppSettings::InferSubcommands)\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .get_matches_from(vec![\n    ///         \"prog\", \"te\"\n    ///     ]);\n    /// assert_eq!(m.subcommand_name(), Some(\"test\"));\n    /// ```\n    /// [`subcommands`]: ./struct.SubCommand.html\n    /// [positional/free arguments]: ./struct.Arg.html#method.index\n    /// [aliases]: ./struct.App.html#method.alias\n    /// [`AppSeettings::ArgsNegateSubcommands`]: ./enum.AppSettings.html#variant.ArgsNegateSubcommands\n    InferSubcommands,\n\n    /// Specifies that the parser should not assume the first argument passed is the binary name.\n    /// This is normally the case when using a \"daemon\" style mode, or an interactive CLI where one\n    /// one would not normally type the binary or program name for each command.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings};\n    /// let m = App::new(\"myprog\")\n    ///     .setting(AppSettings::NoBinaryName)\n    ///     .arg(Arg::from_usage(\"<cmd>... 'commands to run'\"))\n    ///     .get_matches_from(vec![\"command\", \"set\"]);\n    ///\n    /// let cmds: Vec<&str> = m.values_of(\"cmd\").unwrap().collect();\n    /// assert_eq!(cmds, [\"command\", \"set\"]);\n    /// ```\n    NoBinaryName,\n\n    /// Places the help string for all arguments on the line after the argument.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::NextLineHelp)\n    ///     .get_matches();\n    /// ```\n    NextLineHelp,\n\n    /// **DEPRECATED**: This setting is no longer required in order to propagate values up or down\n    ///\n    /// Specifies that the parser should propagate global arg's values down or up through any *used*\n    /// child subcommands. Meaning, if a subcommand wasn't used, the values won't be propagated to\n    /// said subcommand.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings, SubCommand};\n    /// let m = App::new(\"myprog\")\n    ///     .arg(Arg::from_usage(\"[cmd] 'command to run'\")\n    ///         .global(true))\n    ///     .subcommand(SubCommand::with_name(\"foo\"))\n    ///     .get_matches_from(vec![\"myprog\", \"set\", \"foo\"]);\n    ///\n    /// assert_eq!(m.value_of(\"cmd\"), Some(\"set\"));\n    ///\n    /// let sub_m = m.subcommand_matches(\"foo\").unwrap();\n    /// assert_eq!(sub_m.value_of(\"cmd\"), Some(\"set\"));\n    /// ```\n    /// Now doing the same thing, but *not* using any subcommands will result in the value not being\n    /// propagated down.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings, SubCommand};\n    /// let m = App::new(\"myprog\")\n    ///     .arg(Arg::from_usage(\"[cmd] 'command to run'\")\n    ///         .global(true))\n    ///     .subcommand(SubCommand::with_name(\"foo\"))\n    ///     .get_matches_from(vec![\"myprog\", \"set\"]);\n    ///\n    /// assert_eq!(m.value_of(\"cmd\"), Some(\"set\"));\n    ///\n    /// assert!(m.subcommand_matches(\"foo\").is_none());\n    /// ```\n    #[deprecated(since = \"2.27.0\", note = \"No longer required to propagate values\")]\n    PropagateGlobalValuesDown,\n\n    /// Allows [`SubCommand`]s to override all requirements of the parent command.\n    /// For example if you had a subcommand or top level application with a required argument\n    /// that is only required as long as there is no subcommand present,\n    /// using this setting would allow you to set those arguments to [`Arg::required(true)`]\n    /// and yet receive no error so long as the user uses a valid subcommand instead.\n    ///\n    /// **NOTE:** This defaults to false (using subcommand does *not* negate requirements)\n    ///\n    /// # Examples\n    ///\n    /// This first example shows that it is an error to not use a required argument\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings, SubCommand, ErrorKind};\n    /// let err = App::new(\"myprog\")\n    ///     .setting(AppSettings::SubcommandsNegateReqs)\n    ///     .arg(Arg::with_name(\"opt\").required(true))\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"myprog\"\n    ///     ]);\n    /// assert!(err.is_err());\n    /// assert_eq!(err.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// # ;\n    /// ```\n    ///\n    /// This next example shows that it is no longer error to not use a required argument if a\n    /// valid subcommand is used.\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings, SubCommand, ErrorKind};\n    /// let noerr = App::new(\"myprog\")\n    ///     .setting(AppSettings::SubcommandsNegateReqs)\n    ///     .arg(Arg::with_name(\"opt\").required(true))\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"myprog\", \"test\"\n    ///     ]);\n    /// assert!(noerr.is_ok());\n    /// # ;\n    /// ```\n    /// [`Arg::required(true)`]: ./struct.Arg.html#method.required\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    SubcommandsNegateReqs,\n\n    /// Specifies that the help text should be displayed (before exiting gracefully) if no\n    /// [`SubCommand`]s are present at runtime (i.e. an empty run such as `$ myprog`).\n    ///\n    /// **NOTE:** This should *not* be used with [`AppSettings::SubcommandRequired`] as they do\n    /// nearly same thing; this prints the help text, and the other prints an error.\n    ///\n    /// **NOTE:** If the user specifies arguments at runtime, but no subcommand the help text will\n    /// still be displayed and exit. If this is *not* the desired result, consider using\n    /// [`AppSettings::ArgRequiredElseHelp`] instead.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::SubcommandRequiredElseHelp)\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`AppSettings::SubcommandRequired`]: ./enum.AppSettings.html#variant.SubcommandRequired\n    /// [`AppSettings::ArgRequiredElseHelp`]: ./enum.AppSettings.html#variant.ArgRequiredElseHelp\n    SubcommandRequiredElseHelp,\n\n    /// Specifies that any invalid UTF-8 code points should be treated as an error and fail\n    /// with a [`ErrorKind::InvalidUtf8`] error.\n    ///\n    /// **NOTE:** This rule only applies to argument values; Things such as flags, options, and\n    /// [`SubCommand`]s themselves only allow valid UTF-8 code points.\n    ///\n    /// # Platform Specific\n    ///\n    /// Non Windows systems only\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(not(unix), doc = \" ```ignore\")]\n    #[cfg_attr(unix, doc = \" ```\")]\n    /// # use clap::{App, AppSettings, ErrorKind};\n    /// use std::ffi::OsString;\n    /// use std::os::unix::ffi::OsStringExt;\n    ///\n    /// let m = App::new(\"myprog\")\n    ///     .setting(AppSettings::StrictUtf8)\n    ///     .arg_from_usage(\"<arg> 'some positional arg'\")\n    ///     .get_matches_from_safe(\n    ///         vec![\n    ///             OsString::from(\"myprog\"),\n    ///             OsString::from_vec(vec![0xe9])]);\n    ///\n    /// assert!(m.is_err());\n    /// assert_eq!(m.unwrap_err().kind, ErrorKind::InvalidUtf8);\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`ErrorKind::InvalidUtf8`]: ./enum.ErrorKind.html#variant.InvalidUtf8\n    StrictUtf8,\n\n    /// Allows specifying that if no [`SubCommand`] is present at runtime,\n    /// error and exit gracefully.\n    ///\n    /// **NOTE:** This defaults to `false` (subcommands do *not* need to be present)\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, AppSettings, SubCommand, ErrorKind};\n    /// let err = App::new(\"myprog\")\n    ///     .setting(AppSettings::SubcommandRequired)\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"myprog\",\n    ///     ]);\n    /// assert!(err.is_err());\n    /// assert_eq!(err.unwrap_err().kind, ErrorKind::MissingSubcommand);\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    SubcommandRequired,\n\n    /// Specifies that the final positional argument is a \"VarArg\" and that `clap` should not\n    /// attempt to parse any further args.\n    ///\n    /// The values of the trailing positional argument will contain all args from itself on.\n    ///\n    /// **NOTE:** The final positional argument **must** have [`Arg::multiple(true)`] or the usage\n    /// string equivalent.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings};\n    /// let m = App::new(\"myprog\")\n    ///     .setting(AppSettings::TrailingVarArg)\n    ///     .arg(Arg::from_usage(\"<cmd>... 'commands to run'\"))\n    ///     .get_matches_from(vec![\"myprog\", \"arg1\", \"-r\", \"val1\"]);\n    ///\n    /// let trail: Vec<&str> = m.values_of(\"cmd\").unwrap().collect();\n    /// assert_eq!(trail, [\"arg1\", \"-r\", \"val1\"]);\n    /// ```\n    /// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n    TrailingVarArg,\n\n    /// Groups flags and options together, presenting a more unified help message\n    /// (a la `getopts` or `docopt` style).\n    ///\n    /// The default is that the auto-generated help message will group flags, and options\n    /// separately.\n    ///\n    /// **NOTE:** This setting is cosmetic only and does not affect any functionality.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// # use clap::{App, Arg, SubCommand, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::UnifiedHelpMessage)\n    ///     .get_matches();\n    /// // running `myprog --help` will display a unified \"docopt\" or \"getopts\" style help message\n    /// ```\n    UnifiedHelpMessage,\n\n    /// Disables `-V` and `--version` for all [`SubCommand`]s\n    /// (Defaults to `false`; subcommands *do* have version flags.)\n    ///\n    /// **NOTE:** This setting must be set **prior** to adding any subcommands.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, SubCommand, AppSettings, ErrorKind};\n    /// let res = App::new(\"myprog\")\n    ///     .version(\"v1.1\")\n    ///     .setting(AppSettings::VersionlessSubcommands)\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"myprog\", \"test\", \"-V\"\n    ///     ]);\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::UnknownArgument);\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    VersionlessSubcommands,\n\n    /// Will display a message \"Press \\[ENTER\\]/\\[RETURN\\] to continue...\" and wait for user before\n    /// exiting\n    ///\n    /// This is most useful when writing an application which is run from a GUI shortcut, or on\n    /// Windows where a user tries to open the binary by double-clicking instead of using the\n    /// command line.\n    ///\n    /// **NOTE:** This setting is **not** recursive with [`SubCommand`]s, meaning if you wish this\n    /// behavior for all subcommands, you must set this on each command (needing this is extremely\n    /// rare)\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings};\n    /// App::new(\"myprog\")\n    ///     .setting(AppSettings::WaitOnError)\n    /// # ;\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    WaitOnError,\n\n    #[doc(hidden)]\n    NeedsLongVersion,\n\n    #[doc(hidden)]\n    NeedsLongHelp,\n\n    #[doc(hidden)]\n    NeedsSubcommandHelp,\n\n    #[doc(hidden)]\n    LowIndexMultiplePositional,\n\n    #[doc(hidden)]\n    TrailingValues,\n\n    #[doc(hidden)]\n    ValidNegNumFound,\n\n    #[doc(hidden)]\n    Propagated,\n\n    #[doc(hidden)]\n    ValidArgFound,\n\n    #[doc(hidden)]\n    ContainsLast,\n}","Real(LocalPath(\"src/app/settings.rs\"))"],"app::settings::Flags":["$vis struct $BitFlags {\n            bits: $T,\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::all":["/// Returns the set containing all flags.\n#[inline]\npub const fn all() -> Self{\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::all::__BitFlags":["#[allow(non_snake_case)]\ntrait __BitFlags {\n            $(\n                const $Flag: $T = 0;\n            )+\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::bits":["/// Returns the raw value of the flags currently stored.\n#[inline]\npub const fn bits(&self) -> $T{\n                self.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::complement":["/// Returns the complement of this set of flags.\n///\n/// Specifically, the returned set contains all the flags which are\n/// not set in `self`, but which are allowed for this type.\n///\n/// Alternatively, it can be thought of as the set difference\n/// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n///\n/// This is equivalent to using the `!` operator (e.g.\n/// [`ops::Not`]), as in `!flags`.\n///\n/// [`Self::all()`]: Self::all\n/// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n#[inline]\n#[must_use]\npub const fn complement(self) -> Self{\n                Self::from_bits_truncate(!self.bits)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::contains":["/// Returns `true` if all of the flags in `other` are contained within `self`.\n#[inline]\npub const fn contains(&self, other: Self) -> bool{\n                (self.bits & other.bits) == other.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::difference":["/// Returns the difference between the flags in `self` and `other`.\n///\n/// Specifically, the returned set contains all flags present in\n/// `self`, except for the ones present in `other`.\n///\n/// It is also conceptually equivalent to the \"bit-clear\" operation:\n/// `flags & !other` (and this syntax is also supported).\n///\n/// This is equivalent to using the `-` operator (e.g.\n/// [`ops::Sub`]), as in `flags - other`.\n///\n/// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n#[inline]\n#[must_use]\npub const fn difference(self, other: Self) -> Self{\n                Self { bits: self.bits & !other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::empty":["/// Returns an empty set of flags.\n#[inline]\npub const fn empty() -> Self{\n                Self { bits: 0 }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::from_bits":["/// Convert from underlying bit representation, unless that\n/// representation contains bits that do not correspond to a flag.\n#[inline]\npub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self>{\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::from_bits_truncate":["/// Convert from underlying bit representation, dropping any bits\n/// that do not correspond to flags.\n#[inline]\npub const fn from_bits_truncate(bits: $T) -> Self{\n                Self { bits: bits & Self::all().bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::from_bits_unchecked":["/// Convert from underlying bit representation, preserving all\n/// bits (even those not corresponding to a defined flag).\n///\n/// # Safety\n///\n/// The caller of the `bitflags!` macro can chose to allow or\n/// disallow extra bits for their bitflags type.\n///\n/// The caller of `from_bits_unchecked()` has to ensure that\n/// all bits correspond to a defined flag or that extra bits\n/// are valid for this bitflags type.\n#[inline]\npub const unsafe fn from_bits_unchecked(bits: $T) -> Self{\n                Self { bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::insert":["/// Inserts the specified flags in-place.\n#[inline]\npub fn insert(&mut self, other: Self){\n                self.bits |= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::intersection":["/// Returns the intersection between the flags in `self` and\n/// `other`.\n///\n/// Specifically, the returned set contains only the flags which are\n/// present in *both* `self` *and* `other`.\n///\n/// This is equivalent to using the `&` operator (e.g.\n/// [`ops::BitAnd`]), as in `flags & other`.\n///\n/// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n#[inline]\n#[must_use]\npub const fn intersection(self, other: Self) -> Self{\n                Self { bits: self.bits & other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::intersects":["/// Returns `true` if there are flags common to both `self` and `other`.\n#[inline]\npub const fn intersects(&self, other: Self) -> bool{\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::is_all":["/// Returns `true` if all flags are currently set.\n#[inline]\npub const fn is_all(&self) -> bool{\n                Self::all().bits | self.bits == self.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::is_empty":["/// Returns `true` if no flags are currently stored.\n#[inline]\npub const fn is_empty(&self) -> bool{\n                self.bits() == Self::empty().bits()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::remove":["/// Removes the specified flags in-place.\n#[inline]\npub fn remove(&mut self, other: Self){\n                self.bits &= !other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::set":["/// Inserts or removes the specified flags depending on the passed value.\n#[inline]\npub fn set(&mut self, other: Self, value: bool){\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::symmetric_difference":["/// Returns the [symmetric difference][sym-diff] between the flags\n/// in `self` and `other`.\n///\n/// Specifically, the returned set contains the flags present which\n/// are present in `self` or `other`, but that are not present in\n/// both. Equivalently, it contains the flags present in *exactly\n/// one* of the sets `self` and `other`.\n///\n/// This is equivalent to using the `^` operator (e.g.\n/// [`ops::BitXor`]), as in `flags ^ other`.\n///\n/// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n/// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n#[inline]\n#[must_use]\npub const fn symmetric_difference(self, other: Self) -> Self{\n                Self { bits: self.bits ^ other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::toggle":["/// Toggles the specified flags in-place.\n#[inline]\npub fn toggle(&mut self, other: Self){\n                self.bits ^= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::settings::Flags::union":["/// Returns the union of between the flags in `self` and `other`.\n///\n/// Specifically, the returned set contains all flags which are\n/// present in *either* `self` *or* `other`, including any which are\n/// present in both (see [`Self::symmetric_difference`] if that\n/// is undesirable).\n///\n/// This is equivalent to using the `|` operator (e.g.\n/// [`ops::BitOr`]), as in `flags | other`.\n///\n/// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n#[inline]\n#[must_use]\npub const fn union(self, other: Self) -> Self{\n                Self { bits: self.bits | other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"app::usage::create_error_usage":["pub fn create_error_usage<'a, 'b>(\n    p: &Parser<'a, 'b>,\n    matcher: &'b ArgMatcher<'a>,\n    extra: Option<&str>,\n) -> String{\n    let mut args: Vec<_> = matcher\n        .arg_names()\n        .iter()\n        .filter(|n| {\n            if let Some(o) = find_by_name!(p, **n, opts, iter) {\n                !o.b.is_set(ArgSettings::Required) && !o.b.is_set(ArgSettings::Hidden)\n            } else if let Some(p) = find_by_name!(p, **n, positionals, values) {\n                !p.b.is_set(ArgSettings::Required) && p.b.is_set(ArgSettings::Hidden)\n            } else {\n                true // flags can't be required, so they're always true\n            }\n        })\n        .map(|&n| n)\n        .collect();\n    if let Some(r) = extra {\n        args.push(r);\n    }\n    create_usage_with_title(p, &*args)\n}","Real(LocalPath(\"src/app/usage.rs\"))"],"app::usage::create_help_usage":["pub fn create_help_usage(p: &Parser, incl_reqs: bool) -> String{\n    let mut usage = String::with_capacity(75);\n    let name = p\n        .meta\n        .usage\n        .as_ref()\n        .unwrap_or_else(|| p.meta.bin_name.as_ref().unwrap_or(&p.meta.name));\n    usage.push_str(&*name);\n    let req_string = if incl_reqs {\n        let mut reqs: Vec<&str> = p.required().map(|r| &**r).collect();\n        reqs.sort();\n        reqs.dedup();\n        get_required_usage_from(p, &reqs, None, None, false)\n            .iter()\n            .fold(String::new(), |a, s| a + &format!(\" {}\", s)[..])\n    } else {\n        String::new()\n    };\n\n    let flags = needs_flags_tag(p);\n    if flags && !p.is_set(AS::UnifiedHelpMessage) {\n        usage.push_str(\" [FLAGS]\");\n    } else if flags {\n        usage.push_str(\" [OPTIONS]\");\n    }\n    if !p.is_set(AS::UnifiedHelpMessage)\n        && p.opts\n            .iter()\n            .any(|o| !o.is_set(ArgSettings::Required) && !o.is_set(ArgSettings::Hidden))\n    {\n        usage.push_str(\" [OPTIONS]\");\n    }\n\n    usage.push_str(&req_string[..]);\n\n    let has_last = p.positionals.values().any(|p| p.is_set(ArgSettings::Last));\n    // places a '--' in the usage string if there are args and options\n    // supporting multiple values\n    if p.opts.iter().any(|o| o.is_set(ArgSettings::Multiple))\n        && p.positionals\n            .values()\n            .any(|p| !p.is_set(ArgSettings::Required))\n        && !(p.has_visible_subcommands() || p.is_set(AS::AllowExternalSubcommands))\n        && !has_last\n    {\n        usage.push_str(\" [--]\");\n    }\n    let not_req_or_hidden = |p: &PosBuilder| {\n        (!p.is_set(ArgSettings::Required) || p.is_set(ArgSettings::Last))\n            && !p.is_set(ArgSettings::Hidden)\n    };\n    if p.has_positionals() && p.positionals.values().any(not_req_or_hidden) {\n        if let Some(args_tag) = get_args_tag(p, incl_reqs) {\n            usage.push_str(&*args_tag);\n        } else {\n            usage.push_str(\" [ARGS]\");\n        }\n        if has_last && incl_reqs {\n            let pos = p\n                .positionals\n                .values()\n                .find(|p| p.b.is_set(ArgSettings::Last))\n                .expect(INTERNAL_ERROR_MSG);\n            debugln!(\"usage::create_help_usage: '{}' has .last(true)\", pos.name());\n            let req = pos.is_set(ArgSettings::Required);\n            if req\n                && p.positionals\n                    .values()\n                    .any(|p| !p.is_set(ArgSettings::Required))\n            {\n                usage.push_str(\" -- <\");\n            } else if req {\n                usage.push_str(\" [--] <\");\n            } else {\n                usage.push_str(\" [-- <\");\n            }\n            usage.push_str(&*pos.name_no_brackets());\n            usage.push_str(\">\");\n            usage.push_str(pos.multiple_str());\n            if !req {\n                usage.push_str(\"]\");\n            }\n        }\n    }\n\n    // incl_reqs is only false when this function is called recursively\n    if p.has_visible_subcommands() && incl_reqs || p.is_set(AS::AllowExternalSubcommands) {\n        if p.is_set(AS::SubcommandsNegateReqs) || p.is_set(AS::ArgsNegateSubcommands) {\n            if !p.is_set(AS::ArgsNegateSubcommands) {\n                usage.push_str(\"\\n    \");\n                usage.push_str(&*create_help_usage(p, false));\n                usage.push_str(\" <SUBCOMMAND>\");\n            } else {\n                usage.push_str(\"\\n    \");\n                usage.push_str(&*name);\n                usage.push_str(\" <SUBCOMMAND>\");\n            }\n        } else if p.is_set(AS::SubcommandRequired) || p.is_set(AS::SubcommandRequiredElseHelp) {\n            usage.push_str(\" <SUBCOMMAND>\");\n        } else {\n            usage.push_str(\" [SUBCOMMAND]\");\n        }\n    }\n    usage.shrink_to_fit();\n    debugln!(\"usage::create_help_usage: usage={}\", usage);\n    usage\n}","Real(LocalPath(\"src/app/usage.rs\"))"],"app::usage::create_smart_usage":["fn create_smart_usage(p: &Parser, used: &[&str]) -> String{\n    debugln!(\"usage::smart_usage;\");\n    let mut usage = String::with_capacity(75);\n    let mut hs: Vec<&str> = p.required().map(|s| &**s).collect();\n    hs.extend_from_slice(used);\n\n    let r_string = get_required_usage_from(p, &hs, None, None, false)\n        .iter()\n        .fold(String::new(), |acc, s| acc + &format!(\" {}\", s)[..]);\n\n    usage.push_str(\n        &p.meta\n            .usage\n            .as_ref()\n            .unwrap_or_else(|| p.meta.bin_name.as_ref().unwrap_or(&p.meta.name))[..],\n    );\n    usage.push_str(&*r_string);\n    if p.is_set(AS::SubcommandRequired) {\n        usage.push_str(\" <SUBCOMMAND>\");\n    }\n    usage.shrink_to_fit();\n    usage\n}","Real(LocalPath(\"src/app/usage.rs\"))"],"app::usage::create_usage_no_title":["pub fn create_usage_no_title(p: &Parser, used: &[&str]) -> String{\n    debugln!(\"usage::create_usage_no_title;\");\n    if let Some(u) = p.meta.usage_str {\n        String::from(&*u)\n    } else if used.is_empty() {\n        create_help_usage(p, true)\n    } else {\n        create_smart_usage(p, used)\n    }\n}","Real(LocalPath(\"src/app/usage.rs\"))"],"app::usage::create_usage_with_title":["pub fn create_usage_with_title(p: &Parser, used: &[&str]) -> String{\n    debugln!(\"usage::create_usage_with_title;\");\n    let mut usage = String::with_capacity(75);\n    usage.push_str(\"USAGE:\\n    \");\n    usage.push_str(&*create_usage_no_title(p, used));\n    usage\n}","Real(LocalPath(\"src/app/usage.rs\"))"],"app::usage::get_args_tag":["fn get_args_tag(p: &Parser, incl_reqs: bool) -> Option<String>{\n    debugln!(\"usage::get_args_tag;\");\n    let mut count = 0;\n    'outer: for pos in p\n        .positionals\n        .values()\n        .filter(|pos| !pos.is_set(ArgSettings::Required))\n        .filter(|pos| !pos.is_set(ArgSettings::Hidden))\n        .filter(|pos| !pos.is_set(ArgSettings::Last))\n    {\n        debugln!(\"usage::get_args_tag:iter:{}:\", pos.b.name);\n        if let Some(g_vec) = p.groups_for_arg(pos.b.name) {\n            for grp_s in &g_vec {\n                debugln!(\"usage::get_args_tag:iter:{}:iter:{};\", pos.b.name, grp_s);\n                // if it's part of a required group we don't want to count it\n                if p.groups.iter().any(|g| g.required && (&g.name == grp_s)) {\n                    continue 'outer;\n                }\n            }\n        }\n        count += 1;\n        debugln!(\n            \"usage::get_args_tag:iter: {} Args not required or hidden\",\n            count\n        );\n    }\n    if !p.is_set(AS::DontCollapseArgsInUsage) && count > 1 {\n        debugln!(\"usage::get_args_tag:iter: More than one, returning [ARGS]\");\n        return None; // [ARGS]\n    } else if count == 1 && incl_reqs {\n        let pos = p\n            .positionals\n            .values()\n            .find(|pos| {\n                !pos.is_set(ArgSettings::Required)\n                    && !pos.is_set(ArgSettings::Hidden)\n                    && !pos.is_set(ArgSettings::Last)\n            })\n            .expect(INTERNAL_ERROR_MSG);\n        debugln!(\n            \"usage::get_args_tag:iter: Exactly one, returning '{}'\",\n            pos.name()\n        );\n        return Some(format!(\n            \" [{}]{}\",\n            pos.name_no_brackets(),\n            pos.multiple_str()\n        ));\n    } else if p.is_set(AS::DontCollapseArgsInUsage) && !p.positionals.is_empty() && incl_reqs {\n        debugln!(\"usage::get_args_tag:iter: Don't collapse returning all\");\n        return Some(\n            p.positionals\n                .values()\n                .filter(|pos| !pos.is_set(ArgSettings::Required))\n                .filter(|pos| !pos.is_set(ArgSettings::Hidden))\n                .filter(|pos| !pos.is_set(ArgSettings::Last))\n                .map(|pos| format!(\" [{}]{}\", pos.name_no_brackets(), pos.multiple_str()))\n                .collect::<Vec<_>>()\n                .join(\"\"),\n        );\n    } else if !incl_reqs {\n        debugln!(\"usage::get_args_tag:iter: incl_reqs=false, building secondary usage string\");\n        let highest_req_pos = p\n            .positionals\n            .iter()\n            .filter_map(|(idx, pos)| {\n                if pos.b.is_set(ArgSettings::Required) && !pos.b.is_set(ArgSettings::Last) {\n                    Some(idx)\n                } else {\n                    None\n                }\n            })\n            .max()\n            .unwrap_or_else(|| p.positionals.len());\n        return Some(\n            p.positionals\n                .iter()\n                .filter_map(|(idx, pos)| {\n                    if idx <= highest_req_pos {\n                        Some(pos)\n                    } else {\n                        None\n                    }\n                })\n                .filter(|pos| !pos.is_set(ArgSettings::Required))\n                .filter(|pos| !pos.is_set(ArgSettings::Hidden))\n                .filter(|pos| !pos.is_set(ArgSettings::Last))\n                .map(|pos| format!(\" [{}]{}\", pos.name_no_brackets(), pos.multiple_str()))\n                .collect::<Vec<_>>()\n                .join(\"\"),\n        );\n    }\n    Some(\"\".into())\n}","Real(LocalPath(\"src/app/usage.rs\"))"],"app::usage::get_required_usage_from":["pub fn get_required_usage_from<'a, 'b>(\n    p: &Parser<'a, 'b>,\n    reqs: &[&'a str],\n    matcher: Option<&ArgMatcher<'a>>,\n    extra: Option<&str>,\n    incl_last: bool,\n) -> VecDeque<String>{\n    debugln!(\n        \"usage::get_required_usage_from: reqs={:?}, extra={:?}\",\n        reqs,\n        extra\n    );\n    let mut desc_reqs: Vec<&str> = vec![];\n    desc_reqs.extend(extra);\n    let mut new_reqs: Vec<&str> = vec![];\n    macro_rules! get_requires {\n        (@group $a: ident, $v:ident, $p:ident) => {{\n            if let Some(rl) = p\n                .groups\n                .iter()\n                .filter(|g| g.requires.is_some())\n                .find(|g| &g.name == $a)\n                .map(|g| g.requires.as_ref().unwrap())\n            {\n                for r in rl {\n                    if !$p.contains(&r) {\n                        debugln!(\n                            \"usage::get_required_usage_from:iter:{}: adding group req={:?}\",\n                            $a,\n                            r\n                        );\n                        $v.push(r);\n                    }\n                }\n            }\n        }};\n        ($a:ident, $what:ident, $how:ident, $v:ident, $p:ident) => {{\n            if let Some(rl) = p\n                .$what\n                .$how()\n                .filter(|a| a.b.requires.is_some())\n                .find(|arg| &arg.b.name == $a)\n                .map(|a| a.b.requires.as_ref().unwrap())\n            {\n                for &(_, r) in rl.iter() {\n                    if !$p.contains(&r) {\n                        debugln!(\n                            \"usage::get_required_usage_from:iter:{}: adding arg req={:?}\",\n                            $a,\n                            r\n                        );\n                        $v.push(r);\n                    }\n                }\n            }\n        }};\n    }\n    // initialize new_reqs\n    for a in reqs {\n        get_requires!(a, flags, iter, new_reqs, reqs);\n        get_requires!(a, opts, iter, new_reqs, reqs);\n        get_requires!(a, positionals, values, new_reqs, reqs);\n        get_requires!(@group a, new_reqs, reqs);\n    }\n    desc_reqs.extend_from_slice(&*new_reqs);\n    debugln!(\n        \"usage::get_required_usage_from: after init desc_reqs={:?}\",\n        desc_reqs\n    );\n    loop {\n        let mut tmp = vec![];\n        for a in &new_reqs {\n            get_requires!(a, flags, iter, tmp, desc_reqs);\n            get_requires!(a, opts, iter, tmp, desc_reqs);\n            get_requires!(a, positionals, values, tmp, desc_reqs);\n            get_requires!(@group a, tmp, desc_reqs);\n        }\n        if tmp.is_empty() {\n            debugln!(\"usage::get_required_usage_from: no more children\");\n            break;\n        } else {\n            debugln!(\"usage::get_required_usage_from: after iter tmp={:?}\", tmp);\n            debugln!(\n                \"usage::get_required_usage_from: after iter new_reqs={:?}\",\n                new_reqs\n            );\n            desc_reqs.extend_from_slice(&*new_reqs);\n            new_reqs.clear();\n            new_reqs.extend_from_slice(&*tmp);\n            debugln!(\n                \"usage::get_required_usage_from: after iter desc_reqs={:?}\",\n                desc_reqs\n            );\n        }\n    }\n    desc_reqs.extend_from_slice(reqs);\n    desc_reqs.sort();\n    desc_reqs.dedup();\n    debugln!(\n        \"usage::get_required_usage_from: final desc_reqs={:?}\",\n        desc_reqs\n    );\n    let mut ret_val = VecDeque::new();\n    let args_in_groups = p\n        .groups\n        .iter()\n        .filter(|gn| desc_reqs.contains(&gn.name))\n        .flat_map(|g| p.arg_names_in_group(g.name))\n        .collect::<Vec<_>>();\n\n    let pmap = if let Some(m) = matcher {\n        desc_reqs\n            .iter()\n            .filter(|a| p.positionals.values().any(|p| &&p.b.name == a))\n            .filter(|&pos| !m.contains(pos))\n            .filter_map(|pos| p.positionals.values().find(|x| &x.b.name == pos))\n            .filter(|&pos| incl_last || !pos.is_set(ArgSettings::Last))\n            .filter(|pos| !args_in_groups.contains(&pos.b.name))\n            .map(|pos| (pos.index, pos))\n            .collect::<BTreeMap<u64, &PosBuilder>>() // sort by index\n    } else {\n        desc_reqs\n            .iter()\n            .filter(|a| p.positionals.values().any(|pos| &&pos.b.name == a))\n            .filter_map(|pos| p.positionals.values().find(|x| &x.b.name == pos))\n            .filter(|&pos| incl_last || !pos.is_set(ArgSettings::Last))\n            .filter(|pos| !args_in_groups.contains(&pos.b.name))\n            .map(|pos| (pos.index, pos))\n            .collect::<BTreeMap<u64, &PosBuilder>>() // sort by index\n    };\n    debugln!(\n        \"usage::get_required_usage_from: args_in_groups={:?}\",\n        args_in_groups\n    );\n    for &p in pmap.values() {\n        let s = p.to_string();\n        if args_in_groups.is_empty() || !args_in_groups.contains(&&*s) {\n            ret_val.push_back(s);\n        }\n    }\n    for a in desc_reqs\n        .iter()\n        .filter(|name| !p.positionals.values().any(|p| &&p.b.name == name))\n        .filter(|name| !p.groups.iter().any(|g| &&g.name == name))\n        .filter(|name| !args_in_groups.contains(name))\n        .filter(|name| !(matcher.is_some() && matcher.as_ref().unwrap().contains(name)))\n    {\n        debugln!(\"usage::get_required_usage_from:iter:{}:\", a);\n        let arg = find_by_name!(p, *a, flags, iter)\n            .map(|f| f.to_string())\n            .unwrap_or_else(|| {\n                find_by_name!(p, *a, opts, iter)\n                    .map(|o| o.to_string())\n                    .expect(INTERNAL_ERROR_MSG)\n            });\n        ret_val.push_back(arg);\n    }\n    let mut g_vec: Vec<String> = vec![];\n    for g in desc_reqs\n        .iter()\n        .filter(|n| p.groups.iter().any(|g| &&g.name == n))\n    {\n        let g_string = p.args_in_group(g).join(\"|\");\n        let elem = format!(\"<{}>\", &g_string[..g_string.len()]);\n        if !g_vec.contains(&elem) {\n            g_vec.push(elem);\n        }\n    }\n    for g in g_vec {\n        ret_val.push_back(g);\n    }\n\n    ret_val\n}","Real(LocalPath(\"src/app/usage.rs\"))"],"app::usage::needs_flags_tag":["fn needs_flags_tag(p: &Parser) -> bool{\n    debugln!(\"usage::needs_flags_tag;\");\n    'outer: for f in &p.flags {\n        debugln!(\"usage::needs_flags_tag:iter: f={};\", f.b.name);\n        if let Some(l) = f.s.long {\n            if l == \"help\" || l == \"version\" {\n                // Don't print `[FLAGS]` just for help or version\n                continue;\n            }\n        }\n        if let Some(g_vec) = p.groups_for_arg(f.b.name) {\n            for grp_s in &g_vec {\n                debugln!(\"usage::needs_flags_tag:iter:iter: grp_s={};\", grp_s);\n                if p.groups.iter().any(|g| &g.name == grp_s && g.required) {\n                    debugln!(\"usage::needs_flags_tag:iter:iter: Group is required\");\n                    continue 'outer;\n                }\n            }\n        }\n        if f.is_set(ArgSettings::Hidden) {\n            continue;\n        }\n        debugln!(\"usage::needs_flags_tag:iter: [FLAGS] required\");\n        return true;\n    }\n\n    debugln!(\"usage::needs_flags_tag: [FLAGS] not required\");\n    false\n}","Real(LocalPath(\"src/app/usage.rs\"))"],"app::validator::Validator":["pub struct Validator<'a, 'b, 'z>(&'z mut Parser<'a, 'b>)\nwhere\n    'a: 'b,\n    'b: 'z;","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::build_err":["fn build_err(&self, name: &str, matcher: &ArgMatcher) -> ClapResult<()>{\n        debugln!(\"build_err!: name={}\", name);\n        let mut c_with = find_from!(self.0, &name, blacklist, matcher);\n        c_with = c_with.or(self\n            .0\n            .find_any_arg(name)\n            .map_or(None, |aa| aa.blacklist())\n            .map_or(None, |bl| bl.iter().find(|arg| matcher.contains(arg)))\n            .map_or(None, |an| self.0.find_any_arg(an))\n            .map_or(None, |aa| Some(format!(\"{}\", aa))));\n        debugln!(\"build_err!: '{:?}' conflicts with '{}'\", c_with, &name);\n        //        matcher.remove(&name);\n        let usg = usage::create_error_usage(self.0, matcher, None);\n        if let Some(f) = find_by_name!(self.0, name, flags, iter) {\n            debugln!(\"build_err!: It was a flag...\");\n            Err(Error::argument_conflict(f, c_with, &*usg, self.0.color()))\n        } else if let Some(o) = find_by_name!(self.0, name, opts, iter) {\n            debugln!(\"build_err!: It was an option...\");\n            Err(Error::argument_conflict(o, c_with, &*usg, self.0.color()))\n        } else {\n            match find_by_name!(self.0, name, positionals, values) {\n                Some(p) => {\n                    debugln!(\"build_err!: It was a positional...\");\n                    Err(Error::argument_conflict(p, c_with, &*usg, self.0.color()))\n                }\n                None => panic!(INTERNAL_ERROR_MSG),\n            }\n        }\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::is_missing_required_ok":["#[inline]\nfn is_missing_required_ok(&self, a: &AnyArg, matcher: &ArgMatcher) -> bool{\n        debugln!(\"Validator::is_missing_required_ok: a={}\", a.name());\n        self.validate_arg_conflicts(a, matcher).unwrap_or(false)\n            || self.validate_required_unless(a, matcher).unwrap_or(false)\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::missing_required_error":["fn missing_required_error(&self, matcher: &ArgMatcher, extra: Option<&str>) -> ClapResult<()>{\n        debugln!(\"Validator::missing_required_error: extra={:?}\", extra);\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: self.0.color(),\n        });\n        let mut reqs = self.0.required.iter().map(|&r| &*r).collect::<Vec<_>>();\n        if let Some(r) = extra {\n            reqs.push(r);\n        }\n        reqs.retain(|n| !matcher.contains(n));\n        reqs.dedup();\n        debugln!(\"Validator::missing_required_error: reqs={:#?}\", reqs);\n        let req_args =\n            usage::get_required_usage_from(self.0, &reqs[..], Some(matcher), extra, true)\n                .iter()\n                .fold(String::new(), |acc, s| {\n                    acc + &format!(\"\\n    {}\", c.error(s))[..]\n                });\n        debugln!(\n            \"Validator::missing_required_error: req_args={:#?}\",\n            req_args\n        );\n        Err(Error::missing_required_argument(\n            &*req_args,\n            &*usage::create_error_usage(self.0, matcher, extra),\n            self.0.color(),\n        ))\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::new":["pub fn new(p: &'z mut Parser<'a, 'b>) -> Self{\n        Validator(p)\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate":["pub fn validate(\n        &mut self,\n        needs_val_of: ParseResult<'a>,\n        subcmd_name: Option<String>,\n        matcher: &mut ArgMatcher<'a>,\n    ) -> ClapResult<()>{\n        debugln!(\"Validator::validate;\");\n        let mut reqs_validated = false;\n        self.0.add_env(matcher)?;\n        self.0.add_defaults(matcher)?;\n        if let ParseResult::Opt(a) = needs_val_of {\n            debugln!(\"Validator::validate: needs_val_of={:?}\", a);\n            let o = {\n                self.0\n                    .opts\n                    .iter()\n                    .find(|o| o.b.name == a)\n                    .expect(INTERNAL_ERROR_MSG)\n                    .clone()\n            };\n            self.validate_required(matcher)?;\n            reqs_validated = true;\n            let should_err = if let Some(v) = matcher.0.args.get(&*o.b.name) {\n                v.vals.is_empty() && !(o.v.min_vals.is_some() && o.v.min_vals.unwrap() == 0)\n            } else {\n                true\n            };\n            if should_err {\n                return Err(Error::empty_value(\n                    &o,\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n        }\n\n        if matcher.is_empty()\n            && matcher.subcommand_name().is_none()\n            && self.0.is_set(AS::ArgRequiredElseHelp)\n        {\n            let mut out = vec![];\n            self.0.write_help_err(&mut out)?;\n            return Err(Error {\n                message: String::from_utf8_lossy(&*out).into_owned(),\n                kind: ErrorKind::MissingArgumentOrSubcommand,\n                info: None,\n            });\n        }\n        self.validate_blacklist(matcher)?;\n        if !(self.0.is_set(AS::SubcommandsNegateReqs) && subcmd_name.is_some()) && !reqs_validated {\n            self.validate_required(matcher)?;\n        }\n        self.validate_matched_args(matcher)?;\n        matcher.usage(usage::create_usage_with_title(self.0, &[]));\n\n        Ok(())\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_conflicts":["fn validate_arg_conflicts(&self, a: &AnyArg, matcher: &ArgMatcher) -> Option<bool>{\n        debugln!(\"Validator::validate_arg_conflicts: a={:?};\", a.name());\n        a.blacklist().map(|bl| {\n            bl.iter().any(|conf| {\n                matcher.contains(conf)\n                    || self\n                        .0\n                        .groups\n                        .iter()\n                        .find(|g| &g.name == conf)\n                        .map_or(false, |g| g.args.iter().any(|arg| matcher.contains(arg)))\n            })\n        })\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_num_occurs":["fn validate_arg_num_occurs<A>(\n        &self,\n        a: &A,\n        ma: &MatchedArg,\n        matcher: &ArgMatcher,\n    ) -> ClapResult<()>\n    where\n        A: AnyArg<'a, 'b> + Display,{\n        debugln!(\"Validator::validate_arg_num_occurs: a={};\", a.name());\n        if ma.occurs > 1 && !a.is_set(ArgSettings::Multiple) {\n            // Not the first time, and we don't allow multiples\n            return Err(Error::unexpected_multiple_usage(\n                a,\n                &*usage::create_error_usage(self.0, matcher, None),\n                self.0.color(),\n            ));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_num_vals":["fn validate_arg_num_vals<A>(\n        &self,\n        a: &A,\n        ma: &MatchedArg,\n        matcher: &ArgMatcher,\n    ) -> ClapResult<()>\n    where\n        A: AnyArg<'a, 'b> + Display,{\n        debugln!(\"Validator::validate_arg_num_vals:{}\", a.name());\n        if let Some(num) = a.num_vals() {\n            debugln!(\"Validator::validate_arg_num_vals: num_vals set...{}\", num);\n            let should_err = if a.is_set(ArgSettings::Multiple) {\n                ((ma.vals.len() as u64) % num) != 0\n            } else {\n                num != (ma.vals.len() as u64)\n            };\n            if should_err {\n                debugln!(\"Validator::validate_arg_num_vals: Sending error WrongNumberOfValues\");\n                return Err(Error::wrong_number_of_values(\n                    a,\n                    num,\n                    if a.is_set(ArgSettings::Multiple) {\n                        (ma.vals.len() % num as usize)\n                    } else {\n                        ma.vals.len()\n                    },\n                    if ma.vals.len() == 1\n                        || (a.is_set(ArgSettings::Multiple) && (ma.vals.len() % num as usize) == 1)\n                    {\n                        \"as\"\n                    } else {\n                        \"ere\"\n                    },\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n        }\n        if let Some(num) = a.max_vals() {\n            debugln!(\"Validator::validate_arg_num_vals: max_vals set...{}\", num);\n            if (ma.vals.len() as u64) > num {\n                debugln!(\"Validator::validate_arg_num_vals: Sending error TooManyValues\");\n                return Err(Error::too_many_values(\n                    ma.vals\n                        .iter()\n                        .last()\n                        .expect(INTERNAL_ERROR_MSG)\n                        .to_str()\n                        .expect(INVALID_UTF8),\n                    a,\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n        }\n        let min_vals_zero = if let Some(num) = a.min_vals() {\n            debugln!(\"Validator::validate_arg_num_vals: min_vals set: {}\", num);\n            if (ma.vals.len() as u64) < num && num != 0 {\n                debugln!(\"Validator::validate_arg_num_vals: Sending error TooFewValues\");\n                return Err(Error::too_few_values(\n                    a,\n                    num,\n                    ma.vals.len(),\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n            num == 0\n        } else {\n            false\n        };\n        // Issue 665 (https://github.com/clap-rs/clap/issues/665)\n        // Issue 1105 (https://github.com/clap-rs/clap/issues/1105)\n        if a.takes_value() && !min_vals_zero && ma.vals.is_empty() {\n            return Err(Error::empty_value(\n                a,\n                &*usage::create_error_usage(self.0, matcher, None),\n                self.0.color(),\n            ));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_requires":["fn validate_arg_requires<A>(\n        &self,\n        a: &A,\n        ma: &MatchedArg,\n        matcher: &ArgMatcher,\n    ) -> ClapResult<()>\n    where\n        A: AnyArg<'a, 'b> + Display,{\n        debugln!(\"Validator::validate_arg_requires:{};\", a.name());\n        if let Some(a_reqs) = a.requires() {\n            for &(val, name) in a_reqs.iter().filter(|&&(val, _)| val.is_some()) {\n                let missing_req =\n                    |v| v == val.expect(INTERNAL_ERROR_MSG) && !matcher.contains(name);\n                if ma.vals.iter().any(missing_req) {\n                    return self.missing_required_error(matcher, None);\n                }\n            }\n            for &(_, name) in a_reqs.iter().filter(|&&(val, _)| val.is_none()) {\n                if !matcher.contains(name) {\n                    return self.missing_required_error(matcher, Some(name));\n                }\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_values":["fn validate_arg_values<A>(\n        &self,\n        arg: &A,\n        ma: &MatchedArg,\n        matcher: &ArgMatcher<'a>,\n    ) -> ClapResult<()>\n    where\n        A: AnyArg<'a, 'b> + Display,{\n        debugln!(\"Validator::validate_arg_values: arg={:?}\", arg.name());\n        for val in &ma.vals {\n            if self.0.is_set(AS::StrictUtf8) && val.to_str().is_none() {\n                debugln!(\n                    \"Validator::validate_arg_values: invalid UTF-8 found in val {:?}\",\n                    val\n                );\n                return Err(Error::invalid_utf8(\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n            if let Some(p_vals) = arg.possible_vals() {\n                debugln!(\"Validator::validate_arg_values: possible_vals={:?}\", p_vals);\n                let val_str = val.to_string_lossy();\n                let ok = if arg.is_set(ArgSettings::CaseInsensitive) {\n                    p_vals.iter().any(|pv| pv.eq_ignore_ascii_case(&*val_str))\n                } else {\n                    p_vals.contains(&&*val_str)\n                };\n                if !ok {\n                    return Err(Error::invalid_value(\n                        val_str,\n                        p_vals,\n                        arg,\n                        &*usage::create_error_usage(self.0, matcher, None),\n                        self.0.color(),\n                    ));\n                }\n            }\n            if !arg.is_set(ArgSettings::EmptyValues)\n                && val.is_empty()\n                && matcher.contains(&*arg.name())\n            {\n                debugln!(\"Validator::validate_arg_values: illegal empty val found\");\n                return Err(Error::empty_value(\n                    arg,\n                    &*usage::create_error_usage(self.0, matcher, None),\n                    self.0.color(),\n                ));\n            }\n            if let Some(vtor) = arg.validator() {\n                debug!(\"Validator::validate_arg_values: checking validator...\");\n                if let Err(e) = vtor(val.to_string_lossy().into_owned()) {\n                    sdebugln!(\"error\");\n                    return Err(Error::value_validation(Some(arg), e, self.0.color()));\n                } else {\n                    sdebugln!(\"good\");\n                }\n            }\n            if let Some(vtor) = arg.validator_os() {\n                debug!(\"Validator::validate_arg_values: checking validator_os...\");\n                if let Err(e) = vtor(val) {\n                    sdebugln!(\"error\");\n                    return Err(Error::value_validation(\n                        Some(arg),\n                        (*e).to_string_lossy().to_string(),\n                        self.0.color(),\n                    ));\n                } else {\n                    sdebugln!(\"good\");\n                }\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate_blacklist":["fn validate_blacklist(&self, matcher: &mut ArgMatcher) -> ClapResult<()>{\n        debugln!(\"Validator::validate_blacklist;\");\n        let mut conflicts: Vec<&str> = vec![];\n        for (&name, _) in matcher.iter() {\n            debugln!(\"Validator::validate_blacklist:iter:{};\", name);\n            if let Some(grps) = self.0.groups_for_arg(name) {\n                for grp in &grps {\n                    if let Some(g) = self.0.groups.iter().find(|g| &g.name == grp) {\n                        if !g.multiple {\n                            for arg in &g.args {\n                                if arg == &name {\n                                    continue;\n                                }\n                                conflicts.push(arg);\n                            }\n                        }\n                        if let Some(ref gc) = g.conflicts {\n                            conflicts.extend(&*gc);\n                        }\n                    }\n                }\n            }\n            if let Some(arg) = find_any_by_name!(self.0, name) {\n                if let Some(bl) = arg.blacklist() {\n                    for conf in bl {\n                        if matcher.get(conf).is_some() {\n                            conflicts.push(conf);\n                        }\n                    }\n                }\n            } else {\n                debugln!(\"Validator::validate_blacklist:iter:{}:group;\", name);\n                let args = self.0.arg_names_in_group(name);\n                for arg in &args {\n                    debugln!(\n                        \"Validator::validate_blacklist:iter:{}:group:iter:{};\",\n                        name,\n                        arg\n                    );\n                    if let Some(bl) = find_any_by_name!(self.0, *arg).unwrap().blacklist() {\n                        for conf in bl {\n                            if matcher.get(conf).is_some() {\n                                conflicts.push(conf);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        for name in &conflicts {\n            debugln!(\n                \"Validator::validate_blacklist:iter:{}: Checking blacklisted arg\",\n                name\n            );\n            let mut should_err = false;\n            if self.0.groups.iter().any(|g| &g.name == name) {\n                debugln!(\n                    \"Validator::validate_blacklist:iter:{}: groups contains it...\",\n                    name\n                );\n                for n in self.0.arg_names_in_group(name) {\n                    debugln!(\n                        \"Validator::validate_blacklist:iter:{}:iter:{}: looking in group...\",\n                        name,\n                        n\n                    );\n                    if matcher.contains(n) {\n                        debugln!(\n                            \"Validator::validate_blacklist:iter:{}:iter:{}: matcher contains it...\",\n                            name,\n                            n\n                        );\n                        return self.build_err(n, matcher);\n                    }\n                }\n            } else if let Some(ma) = matcher.get(name) {\n                debugln!(\n                    \"Validator::validate_blacklist:iter:{}: matcher contains it...\",\n                    name\n                );\n                should_err = ma.occurs > 0;\n            }\n            if should_err {\n                return self.build_err(*name, matcher);\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate_blacklist::as_trait_obj":["fn as_trait_obj<'a, 'b, T: AnyArg<'a, 'b>>(x: &T) -> &AnyArg<'a, 'b>{\n            x\n        }","Real(LocalPath(\"src/macros.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate_matched_args":["fn validate_matched_args(&self, matcher: &mut ArgMatcher<'a>) -> ClapResult<()>{\n        debugln!(\"Validator::validate_matched_args;\");\n        for (name, ma) in matcher.iter() {\n            debugln!(\n                \"Validator::validate_matched_args:iter:{}: vals={:#?}\",\n                name,\n                ma.vals\n            );\n            if let Some(opt) = find_by_name!(self.0, *name, opts, iter) {\n                self.validate_arg_num_vals(opt, ma, matcher)?;\n                self.validate_arg_values(opt, ma, matcher)?;\n                self.validate_arg_requires(opt, ma, matcher)?;\n                self.validate_arg_num_occurs(opt, ma, matcher)?;\n            } else if let Some(flag) = find_by_name!(self.0, *name, flags, iter) {\n                self.validate_arg_requires(flag, ma, matcher)?;\n                self.validate_arg_num_occurs(flag, ma, matcher)?;\n            } else if let Some(pos) = find_by_name!(self.0, *name, positionals, values) {\n                self.validate_arg_num_vals(pos, ma, matcher)?;\n                self.validate_arg_num_occurs(pos, ma, matcher)?;\n                self.validate_arg_values(pos, ma, matcher)?;\n                self.validate_arg_requires(pos, ma, matcher)?;\n            } else {\n                let grp = self\n                    .0\n                    .groups\n                    .iter()\n                    .find(|g| &g.name == name)\n                    .expect(INTERNAL_ERROR_MSG);\n                if let Some(ref g_reqs) = grp.requires {\n                    if g_reqs.iter().any(|&n| !matcher.contains(n)) {\n                        return self.missing_required_error(matcher, None);\n                    }\n                }\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate_required":["fn validate_required(&mut self, matcher: &ArgMatcher) -> ClapResult<()>{\n        debugln!(\n            \"Validator::validate_required: required={:?};\",\n            self.0.required\n        );\n\n        let mut should_err = false;\n        let mut to_rem = Vec::new();\n        for name in &self.0.required {\n            debugln!(\"Validator::validate_required:iter:{}:\", name);\n            if matcher.contains(name) {\n                continue;\n            }\n            if to_rem.contains(name) {\n                continue;\n            } else if let Some(a) = find_any_by_name!(self.0, *name) {\n                if self.is_missing_required_ok(a, matcher) {\n                    to_rem.push(a.name());\n                    if let Some(reqs) = a.requires() {\n                        for r in reqs\n                            .iter()\n                            .filter(|&&(val, _)| val.is_none())\n                            .map(|&(_, name)| name)\n                        {\n                            to_rem.push(r);\n                        }\n                    }\n                    continue;\n                }\n            }\n            should_err = true;\n            break;\n        }\n        if should_err {\n            for r in &to_rem {\n                'inner: for i in (0..self.0.required.len()).rev() {\n                    if &self.0.required[i] == r {\n                        self.0.required.swap_remove(i);\n                        break 'inner;\n                    }\n                }\n            }\n            return self.missing_required_error(matcher, None);\n        }\n\n        // Validate the conditionally required args\n        for &(a, v, r) in &self.0.r_ifs {\n            if let Some(ma) = matcher.get(a) {\n                if matcher.get(r).is_none() && ma.vals.iter().any(|val| val == v) {\n                    return self.missing_required_error(matcher, Some(r));\n                }\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate_required::as_trait_obj":["fn as_trait_obj<'a, 'b, T: AnyArg<'a, 'b>>(x: &T) -> &AnyArg<'a, 'b>{\n            x\n        }","Real(LocalPath(\"src/macros.rs\"))"],"app::validator::Validator::<'a, 'b, 'z>::validate_required_unless":["fn validate_required_unless(&self, a: &AnyArg, matcher: &ArgMatcher) -> Option<bool>{\n        debugln!(\"Validator::validate_required_unless: a={:?};\", a.name());\n        macro_rules! check {\n            ($how:ident, $_self:expr, $a:ident, $m:ident) => {{\n                $a.required_unless().map(|ru| {\n                    ru.iter().$how(|n| {\n                        $m.contains(n) || {\n                            if let Some(grp) = $_self.groups.iter().find(|g| &g.name == n) {\n                                grp.args.iter().any(|arg| $m.contains(arg))\n                            } else {\n                                false\n                            }\n                        }\n                    })\n                })\n            }};\n        }\n        if a.is_set(ArgSettings::RequiredUnlessAll) {\n            check!(all, self.0, a, matcher)\n        } else {\n            check!(any, self.0, a, matcher)\n        }\n    }","Real(LocalPath(\"src/app/validator.rs\"))"],"args::any_arg::AnyArg":["#[doc(hidden)]\npub trait AnyArg<'n, 'e>: std_fmt::Display {\n    fn name(&self) -> &'n str;\n    fn overrides(&self) -> Option<&[&'e str]>;\n    fn aliases(&self) -> Option<Vec<&'e str>>;\n    fn requires(&self) -> Option<&[(Option<&'e str>, &'n str)]>;\n    fn blacklist(&self) -> Option<&[&'e str]>;\n    fn required_unless(&self) -> Option<&[&'e str]>;\n    fn is_set(&self, ArgSettings) -> bool;\n    fn set(&mut self, ArgSettings);\n    fn has_switch(&self) -> bool;\n    fn max_vals(&self) -> Option<u64>;\n    fn min_vals(&self) -> Option<u64>;\n    fn num_vals(&self) -> Option<u64>;\n    fn possible_vals(&self) -> Option<&[&'e str]>;\n    fn validator(&self) -> Option<&Rc<Fn(String) -> Result<(), String>>>;\n    fn validator_os(&self) -> Option<&Rc<Fn(&OsStr) -> Result<(), OsString>>>;\n    fn short(&self) -> Option<char>;\n    fn long(&self) -> Option<&'e str>;\n    fn val_delim(&self) -> Option<char>;\n    fn takes_value(&self) -> bool;\n    fn val_names(&self) -> Option<&VecMap<&'e str>>;\n    fn help(&self) -> Option<&'e str>;\n    fn long_help(&self) -> Option<&'e str>;\n    fn default_val(&self) -> Option<&'e OsStr>;\n    fn default_vals_ifs(&self) -> Option<map::Values<(&'n str, Option<&'e OsStr>, &'e OsStr)>>;\n    fn env<'s>(&'s self) -> Option<(&'n OsStr, Option<&'s OsString>)>;\n    fn longest_filter(&self) -> bool;\n    fn val_terminator(&self) -> Option<&'e str>;\n}","Real(LocalPath(\"src/args/any_arg.rs\"))"],"args::any_arg::DispOrder":["pub trait DispOrder {\n    fn disp_ord(&self) -> usize;\n}","Real(LocalPath(\"src/args/any_arg.rs\"))"],"args::arg::Arg":["/// The abstract representation of a command line argument. Used to set all the options and\n/// relationships that define a valid argument for the program.\n///\n/// There are two methods for constructing [`Arg`]s, using the builder pattern and setting options\n/// manually, or using a usage string which is far less verbose but has fewer options. You can also\n/// use a combination of the two methods to achieve the best of both worlds.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// // Using the traditional builder pattern and setting each option manually\n/// let cfg = Arg::with_name(\"config\")\n///       .short(\"c\")\n///       .long(\"config\")\n///       .takes_value(true)\n///       .value_name(\"FILE\")\n///       .help(\"Provides a config file to myprog\");\n/// // Using a usage string (setting a similar argument to the one above)\n/// let input = Arg::from_usage(\"-i, --input=[FILE] 'Provides an input file to the program'\");\n/// ```\n/// [`Arg`]: ./struct.Arg.html\n#[allow(missing_debug_implementations)]\npub struct Arg<'a, 'b>\nwhere\n    'a: 'b,\n{\n    #[doc(hidden)]\n    pub b: Base<'a, 'b>,\n    #[doc(hidden)]\n    pub s: Switched<'b>,\n    #[doc(hidden)]\n    pub v: Valued<'a, 'b>,\n    #[doc(hidden)]\n    pub index: Option<u64>,\n    #[doc(hidden)]\n    pub r_ifs: Option<Vec<(&'a str, &'b str)>>,\n}","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::alias":["/// Allows adding a [`Arg`] alias, which function as \"hidden\" arguments that\n/// automatically dispatch as if this argument was used. This is more efficient, and easier\n/// than creating multiple hidden arguments as one only needs to check for the existence of\n/// this command, and not all variants.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///             .arg(Arg::with_name(\"test\")\n///             .long(\"test\")\n///             .alias(\"alias\")\n///             .takes_value(true))\n///        .get_matches_from(vec![\n///             \"prog\", \"--alias\", \"cool\"\n///         ]);\n/// assert!(m.is_present(\"test\"));\n/// assert_eq!(m.value_of(\"test\"), Some(\"cool\"));\n/// ```\n/// [`Arg`]: ./struct.Arg.html\npub fn alias<S: Into<&'b str>>(mut self, name: S) -> Self{\n        if let Some(ref mut als) = self.s.aliases {\n            als.push((name.into(), false));\n        } else {\n            self.s.aliases = Some(vec![(name.into(), false)]);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::aliases":["/// Allows adding [`Arg`] aliases, which function as \"hidden\" arguments that\n/// automatically dispatch as if this argument was used. This is more efficient, and easier\n/// than creating multiple hidden subcommands as one only needs to check for the existence of\n/// this command, and not all variants.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///             .arg(Arg::with_name(\"test\")\n///                     .long(\"test\")\n///                     .aliases(&[\"do-stuff\", \"do-tests\", \"tests\"])\n///                     .help(\"the file to add\")\n///                     .required(false))\n///             .get_matches_from(vec![\n///                 \"prog\", \"--do-tests\"\n///             ]);\n/// assert!(m.is_present(\"test\"));\n/// ```\n/// [`Arg`]: ./struct.Arg.html\npub fn aliases(mut self, names: &[&'b str]) -> Self{\n        if let Some(ref mut als) = self.s.aliases {\n            for n in names {\n                als.push((n, false));\n            }\n        } else {\n            self.s.aliases = Some(names.iter().map(|n| (*n, false)).collect::<Vec<_>>());\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::allow_hyphen_values":["/// Allows values which start with a leading hyphen (`-`)\n///\n/// **WARNING**: Take caution when using this setting combined with [`Arg::multiple(true)`], as\n/// this becomes ambiguous `$ prog --arg -- -- val`. All three `--, --, val` will be values\n/// when the user may have thought the second `--` would constitute the normal, \"Only\n/// positional args follow\" idiom. To fix this, consider using [`Arg::number_of_values(1)`]\n///\n/// **WARNING**: When building your CLIs, consider the effects of allowing leading hyphens and\n/// the user passing in a value that matches a valid short. For example `prog -opt -F` where\n/// `-F` is supposed to be a value, yet `-F` is *also* a valid short for another arg. Care should\n/// should be taken when designing these args. This is compounded by the ability to \"stack\"\n/// short args. I.e. if `-val` is supposed to be a value, but `-v`, `-a`, and `-l` are all valid\n/// shorts.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"pattern\")\n///     .allow_hyphen_values(true)\n/// # ;\n/// ```\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"pat\")\n///         .allow_hyphen_values(true)\n///         .takes_value(true)\n///         .long(\"pattern\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--pattern\", \"-file\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"pat\"), Some(\"-file\"));\n/// ```\n///\n/// Not setting [`Arg::allow_hyphen_values(true)`] and supplying a value which starts with a\n/// hyphen is an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"pat\")\n///         .takes_value(true)\n///         .long(\"pattern\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--pattern\", \"-file\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::UnknownArgument);\n/// ```\n/// [`Arg::allow_hyphen_values(true)`]: ./struct.Arg.html#method.allow_hyphen_values\n/// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n/// [`Arg::number_of_values(1)`]: ./struct.Arg.html#method.number_of_values\npub fn allow_hyphen_values(self, a: bool) -> Self{\n        if a {\n            self.set(ArgSettings::AllowLeadingHyphen)\n        } else {\n            self.unset(ArgSettings::AllowLeadingHyphen)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::case_insensitive":["/// When used with [`Arg::possible_values`] it allows the argument value to pass validation even if\n/// the case differs from that of the specified `possible_value`.\n///\n/// **Pro Tip:** Use this setting with [`arg_enum!`]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// # use std::ascii::AsciiExt;\n/// let m = App::new(\"pv\")\n///     .arg(Arg::with_name(\"option\")\n///         .long(\"--option\")\n///         .takes_value(true)\n///         .possible_value(\"test123\")\n///         .case_insensitive(true))\n///     .get_matches_from(vec![\n///         \"pv\", \"--option\", \"TeSt123\",\n///     ]);\n///\n/// assert!(m.value_of(\"option\").unwrap().eq_ignore_ascii_case(\"test123\"));\n/// ```\n///\n/// This setting also works when multiple values can be defined:\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"pv\")\n///     .arg(Arg::with_name(\"option\")\n///         .short(\"-o\")\n///         .long(\"--option\")\n///         .takes_value(true)\n///         .possible_value(\"test123\")\n///         .possible_value(\"test321\")\n///         .multiple(true)\n///         .case_insensitive(true))\n///     .get_matches_from(vec![\n///         \"pv\", \"--option\", \"TeSt123\", \"teST123\", \"tESt321\"\n///     ]);\n///\n/// let matched_vals = m.values_of(\"option\").unwrap().collect::<Vec<_>>();\n/// assert_eq!(&*matched_vals, &[\"TeSt123\", \"teST123\", \"tESt321\"]);\n/// ```\n/// [`Arg::case_insensitive(true)`]: ./struct.Arg.html#method.possible_values\n/// [`arg_enum!`]: ./macro.arg_enum.html\npub fn case_insensitive(self, ci: bool) -> Self{\n        if ci {\n            self.set(ArgSettings::CaseInsensitive)\n        } else {\n            self.unset(ArgSettings::CaseInsensitive)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::conflicts_with":["/// Sets a conflicting argument by name. I.e. when using this argument,\n/// the following argument can't be present and vice versa.\n///\n/// **NOTE:** Conflicting rules take precedence over being required by default. Conflict rules\n/// only need to be set for one of the two arguments, they do not need to be set for each.\n///\n/// **NOTE:** Defining a conflict is two-way, but does *not* need to defined for both arguments\n/// (i.e. if A conflicts with B, defining A.conflicts_with(B) is sufficient. You do not need\n/// need to also do B.conflicts_with(A))\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .conflicts_with(\"debug\")\n/// # ;\n/// ```\n///\n/// Setting conflicting argument, and having both arguments present at runtime is an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .takes_value(true)\n///         .conflicts_with(\"debug\")\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"debug\")\n///         .long(\"debug\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--debug\", \"--config\", \"file.conf\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::ArgumentConflict);\n/// ```\npub fn conflicts_with(mut self, name: &'a str) -> Self{\n        if let Some(ref mut vec) = self.b.blacklist {\n            vec.push(name);\n        } else {\n            self.b.blacklist = Some(vec![name]);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::conflicts_with_all":["/// The same as [`Arg::conflicts_with`] but allows specifying multiple two-way conlicts per\n/// argument.\n///\n/// **NOTE:** Conflicting rules take precedence over being required by default. Conflict rules\n/// only need to be set for one of the two arguments, they do not need to be set for each.\n///\n/// **NOTE:** Defining a conflict is two-way, but does *not* need to defined for both arguments\n/// (i.e. if A conflicts with B, defining A.conflicts_with(B) is sufficient. You do not need\n/// need to also do B.conflicts_with(A))\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .conflicts_with_all(&[\"debug\", \"input\"])\n/// # ;\n/// ```\n///\n/// Setting conflicting argument, and having any of the arguments present at runtime with a\n/// conflicting argument is an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .takes_value(true)\n///         .conflicts_with_all(&[\"debug\", \"input\"])\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"debug\")\n///         .long(\"debug\"))\n///     .arg(Arg::with_name(\"input\")\n///         .index(1))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--config\", \"file.conf\", \"file.txt\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::ArgumentConflict);\n/// ```\n/// [`Arg::conflicts_with`]: ./struct.Arg.html#method.conflicts_with\npub fn conflicts_with_all(mut self, names: &[&'a str]) -> Self{\n        if let Some(ref mut vec) = self.b.blacklist {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.b.blacklist = Some(names.iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::default_value":["/// Specifies the value of the argument when *not* specified at runtime.\n///\n/// **NOTE:** If the user *does not* use this argument at runtime, [`ArgMatches::occurrences_of`]\n/// will return `0` even though the [`ArgMatches::value_of`] will return the default specified.\n///\n/// **NOTE:** If the user *does not* use this argument at runtime [`ArgMatches::is_present`] will\n/// still return `true`. If you wish to determine whether the argument was used at runtime or\n/// not, consider [`ArgMatches::occurrences_of`] which will return `0` if the argument was *not*\n/// used at runtime.\n///\n/// **NOTE:** This setting is perfectly compatible with [`Arg::default_value_if`] but slightly\n/// different. `Arg::default_value` *only* takes affect when the user has not provided this arg\n/// at runtime. `Arg::default_value_if` however only takes affect when the user has not provided\n/// a value at runtime **and** these other conditions are met as well. If you have set\n/// `Arg::default_value` and `Arg::default_value_if`, and the user **did not** provide a this\n/// arg at runtime, nor did were the conditions met for `Arg::default_value_if`, the\n/// `Arg::default_value` will be applied.\n///\n/// **NOTE:** This implicitly sets [`Arg::takes_value(true)`].\n///\n/// **NOTE:** This setting effectively disables `AppSettings::ArgRequiredElseHelp` if used in\n/// conjunction as it ensures that some argument will always be present.\n///\n/// # Examples\n///\n/// First we use the default value without providing any value at runtime.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"opt\")\n///         .long(\"myopt\")\n///         .default_value(\"myval\"))\n///     .get_matches_from(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"opt\"), Some(\"myval\"));\n/// assert!(m.is_present(\"opt\"));\n/// assert_eq!(m.occurrences_of(\"opt\"), 0);\n/// ```\n///\n/// Next we provide a value at runtime to override the default.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"opt\")\n///         .long(\"myopt\")\n///         .default_value(\"myval\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--myopt=non_default\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"opt\"), Some(\"non_default\"));\n/// assert!(m.is_present(\"opt\"));\n/// assert_eq!(m.occurrences_of(\"opt\"), 1);\n/// ```\n/// [`ArgMatches::occurrences_of`]: ./struct.ArgMatches.html#method.occurrences_of\n/// [`ArgMatches::value_of`]: ./struct.ArgMatches.html#method.value_of\n/// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n/// [`ArgMatches::is_present`]: ./struct.ArgMatches.html#method.is_present\n/// [`Arg::default_value_if`]: ./struct.Arg.html#method.default_value_if\npub fn default_value(self, val: &'a str) -> Self{\n        self.default_value_os(OsStr::from_bytes(val.as_bytes()))\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::default_value_if":["/// Specifies the value of the argument if `arg` has been used at runtime. If `val` is set to\n/// `None`, `arg` only needs to be present. If `val` is set to `\"some-val\"` then `arg` must be\n/// present at runtime **and** have the value `val`.\n///\n/// **NOTE:** This setting is perfectly compatible with [`Arg::default_value`] but slightly\n/// different. `Arg::default_value` *only* takes affect when the user has not provided this arg\n/// at runtime. This setting however only takes affect when the user has not provided a value at\n/// runtime **and** these other conditions are met as well. If you have set `Arg::default_value`\n/// and `Arg::default_value_if`, and the user **did not** provide a this arg at runtime, nor did\n/// were the conditions met for `Arg::default_value_if`, the `Arg::default_value` will be\n/// applied.\n///\n/// **NOTE:** This implicitly sets [`Arg::takes_value(true)`].\n///\n/// **NOTE:** If using YAML the values should be laid out as follows (`None` can be represented\n/// as `null` in YAML)\n///\n/// ```yaml\n/// default_value_if:\n///     - [arg, val, default]\n/// ```\n///\n/// # Examples\n///\n/// First we use the default value only if another arg is present at runtime.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .long(\"flag\"))\n///     .arg(Arg::with_name(\"other\")\n///         .long(\"other\")\n///         .default_value_if(\"flag\", None, \"default\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--flag\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"other\"), Some(\"default\"));\n/// ```\n///\n/// Next we run the same test, but without providing `--flag`.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .long(\"flag\"))\n///     .arg(Arg::with_name(\"other\")\n///         .long(\"other\")\n///         .default_value_if(\"flag\", None, \"default\"))\n///     .get_matches_from(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"other\"), None);\n/// ```\n///\n/// Now lets only use the default value if `--opt` contains the value `special`.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"opt\")\n///         .takes_value(true)\n///         .long(\"opt\"))\n///     .arg(Arg::with_name(\"other\")\n///         .long(\"other\")\n///         .default_value_if(\"opt\", Some(\"special\"), \"default\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--opt\", \"special\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"other\"), Some(\"default\"));\n/// ```\n///\n/// We can run the same test and provide any value *other than* `special` and we won't get a\n/// default value.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"opt\")\n///         .takes_value(true)\n///         .long(\"opt\"))\n///     .arg(Arg::with_name(\"other\")\n///         .long(\"other\")\n///         .default_value_if(\"opt\", Some(\"special\"), \"default\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--opt\", \"hahaha\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"other\"), None);\n/// ```\n/// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n/// [`Arg::default_value`]: ./struct.Arg.html#method.default_value\npub fn default_value_if(self, arg: &'a str, val: Option<&'b str>, default: &'b str) -> Self{\n        self.default_value_if_os(\n            arg,\n            val.map(str::as_bytes).map(OsStr::from_bytes),\n            OsStr::from_bytes(default.as_bytes()),\n        )\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::default_value_if_os":["/// Provides a conditional default value in the exact same manner as [`Arg::default_value_if`]\n/// only using [`OsStr`]s instead.\n/// [`Arg::default_value_if`]: ./struct.Arg.html#method.default_value_if\n/// [`OsStr`]: https://doc.rust-lang.org/std/ffi/struct.OsStr.html\npub fn default_value_if_os(\n        mut self,\n        arg: &'a str,\n        val: Option<&'b OsStr>,\n        default: &'b OsStr,\n    ) -> Self{\n        self.setb(ArgSettings::TakesValue);\n        if let Some(ref mut vm) = self.v.default_vals_ifs {\n            let l = vm.len();\n            vm.insert(l, (arg, val, default));\n        } else {\n            let mut vm = VecMap::new();\n            vm.insert(0, (arg, val, default));\n            self.v.default_vals_ifs = Some(vm);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::default_value_ifs":["/// Specifies multiple values and conditions in the same manner as [`Arg::default_value_if`].\n/// The method takes a slice of tuples in the `(arg, Option<val>, default)` format.\n///\n/// **NOTE**: The conditions are stored in order and evaluated in the same order. I.e. the first\n/// if multiple conditions are true, the first one found will be applied and the ultimate value.\n///\n/// **NOTE:** If using YAML the values should be laid out as follows\n///\n/// ```yaml\n/// default_value_if:\n///     - [arg, val, default]\n///     - [arg2, null, default2]\n/// ```\n///\n/// # Examples\n///\n/// First we use the default value only if another arg is present at runtime.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .long(\"flag\"))\n///     .arg(Arg::with_name(\"opt\")\n///         .long(\"opt\")\n///         .takes_value(true))\n///     .arg(Arg::with_name(\"other\")\n///         .long(\"other\")\n///         .default_value_ifs(&[\n///             (\"flag\", None, \"default\"),\n///             (\"opt\", Some(\"channal\"), \"chan\"),\n///         ]))\n///     .get_matches_from(vec![\n///         \"prog\", \"--opt\", \"channal\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"other\"), Some(\"chan\"));\n/// ```\n///\n/// Next we run the same test, but without providing `--flag`.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .long(\"flag\"))\n///     .arg(Arg::with_name(\"other\")\n///         .long(\"other\")\n///         .default_value_ifs(&[\n///             (\"flag\", None, \"default\"),\n///             (\"opt\", Some(\"channal\"), \"chan\"),\n///         ]))\n///     .get_matches_from(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"other\"), None);\n/// ```\n///\n/// We can also see that these values are applied in order, and if more than one condition is\n/// true, only the first evaluated \"wins\"\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .long(\"flag\"))\n///     .arg(Arg::with_name(\"opt\")\n///         .long(\"opt\")\n///         .takes_value(true))\n///     .arg(Arg::with_name(\"other\")\n///         .long(\"other\")\n///         .default_value_ifs(&[\n///             (\"flag\", None, \"default\"),\n///             (\"opt\", Some(\"channal\"), \"chan\"),\n///         ]))\n///     .get_matches_from(vec![\n///         \"prog\", \"--opt\", \"channal\", \"--flag\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"other\"), Some(\"default\"));\n/// ```\n/// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n/// [`Arg::default_value`]: ./struct.Arg.html#method.default_value\npub fn default_value_ifs(mut self, ifs: &[(&'a str, Option<&'b str>, &'b str)]) -> Self{\n        for &(arg, val, default) in ifs {\n            self = self.default_value_if_os(\n                arg,\n                val.map(str::as_bytes).map(OsStr::from_bytes),\n                OsStr::from_bytes(default.as_bytes()),\n            );\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::default_value_ifs_os":["/// Provides multiple conditional default values in the exact same manner as\n/// [`Arg::default_value_ifs`] only using [`OsStr`]s instead.\n/// [`Arg::default_value_ifs`]: ./struct.Arg.html#method.default_value_ifs\n/// [`OsStr`]: https://doc.rust-lang.org/std/ffi/struct.OsStr.html\npub fn default_value_ifs_os(mut self, ifs: &[(&'a str, Option<&'b OsStr>, &'b OsStr)]) -> Self{\n        for &(arg, val, default) in ifs {\n            self = self.default_value_if_os(arg, val, default);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::default_value_os":["/// Provides a default value in the exact same manner as [`Arg::default_value`]\n/// only using [`OsStr`]s instead.\n/// [`Arg::default_value`]: ./struct.Arg.html#method.default_value\n/// [`OsStr`]: https://doc.rust-lang.org/std/ffi/struct.OsStr.html\npub fn default_value_os(mut self, val: &'a OsStr) -> Self{\n        self.setb(ArgSettings::TakesValue);\n        self.v.default_val = Some(val);\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::display_order":["/// Allows custom ordering of args within the help message. Args with a lower value will be\n/// displayed first in the help message. This is helpful when one would like to emphasise\n/// frequently used args, or prioritize those towards the top of the list. Duplicate values\n/// **are** allowed. Args with duplicate display orders will be displayed in alphabetical\n/// order.\n///\n/// **NOTE:** The default is 999 for all arguments.\n///\n/// **NOTE:** This setting is ignored for [positional arguments] which are always displayed in\n/// [index] order.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"a\") // Typically args are grouped alphabetically by name.\n///                              // Args without a display_order have a value of 999 and are\n///                              // displayed alphabetically with all other 999 valued args.\n///         .long(\"long-option\")\n///         .short(\"o\")\n///         .takes_value(true)\n///         .help(\"Some help and text\"))\n///     .arg(Arg::with_name(\"b\")\n///         .long(\"other-option\")\n///         .short(\"O\")\n///         .takes_value(true)\n///         .display_order(1)   // In order to force this arg to appear *first*\n///                             // all we have to do is give it a value lower than 999.\n///                             // Any other args with a value of 1 will be displayed\n///                             // alphabetically with this one...then 2 values, then 3, etc.\n///         .help(\"I should be first!\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--help\"\n///     ]);\n/// ```\n///\n/// The above example displays the following help message\n///\n/// ```notrust\n/// cust-ord\n///\n/// USAGE:\n///     cust-ord [FLAGS] [OPTIONS]\n///\n/// FLAGS:\n///     -h, --help       Prints help information\n///     -V, --version    Prints version information\n///\n/// OPTIONS:\n///     -O, --other-option <b>    I should be first!\n///     -o, --long-option <a>     Some help and text\n/// ```\n/// [positional arguments]: ./struct.Arg.html#method.index\n/// [index]: ./struct.Arg.html#method.index\npub fn display_order(mut self, ord: usize) -> Self{\n        self.s.disp_ord = ord;\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::empty_values":["/// Allows an argument to accept explicitly empty values. An empty value must be specified at\n/// the command line with an explicit `\"\"`, or `''`\n///\n/// **NOTE:** Defaults to `true` (Explicitly empty values are allowed)\n///\n/// **NOTE:** Implicitly sets [`Arg::takes_value(true)`] when set to `false`\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"file\")\n///     .long(\"file\")\n///     .empty_values(false)\n/// # ;\n/// ```\n/// The default is to allow empty values, such as `--option \"\"` would be an empty value. But\n/// we can change to make empty values become an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .long(\"config\")\n///         .short(\"v\")\n///         .empty_values(false))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--config=\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::EmptyValue);\n/// ```\n/// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\npub fn empty_values(mut self, ev: bool) -> Self{\n        if ev {\n            self.set(ArgSettings::EmptyValues)\n        } else {\n            self = self.set(ArgSettings::TakesValue);\n            self.unset(ArgSettings::EmptyValues)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::env":["/// Specifies that if the value is not passed in as an argument, that it should be retrieved\n/// from the environment, if available. If it is not present in the environment, then default\n/// rules will apply.\n///\n/// **NOTE:** If the user *does not* use this argument at runtime, [`ArgMatches::occurrences_of`]\n/// will return `0` even though the [`ArgMatches::value_of`] will return the default specified.\n///\n/// **NOTE:** If the user *does not* use this argument at runtime [`ArgMatches::is_present`] will\n/// return `true` if the variable is present in the environment . If you wish to determine whether\n/// the argument was used at runtime or not, consider [`ArgMatches::occurrences_of`] which will\n/// return `0` if the argument was *not* used at runtime.\n///\n/// **NOTE:** This implicitly sets [`Arg::takes_value(true)`].\n///\n/// **NOTE:** If [`Arg::multiple(true)`] is set then [`Arg::use_delimiter(true)`] should also be\n/// set. Otherwise, only a single argument will be returned from the environment variable. The\n/// default delimiter is `,` and follows all the other delimiter rules.\n///\n/// # Examples\n///\n/// In this example, we show the variable coming from the environment:\n///\n/// ```rust\n/// # use std::env;\n/// # use clap::{App, Arg};\n///\n/// env::set_var(\"MY_FLAG\", \"env\");\n///\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .long(\"flag\")\n///         .env(\"MY_FLAG\"))\n///     .get_matches_from(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"flag\"), Some(\"env\"));\n/// ```\n///\n/// In this example, we show the variable coming from an option on the CLI:\n///\n/// ```rust\n/// # use std::env;\n/// # use clap::{App, Arg};\n///\n/// env::set_var(\"MY_FLAG\", \"env\");\n///\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .long(\"flag\")\n///         .env(\"MY_FLAG\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--flag\", \"opt\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"flag\"), Some(\"opt\"));\n/// ```\n///\n/// In this example, we show the variable coming from the environment even with the\n/// presence of a default:\n///\n/// ```rust\n/// # use std::env;\n/// # use clap::{App, Arg};\n///\n/// env::set_var(\"MY_FLAG\", \"env\");\n///\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .long(\"flag\")\n///         .env(\"MY_FLAG\")\n///         .default_value(\"default\"))\n///     .get_matches_from(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert_eq!(m.value_of(\"flag\"), Some(\"env\"));\n/// ```\n///\n/// In this example, we show the use of multiple values in a single environment variable:\n///\n/// ```rust\n/// # use std::env;\n/// # use clap::{App, Arg};\n///\n/// env::set_var(\"MY_FLAG_MULTI\", \"env1,env2\");\n///\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .long(\"flag\")\n///         .env(\"MY_FLAG_MULTI\")\n///         .multiple(true)\n///         .use_delimiter(true))\n///     .get_matches_from(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert_eq!(m.values_of(\"flag\").unwrap().collect::<Vec<_>>(), vec![\"env1\", \"env2\"]);\n/// ```\n/// [`ArgMatches::occurrences_of`]: ./struct.ArgMatches.html#method.occurrences_of\n/// [`ArgMatches::value_of`]: ./struct.ArgMatches.html#method.value_of\n/// [`ArgMatches::is_present`]: ./struct.ArgMatches.html#method.is_present\n/// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n/// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n/// [`Arg::use_delimiter(true)`]: ./struct.Arg.html#method.use_delimiter\npub fn env(self, name: &'a str) -> Self{\n        self.env_os(OsStr::new(name))\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::env_os":["/// Specifies that if the value is not passed in as an argument, that it should be retrieved\n/// from the environment if available in the exact same manner as [`Arg::env`] only using\n/// [`OsStr`]s instead.\npub fn env_os(mut self, name: &'a OsStr) -> Self{\n        self.setb(ArgSettings::TakesValue);\n\n        self.v.env = Some((name, env::var_os(name)));\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::from_usage":["/// Creates a new instance of [`Arg`] from a usage string. Allows creation of basic settings\n/// for the [`Arg`]. The syntax is flexible, but there are some rules to follow.\n///\n/// **NOTE**: Not all settings may be set using the usage string method. Some properties are\n/// only available via the builder pattern.\n///\n/// **NOTE**: Only ASCII values are officially supported in [`Arg::from_usage`] strings. Some\n/// UTF-8 codepoints may work just fine, but this is not guaranteed.\n///\n/// # Syntax\n///\n/// Usage strings typically following the form:\n///\n/// ```notrust\n/// [explicit name] [short] [long] [value names] [help string]\n/// ```\n///\n/// This is not a hard rule as the attributes can appear in other orders. There are also\n/// several additional sigils which denote additional settings. Below are the details of each\n/// portion of the string.\n///\n/// ### Explicit Name\n///\n/// This is an optional field, if it's omitted the argument will use one of the additional\n/// fields as the name using the following priority order:\n///\n///  * Explicit Name (This always takes precedence when present)\n///  * Long\n///  * Short\n///  * Value Name\n///\n/// `clap` determines explicit names as the first string of characters between either `[]` or\n/// `<>` where `[]` has the dual notation of meaning the argument is optional, and `<>` meaning\n/// the argument is required.\n///\n/// Explicit names may be followed by:\n///  * The multiple denotation `...`\n///\n/// Example explicit names as follows (`ename` for an optional argument, and `rname` for a\n/// required argument):\n///\n/// ```notrust\n/// [ename] -s, --long 'some flag'\n/// <rname> -r, --longer 'some other flag'\n/// ```\n///\n/// ### Short\n///\n/// This is set by placing a single character after a leading `-`.\n///\n/// Shorts may be followed by\n///  * The multiple denotation `...`\n///  * An optional comma `,` which is cosmetic only\n///  * Value notation\n///\n/// Example shorts are as follows (`-s`, and `-r`):\n///\n/// ```notrust\n/// -s, --long 'some flag'\n/// <rname> -r [val], --longer 'some option'\n/// ```\n///\n/// ### Long\n///\n/// This is set by placing a word (no spaces) after a leading `--`.\n///\n/// Shorts may be followed by\n///  * The multiple denotation `...`\n///  * Value notation\n///\n/// Example longs are as follows (`--some`, and `--rapid`):\n///\n/// ```notrust\n/// -s, --some 'some flag'\n/// --rapid=[FILE] 'some option'\n/// ```\n///\n/// ### Values (Value Notation)\n///\n/// This is set by placing a word(s) between `[]` or `<>` optionally after `=` (although this\n/// is cosmetic only and does not affect functionality). If an explicit name has **not** been\n/// set, using `<>` will denote a required argument, and `[]` will denote an optional argument\n///\n/// Values may be followed by\n///  * The multiple denotation `...`\n///  * More Value notation\n///\n/// More than one value will also implicitly set the arguments number of values, i.e. having\n/// two values, `--option [val1] [val2]` specifies that in order for option to be satisified it\n/// must receive exactly two values\n///\n/// Example values are as follows (`FILE`, and `SPEED`):\n///\n/// ```notrust\n/// -s, --some [FILE] 'some option'\n/// --rapid=<SPEED>... 'some required multiple option'\n/// ```\n///\n/// ### Help String\n///\n/// The help string is denoted between a pair of single quotes `''` and may contain any\n/// characters.\n///\n/// Example help strings are as follows:\n///\n/// ```notrust\n/// -s, --some [FILE] 'some option'\n/// --rapid=<SPEED>... 'some required multiple option'\n/// ```\n///\n/// ### Additional Sigils\n///\n/// Multiple notation `...` (three consecutive dots/periods) specifies that this argument may\n/// be used multiple times. Do not confuse multiple occurrences (`...`) with multiple values.\n/// `--option val1 val2` is a single occurrence with multiple values. `--flag --flag` is\n/// multiple occurrences (and then you can obviously have instances of both as well)\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// App::new(\"prog\")\n///     .args(&[\n///         Arg::from_usage(\"--config <FILE> 'a required file for the configuration and no short'\"),\n///         Arg::from_usage(\"-d, --debug... 'turns on debugging information and allows multiples'\"),\n///         Arg::from_usage(\"[input] 'an optional input file to use'\")\n/// ])\n/// # ;\n/// ```\n/// [`Arg`]: ./struct.Arg.html\n/// [`Arg::from_usage`]: ./struct.Arg.html#method.from_usage\npub fn from_usage(u: &'a str) -> Self{\n        let parser = UsageParser::from_usage(u);\n        parser.parse()\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::global":["/// Specifies that an argument can be matched to all child [`SubCommand`]s.\n///\n/// **NOTE:** Global arguments *only* propagate down, **not** up (to parent commands), however\n/// their values once a user uses them will be propagated back up to parents. In effect, this\n/// means one should *define* all global arguments at the top level, however it doesn't matter\n/// where the user *uses* the global argument.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"debug\")\n///     .short(\"d\")\n///     .global(true)\n/// # ;\n/// ```\n///\n/// For example, assume an application with two subcommands, and you'd like to define a\n/// `--verbose` flag that can be called on any of the subcommands and parent, but you don't\n/// want to clutter the source with three duplicate [`Arg`] definitions.\n///\n/// ```rust\n/// # use clap::{App, Arg, SubCommand};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"verb\")\n///         .long(\"verbose\")\n///         .short(\"v\")\n///         .global(true))\n///     .subcommand(SubCommand::with_name(\"test\"))\n///     .subcommand(SubCommand::with_name(\"do-stuff\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"do-stuff\", \"--verbose\"\n///     ]);\n///\n/// assert_eq!(m.subcommand_name(), Some(\"do-stuff\"));\n/// let sub_m = m.subcommand_matches(\"do-stuff\").unwrap();\n/// assert!(sub_m.is_present(\"verb\"));\n/// ```\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [required]: ./struct.Arg.html#method.required\n/// [`ArgMatches`]: ./struct.ArgMatches.html\n/// [`ArgMatches::is_present(\"flag\")`]: ./struct.ArgMatches.html#method.is_present\n/// [`Arg`]: ./struct.Arg.html\npub fn global(self, g: bool) -> Self{\n        if g {\n            self.set(ArgSettings::Global)\n        } else {\n            self.unset(ArgSettings::Global)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::group":["/// Specifies the name of the [`ArgGroup`] the argument belongs to.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"debug\")\n///     .long(\"debug\")\n///     .group(\"mode\")\n/// # ;\n/// ```\n///\n/// Multiple arguments can be a member of a single group and then the group checked as if it\n/// was one of said arguments.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"debug\")\n///         .long(\"debug\")\n///         .group(\"mode\"))\n///     .arg(Arg::with_name(\"verbose\")\n///         .long(\"verbose\")\n///         .group(\"mode\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--debug\"\n///     ]);\n/// assert!(m.is_present(\"mode\"));\n/// ```\n/// [`ArgGroup`]: ./struct.ArgGroup.html\npub fn group(mut self, name: &'a str) -> Self{\n        if let Some(ref mut vec) = self.b.groups {\n            vec.push(name);\n        } else {\n            self.b.groups = Some(vec![name]);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::groups":["/// Specifies the names of multiple [`ArgGroup`]'s the argument belongs to.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"debug\")\n///     .long(\"debug\")\n///     .groups(&[\"mode\", \"verbosity\"])\n/// # ;\n/// ```\n///\n/// Arguments can be members of multiple groups and then the group checked as if it\n/// was one of said arguments.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"debug\")\n///         .long(\"debug\")\n///         .groups(&[\"mode\", \"verbosity\"]))\n///     .arg(Arg::with_name(\"verbose\")\n///         .long(\"verbose\")\n///         .groups(&[\"mode\", \"verbosity\"]))\n///     .get_matches_from(vec![\n///         \"prog\", \"--debug\"\n///     ]);\n/// assert!(m.is_present(\"mode\"));\n/// assert!(m.is_present(\"verbosity\"));\n/// ```\n/// [`ArgGroup`]: ./struct.ArgGroup.html\npub fn groups(mut self, names: &[&'a str]) -> Self{\n        if let Some(ref mut vec) = self.b.groups {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.b.groups = Some(names.into_iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::help":["/// Sets the short help text of the argument that will be displayed to the user when they print\n/// the help information with `-h`. Typically, this is a short (one line) description of the\n/// arg.\n///\n/// **NOTE:** If only `Arg::help` is provided, and not [`Arg::long_help`] but the user requests\n/// `--help` clap will still display the contents of `help` appropriately\n///\n/// **NOTE:** Only `Arg::help` is used in completion script generation in order to be concise\n///\n/// # Examples\n///\n/// Any valid UTF-8 is allowed in the help text. The one exception is when one wishes to\n/// include a newline in the help text and have the following text be properly aligned with all\n/// the other help text.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"config\")\n///     .help(\"The config file used by the myprog\")\n/// # ;\n/// ```\n///\n/// Setting `help` displays a short message to the side of the argument when the user passes\n/// `-h` or `--help` (by default).\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .long(\"config\")\n///         .help(\"Some help text describing the --config arg\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--help\"\n///     ]);\n/// ```\n///\n/// The above example displays\n///\n/// ```notrust\n/// helptest\n///\n/// USAGE:\n///    helptest [FLAGS]\n///\n/// FLAGS:\n///     --config     Some help text describing the --config arg\n/// -h, --help       Prints help information\n/// -V, --version    Prints version information\n/// ```\n/// [`Arg::long_help`]: ./struct.Arg.html#method.long_help\npub fn help(mut self, h: &'b str) -> Self{\n        self.b.help = Some(h);\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::hidden":["/// Hides an argument from help message output.\n///\n/// **NOTE:** Implicitly sets [`Arg::hidden_short_help(true)`] and [`Arg::hidden_long_help(true)`]\n/// when set to true\n///\n/// **NOTE:** This does **not** hide the argument from usage strings on error\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"debug\")\n///     .hidden(true)\n/// # ;\n/// ```\n/// Setting `hidden(true)` will hide the argument when displaying help text\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .long(\"config\")\n///         .hidden(true)\n///         .help(\"Some help text describing the --config arg\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--help\"\n///     ]);\n/// ```\n///\n/// The above example displays\n///\n/// ```notrust\n/// helptest\n///\n/// USAGE:\n///    helptest [FLAGS]\n///\n/// FLAGS:\n/// -h, --help       Prints help information\n/// -V, --version    Prints version information\n/// ```\n/// [`Arg::hidden_short_help(true)`]: ./struct.Arg.html#method.hidden_short_help\n/// [`Arg::hidden_long_help(true)`]: ./struct.Arg.html#method.hidden_long_help\npub fn hidden(self, h: bool) -> Self{\n        if h {\n            self.set(ArgSettings::Hidden)\n        } else {\n            self.unset(ArgSettings::Hidden)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::hidden_long_help":["/// Hides an argument from long help message output.\n///\n/// **NOTE:** This does **not** hide the argument from usage strings on error\n///\n/// **NOTE:** Setting this option will cause next-line-help output style to be used\n/// when long help (`--help`) is called.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"debug\")\n///     .hidden_long_help(true)\n/// # ;\n/// ```\n/// Setting `hidden_long_help(true)` will hide the argument when displaying long help text\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .long(\"config\")\n///         .hidden_long_help(true)\n///         .help(\"Some help text describing the --config arg\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--help\"\n///     ]);\n/// ```\n///\n/// The above example displays\n///\n/// ```notrust\n/// helptest\n///\n/// USAGE:\n///    helptest [FLAGS]\n///\n/// FLAGS:\n/// -h, --help       Prints help information\n/// -V, --version    Prints version information\n/// ```\n///\n/// However, when -h is called\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .long(\"config\")\n///         .hidden_long_help(true)\n///         .help(\"Some help text describing the --config arg\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"-h\"\n///     ]);\n/// ```\n///\n/// Then the following would be displayed\n///\n/// ```notrust\n/// helptest\n///\n/// USAGE:\n///    helptest [FLAGS]\n///\n/// FLAGS:\n///     --config     Some help text describing the --config arg\n/// -h, --help       Prints help information\n/// -V, --version    Prints version information\n/// ```\npub fn hidden_long_help(self, hide: bool) -> Self{\n        if hide {\n            self.set(ArgSettings::HiddenLongHelp)\n        } else {\n            self.unset(ArgSettings::HiddenLongHelp)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::hidden_short_help":["/// Hides an argument from short help message output.\n///\n/// **NOTE:** This does **not** hide the argument from usage strings on error\n///\n/// **NOTE:** Setting this option will cause next-line-help output style to be used\n/// when long help (`--help`) is called.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"debug\")\n///     .hidden_short_help(true)\n/// # ;\n/// ```\n/// Setting `hidden_short_help(true)` will hide the argument when displaying short help text\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .long(\"config\")\n///         .hidden_short_help(true)\n///         .help(\"Some help text describing the --config arg\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"-h\"\n///     ]);\n/// ```\n///\n/// The above example displays\n///\n/// ```notrust\n/// helptest\n///\n/// USAGE:\n///    helptest [FLAGS]\n///\n/// FLAGS:\n/// -h, --help       Prints help information\n/// -V, --version    Prints version information\n/// ```\n///\n/// However, when --help is called\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .long(\"config\")\n///         .hidden_short_help(true)\n///         .help(\"Some help text describing the --config arg\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--help\"\n///     ]);\n/// ```\n///\n/// Then the following would be displayed\n///\n/// ```notrust\n/// helptest\n///\n/// USAGE:\n///    helptest [FLAGS]\n///\n/// FLAGS:\n///     --config     Some help text describing the --config arg\n/// -h, --help       Prints help information\n/// -V, --version    Prints version information\n/// ```\npub fn hidden_short_help(self, hide: bool) -> Self{\n        if hide {\n            self.set(ArgSettings::HiddenShortHelp)\n        } else {\n            self.unset(ArgSettings::HiddenShortHelp)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::hide_default_value":["/// Specifies if the default value of an argument should be displayed in the help text or\n/// not. Defaults to `false` (i.e. show default value)\n///\n/// This is useful when default behavior of an arg is explained elsewhere in the help text.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"config\")\n///     .hide_default_value(true)\n/// # ;\n/// ```\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"connect\")\n///     .arg(Arg::with_name(\"host\")\n///         .long(\"host\")\n///         .default_value(\"localhost\")\n///         .hide_default_value(true));\n///\n/// ```\n///\n/// If we were to run the above program with `--help` the `[default: localhost]` portion of\n/// the help text would be omitted.\npub fn hide_default_value(self, hide: bool) -> Self{\n        if hide {\n            self.set(ArgSettings::HideDefaultValue)\n        } else {\n            self.unset(ArgSettings::HideDefaultValue)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::hide_env_values":["/// @TODO @p2 @docs @release: write docs\npub fn hide_env_values(self, hide: bool) -> Self{\n        if hide {\n            self.set(ArgSettings::HideEnvValues)\n        } else {\n            self.unset(ArgSettings::HideEnvValues)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::hide_possible_values":["/// Specifies if the possible values of an argument should be displayed in the help text or\n/// not. Defaults to `false` (i.e. show possible values)\n///\n/// This is useful for args with many values, or ones which are explained elsewhere in the\n/// help text.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"config\")\n///     .hide_possible_values(true)\n/// # ;\n/// ```\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"mode\")\n///         .long(\"mode\")\n///         .possible_values(&[\"fast\", \"slow\"])\n///         .takes_value(true)\n///         .hide_possible_values(true));\n///\n/// ```\n///\n/// If we were to run the above program with `--help` the `[values: fast, slow]` portion of\n/// the help text would be omitted.\npub fn hide_possible_values(self, hide: bool) -> Self{\n        if hide {\n            self.set(ArgSettings::HidePossibleValues)\n        } else {\n            self.unset(ArgSettings::HidePossibleValues)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::index":["/// Specifies the index of a positional argument **starting at** 1.\n///\n/// **NOTE:** The index refers to position according to **other positional argument**. It does\n/// not define position in the argument list as a whole.\n///\n/// **NOTE:** If no [`Arg::short`], or [`Arg::long`] have been defined, you can optionally\n/// leave off the `index` method, and the index will be assigned in order of evaluation.\n/// Utilizing the `index` method allows for setting indexes out of order\n///\n/// **NOTE:** When utilized with [`Arg::multiple(true)`], only the **last** positional argument\n/// may be defined as multiple (i.e. with the highest index)\n///\n/// # Panics\n///\n/// Although not in this method directly, [`App`] will [`panic!`] if indexes are skipped (such\n/// as defining `index(1)` and `index(3)` but not `index(2)`, or a positional argument is\n/// defined as multiple and is not the highest index\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"config\")\n///     .index(1)\n/// # ;\n/// ```\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"mode\")\n///         .index(1))\n///     .arg(Arg::with_name(\"debug\")\n///         .long(\"debug\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--debug\", \"fast\"\n///     ]);\n///\n/// assert!(m.is_present(\"mode\"));\n/// assert_eq!(m.value_of(\"mode\"), Some(\"fast\")); // notice index(1) means \"first positional\"\n///                                               // *not* first argument\n/// ```\n/// [`Arg::short`]: ./struct.Arg.html#method.short\n/// [`Arg::long`]: ./struct.Arg.html#method.long\n/// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n/// [`App`]: ./struct.App.html\n/// [`panic!`]: https://doc.rust-lang.org/std/macro.panic!.html\npub fn index(mut self, idx: u64) -> Self{\n        self.index = Some(idx);\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::is_set":["/// Checks if one of the [`ArgSettings`] settings is set for the argument.\n///\n/// [`ArgSettings`]: ./enum.ArgSettings.html\npub fn is_set(&self, s: ArgSettings) -> bool{\n        self.b.is_set(s)\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::last":["/// Specifies that this arg is the last, or final, positional argument (i.e. has the highest\n/// index) and is *only* able to be accessed via the `--` syntax (i.e. `$ prog args --\n/// last_arg`). Even, if no other arguments are left to parse, if the user omits the `--` syntax\n/// they will receive an [`UnknownArgument`] error. Setting an argument to `.last(true)` also\n/// allows one to access this arg early using the `--` syntax. Accessing an arg early, even with\n/// the `--` syntax is otherwise not possible.\n///\n/// **NOTE:** This will change the usage string to look like `$ prog [FLAGS] [-- <ARG>]` if\n/// `ARG` is marked as `.last(true)`.\n///\n/// **NOTE:** This setting will imply [`AppSettings::DontCollapseArgsInUsage`] because failing\n/// to set this can make the usage string very confusing.\n///\n/// **NOTE**: This setting only applies to positional arguments, and has no affect on FLAGS /\n/// OPTIONS\n///\n/// **CAUTION:** Setting an argument to `.last(true)` *and* having child subcommands is not\n/// recommended with the exception of *also* using [`AppSettings::ArgsNegateSubcommands`]\n/// (or [`AppSettings::SubcommandsNegateReqs`] if the argument marked `.last(true)` is also\n/// marked [`.required(true)`])\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"args\")\n///     .last(true)\n/// # ;\n/// ```\n///\n/// Setting [`Arg::last(true)`] ensures the arg has the highest [index] of all positional args\n/// and requires that the `--` syntax be used to access it early.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"first\"))\n///     .arg(Arg::with_name(\"second\"))\n///     .arg(Arg::with_name(\"third\").last(true))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"one\", \"--\", \"three\"\n///     ]);\n///\n/// assert!(res.is_ok());\n/// let m = res.unwrap();\n/// assert_eq!(m.value_of(\"third\"), Some(\"three\"));\n/// assert!(m.value_of(\"second\").is_none());\n/// ```\n///\n/// Even if the positional argument marked `.last(true)` is the only argument left to parse,\n/// failing to use the `--` syntax results in an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"first\"))\n///     .arg(Arg::with_name(\"second\"))\n///     .arg(Arg::with_name(\"third\").last(true))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"one\", \"two\", \"three\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::UnknownArgument);\n/// ```\n/// [`Arg::last(true)`]: ./struct.Arg.html#method.last\n/// [index]: ./struct.Arg.html#method.index\n/// [`AppSettings::DontCollapseArgsInUsage`]: ./enum.AppSettings.html#variant.DontCollapseArgsInUsage\n/// [`AppSettings::ArgsNegateSubcommands`]: ./enum.AppSettings.html#variant.ArgsNegateSubcommands\n/// [`AppSettings::SubcommandsNegateReqs`]: ./enum.AppSettings.html#variant.SubcommandsNegateReqs\n/// [`.required(true)`]: ./struct.Arg.html#method.required\n/// [`UnknownArgument`]: ./enum.ErrorKind.html#variant.UnknownArgument\npub fn last(self, l: bool) -> Self{\n        if l {\n            self.set(ArgSettings::Last)\n        } else {\n            self.unset(ArgSettings::Last)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::long":["/// Sets the long version of the argument without the preceding `--`.\n///\n/// By default `clap` automatically assigns `version` and `help` to the auto-generated\n/// `version` and `help` arguments respectively. You may use the word `version` or `help` for\n/// the long form of your own arguments, in which case `clap` simply will not assign those to\n/// the auto-generated `version` or `help` arguments.\n///\n/// **NOTE:** Any leading `-` characters will be stripped\n///\n/// # Examples\n///\n/// To set `long` use a word containing valid UTF-8 codepoints. If you supply a double leading\n/// `--` such as `--config` they will be stripped. Hyphens in the middle of the word, however,\n/// will *not* be stripped (i.e. `config-file` is allowed)\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"cfg\")\n///     .long(\"config\")\n/// # ;\n/// ```\n///\n/// Setting `long` allows using the argument via a double hyphen (`--`) such as `--config`\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .long(\"config\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--config\"\n///     ]);\n///\n/// assert!(m.is_present(\"cfg\"));\n/// ```\npub fn long(mut self, l: &'b str) -> Self{\n        self.s.long = Some(l.trim_left_matches(|c| c == '-'));\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::long_help":["/// Sets the long help text of the argument that will be displayed to the user when they print\n/// the help information with `--help`. Typically this a more detailed (multi-line) message\n/// that describes the arg.\n///\n/// **NOTE:** If only `long_help` is provided, and not [`Arg::help`] but the user requests `-h`\n/// clap will still display the contents of `long_help` appropriately\n///\n/// **NOTE:** Only [`Arg::help`] is used in completion script generation in order to be concise\n///\n/// # Examples\n///\n/// Any valid UTF-8 is allowed in the help text. The one exception is when one wishes to\n/// include a newline in the help text and have the following text be properly aligned with all\n/// the other help text.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"config\")\n///     .long_help(\n/// \"The config file used by the myprog must be in JSON format\n/// with only valid keys and may not contain other nonsense\n/// that cannot be read by this program. Obviously I'm going on\n/// and on, so I'll stop now.\")\n/// # ;\n/// ```\n///\n/// Setting `help` displays a short message to the side of the argument when the user passes\n/// `-h` or `--help` (by default).\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .long(\"config\")\n///         .long_help(\n/// \"The config file used by the myprog must be in JSON format\n/// with only valid keys and may not contain other nonsense\n/// that cannot be read by this program. Obviously I'm going on\n/// and on, so I'll stop now.\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--help\"\n///     ]);\n/// ```\n///\n/// The above example displays\n///\n/// ```notrust\n/// helptest\n///\n/// USAGE:\n///    helptest [FLAGS]\n///\n/// FLAGS:\n///    --config\n///         The config file used by the myprog must be in JSON format\n///         with only valid keys and may not contain other nonsense\n///         that cannot be read by this program. Obviously I'm going on\n///         and on, so I'll stop now.\n///\n/// -h, --help\n///         Prints help information\n///\n/// -V, --version\n///         Prints version information\n/// ```\n/// [`Arg::help`]: ./struct.Arg.html#method.help\npub fn long_help(mut self, h: &'b str) -> Self{\n        self.b.long_help = Some(h);\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::max_values":["/// Specifies the *maximum* number of values are for this argument. For example, if you had a\n/// `-f <file>` argument where you wanted up to 3 'files' you would set `.max_values(3)`, and\n/// this argument would be satisfied if the user provided, 1, 2, or 3 values.\n///\n/// **NOTE:** This does *not* implicitly set [`Arg::multiple(true)`]. This is because\n/// `-o val -o val` is multiple occurrences but a single value and `-o val1 val2` is a single\n/// occurrence with multiple values. For positional arguments this **does** set\n/// [`Arg::multiple(true)`] because there is no way to determine the difference between multiple\n/// occurrences and multiple values.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"file\")\n///     .short(\"f\")\n///     .max_values(3)\n/// # ;\n/// ```\n///\n/// Supplying less than the maximum number of values is allowed\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .takes_value(true)\n///         .max_values(3)\n///         .short(\"F\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"-F\", \"file1\", \"file2\"\n///     ]);\n///\n/// assert!(res.is_ok());\n/// let m = res.unwrap();\n/// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n/// assert_eq!(files, [\"file1\", \"file2\"]);\n/// ```\n///\n/// Supplying more than the maximum number of values is an error\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .takes_value(true)\n///         .max_values(2)\n///         .short(\"F\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"-F\", \"file1\", \"file2\", \"file3\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::TooManyValues);\n/// ```\n/// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\npub fn max_values(mut self, qty: u64) -> Self{\n        self.setb(ArgSettings::TakesValue);\n        self.v.max_vals = Some(qty);\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::min_values":["/// Specifies the *minimum* number of values for this argument. For example, if you had a\n/// `-f <file>` argument where you wanted at least 2 'files' you would set\n/// `.min_values(2)`, and this argument would be satisfied if the user provided, 2 or more\n/// values.\n///\n/// **NOTE:** This does not implicitly set [`Arg::multiple(true)`]. This is because\n/// `-o val -o val` is multiple occurrences but a single value and `-o val1 val2` is a single\n/// occurrence with multiple values. For positional arguments this **does** set\n/// [`Arg::multiple(true)`] because there is no way to determine the difference between multiple\n/// occurrences and multiple values.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"file\")\n///     .short(\"f\")\n///     .min_values(3)\n/// # ;\n/// ```\n///\n/// Supplying more than the minimum number of values is allowed\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .takes_value(true)\n///         .min_values(2)\n///         .short(\"F\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"-F\", \"file1\", \"file2\", \"file3\"\n///     ]);\n///\n/// assert!(res.is_ok());\n/// let m = res.unwrap();\n/// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n/// assert_eq!(files, [\"file1\", \"file2\", \"file3\"]);\n/// ```\n///\n/// Supplying less than the minimum number of values is an error\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .takes_value(true)\n///         .min_values(2)\n///         .short(\"F\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"-F\", \"file1\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::TooFewValues);\n/// ```\n/// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\npub fn min_values(mut self, qty: u64) -> Self{\n        self.v.min_vals = Some(qty);\n        self.set(ArgSettings::TakesValue)\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::multiple":["/// Specifies that the argument may appear more than once. For flags, this results\n/// in the number of occurrences of the flag being recorded. For example `-ddd` or `-d -d -d`\n/// would count as three occurrences. For options there is a distinct difference in multiple\n/// occurrences vs multiple values.\n///\n/// For example, `--opt val1 val2` is one occurrence, but two values. Whereas\n/// `--opt val1 --opt val2` is two occurrences.\n///\n/// **WARNING:**\n///\n/// Setting `multiple(true)` for an [option] with no other details, allows multiple values\n/// **and** multiple occurrences because it isn't possible to have more occurrences than values\n/// for options. Because multiple values are allowed, `--option val1 val2 val3` is perfectly\n/// valid, be careful when designing a CLI where positional arguments are expected after a\n/// option which accepts multiple values, as `clap` will continue parsing *values* until it\n/// reaches the max or specific number of values defined, or another flag or option.\n///\n/// **Pro Tip**:\n///\n/// It's possible to define an option which allows multiple occurrences, but only one value per\n/// occurrence. To do this use [`Arg::number_of_values(1)`] in coordination with\n/// [`Arg::multiple(true)`].\n///\n/// **WARNING:**\n///\n/// When using args with `multiple(true)` on [options] or [positionals] (i.e. those args that\n/// accept values) and [subcommands], one needs to consider the possibility of an argument value\n/// being the same as a valid subcommand. By default `clap` will parse the argument in question\n/// as a value *only if* a value is possible at that moment. Otherwise it will be parsed as a\n/// subcommand. In effect, this means using `multiple(true)` with no additional parameters and\n/// a possible value that coincides with a subcommand name, the subcommand cannot be called\n/// unless another argument is passed first.\n///\n/// As an example, consider a CLI with an option `--ui-paths=<paths>...` and subcommand `signer`\n///\n/// The following would be parsed as values to `--ui-paths`.\n///\n/// ```notrust\n/// $ program --ui-paths path1 path2 signer\n/// ```\n///\n/// This is because `--ui-paths` accepts multiple values. `clap` will continue parsing values\n/// until another argument is reached and it knows `--ui-paths` is done.\n///\n/// By adding additional parameters to `--ui-paths` we can solve this issue. Consider adding\n/// [`Arg::number_of_values(1)`] as discussed above. The following are all valid, and `signer`\n/// is parsed as both a subcommand and a value in the second case.\n///\n/// ```notrust\n/// $ program --ui-paths path1 signer\n/// $ program --ui-paths path1 --ui-paths signer signer\n/// ```\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"debug\")\n///     .short(\"d\")\n///     .multiple(true)\n/// # ;\n/// ```\n/// An example with flags\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"verbose\")\n///         .multiple(true)\n///         .short(\"v\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"-v\", \"-v\", \"-v\"    // note, -vvv would have same result\n///     ]);\n///\n/// assert!(m.is_present(\"verbose\"));\n/// assert_eq!(m.occurrences_of(\"verbose\"), 3);\n/// ```\n///\n/// An example with options\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .multiple(true)\n///         .takes_value(true)\n///         .short(\"F\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"-F\", \"file1\", \"file2\", \"file3\"\n///     ]);\n///\n/// assert!(m.is_present(\"file\"));\n/// assert_eq!(m.occurrences_of(\"file\"), 1); // notice only one occurrence\n/// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n/// assert_eq!(files, [\"file1\", \"file2\", \"file3\"]);\n/// ```\n/// This is functionally equivalent to the example above\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .multiple(true)\n///         .takes_value(true)\n///         .short(\"F\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"-F\", \"file1\", \"-F\", \"file2\", \"-F\", \"file3\"\n///     ]);\n/// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n/// assert_eq!(files, [\"file1\", \"file2\", \"file3\"]);\n///\n/// assert!(m.is_present(\"file\"));\n/// assert_eq!(m.occurrences_of(\"file\"), 3); // Notice 3 occurrences\n/// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n/// assert_eq!(files, [\"file1\", \"file2\", \"file3\"]);\n/// ```\n///\n/// A common mistake is to define an option which allows multiples, and a positional argument\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .multiple(true)\n///         .takes_value(true)\n///         .short(\"F\"))\n///     .arg(Arg::with_name(\"word\")\n///         .index(1))\n///     .get_matches_from(vec![\n///         \"prog\", \"-F\", \"file1\", \"file2\", \"file3\", \"word\"\n///     ]);\n///\n/// assert!(m.is_present(\"file\"));\n/// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n/// assert_eq!(files, [\"file1\", \"file2\", \"file3\", \"word\"]); // wait...what?!\n/// assert!(!m.is_present(\"word\")); // but we clearly used word!\n/// ```\n/// The problem is clap doesn't know when to stop parsing values for \"files\". This is further\n/// compounded by if we'd said `word -F file1 file2` it would have worked fine, so it would\n/// appear to only fail sometimes...not good!\n///\n/// A solution for the example above is to specify that `-F` only accepts one value, but is\n/// allowed to appear multiple times\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .multiple(true)\n///         .takes_value(true)\n///         .number_of_values(1)\n///         .short(\"F\"))\n///     .arg(Arg::with_name(\"word\")\n///         .index(1))\n///     .get_matches_from(vec![\n///         \"prog\", \"-F\", \"file1\", \"-F\", \"file2\", \"-F\", \"file3\", \"word\"\n///     ]);\n///\n/// assert!(m.is_present(\"file\"));\n/// let files: Vec<_> = m.values_of(\"file\").unwrap().collect();\n/// assert_eq!(files, [\"file1\", \"file2\", \"file3\"]);\n/// assert!(m.is_present(\"word\"));\n/// assert_eq!(m.value_of(\"word\"), Some(\"word\"));\n/// ```\n/// As a final example, notice if we define [`Arg::number_of_values(1)`] and try to run the\n/// problem example above, it would have been a runtime error with a pretty message to the\n/// user :)\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .multiple(true)\n///         .takes_value(true)\n///         .number_of_values(1)\n///         .short(\"F\"))\n///     .arg(Arg::with_name(\"word\")\n///         .index(1))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"-F\", \"file1\", \"file2\", \"file3\", \"word\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::UnknownArgument);\n/// ```\n/// [option]: ./struct.Arg.html#method.takes_value\n/// [options]: ./struct.Arg.html#method.takes_value\n/// [subcommands]: ./struct.SubCommand.html\n/// [positionals]: ./struct.Arg.html#method.index\n/// [`Arg::number_of_values(1)`]: ./struct.Arg.html#method.number_of_values\n/// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\npub fn multiple(self, multi: bool) -> Self{\n        if multi {\n            self.set(ArgSettings::Multiple)\n        } else {\n            self.unset(ArgSettings::Multiple)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::next_line_help":["/// When set to `true` the help string will be displayed on the line after the argument and\n/// indented once. This can be helpful for arguments with very long or complex help messages.\n/// This can also be helpful for arguments with very long flag names, or many/long value names.\n///\n/// **NOTE:** To apply this setting to all arguments consider using\n/// [`AppSettings::NextLineHelp`]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"opt\")\n///         .long(\"long-option-flag\")\n///         .short(\"o\")\n///         .takes_value(true)\n///         .value_names(&[\"value1\", \"value2\"])\n///         .help(\"Some really long help and complex\\n\\\n///                help that makes more sense to be\\n\\\n///                on a line after the option\")\n///         .next_line_help(true))\n///     .get_matches_from(vec![\n///         \"prog\", \"--help\"\n///     ]);\n/// ```\n///\n/// The above example displays the following help message\n///\n/// ```notrust\n/// nlh\n///\n/// USAGE:\n///     nlh [FLAGS] [OPTIONS]\n///\n/// FLAGS:\n///     -h, --help       Prints help information\n///     -V, --version    Prints version information\n///\n/// OPTIONS:\n///     -o, --long-option-flag <value1> <value2>\n///         Some really long help and complex\n///         help that makes more sense to be\n///         on a line after the option\n/// ```\n/// [`AppSettings::NextLineHelp`]: ./enum.AppSettings.html#variant.NextLineHelp\npub fn next_line_help(mut self, nlh: bool) -> Self{\n        if nlh {\n            self.setb(ArgSettings::NextLineHelp);\n        } else {\n            self.unsetb(ArgSettings::NextLineHelp);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::number_of_values":["/// Specifies how many values are required to satisfy this argument. For example, if you had a\n/// `-f <file>` argument where you wanted exactly 3 'files' you would set\n/// `.number_of_values(3)`, and this argument wouldn't be satisfied unless the user provided\n/// 3 and only 3 values.\n///\n/// **NOTE:** Does *not* require [`Arg::multiple(true)`] to be set. Setting\n/// [`Arg::multiple(true)`] would allow `-f <file> <file> <file> -f <file> <file> <file>` where\n/// as *not* setting [`Arg::multiple(true)`] would only allow one occurrence of this argument.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"file\")\n///     .short(\"f\")\n///     .number_of_values(3)\n/// # ;\n/// ```\n///\n/// Not supplying the correct number of values is an error\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .takes_value(true)\n///         .number_of_values(2)\n///         .short(\"F\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"-F\", \"file1\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::WrongNumberOfValues);\n/// ```\n/// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\npub fn number_of_values(mut self, qty: u64) -> Self{\n        self.setb(ArgSettings::TakesValue);\n        self.v.num_vals = Some(qty);\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::overrides_with":["/// Sets a overridable argument by name. I.e. this argument and the following argument\n/// will override each other in POSIX style (whichever argument was specified at runtime\n/// **last** \"wins\")\n///\n/// **NOTE:** When an argument is overridden it is essentially as if it never was used, any\n/// conflicts, requirements, etc. are evaluated **after** all \"overrides\" have been removed\n///\n/// **WARNING:** Positional arguments cannot override themselves (or we would never be able\n/// to advance to the next positional). If a positional agument lists itself as an override,\n/// it is simply ignored.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::from_usage(\"-f, --flag 'some flag'\")\n///         .conflicts_with(\"debug\"))\n///     .arg(Arg::from_usage(\"-d, --debug 'other flag'\"))\n///     .arg(Arg::from_usage(\"-c, --color 'third flag'\")\n///         .overrides_with(\"flag\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"-f\", \"-d\", \"-c\"]);\n///             //    ^~~~~~~~~~~~^~~~~ flag is overridden by color\n///\n/// assert!(m.is_present(\"color\"));\n/// assert!(m.is_present(\"debug\")); // even though flag conflicts with debug, it's as if flag\n///                                 // was never used because it was overridden with color\n/// assert!(!m.is_present(\"flag\"));\n/// ```\n/// Care must be taken when using this setting, and having an arg override with itself. This\n/// is common practice when supporting things like shell aliases, config files, etc.\n/// However, when combined with multiple values, it can get dicy.\n/// Here is how clap handles such situations:\n///\n/// When a flag overrides itself, it's as if the flag was only ever used once (essentially\n/// preventing a \"Unexpected multiple usage\" error):\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"posix\")\n///             .arg(Arg::from_usage(\"--flag  'some flag'\").overrides_with(\"flag\"))\n///             .get_matches_from(vec![\"posix\", \"--flag\", \"--flag\"]);\n/// assert!(m.is_present(\"flag\"));\n/// assert_eq!(m.occurrences_of(\"flag\"), 1);\n/// ```\n/// Making a arg `multiple(true)` and override itself is essentially meaningless. Therefore\n/// clap ignores an override of self if it's a flag and it already accepts multiple occurrences.\n///\n/// ```\n/// # use clap::{App, Arg};\n/// let m = App::new(\"posix\")\n///             .arg(Arg::from_usage(\"--flag...  'some flag'\").overrides_with(\"flag\"))\n///             .get_matches_from(vec![\"\", \"--flag\", \"--flag\", \"--flag\", \"--flag\"]);\n/// assert!(m.is_present(\"flag\"));\n/// assert_eq!(m.occurrences_of(\"flag\"), 4);\n/// ```\n/// Now notice with options (which *do not* set `multiple(true)`), it's as if only the last\n/// occurrence happened.\n///\n/// ```\n/// # use clap::{App, Arg};\n/// let m = App::new(\"posix\")\n///             .arg(Arg::from_usage(\"--opt [val] 'some option'\").overrides_with(\"opt\"))\n///             .get_matches_from(vec![\"\", \"--opt=some\", \"--opt=other\"]);\n/// assert!(m.is_present(\"opt\"));\n/// assert_eq!(m.occurrences_of(\"opt\"), 1);\n/// assert_eq!(m.value_of(\"opt\"), Some(\"other\"));\n/// ```\n///\n/// Just like flags, options with `multiple(true)` set, will ignore the \"override self\" setting.\n///\n/// ```\n/// # use clap::{App, Arg};\n/// let m = App::new(\"posix\")\n///             .arg(Arg::from_usage(\"--opt [val]... 'some option'\")\n///                 .overrides_with(\"opt\"))\n///             .get_matches_from(vec![\"\", \"--opt\", \"first\", \"over\", \"--opt\", \"other\", \"val\"]);\n/// assert!(m.is_present(\"opt\"));\n/// assert_eq!(m.occurrences_of(\"opt\"), 2);\n/// assert_eq!(m.values_of(\"opt\").unwrap().collect::<Vec<_>>(), &[\"first\", \"over\", \"other\", \"val\"]);\n/// ```\n///\n/// A safe thing to do if you'd like to support an option which supports multiple values, but\n/// also is \"overridable\" by itself, is to use `use_delimiter(false)` and *not* use\n/// `multiple(true)` while telling users to seperate values with a comma (i.e. `val1,val2`)\n///\n/// ```\n/// # use clap::{App, Arg};\n/// let m = App::new(\"posix\")\n///             .arg(Arg::from_usage(\"--opt [val] 'some option'\")\n///                 .overrides_with(\"opt\")\n///                 .use_delimiter(false))\n///             .get_matches_from(vec![\"\", \"--opt=some,other\", \"--opt=one,two\"]);\n/// assert!(m.is_present(\"opt\"));\n/// assert_eq!(m.occurrences_of(\"opt\"), 1);\n/// assert_eq!(m.values_of(\"opt\").unwrap().collect::<Vec<_>>(), &[\"one,two\"]);\n/// ```\npub fn overrides_with(mut self, name: &'a str) -> Self{\n        if let Some(ref mut vec) = self.b.overrides {\n            vec.push(name);\n        } else {\n            self.b.overrides = Some(vec![name]);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::overrides_with_all":["/// Sets multiple mutually overridable arguments by name. I.e. this argument and the following\n/// argument will override each other in POSIX style (whichever argument was specified at\n/// runtime **last** \"wins\")\n///\n/// **NOTE:** When an argument is overridden it is essentially as if it never was used, any\n/// conflicts, requirements, etc. are evaluated **after** all \"overrides\" have been removed\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::from_usage(\"-f, --flag 'some flag'\")\n///         .conflicts_with(\"color\"))\n///     .arg(Arg::from_usage(\"-d, --debug 'other flag'\"))\n///     .arg(Arg::from_usage(\"-c, --color 'third flag'\")\n///         .overrides_with_all(&[\"flag\", \"debug\"]))\n///     .get_matches_from(vec![\n///         \"prog\", \"-f\", \"-d\", \"-c\"]);\n///             //    ^~~~~~^~~~~~~~~ flag and debug are overridden by color\n///\n/// assert!(m.is_present(\"color\")); // even though flag conflicts with color, it's as if flag\n///                                 // and debug were never used because they were overridden\n///                                 // with color\n/// assert!(!m.is_present(\"debug\"));\n/// assert!(!m.is_present(\"flag\"));\n/// ```\npub fn overrides_with_all(mut self, names: &[&'a str]) -> Self{\n        if let Some(ref mut vec) = self.b.overrides {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.b.overrides = Some(names.iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::possible_value":["/// Specifies a possible value for this argument, one at a time. At runtime, `clap` verifies\n/// that only one of the specified values was used, or fails with error message.\n///\n/// **NOTE:** This setting only applies to [options] and [positional arguments]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"mode\")\n///     .takes_value(true)\n///     .possible_value(\"fast\")\n///     .possible_value(\"slow\")\n///     .possible_value(\"medium\")\n/// # ;\n/// ```\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"mode\")\n///         .long(\"mode\")\n///         .takes_value(true)\n///         .possible_value(\"fast\")\n///         .possible_value(\"slow\")\n///         .possible_value(\"medium\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--mode\", \"fast\"\n///     ]);\n/// assert!(m.is_present(\"mode\"));\n/// assert_eq!(m.value_of(\"mode\"), Some(\"fast\"));\n/// ```\n///\n/// The next example shows a failed parse from using a value which wasn't defined as one of the\n/// possible values.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"mode\")\n///         .long(\"mode\")\n///         .takes_value(true)\n///         .possible_value(\"fast\")\n///         .possible_value(\"slow\")\n///         .possible_value(\"medium\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--mode\", \"wrong\"\n///     ]);\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::InvalidValue);\n/// ```\n/// [options]: ./struct.Arg.html#method.takes_value\n/// [positional arguments]: ./struct.Arg.html#method.index\npub fn possible_value(mut self, name: &'b str) -> Self{\n        if let Some(ref mut vec) = self.v.possible_vals {\n            vec.push(name);\n        } else {\n            self.v.possible_vals = Some(vec![name]);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::possible_values":["/// Specifies a list of possible values for this argument. At runtime, `clap` verifies that\n/// only one of the specified values was used, or fails with an error message.\n///\n/// **NOTE:** This setting only applies to [options] and [positional arguments]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"mode\")\n///     .takes_value(true)\n///     .possible_values(&[\"fast\", \"slow\", \"medium\"])\n/// # ;\n/// ```\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"mode\")\n///         .long(\"mode\")\n///         .takes_value(true)\n///         .possible_values(&[\"fast\", \"slow\", \"medium\"]))\n///     .get_matches_from(vec![\n///         \"prog\", \"--mode\", \"fast\"\n///     ]);\n/// assert!(m.is_present(\"mode\"));\n/// assert_eq!(m.value_of(\"mode\"), Some(\"fast\"));\n/// ```\n///\n/// The next example shows a failed parse from using a value which wasn't defined as one of the\n/// possible values.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"mode\")\n///         .long(\"mode\")\n///         .takes_value(true)\n///         .possible_values(&[\"fast\", \"slow\", \"medium\"]))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--mode\", \"wrong\"\n///     ]);\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::InvalidValue);\n/// ```\n/// [options]: ./struct.Arg.html#method.takes_value\n/// [positional arguments]: ./struct.Arg.html#method.index\npub fn possible_values(mut self, names: &[&'b str]) -> Self{\n        if let Some(ref mut vec) = self.v.possible_vals {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.v.possible_vals = Some(names.iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::raw":["/// Indicates that all parameters passed after this should not be parsed\n/// individually, but rather passed in their entirety. It is worth noting\n/// that setting this requires all values to come after a `--` to indicate they\n/// should all be captured. For example:\n///\n/// ```notrust\n/// --foo something -- -v -v -v -b -b -b --baz -q -u -x\n/// ```\n/// Will result in everything after `--` to be considered one raw argument. This behavior\n/// may not be exactly what you are expecting and using [`AppSettings::TrailingVarArg`]\n/// may be more appropriate.\n///\n/// **NOTE:** Implicitly sets [`Arg::multiple(true)`], [`Arg::allow_hyphen_values(true)`], and\n/// [`Arg::last(true)`] when set to `true`\n///\n/// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\n/// [`Arg::allow_hyphen_values(true)`]: ./struct.Arg.html#method.allow_hyphen_values\n/// [`Arg::last(true)`]: ./struct.Arg.html#method.last\n/// [`AppSettings::TrailingVarArg`]: ./enum.AppSettings.html#variant.TrailingVarArg\npub fn raw(self, raw: bool) -> Self{\n        self.multiple(raw).allow_hyphen_values(raw).last(raw)\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::require_delimiter":["/// Specifies that *multiple values* may only be set using the delimiter. This means if an\n/// if an option is encountered, and no delimiter is found, it automatically assumed that no\n/// additional values for that option follow. This is unlike the default, where it is generally\n/// assumed that more values will follow regardless of whether or not a delimiter is used.\n///\n/// **NOTE:** The default is `false`.\n///\n/// **NOTE:** Setting this to true implies [`Arg::use_delimiter(true)`]\n///\n/// **NOTE:** It's a good idea to inform the user that use of a delimiter is required, either\n/// through help text or other means.\n///\n/// # Examples\n///\n/// These examples demonstrate what happens when `require_delimiter(true)` is used. Notice\n/// everything works in this first example, as we use a delimiter, as expected.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let delims = App::new(\"prog\")\n///     .arg(Arg::with_name(\"opt\")\n///         .short(\"o\")\n///         .takes_value(true)\n///         .multiple(true)\n///         .require_delimiter(true))\n///     .get_matches_from(vec![\n///         \"prog\", \"-o\", \"val1,val2,val3\",\n///     ]);\n///\n/// assert!(delims.is_present(\"opt\"));\n/// assert_eq!(delims.values_of(\"opt\").unwrap().collect::<Vec<_>>(), [\"val1\", \"val2\", \"val3\"]);\n/// ```\n/// In this next example, we will *not* use a delimiter. Notice it's now an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"opt\")\n///         .short(\"o\")\n///         .takes_value(true)\n///         .multiple(true)\n///         .require_delimiter(true))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"-o\", \"val1\", \"val2\", \"val3\",\n///     ]);\n///\n/// assert!(res.is_err());\n/// let err = res.unwrap_err();\n/// assert_eq!(err.kind, ErrorKind::UnknownArgument);\n/// ```\n/// What's happening is `-o` is getting `val1`, and because delimiters are required yet none\n/// were present, it stops parsing `-o`. At this point it reaches `val2` and because no\n/// positional arguments have been defined, it's an error of an unexpected argument.\n///\n/// In this final example, we contrast the above with `clap`'s default behavior where the above\n/// is *not* an error.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let delims = App::new(\"prog\")\n///     .arg(Arg::with_name(\"opt\")\n///         .short(\"o\")\n///         .takes_value(true)\n///         .multiple(true))\n///     .get_matches_from(vec![\n///         \"prog\", \"-o\", \"val1\", \"val2\", \"val3\",\n///     ]);\n///\n/// assert!(delims.is_present(\"opt\"));\n/// assert_eq!(delims.values_of(\"opt\").unwrap().collect::<Vec<_>>(), [\"val1\", \"val2\", \"val3\"]);\n/// ```\n/// [`Arg::use_delimiter(true)`]: ./struct.Arg.html#method.use_delimiter\npub fn require_delimiter(mut self, d: bool) -> Self{\n        if d {\n            self = self.use_delimiter(true);\n            self.unsetb(ArgSettings::ValueDelimiterNotSet);\n            self.setb(ArgSettings::UseValueDelimiter);\n            self.set(ArgSettings::RequireDelimiter)\n        } else {\n            self = self.use_delimiter(false);\n            self.unsetb(ArgSettings::UseValueDelimiter);\n            self.unset(ArgSettings::RequireDelimiter)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::require_equals":["/// Requires that options use the `--option=val` syntax (i.e. an equals between the option and\n/// associated value) **Default:** `false`\n///\n/// **NOTE:** This setting also removes the default of allowing empty values and implies\n/// [`Arg::empty_values(false)`].\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .long(\"config\")\n///     .takes_value(true)\n///     .require_equals(true)\n/// # ;\n/// ```\n///\n/// Setting [`Arg::require_equals(true)`] requires that the option have an equals sign between\n/// it and the associated value.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .require_equals(true)\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--config=file.conf\"\n///     ]);\n///\n/// assert!(res.is_ok());\n/// ```\n///\n/// Setting [`Arg::require_equals(true)`] and *not* supplying the equals will cause an error\n/// unless [`Arg::empty_values(true)`] is set.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .require_equals(true)\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--config\", \"file.conf\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::EmptyValue);\n/// ```\n/// [`Arg::require_equals(true)`]: ./struct.Arg.html#method.require_equals\n/// [`Arg::empty_values(true)`]: ./struct.Arg.html#method.empty_values\n/// [`Arg::empty_values(false)`]: ./struct.Arg.html#method.empty_values\npub fn require_equals(mut self, r: bool) -> Self{\n        if r {\n            self.unsetb(ArgSettings::EmptyValues);\n            self.set(ArgSettings::RequireEquals)\n        } else {\n            self.unset(ArgSettings::RequireEquals)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::required":["/// Sets whether or not the argument is required by default. Required by default means it is\n/// required, when no other conflicting rules have been evaluated. Conflicting rules take\n/// precedence over being required. **Default:** `false`\n///\n/// **NOTE:** Flags (i.e. not positional, or arguments that take values) cannot be required by\n/// default. This is simply because if a flag should be required, it should simply be implied\n/// as no additional information is required from user. Flags by their very nature are simply\n/// yes/no, or true/false.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .required(true)\n/// # ;\n/// ```\n///\n/// Setting [`Arg::required(true)`] requires that the argument be used at runtime.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .required(true)\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--config\", \"file.conf\"\n///     ]);\n///\n/// assert!(res.is_ok());\n/// ```\n///\n/// Setting [`Arg::required(true)`] and *not* supplying that argument is an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .required(true)\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [`Arg::required(true)`]: ./struct.Arg.html#method.required\npub fn required(self, r: bool) -> Self{\n        if r {\n            self.set(ArgSettings::Required)\n        } else {\n            self.unset(ArgSettings::Required)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::required_if":["/// Allows specifying that an argument is [required] conditionally. The requirement will only\n/// become valid if the specified `arg`'s value equals `val`.\n///\n/// **NOTE:** If using YAML the values should be laid out as follows\n///\n/// ```yaml\n/// required_if:\n///     - [arg, val]\n/// ```\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .required_if(\"other_arg\", \"value\")\n/// # ;\n/// ```\n///\n/// Setting [`Arg::required_if(arg, val)`] makes this arg required if the `arg` is used at\n/// runtime and it's value is equal to `val`. If the `arg`'s value is anything other than `val`,\n/// this argument isn't required.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .takes_value(true)\n///         .required_if(\"other\", \"special\")\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"other\")\n///         .long(\"other\")\n///         .takes_value(true))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--other\", \"not-special\"\n///     ]);\n///\n/// assert!(res.is_ok()); // We didn't use --other=special, so \"cfg\" wasn't required\n/// ```\n///\n/// Setting [`Arg::required_if(arg, val)`] and having `arg` used with a value of `val` but *not*\n/// using this arg is an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .takes_value(true)\n///         .required_if(\"other\", \"special\")\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"other\")\n///         .long(\"other\")\n///         .takes_value(true))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--other\", \"special\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [`Arg::requires(name)`]: ./struct.Arg.html#method.requires\n/// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n/// [required]: ./struct.Arg.html#method.required\npub fn required_if(mut self, arg: &'a str, val: &'b str) -> Self{\n        if let Some(ref mut vec) = self.r_ifs {\n            vec.push((arg, val));\n        } else {\n            self.r_ifs = Some(vec![(arg, val)]);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::required_ifs":["/// Allows specifying that an argument is [required] based on multiple conditions. The\n/// conditions are set up in a `(arg, val)` style tuple. The requirement will only become valid\n/// if one of the specified `arg`'s value equals it's corresponding `val`.\n///\n/// **NOTE:** If using YAML the values should be laid out as follows\n///\n/// ```yaml\n/// required_if:\n///     - [arg, val]\n///     - [arg2, val2]\n/// ```\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .required_ifs(&[\n///         (\"extra\", \"val\"),\n///         (\"option\", \"spec\")\n///     ])\n/// # ;\n/// ```\n///\n/// Setting [`Arg::required_ifs(&[(arg, val)])`] makes this arg required if any of the `arg`s\n/// are used at runtime and it's corresponding value is equal to `val`. If the `arg`'s value is\n/// anything other than `val`, this argument isn't required.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .required_ifs(&[\n///             (\"extra\", \"val\"),\n///             (\"option\", \"spec\")\n///         ])\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"extra\")\n///         .takes_value(true)\n///         .long(\"extra\"))\n///     .arg(Arg::with_name(\"option\")\n///         .takes_value(true)\n///         .long(\"option\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--option\", \"other\"\n///     ]);\n///\n/// assert!(res.is_ok()); // We didn't use --option=spec, or --extra=val so \"cfg\" isn't required\n/// ```\n///\n/// Setting [`Arg::required_ifs(&[(arg, val)])`] and having any of the `arg`s used with it's\n/// value of `val` but *not* using this arg is an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .required_ifs(&[\n///             (\"extra\", \"val\"),\n///             (\"option\", \"spec\")\n///         ])\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"extra\")\n///         .takes_value(true)\n///         .long(\"extra\"))\n///     .arg(Arg::with_name(\"option\")\n///         .takes_value(true)\n///         .long(\"option\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--option\", \"spec\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [`Arg::requires(name)`]: ./struct.Arg.html#method.requires\n/// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n/// [required]: ./struct.Arg.html#method.required\npub fn required_ifs(mut self, ifs: &[(&'a str, &'b str)]) -> Self{\n        if let Some(ref mut vec) = self.r_ifs {\n            for r_if in ifs {\n                vec.push((r_if.0, r_if.1));\n            }\n        } else {\n            let mut vec = vec![];\n            for r_if in ifs {\n                vec.push((r_if.0, r_if.1));\n            }\n            self.r_ifs = Some(vec);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::required_unless":["/// Sets an arg that override this arg's required setting. (i.e. this arg will be required\n/// unless this other argument is present).\n///\n/// **Pro Tip:** Using [`Arg::required_unless`] implies [`Arg::required`] and is therefore not\n/// mandatory to also set.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .required_unless(\"debug\")\n/// # ;\n/// ```\n///\n/// Setting [`Arg::required_unless(name)`] requires that the argument be used at runtime\n/// *unless* `name` is present. In the following example, the required argument is *not*\n/// provided, but it's not an error because the `unless` arg has been supplied.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .required_unless(\"dbg\")\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"dbg\")\n///         .long(\"debug\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--debug\"\n///     ]);\n///\n/// assert!(res.is_ok());\n/// ```\n///\n/// Setting [`Arg::required_unless(name)`] and *not* supplying `name` or this arg is an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .required_unless(\"dbg\")\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"dbg\")\n///         .long(\"debug\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [`Arg::required_unless`]: ./struct.Arg.html#method.required_unless\n/// [`Arg::required`]: ./struct.Arg.html#method.required\n/// [`Arg::required_unless(name)`]: ./struct.Arg.html#method.required_unless\npub fn required_unless(mut self, name: &'a str) -> Self{\n        if let Some(ref mut vec) = self.b.r_unless {\n            vec.push(name);\n        } else {\n            self.b.r_unless = Some(vec![name]);\n        }\n        self.required(true)\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::required_unless_all":["/// Sets args that override this arg's required setting. (i.e. this arg will be required unless\n/// all these other arguments are present).\n///\n/// **NOTE:** If you wish for this argument to only be required if *one of* these args are\n/// present see [`Arg::required_unless_one`]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .required_unless_all(&[\"cfg\", \"dbg\"])\n/// # ;\n/// ```\n///\n/// Setting [`Arg::required_unless_all(names)`] requires that the argument be used at runtime\n/// *unless* *all* the args in `names` are present. In the following example, the required\n/// argument is *not* provided, but it's not an error because all the `unless` args have been\n/// supplied.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .required_unless_all(&[\"dbg\", \"infile\"])\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"dbg\")\n///         .long(\"debug\"))\n///     .arg(Arg::with_name(\"infile\")\n///         .short(\"i\")\n///         .takes_value(true))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--debug\", \"-i\", \"file\"\n///     ]);\n///\n/// assert!(res.is_ok());\n/// ```\n///\n/// Setting [`Arg::required_unless_all(names)`] and *not* supplying *all* of `names` or this\n/// arg is an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .required_unless_all(&[\"dbg\", \"infile\"])\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"dbg\")\n///         .long(\"debug\"))\n///     .arg(Arg::with_name(\"infile\")\n///         .short(\"i\")\n///         .takes_value(true))\n///     .get_matches_from_safe(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [`Arg::required_unless_one`]: ./struct.Arg.html#method.required_unless_one\n/// [`Arg::required_unless_all(names)`]: ./struct.Arg.html#method.required_unless_all\npub fn required_unless_all(mut self, names: &[&'a str]) -> Self{\n        if let Some(ref mut vec) = self.b.r_unless {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.b.r_unless = Some(names.iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self.setb(ArgSettings::RequiredUnlessAll);\n        self.required(true)\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::required_unless_one":["/// Sets args that override this arg's [required] setting. (i.e. this arg will be required\n/// unless *at least one of* these other arguments are present).\n///\n/// **NOTE:** If you wish for this argument to only be required if *all of* these args are\n/// present see [`Arg::required_unless_all`]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .required_unless_all(&[\"cfg\", \"dbg\"])\n/// # ;\n/// ```\n///\n/// Setting [`Arg::required_unless_one(names)`] requires that the argument be used at runtime\n/// *unless* *at least one of* the args in `names` are present. In the following example, the\n/// required argument is *not* provided, but it's not an error because one the `unless` args\n/// have been supplied.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .required_unless_one(&[\"dbg\", \"infile\"])\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"dbg\")\n///         .long(\"debug\"))\n///     .arg(Arg::with_name(\"infile\")\n///         .short(\"i\")\n///         .takes_value(true))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--debug\"\n///     ]);\n///\n/// assert!(res.is_ok());\n/// ```\n///\n/// Setting [`Arg::required_unless_one(names)`] and *not* supplying *at least one of* `names`\n/// or this arg is an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .required_unless_one(&[\"dbg\", \"infile\"])\n///         .takes_value(true)\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"dbg\")\n///         .long(\"debug\"))\n///     .arg(Arg::with_name(\"infile\")\n///         .short(\"i\")\n///         .takes_value(true))\n///     .get_matches_from_safe(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [required]: ./struct.Arg.html#method.required\n/// [`Arg::required_unless_one(names)`]: ./struct.Arg.html#method.required_unless_one\n/// [`Arg::required_unless_all`]: ./struct.Arg.html#method.required_unless_all\npub fn required_unless_one(mut self, names: &[&'a str]) -> Self{\n        if let Some(ref mut vec) = self.b.r_unless {\n            for s in names {\n                vec.push(s);\n            }\n        } else {\n            self.b.r_unless = Some(names.iter().map(|s| *s).collect::<Vec<_>>());\n        }\n        self.required(true)\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::requires":["/// Sets an argument by name that is required when this one is present I.e. when\n/// using this argument, the following argument *must* be present.\n///\n/// **NOTE:** [Conflicting] rules and [override] rules take precedence over being required\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .requires(\"input\")\n/// # ;\n/// ```\n///\n/// Setting [`Arg::requires(name)`] requires that the argument be used at runtime if the\n/// defining argument is used. If the defining argument isn't used, the other argument isn't\n/// required\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .takes_value(true)\n///         .requires(\"input\")\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"input\")\n///         .index(1))\n///     .get_matches_from_safe(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert!(res.is_ok()); // We didn't use cfg, so input wasn't required\n/// ```\n///\n/// Setting [`Arg::requires(name)`] and *not* supplying that argument is an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .takes_value(true)\n///         .requires(\"input\")\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"input\")\n///         .index(1))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--config\", \"file.conf\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [`Arg::requires(name)`]: ./struct.Arg.html#method.requires\n/// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n/// [override]: ./struct.Arg.html#method.overrides_with\npub fn requires(mut self, name: &'a str) -> Self{\n        if let Some(ref mut vec) = self.b.requires {\n            vec.push((None, name));\n        } else {\n            let mut vec = vec![];\n            vec.push((None, name));\n            self.b.requires = Some(vec);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::requires_all":["/// Sets multiple arguments by names that are required when this one is present I.e. when\n/// using this argument, the following arguments *must* be present.\n///\n/// **NOTE:** [Conflicting] rules and [override] rules take precedence over being required\n/// by default.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .requires_all(&[\"input\", \"output\"])\n/// # ;\n/// ```\n///\n/// Setting [`Arg::requires_all(&[arg, arg2])`] requires that all the arguments be used at\n/// runtime if the defining argument is used. If the defining argument isn't used, the other\n/// argument isn't required\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .takes_value(true)\n///         .requires(\"input\")\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"input\")\n///         .index(1))\n///     .arg(Arg::with_name(\"output\")\n///         .index(2))\n///     .get_matches_from_safe(vec![\n///         \"prog\"\n///     ]);\n///\n/// assert!(res.is_ok()); // We didn't use cfg, so input and output weren't required\n/// ```\n///\n/// Setting [`Arg::requires_all(&[arg, arg2])`] and *not* supplying all the arguments is an\n/// error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .takes_value(true)\n///         .requires_all(&[\"input\", \"output\"])\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"input\")\n///         .index(1))\n///     .arg(Arg::with_name(\"output\")\n///         .index(2))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--config\", \"file.conf\", \"in.txt\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// // We didn't use output\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n/// [override]: ./struct.Arg.html#method.overrides_with\n/// [`Arg::requires_all(&[arg, arg2])`]: ./struct.Arg.html#method.requires_all\npub fn requires_all(mut self, names: &[&'a str]) -> Self{\n        if let Some(ref mut vec) = self.b.requires {\n            for s in names {\n                vec.push((None, s));\n            }\n        } else {\n            let mut vec = vec![];\n            for s in names {\n                vec.push((None, *s));\n            }\n            self.b.requires = Some(vec);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::requires_if":["/// Allows a conditional requirement. The requirement will only become valid if this arg's value\n/// equals `val`.\n///\n/// **NOTE:** If using YAML the values should be laid out as follows\n///\n/// ```yaml\n/// requires_if:\n///     - [val, arg]\n/// ```\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .requires_if(\"val\", \"arg\")\n/// # ;\n/// ```\n///\n/// Setting [`Arg::requires_if(val, arg)`] requires that the `arg` be used at runtime if the\n/// defining argument's value is equal to `val`. If the defining argument is anything other than\n/// `val`, the other argument isn't required.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .takes_value(true)\n///         .requires_if(\"my.cfg\", \"other\")\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"other\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--config\", \"some.cfg\"\n///     ]);\n///\n/// assert!(res.is_ok()); // We didn't use --config=my.cfg, so other wasn't required\n/// ```\n///\n/// Setting [`Arg::requires_if(val, arg)`] and setting the value to `val` but *not* supplying\n/// `arg` is an error.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .takes_value(true)\n///         .requires_if(\"my.cfg\", \"input\")\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"input\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--config\", \"my.cfg\"\n///     ]);\n///\n/// assert!(res.is_err());\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [`Arg::requires(name)`]: ./struct.Arg.html#method.requires\n/// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n/// [override]: ./struct.Arg.html#method.overrides_with\npub fn requires_if(mut self, val: &'b str, arg: &'a str) -> Self{\n        if let Some(ref mut vec) = self.b.requires {\n            vec.push((Some(val), arg));\n        } else {\n            self.b.requires = Some(vec![(Some(val), arg)]);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::requires_ifs":["/// Allows multiple conditional requirements. The requirement will only become valid if this arg's value\n/// equals `val`.\n///\n/// **NOTE:** If using YAML the values should be laid out as follows\n///\n/// ```yaml\n/// requires_if:\n///     - [val, arg]\n///     - [val2, arg2]\n/// ```\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::Arg;\n/// Arg::with_name(\"config\")\n///     .requires_ifs(&[\n///         (\"val\", \"arg\"),\n///         (\"other_val\", \"arg2\"),\n///     ])\n/// # ;\n/// ```\n///\n/// Setting [`Arg::requires_ifs(&[\"val\", \"arg\"])`] requires that the `arg` be used at runtime if the\n/// defining argument's value is equal to `val`. If the defining argument's value is anything other\n/// than `val`, `arg` isn't required.\n///\n/// ```rust\n/// # use clap::{App, Arg, ErrorKind};\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cfg\")\n///         .takes_value(true)\n///         .requires_ifs(&[\n///             (\"special.conf\", \"opt\"),\n///             (\"other.conf\", \"other\"),\n///         ])\n///         .long(\"config\"))\n///     .arg(Arg::with_name(\"opt\")\n///         .long(\"option\")\n///         .takes_value(true))\n///     .arg(Arg::with_name(\"other\"))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"--config\", \"special.conf\"\n///     ]);\n///\n/// assert!(res.is_err()); // We  used --config=special.conf so --option <val> is required\n/// assert_eq!(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [`Arg::requires(name)`]: ./struct.Arg.html#method.requires\n/// [Conflicting]: ./struct.Arg.html#method.conflicts_with\n/// [override]: ./struct.Arg.html#method.overrides_with\npub fn requires_ifs(mut self, ifs: &[(&'b str, &'a str)]) -> Self{\n        if let Some(ref mut vec) = self.b.requires {\n            for &(val, arg) in ifs {\n                vec.push((Some(val), arg));\n            }\n        } else {\n            let mut vec = vec![];\n            for &(val, arg) in ifs {\n                vec.push((Some(val), arg));\n            }\n            self.b.requires = Some(vec);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::set":["/// Sets one of the [`ArgSettings`] settings for the argument.\n///\n/// [`ArgSettings`]: ./enum.ArgSettings.html\npub fn set(mut self, s: ArgSettings) -> Self{\n        self.setb(s);\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::setb":["#[doc(hidden)]\npub fn setb(&mut self, s: ArgSettings){\n        self.b.set(s);\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::short":["/// Sets the short version of the argument without the preceding `-`.\n///\n/// By default `clap` automatically assigns `V` and `h` to the auto-generated `version` and\n/// `help` arguments respectively. You may use the uppercase `V` or lowercase `h` for your own\n/// arguments, in which case `clap` simply will not assign those to the auto-generated\n/// `version` or `help` arguments.\n///\n/// **NOTE:** Any leading `-` characters will be stripped, and only the first\n/// non `-` character will be used as the [`short`] version\n///\n/// # Examples\n///\n/// To set [`short`] use a single valid UTF-8 code point. If you supply a leading `-` such as\n/// `-c`, the `-` will be stripped.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"config\")\n///     .short(\"c\")\n/// # ;\n/// ```\n///\n/// Setting [`short`] allows using the argument via a single hyphen (`-`) such as `-c`\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"config\")\n///         .short(\"c\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"-c\"\n///     ]);\n///\n/// assert!(m.is_present(\"config\"));\n/// ```\n/// [`short`]: ./struct.Arg.html#method.short\npub fn short<S: AsRef<str>>(mut self, s: S) -> Self{\n        self.s.short = s.as_ref().trim_left_matches(|c| c == '-').chars().nth(0);\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::takes_value":["/// Specifies that the argument takes a value at run time.\n///\n/// **NOTE:** values for arguments may be specified in any of the following methods\n///\n/// * Using a space such as `-o value` or `--option value`\n/// * Using an equals and no space such as `-o=value` or `--option=value`\n/// * Use a short and no space such as `-ovalue`\n///\n/// **NOTE:** By default, args which allow [multiple values] are delimited by commas, meaning\n/// `--option=val1,val2,val3` is three values for the `--option` argument. If you wish to\n/// change the delimiter to another character you can use [`Arg::value_delimiter(char)`],\n/// alternatively you can turn delimiting values **OFF** by using [`Arg::use_delimiter(false)`]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"config\")\n///     .takes_value(true)\n/// # ;\n/// ```\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"mode\")\n///         .long(\"mode\")\n///         .takes_value(true))\n///     .get_matches_from(vec![\n///         \"prog\", \"--mode\", \"fast\"\n///     ]);\n///\n/// assert!(m.is_present(\"mode\"));\n/// assert_eq!(m.value_of(\"mode\"), Some(\"fast\"));\n/// ```\n/// [`Arg::value_delimiter(char)`]: ./struct.Arg.html#method.value_delimiter\n/// [`Arg::use_delimiter(false)`]: ./struct.Arg.html#method.use_delimiter\n/// [multiple values]: ./struct.Arg.html#method.multiple\npub fn takes_value(self, tv: bool) -> Self{\n        if tv {\n            self.set(ArgSettings::TakesValue)\n        } else {\n            self.unset(ArgSettings::TakesValue)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::unset":["/// Unsets one of the [`ArgSettings`] settings for the argument.\n///\n/// [`ArgSettings`]: ./enum.ArgSettings.html\npub fn unset(mut self, s: ArgSettings) -> Self{\n        self.unsetb(s);\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::unsetb":["#[doc(hidden)]\npub fn unsetb(&mut self, s: ArgSettings){\n        self.b.unset(s);\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::use_delimiter":["/// Specifies whether or not an argument should allow grouping of multiple values via a\n/// delimiter. I.e. should `--option=val1,val2,val3` be parsed as three values (`val1`, `val2`,\n/// and `val3`) or as a single value (`val1,val2,val3`). Defaults to using `,` (comma) as the\n/// value delimiter for all arguments that accept values (options and positional arguments)\n///\n/// **NOTE:** The default is `false`. When set to `true` the default [`Arg::value_delimiter`]\n/// is the comma `,`.\n///\n/// # Examples\n///\n/// The following example shows the default behavior.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let delims = App::new(\"prog\")\n///     .arg(Arg::with_name(\"option\")\n///         .long(\"option\")\n///         .use_delimiter(true)\n///         .takes_value(true))\n///     .get_matches_from(vec![\n///         \"prog\", \"--option=val1,val2,val3\",\n///     ]);\n///\n/// assert!(delims.is_present(\"option\"));\n/// assert_eq!(delims.occurrences_of(\"option\"), 1);\n/// assert_eq!(delims.values_of(\"option\").unwrap().collect::<Vec<_>>(), [\"val1\", \"val2\", \"val3\"]);\n/// ```\n/// The next example shows the difference when turning delimiters off. This is the default\n/// behavior\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let nodelims = App::new(\"prog\")\n///     .arg(Arg::with_name(\"option\")\n///         .long(\"option\")\n///         .use_delimiter(false)\n///         .takes_value(true))\n///     .get_matches_from(vec![\n///         \"prog\", \"--option=val1,val2,val3\",\n///     ]);\n///\n/// assert!(nodelims.is_present(\"option\"));\n/// assert_eq!(nodelims.occurrences_of(\"option\"), 1);\n/// assert_eq!(nodelims.value_of(\"option\").unwrap(), \"val1,val2,val3\");\n/// ```\n/// [`Arg::value_delimiter`]: ./struct.Arg.html#method.value_delimiter\npub fn use_delimiter(mut self, d: bool) -> Self{\n        if d {\n            if self.v.val_delim.is_none() {\n                self.v.val_delim = Some(',');\n            }\n            self.setb(ArgSettings::TakesValue);\n            self.setb(ArgSettings::UseValueDelimiter);\n            self.unset(ArgSettings::ValueDelimiterNotSet)\n        } else {\n            self.v.val_delim = None;\n            self.unsetb(ArgSettings::UseValueDelimiter);\n            self.unset(ArgSettings::ValueDelimiterNotSet)\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::validator":["/// Allows one to perform a custom validation on the argument value. You provide a closure\n/// which accepts a [`String`] value, and return a [`Result`] where the [`Err(String)`] is a\n/// message displayed to the user.\n///\n/// **NOTE:** The error message does *not* need to contain the `error:` portion, only the\n/// message as all errors will appear as\n/// `error: Invalid value for '<arg>': <YOUR MESSAGE>` where `<arg>` is replaced by the actual\n/// arg, and `<YOUR MESSAGE>` is the `String` you return as the error.\n///\n/// **NOTE:** There is a small performance hit for using validators, as they are implemented\n/// with [`Rc`] pointers. And the value to be checked will be allocated an extra time in order\n/// to to be passed to the closure. This performance hit is extremely minimal in the grand\n/// scheme of things.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// fn has_at(v: String) -> Result<(), String> {\n///     if v.contains(\"@\") { return Ok(()); }\n///     Err(String::from(\"The value did not contain the required @ sigil\"))\n/// }\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .index(1)\n///         .validator(has_at))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"some@file\"\n///     ]);\n/// assert!(res.is_ok());\n/// assert_eq!(res.unwrap().value_of(\"file\"), Some(\"some@file\"));\n/// ```\n/// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html\n/// [`Result`]: https://doc.rust-lang.org/std/result/enum.Result.html\n/// [`Err(String)`]: https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err\n/// [`Rc`]: https://doc.rust-lang.org/std/rc/struct.Rc.html\npub fn validator<F>(mut self, f: F) -> Self\n    where\n        F: Fn(String) -> Result<(), String> + 'static,{\n        self.v.validator = Some(Rc::new(f));\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::validator_os":["/// Works identically to Validator but is intended to be used with values that could\n/// contain non UTF-8 formatted strings.\n///\n/// # Examples\n///\ndoc = \" ```rust\"\n/// # use clap::{App, Arg};\n/// # use std::ffi::{OsStr, OsString};\n/// # use std::os::unix::ffi::OsStrExt;\n/// fn has_ampersand(v: &OsStr) -> Result<(), OsString> {\n///     if v.as_bytes().iter().any(|b| *b == b'&') { return Ok(()); }\n///     Err(OsString::from(\"The value did not contain the required & sigil\"))\n/// }\n/// let res = App::new(\"prog\")\n///     .arg(Arg::with_name(\"file\")\n///         .index(1)\n///         .validator_os(has_ampersand))\n///     .get_matches_from_safe(vec![\n///         \"prog\", \"Fish & chips\"\n///     ]);\n/// assert!(res.is_ok());\n/// assert_eq!(res.unwrap().value_of(\"file\"), Some(\"Fish & chips\"));\n/// ```\n/// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html\n/// [`OsStr`]: https://doc.rust-lang.org/std/ffi/struct.OsStr.html\n/// [`OsString`]: https://doc.rust-lang.org/std/ffi/struct.OsString.html\n/// [`Result`]: https://doc.rust-lang.org/std/result/enum.Result.html\n/// [`Err(String)`]: https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err\n/// [`Rc`]: https://doc.rust-lang.org/std/rc/struct.Rc.html\npub fn validator_os<F>(mut self, f: F) -> Self\n    where\n        F: Fn(&OsStr) -> Result<(), OsString> + 'static,{\n        self.v.validator_os = Some(Rc::new(f));\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::value_delimiter":["/// Specifies the separator to use when values are clumped together, defaults to `,` (comma).\n///\n/// **NOTE:** implicitly sets [`Arg::use_delimiter(true)`]\n///\n/// **NOTE:** implicitly sets [`Arg::takes_value(true)`]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"config\")\n///         .short(\"c\")\n///         .long(\"config\")\n///         .value_delimiter(\";\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--config=val1;val2;val3\"\n///     ]);\n///\n/// assert_eq!(m.values_of(\"config\").unwrap().collect::<Vec<_>>(), [\"val1\", \"val2\", \"val3\"])\n/// ```\n/// [`Arg::use_delimiter(true)`]: ./struct.Arg.html#method.use_delimiter\n/// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\npub fn value_delimiter(mut self, d: &str) -> Self{\n        self.unsetb(ArgSettings::ValueDelimiterNotSet);\n        self.setb(ArgSettings::TakesValue);\n        self.setb(ArgSettings::UseValueDelimiter);\n        self.v.val_delim = Some(\n            d.chars()\n                .nth(0)\n                .expect(\"Failed to get value_delimiter from arg\"),\n        );\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::value_name":["/// Specifies the name for value of [option] or [positional] arguments inside of help\n/// documentation. This name is cosmetic only, the name is **not** used to access arguments.\n/// This setting can be very helpful when describing the type of input the user should be\n/// using, such as `FILE`, `INTERFACE`, etc. Although not required, it's somewhat convention to\n/// use all capital letters for the value name.\n///\n/// **NOTE:** implicitly sets [`Arg::takes_value(true)`]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"cfg\")\n///     .long(\"config\")\n///     .value_name(\"FILE\")\n/// # ;\n/// ```\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"config\")\n///         .long(\"config\")\n///         .value_name(\"FILE\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--help\"\n///     ]);\n/// ```\n/// Running the above program produces the following output\n///\n/// ```notrust\n/// valnames\n///\n/// USAGE:\n///    valnames [FLAGS] [OPTIONS]\n///\n/// FLAGS:\n///     -h, --help       Prints help information\n///     -V, --version    Prints version information\n///\n/// OPTIONS:\n///     --config <FILE>     Some help text\n/// ```\n/// [option]: ./struct.Arg.html#method.takes_value\n/// [positional]: ./struct.Arg.html#method.index\n/// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\npub fn value_name(mut self, name: &'b str) -> Self{\n        self.setb(ArgSettings::TakesValue);\n        if let Some(ref mut vals) = self.v.val_names {\n            let l = vals.len();\n            vals.insert(l, name);\n        } else {\n            let mut vm = VecMap::new();\n            vm.insert(0, name);\n            self.v.val_names = Some(vm);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::value_names":["/// Specify multiple names for values of option arguments. These names are cosmetic only, used\n/// for help and usage strings only. The names are **not** used to access arguments. The values\n/// of the arguments are accessed in numeric order (i.e. if you specify two names `one` and\n/// `two` `one` will be the first matched value, `two` will be the second).\n///\n/// This setting can be very helpful when describing the type of input the user should be\n/// using, such as `FILE`, `INTERFACE`, etc. Although not required, it's somewhat convention to\n/// use all capital letters for the value name.\n///\n/// **Pro Tip:** It may help to use [`Arg::next_line_help(true)`] if there are long, or\n/// multiple value names in order to not throw off the help text alignment of all options.\n///\n/// **NOTE:** This implicitly sets [`Arg::number_of_values`] if the number of value names is\n/// greater than one. I.e. be aware that the number of \"names\" you set for the values, will be\n/// the *exact* number of values required to satisfy this argument\n///\n/// **NOTE:** implicitly sets [`Arg::takes_value(true)`]\n///\n/// **NOTE:** Does *not* require or imply [`Arg::multiple(true)`].\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"speed\")\n///     .short(\"s\")\n///     .value_names(&[\"fast\", \"slow\"])\n/// # ;\n/// ```\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"io\")\n///         .long(\"io-files\")\n///         .value_names(&[\"INFILE\", \"OUTFILE\"]))\n///     .get_matches_from(vec![\n///         \"prog\", \"--help\"\n///     ]);\n/// ```\n/// Running the above program produces the following output\n///\n/// ```notrust\n/// valnames\n///\n/// USAGE:\n///    valnames [FLAGS] [OPTIONS]\n///\n/// FLAGS:\n///     -h, --help       Prints help information\n///     -V, --version    Prints version information\n///\n/// OPTIONS:\n///     --io-files <INFILE> <OUTFILE>    Some help text\n/// ```\n/// [`Arg::next_line_help(true)`]: ./struct.Arg.html#method.next_line_help\n/// [`Arg::number_of_values`]: ./struct.Arg.html#method.number_of_values\n/// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n/// [`Arg::multiple(true)`]: ./struct.Arg.html#method.multiple\npub fn value_names(mut self, names: &[&'b str]) -> Self{\n        self.setb(ArgSettings::TakesValue);\n        if self.is_set(ArgSettings::ValueDelimiterNotSet) {\n            self.unsetb(ArgSettings::ValueDelimiterNotSet);\n            self.setb(ArgSettings::UseValueDelimiter);\n        }\n        if let Some(ref mut vals) = self.v.val_names {\n            let mut l = vals.len();\n            for s in names {\n                vals.insert(l, s);\n                l += 1;\n            }\n        } else {\n            let mut vm = VecMap::new();\n            for (i, n) in names.iter().enumerate() {\n                vm.insert(i, *n);\n            }\n            self.v.val_names = Some(vm);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::value_terminator":["/// Specifies a value that *stops* parsing multiple values of a give argument. By default when\n/// one sets [`multiple(true)`] on an argument, clap will continue parsing values for that\n/// argument until it reaches another valid argument, or one of the other more specific settings\n/// for multiple values is used (such as [`min_values`], [`max_values`] or\n/// [`number_of_values`]).\n///\n/// **NOTE:** This setting only applies to [options] and [positional arguments]\n///\n/// **NOTE:** When the terminator is passed in on the command line, it is **not** stored as one\n/// of the values\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"vals\")\n///     .takes_value(true)\n///     .multiple(true)\n///     .value_terminator(\";\")\n/// # ;\n/// ```\n/// The following example uses two arguments, a sequence of commands, and the location in which\n/// to perform them\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///     .arg(Arg::with_name(\"cmds\")\n///         .multiple(true)\n///         .allow_hyphen_values(true)\n///         .value_terminator(\";\"))\n///     .arg(Arg::with_name(\"location\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"find\", \"-type\", \"f\", \"-name\", \"special\", \";\", \"/home/clap\"\n///     ]);\n/// let cmds: Vec<_> = m.values_of(\"cmds\").unwrap().collect();\n/// assert_eq!(&cmds, &[\"find\", \"-type\", \"f\", \"-name\", \"special\"]);\n/// assert_eq!(m.value_of(\"location\"), Some(\"/home/clap\"));\n/// ```\n/// [options]: ./struct.Arg.html#method.takes_value\n/// [positional arguments]: ./struct.Arg.html#method.index\n/// [`multiple(true)`]: ./struct.Arg.html#method.multiple\n/// [`min_values`]: ./struct.Arg.html#method.min_values\n/// [`number_of_values`]: ./struct.Arg.html#method.number_of_values\n/// [`max_values`]: ./struct.Arg.html#method.max_values\npub fn value_terminator(mut self, term: &'b str) -> Self{\n        self.setb(ArgSettings::TakesValue);\n        self.v.terminator = Some(term);\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::visible_alias":["/// Allows adding a [`Arg`] alias that functions exactly like those defined with\n/// [`Arg::alias`], except that they are visible inside the help message.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///             .arg(Arg::with_name(\"test\")\n///                 .visible_alias(\"something-awesome\")\n///                 .long(\"test\")\n///                 .takes_value(true))\n///        .get_matches_from(vec![\n///             \"prog\", \"--something-awesome\", \"coffee\"\n///         ]);\n/// assert!(m.is_present(\"test\"));\n/// assert_eq!(m.value_of(\"test\"), Some(\"coffee\"));\n/// ```\n/// [`Arg`]: ./struct.Arg.html\n/// [`App::alias`]: ./struct.Arg.html#method.alias\npub fn visible_alias<S: Into<&'b str>>(mut self, name: S) -> Self{\n        if let Some(ref mut als) = self.s.aliases {\n            als.push((name.into(), true));\n        } else {\n            self.s.aliases = Some(vec![(name.into(), true)]);\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::visible_aliases":["/// Allows adding multiple [`Arg`] aliases that functions exactly like those defined\n/// with [`Arg::aliases`], except that they are visible inside the help message.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"prog\")\n///             .arg(Arg::with_name(\"test\")\n///                 .long(\"test\")\n///                 .visible_aliases(&[\"something\", \"awesome\", \"cool\"]))\n///        .get_matches_from(vec![\n///             \"prog\", \"--awesome\"\n///         ]);\n/// assert!(m.is_present(\"test\"));\n/// ```\n/// [`Arg`]: ./struct.Arg.html\n/// [`App::aliases`]: ./struct.Arg.html#method.aliases\npub fn visible_aliases(mut self, names: &[&'b str]) -> Self{\n        if let Some(ref mut als) = self.s.aliases {\n            for n in names {\n                als.push((n, true));\n            }\n        } else {\n            self.s.aliases = Some(names.iter().map(|n| (*n, true)).collect::<Vec<_>>());\n        }\n        self\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg::Arg::<'a, 'b>::with_name":["/// Creates a new instance of [`Arg`] using a unique string name. The name will be used to get\n/// information about whether or not the argument was used at runtime, get values, set\n/// relationships with other args, etc..\n///\n/// **NOTE:** In the case of arguments that take values (i.e. [`Arg::takes_value(true)`])\n/// and positional arguments (i.e. those without a preceding `-` or `--`) the name will also\n/// be displayed when the user prints the usage/help information of the program.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// Arg::with_name(\"config\")\n/// # ;\n/// ```\n/// [`Arg::takes_value(true)`]: ./struct.Arg.html#method.takes_value\n/// [`Arg`]: ./struct.Arg.html\npub fn with_name(n: &'a str) -> Self{\n        Arg {\n            b: Base::new(n),\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"src/args/arg.rs\"))"],"args::arg_builder::base::Base":["pub struct Base<'a, 'b>\nwhere\n    'a: 'b,\n{\n    pub name: &'a str,\n    pub help: Option<&'b str>,\n    pub long_help: Option<&'b str>,\n    pub blacklist: Option<Vec<&'a str>>,\n    pub settings: ArgFlags,\n    pub r_unless: Option<Vec<&'a str>>,\n    pub overrides: Option<Vec<&'a str>>,\n    pub groups: Option<Vec<&'a str>>,\n    pub requires: Option<Vec<(Option<&'b str>, &'a str)>>,\n}","Real(LocalPath(\"src/args/arg_builder/base.rs\"))"],"args::arg_builder::base::Base::<'n, 'e>::is_set":["pub fn is_set(&self, s: ArgSettings) -> bool{\n        self.settings.is_set(s)\n    }","Real(LocalPath(\"src/args/arg_builder/base.rs\"))"],"args::arg_builder::base::Base::<'n, 'e>::new":["pub fn new(name: &'n str) -> Self{\n        Base {\n            name: name,\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/base.rs\"))"],"args::arg_builder::base::Base::<'n, 'e>::set":["pub fn set(&mut self, s: ArgSettings){\n        self.settings.set(s);\n    }","Real(LocalPath(\"src/args/arg_builder/base.rs\"))"],"args::arg_builder::base::Base::<'n, 'e>::unset":["pub fn unset(&mut self, s: ArgSettings){\n        self.settings.unset(s);\n    }","Real(LocalPath(\"src/args/arg_builder/base.rs\"))"],"args::arg_builder::flag::FlagBuilder":["#[doc(hidden)]\npub struct FlagBuilder<'n, 'e>\nwhere\n    'n: 'e,\n{\n    pub b: Base<'n, 'e>,\n    pub s: Switched<'e>,\n}","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"args::arg_builder::flag::FlagBuilder::<'n, 'e>::new":["pub fn new(name: &'n str) -> Self{\n        FlagBuilder {\n            b: Base::new(name),\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))"],"args::arg_builder::option::OptBuilder":["#[allow(missing_debug_implementations)]\n#[doc(hidden)]\npub struct OptBuilder<'n, 'e>\nwhere\n    'n: 'e,\n{\n    pub b: Base<'n, 'e>,\n    pub s: Switched<'e>,\n    pub v: Valued<'n, 'e>,\n}","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"args::arg_builder::option::OptBuilder::<'n, 'e>::new":["pub fn new(name: &'n str) -> Self{\n        OptBuilder {\n            b: Base::new(name),\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/option.rs\"))"],"args::arg_builder::positional::PosBuilder":["#[allow(missing_debug_implementations)]\n#[doc(hidden)]\npub struct PosBuilder<'n, 'e>\nwhere\n    'n: 'e,\n{\n    pub b: Base<'n, 'e>,\n    pub v: Valued<'n, 'e>,\n    pub index: u64,\n}","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"args::arg_builder::positional::PosBuilder::<'n, 'e>::from_arg":["pub fn from_arg(mut a: Arg<'n, 'e>, idx: u64) -> Self{\n        if a.v.max_vals.is_some()\n            || a.v.min_vals.is_some()\n            || (a.v.num_vals.is_some() && a.v.num_vals.unwrap() > 1)\n        {\n            a.b.settings.set(ArgSettings::Multiple);\n        }\n        PosBuilder {\n            b: mem::replace(&mut a.b, Base::default()),\n            v: mem::replace(&mut a.v, Valued::default()),\n            index: idx,\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"args::arg_builder::positional::PosBuilder::<'n, 'e>::from_arg_ref":["pub fn from_arg_ref(a: &Arg<'n, 'e>, idx: u64) -> Self{\n        let mut pb = PosBuilder {\n            b: Base::from(a),\n            v: Valued::from(a),\n            index: idx,\n        };\n        if a.v.max_vals.is_some()\n            || a.v.min_vals.is_some()\n            || (a.v.num_vals.is_some() && a.v.num_vals.unwrap() > 1)\n        {\n            pb.b.settings.set(ArgSettings::Multiple);\n        }\n        pb\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"args::arg_builder::positional::PosBuilder::<'n, 'e>::multiple_str":["pub fn multiple_str(&self) -> &str{\n        let mult_vals = self\n            .v\n            .val_names\n            .as_ref()\n            .map_or(true, |names| names.len() < 2);\n        if self.is_set(ArgSettings::Multiple) && mult_vals {\n            \"...\"\n        } else {\n            \"\"\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"args::arg_builder::positional::PosBuilder::<'n, 'e>::name_no_brackets":["pub fn name_no_brackets(&self) -> Cow<str>{\n        debugln!(\"PosBuilder::name_no_brackets;\");\n        let mut delim = String::new();\n        delim.push(if self.is_set(ArgSettings::RequireDelimiter) {\n            self.v.val_delim.expect(INTERNAL_ERROR_MSG)\n        } else {\n            ' '\n        });\n        if let Some(ref names) = self.v.val_names {\n            debugln!(\"PosBuilder:name_no_brackets: val_names={:#?}\", names);\n            if names.len() > 1 {\n                Cow::Owned(\n                    names\n                        .values()\n                        .map(|n| format!(\"<{}>\", n))\n                        .collect::<Vec<_>>()\n                        .join(&*delim),\n                )\n            } else {\n                Cow::Borrowed(names.values().next().expect(INTERNAL_ERROR_MSG))\n            }\n        } else {\n            debugln!(\"PosBuilder:name_no_brackets: just name\");\n            Cow::Borrowed(self.b.name)\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"args::arg_builder::positional::PosBuilder::<'n, 'e>::new":["pub fn new(name: &'n str, idx: u64) -> Self{\n        PosBuilder {\n            b: Base::new(name),\n            index: idx,\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))"],"args::arg_builder::switched::Switched":["pub struct Switched<'b> {\n    pub short: Option<char>,\n    pub long: Option<&'b str>,\n    pub aliases: Option<Vec<(&'b str, bool)>>, // (name, visible)\n    pub disp_ord: usize,\n    pub unified_ord: usize,\n}","Real(LocalPath(\"src/args/arg_builder/switched.rs\"))"],"args::arg_builder::valued::Valued":["#[allow(missing_debug_implementations)]\npub struct Valued<'a, 'b>\nwhere\n    'a: 'b,\n{\n    pub possible_vals: Option<Vec<&'b str>>,\n    pub val_names: Option<VecMap<&'b str>>,\n    pub num_vals: Option<u64>,\n    pub max_vals: Option<u64>,\n    pub min_vals: Option<u64>,\n    pub validator: Option<Rc<Fn(String) -> Result<(), String>>>,\n    pub validator_os: Option<Rc<Fn(&OsStr) -> Result<(), OsString>>>,\n    pub val_delim: Option<char>,\n    pub default_val: Option<&'b OsStr>,\n    pub default_vals_ifs: Option<VecMap<(&'a str, Option<&'b OsStr>, &'b OsStr)>>,\n    pub env: Option<(&'a OsStr, Option<OsString>)>,\n    pub terminator: Option<&'b str>,\n}","Real(LocalPath(\"src/args/arg_builder/valued.rs\"))"],"args::arg_builder::valued::Valued::<'n, 'e>::fill_in":["pub fn fill_in(&mut self){\n        if let Some(ref vec) = self.val_names {\n            if vec.len() > 1 {\n                self.num_vals = Some(vec.len() as u64);\n            }\n        }\n    }","Real(LocalPath(\"src/args/arg_builder/valued.rs\"))"],"args::arg_matcher::ArgMatcher":["#[doc(hidden)]\n#[allow(missing_debug_implementations)]\npub struct ArgMatcher<'a>(pub ArgMatches<'a>);","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::add_index_to":["pub fn add_index_to(&mut self, arg: &'a str, idx: usize){\n        let ma = self.entry(arg).or_insert(MatchedArg {\n            occurs: 0,\n            indices: Vec::with_capacity(1),\n            vals: Vec::new(),\n        });\n        ma.indices.push(idx);\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::add_val_to":["pub fn add_val_to(&mut self, arg: &'a str, val: &OsStr){\n        let ma = self.entry(arg).or_insert(MatchedArg {\n            occurs: 0,\n            indices: Vec::with_capacity(1),\n            vals: Vec::with_capacity(1),\n        });\n        ma.vals.push(val.to_owned());\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::arg_names":["pub fn arg_names(&'a self) -> Vec<&'a str>{\n        self.0.args.keys().map(Deref::deref).collect()\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::contains":["pub fn contains(&self, arg: &str) -> bool{\n        self.0.args.contains_key(arg)\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::entry":["pub fn entry(&mut self, arg: &'a str) -> Entry<&'a str, MatchedArg>{\n        self.0.args.entry(arg)\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::fill_in_global_values":["fn fill_in_global_values(\n        &mut self,\n        global_arg_vec: &[&'a str],\n        vals_map: &mut HashMap<&'a str, MatchedArg>,\n    ){\n        for global_arg in global_arg_vec {\n            if let Some(ma) = self.get(global_arg) {\n                // We have to check if the parent's global arg wasn't used but still exists\n                // such as from a default value.\n                //\n                // For example, `myprog subcommand --global-arg=value` where --global-arg defines\n                // a default value of `other` myprog would have an existing MatchedArg for\n                // --global-arg where the value is `other`, however the occurs will be 0.\n                let to_update = if let Some(parent_ma) = vals_map.get(global_arg) {\n                    if parent_ma.occurs > 0 && ma.occurs == 0 {\n                        parent_ma.clone()\n                    } else {\n                        ma.clone()\n                    }\n                } else {\n                    ma.clone()\n                };\n                vals_map.insert(global_arg, to_update);\n            }\n        }\n        if let Some(ref mut sc) = self.0.subcommand {\n            let mut am = ArgMatcher(mem::replace(&mut sc.matches, ArgMatches::new()));\n            am.fill_in_global_values(global_arg_vec, vals_map);\n            mem::swap(&mut am.0, &mut sc.matches);\n        }\n\n        for (name, matched_arg) in vals_map.into_iter() {\n            self.0.args.insert(name, matched_arg.clone());\n        }\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::get":["pub fn get(&self, arg: &str) -> Option<&MatchedArg>{\n        self.0.args.get(arg)\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::get_mut":["pub fn get_mut(&mut self, arg: &str) -> Option<&mut MatchedArg>{\n        self.0.args.get_mut(arg)\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::handle_self_overrides":["pub fn handle_self_overrides<'b>(&mut self, a: Option<&AnyArg<'a, 'b>>){\n        debugln!(\n            \"ArgMatcher::handle_self_overrides:{:?};\",\n            a.map_or(None, |a| Some(a.name()))\n        );\n        if let Some(aa) = a {\n            if !aa.has_switch() || aa.is_set(ArgSettings::Multiple) {\n                // positional args can't override self or else we would never advance to the next\n\n                // Also flags with --multiple set are ignored otherwise we could never have more\n                // than one\n                return;\n            }\n            if let Some(ma) = self.get_mut(aa.name()) {\n                if ma.vals.len() > 1 {\n                    // swap_remove(0) would be O(1) but does not preserve order, which\n                    // we need\n                    ma.vals.remove(0);\n                    ma.occurs = 1;\n                } else if !aa.takes_value() && ma.occurs > 1 {\n                    ma.occurs = 1;\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::inc_occurrence_of":["pub fn inc_occurrence_of(&mut self, arg: &'a str){\n        debugln!(\"ArgMatcher::inc_occurrence_of: arg={}\", arg);\n        if let Some(a) = self.get_mut(arg) {\n            a.occurs += 1;\n            return;\n        }\n        debugln!(\"ArgMatcher::inc_occurrence_of: first instance\");\n        self.insert(arg);\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::inc_occurrences_of":["pub fn inc_occurrences_of(&mut self, args: &[&'a str]){\n        debugln!(\"ArgMatcher::inc_occurrences_of: args={:?}\", args);\n        for arg in args {\n            self.inc_occurrence_of(arg);\n        }\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::insert":["pub fn insert(&mut self, name: &'a str){\n        self.0.args.insert(name, MatchedArg::new());\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::is_empty":["pub fn is_empty(&self) -> bool{\n        self.0.args.is_empty()\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::is_present":["pub fn is_present(&self, name: &str) -> bool{\n        self.0.is_present(name)\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::iter":["pub fn iter(&self) -> Iter<&str, MatchedArg>{\n        self.0.args.iter()\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::needs_more_vals":["pub fn needs_more_vals<'b, A>(&self, o: &A) -> bool\n    where\n        A: AnyArg<'a, 'b>,{\n        debugln!(\"ArgMatcher::needs_more_vals: o={}\", o.name());\n        if let Some(ma) = self.get(o.name()) {\n            if let Some(num) = o.num_vals() {\n                debugln!(\"ArgMatcher::needs_more_vals: num_vals...{}\", num);\n                return if o.is_set(ArgSettings::Multiple) {\n                    ((ma.vals.len() as u64) % num) != 0\n                } else {\n                    num != (ma.vals.len() as u64)\n                };\n            } else if let Some(num) = o.max_vals() {\n                debugln!(\"ArgMatcher::needs_more_vals: max_vals...{}\", num);\n                return !((ma.vals.len() as u64) > num);\n            } else if o.min_vals().is_some() {\n                debugln!(\"ArgMatcher::needs_more_vals: min_vals...true\");\n                return true;\n            }\n            return o.is_set(ArgSettings::Multiple);\n        }\n        true\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::new":["pub fn new() -> Self{\n        ArgMatcher::default()\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::process_arg_overrides":["pub fn process_arg_overrides<'b>(\n        &mut self,\n        a: Option<&AnyArg<'a, 'b>>,\n        overrides: &mut Vec<(&'b str, &'a str)>,\n        required: &mut Vec<&'a str>,\n        check_all: bool,\n    ){\n        debugln!(\n            \"ArgMatcher::process_arg_overrides:{:?};\",\n            a.map_or(None, |a| Some(a.name()))\n        );\n        if let Some(aa) = a {\n            let mut self_done = false;\n            if let Some(a_overrides) = aa.overrides() {\n                for overr in a_overrides {\n                    debugln!(\"ArgMatcher::process_arg_overrides:iter:{};\", overr);\n                    if overr == &aa.name() {\n                        self_done = true;\n                        self.handle_self_overrides(a);\n                    } else if self.is_present(overr) {\n                        debugln!(\n                            \"ArgMatcher::process_arg_overrides:iter:{}: removing from matches;\",\n                            overr\n                        );\n                        self.remove(overr);\n                        for i in (0..required.len()).rev() {\n                            if &required[i] == overr {\n                                debugln!(\n                                    \"ArgMatcher::process_arg_overrides:iter:{}: removing required;\",\n                                    overr\n                                );\n                                required.swap_remove(i);\n                                break;\n                            }\n                        }\n                        overrides.push((overr, aa.name()));\n                    } else {\n                        overrides.push((overr, aa.name()));\n                    }\n                }\n            }\n            if check_all && !self_done {\n                self.handle_self_overrides(a);\n            }\n        }\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::propagate_globals":["pub fn propagate_globals(&mut self, global_arg_vec: &[&'a str]){\n        debugln!(\n            \"ArgMatcher::get_global_values: global_arg_vec={:?}\",\n            global_arg_vec\n        );\n        let mut vals_map = HashMap::new();\n        self.fill_in_global_values(global_arg_vec, &mut vals_map);\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::remove":["pub fn remove(&mut self, arg: &str){\n        self.0.args.remove(arg);\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::remove_all":["pub fn remove_all(&mut self, args: &[&str]){\n        for &arg in args {\n            self.0.args.remove(arg);\n        }\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::subcommand":["pub fn subcommand(&mut self, sc: SubCommand<'a>){\n        self.0.subcommand = Some(Box::new(sc));\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::subcommand_name":["pub fn subcommand_name(&self) -> Option<&str>{\n        self.0.subcommand_name()\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matcher::ArgMatcher::<'a>::usage":["pub fn usage(&mut self, usage: String){\n        self.0.usage = Some(usage);\n    }","Real(LocalPath(\"src/args/arg_matcher.rs\"))"],"args::arg_matches::ArgMatches":["/// Used to get information about the arguments that were supplied to the program at runtime by\n/// the user. New instances of this struct are obtained by using the [`App::get_matches`] family of\n/// methods.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg};\n/// let matches = App::new(\"MyApp\")\n///     .arg(Arg::with_name(\"out\")\n///         .long(\"output\")\n///         .required(true)\n///         .takes_value(true))\n///     .arg(Arg::with_name(\"debug\")\n///         .short(\"d\")\n///         .multiple(true))\n///     .arg(Arg::with_name(\"cfg\")\n///         .short(\"c\")\n///         .takes_value(true))\n///     .get_matches(); // builds the instance of ArgMatches\n///\n/// // to get information about the \"cfg\" argument we created, such as the value supplied we use\n/// // various ArgMatches methods, such as ArgMatches::value_of\n/// if let Some(c) = matches.value_of(\"cfg\") {\n///     println!(\"Value for -c: {}\", c);\n/// }\n///\n/// // The ArgMatches::value_of method returns an Option because the user may not have supplied\n/// // that argument at runtime. But if we specified that the argument was \"required\" as we did\n/// // with the \"out\" argument, we can safely unwrap because `clap` verifies that was actually\n/// // used at runtime.\n/// println!(\"Value for --output: {}\", matches.value_of(\"out\").unwrap());\n///\n/// // You can check the presence of an argument\n/// if matches.is_present(\"out\") {\n///     // Another way to check if an argument was present, or if it occurred multiple times is to\n///     // use occurrences_of() which returns 0 if an argument isn't found at runtime, or the\n///     // number of times that it occurred, if it was. To allow an argument to appear more than\n///     // once, you must use the .multiple(true) method, otherwise it will only return 1 or 0.\n///     if matches.occurrences_of(\"debug\") > 2 {\n///         println!(\"Debug mode is REALLY on, don't be crazy\");\n///     } else {\n///         println!(\"Debug mode kind of on\");\n///     }\n/// }\n/// ```\n/// [`App::get_matches`]: ./struct.App.html#method.get_matches\npub struct ArgMatches<'a> {\n    #[doc(hidden)]\n    pub args: HashMap<&'a str, MatchedArg>,\n    #[doc(hidden)]\n    pub subcommand: Option<Box<SubCommand<'a>>>,\n    #[doc(hidden)]\n    pub usage: Option<String>,\n}","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::index_of":["/// Gets the starting index of the argument in respect to all other arguments. Indices are\n/// similar to argv indices, but are not exactly 1:1.\n///\n/// For flags (i.e. those arguments which don't have an associated value), indices refer\n/// to occurrence of the switch, such as `-f`, or `--flag`. However, for options the indices\n/// refer to the *values* `-o val` would therefore not represent two distinct indices, only the\n/// index for `val` would be recorded. This is by design.\n///\n/// Besides the flag/option descrepancy, the primary difference between an argv index and clap\n/// index, is that clap continues counting once all arguments have properly seperated, whereas\n/// an argv index does not.\n///\n/// The examples should clear this up.\n///\n/// *NOTE:* If an argument is allowed multiple times, this method will only give the *first*\n/// index.\n///\n/// # Examples\n///\n/// The argv indices are listed in the comments below. See how they correspond to the clap\n/// indices. Note that if it's not listed in a clap index, this is becuase it's not saved in\n/// in an `ArgMatches` struct for querying.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myapp\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"option\")\n///         .short(\"o\")\n///         .takes_value(true))\n///     .get_matches_from(vec![\"myapp\", \"-f\", \"-o\", \"val\"]);\n///             // ARGV idices: ^0       ^1    ^2    ^3\n///             // clap idices:          ^1          ^3\n///\n/// assert_eq!(m.index_of(\"flag\"), Some(1));\n/// assert_eq!(m.index_of(\"option\"), Some(3));\n/// ```\n///\n/// Now notice, if we use one of the other styles of options:\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myapp\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"option\")\n///         .short(\"o\")\n///         .takes_value(true))\n///     .get_matches_from(vec![\"myapp\", \"-f\", \"-o=val\"]);\n///             // ARGV idices: ^0       ^1    ^2\n///             // clap idices:          ^1       ^3\n///\n/// assert_eq!(m.index_of(\"flag\"), Some(1));\n/// assert_eq!(m.index_of(\"option\"), Some(3));\n/// ```\n///\n/// Things become much more complicated, or clear if we look at a more complex combination of\n/// flags. Let's also throw in the final option style for good measure.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myapp\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"flag2\")\n///         .short(\"F\"))\n///     .arg(Arg::with_name(\"flag3\")\n///         .short(\"z\"))\n///     .arg(Arg::with_name(\"option\")\n///         .short(\"o\")\n///         .takes_value(true))\n///     .get_matches_from(vec![\"myapp\", \"-fzF\", \"-oval\"]);\n///             // ARGV idices: ^0      ^1       ^2\n///             // clap idices:         ^1,2,3    ^5\n///             //\n///             // clap sees the above as 'myapp -f -z -F -o val'\n///             //                         ^0    ^1 ^2 ^3 ^4 ^5\n/// assert_eq!(m.index_of(\"flag\"), Some(1));\n/// assert_eq!(m.index_of(\"flag2\"), Some(3));\n/// assert_eq!(m.index_of(\"flag3\"), Some(2));\n/// assert_eq!(m.index_of(\"option\"), Some(5));\n/// ```\n///\n/// One final combination of flags/options to see how they combine:\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myapp\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"flag2\")\n///         .short(\"F\"))\n///     .arg(Arg::with_name(\"flag3\")\n///         .short(\"z\"))\n///     .arg(Arg::with_name(\"option\")\n///         .short(\"o\")\n///         .takes_value(true)\n///         .multiple(true))\n///     .get_matches_from(vec![\"myapp\", \"-fzFoval\"]);\n///             // ARGV idices: ^0       ^1\n///             // clap idices:          ^1,2,3^5\n///             //\n///             // clap sees the above as 'myapp -f -z -F -o val'\n///             //                         ^0    ^1 ^2 ^3 ^4 ^5\n/// assert_eq!(m.index_of(\"flag\"), Some(1));\n/// assert_eq!(m.index_of(\"flag2\"), Some(3));\n/// assert_eq!(m.index_of(\"flag3\"), Some(2));\n/// assert_eq!(m.index_of(\"option\"), Some(5));\n/// ```\n///\n/// The last part to mention is when values are sent in multiple groups with a [delimiter].\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myapp\")\n///     .arg(Arg::with_name(\"option\")\n///         .short(\"o\")\n///         .takes_value(true)\n///         .multiple(true))\n///     .get_matches_from(vec![\"myapp\", \"-o=val1,val2,val3\"]);\n///             // ARGV idices: ^0       ^1\n///             // clap idices:             ^2   ^3   ^4\n///             //\n///             // clap sees the above as 'myapp -o val1 val2 val3'\n///             //                         ^0    ^1 ^2   ^3   ^4\n/// assert_eq!(m.index_of(\"option\"), Some(2));\n/// ```\n/// [`ArgMatches`]: ./struct.ArgMatches.html\n/// [delimiter]: ./struct.Arg.html#method.value_delimiter\npub fn index_of<S: AsRef<str>>(&self, name: S) -> Option<usize>{\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            if let Some(i) = arg.indices.get(0) {\n                return Some(*i);\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::indices_of":["/// Gets all indices of the argument in respect to all other arguments. Indices are\n/// similar to argv indices, but are not exactly 1:1.\n///\n/// For flags (i.e. those arguments which don't have an associated value), indices refer\n/// to occurrence of the switch, such as `-f`, or `--flag`. However, for options the indices\n/// refer to the *values* `-o val` would therefore not represent two distinct indices, only the\n/// index for `val` would be recorded. This is by design.\n///\n/// *NOTE:* For more information about how clap indices compare to argv indices, see\n/// [`ArgMatches::index_of`]\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myapp\")\n///     .arg(Arg::with_name(\"option\")\n///         .short(\"o\")\n///         .takes_value(true)\n///         .use_delimiter(true)\n///         .multiple(true))\n///     .get_matches_from(vec![\"myapp\", \"-o=val1,val2,val3\"]);\n///             // ARGV idices: ^0       ^1\n///             // clap idices:             ^2   ^3   ^4\n///             //\n///             // clap sees the above as 'myapp -o val1 val2 val3'\n///             //                         ^0    ^1 ^2   ^3   ^4\n/// assert_eq!(m.indices_of(\"option\").unwrap().collect::<Vec<_>>(), &[2, 3, 4]);\n/// ```\n///\n/// Another quick example is when flags and options are used together\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myapp\")\n///     .arg(Arg::with_name(\"option\")\n///         .short(\"o\")\n///         .takes_value(true)\n///         .multiple(true))\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\")\n///         .multiple(true))\n///     .get_matches_from(vec![\"myapp\", \"-o\", \"val1\", \"-f\", \"-o\", \"val2\", \"-f\"]);\n///             // ARGV idices: ^0       ^1    ^2      ^3    ^4    ^5      ^6\n///             // clap idices:                ^2      ^3          ^5      ^6\n///\n/// assert_eq!(m.indices_of(\"option\").unwrap().collect::<Vec<_>>(), &[2, 5]);\n/// assert_eq!(m.indices_of(\"flag\").unwrap().collect::<Vec<_>>(), &[3, 6]);\n/// ```\n///\n/// One final example, which is an odd case; if we *don't* use  value delimiter as we did with\n/// the first example above instead of `val1`, `val2` and `val3` all being distinc values, they\n/// would all be a single value of `val1,val2,val3`, in which case case they'd only receive a\n/// single index.\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myapp\")\n///     .arg(Arg::with_name(\"option\")\n///         .short(\"o\")\n///         .takes_value(true)\n///         .multiple(true))\n///     .get_matches_from(vec![\"myapp\", \"-o=val1,val2,val3\"]);\n///             // ARGV idices: ^0       ^1\n///             // clap idices:             ^2\n///             //\n///             // clap sees the above as 'myapp -o \"val1,val2,val3\"'\n///             //                         ^0    ^1  ^2\n/// assert_eq!(m.indices_of(\"option\").unwrap().collect::<Vec<_>>(), &[2]);\n/// ```\n/// [`ArgMatches`]: ./struct.ArgMatches.html\n/// [`ArgMatches::index_of`]: ./struct.ArgMatches.html#method.index_of\n/// [delimiter]: ./struct.Arg.html#method.value_delimiter\npub fn indices_of<S: AsRef<str>>(&'a self, name: S) -> Option<Indices<'a>>{\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            fn to_usize(i: &usize) -> usize {\n                *i\n            }\n            let to_usize: fn(&usize) -> usize = to_usize; // coerce to fn pointer\n            return Some(Indices {\n                iter: arg.indices.iter().map(to_usize),\n            });\n        }\n        None\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::indices_of::to_usize":["fn to_usize(i: &usize) -> usize{\n                *i\n            }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::is_present":["/// Returns `true` if an argument was present at runtime, otherwise `false`.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"debug\")\n///         .short(\"d\"))\n///     .get_matches_from(vec![\n///         \"myprog\", \"-d\"\n///     ]);\n///\n/// assert!(m.is_present(\"debug\"));\n/// ```\npub fn is_present<S: AsRef<str>>(&self, name: S) -> bool{\n        if let Some(ref sc) = self.subcommand {\n            if sc.name == name.as_ref() {\n                return true;\n            }\n        }\n        self.args.contains_key(name.as_ref())\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::new":["#[doc(hidden)]\npub fn new() -> Self{\n        ArgMatches {\n            ..Default::default()\n        }\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::occurrences_of":["/// Returns the number of times an argument was used at runtime. If an argument isn't present\n/// it will return `0`.\n///\n/// **NOTE:** This returns the number of times the argument was used, *not* the number of\n/// values. For example, `-o val1 val2 val3 -o val4` would return `2` (2 occurrences, but 4\n/// values).\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"debug\")\n///         .short(\"d\")\n///         .multiple(true))\n///     .get_matches_from(vec![\n///         \"myprog\", \"-d\", \"-d\", \"-d\"\n///     ]);\n///\n/// assert_eq!(m.occurrences_of(\"debug\"), 3);\n/// ```\n///\n/// This next example shows that counts actual uses of the argument, not just `-`'s\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"debug\")\n///         .short(\"d\")\n///         .multiple(true))\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .get_matches_from(vec![\n///         \"myprog\", \"-ddfd\"\n///     ]);\n///\n/// assert_eq!(m.occurrences_of(\"debug\"), 3);\n/// assert_eq!(m.occurrences_of(\"flag\"), 1);\n/// ```\npub fn occurrences_of<S: AsRef<str>>(&self, name: S) -> u64{\n        self.args.get(name.as_ref()).map_or(0, |a| a.occurs)\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::subcommand":["/// This brings together [`ArgMatches::subcommand_matches`] and [`ArgMatches::subcommand_name`]\n/// by returning a tuple with both pieces of information.\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg, SubCommand};\n///  let app_m = App::new(\"git\")\n///      .subcommand(SubCommand::with_name(\"clone\"))\n///      .subcommand(SubCommand::with_name(\"push\"))\n///      .subcommand(SubCommand::with_name(\"commit\"))\n///      .get_matches();\n///\n/// match app_m.subcommand() {\n///     (\"clone\",  Some(sub_m)) => {}, // clone was used\n///     (\"push\",   Some(sub_m)) => {}, // push was used\n///     (\"commit\", Some(sub_m)) => {}, // commit was used\n///     _                       => {}, // Either no subcommand or one not tested for...\n/// }\n/// ```\n///\n/// Another useful scenario is when you want to support third party, or external, subcommands.\n/// In these cases you can't know the subcommand name ahead of time, so use a variable instead\n/// with pattern matching!\n///\n/// ```rust\n/// # use clap::{App, AppSettings};\n/// // Assume there is an external subcommand named \"subcmd\"\n/// let app_m = App::new(\"myprog\")\n///     .setting(AppSettings::AllowExternalSubcommands)\n///     .get_matches_from(vec![\n///         \"myprog\", \"subcmd\", \"--option\", \"value\", \"-fff\", \"--flag\"\n///     ]);\n///\n/// // All trailing arguments will be stored under the subcommand's sub-matches using an empty\n/// // string argument name\n/// match app_m.subcommand() {\n///     (external, Some(sub_m)) => {\n///          let ext_args: Vec<&str> = sub_m.values_of(\"\").unwrap().collect();\n///          assert_eq!(external, \"subcmd\");\n///          assert_eq!(ext_args, [\"--option\", \"value\", \"-fff\", \"--flag\"]);\n///     },\n///     _ => {},\n/// }\n/// ```\n/// [`ArgMatches::subcommand_matches`]: ./struct.ArgMatches.html#method.subcommand_matches\n/// [`ArgMatches::subcommand_name`]: ./struct.ArgMatches.html#method.subcommand_name\npub fn subcommand(&self) -> (&str, Option<&ArgMatches<'a>>){\n        self.subcommand\n            .as_ref()\n            .map_or((\"\", None), |sc| (&sc.name[..], Some(&sc.matches)))\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::subcommand_matches":["/// Because [`Subcommand`]s are essentially \"sub-[`App`]s\" they have their own [`ArgMatches`]\n/// as well. This method returns the [`ArgMatches`] for a particular subcommand or `None` if\n/// the subcommand wasn't present at runtime.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, SubCommand};\n/// let app_m = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"debug\")\n///         .short(\"d\"))\n///     .subcommand(SubCommand::with_name(\"test\")\n///         .arg(Arg::with_name(\"opt\")\n///             .long(\"option\")\n///             .takes_value(true)))\n///     .get_matches_from(vec![\n///         \"myprog\", \"-d\", \"test\", \"--option\", \"val\"\n///     ]);\n///\n/// // Both parent commands, and child subcommands can have arguments present at the same times\n/// assert!(app_m.is_present(\"debug\"));\n///\n/// // Get the subcommand's ArgMatches instance\n/// if let Some(sub_m) = app_m.subcommand_matches(\"test\") {\n///     // Use the struct like normal\n///     assert_eq!(sub_m.value_of(\"opt\"), Some(\"val\"));\n/// }\n/// ```\n/// [`Subcommand`]: ./struct.SubCommand.html\n/// [`App`]: ./struct.App.html\n/// [`ArgMatches`]: ./struct.ArgMatches.html\npub fn subcommand_matches<S: AsRef<str>>(&self, name: S) -> Option<&ArgMatches<'a>>{\n        if let Some(ref s) = self.subcommand {\n            if s.name == name.as_ref() {\n                return Some(&s.matches);\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::subcommand_name":["/// Because [`Subcommand`]s are essentially \"sub-[`App`]s\" they have their own [`ArgMatches`]\n/// as well.But simply getting the sub-[`ArgMatches`] doesn't help much if we don't also know\n/// which subcommand was actually used. This method returns the name of the subcommand that was\n/// used at runtime, or `None` if one wasn't.\n///\n/// *NOTE*: Subcommands form a hierarchy, where multiple subcommands can be used at runtime,\n/// but only a single subcommand from any group of sibling commands may used at once.\n///\n/// An ASCII art depiction may help explain this better...Using a fictional version of `git` as\n/// the demo subject. Imagine the following are all subcommands of `git` (note, the author is\n/// aware these aren't actually all subcommands in the real `git` interface, but it makes\n/// explanation easier)\n///\n/// ```notrust\n///              Top Level App (git)                         TOP\n///                              |\n///       -----------------------------------------\n///      /             |                \\          \\\n///   clone          push              add       commit      LEVEL 1\n///     |           /    \\            /    \\       |\n///    url      origin   remote    ref    name   message     LEVEL 2\n///             /                  /\\\n///          path            remote  local                   LEVEL 3\n/// ```\n///\n/// Given the above fictional subcommand hierarchy, valid runtime uses would be (not an all\n/// inclusive list, and not including argument options per command for brevity and clarity):\n///\n/// ```sh\n/// $ git clone url\n/// $ git push origin path\n/// $ git add ref local\n/// $ git commit message\n/// ```\n///\n/// Notice only one command per \"level\" may be used. You could not, for example, do `$ git\n/// clone url push origin path`\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg, SubCommand};\n///  let app_m = App::new(\"git\")\n///      .subcommand(SubCommand::with_name(\"clone\"))\n///      .subcommand(SubCommand::with_name(\"push\"))\n///      .subcommand(SubCommand::with_name(\"commit\"))\n///      .get_matches();\n///\n/// match app_m.subcommand_name() {\n///     Some(\"clone\")  => {}, // clone was used\n///     Some(\"push\")   => {}, // push was used\n///     Some(\"commit\") => {}, // commit was used\n///     _              => {}, // Either no subcommand or one not tested for...\n/// }\n/// ```\n/// [`Subcommand`]: ./struct.SubCommand.html\n/// [`App`]: ./struct.App.html\n/// [`ArgMatches`]: ./struct.ArgMatches.html\npub fn subcommand_name(&self) -> Option<&str>{\n        self.subcommand.as_ref().map(|sc| &sc.name[..])\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::usage":["/// Returns a string slice of the usage statement for the [`App`] or [`SubCommand`]\n///\n/// # Examples\n///\n/// ```no_run\n/// # use clap::{App, Arg, SubCommand};\n/// let app_m = App::new(\"myprog\")\n///     .subcommand(SubCommand::with_name(\"test\"))\n///     .get_matches();\n///\n/// println!(\"{}\", app_m.usage());\n/// ```\n/// [`Subcommand`]: ./struct.SubCommand.html\n/// [`App`]: ./struct.App.html\npub fn usage(&self) -> &str{\n        self.usage.as_ref().map_or(\"\", |u| &u[..])\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::value_of":["/// Gets the value of a specific [option] or [positional] argument (i.e. an argument that takes\n/// an additional value at runtime). If the option wasn't present at runtime\n/// it returns `None`.\n///\n/// *NOTE:* If getting a value for an option or positional argument that allows multiples,\n/// prefer [`ArgMatches::values_of`] as `ArgMatches::value_of` will only return the *first*\n/// value.\n///\n/// # Panics\n///\n/// This method will [`panic!`] if the value contains invalid UTF-8 code points.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myapp\")\n///     .arg(Arg::with_name(\"output\")\n///         .takes_value(true))\n///     .get_matches_from(vec![\"myapp\", \"something\"]);\n///\n/// assert_eq!(m.value_of(\"output\"), Some(\"something\"));\n/// ```\n/// [option]: ./struct.Arg.html#method.takes_value\n/// [positional]: ./struct.Arg.html#method.index\n/// [`ArgMatches::values_of`]: ./struct.ArgMatches.html#method.values_of\n/// [`panic!`]: https://doc.rust-lang.org/std/macro.panic!.html\npub fn value_of<S: AsRef<str>>(&self, name: S) -> Option<&str>{\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            if let Some(v) = arg.vals.get(0) {\n                return Some(v.to_str().expect(INVALID_UTF8));\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::value_of_lossy":["/// Gets the lossy value of a specific argument. If the argument wasn't present at runtime\n/// it returns `None`. A lossy value is one which contains invalid UTF-8 code points, those\n/// invalid points will be replaced with `\\u{FFFD}`\n///\n/// *NOTE:* If getting a value for an option or positional argument that allows multiples,\n/// prefer [`Arg::values_of_lossy`] as `value_of_lossy()` will only return the *first* value.\n///\n/// # Examples\n///\ndoc = \" ```\"\n/// # use clap::{App, Arg};\n/// use std::ffi::OsString;\n/// use std::os::unix::ffi::{OsStrExt,OsStringExt};\n///\n/// let m = App::new(\"utf8\")\n///     .arg(Arg::from_usage(\"<arg> 'some arg'\"))\n///     .get_matches_from(vec![OsString::from(\"myprog\"),\n///                             // \"Hi {0xe9}!\"\n///                             OsString::from_vec(vec![b'H', b'i', b' ', 0xe9, b'!'])]);\n/// assert_eq!(&*m.value_of_lossy(\"arg\").unwrap(), \"Hi \\u{FFFD}!\");\n/// ```\n/// [`Arg::values_of_lossy`]: ./struct.ArgMatches.html#method.values_of_lossy\npub fn value_of_lossy<S: AsRef<str>>(&'a self, name: S) -> Option<Cow<'a, str>>{\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            if let Some(v) = arg.vals.get(0) {\n                return Some(v.to_string_lossy());\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::value_of_os":["/// Gets the OS version of a string value of a specific argument. If the option wasn't present\n/// at runtime it returns `None`. An OS value on Unix-like systems is any series of bytes,\n/// regardless of whether or not they contain valid UTF-8 code points. Since [`String`]s in\n/// Rust are guaranteed to be valid UTF-8, a valid filename on a Unix system as an argument\n/// value may contain invalid UTF-8 code points.\n///\n/// *NOTE:* If getting a value for an option or positional argument that allows multiples,\n/// prefer [`ArgMatches::values_of_os`] as `Arg::value_of_os` will only return the *first*\n/// value.\n///\n/// # Examples\n///\ndoc = \" ```\"\n/// # use clap::{App, Arg};\n/// use std::ffi::OsString;\n/// use std::os::unix::ffi::{OsStrExt,OsStringExt};\n///\n/// let m = App::new(\"utf8\")\n///     .arg(Arg::from_usage(\"<arg> 'some arg'\"))\n///     .get_matches_from(vec![OsString::from(\"myprog\"),\n///                             // \"Hi {0xe9}!\"\n///                             OsString::from_vec(vec![b'H', b'i', b' ', 0xe9, b'!'])]);\n/// assert_eq!(&*m.value_of_os(\"arg\").unwrap().as_bytes(), [b'H', b'i', b' ', 0xe9, b'!']);\n/// ```\n/// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html\n/// [`ArgMatches::values_of_os`]: ./struct.ArgMatches.html#method.values_of_os\npub fn value_of_os<S: AsRef<str>>(&self, name: S) -> Option<&OsStr>{\n        self.args\n            .get(name.as_ref())\n            .and_then(|arg| arg.vals.get(0).map(|v| v.as_os_str()))\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::values_of":["/// Gets a [`Values`] struct which implements [`Iterator`] for values of a specific argument\n/// (i.e. an argument that takes multiple values at runtime). If the option wasn't present at\n/// runtime it returns `None`\n///\n/// # Panics\n///\n/// This method will panic if any of the values contain invalid UTF-8 code points.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"output\")\n///         .multiple(true)\n///         .short(\"o\")\n///         .takes_value(true))\n///     .get_matches_from(vec![\n///         \"myprog\", \"-o\", \"val1\", \"val2\", \"val3\"\n///     ]);\n/// let vals: Vec<&str> = m.values_of(\"output\").unwrap().collect();\n/// assert_eq!(vals, [\"val1\", \"val2\", \"val3\"]);\n/// ```\n/// [`Values`]: ./struct.Values.html\n/// [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\npub fn values_of<S: AsRef<str>>(&'a self, name: S) -> Option<Values<'a>>{\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            fn to_str_slice(o: &OsString) -> &str {\n                o.to_str().expect(INVALID_UTF8)\n            }\n            let to_str_slice: fn(&OsString) -> &str = to_str_slice; // coerce to fn pointer\n            return Some(Values {\n                iter: arg.vals.iter().map(to_str_slice),\n            });\n        }\n        None\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::values_of::to_str_slice":["fn to_str_slice(o: &OsString) -> &str{\n                o.to_str().expect(INVALID_UTF8)\n            }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::values_of_lossy":["/// Gets the lossy values of a specific argument. If the option wasn't present at runtime\n/// it returns `None`. A lossy value is one where if it contains invalid UTF-8 code points,\n/// those invalid points will be replaced with `\\u{FFFD}`\n///\n/// # Examples\n///\ndoc = \" ```\"\n/// # use clap::{App, Arg};\n/// use std::ffi::OsString;\n/// use std::os::unix::ffi::OsStringExt;\n///\n/// let m = App::new(\"utf8\")\n///     .arg(Arg::from_usage(\"<arg>... 'some arg'\"))\n///     .get_matches_from(vec![OsString::from(\"myprog\"),\n///                             // \"Hi\"\n///                             OsString::from_vec(vec![b'H', b'i']),\n///                             // \"{0xe9}!\"\n///                             OsString::from_vec(vec![0xe9, b'!'])]);\n/// let mut itr = m.values_of_lossy(\"arg\").unwrap().into_iter();\n/// assert_eq!(&itr.next().unwrap()[..], \"Hi\");\n/// assert_eq!(&itr.next().unwrap()[..], \"\\u{FFFD}!\");\n/// assert_eq!(itr.next(), None);\n/// ```\npub fn values_of_lossy<S: AsRef<str>>(&'a self, name: S) -> Option<Vec<String>>{\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            return Some(\n                arg.vals\n                    .iter()\n                    .map(|v| v.to_string_lossy().into_owned())\n                    .collect(),\n            );\n        }\n        None\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::values_of_os":["/// Gets a [`OsValues`] struct which is implements [`Iterator`] for [`OsString`] values of a\n/// specific argument. If the option wasn't present at runtime it returns `None`. An OS value\n/// on Unix-like systems is any series of bytes, regardless of whether or not they contain\n/// valid UTF-8 code points. Since [`String`]s in Rust are guaranteed to be valid UTF-8, a valid\n/// filename as an argument value on Linux (for example) may contain invalid UTF-8 code points.\n///\n/// # Examples\n///\ndoc = \" ```\"\n/// # use clap::{App, Arg};\n/// use std::ffi::{OsStr,OsString};\n/// use std::os::unix::ffi::{OsStrExt,OsStringExt};\n///\n/// let m = App::new(\"utf8\")\n///     .arg(Arg::from_usage(\"<arg>... 'some arg'\"))\n///     .get_matches_from(vec![OsString::from(\"myprog\"),\n///                                 // \"Hi\"\n///                                 OsString::from_vec(vec![b'H', b'i']),\n///                                 // \"{0xe9}!\"\n///                                 OsString::from_vec(vec![0xe9, b'!'])]);\n///\n/// let mut itr = m.values_of_os(\"arg\").unwrap().into_iter();\n/// assert_eq!(itr.next(), Some(OsStr::new(\"Hi\")));\n/// assert_eq!(itr.next(), Some(OsStr::from_bytes(&[0xe9, b'!'])));\n/// assert_eq!(itr.next(), None);\n/// ```\n/// [`OsValues`]: ./struct.OsValues.html\n/// [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n/// [`OsString`]: https://doc.rust-lang.org/std/ffi/struct.OsString.html\n/// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html\npub fn values_of_os<S: AsRef<str>>(&'a self, name: S) -> Option<OsValues<'a>>{\n        fn to_str_slice(o: &OsString) -> &OsStr {\n            &*o\n        }\n        let to_str_slice: fn(&'a OsString) -> &'a OsStr = to_str_slice; // coerce to fn pointer\n        if let Some(arg) = self.args.get(name.as_ref()) {\n            return Some(OsValues {\n                iter: arg.vals.iter().map(to_str_slice),\n            });\n        }\n        None\n    }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::ArgMatches::<'a>::values_of_os::to_str_slice":["fn to_str_slice(o: &OsString) -> &OsStr{\n            &*o\n        }","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::Indices":["/// An iterator for getting multiple indices out of an argument via the [`ArgMatches::indices_of`]\n/// method.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myapp\")\n///     .arg(Arg::with_name(\"output\")\n///         .short(\"o\")\n///         .multiple(true)\n///         .takes_value(true))\n///     .get_matches_from(vec![\"myapp\", \"-o\", \"val1\", \"val2\"]);\n///\n/// let mut indices = m.indices_of(\"output\").unwrap();\n///\n/// assert_eq!(indices.next(), Some(2));\n/// assert_eq!(indices.next(), Some(3));\n/// assert_eq!(indices.next(), None);\n/// ```\n/// [`ArgMatches::indices_of`]: ./struct.ArgMatches.html#method.indices_of\npub struct Indices<'a> {\n    // would rather use '_, but: https://github.com/rust-lang/rust/issues/48469\n    iter: Map<Iter<'a, usize>, fn(&'a usize) -> usize>,\n}","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::OsValues":["/// An iterator for getting multiple values out of an argument via the [`ArgMatches::values_of_os`]\n/// method. Usage of this iterator allows values which contain invalid UTF-8 code points unlike\n/// [`Values`].\n///\n/// # Examples\n///\ndoc = \" ```\"\n/// # use clap::{App, Arg};\n/// use std::ffi::OsString;\n/// use std::os::unix::ffi::{OsStrExt,OsStringExt};\n///\n/// let m = App::new(\"utf8\")\n///     .arg(Arg::from_usage(\"<arg> 'some arg'\"))\n///     .get_matches_from(vec![OsString::from(\"myprog\"),\n///                             // \"Hi {0xe9}!\"\n///                             OsString::from_vec(vec![b'H', b'i', b' ', 0xe9, b'!'])]);\n/// assert_eq!(&*m.value_of_os(\"arg\").unwrap().as_bytes(), [b'H', b'i', b' ', 0xe9, b'!']);\n/// ```\n/// [`ArgMatches::values_of_os`]: ./struct.ArgMatches.html#method.values_of_os\n/// [`Values`]: ./struct.Values.html\npub struct OsValues<'a> {\n    iter: Map<Iter<'a, OsString>, fn(&'a OsString) -> &'a OsStr>,\n}","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::arg_matches::Values":["/// An iterator for getting multiple values out of an argument via the [`ArgMatches::values_of`]\n/// method.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg};\n/// let m = App::new(\"myapp\")\n///     .arg(Arg::with_name(\"output\")\n///         .short(\"o\")\n///         .multiple(true)\n///         .takes_value(true))\n///     .get_matches_from(vec![\"myapp\", \"-o\", \"val1\", \"val2\"]);\n///\n/// let mut values = m.values_of(\"output\").unwrap();\n///\n/// assert_eq!(values.next(), Some(\"val1\"));\n/// assert_eq!(values.next(), Some(\"val2\"));\n/// assert_eq!(values.next(), None);\n/// ```\n/// [`ArgMatches::values_of`]: ./struct.ArgMatches.html#method.values_of\npub struct Values<'a> {\n    iter: Map<Iter<'a, OsString>, fn(&'a OsString) -> &'a str>,\n}","Real(LocalPath(\"src/args/arg_matches.rs\"))"],"args::group::ArgGroup":["/// `ArgGroup`s are a family of related [arguments] and way for you to express, \"Any of these\n/// arguments\". By placing arguments in a logical group, you can create easier requirement and\n/// exclusion rules instead of having to list each argument individually, or when you want a rule\n/// to apply \"any but not all\" arguments.\n///\n/// For instance, you can make an entire `ArgGroup` required. If [`ArgGroup::multiple(true)`] is\n/// set, this means that at least one argument from that group must be present. If\n/// [`ArgGroup::multiple(false)`] is set (the default), one and *only* one must be present.\n///\n/// You can also do things such as name an entire `ArgGroup` as a [conflict] or [requirement] for\n/// another argument, meaning any of the arguments that belong to that group will cause a failure\n/// if present, or must present respectively.\n///\n/// Perhaps the most common use of `ArgGroup`s is to require one and *only* one argument to be\n/// present out of a given set. Imagine that you had multiple arguments, and you want one of them\n/// to be required, but making all of them required isn't feasible because perhaps they conflict\n/// with each other. For example, lets say that you were building an application where one could\n/// set a given version number by supplying a string with an option argument, i.e.\n/// `--set-ver v1.2.3`, you also wanted to support automatically using a previous version number\n/// and simply incrementing one of the three numbers. So you create three flags `--major`,\n/// `--minor`, and `--patch`. All of these arguments shouldn't be used at one time but you want to\n/// specify that *at least one* of them is used. For this, you can create a group.\n///\n/// Finally, you may use `ArgGroup`s to pull a value from a group of arguments when you don't care\n/// exactly which argument was actually used at runtime.\n///\n/// # Examples\n///\n/// The following example demonstrates using an `ArgGroup` to ensure that one, and only one, of\n/// the arguments from the specified group is present at runtime.\n///\n/// ```rust\n/// # use clap::{App, ArgGroup, ErrorKind};\n/// let result = App::new(\"app\")\n///     .args_from_usage(\n///         \"--set-ver [ver] 'set the version manually'\n///          --major         'auto increase major'\n///          --minor         'auto increase minor'\n///          --patch         'auto increase patch'\")\n///     .group(ArgGroup::with_name(\"vers\")\n///          .args(&[\"set-ver\", \"major\", \"minor\", \"patch\"])\n///          .required(true))\n///     .get_matches_from_safe(vec![\"app\", \"--major\", \"--patch\"]);\n/// // Because we used two args in the group it's an error\n/// assert!(result.is_err());\n/// let err = result.unwrap_err();\n/// assert_eq!(err.kind, ErrorKind::ArgumentConflict);\n/// ```\n/// This next example shows a passing parse of the same scenario\n///\n/// ```rust\n/// # use clap::{App, ArgGroup};\n/// let result = App::new(\"app\")\n///     .args_from_usage(\n///         \"--set-ver [ver] 'set the version manually'\n///          --major         'auto increase major'\n///          --minor         'auto increase minor'\n///          --patch         'auto increase patch'\")\n///     .group(ArgGroup::with_name(\"vers\")\n///          .args(&[\"set-ver\", \"major\", \"minor\",\"patch\"])\n///          .required(true))\n///     .get_matches_from_safe(vec![\"app\", \"--major\"]);\n/// assert!(result.is_ok());\n/// let matches = result.unwrap();\n/// // We may not know which of the args was used, so we can test for the group...\n/// assert!(matches.is_present(\"vers\"));\n/// // we could also alternatively check each arg individually (not shown here)\n/// ```\n/// [`ArgGroup::multiple(true)`]: ./struct.ArgGroup.html#method.multiple\n/// [arguments]: ./struct.Arg.html\n/// [conflict]: ./struct.Arg.html#method.conflicts_with\n/// [requirement]: ./struct.Arg.html#method.requires\npub struct ArgGroup<'a> {\n    #[doc(hidden)]\n    pub name: &'a str,\n    #[doc(hidden)]\n    pub args: Vec<&'a str>,\n    #[doc(hidden)]\n    pub required: bool,\n    #[doc(hidden)]\n    pub requires: Option<Vec<&'a str>>,\n    #[doc(hidden)]\n    pub conflicts: Option<Vec<&'a str>>,\n    #[doc(hidden)]\n    pub multiple: bool,\n}","Real(LocalPath(\"src/args/group.rs\"))"],"args::group::ArgGroup::<'a>::arg":["/// Adds an [argument] to this group by name\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, ArgGroup};\n/// let m = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"color\")\n///         .short(\"c\"))\n///     .group(ArgGroup::with_name(\"req_flags\")\n///         .arg(\"flag\")\n///         .arg(\"color\"))\n///     .get_matches_from(vec![\"myprog\", \"-f\"]);\n/// // maybe we don't know which of the two flags was used...\n/// assert!(m.is_present(\"req_flags\"));\n/// // but we can also check individually if needed\n/// assert!(m.is_present(\"flag\"));\n/// ```\n/// [argument]: ./struct.Arg.html\npub fn arg(mut self, n: &'a str) -> Self{\n        assert!(\n            self.name != n,\n            \"ArgGroup '{}' can not have same name as arg inside it\",\n            &*self.name\n        );\n        self.args.push(n);\n        self\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"args::group::ArgGroup::<'a>::args":["/// Adds multiple [arguments] to this group by name\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, ArgGroup};\n/// let m = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"color\")\n///         .short(\"c\"))\n///     .group(ArgGroup::with_name(\"req_flags\")\n///         .args(&[\"flag\", \"color\"]))\n///     .get_matches_from(vec![\"myprog\", \"-f\"]);\n/// // maybe we don't know which of the two flags was used...\n/// assert!(m.is_present(\"req_flags\"));\n/// // but we can also check individually if needed\n/// assert!(m.is_present(\"flag\"));\n/// ```\n/// [arguments]: ./struct.Arg.html\npub fn args(mut self, ns: &[&'a str]) -> Self{\n        for n in ns {\n            self = self.arg(n);\n        }\n        self\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"args::group::ArgGroup::<'a>::conflicts_with":["/// Sets the exclusion rules of this group. Exclusion (aka conflict) rules function just like\n/// [argument exclusion rules], you can name other arguments or groups that must *not* be\n/// present when one of the arguments from this group are used.\n///\n/// **NOTE:** The name provided may be an argument, or group name\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, ArgGroup, ErrorKind};\n/// let result = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"color\")\n///         .short(\"c\"))\n///     .arg(Arg::with_name(\"debug\")\n///         .short(\"d\"))\n///     .group(ArgGroup::with_name(\"req_flags\")\n///         .args(&[\"flag\", \"color\"])\n///         .conflicts_with(\"debug\"))\n///     .get_matches_from_safe(vec![\"myprog\", \"-c\", \"-d\"]);\n/// // because we used an arg from the group, and the group conflicts with \"-d\", it's an error\n/// assert!(result.is_err());\n/// let err = result.unwrap_err();\n/// assert_eq!(err.kind, ErrorKind::ArgumentConflict);\n/// ```\n/// [argument exclusion rules]: ./struct.Arg.html#method.conflicts_with\npub fn conflicts_with(mut self, n: &'a str) -> Self{\n        if let Some(ref mut confs) = self.conflicts {\n            confs.push(n);\n        } else {\n            self.conflicts = Some(vec![n]);\n        }\n        self\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"args::group::ArgGroup::<'a>::conflicts_with_all":["/// Sets the exclusion rules of this group. Exclusion rules function just like\n/// [argument exclusion rules], you can name other arguments or groups that must *not* be\n/// present when one of the arguments from this group are used.\n///\n/// **NOTE:** The names provided may be an argument, or group name\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, ArgGroup, ErrorKind};\n/// let result = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"color\")\n///         .short(\"c\"))\n///     .arg(Arg::with_name(\"debug\")\n///         .short(\"d\"))\n///     .arg(Arg::with_name(\"verb\")\n///         .short(\"v\"))\n///     .group(ArgGroup::with_name(\"req_flags\")\n///         .args(&[\"flag\", \"color\"])\n///         .conflicts_with_all(&[\"debug\", \"verb\"]))\n///     .get_matches_from_safe(vec![\"myprog\", \"-c\", \"-v\"]);\n/// // because we used an arg from the group, and the group conflicts with either \"-v\" or \"-d\"\n/// // it's an error\n/// assert!(result.is_err());\n/// let err = result.unwrap_err();\n/// assert_eq!(err.kind, ErrorKind::ArgumentConflict);\n/// ```\n/// [argument exclusion rules]: ./struct.Arg.html#method.conflicts_with_all\npub fn conflicts_with_all(mut self, ns: &[&'a str]) -> Self{\n        for n in ns {\n            self = self.conflicts_with(n);\n        }\n        self\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"args::group::ArgGroup::<'a>::multiple":["/// Allows more than one of the ['Arg']s in this group to be used. (Default: `false`)\n///\n/// # Examples\n///\n/// Notice in this example we use *both* the `-f` and `-c` flags which are both part of the\n/// group\n///\n/// ```rust\n/// # use clap::{App, Arg, ArgGroup};\n/// let m = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"color\")\n///         .short(\"c\"))\n///     .group(ArgGroup::with_name(\"req_flags\")\n///         .args(&[\"flag\", \"color\"])\n///         .multiple(true))\n///     .get_matches_from(vec![\"myprog\", \"-f\", \"-c\"]);\n/// // maybe we don't know which of the two flags was used...\n/// assert!(m.is_present(\"req_flags\"));\n/// ```\n/// In this next example, we show the default behavior (i.e. `multiple(false)) which will throw\n/// an error if more than one of the args in the group was used.\n///\n/// ```rust\n/// # use clap::{App, Arg, ArgGroup, ErrorKind};\n/// let result = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"color\")\n///         .short(\"c\"))\n///     .group(ArgGroup::with_name(\"req_flags\")\n///         .args(&[\"flag\", \"color\"]))\n///     .get_matches_from_safe(vec![\"myprog\", \"-f\", \"-c\"]);\n/// // Because we used both args in the group it's an error\n/// assert!(result.is_err());\n/// let err = result.unwrap_err();\n/// assert_eq!(err.kind, ErrorKind::ArgumentConflict);\n/// ```\n/// ['Arg']: ./struct.Arg.html\npub fn multiple(mut self, m: bool) -> Self{\n        self.multiple = m;\n        self\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"args::group::ArgGroup::<'a>::required":["/// Sets the group as required or not. A required group will be displayed in the usage string\n/// of the application in the format `<arg|arg2|arg3>`. A required `ArgGroup` simply states\n/// that one argument from this group *must* be present at runtime (unless\n/// conflicting with another argument).\n///\n/// **NOTE:** This setting only applies to the current [`App`] / [`SubCommand`], and not\n/// globally.\n///\n/// **NOTE:** By default, [`ArgGroup::multiple`] is set to `false` which when combined with\n/// `ArgGroup::required(true)` states, \"One and *only one* arg must be used from this group.\n/// Use of more than one arg is an error.\" Vice setting `ArgGroup::multiple(true)` which\n/// states, '*At least* one arg from this group must be used. Using multiple is OK.\"\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, ArgGroup, ErrorKind};\n/// let result = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"color\")\n///         .short(\"c\"))\n///     .group(ArgGroup::with_name(\"req_flags\")\n///         .args(&[\"flag\", \"color\"])\n///         .required(true))\n///     .get_matches_from_safe(vec![\"myprog\"]);\n/// // Because we didn't use any of the args in the group, it's an error\n/// assert!(result.is_err());\n/// let err = result.unwrap_err();\n/// assert_eq!(err.kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [`App`]: ./struct.App.html\n/// [`SubCommand`]: ./struct.SubCommand.html\n/// [`ArgGroup::multiple`]: ./struct.ArgGroup.html#method.multiple\npub fn required(mut self, r: bool) -> Self{\n        self.required = r;\n        self\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"args::group::ArgGroup::<'a>::requires":["/// Sets the requirement rules of this group. This is not to be confused with a\n/// [required group]. Requirement rules function just like [argument requirement rules], you\n/// can name other arguments or groups that must be present when any one of the arguments from\n/// this group is used.\n///\n/// **NOTE:** The name provided may be an argument, or group name\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, ArgGroup, ErrorKind};\n/// let result = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"color\")\n///         .short(\"c\"))\n///     .arg(Arg::with_name(\"debug\")\n///         .short(\"d\"))\n///     .group(ArgGroup::with_name(\"req_flags\")\n///         .args(&[\"flag\", \"color\"])\n///         .requires(\"debug\"))\n///     .get_matches_from_safe(vec![\"myprog\", \"-c\"]);\n/// // because we used an arg from the group, and the group requires \"-d\" to be used, it's an\n/// // error\n/// assert!(result.is_err());\n/// let err = result.unwrap_err();\n/// assert_eq!(err.kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [required group]: ./struct.ArgGroup.html#method.required\n/// [argument requirement rules]: ./struct.Arg.html#method.requires\npub fn requires(mut self, n: &'a str) -> Self{\n        if let Some(ref mut reqs) = self.requires {\n            reqs.push(n);\n        } else {\n            self.requires = Some(vec![n]);\n        }\n        self\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"args::group::ArgGroup::<'a>::requires_all":["/// Sets the requirement rules of this group. This is not to be confused with a\n/// [required group]. Requirement rules function just like [argument requirement rules], you\n/// can name other arguments or groups that must be present when one of the arguments from this\n/// group is used.\n///\n/// **NOTE:** The names provided may be an argument, or group name\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, ArgGroup, ErrorKind};\n/// let result = App::new(\"myprog\")\n///     .arg(Arg::with_name(\"flag\")\n///         .short(\"f\"))\n///     .arg(Arg::with_name(\"color\")\n///         .short(\"c\"))\n///     .arg(Arg::with_name(\"debug\")\n///         .short(\"d\"))\n///     .arg(Arg::with_name(\"verb\")\n///         .short(\"v\"))\n///     .group(ArgGroup::with_name(\"req_flags\")\n///         .args(&[\"flag\", \"color\"])\n///         .requires_all(&[\"debug\", \"verb\"]))\n///     .get_matches_from_safe(vec![\"myprog\", \"-c\", \"-d\"]);\n/// // because we used an arg from the group, and the group requires \"-d\" and \"-v\" to be used,\n/// // yet we only used \"-d\" it's an error\n/// assert!(result.is_err());\n/// let err = result.unwrap_err();\n/// assert_eq!(err.kind, ErrorKind::MissingRequiredArgument);\n/// ```\n/// [required group]: ./struct.ArgGroup.html#method.required\n/// [argument requirement rules]: ./struct.Arg.html#method.requires_all\npub fn requires_all(mut self, ns: &[&'a str]) -> Self{\n        for n in ns {\n            self = self.requires(n);\n        }\n        self\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"args::group::ArgGroup::<'a>::with_name":["/// Creates a new instance of `ArgGroup` using a unique string name. The name will be used to\n/// get values from the group or refer to the group inside of conflict and requirement rules.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, ArgGroup};\n/// ArgGroup::with_name(\"config\")\n/// # ;\n/// ```\npub fn with_name(n: &'a str) -> Self{\n        ArgGroup {\n            name: n,\n            required: false,\n            args: vec![],\n            requires: None,\n            conflicts: None,\n            multiple: false,\n        }\n    }","Real(LocalPath(\"src/args/group.rs\"))"],"args::matched_arg::MatchedArg":["#[doc(hidden)]\npub struct MatchedArg {\n    #[doc(hidden)]\n    pub occurs: u64,\n    #[doc(hidden)]\n    pub indices: Vec<usize>,\n    #[doc(hidden)]\n    pub vals: Vec<OsString>,\n}","Real(LocalPath(\"src/args/matched_arg.rs\"))"],"args::matched_arg::MatchedArg::new":["pub fn new() -> Self{\n        MatchedArg::default()\n    }","Real(LocalPath(\"src/args/matched_arg.rs\"))"],"args::settings::ArgFlags":["#[doc(hidden)]\npub struct ArgFlags(Flags);","Real(LocalPath(\"src/args/settings.rs\"))"],"args::settings::ArgFlags::is_set":["pub fn is_set(&self, s: $n) -> bool{\n            match s {\n                $($n::$v => self.0.contains($c)),+\n            }\n        }","Real(LocalPath(\"src/macros.rs\"))"],"args::settings::ArgFlags::new":["pub fn new() -> Self{\n        ArgFlags::default()\n    }","Real(LocalPath(\"src/args/settings.rs\"))"],"args::settings::ArgFlags::set":["pub fn set(&mut self, s: $n){\n            match s {\n                $($n::$v => self.0.insert($c)),+\n            }\n        }","Real(LocalPath(\"src/macros.rs\"))"],"args::settings::ArgFlags::unset":["pub fn unset(&mut self, s: $n){\n            match s {\n                $($n::$v => self.0.remove($c)),+\n            }\n        }","Real(LocalPath(\"src/macros.rs\"))"],"args::settings::ArgSettings":["/// Various settings that apply to arguments and may be set, unset, and checked via getter/setter\n/// methods [`Arg::set`], [`Arg::unset`], and [`Arg::is_set`]\n///\n/// [`Arg::set`]: ./struct.Arg.html#method.set\n/// [`Arg::unset`]: ./struct.Arg.html#method.unset\n/// [`Arg::is_set`]: ./struct.Arg.html#method.is_set\npub enum ArgSettings {\n    /// The argument must be used\n    Required,\n    /// The argument may be used multiple times such as `--flag --flag`\n    Multiple,\n    /// The argument allows empty values such as `--option \"\"`\n    EmptyValues,\n    /// The argument should be propagated down through all child [`SubCommand`]s\n    ///\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    Global,\n    /// The argument should **not** be shown in help text\n    Hidden,\n    /// The argument accepts a value, such as `--option <value>`\n    TakesValue,\n    /// Determines if the argument allows values to be grouped via a delimiter\n    UseValueDelimiter,\n    /// Prints the help text on the line after the argument\n    NextLineHelp,\n    /// Requires the use of a value delimiter for all multiple values\n    RequireDelimiter,\n    /// Hides the possible values from the help string\n    HidePossibleValues,\n    /// Allows vals that start with a '-'\n    AllowLeadingHyphen,\n    /// Require options use `--option=val` syntax\n    RequireEquals,\n    /// Specifies that the arg is the last positional argument and may be accessed early via `--`\n    /// syntax\n    Last,\n    /// Hides the default value from the help string\n    HideDefaultValue,\n    /// Makes `Arg::possible_values` case insensitive\n    CaseInsensitive,\n    /// Hides ENV values in the help message\n    HideEnvValues,\n    /// The argument should **not** be shown in short help text\n    HiddenShortHelp,\n    /// The argument should **not** be shown in long help text\n    HiddenLongHelp,\n    #[doc(hidden)]\n    RequiredUnlessAll,\n    #[doc(hidden)]\n    ValueDelimiterNotSet,\n}","Real(LocalPath(\"src/args/settings.rs\"))"],"args::settings::Flags":["$vis struct $BitFlags {\n            bits: $T,\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::all":["/// Returns the set containing all flags.\n#[inline]\npub const fn all() -> Self{\n                __impl_all_bitflags! {\n                    $BitFlags: $T {\n                        $(\n                            $(#[$attr $($args)*])*\n                            $Flag = $value;\n                        )*\n                    }\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::all::__BitFlags":["#[allow(non_snake_case)]\ntrait __BitFlags {\n            $(\n                const $Flag: $T = 0;\n            )+\n        }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::bits":["/// Returns the raw value of the flags currently stored.\n#[inline]\npub const fn bits(&self) -> $T{\n                self.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::complement":["/// Returns the complement of this set of flags.\n///\n/// Specifically, the returned set contains all the flags which are\n/// not set in `self`, but which are allowed for this type.\n///\n/// Alternatively, it can be thought of as the set difference\n/// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n///\n/// This is equivalent to using the `!` operator (e.g.\n/// [`ops::Not`]), as in `!flags`.\n///\n/// [`Self::all()`]: Self::all\n/// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n#[inline]\n#[must_use]\npub const fn complement(self) -> Self{\n                Self::from_bits_truncate(!self.bits)\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::contains":["/// Returns `true` if all of the flags in `other` are contained within `self`.\n#[inline]\npub const fn contains(&self, other: Self) -> bool{\n                (self.bits & other.bits) == other.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::difference":["/// Returns the difference between the flags in `self` and `other`.\n///\n/// Specifically, the returned set contains all flags present in\n/// `self`, except for the ones present in `other`.\n///\n/// It is also conceptually equivalent to the \"bit-clear\" operation:\n/// `flags & !other` (and this syntax is also supported).\n///\n/// This is equivalent to using the `-` operator (e.g.\n/// [`ops::Sub`]), as in `flags - other`.\n///\n/// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n#[inline]\n#[must_use]\npub const fn difference(self, other: Self) -> Self{\n                Self { bits: self.bits & !other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::empty":["/// Returns an empty set of flags.\n#[inline]\npub const fn empty() -> Self{\n                Self { bits: 0 }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::from_bits":["/// Convert from underlying bit representation, unless that\n/// representation contains bits that do not correspond to a flag.\n#[inline]\npub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self>{\n                if (bits & !Self::all().bits()) == 0 {\n                    $crate::_core::option::Option::Some(Self { bits })\n                } else {\n                    $crate::_core::option::Option::None\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::from_bits_truncate":["/// Convert from underlying bit representation, dropping any bits\n/// that do not correspond to flags.\n#[inline]\npub const fn from_bits_truncate(bits: $T) -> Self{\n                Self { bits: bits & Self::all().bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::from_bits_unchecked":["/// Convert from underlying bit representation, preserving all\n/// bits (even those not corresponding to a defined flag).\n///\n/// # Safety\n///\n/// The caller of the `bitflags!` macro can chose to allow or\n/// disallow extra bits for their bitflags type.\n///\n/// The caller of `from_bits_unchecked()` has to ensure that\n/// all bits correspond to a defined flag or that extra bits\n/// are valid for this bitflags type.\n#[inline]\npub const unsafe fn from_bits_unchecked(bits: $T) -> Self{\n                Self { bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::insert":["/// Inserts the specified flags in-place.\n#[inline]\npub fn insert(&mut self, other: Self){\n                self.bits |= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::intersection":["/// Returns the intersection between the flags in `self` and\n/// `other`.\n///\n/// Specifically, the returned set contains only the flags which are\n/// present in *both* `self` *and* `other`.\n///\n/// This is equivalent to using the `&` operator (e.g.\n/// [`ops::BitAnd`]), as in `flags & other`.\n///\n/// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n#[inline]\n#[must_use]\npub const fn intersection(self, other: Self) -> Self{\n                Self { bits: self.bits & other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::intersects":["/// Returns `true` if there are flags common to both `self` and `other`.\n#[inline]\npub const fn intersects(&self, other: Self) -> bool{\n                !(Self { bits: self.bits & other.bits}).is_empty()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::is_all":["/// Returns `true` if all flags are currently set.\n#[inline]\npub const fn is_all(&self) -> bool{\n                Self::all().bits | self.bits == self.bits\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::is_empty":["/// Returns `true` if no flags are currently stored.\n#[inline]\npub const fn is_empty(&self) -> bool{\n                self.bits() == Self::empty().bits()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::remove":["/// Removes the specified flags in-place.\n#[inline]\npub fn remove(&mut self, other: Self){\n                self.bits &= !other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::set":["/// Inserts or removes the specified flags depending on the passed value.\n#[inline]\npub fn set(&mut self, other: Self, value: bool){\n                if value {\n                    self.insert(other);\n                } else {\n                    self.remove(other);\n                }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::symmetric_difference":["/// Returns the [symmetric difference][sym-diff] between the flags\n/// in `self` and `other`.\n///\n/// Specifically, the returned set contains the flags present which\n/// are present in `self` or `other`, but that are not present in\n/// both. Equivalently, it contains the flags present in *exactly\n/// one* of the sets `self` and `other`.\n///\n/// This is equivalent to using the `^` operator (e.g.\n/// [`ops::BitXor`]), as in `flags ^ other`.\n///\n/// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n/// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n#[inline]\n#[must_use]\npub const fn symmetric_difference(self, other: Self) -> Self{\n                Self { bits: self.bits ^ other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::toggle":["/// Toggles the specified flags in-place.\n#[inline]\npub fn toggle(&mut self, other: Self){\n                self.bits ^= other.bits;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::settings::Flags::union":["/// Returns the union of between the flags in `self` and `other`.\n///\n/// Specifically, the returned set contains all flags which are\n/// present in *either* `self` *or* `other`, including any which are\n/// present in both (see [`Self::symmetric_difference`] if that\n/// is undesirable).\n///\n/// This is equivalent to using the `|` operator (e.g.\n/// [`ops::BitOr`]), as in `flags | other`.\n///\n/// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n#[inline]\n#[must_use]\npub const fn union(self, other: Self) -> Self{\n                Self { bits: self.bits | other.bits }\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))"],"args::subcommand::SubCommand":["/// The abstract representation of a command line subcommand.\n///\n/// This struct describes all the valid options of the subcommand for the program. Subcommands are\n/// essentially \"sub-[`App`]s\" and contain all the same possibilities (such as their own\n/// [arguments], subcommands, and settings).\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, SubCommand};\n/// App::new(\"myprog\")\n///     .subcommand(\n///         SubCommand::with_name(\"config\")\n///             .about(\"Used for configuration\")\n///             .arg(Arg::with_name(\"config_file\")\n///                 .help(\"The configuration file to use\")\n///                 .index(1)))\n/// # ;\n/// ```\n/// [`App`]: ./struct.App.html\n/// [arguments]: ./struct.Arg.html\npub struct SubCommand<'a> {\n    #[doc(hidden)]\n    pub name: String,\n    #[doc(hidden)]\n    pub matches: ArgMatches<'a>,\n}","Real(LocalPath(\"src/args/subcommand.rs\"))"],"args::subcommand::SubCommand::<'a>::with_name":["/// Creates a new instance of a subcommand requiring a name. The name will be displayed\n/// to the user when they print version or help and usage information.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap::{App, Arg, SubCommand};\n/// App::new(\"myprog\")\n///     .subcommand(\n///         SubCommand::with_name(\"config\"))\n/// # ;\n/// ```\npub fn with_name<'b>(name: &str) -> App<'a, 'b>{\n        App::new(name)\n    }","Real(LocalPath(\"src/args/subcommand.rs\"))"],"completions::ComplGen":["pub struct ComplGen<'a, 'b>\nwhere\n    'a: 'b,\n{\n    p: &'b Parser<'a, 'b>,\n}","Real(LocalPath(\"src/completions/mod.rs\"))"],"completions::ComplGen::<'a, 'b>::generate":["pub fn generate<W: Write>(&self, for_shell: Shell, buf: &mut W){\n        match for_shell {\n            Shell::Bash => BashGen::new(self.p).generate_to(buf),\n            Shell::Fish => FishGen::new(self.p).generate_to(buf),\n            Shell::Zsh => ZshGen::new(self.p).generate_to(buf),\n            Shell::PowerShell => PowerShellGen::new(self.p).generate_to(buf),\n            Shell::Elvish => ElvishGen::new(self.p).generate_to(buf),\n        }\n    }","Real(LocalPath(\"src/completions/mod.rs\"))"],"completions::ComplGen::<'a, 'b>::new":["pub fn new(p: &'b Parser<'a, 'b>) -> Self{\n        ComplGen { p: p }\n    }","Real(LocalPath(\"src/completions/mod.rs\"))"],"completions::all_subcommand_names":["pub fn all_subcommand_names(p: &Parser) -> Vec<String>{\n    debugln!(\"all_subcommand_names;\");\n    let mut subcmds: Vec<_> = subcommands_of(p)\n        .iter()\n        .map(|&(ref n, _)| n.clone())\n        .collect();\n    for sc_v in p.subcommands.iter().map(|s| all_subcommand_names(&s.p)) {\n        subcmds.extend(sc_v);\n    }\n    subcmds.sort();\n    subcmds.dedup();\n    subcmds\n}","Real(LocalPath(\"src/completions/mod.rs\"))"],"completions::all_subcommands":["pub fn all_subcommands(p: &Parser) -> Vec<(String, String)>{\n    debugln!(\"all_subcommands;\");\n    let mut subcmds: Vec<_> = subcommands_of(p);\n    for sc_v in p.subcommands.iter().map(|s| all_subcommands(&s.p)) {\n        subcmds.extend(sc_v);\n    }\n    subcmds\n}","Real(LocalPath(\"src/completions/mod.rs\"))"],"completions::bash::BashGen":["pub struct BashGen<'a, 'b>\nwhere\n    'a: 'b,\n{\n    p: &'b Parser<'a, 'b>,\n}","Real(LocalPath(\"src/completions/bash.rs\"))"],"completions::bash::BashGen::<'a, 'b>::all_options_for_path":["fn all_options_for_path(&self, path: &str) -> String{\n        debugln!(\"BashGen::all_options_for_path: path={}\", path);\n        let mut p = self.p;\n        for sc in path.split(\"__\").skip(1) {\n            debugln!(\"BashGen::all_options_for_path:iter: sc={}\", sc);\n            p = &find_subcmd!(p, sc).unwrap().p;\n        }\n        let mut opts = shorts!(p).fold(String::new(), |acc, s| format!(\"{} -{}\", acc, s));\n        opts = format!(\n            \"{} {}\",\n            opts,\n            longs!(p).fold(String::new(), |acc, l| format!(\"{} --{}\", acc, l))\n        );\n        opts = format!(\n            \"{} {}\",\n            opts,\n            p.positionals\n                .values()\n                .fold(String::new(), |acc, p| format!(\"{} {}\", acc, p))\n        );\n        opts = format!(\n            \"{} {}\",\n            opts,\n            p.subcommands\n                .iter()\n                .fold(String::new(), |acc, s| format!(\"{} {}\", acc, s.p.meta.name))\n        );\n        for sc in &p.subcommands {\n            if let Some(ref aliases) = sc.p.meta.aliases {\n                opts = format!(\n                    \"{} {}\",\n                    opts,\n                    aliases\n                        .iter()\n                        .map(|&(n, _)| n)\n                        .fold(String::new(), |acc, a| format!(\"{} {}\", acc, a))\n                );\n            }\n        }\n        opts\n    }","Real(LocalPath(\"src/completions/bash.rs\"))"],"completions::bash::BashGen::<'a, 'b>::all_subcommands":["fn all_subcommands(&self) -> String{\n        debugln!(\"BashGen::all_subcommands;\");\n        let mut subcmds = String::new();\n        let scs = completions::all_subcommand_names(self.p);\n\n        for sc in &scs {\n            subcmds = format!(\n                r#\"{}\n            {name})\n                cmd+=\"__{fn_name}\"\n                ;;\"#,\n                subcmds,\n                name = sc,\n                fn_name = sc.replace(\"-\", \"__\")\n            );\n        }\n\n        subcmds\n    }","Real(LocalPath(\"src/completions/bash.rs\"))"],"completions::bash::BashGen::<'a, 'b>::generate_to":["pub fn generate_to<W: Write>(&self, buf: &mut W){\n        w!(\n            buf,\n            format!(\n                r#\"_{name}() {{\n    local i cur prev opts cmds\n    COMPREPLY=()\n    cur=\"${{COMP_WORDS[COMP_CWORD]}}\"\n    prev=\"${{COMP_WORDS[COMP_CWORD-1]}}\"\n    cmd=\"\"\n    opts=\"\"\n\n    for i in ${{COMP_WORDS[@]}}\n    do\n        case \"${{i}}\" in\n            {name})\n                cmd=\"{name}\"\n                ;;\n            {subcmds}\n            *)\n                ;;\n        esac\n    done\n\n    case \"${{cmd}}\" in\n        {name})\n            opts=\"{name_opts}\"\n            if [[ ${{cur}} == -* || ${{COMP_CWORD}} -eq 1 ]] ; then\n                COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )\n                return 0\n            fi\n            case \"${{prev}}\" in\n                {name_opts_details}\n                *)\n                    COMPREPLY=()\n                    ;;\n            esac\n            COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )\n            return 0\n            ;;\n        {subcmd_details}\n    esac\n}}\n\ncomplete -F _{name} -o bashdefault -o default {name}\n\"#,\n                name = self.p.meta.bin_name.as_ref().unwrap(),\n                name_opts = self.all_options_for_path(self.p.meta.bin_name.as_ref().unwrap()),\n                name_opts_details =\n                    self.option_details_for_path(self.p.meta.bin_name.as_ref().unwrap()),\n                subcmds = self.all_subcommands(),\n                subcmd_details = self.subcommand_details()\n            )\n            .as_bytes()\n        );\n    }","Real(LocalPath(\"src/completions/bash.rs\"))"],"completions::bash::BashGen::<'a, 'b>::new":["pub fn new(p: &'b Parser<'a, 'b>) -> Self{\n        BashGen { p: p }\n    }","Real(LocalPath(\"src/completions/bash.rs\"))"],"completions::bash::BashGen::<'a, 'b>::option_details_for_path":["fn option_details_for_path(&self, path: &str) -> String{\n        debugln!(\"BashGen::option_details_for_path: path={}\", path);\n        let mut p = self.p;\n        for sc in path.split(\"__\").skip(1) {\n            debugln!(\"BashGen::option_details_for_path:iter: sc={}\", sc);\n            p = &find_subcmd!(p, sc).unwrap().p;\n        }\n        let mut opts = String::new();\n        for o in p.opts() {\n            if let Some(l) = o.s.long {\n                opts = format!(\n                    \"{}\n                --{})\n                    COMPREPLY=({})\n                    return 0\n                    ;;\",\n                    opts,\n                    l,\n                    self.vals_for(o)\n                );\n            }\n            if let Some(s) = o.s.short {\n                opts = format!(\n                    \"{}\n                    -{})\n                    COMPREPLY=({})\n                    return 0\n                    ;;\",\n                    opts,\n                    s,\n                    self.vals_for(o)\n                );\n            }\n        }\n        opts\n    }","Real(LocalPath(\"src/completions/bash.rs\"))"],"completions::bash::BashGen::<'a, 'b>::subcommand_details":["fn subcommand_details(&self) -> String{\n        debugln!(\"BashGen::subcommand_details;\");\n        let mut subcmd_dets = String::new();\n        let mut scs = completions::get_all_subcommand_paths(self.p, true);\n        scs.sort();\n        scs.dedup();\n\n        for sc in &scs {\n            subcmd_dets = format!(\n                r#\"{}\n        {subcmd})\n            opts=\"{sc_opts}\"\n            if [[ ${{cur}} == -* || ${{COMP_CWORD}} -eq {level} ]] ; then\n                COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )\n                return 0\n            fi\n            case \"${{prev}}\" in\n                {opts_details}\n                *)\n                    COMPREPLY=()\n                    ;;\n            esac\n            COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )\n            return 0\n            ;;\"#,\n                subcmd_dets,\n                subcmd = sc.replace(\"-\", \"__\"),\n                sc_opts = self.all_options_for_path(&*sc),\n                level = sc.split(\"__\").map(|_| 1).fold(0, |acc, n| acc + n),\n                opts_details = self.option_details_for_path(&*sc)\n            );\n        }\n\n        subcmd_dets\n    }","Real(LocalPath(\"src/completions/bash.rs\"))"],"completions::bash::BashGen::<'a, 'b>::vals_for":["fn vals_for(&self, o: &OptBuilder) -> String{\n        debugln!(\"BashGen::vals_for: o={}\", o.b.name);\n        use args::AnyArg;\n        if let Some(vals) = o.possible_vals() {\n            format!(r#\"$(compgen -W \"{}\" -- \"${{cur}}\")\"#, vals.join(\" \"))\n        } else {\n            String::from(r#\"$(compgen -f \"${cur}\")\"#)\n        }\n    }","Real(LocalPath(\"src/completions/bash.rs\"))"],"completions::elvish::ElvishGen":["pub struct ElvishGen<'a, 'b>\nwhere\n    'a: 'b,\n{\n    p: &'b Parser<'a, 'b>,\n}","Real(LocalPath(\"src/completions/elvish.rs\"))"],"completions::elvish::ElvishGen::<'a, 'b>::generate_to":["pub fn generate_to<W: Write>(&self, buf: &mut W){\n        let bin_name = self.p.meta.bin_name.as_ref().unwrap();\n\n        let mut names = vec![];\n        let subcommands_cases = generate_inner(self.p, \"\", &mut names);\n\n        let result = format!(\n            r#\"\nedit:completion:arg-completer[{bin_name}] = [@words]{{\n    fn spaces [n]{{\n        repeat $n ' ' | joins ''\n    }}\n    fn cand [text desc]{{\n        edit:complex-candidate $text &display-suffix=' '(spaces (- 14 (wcswidth $text)))$desc\n    }}\n    command = '{bin_name}'\n    for word $words[1:-1] {{\n        if (has-prefix $word '-') {{\n            break\n        }}\n        command = $command';'$word\n    }}\n    completions = [{subcommands_cases}\n    ]\n    $completions[$command]\n}}\n\"#,\n            bin_name = bin_name,\n            subcommands_cases = subcommands_cases\n        );\n\n        w!(buf, result.as_bytes());\n    }","Real(LocalPath(\"src/completions/elvish.rs\"))"],"completions::elvish::ElvishGen::<'a, 'b>::new":["pub fn new(p: &'b Parser<'a, 'b>) -> Self{\n        ElvishGen { p: p }\n    }","Real(LocalPath(\"src/completions/elvish.rs\"))"],"completions::elvish::escape_string":["fn escape_string(string: &str) -> String{\n    string.replace(\"'\", \"''\")\n}","Real(LocalPath(\"src/completions/elvish.rs\"))"],"completions::elvish::generate_inner":["fn generate_inner<'a, 'b, 'p>(\n    p: &'p Parser<'a, 'b>,\n    previous_command_name: &str,\n    names: &mut Vec<&'p str>,\n) -> String{\n    debugln!(\"ElvishGen::generate_inner;\");\n    let command_name = if previous_command_name.is_empty() {\n        p.meta.bin_name.as_ref().expect(INTERNAL_ERROR_MSG).clone()\n    } else {\n        format!(\"{};{}\", previous_command_name, &p.meta.name)\n    };\n\n    let mut completions = String::new();\n    let preamble = String::from(\"\\n            cand \");\n\n    for option in p.opts() {\n        if let Some(data) = option.s.short {\n            let tooltip = get_tooltip(option.b.help, data);\n            completions.push_str(&preamble);\n            completions.push_str(format!(\"-{} '{}'\", data, tooltip).as_str());\n        }\n        if let Some(data) = option.s.long {\n            let tooltip = get_tooltip(option.b.help, data);\n            completions.push_str(&preamble);\n            completions.push_str(format!(\"--{} '{}'\", data, tooltip).as_str());\n        }\n    }\n\n    for flag in p.flags() {\n        if let Some(data) = flag.s.short {\n            let tooltip = get_tooltip(flag.b.help, data);\n            completions.push_str(&preamble);\n            completions.push_str(format!(\"-{} '{}'\", data, tooltip).as_str());\n        }\n        if let Some(data) = flag.s.long {\n            let tooltip = get_tooltip(flag.b.help, data);\n            completions.push_str(&preamble);\n            completions.push_str(format!(\"--{} '{}'\", data, tooltip).as_str());\n        }\n    }\n\n    for subcommand in &p.subcommands {\n        let data = &subcommand.p.meta.name;\n        let tooltip = get_tooltip(subcommand.p.meta.about, data);\n        completions.push_str(&preamble);\n        completions.push_str(format!(\"{} '{}'\", data, tooltip).as_str());\n    }\n\n    let mut subcommands_cases = format!(\n        r\"\n        &'{}'= {{{}\n        }}\",\n        &command_name, completions\n    );\n\n    for subcommand in &p.subcommands {\n        let subcommand_subcommands_cases = generate_inner(&subcommand.p, &command_name, names);\n        subcommands_cases.push_str(&subcommand_subcommands_cases);\n    }\n\n    subcommands_cases\n}","Real(LocalPath(\"src/completions/elvish.rs\"))"],"completions::elvish::get_tooltip":["fn get_tooltip<T: ToString>(help: Option<&str>, data: T) -> String{\n    match help {\n        Some(help) => escape_string(help),\n        _ => data.to_string(),\n    }\n}","Real(LocalPath(\"src/completions/elvish.rs\"))"],"completions::fish::FishGen":["pub struct FishGen<'a, 'b>\nwhere\n    'a: 'b,\n{\n    p: &'b Parser<'a, 'b>,\n}","Real(LocalPath(\"src/completions/fish.rs\"))"],"completions::fish::FishGen::<'a, 'b>::generate_to":["pub fn generate_to<W: Write>(&self, buf: &mut W){\n        let command = self.p.meta.bin_name.as_ref().unwrap();\n        let mut buffer = String::new();\n        gen_fish_inner(command, self, command, &mut buffer);\n        w!(buf, buffer.as_bytes());\n    }","Real(LocalPath(\"src/completions/fish.rs\"))"],"completions::fish::FishGen::<'a, 'b>::new":["pub fn new(p: &'b Parser<'a, 'b>) -> Self{\n        FishGen { p: p }\n    }","Real(LocalPath(\"src/completions/fish.rs\"))"],"completions::fish::escape_string":["fn escape_string(string: &str) -> String{\n    string.replace(\"\\\\\", \"\\\\\\\\\").replace(\"'\", \"\\\\'\")\n}","Real(LocalPath(\"src/completions/fish.rs\"))"],"completions::fish::gen_fish_inner":["fn gen_fish_inner(root_command: &str, comp_gen: &FishGen, subcommand: &str, buffer: &mut String){\n    debugln!(\"FishGen::gen_fish_inner;\");\n    // example :\n    //\n    // complete\n    //      -c {command}\n    //      -d \"{description}\"\n    //      -s {short}\n    //      -l {long}\n    //      -a \"{possible_arguments}\"\n    //      -r # if require parameter\n    //      -f # don't use file completion\n    //      -n \"__fish_use_subcommand\"               # complete for command \"myprog\"\n    //      -n \"__fish_seen_subcommand_from subcmd1\" # complete for command \"myprog subcmd1\"\n\n    let mut basic_template = format!(\"complete -c {} -n \", root_command);\n    if root_command == subcommand {\n        basic_template.push_str(\"\\\"__fish_use_subcommand\\\"\");\n    } else {\n        basic_template.push_str(format!(\"\\\"__fish_seen_subcommand_from {}\\\"\", subcommand).as_str());\n    }\n\n    for option in comp_gen.p.opts() {\n        let mut template = basic_template.clone();\n        if let Some(data) = option.s.short {\n            template.push_str(format!(\" -s {}\", data).as_str());\n        }\n        if let Some(data) = option.s.long {\n            template.push_str(format!(\" -l {}\", data).as_str());\n        }\n        if let Some(data) = option.b.help {\n            template.push_str(format!(\" -d '{}'\", escape_string(data)).as_str());\n        }\n        if let Some(ref data) = option.v.possible_vals {\n            template.push_str(format!(\" -r -f -a \\\"{}\\\"\", data.join(\" \")).as_str());\n        }\n        buffer.push_str(template.as_str());\n        buffer.push_str(\"\\n\");\n    }\n\n    for flag in comp_gen.p.flags() {\n        let mut template = basic_template.clone();\n        if let Some(data) = flag.s.short {\n            template.push_str(format!(\" -s {}\", data).as_str());\n        }\n        if let Some(data) = flag.s.long {\n            template.push_str(format!(\" -l {}\", data).as_str());\n        }\n        if let Some(data) = flag.b.help {\n            template.push_str(format!(\" -d '{}'\", escape_string(data)).as_str());\n        }\n        buffer.push_str(template.as_str());\n        buffer.push_str(\"\\n\");\n    }\n\n    for subcommand in &comp_gen.p.subcommands {\n        let mut template = basic_template.clone();\n        template.push_str(\" -f\");\n        template.push_str(format!(\" -a \\\"{}\\\"\", &subcommand.p.meta.name).as_str());\n        if let Some(data) = subcommand.p.meta.about {\n            template.push_str(format!(\" -d '{}'\", escape_string(data)).as_str())\n        }\n        buffer.push_str(template.as_str());\n        buffer.push_str(\"\\n\");\n    }\n\n    // generate options of subcommands\n    for subcommand in &comp_gen.p.subcommands {\n        let sub_comp_gen = FishGen::new(&subcommand.p);\n        gen_fish_inner(root_command, &sub_comp_gen, &subcommand.to_string(), buffer);\n    }\n}","Real(LocalPath(\"src/completions/fish.rs\"))"],"completions::get_all_subcommand_paths":["pub fn get_all_subcommand_paths(p: &Parser, first: bool) -> Vec<String>{\n    debugln!(\"get_all_subcommand_paths;\");\n    let mut subcmds = vec![];\n    if !p.has_subcommands() {\n        if !first {\n            let name = &*p.meta.name;\n            let path = p.meta.bin_name.as_ref().unwrap().clone().replace(\" \", \"__\");\n            let mut ret = vec![path.clone()];\n            if let Some(ref aliases) = p.meta.aliases {\n                for &(n, _) in aliases {\n                    ret.push(path.replace(name, n));\n                }\n            }\n            return ret;\n        }\n        return vec![];\n    }\n    for sc in &p.subcommands {\n        let name = &*sc.p.meta.name;\n        let path =\n            sc.p.meta\n                .bin_name\n                .as_ref()\n                .unwrap()\n                .clone()\n                .replace(\" \", \"__\");\n        subcmds.push(path.clone());\n        if let Some(ref aliases) = sc.p.meta.aliases {\n            for &(n, _) in aliases {\n                subcmds.push(path.replace(name, n));\n            }\n        }\n    }\n    for sc_v in p\n        .subcommands\n        .iter()\n        .map(|s| get_all_subcommand_paths(&s.p, false))\n    {\n        subcmds.extend(sc_v);\n    }\n    subcmds\n}","Real(LocalPath(\"src/completions/mod.rs\"))"],"completions::powershell::PowerShellGen":["pub struct PowerShellGen<'a, 'b>\nwhere\n    'a: 'b,\n{\n    p: &'b Parser<'a, 'b>,\n}","Real(LocalPath(\"src/completions/powershell.rs\"))"],"completions::powershell::PowerShellGen::<'a, 'b>::generate_to":["pub fn generate_to<W: Write>(&self, buf: &mut W){\n        let bin_name = self.p.meta.bin_name.as_ref().unwrap();\n\n        let mut names = vec![];\n        let subcommands_cases = generate_inner(self.p, \"\", &mut names);\n\n        let result = format!(\n            r#\"\nusing namespace System.Management.Automation\nusing namespace System.Management.Automation.Language\n\nRegister-ArgumentCompleter -Native -CommandName '{bin_name}' -ScriptBlock {{\n    param($wordToComplete, $commandAst, $cursorPosition)\n\n    $commandElements = $commandAst.CommandElements\n    $command = @(\n        '{bin_name}'\n        for ($i = 1; $i -lt $commandElements.Count; $i++) {{\n            $element = $commandElements[$i]\n            if ($element -isnot [StringConstantExpressionAst] -or\n                $element.StringConstantType -ne [StringConstantType]::BareWord -or\n                $element.Value.StartsWith('-')) {{\n                break\n        }}\n        $element.Value\n    }}) -join ';'\n\n    $completions = @(switch ($command) {{{subcommands_cases}\n    }})\n\n    $completions.Where{{ $_.CompletionText -like \"$wordToComplete*\" }} |\n        Sort-Object -Property ListItemText\n}}\n\"#,\n            bin_name = bin_name,\n            subcommands_cases = subcommands_cases\n        );\n\n        w!(buf, result.as_bytes());\n    }","Real(LocalPath(\"src/completions/powershell.rs\"))"],"completions::powershell::PowerShellGen::<'a, 'b>::new":["pub fn new(p: &'b Parser<'a, 'b>) -> Self{\n        PowerShellGen { p: p }\n    }","Real(LocalPath(\"src/completions/powershell.rs\"))"],"completions::powershell::escape_string":["fn escape_string(string: &str) -> String{\n    string.replace(\"'\", \"''\")\n}","Real(LocalPath(\"src/completions/powershell.rs\"))"],"completions::powershell::generate_inner":["fn generate_inner<'a, 'b, 'p>(\n    p: &'p Parser<'a, 'b>,\n    previous_command_name: &str,\n    names: &mut Vec<&'p str>,\n) -> String{\n    debugln!(\"PowerShellGen::generate_inner;\");\n    let command_name = if previous_command_name.is_empty() {\n        p.meta.bin_name.as_ref().expect(INTERNAL_ERROR_MSG).clone()\n    } else {\n        format!(\"{};{}\", previous_command_name, &p.meta.name)\n    };\n\n    let mut completions = String::new();\n    let preamble = String::from(\"\\n            [CompletionResult]::new(\");\n\n    for option in p.opts() {\n        if let Some(data) = option.s.short {\n            let tooltip = get_tooltip(option.b.help, data);\n            completions.push_str(&preamble);\n            completions.push_str(\n                format!(\n                    \"'-{}', '{}', {}, '{}')\",\n                    data, data, \"[CompletionResultType]::ParameterName\", tooltip\n                )\n                .as_str(),\n            );\n        }\n        if let Some(data) = option.s.long {\n            let tooltip = get_tooltip(option.b.help, data);\n            completions.push_str(&preamble);\n            completions.push_str(\n                format!(\n                    \"'--{}', '{}', {}, '{}')\",\n                    data, data, \"[CompletionResultType]::ParameterName\", tooltip\n                )\n                .as_str(),\n            );\n        }\n    }\n\n    for flag in p.flags() {\n        if let Some(data) = flag.s.short {\n            let tooltip = get_tooltip(flag.b.help, data);\n            completions.push_str(&preamble);\n            completions.push_str(\n                format!(\n                    \"'-{}', '{}', {}, '{}')\",\n                    data, data, \"[CompletionResultType]::ParameterName\", tooltip\n                )\n                .as_str(),\n            );\n        }\n        if let Some(data) = flag.s.long {\n            let tooltip = get_tooltip(flag.b.help, data);\n            completions.push_str(&preamble);\n            completions.push_str(\n                format!(\n                    \"'--{}', '{}', {}, '{}')\",\n                    data, data, \"[CompletionResultType]::ParameterName\", tooltip\n                )\n                .as_str(),\n            );\n        }\n    }\n\n    for subcommand in &p.subcommands {\n        let data = &subcommand.p.meta.name;\n        let tooltip = get_tooltip(subcommand.p.meta.about, data);\n        completions.push_str(&preamble);\n        completions.push_str(\n            format!(\n                \"'{}', '{}', {}, '{}')\",\n                data, data, \"[CompletionResultType]::ParameterValue\", tooltip\n            )\n            .as_str(),\n        );\n    }\n\n    let mut subcommands_cases = format!(\n        r\"\n        '{}' {{{}\n            break\n        }}\",\n        &command_name, completions\n    );\n\n    for subcommand in &p.subcommands {\n        let subcommand_subcommands_cases = generate_inner(&subcommand.p, &command_name, names);\n        subcommands_cases.push_str(&subcommand_subcommands_cases);\n    }\n\n    subcommands_cases\n}","Real(LocalPath(\"src/completions/powershell.rs\"))"],"completions::powershell::get_tooltip":["fn get_tooltip<T: ToString>(help: Option<&str>, data: T) -> String{\n    match help {\n        Some(help) => escape_string(help),\n        _ => data.to_string(),\n    }\n}","Real(LocalPath(\"src/completions/powershell.rs\"))"],"completions::shell::Shell":["/// Describes which shell to produce a completions file for\npub enum Shell {\n    /// Generates a .bash completion file for the Bourne Again SHell (BASH)\n    Bash,\n    /// Generates a .fish completion file for the Friendly Interactive SHell (fish)\n    Fish,\n    /// Generates a completion file for the Z SHell (ZSH)\n    Zsh,\n    /// Generates a completion file for PowerShell\n    PowerShell,\n    /// Generates a completion file for Elvish\n    Elvish,\n}","Real(LocalPath(\"src/completions/shell.rs\"))"],"completions::shell::Shell::variants":["/// A list of possible variants in `&'static str` form\npub fn variants() -> [&'static str; 5]{\n        [\"zsh\", \"bash\", \"fish\", \"powershell\", \"elvish\"]\n    }","Real(LocalPath(\"src/completions/shell.rs\"))"],"completions::subcommands_of":["pub fn subcommands_of(p: &Parser) -> Vec<(String, String)>{\n    debugln!(\n        \"subcommands_of: name={}, bin_name={}\",\n        p.meta.name,\n        p.meta.bin_name.as_ref().unwrap()\n    );\n    let mut subcmds = vec![];\n\n    debugln!(\n        \"subcommands_of: Has subcommands...{:?}\",\n        p.has_subcommands()\n    );\n    if !p.has_subcommands() {\n        let mut ret = vec![];\n        debugln!(\"subcommands_of: Looking for aliases...\");\n        if let Some(ref aliases) = p.meta.aliases {\n            for &(n, _) in aliases {\n                debugln!(\"subcommands_of:iter:iter: Found alias...{}\", n);\n                let mut als_bin_name: Vec<_> =\n                    p.meta.bin_name.as_ref().unwrap().split(' ').collect();\n                als_bin_name.push(n);\n                let old = als_bin_name.len() - 2;\n                als_bin_name.swap_remove(old);\n                ret.push((n.to_owned(), als_bin_name.join(\" \")));\n            }\n        }\n        return ret;\n    }\n    for sc in &p.subcommands {\n        debugln!(\n            \"subcommands_of:iter: name={}, bin_name={}\",\n            sc.p.meta.name,\n            sc.p.meta.bin_name.as_ref().unwrap()\n        );\n\n        debugln!(\"subcommands_of:iter: Looking for aliases...\");\n        if let Some(ref aliases) = sc.p.meta.aliases {\n            for &(n, _) in aliases {\n                debugln!(\"subcommands_of:iter:iter: Found alias...{}\", n);\n                let mut als_bin_name: Vec<_> =\n                    p.meta.bin_name.as_ref().unwrap().split(' ').collect();\n                als_bin_name.push(n);\n                let old = als_bin_name.len() - 2;\n                als_bin_name.swap_remove(old);\n                subcmds.push((n.to_owned(), als_bin_name.join(\" \")));\n            }\n        }\n        subcmds.push((\n            sc.p.meta.name.clone(),\n            sc.p.meta.bin_name.as_ref().unwrap().clone(),\n        ));\n    }\n    subcmds\n}","Real(LocalPath(\"src/completions/mod.rs\"))"],"completions::zsh::ZshGen":["pub struct ZshGen<'a, 'b>\nwhere\n    'a: 'b,\n{\n    p: &'b Parser<'a, 'b>,\n}","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::ZshGen::<'a, 'b>::generate_to":["pub fn generate_to<W: Write>(&self, buf: &mut W){\n        debugln!(\"ZshGen::generate_to;\");\n        w!(\n            buf,\n            format!(\n                \"\\\n#compdef {name}\n\nautoload -U is-at-least\n\n_{name}() {{\n    typeset -A opt_args\n    typeset -a _arguments_options\n    local ret=1\n\n    if is-at-least 5.2; then\n        _arguments_options=(-s -S -C)\n    else\n        _arguments_options=(-s -C)\n    fi\n\n    local context curcontext=\\\"$curcontext\\\" state line\n    {initial_args}\n    {subcommands}\n}}\n\n{subcommand_details}\n\n_{name} \\\"$@\\\"\",\n                name = self.p.meta.bin_name.as_ref().unwrap(),\n                initial_args = get_args_of(self.p),\n                subcommands = get_subcommands_of(self.p),\n                subcommand_details = subcommand_details(self.p)\n            )\n            .as_bytes()\n        );\n    }","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::ZshGen::<'a, 'b>::new":["pub fn new(p: &'b Parser<'a, 'b>) -> Self{\n        debugln!(\"ZshGen::new;\");\n        ZshGen { p: p }\n    }","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::escape_help":["fn escape_help(string: &str) -> String{\n    string\n        .replace(\"\\\\\", \"\\\\\\\\\")\n        .replace(\"'\", \"'\\\\''\")\n        .replace(\"[\", \"\\\\[\")\n        .replace(\"]\", \"\\\\]\")\n}","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::escape_value":["fn escape_value(string: &str) -> String{\n    string\n        .replace(\"\\\\\", \"\\\\\\\\\")\n        .replace(\"'\", \"'\\\\''\")\n        .replace(\"(\", \"\\\\(\")\n        .replace(\")\", \"\\\\)\")\n        .replace(\" \", \"\\\\ \")\n}","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::get_args_of":["fn get_args_of(p: &Parser) -> String{\n    debugln!(\"get_args_of;\");\n    let mut ret = vec![String::from(\"_arguments \\\"${_arguments_options[@]}\\\" \\\\\")];\n    let opts = write_opts_of(p);\n    let flags = write_flags_of(p);\n    let positionals = write_positionals_of(p);\n    let sc_or_a = if p.has_subcommands() {\n        format!(\n            \"\\\":: :_{name}_commands\\\" \\\\\",\n            name = p.meta.bin_name.as_ref().unwrap().replace(\" \", \"__\")\n        )\n    } else {\n        String::new()\n    };\n    let sc = if p.has_subcommands() {\n        format!(\"\\\"*::: :->{name}\\\" \\\\\", name = p.meta.name)\n    } else {\n        String::new()\n    };\n\n    if !opts.is_empty() {\n        ret.push(opts);\n    }\n    if !flags.is_empty() {\n        ret.push(flags);\n    }\n    if !positionals.is_empty() {\n        ret.push(positionals);\n    }\n    if !sc_or_a.is_empty() {\n        ret.push(sc_or_a);\n    }\n    if !sc.is_empty() {\n        ret.push(sc);\n    }\n    ret.push(String::from(\"&& ret=0\"));\n\n    ret.join(\"\\n\")\n}","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::get_subcommands_of":["fn get_subcommands_of(p: &Parser) -> String{\n    debugln!(\"get_subcommands_of;\");\n\n    debugln!(\n        \"get_subcommands_of: Has subcommands...{:?}\",\n        p.has_subcommands()\n    );\n    if !p.has_subcommands() {\n        return String::new();\n    }\n\n    let sc_names = completions::subcommands_of(p);\n\n    let mut subcmds = vec![];\n    for &(ref name, ref bin_name) in &sc_names {\n        let mut v = vec![format!(\"({})\", name)];\n        let subcommand_args = get_args_of(parser_of(p, &*bin_name));\n        if !subcommand_args.is_empty() {\n            v.push(subcommand_args);\n        }\n        let subcommands = get_subcommands_of(parser_of(p, &*bin_name));\n        if !subcommands.is_empty() {\n            v.push(subcommands);\n        }\n        v.push(String::from(\";;\"));\n        subcmds.push(v.join(\"\\n\"));\n    }\n\n    format!(\n        \"case $state in\n    ({name})\n        words=($line[{pos}] \\\"${{words[@]}}\\\")\n        (( CURRENT += 1 ))\n        curcontext=\\\"${{curcontext%:*:*}}:{name_hyphen}-command-$line[{pos}]:\\\"\n        case $line[{pos}] in\n            {subcommands}\n        esac\n    ;;\nesac\",\n        name = p.meta.name,\n        name_hyphen = p.meta.bin_name.as_ref().unwrap().replace(\" \", \"-\"),\n        subcommands = subcmds.join(\"\\n\"),\n        pos = p.positionals().len() + 1\n    )\n}","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::parser_of":["fn parser_of<'a, 'b>(p: &'b Parser<'a, 'b>, sc: &str) -> &'b Parser<'a, 'b>{\n    debugln!(\"parser_of: sc={}\", sc);\n    if sc == p.meta.bin_name.as_ref().unwrap_or(&String::new()) {\n        return p;\n    }\n    &p.find_subcommand(sc).expect(INTERNAL_ERROR_MSG).p\n}","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::subcommand_details":["fn subcommand_details(p: &Parser) -> String{\n    debugln!(\"ZshGen::subcommand_details;\");\n    // First we do ourself\n    let mut ret = vec![format!(\n        \"\\\n(( $+functions[_{bin_name_underscore}_commands] )) ||\n_{bin_name_underscore}_commands() {{\n    local commands; commands=(\n        {subcommands_and_args}\n    )\n    _describe -t commands '{bin_name} commands' commands \\\"$@\\\"\n}}\",\n        bin_name_underscore = p.meta.bin_name.as_ref().unwrap().replace(\" \", \"__\"),\n        bin_name = p.meta.bin_name.as_ref().unwrap(),\n        subcommands_and_args = subcommands_of(p)\n    )];\n\n    // Next we start looping through all the children, grandchildren, etc.\n    let mut all_subcommands = completions::all_subcommands(p);\n    all_subcommands.sort();\n    all_subcommands.dedup();\n    for &(_, ref bin_name) in &all_subcommands {\n        debugln!(\"ZshGen::subcommand_details:iter: bin_name={}\", bin_name);\n        ret.push(format!(\n            \"\\\n(( $+functions[_{bin_name_underscore}_commands] )) ||\n_{bin_name_underscore}_commands() {{\n    local commands; commands=(\n        {subcommands_and_args}\n    )\n    _describe -t commands '{bin_name} commands' commands \\\"$@\\\"\n}}\",\n            bin_name_underscore = bin_name.replace(\" \", \"__\"),\n            bin_name = bin_name,\n            subcommands_and_args = subcommands_of(parser_of(p, bin_name))\n        ));\n    }\n\n    ret.join(\"\\n\")\n}","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::subcommands_of":["fn subcommands_of(p: &Parser) -> String{\n    debugln!(\"ZshGen::subcommands_of;\");\n    let mut ret = vec![];\n    fn add_sc(sc: &App, n: &str, ret: &mut Vec<String>) {\n        debugln!(\"ZshGen::add_sc;\");\n        let s = format!(\n            \"\\\"{name}:{help}\\\" \\\\\",\n            name = n,\n            help =\n                sc.p.meta\n                    .about\n                    .unwrap_or(\"\")\n                    .replace(\"[\", \"\\\\[\")\n                    .replace(\"]\", \"\\\\]\")\n        );\n        if !s.is_empty() {\n            ret.push(s);\n        }\n    }\n\n    // The subcommands\n    for sc in p.subcommands() {\n        debugln!(\"ZshGen::subcommands_of:iter: subcommand={}\", sc.p.meta.name);\n        add_sc(sc, &sc.p.meta.name, &mut ret);\n        if let Some(ref v) = sc.p.meta.aliases {\n            for alias in v.iter().filter(|&&(_, vis)| vis).map(|&(n, _)| n) {\n                add_sc(sc, alias, &mut ret);\n            }\n        }\n    }\n\n    ret.join(\"\\n\")\n}","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::subcommands_of::add_sc":["fn add_sc(sc: &App, n: &str, ret: &mut Vec<String>){\n        debugln!(\"ZshGen::add_sc;\");\n        let s = format!(\n            \"\\\"{name}:{help}\\\" \\\\\",\n            name = n,\n            help =\n                sc.p.meta\n                    .about\n                    .unwrap_or(\"\")\n                    .replace(\"[\", \"\\\\[\")\n                    .replace(\"]\", \"\\\\]\")\n        );\n        if !s.is_empty() {\n            ret.push(s);\n        }\n    }","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::write_flags_of":["fn write_flags_of(p: &Parser) -> String{\n    debugln!(\"write_flags_of;\");\n    let mut ret = vec![];\n    for f in p.flags() {\n        debugln!(\"write_flags_of:iter: f={}\", f.name());\n        let help = f.help().map_or(String::new(), escape_help);\n        let mut conflicts = get_zsh_arg_conflicts!(p, f, INTERNAL_ERROR_MSG);\n        conflicts = if conflicts.is_empty() {\n            String::new()\n        } else {\n            format!(\"({})\", conflicts)\n        };\n\n        let multiple = if f.is_set(ArgSettings::Multiple) {\n            \"*\"\n        } else {\n            \"\"\n        };\n        if let Some(short) = f.short() {\n            let s = format!(\n                \"'{conflicts}{multiple}-{arg}[{help}]' \\\\\",\n                multiple = multiple,\n                conflicts = conflicts,\n                arg = short,\n                help = help\n            );\n\n            debugln!(\"write_flags_of:iter: Wrote...{}\", &*s);\n            ret.push(s);\n        }\n\n        if let Some(long) = f.long() {\n            let l = format!(\n                \"'{conflicts}{multiple}--{arg}[{help}]' \\\\\",\n                conflicts = conflicts,\n                multiple = multiple,\n                arg = long,\n                help = help\n            );\n\n            debugln!(\"write_flags_of:iter: Wrote...{}\", &*l);\n            ret.push(l);\n        }\n    }\n\n    ret.join(\"\\n\")\n}","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::write_opts_of":["fn write_opts_of(p: &Parser) -> String{\n    debugln!(\"write_opts_of;\");\n    let mut ret = vec![];\n    for o in p.opts() {\n        debugln!(\"write_opts_of:iter: o={}\", o.name());\n        let help = o.help().map_or(String::new(), escape_help);\n        let mut conflicts = get_zsh_arg_conflicts!(p, o, INTERNAL_ERROR_MSG);\n        conflicts = if conflicts.is_empty() {\n            String::new()\n        } else {\n            format!(\"({})\", conflicts)\n        };\n\n        let multiple = if o.is_set(ArgSettings::Multiple) {\n            \"*\"\n        } else {\n            \"\"\n        };\n        let pv = if let Some(pv_vec) = o.possible_vals() {\n            format!(\n                \": :({})\",\n                pv_vec\n                    .iter()\n                    .map(|v| escape_value(*v))\n                    .collect::<Vec<String>>()\n                    .join(\" \")\n            )\n        } else {\n            String::new()\n        };\n        if let Some(short) = o.short() {\n            let s = format!(\n                \"'{conflicts}{multiple}-{arg}+[{help}]{possible_values}' \\\\\",\n                conflicts = conflicts,\n                multiple = multiple,\n                arg = short,\n                possible_values = pv,\n                help = help\n            );\n\n            debugln!(\"write_opts_of:iter: Wrote...{}\", &*s);\n            ret.push(s);\n        }\n        if let Some(long) = o.long() {\n            let l = format!(\n                \"'{conflicts}{multiple}--{arg}=[{help}]{possible_values}' \\\\\",\n                conflicts = conflicts,\n                multiple = multiple,\n                arg = long,\n                possible_values = pv,\n                help = help\n            );\n\n            debugln!(\"write_opts_of:iter: Wrote...{}\", &*l);\n            ret.push(l);\n        }\n    }\n\n    ret.join(\"\\n\")\n}","Real(LocalPath(\"src/completions/zsh.rs\"))"],"completions::zsh::write_positionals_of":["fn write_positionals_of(p: &Parser) -> String{\n    debugln!(\"write_positionals_of;\");\n    let mut ret = vec![];\n    for arg in p.positionals() {\n        debugln!(\"write_positionals_of:iter: arg={}\", arg.b.name);\n        let a = format!(\n            \"'{optional}:{name}{help}:{action}' \\\\\",\n            optional = if !arg.b.is_set(ArgSettings::Required) {\n                \":\"\n            } else {\n                \"\"\n            },\n            name = arg.b.name,\n            help = arg\n                .b\n                .help\n                .map_or(\"\".to_owned(), |v| \" -- \".to_owned() + v)\n                .replace(\"[\", \"\\\\[\")\n                .replace(\"]\", \"\\\\]\"),\n            action = arg.possible_vals().map_or(\"_files\".to_owned(), |values| {\n                format!(\n                    \"({})\",\n                    values\n                        .iter()\n                        .map(|v| escape_value(*v))\n                        .collect::<Vec<String>>()\n                        .join(\" \")\n                )\n            })\n        );\n\n        debugln!(\"write_positionals_of:iter: Wrote...{}\", a);\n        ret.push(a);\n    }\n\n    ret.join(\"\\n\")\n}","Real(LocalPath(\"src/completions/zsh.rs\"))"],"errors::Error":["/// Command Line Argument Parser Error\npub struct Error {\n    /// Formatted error message\n    pub message: String,\n    /// The type of error\n    pub kind: ErrorKind,\n    /// Any additional information passed along, such as the argument name that caused the error\n    pub info: Option<Vec<String>>,\n}","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::argument_conflict":["#[doc(hidden)]\npub fn argument_conflict<O, U>(\n        arg: &AnyArg,\n        other: Option<O>,\n        usage: U,\n        color: ColorWhen,\n    ) -> Self\n    where\n        O: Into<String>,\n        U: Display,{\n        let mut v = vec![arg.name().to_owned()];\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' cannot be used with {}\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(&*arg.to_string()),\n                match other {\n                    Some(name) => {\n                        let n = name.into();\n                        v.push(n.clone());\n                        c.warning(format!(\"'{}'\", n))\n                    }\n                    None => c.none(\"one or more of the other specified arguments\".to_owned()),\n                },\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::ArgumentConflict,\n            info: Some(v),\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::argument_not_found_auto":["#[doc(hidden)]\npub fn argument_not_found_auto<A>(arg: A) -> Self\n    where\n        A: Into<String>,{\n        let a = arg.into();\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: ColorWhen::Auto,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' wasn't found\",\n                c.error(\"error:\"),\n                a.clone()\n            ),\n            kind: ErrorKind::ArgumentNotFound,\n            info: Some(vec![a]),\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::empty_value":["#[doc(hidden)]\npub fn empty_value<U>(arg: &AnyArg, usage: U, color: ColorWhen) -> Self\n    where\n        U: Display,{\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' requires a value but none was supplied\\\n                 \\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(arg.to_string()),\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::EmptyValue,\n            info: Some(vec![arg.name().to_owned()]),\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::exit":["/// Prints the error to `stderr` and exits with a status of `1`\npub fn exit(&self) -> !{\n        if self.use_stderr() {\n            wlnerr!(\"{}\", self.message);\n            process::exit(1);\n        }\n        let out = io::stdout();\n        writeln!(&mut out.lock(), \"{}\", self.message).expect(\"Error writing Error to stdout\");\n        process::exit(0);\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::invalid_subcommand":["#[doc(hidden)]\npub fn invalid_subcommand<S, D, N, U>(\n        subcmd: S,\n        did_you_mean: D,\n        name: N,\n        usage: U,\n        color: ColorWhen,\n    ) -> Self\n    where\n        S: Into<String>,\n        D: AsRef<str> + Display,\n        N: Display,\n        U: Display,{\n        let s = subcmd.into();\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The subcommand '{}' wasn't recognized\\n\\t\\\n                 Did you mean '{}'?\\n\\n\\\n                 If you believe you received this message in error, try \\\n                 re-running with '{} {} {}'\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(&*s),\n                c.good(did_you_mean.as_ref()),\n                name,\n                c.good(\"--\"),\n                &*s,\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::InvalidSubcommand,\n            info: Some(vec![s]),\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::invalid_utf8":["#[doc(hidden)]\npub fn invalid_utf8<U>(usage: U, color: ColorWhen) -> Self\n    where\n        U: Display,{\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} Invalid UTF-8 was detected in one or more arguments\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::InvalidUtf8,\n            info: None,\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::invalid_value":["#[doc(hidden)]\npub fn invalid_value<B, G, U>(\n        bad_val: B,\n        good_vals: &[G],\n        arg: &AnyArg,\n        usage: U,\n        color: ColorWhen,\n    ) -> Self\n    where\n        B: AsRef<str>,\n        G: AsRef<str> + Display,\n        U: Display,{\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        let suffix = suggestions::did_you_mean_value_suffix(bad_val.as_ref(), good_vals.iter());\n\n        let mut sorted = vec![];\n        for v in good_vals {\n            let val = format!(\"{}\", c.good(v));\n            sorted.push(val);\n        }\n        sorted.sort();\n        let valid_values = sorted.join(\", \");\n        Error {\n            message: format!(\n                \"{} '{}' isn't a valid value for '{}'\\n\\t\\\n                 [possible values: {}]\\n\\\n                 {}\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(bad_val.as_ref()),\n                c.warning(arg.to_string()),\n                valid_values,\n                suffix.0,\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::InvalidValue,\n            info: Some(vec![arg.name().to_owned(), bad_val.as_ref().to_owned()]),\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::io_error":["#[doc(hidden)]\npub fn io_error(e: &Error, color: ColorWhen) -> Self{\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\"{} {}\", c.error(\"error:\"), e.description()),\n            kind: ErrorKind::Io,\n            info: None,\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::missing_required_argument":["#[doc(hidden)]\npub fn missing_required_argument<R, U>(required: R, usage: U, color: ColorWhen) -> Self\n    where\n        R: Display,\n        U: Display,{\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The following required arguments were not provided:{}\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                required,\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::MissingRequiredArgument,\n            info: None,\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::missing_subcommand":["#[doc(hidden)]\npub fn missing_subcommand<N, U>(name: N, usage: U, color: ColorWhen) -> Self\n    where\n        N: AsRef<str> + Display,\n        U: Display,{\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} '{}' requires a subcommand, but one was not provided\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(name),\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::MissingSubcommand,\n            info: None,\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::too_few_values":["#[doc(hidden)]\npub fn too_few_values<U>(\n        arg: &AnyArg,\n        min_vals: u64,\n        curr_vals: usize,\n        usage: U,\n        color: ColorWhen,\n    ) -> Self\n    where\n        U: Display,{\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' requires at least {} values, but only {} w{} \\\n                 provided\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(arg.to_string()),\n                c.warning(min_vals.to_string()),\n                c.warning(curr_vals.to_string()),\n                if curr_vals > 1 { \"ere\" } else { \"as\" },\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::TooFewValues,\n            info: Some(vec![arg.name().to_owned()]),\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::too_many_values":["#[doc(hidden)]\npub fn too_many_values<V, U>(val: V, arg: &AnyArg, usage: U, color: ColorWhen) -> Self\n    where\n        V: AsRef<str> + Display + ToOwned,\n        U: Display,{\n        let v = val.as_ref();\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The value '{}' was provided to '{}', but it wasn't expecting \\\n                 any more values\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(v),\n                c.warning(arg.to_string()),\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::TooManyValues,\n            info: Some(vec![arg.name().to_owned(), v.to_owned()]),\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::unexpected_multiple_usage":["#[doc(hidden)]\npub fn unexpected_multiple_usage<U>(arg: &AnyArg, usage: U, color: ColorWhen) -> Self\n    where\n        U: Display,{\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' was provided more than once, but cannot \\\n                 be used multiple times\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(arg.to_string()),\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::UnexpectedMultipleUsage,\n            info: Some(vec![arg.name().to_owned()]),\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::unknown_argument":["#[doc(hidden)]\npub fn unknown_argument<A, U>(arg: A, did_you_mean: &str, usage: U, color: ColorWhen) -> Self\n    where\n        A: Into<String>,\n        U: Display,{\n        let a = arg.into();\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} Found argument '{}' which wasn't expected, or isn't valid in \\\n                 this context{}\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(&*a),\n                if did_you_mean.is_empty() {\n                    \"\\n\".to_owned()\n                } else {\n                    format!(\"{}\\n\", did_you_mean)\n                },\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::UnknownArgument,\n            info: Some(vec![a]),\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::unrecognized_subcommand":["#[doc(hidden)]\npub fn unrecognized_subcommand<S, N>(subcmd: S, name: N, color: ColorWhen) -> Self\n    where\n        S: Into<String>,\n        N: Display,{\n        let s = subcmd.into();\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The subcommand '{}' wasn't recognized\\n\\n\\\n                 {}\\n\\t\\\n                 {} help <subcommands>...\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(&*s),\n                c.warning(\"USAGE:\"),\n                name,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::UnrecognizedSubcommand,\n            info: Some(vec![s]),\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::use_stderr":["/// Should the message be written to `stdout` or not\npub fn use_stderr(&self) -> bool{\n        match self.kind {\n            ErrorKind::HelpDisplayed | ErrorKind::VersionDisplayed => false,\n            _ => true,\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::value_validation":["#[doc(hidden)]\npub fn value_validation(arg: Option<&AnyArg>, err: String, color: ColorWhen) -> Self{\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} Invalid value{}: {}\",\n                c.error(\"error:\"),\n                if let Some(a) = arg {\n                    format!(\" for '{}'\", c.warning(a.to_string()))\n                } else {\n                    \"\".to_string()\n                },\n                err\n            ),\n            kind: ErrorKind::ValueValidation,\n            info: None,\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::value_validation_auto":["#[doc(hidden)]\npub fn value_validation_auto(err: String) -> Self{\n        let n: Option<&AnyArg> = None;\n        Error::value_validation(n, err, ColorWhen::Auto)\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::with_description":["/// Create an error with a custom description.\n///\n/// This can be used in combination with `Error::exit` to exit your program\n/// with a custom error message.\npub fn with_description(description: &str, kind: ErrorKind) -> Self{\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: ColorWhen::Auto,\n        });\n        Error {\n            message: format!(\"{} {}\", c.error(\"error:\"), description),\n            kind: kind,\n            info: None,\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::write_to":["#[doc(hidden)]\npub fn write_to<W: Write>(&self, w: &mut W) -> io::Result<()>{\n        write!(w, \"{}\", self.message)\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::Error::wrong_number_of_values":["#[doc(hidden)]\npub fn wrong_number_of_values<S, U>(\n        arg: &AnyArg,\n        num_vals: u64,\n        curr_vals: usize,\n        suffix: S,\n        usage: U,\n        color: ColorWhen,\n    ) -> Self\n    where\n        S: Display,\n        U: Display,{\n        let c = Colorizer::new(ColorizerOption {\n            use_stderr: true,\n            when: color,\n        });\n        Error {\n            message: format!(\n                \"{} The argument '{}' requires {} values, but {} w{} \\\n                 provided\\n\\n\\\n                 {}\\n\\n\\\n                 For more information try {}\",\n                c.error(\"error:\"),\n                c.warning(arg.to_string()),\n                c.warning(num_vals.to_string()),\n                c.warning(curr_vals.to_string()),\n                suffix,\n                usage,\n                c.good(\"--help\")\n            ),\n            kind: ErrorKind::WrongNumberOfValues,\n            info: Some(vec![arg.name().to_owned()]),\n        }\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::ErrorKind":["/// Command line argument parser kind of error\npub enum ErrorKind {\n    /// Occurs when an [`Arg`] has a set of possible values,\n    /// and the user provides a value which isn't in that set.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let result = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"speed\")\n    ///         .possible_value(\"fast\")\n    ///         .possible_value(\"slow\"))\n    ///     .get_matches_from_safe(vec![\"prog\", \"other\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::InvalidValue);\n    /// ```\n    /// [`Arg`]: ./struct.Arg.html\n    InvalidValue,\n\n    /// Occurs when a user provides a flag, option, argument or subcommand which isn't defined.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let result = App::new(\"prog\")\n    ///     .arg(Arg::from_usage(\"--flag 'some flag'\"))\n    ///     .get_matches_from_safe(vec![\"prog\", \"--other\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::UnknownArgument);\n    /// ```\n    UnknownArgument,\n\n    /// Occurs when the user provides an unrecognized [`SubCommand`] which meets the threshold for\n    /// being similar enough to an existing subcommand.\n    /// If it doesn't meet the threshold, or the 'suggestions' feature is disabled,\n    /// the more general [`UnknownArgument`] error is returned.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(not(feature = \"suggestions\"), doc = \" ```no_run\")]\n    #[cfg_attr(feature = \"suggestions\", doc = \" ```\")]\n    /// # use clap::{App, Arg, ErrorKind, SubCommand};\n    /// let result = App::new(\"prog\")\n    ///     .subcommand(SubCommand::with_name(\"config\")\n    ///         .about(\"Used for configuration\")\n    ///         .arg(Arg::with_name(\"config_file\")\n    ///             .help(\"The configuration file to use\")\n    ///             .index(1)))\n    ///     .get_matches_from_safe(vec![\"prog\", \"confi\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::InvalidSubcommand);\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`UnknownArgument`]: ./enum.ErrorKind.html#variant.UnknownArgument\n    InvalidSubcommand,\n\n    /// Occurs when the user provides an unrecognized [`SubCommand`] which either\n    /// doesn't meet the threshold for being similar enough to an existing subcommand,\n    /// or the 'suggestions' feature is disabled.\n    /// Otherwise the more detailed [`InvalidSubcommand`] error is returned.\n    ///\n    /// This error typically happens when passing additional subcommand names to the `help`\n    /// subcommand. Otherwise, the more general [`UnknownArgument`] error is used.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind, SubCommand};\n    /// let result = App::new(\"prog\")\n    ///     .subcommand(SubCommand::with_name(\"config\")\n    ///         .about(\"Used for configuration\")\n    ///         .arg(Arg::with_name(\"config_file\")\n    ///             .help(\"The configuration file to use\")\n    ///             .index(1)))\n    ///     .get_matches_from_safe(vec![\"prog\", \"help\", \"nothing\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::UnrecognizedSubcommand);\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`InvalidSubcommand`]: ./enum.ErrorKind.html#variant.InvalidSubcommand\n    /// [`UnknownArgument`]: ./enum.ErrorKind.html#variant.UnknownArgument\n    UnrecognizedSubcommand,\n\n    /// Occurs when the user provides an empty value for an option that does not allow empty\n    /// values.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let res = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"color\")\n    ///          .long(\"color\")\n    ///          .empty_values(false))\n    ///     .get_matches_from_safe(vec![\"prog\", \"--color=\"]);\n    /// assert!(res.is_err());\n    /// assert_eq!(res.unwrap_err().kind, ErrorKind::EmptyValue);\n    /// ```\n    EmptyValue,\n\n    /// Occurs when the user provides a value for an argument with a custom validation and the\n    /// value fails that validation.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// fn is_numeric(val: String) -> Result<(), String> {\n    ///     match val.parse::<i64>() {\n    ///         Ok(..) => Ok(()),\n    ///         Err(..) => Err(String::from(\"Value wasn't a number!\")),\n    ///     }\n    /// }\n    ///\n    /// let result = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"num\")\n    ///          .validator(is_numeric))\n    ///     .get_matches_from_safe(vec![\"prog\", \"NotANumber\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::ValueValidation);\n    /// ```\n    ValueValidation,\n\n    /// Occurs when a user provides more values for an argument than were defined by setting\n    /// [`Arg::max_values`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let result = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"arg\")\n    ///         .multiple(true)\n    ///         .max_values(2))\n    ///     .get_matches_from_safe(vec![\"prog\", \"too\", \"many\", \"values\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::TooManyValues);\n    /// ```\n    /// [`Arg::max_values`]: ./struct.Arg.html#method.max_values\n    TooManyValues,\n\n    /// Occurs when the user provides fewer values for an argument than were defined by setting\n    /// [`Arg::min_values`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let result = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"some_opt\")\n    ///         .long(\"opt\")\n    ///         .min_values(3))\n    ///     .get_matches_from_safe(vec![\"prog\", \"--opt\", \"too\", \"few\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::TooFewValues);\n    /// ```\n    /// [`Arg::min_values`]: ./struct.Arg.html#method.min_values\n    TooFewValues,\n\n    /// Occurs when the user provides a different number of values for an argument than what's\n    /// been defined by setting [`Arg::number_of_values`] or than was implicitly set by\n    /// [`Arg::value_names`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let result = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"some_opt\")\n    ///         .long(\"opt\")\n    ///         .takes_value(true)\n    ///         .number_of_values(2))\n    ///     .get_matches_from_safe(vec![\"prog\", \"--opt\", \"wrong\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::WrongNumberOfValues);\n    /// ```\n    ///\n    /// [`Arg::number_of_values`]: ./struct.Arg.html#method.number_of_values\n    /// [`Arg::value_names`]: ./struct.Arg.html#method.value_names\n    WrongNumberOfValues,\n\n    /// Occurs when the user provides two values which conflict with each other and can't be used\n    /// together.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let result = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .long(\"debug\")\n    ///         .conflicts_with(\"color\"))\n    ///     .arg(Arg::with_name(\"color\")\n    ///         .long(\"color\"))\n    ///     .get_matches_from_safe(vec![\"prog\", \"--debug\", \"--color\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::ArgumentConflict);\n    /// ```\n    ArgumentConflict,\n\n    /// Occurs when the user does not provide one or more required arguments.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let result = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .required(true))\n    ///     .get_matches_from_safe(vec![\"prog\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::MissingRequiredArgument);\n    /// ```\n    MissingRequiredArgument,\n\n    /// Occurs when a subcommand is required (as defined by [`AppSettings::SubcommandRequired`]),\n    /// but the user does not provide one.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, AppSettings, SubCommand, ErrorKind};\n    /// let err = App::new(\"prog\")\n    ///     .setting(AppSettings::SubcommandRequired)\n    ///     .subcommand(SubCommand::with_name(\"test\"))\n    ///     .get_matches_from_safe(vec![\n    ///         \"myprog\",\n    ///     ]);\n    /// assert!(err.is_err());\n    /// assert_eq!(err.unwrap_err().kind, ErrorKind::MissingSubcommand);\n    /// # ;\n    /// ```\n    /// [`AppSettings::SubcommandRequired`]: ./enum.AppSettings.html#variant.SubcommandRequired\n    MissingSubcommand,\n\n    /// Occurs when either an argument or [`SubCommand`] is required, as defined by\n    /// [`AppSettings::ArgRequiredElseHelp`], but the user did not provide one.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, AppSettings, ErrorKind, SubCommand};\n    /// let result = App::new(\"prog\")\n    ///     .setting(AppSettings::ArgRequiredElseHelp)\n    ///     .subcommand(SubCommand::with_name(\"config\")\n    ///         .about(\"Used for configuration\")\n    ///         .arg(Arg::with_name(\"config_file\")\n    ///             .help(\"The configuration file to use\")))\n    ///     .get_matches_from_safe(vec![\"prog\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::MissingArgumentOrSubcommand);\n    /// ```\n    /// [`SubCommand`]: ./struct.SubCommand.html\n    /// [`AppSettings::ArgRequiredElseHelp`]: ./enum.AppSettings.html#variant.ArgRequiredElseHelp\n    MissingArgumentOrSubcommand,\n\n    /// Occurs when the user provides multiple values to an argument which doesn't allow that.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let result = App::new(\"prog\")\n    ///     .arg(Arg::with_name(\"debug\")\n    ///         .long(\"debug\")\n    ///         .multiple(false))\n    ///     .get_matches_from_safe(vec![\"prog\", \"--debug\", \"--debug\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::UnexpectedMultipleUsage);\n    /// ```\n    UnexpectedMultipleUsage,\n\n    /// Occurs when the user provides a value containing invalid UTF-8 for an argument and\n    /// [`AppSettings::StrictUtf8`] is set.\n    ///\n    /// # Platform Specific\n    ///\n    /// Non-Windows platforms only (such as Linux, Unix, macOS, etc.)\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(not(unix), doc = \" ```ignore\")]\n    #[cfg_attr(unix, doc = \" ```\")]\n    /// # use clap::{App, Arg, ErrorKind, AppSettings};\n    /// # use std::os::unix::ffi::OsStringExt;\n    /// # use std::ffi::OsString;\n    /// let result = App::new(\"prog\")\n    ///     .setting(AppSettings::StrictUtf8)\n    ///     .arg(Arg::with_name(\"utf8\")\n    ///         .short(\"u\")\n    ///         .takes_value(true))\n    ///     .get_matches_from_safe(vec![OsString::from(\"myprog\"),\n    ///                                 OsString::from(\"-u\"),\n    ///                                 OsString::from_vec(vec![0xE9])]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::InvalidUtf8);\n    /// ```\n    /// [`AppSettings::StrictUtf8`]: ./enum.AppSettings.html#variant.StrictUtf8\n    InvalidUtf8,\n\n    /// Not a true \"error\" as it means `--help` or similar was used.\n    /// The help message will be sent to `stdout`.\n    ///\n    /// **Note**: If the help is displayed due to an error (such as missing subcommands) it will\n    /// be sent to `stderr` instead of `stdout`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let result = App::new(\"prog\")\n    ///     .get_matches_from_safe(vec![\"prog\", \"--help\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::HelpDisplayed);\n    /// ```\n    HelpDisplayed,\n\n    /// Not a true \"error\" as it means `--version` or similar was used.\n    /// The message will be sent to `stdout`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use clap::{App, Arg, ErrorKind};\n    /// let result = App::new(\"prog\")\n    ///     .get_matches_from_safe(vec![\"prog\", \"--version\"]);\n    /// assert!(result.is_err());\n    /// assert_eq!(result.unwrap_err().kind, ErrorKind::VersionDisplayed);\n    /// ```\n    VersionDisplayed,\n\n    /// Occurs when using the [`value_t!`] and [`values_t!`] macros to convert an argument value\n    /// into type `T`, but the argument you requested wasn't used. I.e. you asked for an argument\n    /// with name `config` to be converted, but `config` wasn't used by the user.\n    /// [`value_t!`]: ./macro.value_t!.html\n    /// [`values_t!`]: ./macro.values_t!.html\n    ArgumentNotFound,\n\n    /// Represents an [I/O error].\n    /// Can occur when writing to `stderr` or `stdout` or reading a configuration file.\n    /// [I/O error]: https://doc.rust-lang.org/std/io/struct.Error.html\n    Io,\n\n    /// Represents a [Format error] (which is a part of [`Display`]).\n    /// Typically caused by writing to `stderr` or `stdout`.\n    ///\n    /// [`Display`]: https://doc.rust-lang.org/std/fmt/trait.Display.html\n    /// [Format error]: https://doc.rust-lang.org/std/fmt/struct.Error.html\n    Format,\n}","Real(LocalPath(\"src/errors.rs\"))"],"fmt::ColorWhen":["#[doc(hidden)]\npub enum ColorWhen {\n    Auto,\n    Always,\n    Never,\n}","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Colorizer":["#[doc(hidden)]\npub struct Colorizer {\n    when: ColorWhen,\n}","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Colorizer::error":["pub fn error<T>(&self, msg: T) -> Format<T>\n    where\n        T: fmt::Display + AsRef<str>,{\n        debugln!(\"Colorizer::error;\");\n        color!(self, Error, msg)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Colorizer::good":["pub fn good<T>(&self, msg: T) -> Format<T>\n    where\n        T: fmt::Display + AsRef<str>,{\n        debugln!(\"Colorizer::good;\");\n        color!(self, Good, msg)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Colorizer::new":["pub fn new(option: ColorizerOption) -> Colorizer{\n        let is_a_tty = is_a_tty(option.use_stderr);\n        let is_term_dumb = is_term_dumb();\n        Colorizer {\n            when: match option.when {\n                ColorWhen::Auto if is_a_tty && !is_term_dumb => ColorWhen::Auto,\n                ColorWhen::Auto => ColorWhen::Never,\n                when => when,\n            },\n        }\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Colorizer::none":["pub fn none<T>(&self, msg: T) -> Format<T>\n    where\n        T: fmt::Display + AsRef<str>,{\n        debugln!(\"Colorizer::none;\");\n        Format::None(msg)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Colorizer::warning":["pub fn warning<T>(&self, msg: T) -> Format<T>\n    where\n        T: fmt::Display + AsRef<str>,{\n        debugln!(\"Colorizer::warning;\");\n        color!(self, Warning, msg)\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::ColorizerOption":["#[doc(hidden)]\npub struct ColorizerOption {\n    pub use_stderr: bool,\n    pub when: ColorWhen,\n}","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Format":["/// Defines styles for different types of error messages. Defaults to Error=Red, Warning=Yellow,\n/// and Good=Green\n#[doc(hidden)]\npub enum Format<T> {\n    /// Defines the style used for errors, defaults to Red\n    Error(T),\n    /// Defines the style used for warnings, defaults to Yellow\n    Warning(T),\n    /// Defines the style used for good values, defaults to Green\n    Good(T),\n    /// Defines no formatting style\n    None(T),\n}","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::Format::<T>::format":["fn format(&self) -> ANSIString{\n        match *self {\n            Format::Error(ref e) => Red.bold().paint(e.as_ref()),\n            Format::Warning(ref e) => Yellow.paint(e.as_ref()),\n            Format::Good(ref e) => Green.paint(e.as_ref()),\n            Format::None(ref e) => ANSIString::from(e.as_ref()),\n        }\n    }","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::is_a_tty":["#[cfg(feature = \"color\")]\npub fn is_a_tty(stderr: bool) -> bool{\n    debugln!(\"is_a_tty: stderr={:?}\", stderr);\n    let stream = if stderr {\n        atty::Stream::Stderr\n    } else {\n        atty::Stream::Stdout\n    };\n    atty::is(stream)\n}","Real(LocalPath(\"src/fmt.rs\"))"],"fmt::is_term_dumb":["pub fn is_term_dumb() -> bool{\n    env::var(\"TERM\").ok() == Some(String::from(\"dumb\"))\n}","Real(LocalPath(\"src/fmt.rs\"))"],"osstringext::OsSplit":["#[doc(hidden)]\npub struct OsSplit<'a> {\n    sep: u8,\n    val: &'a [u8],\n    pos: usize,\n}","Real(LocalPath(\"src/osstringext.rs\"))"],"osstringext::OsStrExt2":["#[doc(hidden)]\npub trait OsStrExt2 {\n    fn starts_with(&self, s: &[u8]) -> bool;\n    fn split_at_byte(&self, b: u8) -> (&OsStr, &OsStr);\n    fn split_at(&self, i: usize) -> (&OsStr, &OsStr);\n    fn trim_left_matches(&self, b: u8) -> &OsStr;\n    fn contains_byte(&self, b: u8) -> bool;\n    fn split(&self, b: u8) -> OsSplit;\n}","Real(LocalPath(\"src/osstringext.rs\"))"],"strext::_StrExt":["pub trait _StrExt {\n    fn _is_char_boundary(&self, index: usize) -> bool;\n}","Real(LocalPath(\"src/strext.rs\"))"],"suggestions::did_you_mean":["/// Produces a string from a given list of possible values which is similar to\n/// the passed in value `v` with a certain confidence.\n/// Thus in a list of possible values like [\"foo\", \"bar\"], the value \"fop\" will yield\n/// `Some(\"foo\")`, whereas \"blark\" would yield `None`.\n#[cfg(feature = \"suggestions\")]\npub fn did_you_mean<'a, T: ?Sized, I>(v: &str, possible_values: I) -> Option<&'a str>\nwhere\n    T: AsRef<str> + 'a,\n    I: IntoIterator<Item = &'a T>,{\n    let mut candidate: Option<(f64, &str)> = None;\n    for pv in possible_values {\n        let confidence = strsim::jaro_winkler(v, pv.as_ref());\n        if confidence > 0.8 && (candidate.is_none() || (candidate.as_ref().unwrap().0 < confidence))\n        {\n            candidate = Some((confidence, pv.as_ref()));\n        }\n    }\n    match candidate {\n        None => None,\n        Some((_, candidate)) => Some(candidate),\n    }\n}","Real(LocalPath(\"src/suggestions.rs\"))"],"suggestions::did_you_mean_flag_suffix":["/// Returns a suffix that can be empty, or is the standard 'did you mean' phrase\npub fn did_you_mean_flag_suffix<'z, T, I>(\n    arg: &str,\n    args_rest: &'z [&str],\n    longs: I,\n    subcommands: &'z [App],\n) -> (String, Option<&'z str>)\nwhere\n    T: AsRef<str> + 'z,\n    I: IntoIterator<Item = &'z T>,{\n    if let Some(candidate) = did_you_mean(arg, longs) {\n        let suffix = format!(\n            \"\\n\\tDid you mean {}{}?\",\n            Format::Good(\"--\"),\n            Format::Good(candidate)\n        );\n        return (suffix, Some(candidate));\n    }\n\n    subcommands\n        .into_iter()\n        .filter_map(|subcommand| {\n            let opts = subcommand\n                .p\n                .flags\n                .iter()\n                .filter_map(|f| f.s.long)\n                .chain(subcommand.p.opts.iter().filter_map(|o| o.s.long));\n\n            let candidate = match did_you_mean(arg, opts) {\n                Some(candidate) => candidate,\n                None => return None,\n            };\n            let score = match args_rest.iter().position(|x| *x == subcommand.get_name()) {\n                Some(score) => score,\n                None => return None,\n            };\n\n            let suffix = format!(\n                \"\\n\\tDid you mean to put '{}{}' after the subcommand '{}'?\",\n                Format::Good(\"--\"),\n                Format::Good(candidate),\n                Format::Good(subcommand.get_name())\n            );\n\n            Some((score, (suffix, Some(candidate))))\n        })\n        .min_by_key(|&(score, _)| score)\n        .map(|(_, suggestion)| suggestion)\n        .unwrap_or_else(|| (String::new(), None))\n}","Real(LocalPath(\"src/suggestions.rs\"))"],"suggestions::did_you_mean_value_suffix":["/// Returns a suffix that can be empty, or is the standard 'did you mean' phrase\npub fn did_you_mean_value_suffix<'z, T, I>(arg: &str, values: I) -> (String, Option<&'z str>)\nwhere\n    T: AsRef<str> + 'z,\n    I: IntoIterator<Item = &'z T>,{\n    match did_you_mean(arg, values) {\n        Some(candidate) => {\n            let suffix = format!(\"\\n\\tDid you mean '{}'?\", Format::Good(candidate));\n            (suffix, Some(candidate))\n        }\n        None => (String::new(), None),\n    }\n}","Real(LocalPath(\"src/suggestions.rs\"))"],"usage_parser::UsageParser":["#[doc(hidden)]\npub struct UsageParser<'a> {\n    usage: &'a str,\n    pos: usize,\n    start: usize,\n    prev: UsageToken,\n    explicit_name_set: bool,\n}","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::UsageParser::<'a>::from_usage":["pub fn from_usage(usage: &'a str) -> Self{\n        debugln!(\"UsageParser::from_usage;\");\n        UsageParser::new(usage)\n    }","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::UsageParser::<'a>::help":["fn help(&mut self, arg: &mut Arg<'a, 'a>){\n        debugln!(\"UsageParser::help;\");\n        self.stop_at(help_start);\n        self.start = self.pos + 1;\n        self.pos = self.usage.len() - 1;\n        debugln!(\n            \"UsageParser::help: setting help...{}\",\n            &self.usage[self.start..self.pos]\n        );\n        arg.b.help = Some(&self.usage[self.start..self.pos]);\n        self.pos += 1; // Move to next byte to keep from thinking ending ' is a start\n        self.prev = UsageToken::Help;\n    }","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::UsageParser::<'a>::long":["fn long(&mut self, arg: &mut Arg<'a, 'a>){\n        debugln!(\"UsageParser::long;\");\n        self.stop_at(long_end);\n        let name = &self.usage[self.start..self.pos];\n        if !self.explicit_name_set {\n            debugln!(\"UsageParser::long: setting name...{}\", name);\n            arg.b.name = name;\n        }\n        debugln!(\"UsageParser::long: setting long...{}\", name);\n        arg.s.long = Some(name);\n        self.prev = UsageToken::Long;\n    }","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::UsageParser::<'a>::multiple":["fn multiple(&mut self, arg: &mut Arg){\n        debugln!(\"UsageParser::multiple;\");\n        let mut dot_counter = 1;\n        let start = self.pos;\n        let mut bytes = self.usage[start..].bytes();\n        while bytes.next() == Some(b'.') {\n            dot_counter += 1;\n            self.pos += 1;\n            if dot_counter == 3 {\n                debugln!(\"UsageParser::multiple: setting multiple\");\n                arg.setb(ArgSettings::Multiple);\n                if arg.is_set(ArgSettings::TakesValue) {\n                    arg.setb(ArgSettings::UseValueDelimiter);\n                    arg.unsetb(ArgSettings::ValueDelimiterNotSet);\n                    if arg.v.val_delim.is_none() {\n                        arg.v.val_delim = Some(',');\n                    }\n                }\n                self.prev = UsageToken::Multiple;\n                self.pos += 1;\n                break;\n            }\n        }\n    }","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::UsageParser::<'a>::name":["fn name(&mut self, arg: &mut Arg<'a, 'a>){\n        debugln!(\"UsageParser::name;\");\n        if *self\n            .usage\n            .as_bytes()\n            .get(self.pos)\n            .expect(INTERNAL_ERROR_MSG)\n            == b'<'\n            && !self.explicit_name_set\n        {\n            arg.setb(ArgSettings::Required);\n        }\n        self.pos += 1;\n        self.stop_at(name_end);\n        let name = &self.usage[self.start..self.pos];\n        if self.prev == UsageToken::Unknown {\n            debugln!(\"UsageParser::name: setting name...{}\", name);\n            arg.b.name = name;\n            if arg.s.long.is_none() && arg.s.short.is_none() {\n                debugln!(\"UsageParser::name: explicit name set...\");\n                self.explicit_name_set = true;\n                self.prev = UsageToken::Name;\n            }\n        } else {\n            debugln!(\"UsageParser::name: setting val name...{}\", name);\n            if let Some(ref mut v) = arg.v.val_names {\n                let len = v.len();\n                v.insert(len, name);\n            } else {\n                let mut v = VecMap::new();\n                v.insert(0, name);\n                arg.v.val_names = Some(v);\n                arg.setb(ArgSettings::TakesValue);\n            }\n            self.prev = UsageToken::ValName;\n        }\n    }","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::UsageParser::<'a>::new":["fn new(usage: &'a str) -> Self{\n        debugln!(\"UsageParser::new: usage={:?}\", usage);\n        UsageParser {\n            usage: usage,\n            pos: 0,\n            start: 0,\n            prev: UsageToken::Unknown,\n            explicit_name_set: false,\n        }\n    }","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::UsageParser::<'a>::parse":["pub fn parse(mut self) -> Arg<'a, 'a>{\n        debugln!(\"UsageParser::parse;\");\n        let mut arg = Arg::default();\n        loop {\n            debugln!(\"UsageParser::parse:iter: pos={};\", self.pos);\n            self.stop_at(token);\n            if let Some(&c) = self.usage.as_bytes().get(self.pos) {\n                match c {\n                    b'-' => self.short_or_long(&mut arg),\n                    b'.' => self.multiple(&mut arg),\n                    b'\\'' => self.help(&mut arg),\n                    _ => self.name(&mut arg),\n                }\n            } else {\n                break;\n            }\n        }\n        debug_assert!(\n            !arg.b.name.is_empty(),\n            format!(\n                \"No name found for Arg when parsing usage string: {}\",\n                self.usage\n            )\n        );\n        arg.v.num_vals = match arg.v.val_names {\n            Some(ref v) if v.len() >= 2 => Some(v.len() as u64),\n            _ => None,\n        };\n        debugln!(\"UsageParser::parse: vals...{:?}\", arg.v.val_names);\n        arg\n    }","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::UsageParser::<'a>::short":["fn short(&mut self, arg: &mut Arg<'a, 'a>){\n        debugln!(\"UsageParser::short;\");\n        let start = &self.usage[self.pos..];\n        let short = start.chars().nth(0).expect(INTERNAL_ERROR_MSG);\n        debugln!(\"UsageParser::short: setting short...{}\", short);\n        arg.s.short = Some(short);\n        if arg.b.name.is_empty() {\n            // --long takes precedence but doesn't set self.explicit_name_set\n            let name = &start[..short.len_utf8()];\n            debugln!(\"UsageParser::short: setting name...{}\", name);\n            arg.b.name = name;\n        }\n        self.prev = UsageToken::Short;\n    }","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::UsageParser::<'a>::short_or_long":["fn short_or_long(&mut self, arg: &mut Arg<'a, 'a>){\n        debugln!(\"UsageParser::short_or_long;\");\n        self.pos += 1;\n        if *self\n            .usage\n            .as_bytes()\n            .get(self.pos)\n            .expect(INTERNAL_ERROR_MSG)\n            == b'-'\n        {\n            self.pos += 1;\n            self.long(arg);\n            return;\n        }\n        self.short(arg)\n    }","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::UsageParser::<'a>::stop_at":["fn stop_at<F>(&mut self, f: F)\n    where\n        F: Fn(u8) -> bool,{\n        debugln!(\"UsageParser::stop_at;\");\n        self.start = self.pos;\n        self.pos += self.usage[self.start..]\n            .bytes()\n            .take_while(|&b| f(b))\n            .count();\n    }","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::UsageToken":["enum UsageToken {\n    Name,\n    ValName,\n    Short,\n    Long,\n    Help,\n    Multiple,\n    Unknown,\n}","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::help_start":["#[inline]\nfn help_start(b: u8) -> bool{\n    b != b'\\''\n}","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::long_end":["#[inline]\nfn long_end(b: u8) -> bool{\n    b != b'\\'' && b != b'.' && b != b'<' && b != b'[' && b != b'=' && b != b' '\n}","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::name_end":["#[inline]\nfn name_end(b: u8) -> bool{\n    b != b']' && b != b'>'\n}","Real(LocalPath(\"src/usage_parser.rs\"))"],"usage_parser::token":["#[inline]\nfn token(b: u8) -> bool{\n    b != b'\\'' && b != b'.' && b != b'<' && b != b'[' && b != b'-'\n}","Real(LocalPath(\"src/usage_parser.rs\"))"]},"struct_constructor":{"!":["exit"],"&'a std::ffi::OsStr":["next","next_back"],"&'a str":["did_you_mean","next","next_back"],"&'e std::ffi::OsStr":["default_val"],"&'e str":["help","long","long_help","val_terminator"],"&'n str":["name"],"&[&'e str]":["blacklist","overrides","possible_vals","required_unless"],"&[(std::option::Option<&'e str>, &'n str)]":["requires"],"&args::matched_arg::MatchedArg":["get"],"&dyn app::help::ArgWithDisplay<'b, 'c>":["as_base"],"&dyn app::help::ArgWithOrder<'a, 'b>":["as_arg_trait"],"&dyn args::any_arg::AnyArg<'a, 'b>":["as_trait_obj","find_any_arg"],"&mut args::matched_arg::MatchedArg":["get_mut"],"&std::ffi::OsStr":["to_str_slice","trim_left_matches","value_of_os"],"&str":["description","get_bin_name","get_name","multiple_str","subcommand_name","to_str_slice","usage","value_of"],"(&'n std::ffi::OsStr, std::option::Option<&'s std::ffi::OsString>)":["env"],"(&std::ffi::OsStr, &std::ffi::OsStr)":["split_at","split_at_byte"],"(&str, std::option::Option<&args::arg_matches::ArgMatches<'a>>)":["subcommand"],"(bool, std::option::Option<&str>)":["possible_subcommand"],"(std::string::String, std::option::Option<&'z str>)":["did_you_mean_flag_suffix","did_you_mean_value_suffix"],"(usize, std::option::Option<usize>)":["size_hint"],"(usize, usize)":["dimensions"],"[&'static str; 5]":["variants"],"ansi_term::ANSIGenericString":["format"],"app::App":["clone","new","with_defaults","with_name"],"app::help::CopyUntilResult":["copy_until"],"app::help::Help":["new"],"app::meta::AppMeta":["clone","default","new","with_name"],"app::parser::ParseResult":["add_single_val_to_arg","add_val_to_arg","clone","parse_flag","parse_help_subcommand","parse_long_arg","parse_opt","parse_short_arg"],"app::parser::Parser":["clone","default","with_name"],"app::settings::AppFlags":["clone","default","new","zeroed"],"app::settings::AppSettings":["clone","from_str"],"app::settings::Flags":["all","clone","empty","from_bits","from_bits_truncate","from_bits_unchecked","from_iter"],"app::validator::Validator":["new"],"args::arg::Arg":["clone","default","from","from_usage","parse","with_name"],"args::arg_builder::base::Base":["clone","default","from","new"],"args::arg_builder::flag::FlagBuilder":["clone","default","from","new"],"args::arg_builder::option::OptBuilder":["clone","default","from","new"],"args::arg_builder::positional::PosBuilder":["clone","default","from_arg","from_arg_ref","new"],"args::arg_builder::switched::Switched":["clone","default","from"],"args::arg_builder::valued::Valued":["clone","default","from"],"args::arg_matcher::ArgMatcher":["default","new"],"args::arg_matches::ArgMatches":["clone","default","get_matches","get_matches_from","get_matches_from_safe","get_matches_from_safe_borrow","get_matches_safe","into","new"],"args::arg_matches::Indices":["clone","default","indices_of"],"args::arg_matches::OsValues":["clone","default","values_of_os"],"args::arg_matches::Values":["clone","default","values_of"],"args::group::ArgGroup":["clone","default","from","with_name"],"args::matched_arg::MatchedArg":["clone","default","new"],"args::settings::ArgFlags":["clone","default","new"],"args::settings::ArgSettings":["clone","from_str"],"args::settings::Flags":["all","clone","empty","from_bits","from_bits_truncate","from_bits_unchecked","from_iter"],"args::subcommand::SubCommand":["clone"],"bool":["ALLOW_MISSING_POS","ALLOW_NEG_NUMS","ALLOW_TAC_VALS","ALLOW_UNK_SC","ARGS_NEGATE_SCS","ARGS_OVERRIDE_SELF","A_REQUIRED_ELSE_HELP","CASE_INSENSITIVE","COLORED_HELP","COLOR_ALWAYS","COLOR_AUTO","COLOR_NEVER","CONTAINS_LAST","DELIM_NOT_SET","DERIVE_DISP_ORDER","DISABLE_HELP_FLAGS","DISABLE_HELP_SC","DISABLE_VERSION","DONT_COLLAPSE_ARGS","DONT_DELIM_TRAIL","EMPTY_VALS","GLOBAL","GLOBAL_VERSION","HIDDEN","HIDDEN_LONG_H","HIDDEN_SHORT_H","HIDE_DEFAULT_VAL","HIDE_ENV_VALS","HIDE_POS_VALS","INFER_SUBCOMMANDS","LAST","LEADING_HYPHEN","LOW_INDEX_MUL_POS","MULTIPLE","NEEDS_LONG_HELP","NEEDS_LONG_VERSION","NEEDS_SC_HELP","NEXT_LINE_HELP","NO_BIN_NAME","NO_POS_VALUES","PROPAGATED","PROPAGATE_VALS_DOWN","REQUIRED","REQUIRE_EQUALS","REQ_DELIM","R_UNLESS_ALL","SC_NEGATE_REQS","SC_REQUIRED","SC_REQUIRED_ELSE_HELP","TAKES_VAL","TRAILING_VALUES","TRAILING_VARARG","UNIFIED_HELP","USE_DELIM","UTF8_NONE","UTF8_STRICT","VALID_ARG_FOUND","VALID_NEG_NUM_FOUND","VERSIONLESS_SC","WAIT_ON_ERROR","_is_char_boundary","app_debug_asserts","contains","contains_byte","contains_long","contains_short","debug_asserts","eq","has_args","has_flags","has_opts","has_positionals","has_subcommands","has_switch","has_visible_flags","has_visible_opts","has_visible_positionals","has_visible_subcommands","help_start","intersects","is_alias","is_all","is_bin_name","is_empty","is_missing_required_ok","is_new_arg","is_present","is_set","is_term_dumb","long_end","longest_filter","name_end","needs_flags_tag","needs_more_vals","starts","starts_with","takes_value","token","use_long_help","use_stderr","validate_arg_conflicts","validate_required_unless","verify_positionals"],"char":["short","val_delim"],"completions::ComplGen":["new"],"completions::bash::BashGen":["new"],"completions::elvish::ElvishGen":["new"],"completions::fish::FishGen":["new"],"completions::powershell::PowerShellGen":["new"],"completions::shell::Shell":["clone","from_str"],"completions::zsh::ZshGen":["new"],"errors::Error":["_help","_version","argument_conflict","argument_not_found_auto","empty_value","from","invalid_subcommand","invalid_utf8","invalid_value","io_error","missing_required_argument","missing_subcommand","too_few_values","too_many_values","unexpected_multiple_usage","unknown_argument","unrecognized_subcommand","value_validation","value_validation_auto","with_description","wrong_number_of_values"],"errors::ErrorKind":["clone"],"fmt::ColorWhen":["clone","color"],"fmt::Colorizer":["default","new"],"fmt::Format":["error","good","none","warning"],"osstringext::OsSplit":["clone","split"],"std::borrow::Cow":["name_no_brackets","value_of_lossy"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::collections::VecDeque":["get_required_usage_from"],"std::collections::hash_map::Entry":["entry"],"std::collections::hash_map::Iter":["iter"],"std::slice::Iter":["flags","opts","required","subcommands"],"std::string::String":["all_options_for_path","all_subcommands","create_error_usage","create_help_usage","create_smart_usage","create_usage_no_title","create_usage_with_title","escape_help","escape_string","escape_value","generate_inner","get_args_of","get_args_tag","get_subcommands_of","get_tooltip","option_details_for_path","spec_vals","subcommand_details","subcommands_of","val","vals_for","wrap_help","write_flags_of","write_opts_of","write_positionals_of"],"std::vec::Vec":["aliases","all_subcommand_names","all_subcommands","arg_names","arg_names_in_group","args_in_group","get_all_subcommand_paths","groups_for_arg","subcommands_of","values_of_lossy"],"u32":["bits"],"u64":["bits","max_vals","min_vals","num_vals","occurrences_of"],"usage_parser::UsageParser":["from_usage","new"],"usize":["copy_and_capture","disp_ord","index_of","next","next_back","str_width","to_usize"],"vec_map::Values":["default_vals_ifs","positionals"]},"struct_to_trait":{"<T as app::help::ArgWithDisplay<'b, 'c>>::T":["app::help::ArgWithDisplay"],"<T as app::help::ArgWithOrder<'b, 'c>>::T":["app::help::ArgWithOrder"],"app::App":["args::any_arg::AnyArg","args::any_arg::DispOrder","std::clone::Clone","std::fmt::Display"],"app::meta::AppMeta":["std::clone::Clone","std::default::Default"],"app::parser::ParseResult":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"app::parser::Parser":["std::clone::Clone","std::default::Default"],"app::settings::AppFlags":["std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq","std::ops::BitOr"],"app::settings::AppSettings":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq","std::str::FromStr"],"app::settings::Flags":["<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags","app::settings::Flags::all::__BitFlags","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Binary","std::fmt::Debug","std::fmt::LowerHex","std::fmt::Octal","std::fmt::UpperHex","std::hash::Hash","std::iter::Extend","std::iter::FromIterator","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::BitAnd","std::ops::BitAndAssign","std::ops::BitOr","std::ops::BitOrAssign","std::ops::BitXor","std::ops::BitXorAssign","std::ops::Not","std::ops::Sub","std::ops::SubAssign"],"args::arg::Arg":["std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::default::Default"],"args::arg_builder::base::Base":["std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::default::Default","std::fmt::Debug"],"args::arg_builder::flag::FlagBuilder":["args::any_arg::AnyArg","args::any_arg::DispOrder","std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display"],"args::arg_builder::option::OptBuilder":["args::any_arg::AnyArg","args::any_arg::DispOrder","std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::default::Default","std::fmt::Display"],"args::arg_builder::positional::PosBuilder":["args::any_arg::AnyArg","args::any_arg::DispOrder","std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Display"],"args::arg_builder::switched::Switched":["std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug"],"args::arg_builder::valued::Valued":["std::clone::Clone","std::convert::From","std::default::Default"],"args::arg_matcher::ArgMatcher":["std::convert::Into","std::default::Default"],"args::arg_matches::ArgMatches":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"args::arg_matches::Indices":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"args::arg_matches::OsValues":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"args::arg_matches::Values":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"args::group::ArgGroup":["std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug"],"args::matched_arg::MatchedArg":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"args::settings::ArgFlags":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::marker::Copy"],"args::settings::ArgSettings":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq","std::str::FromStr"],"args::settings::Flags":["<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags","args::settings::Flags::all::__BitFlags","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Binary","std::fmt::Debug","std::fmt::LowerHex","std::fmt::Octal","std::fmt::UpperHex","std::hash::Hash","std::iter::Extend","std::iter::FromIterator","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::BitAnd","std::ops::BitAndAssign","std::ops::BitOr","std::ops::BitOrAssign","std::ops::BitXor","std::ops::BitXorAssign","std::ops::Not","std::ops::Sub","std::ops::SubAssign"],"args::subcommand::SubCommand":["std::clone::Clone","std::fmt::Debug"],"completions::shell::Shell":["std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::str::FromStr"],"errors::Error":["std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display"],"errors::ErrorKind":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"fmt::ColorWhen":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"fmt::Colorizer":["std::default::Default"],"fmt::Format":["std::fmt::Debug","std::fmt::Display"],"osstringext::OsSplit":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"std::ffi::OsStr":["osstringext::OsStrExt2"],"usage_parser::UsageParser":["std::fmt::Debug"],"usage_parser::UsageToken":["std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"]},"targets":{"<&'z T as args::any_arg::AnyArg<'n, 'e>>::aliases":["aliases","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::blacklist":["blacklist","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::default_val":["default_val","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["default_vals_ifs","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::env":["env","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::has_switch":["has_switch","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::help":["help","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::is_set":["is_set","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::long":["long","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::long_help":["long_help","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["longest_filter","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::max_vals":["max_vals","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::min_vals":["min_vals","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::name":["name","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::num_vals":["num_vals","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::overrides":["overrides","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["possible_vals","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::required_unless":["required_unless","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::requires":["requires","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::set":["set","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::short":["short","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::takes_value":["takes_value","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::val_delim":["val_delim","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::val_names":["val_names","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["val_terminator","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::validator":["validator","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<&'z T as args::any_arg::AnyArg<'n, 'e>>::validator_os":["validator_os","Real(LocalPath(\"src/args/any_arg.rs\"))","args::any_arg::AnyArg"],"<T as app::help::ArgWithOrder<'b, 'c>>::as_base":["as_base","Real(LocalPath(\"src/app/help.rs\"))","app::help::ArgWithOrder"],"<app::App<'a, 'b> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/app/mod.rs\"))","std::clone::Clone"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["aliases","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["blacklist","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["default_val","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["default_vals_ifs","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["env","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["has_switch","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["help","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["is_set","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["long","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["long_help","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["longest_filter","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["max_vals","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["min_vals","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["name","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["num_vals","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["overrides","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["possible_vals","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["required_unless","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["requires","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["set","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["short","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["takes_value","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["val_delim","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["val_names","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["val_terminator","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["validator","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["validator_os","Real(LocalPath(\"src/app/mod.rs\"))","args::any_arg::AnyArg"],"<app::App<'n, 'e> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/app/mod.rs\"))","std::fmt::Display"],"<app::settings::AppFlags as std::default::Default>::default":["default","Real(LocalPath(\"src/app/settings.rs\"))","std::default::Default"],"<app::settings::AppFlags as std::ops::BitOr>::bitor":["bitor","Real(LocalPath(\"src/app/settings.rs\"))","std::ops::BitOr"],"<app::settings::AppSettings as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/app/settings.rs\"))","std::str::FromStr"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_MISSING_POS":["ALLOW_MISSING_POS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_NEG_NUMS":["ALLOW_NEG_NUMS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_UNK_SC":["ALLOW_UNK_SC","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ARGS_NEGATE_SCS":["ARGS_NEGATE_SCS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ARGS_OVERRIDE_SELF":["ARGS_OVERRIDE_SELF","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::A_REQUIRED_ELSE_HELP":["A_REQUIRED_ELSE_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLORED_HELP":["COLORED_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLOR_ALWAYS":["COLOR_ALWAYS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLOR_AUTO":["COLOR_AUTO","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::COLOR_NEVER":["COLOR_NEVER","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::CONTAINS_LAST":["CONTAINS_LAST","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DERIVE_DISP_ORDER":["DERIVE_DISP_ORDER","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DISABLE_HELP_FLAGS":["DISABLE_HELP_FLAGS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DISABLE_HELP_SC":["DISABLE_HELP_SC","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DISABLE_VERSION":["DISABLE_VERSION","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DONT_COLLAPSE_ARGS":["DONT_COLLAPSE_ARGS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DONT_DELIM_TRAIL":["DONT_DELIM_TRAIL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::GLOBAL_VERSION":["GLOBAL_VERSION","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN":["HIDDEN","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::INFER_SUBCOMMANDS":["INFER_SUBCOMMANDS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::LEADING_HYPHEN":["LEADING_HYPHEN","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::LOW_INDEX_MUL_POS":["LOW_INDEX_MUL_POS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEEDS_LONG_HELP":["NEEDS_LONG_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEEDS_LONG_VERSION":["NEEDS_LONG_VERSION","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEEDS_SC_HELP":["NEEDS_SC_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEXT_LINE_HELP":["NEXT_LINE_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NO_BIN_NAME":["NO_BIN_NAME","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NO_POS_VALUES":["NO_POS_VALUES","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::PROPAGATED":["PROPAGATED","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::PROPAGATE_VALS_DOWN":["PROPAGATE_VALS_DOWN","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::SC_NEGATE_REQS":["SC_NEGATE_REQS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::SC_REQUIRED":["SC_REQUIRED","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::SC_REQUIRED_ELSE_HELP":["SC_REQUIRED_ELSE_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::TRAILING_VALUES":["TRAILING_VALUES","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::TRAILING_VARARG":["TRAILING_VARARG","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::UNIFIED_HELP":["UNIFIED_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::UTF8_NONE":["UTF8_NONE","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::UTF8_STRICT":["UTF8_STRICT","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::VALID_ARG_FOUND":["VALID_ARG_FOUND","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::VALID_NEG_NUM_FOUND":["VALID_NEG_NUM_FOUND","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::VERSIONLESS_SC":["VERSIONLESS_SC","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as <app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::WAIT_ON_ERROR":["WAIT_ON_ERROR","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<app::settings::Flags as std::fmt::Binary>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Binary"],"<app::settings::Flags as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Debug"],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_MISSING_POS":["ALLOW_MISSING_POS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_NEG_NUMS":["ALLOW_NEG_NUMS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_UNK_SC":["ALLOW_UNK_SC","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ARGS_NEGATE_SCS":["ARGS_NEGATE_SCS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ARGS_OVERRIDE_SELF":["ARGS_OVERRIDE_SELF","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::A_REQUIRED_ELSE_HELP":["A_REQUIRED_ELSE_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLORED_HELP":["COLORED_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLOR_ALWAYS":["COLOR_ALWAYS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLOR_AUTO":["COLOR_AUTO","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::COLOR_NEVER":["COLOR_NEVER","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::CONTAINS_LAST":["CONTAINS_LAST","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DERIVE_DISP_ORDER":["DERIVE_DISP_ORDER","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DISABLE_HELP_FLAGS":["DISABLE_HELP_FLAGS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DISABLE_HELP_SC":["DISABLE_HELP_SC","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DISABLE_VERSION":["DISABLE_VERSION","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DONT_COLLAPSE_ARGS":["DONT_COLLAPSE_ARGS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DONT_DELIM_TRAIL":["DONT_DELIM_TRAIL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::GLOBAL_VERSION":["GLOBAL_VERSION","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN":["HIDDEN","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::INFER_SUBCOMMANDS":["INFER_SUBCOMMANDS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::LEADING_HYPHEN":["LEADING_HYPHEN","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::LOW_INDEX_MUL_POS":["LOW_INDEX_MUL_POS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEEDS_LONG_HELP":["NEEDS_LONG_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEEDS_LONG_VERSION":["NEEDS_LONG_VERSION","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEEDS_SC_HELP":["NEEDS_SC_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEXT_LINE_HELP":["NEXT_LINE_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NO_BIN_NAME":["NO_BIN_NAME","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NO_POS_VALUES":["NO_POS_VALUES","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::PROPAGATED":["PROPAGATED","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::PROPAGATE_VALS_DOWN":["PROPAGATE_VALS_DOWN","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::SC_NEGATE_REQS":["SC_NEGATE_REQS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::SC_REQUIRED":["SC_REQUIRED","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::SC_REQUIRED_ELSE_HELP":["SC_REQUIRED_ELSE_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::TRAILING_VALUES":["TRAILING_VALUES","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::TRAILING_VARARG":["TRAILING_VARARG","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::UNIFIED_HELP":["UNIFIED_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::UTF8_NONE":["UTF8_NONE","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::UTF8_STRICT":["UTF8_STRICT","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::VALID_ARG_FOUND":["VALID_ARG_FOUND","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::VALID_NEG_NUM_FOUND":["VALID_NEG_NUM_FOUND","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::VERSIONLESS_SC":["VERSIONLESS_SC","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::WAIT_ON_ERROR":["WAIT_ON_ERROR","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<app::settings::Flags as std::fmt::LowerHex>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::LowerHex"],"<app::settings::Flags as std::fmt::Octal>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Octal"],"<app::settings::Flags as std::fmt::UpperHex>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::UpperHex"],"<app::settings::Flags as std::iter::Extend<app::settings::Flags>>::extend":["extend","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::iter::Extend"],"<app::settings::Flags as std::iter::FromIterator<app::settings::Flags>>::from_iter":["from_iter","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::iter::FromIterator"],"<app::settings::Flags as std::ops::BitAnd>::bitand":["bitand","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitAnd"],"<app::settings::Flags as std::ops::BitAndAssign>::bitand_assign":["bitand_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitAndAssign"],"<app::settings::Flags as std::ops::BitOr>::bitor":["bitor","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitOr"],"<app::settings::Flags as std::ops::BitOrAssign>::bitor_assign":["bitor_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitOrAssign"],"<app::settings::Flags as std::ops::BitXor>::bitxor":["bitxor","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitXor"],"<app::settings::Flags as std::ops::BitXorAssign>::bitxor_assign":["bitxor_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitXorAssign"],"<app::settings::Flags as std::ops::Not>::not":["not","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::Not"],"<app::settings::Flags as std::ops::Sub>::sub":["sub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::Sub"],"<app::settings::Flags as std::ops::SubAssign>::sub_assign":["sub_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::SubAssign"],"<args::arg::Arg<'a, 'b> as std::convert::From<&'z args::arg::Arg<'a, 'b>>>::from":["from","Real(LocalPath(\"src/args/arg.rs\"))","std::convert::From"],"<args::arg::Arg<'n, 'e> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/args/arg.rs\"))","std::cmp::PartialEq"],"<args::arg_builder::base::Base<'n, 'e> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/args/arg_builder/base.rs\"))","std::cmp::PartialEq"],"<args::arg_builder::base::Base<'n, 'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["from","Real(LocalPath(\"src/args/arg_builder/base.rs\"))","std::convert::From"],"<args::arg_builder::flag::FlagBuilder<'a, 'b> as std::convert::From<&'z args::arg::Arg<'a, 'b>>>::from":["from","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","std::convert::From"],"<args::arg_builder::flag::FlagBuilder<'a, 'b> as std::convert::From<args::arg::Arg<'a, 'b>>>::from":["from","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","std::convert::From"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["aliases","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["blacklist","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["default_val","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["default_vals_ifs","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["env","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["has_switch","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["help","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["is_set","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["long","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["long_help","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["longest_filter","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["max_vals","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["min_vals","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["name","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["num_vals","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["overrides","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["possible_vals","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["required_unless","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["requires","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["set","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["short","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["takes_value","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["val_delim","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["val_names","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["val_terminator","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["validator","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["validator_os","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as args::any_arg::DispOrder>::disp_ord":["disp_ord","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","args::any_arg::DispOrder"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","std::cmp::PartialEq"],"<args::arg_builder::flag::FlagBuilder<'n, 'e> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))","std::fmt::Display"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["aliases","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["blacklist","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["default_val","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["default_vals_ifs","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["env","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["has_switch","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["help","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["is_set","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["long","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["long_help","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["longest_filter","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["max_vals","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["min_vals","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["name","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["num_vals","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["overrides","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["possible_vals","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["required_unless","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["requires","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["set","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["short","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["takes_value","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["val_delim","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["val_names","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["val_terminator","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["validator","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["validator_os","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::option::OptBuilder<'n, 'e> as args::any_arg::DispOrder>::disp_ord":["disp_ord","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","args::any_arg::DispOrder"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","std::cmp::PartialEq"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["from","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","std::convert::From"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::convert::From<args::arg::Arg<'n, 'e>>>::from":["from","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","std::convert::From"],"<args::arg_builder::option::OptBuilder<'n, 'e> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/args/arg_builder/option.rs\"))","std::fmt::Display"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::aliases":["aliases","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::blacklist":["blacklist","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_val":["default_val","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::default_vals_ifs":["default_vals_ifs","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::env":["env","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::has_switch":["has_switch","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::help":["help","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::is_set":["is_set","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long":["long","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::long_help":["long_help","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::longest_filter":["longest_filter","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::max_vals":["max_vals","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::min_vals":["min_vals","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::name":["name","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::num_vals":["num_vals","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::overrides":["overrides","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::possible_vals":["possible_vals","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::required_unless":["required_unless","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::requires":["requires","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::set":["set","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::short":["short","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::takes_value":["takes_value","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_delim":["val_delim","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_names":["val_names","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::val_terminator":["val_terminator","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator":["validator","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::AnyArg<'n, 'e>>::validator_os":["validator_os","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::AnyArg"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as args::any_arg::DispOrder>::disp_ord":["disp_ord","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","args::any_arg::DispOrder"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","std::cmp::PartialEq"],"<args::arg_builder::positional::PosBuilder<'n, 'e> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))","std::fmt::Display"],"<args::arg_builder::switched::Switched<'e> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/args/arg_builder/switched.rs\"))","std::clone::Clone"],"<args::arg_builder::switched::Switched<'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["from","Real(LocalPath(\"src/args/arg_builder/switched.rs\"))","std::convert::From"],"<args::arg_builder::switched::Switched<'e> as std::default::Default>::default":["default","Real(LocalPath(\"src/args/arg_builder/switched.rs\"))","std::default::Default"],"<args::arg_builder::valued::Valued<'n, 'e> as std::convert::From<&'z args::arg::Arg<'n, 'e>>>::from":["from","Real(LocalPath(\"src/args/arg_builder/valued.rs\"))","std::convert::From"],"<args::arg_builder::valued::Valued<'n, 'e> as std::default::Default>::default":["default","Real(LocalPath(\"src/args/arg_builder/valued.rs\"))","std::default::Default"],"<args::arg_matcher::ArgMatcher<'a> as std::convert::Into<args::arg_matches::ArgMatches<'a>>>::into":["into","Real(LocalPath(\"src/args/arg_matcher.rs\"))","std::convert::Into"],"<args::arg_matcher::ArgMatcher<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/args/arg_matcher.rs\"))","std::default::Default"],"<args::arg_matches::ArgMatches<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::default::Default"],"<args::arg_matches::Indices<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::default::Default"],"<args::arg_matches::Indices<'a> as std::default::Default>::default::to_usize":["to_usize","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"<args::arg_matches::Indices<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::iter::DoubleEndedIterator"],"<args::arg_matches::Indices<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::iter::Iterator"],"<args::arg_matches::Indices<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::iter::Iterator"],"<args::arg_matches::OsValues<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::default::Default"],"<args::arg_matches::OsValues<'a> as std::default::Default>::default::to_str_slice":["to_str_slice","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"<args::arg_matches::OsValues<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::iter::DoubleEndedIterator"],"<args::arg_matches::OsValues<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::iter::Iterator"],"<args::arg_matches::OsValues<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::iter::Iterator"],"<args::arg_matches::Values<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::default::Default"],"<args::arg_matches::Values<'a> as std::default::Default>::default::to_str_slice":["to_str_slice","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"<args::arg_matches::Values<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::iter::DoubleEndedIterator"],"<args::arg_matches::Values<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::iter::Iterator"],"<args::arg_matches::Values<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/args/arg_matches.rs\"))","std::iter::Iterator"],"<args::group::ArgGroup<'a> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/args/group.rs\"))","std::clone::Clone"],"<args::group::ArgGroup<'a> as std::convert::From<&'z args::group::ArgGroup<'a>>>::from":["from","Real(LocalPath(\"src/args/group.rs\"))","std::convert::From"],"<args::group::ArgGroup<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/args/group.rs\"))","std::fmt::Debug"],"<args::matched_arg::MatchedArg as std::default::Default>::default":["default","Real(LocalPath(\"src/args/matched_arg.rs\"))","std::default::Default"],"<args::settings::ArgFlags as std::default::Default>::default":["default","Real(LocalPath(\"src/args/settings.rs\"))","std::default::Default"],"<args::settings::ArgSettings as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/args/settings.rs\"))","std::str::FromStr"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::ALLOW_TAC_VALS":["ALLOW_TAC_VALS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::CASE_INSENSITIVE":["CASE_INSENSITIVE","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::DELIM_NOT_SET":["DELIM_NOT_SET","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::EMPTY_VALS":["EMPTY_VALS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::GLOBAL":["GLOBAL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN":["HIDDEN","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN_LONG_H":["HIDDEN_LONG_H","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDDEN_SHORT_H":["HIDDEN_SHORT_H","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDE_DEFAULT_VAL":["HIDE_DEFAULT_VAL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDE_ENV_VALS":["HIDE_ENV_VALS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::HIDE_POS_VALS":["HIDE_POS_VALS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::LAST":["LAST","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::MULTIPLE":["MULTIPLE","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::NEXT_LINE_HELP":["NEXT_LINE_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::REQUIRED":["REQUIRED","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::REQUIRE_EQUALS":["REQUIRE_EQUALS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::REQ_DELIM":["REQ_DELIM","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::R_UNLESS_ALL":["R_UNLESS_ALL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::TAKES_VAL":["TAKES_VAL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as <args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags>::USE_DELIM":["USE_DELIM","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags"],"<args::settings::Flags as std::fmt::Binary>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Binary"],"<args::settings::Flags as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Debug"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::ALLOW_TAC_VALS":["ALLOW_TAC_VALS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::CASE_INSENSITIVE":["CASE_INSENSITIVE","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::DELIM_NOT_SET":["DELIM_NOT_SET","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::EMPTY_VALS":["EMPTY_VALS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::GLOBAL":["GLOBAL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN":["HIDDEN","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN_LONG_H":["HIDDEN_LONG_H","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDDEN_SHORT_H":["HIDDEN_SHORT_H","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDE_DEFAULT_VAL":["HIDE_DEFAULT_VAL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDE_ENV_VALS":["HIDE_ENV_VALS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::HIDE_POS_VALS":["HIDE_POS_VALS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::LAST":["LAST","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::MULTIPLE":["MULTIPLE","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::NEXT_LINE_HELP":["NEXT_LINE_HELP","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::REQUIRED":["REQUIRED","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::REQUIRE_EQUALS":["REQUIRE_EQUALS","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::REQ_DELIM":["REQ_DELIM","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::R_UNLESS_ALL":["R_UNLESS_ALL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::TAKES_VAL":["TAKES_VAL","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags::USE_DELIM":["USE_DELIM","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"<args::settings::Flags as std::fmt::LowerHex>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::LowerHex"],"<args::settings::Flags as std::fmt::Octal>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::Octal"],"<args::settings::Flags as std::fmt::UpperHex>::fmt":["fmt","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::fmt::UpperHex"],"<args::settings::Flags as std::iter::Extend<args::settings::Flags>>::extend":["extend","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::iter::Extend"],"<args::settings::Flags as std::iter::FromIterator<args::settings::Flags>>::from_iter":["from_iter","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::iter::FromIterator"],"<args::settings::Flags as std::ops::BitAnd>::bitand":["bitand","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitAnd"],"<args::settings::Flags as std::ops::BitAndAssign>::bitand_assign":["bitand_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitAndAssign"],"<args::settings::Flags as std::ops::BitOr>::bitor":["bitor","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitOr"],"<args::settings::Flags as std::ops::BitOrAssign>::bitor_assign":["bitor_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitOrAssign"],"<args::settings::Flags as std::ops::BitXor>::bitxor":["bitxor","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitXor"],"<args::settings::Flags as std::ops::BitXorAssign>::bitxor_assign":["bitxor_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::BitXorAssign"],"<args::settings::Flags as std::ops::Not>::not":["not","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::Not"],"<args::settings::Flags as std::ops::Sub>::sub":["sub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::Sub"],"<args::settings::Flags as std::ops::SubAssign>::sub_assign":["sub_assign","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))","std::ops::SubAssign"],"<completions::shell::Shell as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/completions/shell.rs\"))","std::fmt::Display"],"<completions::shell::Shell as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/completions/shell.rs\"))","std::str::FromStr"],"<errors::Error as std::convert::From<std::fmt::Error>>::from":["from","Real(LocalPath(\"src/errors.rs\"))","std::convert::From"],"<errors::Error as std::convert::From<std::io::Error>>::from":["from","Real(LocalPath(\"src/errors.rs\"))","std::convert::From"],"<errors::Error as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<fmt::Colorizer as std::default::Default>::default":["default","Real(LocalPath(\"src/fmt.rs\"))","std::default::Default"],"<fmt::Format<T> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/fmt.rs\"))","std::fmt::Display"],"<osstringext::OsSplit<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/osstringext.rs\"))","std::iter::Iterator"],"<std::ffi::OsStr as osstringext::OsStrExt2>::contains_byte":["contains_byte","Real(LocalPath(\"src/osstringext.rs\"))","osstringext::OsStrExt2"],"<std::ffi::OsStr as osstringext::OsStrExt2>::split":["split","Real(LocalPath(\"src/osstringext.rs\"))","osstringext::OsStrExt2"],"<std::ffi::OsStr as osstringext::OsStrExt2>::split_at":["split_at","Real(LocalPath(\"src/osstringext.rs\"))","osstringext::OsStrExt2"],"<std::ffi::OsStr as osstringext::OsStrExt2>::split_at_byte":["split_at_byte","Real(LocalPath(\"src/osstringext.rs\"))","osstringext::OsStrExt2"],"<std::ffi::OsStr as osstringext::OsStrExt2>::starts_with":["starts_with","Real(LocalPath(\"src/osstringext.rs\"))","osstringext::OsStrExt2"],"<std::ffi::OsStr as osstringext::OsStrExt2>::trim_left_matches":["trim_left_matches","Real(LocalPath(\"src/osstringext.rs\"))","osstringext::OsStrExt2"],"<str as strext::_StrExt>::_is_char_boundary":["_is_char_boundary","Real(LocalPath(\"src/strext.rs\"))","strext::_StrExt"],"app::App::<'a, 'b>::about":["about","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::after_help":["after_help","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::alias":["alias","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::aliases":["aliases","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::arg":["arg","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::arg_from_usage":["arg_from_usage","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::args":["args","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::args_from_usage":["args_from_usage","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::author":["author","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::before_help":["before_help","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::bin_name":["bin_name","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::display_order":["display_order","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::gen_completions":["gen_completions","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::gen_completions_to":["gen_completions_to","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::get_bin_name":["get_bin_name","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::get_matches":["get_matches","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::get_matches_from":["get_matches_from","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::get_matches_from_safe":["get_matches_from_safe","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::get_matches_from_safe_borrow":["get_matches_from_safe_borrow","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::get_matches_safe":["get_matches_safe","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::get_name":["get_name","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::global_setting":["global_setting","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::global_settings":["global_settings","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::group":["group","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::groups":["groups","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::help":["help","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::help_message":["help_message","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::help_short":["help_short","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::long_about":["long_about","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::long_version":["long_version","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::max_term_width":["max_term_width","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::name":["name","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::new":["new","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::print_help":["print_help","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::print_long_help":["print_long_help","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::set_term_width":["set_term_width","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::setting":["setting","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::settings":["settings","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::subcommand":["subcommand","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::subcommands":["subcommands","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::template":["template","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::unset_setting":["unset_setting","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::unset_settings":["unset_settings","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::usage":["usage","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::version":["version","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::version_message":["version_message","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::version_short":["version_short","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::visible_alias":["visible_alias","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::visible_aliases":["visible_aliases","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::with_defaults":["with_defaults","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::write_help":["write_help","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::write_long_help":["write_long_help","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::write_long_version":["write_long_version","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::App::<'a, 'b>::write_version":["write_version","Real(LocalPath(\"src/app/mod.rs\"))",""],"app::help::<impl args::any_arg::DispOrder for app::App<'b, 'c>>::disp_ord":["disp_ord","Real(LocalPath(\"src/app/help.rs\"))","args::any_arg::DispOrder"],"app::help::Help::<'a>::_write_parser_help":["_write_parser_help","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::help":["help","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::long":["long","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::new":["new","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::short":["short","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::spec_vals":["spec_vals","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::val":["val","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_all_args":["write_all_args","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_app_help":["write_app_help","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_arg":["write_arg","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_args":["write_args","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_args_unsorted":["write_args_unsorted","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_before_after_help":["write_before_after_help","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_bin_name":["write_bin_name","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_default_help":["write_default_help","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_help":["write_help","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_parser_help":["write_parser_help","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_parser_help_to_stderr":["write_parser_help_to_stderr","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_subcommands":["write_subcommands","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_templated_help":["write_templated_help","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::Help::<'a>::write_version":["write_version","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::as_arg_trait":["as_arg_trait","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::copy_and_capture":["copy_and_capture","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::copy_until":["copy_until","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::should_show_arg":["should_show_arg","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::str_width":["str_width","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::term_size::dimensions":["dimensions","Real(LocalPath(\"src/app/help.rs\"))",""],"app::help::wrap_help":["wrap_help","Real(LocalPath(\"src/app/help.rs\"))",""],"app::meta::AppMeta::<'b>::new":["new","Real(LocalPath(\"src/app/meta.rs\"))",""],"app::meta::AppMeta::<'b>::with_name":["with_name","Real(LocalPath(\"src/app/meta.rs\"))",""],"app::parser::Parser::<'a, 'b>::_help":["_help","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::_version":["_version","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::add_arg":["add_arg","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::add_arg_groups":["add_arg_groups","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::add_arg_ref":["add_arg_ref","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::add_conditional_reqs":["add_conditional_reqs","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::add_defaults":["add_defaults","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::add_env":["add_env","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::add_group":["add_group","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::add_reqs":["add_reqs","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::add_single_val_to_arg":["add_single_val_to_arg","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::add_subcommand":["add_subcommand","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::add_val_to_arg":["add_val_to_arg","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::app_debug_asserts":["app_debug_asserts","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::arg_names_in_group":["arg_names_in_group","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::args_in_group":["args_in_group","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::build_bin_names":["build_bin_names","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::check_for_help_and_version_char":["check_for_help_and_version_char","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::check_for_help_and_version_str":["check_for_help_and_version_str","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::color":["color","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::contains_long":["contains_long","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::contains_short":["contains_short","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::create_help_and_version":["create_help_and_version","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::debug_asserts":["debug_asserts","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::derive_display_order":["derive_display_order","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::did_you_mean_error":["did_you_mean_error","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::find_any_arg":["find_any_arg","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::find_subcommand":["find_subcommand","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::flags":["flags","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::gen_completions":["gen_completions","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::gen_completions_to":["gen_completions_to","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::get_matches_with":["get_matches_with","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::get_matches_with::as_trait_obj":["as_trait_obj","Real(LocalPath(\"src/macros.rs\"))",""],"app::parser::Parser::<'a, 'b>::groups_for_arg":["groups_for_arg","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::has_args":["has_args","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::has_flags":["has_flags","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::has_opts":["has_opts","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::has_positionals":["has_positionals","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::has_subcommands":["has_subcommands","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::has_visible_flags":["has_visible_flags","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::has_visible_opts":["has_visible_opts","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::has_visible_positionals":["has_visible_positionals","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::has_visible_subcommands":["has_visible_subcommands","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::help_short":["help_short","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::implied_settings":["implied_settings","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::is_alias":["is_alias","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::is_bin_name":["is_bin_name","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::is_new_arg":["is_new_arg","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::is_set":["is_set","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::opts":["opts","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::parse_flag":["parse_flag","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::parse_help_subcommand":["parse_help_subcommand","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::parse_long_arg":["parse_long_arg","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::parse_opt":["parse_opt","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::parse_short_arg":["parse_short_arg","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::parse_subcommand":["parse_subcommand","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::positionals":["positionals","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::possible_subcommand":["possible_subcommand","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::possible_subcommand::starts":["starts","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::print_help":["print_help","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::print_version":["print_version","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::propagate_globals":["propagate_globals","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::propagate_help_version":["propagate_help_version","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::propagate_settings":["propagate_settings","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::remove_overrides":["remove_overrides","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::required":["required","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::set":["set","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::subcommands":["subcommands","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::unset":["unset","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::use_long_help":["use_long_help","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::verify_positionals":["verify_positionals","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::version_short":["version_short","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::with_name":["with_name","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::write_help":["write_help","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::write_help_err":["write_help_err","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::write_long_help":["write_long_help","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::parser::Parser::<'a, 'b>::write_version":["write_version","Real(LocalPath(\"src/app/parser.rs\"))",""],"app::settings::AppFlags::is_set":["is_set","Real(LocalPath(\"src/macros.rs\"))",""],"app::settings::AppFlags::new":["new","Real(LocalPath(\"src/app/settings.rs\"))",""],"app::settings::AppFlags::set":["set","Real(LocalPath(\"src/macros.rs\"))",""],"app::settings::AppFlags::unset":["unset","Real(LocalPath(\"src/macros.rs\"))",""],"app::settings::AppFlags::zeroed":["zeroed","Real(LocalPath(\"src/app/settings.rs\"))",""],"app::settings::Flags::all":["all","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::bits":["bits","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::complement":["complement","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::contains":["contains","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::difference":["difference","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::empty":["empty","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::from_bits":["from_bits","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::from_bits_truncate":["from_bits_truncate","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::from_bits_unchecked":["from_bits_unchecked","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::insert":["insert","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::intersection":["intersection","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::intersects":["intersects","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::is_all":["is_all","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::is_empty":["is_empty","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::remove":["remove","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::set":["set","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::symmetric_difference":["symmetric_difference","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::toggle":["toggle","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::settings::Flags::union":["union","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"app::usage::create_error_usage":["create_error_usage","Real(LocalPath(\"src/app/usage.rs\"))",""],"app::usage::create_help_usage":["create_help_usage","Real(LocalPath(\"src/app/usage.rs\"))",""],"app::usage::create_smart_usage":["create_smart_usage","Real(LocalPath(\"src/app/usage.rs\"))",""],"app::usage::create_usage_no_title":["create_usage_no_title","Real(LocalPath(\"src/app/usage.rs\"))",""],"app::usage::create_usage_with_title":["create_usage_with_title","Real(LocalPath(\"src/app/usage.rs\"))",""],"app::usage::get_args_tag":["get_args_tag","Real(LocalPath(\"src/app/usage.rs\"))",""],"app::usage::get_required_usage_from":["get_required_usage_from","Real(LocalPath(\"src/app/usage.rs\"))",""],"app::usage::needs_flags_tag":["needs_flags_tag","Real(LocalPath(\"src/app/usage.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::build_err":["build_err","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::is_missing_required_ok":["is_missing_required_ok","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::missing_required_error":["missing_required_error","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::new":["new","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate":["validate","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_conflicts":["validate_arg_conflicts","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_num_occurs":["validate_arg_num_occurs","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_num_vals":["validate_arg_num_vals","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_requires":["validate_arg_requires","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate_arg_values":["validate_arg_values","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate_blacklist":["validate_blacklist","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate_blacklist::as_trait_obj":["as_trait_obj","Real(LocalPath(\"src/macros.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate_matched_args":["validate_matched_args","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate_required":["validate_required","Real(LocalPath(\"src/app/validator.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate_required::as_trait_obj":["as_trait_obj","Real(LocalPath(\"src/macros.rs\"))",""],"app::validator::Validator::<'a, 'b, 'z>::validate_required_unless":["validate_required_unless","Real(LocalPath(\"src/app/validator.rs\"))",""],"args::arg::Arg::<'a, 'b>::alias":["alias","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::aliases":["aliases","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::allow_hyphen_values":["allow_hyphen_values","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::case_insensitive":["case_insensitive","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::conflicts_with":["conflicts_with","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::conflicts_with_all":["conflicts_with_all","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::default_value":["default_value","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::default_value_if":["default_value_if","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::default_value_if_os":["default_value_if_os","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::default_value_ifs":["default_value_ifs","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::default_value_ifs_os":["default_value_ifs_os","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::default_value_os":["default_value_os","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::display_order":["display_order","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::empty_values":["empty_values","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::env":["env","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::env_os":["env_os","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::from_usage":["from_usage","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::global":["global","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::group":["group","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::groups":["groups","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::help":["help","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::hidden":["hidden","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::hidden_long_help":["hidden_long_help","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::hidden_short_help":["hidden_short_help","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::hide_default_value":["hide_default_value","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::hide_env_values":["hide_env_values","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::hide_possible_values":["hide_possible_values","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::index":["index","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::is_set":["is_set","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::last":["last","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::long":["long","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::long_help":["long_help","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::max_values":["max_values","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::min_values":["min_values","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::multiple":["multiple","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::next_line_help":["next_line_help","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::number_of_values":["number_of_values","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::overrides_with":["overrides_with","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::overrides_with_all":["overrides_with_all","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::possible_value":["possible_value","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::possible_values":["possible_values","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::raw":["raw","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::require_delimiter":["require_delimiter","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::require_equals":["require_equals","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::required":["required","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::required_if":["required_if","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::required_ifs":["required_ifs","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::required_unless":["required_unless","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::required_unless_all":["required_unless_all","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::required_unless_one":["required_unless_one","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::requires":["requires","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::requires_all":["requires_all","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::requires_if":["requires_if","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::requires_ifs":["requires_ifs","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::set":["set","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::setb":["setb","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::short":["short","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::takes_value":["takes_value","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::unset":["unset","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::unsetb":["unsetb","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::use_delimiter":["use_delimiter","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::validator":["validator","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::validator_os":["validator_os","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::value_delimiter":["value_delimiter","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::value_name":["value_name","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::value_names":["value_names","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::value_terminator":["value_terminator","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::visible_alias":["visible_alias","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::visible_aliases":["visible_aliases","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg::Arg::<'a, 'b>::with_name":["with_name","Real(LocalPath(\"src/args/arg.rs\"))",""],"args::arg_builder::base::Base::<'n, 'e>::is_set":["is_set","Real(LocalPath(\"src/args/arg_builder/base.rs\"))",""],"args::arg_builder::base::Base::<'n, 'e>::new":["new","Real(LocalPath(\"src/args/arg_builder/base.rs\"))",""],"args::arg_builder::base::Base::<'n, 'e>::set":["set","Real(LocalPath(\"src/args/arg_builder/base.rs\"))",""],"args::arg_builder::base::Base::<'n, 'e>::unset":["unset","Real(LocalPath(\"src/args/arg_builder/base.rs\"))",""],"args::arg_builder::flag::FlagBuilder::<'n, 'e>::new":["new","Real(LocalPath(\"src/args/arg_builder/flag.rs\"))",""],"args::arg_builder::option::OptBuilder::<'n, 'e>::new":["new","Real(LocalPath(\"src/args/arg_builder/option.rs\"))",""],"args::arg_builder::positional::PosBuilder::<'n, 'e>::from_arg":["from_arg","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))",""],"args::arg_builder::positional::PosBuilder::<'n, 'e>::from_arg_ref":["from_arg_ref","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))",""],"args::arg_builder::positional::PosBuilder::<'n, 'e>::multiple_str":["multiple_str","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))",""],"args::arg_builder::positional::PosBuilder::<'n, 'e>::name_no_brackets":["name_no_brackets","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))",""],"args::arg_builder::positional::PosBuilder::<'n, 'e>::new":["new","Real(LocalPath(\"src/args/arg_builder/positional.rs\"))",""],"args::arg_builder::valued::Valued::<'n, 'e>::fill_in":["fill_in","Real(LocalPath(\"src/args/arg_builder/valued.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::add_index_to":["add_index_to","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::add_val_to":["add_val_to","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::arg_names":["arg_names","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::contains":["contains","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::entry":["entry","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::fill_in_global_values":["fill_in_global_values","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::get":["get","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::get_mut":["get_mut","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::handle_self_overrides":["handle_self_overrides","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::inc_occurrence_of":["inc_occurrence_of","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::inc_occurrences_of":["inc_occurrences_of","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::insert":["insert","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::is_empty":["is_empty","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::is_present":["is_present","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::iter":["iter","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::needs_more_vals":["needs_more_vals","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::new":["new","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::process_arg_overrides":["process_arg_overrides","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::propagate_globals":["propagate_globals","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::remove":["remove","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::remove_all":["remove_all","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::subcommand":["subcommand","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::subcommand_name":["subcommand_name","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matcher::ArgMatcher::<'a>::usage":["usage","Real(LocalPath(\"src/args/arg_matcher.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::index_of":["index_of","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::indices_of":["indices_of","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::indices_of::to_usize":["to_usize","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::is_present":["is_present","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::new":["new","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::occurrences_of":["occurrences_of","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::subcommand":["subcommand","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::subcommand_matches":["subcommand_matches","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::subcommand_name":["subcommand_name","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::usage":["usage","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::value_of":["value_of","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::value_of_lossy":["value_of_lossy","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::value_of_os":["value_of_os","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::values_of":["values_of","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::values_of::to_str_slice":["to_str_slice","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::values_of_lossy":["values_of_lossy","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::values_of_os":["values_of_os","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::arg_matches::ArgMatches::<'a>::values_of_os::to_str_slice":["to_str_slice","Real(LocalPath(\"src/args/arg_matches.rs\"))",""],"args::group::ArgGroup::<'a>::arg":["arg","Real(LocalPath(\"src/args/group.rs\"))",""],"args::group::ArgGroup::<'a>::args":["args","Real(LocalPath(\"src/args/group.rs\"))",""],"args::group::ArgGroup::<'a>::conflicts_with":["conflicts_with","Real(LocalPath(\"src/args/group.rs\"))",""],"args::group::ArgGroup::<'a>::conflicts_with_all":["conflicts_with_all","Real(LocalPath(\"src/args/group.rs\"))",""],"args::group::ArgGroup::<'a>::multiple":["multiple","Real(LocalPath(\"src/args/group.rs\"))",""],"args::group::ArgGroup::<'a>::required":["required","Real(LocalPath(\"src/args/group.rs\"))",""],"args::group::ArgGroup::<'a>::requires":["requires","Real(LocalPath(\"src/args/group.rs\"))",""],"args::group::ArgGroup::<'a>::requires_all":["requires_all","Real(LocalPath(\"src/args/group.rs\"))",""],"args::group::ArgGroup::<'a>::with_name":["with_name","Real(LocalPath(\"src/args/group.rs\"))",""],"args::matched_arg::MatchedArg::new":["new","Real(LocalPath(\"src/args/matched_arg.rs\"))",""],"args::settings::ArgFlags::is_set":["is_set","Real(LocalPath(\"src/macros.rs\"))",""],"args::settings::ArgFlags::new":["new","Real(LocalPath(\"src/args/settings.rs\"))",""],"args::settings::ArgFlags::set":["set","Real(LocalPath(\"src/macros.rs\"))",""],"args::settings::ArgFlags::unset":["unset","Real(LocalPath(\"src/macros.rs\"))",""],"args::settings::Flags::all":["all","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::bits":["bits","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::complement":["complement","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::contains":["contains","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::difference":["difference","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::empty":["empty","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::from_bits":["from_bits","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::from_bits_truncate":["from_bits_truncate","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::from_bits_unchecked":["from_bits_unchecked","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::insert":["insert","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::intersection":["intersection","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::intersects":["intersects","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::is_all":["is_all","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::is_empty":["is_empty","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::remove":["remove","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::set":["set","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::symmetric_difference":["symmetric_difference","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::toggle":["toggle","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::settings::Flags::union":["union","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs\"))",""],"args::subcommand::SubCommand::<'a>::with_name":["with_name","Real(LocalPath(\"src/args/subcommand.rs\"))",""],"completions::ComplGen::<'a, 'b>::generate":["generate","Real(LocalPath(\"src/completions/mod.rs\"))",""],"completions::ComplGen::<'a, 'b>::new":["new","Real(LocalPath(\"src/completions/mod.rs\"))",""],"completions::all_subcommand_names":["all_subcommand_names","Real(LocalPath(\"src/completions/mod.rs\"))",""],"completions::all_subcommands":["all_subcommands","Real(LocalPath(\"src/completions/mod.rs\"))",""],"completions::bash::BashGen::<'a, 'b>::all_options_for_path":["all_options_for_path","Real(LocalPath(\"src/completions/bash.rs\"))",""],"completions::bash::BashGen::<'a, 'b>::all_subcommands":["all_subcommands","Real(LocalPath(\"src/completions/bash.rs\"))",""],"completions::bash::BashGen::<'a, 'b>::generate_to":["generate_to","Real(LocalPath(\"src/completions/bash.rs\"))",""],"completions::bash::BashGen::<'a, 'b>::new":["new","Real(LocalPath(\"src/completions/bash.rs\"))",""],"completions::bash::BashGen::<'a, 'b>::option_details_for_path":["option_details_for_path","Real(LocalPath(\"src/completions/bash.rs\"))",""],"completions::bash::BashGen::<'a, 'b>::subcommand_details":["subcommand_details","Real(LocalPath(\"src/completions/bash.rs\"))",""],"completions::bash::BashGen::<'a, 'b>::vals_for":["vals_for","Real(LocalPath(\"src/completions/bash.rs\"))",""],"completions::elvish::ElvishGen::<'a, 'b>::generate_to":["generate_to","Real(LocalPath(\"src/completions/elvish.rs\"))",""],"completions::elvish::ElvishGen::<'a, 'b>::new":["new","Real(LocalPath(\"src/completions/elvish.rs\"))",""],"completions::elvish::escape_string":["escape_string","Real(LocalPath(\"src/completions/elvish.rs\"))",""],"completions::elvish::generate_inner":["generate_inner","Real(LocalPath(\"src/completions/elvish.rs\"))",""],"completions::elvish::get_tooltip":["get_tooltip","Real(LocalPath(\"src/completions/elvish.rs\"))",""],"completions::fish::FishGen::<'a, 'b>::generate_to":["generate_to","Real(LocalPath(\"src/completions/fish.rs\"))",""],"completions::fish::FishGen::<'a, 'b>::new":["new","Real(LocalPath(\"src/completions/fish.rs\"))",""],"completions::fish::escape_string":["escape_string","Real(LocalPath(\"src/completions/fish.rs\"))",""],"completions::fish::gen_fish_inner":["gen_fish_inner","Real(LocalPath(\"src/completions/fish.rs\"))",""],"completions::get_all_subcommand_paths":["get_all_subcommand_paths","Real(LocalPath(\"src/completions/mod.rs\"))",""],"completions::powershell::PowerShellGen::<'a, 'b>::generate_to":["generate_to","Real(LocalPath(\"src/completions/powershell.rs\"))",""],"completions::powershell::PowerShellGen::<'a, 'b>::new":["new","Real(LocalPath(\"src/completions/powershell.rs\"))",""],"completions::powershell::escape_string":["escape_string","Real(LocalPath(\"src/completions/powershell.rs\"))",""],"completions::powershell::generate_inner":["generate_inner","Real(LocalPath(\"src/completions/powershell.rs\"))",""],"completions::powershell::get_tooltip":["get_tooltip","Real(LocalPath(\"src/completions/powershell.rs\"))",""],"completions::shell::Shell::variants":["variants","Real(LocalPath(\"src/completions/shell.rs\"))",""],"completions::subcommands_of":["subcommands_of","Real(LocalPath(\"src/completions/mod.rs\"))",""],"completions::zsh::ZshGen::<'a, 'b>::generate_to":["generate_to","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::ZshGen::<'a, 'b>::new":["new","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::escape_help":["escape_help","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::escape_value":["escape_value","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::get_args_of":["get_args_of","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::get_subcommands_of":["get_subcommands_of","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::parser_of":["parser_of","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::subcommand_details":["subcommand_details","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::subcommands_of":["subcommands_of","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::subcommands_of::add_sc":["add_sc","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::write_flags_of":["write_flags_of","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::write_opts_of":["write_opts_of","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"completions::zsh::write_positionals_of":["write_positionals_of","Real(LocalPath(\"src/completions/zsh.rs\"))",""],"errors::Error::argument_conflict":["argument_conflict","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::argument_not_found_auto":["argument_not_found_auto","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::empty_value":["empty_value","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::exit":["exit","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::invalid_subcommand":["invalid_subcommand","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::invalid_utf8":["invalid_utf8","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::invalid_value":["invalid_value","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::io_error":["io_error","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::missing_required_argument":["missing_required_argument","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::missing_subcommand":["missing_subcommand","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::too_few_values":["too_few_values","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::too_many_values":["too_many_values","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::unexpected_multiple_usage":["unexpected_multiple_usage","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::unknown_argument":["unknown_argument","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::unrecognized_subcommand":["unrecognized_subcommand","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::use_stderr":["use_stderr","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::value_validation":["value_validation","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::value_validation_auto":["value_validation_auto","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::with_description":["with_description","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::write_to":["write_to","Real(LocalPath(\"src/errors.rs\"))",""],"errors::Error::wrong_number_of_values":["wrong_number_of_values","Real(LocalPath(\"src/errors.rs\"))",""],"fmt::Colorizer::error":["error","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Colorizer::good":["good","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Colorizer::new":["new","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Colorizer::none":["none","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Colorizer::warning":["warning","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::Format::<T>::format":["format","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::is_a_tty":["is_a_tty","Real(LocalPath(\"src/fmt.rs\"))",""],"fmt::is_term_dumb":["is_term_dumb","Real(LocalPath(\"src/fmt.rs\"))",""],"suggestions::did_you_mean":["did_you_mean","Real(LocalPath(\"src/suggestions.rs\"))",""],"suggestions::did_you_mean_flag_suffix":["did_you_mean_flag_suffix","Real(LocalPath(\"src/suggestions.rs\"))",""],"suggestions::did_you_mean_value_suffix":["did_you_mean_value_suffix","Real(LocalPath(\"src/suggestions.rs\"))",""],"usage_parser::UsageParser::<'a>::from_usage":["from_usage","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::UsageParser::<'a>::help":["help","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::UsageParser::<'a>::long":["long","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::UsageParser::<'a>::multiple":["multiple","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::UsageParser::<'a>::name":["name","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::UsageParser::<'a>::new":["new","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::UsageParser::<'a>::parse":["parse","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::UsageParser::<'a>::short":["short","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::UsageParser::<'a>::short_or_long":["short_or_long","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::UsageParser::<'a>::stop_at":["stop_at","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::help_start":["help_start","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::long_end":["long_end","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::name_end":["name_end","Real(LocalPath(\"src/usage_parser.rs\"))",""],"usage_parser::token":["token","Real(LocalPath(\"src/usage_parser.rs\"))",""]},"trait_to_struct":{"<app::settings::Flags as std::fmt::Debug>::fmt::__BitFlags":["app::settings::Flags"],"<args::settings::Flags as std::fmt::Debug>::fmt::__BitFlags":["args::settings::Flags"],"app::help::ArgWithDisplay":["<T as app::help::ArgWithDisplay<'b, 'c>>::T"],"app::help::ArgWithOrder":["<T as app::help::ArgWithOrder<'b, 'c>>::T"],"app::settings::Flags::all::__BitFlags":["app::settings::Flags"],"args::any_arg::AnyArg":["app::App","args::arg_builder::flag::FlagBuilder","args::arg_builder::option::OptBuilder","args::arg_builder::positional::PosBuilder"],"args::any_arg::DispOrder":["app::App","args::arg_builder::flag::FlagBuilder","args::arg_builder::option::OptBuilder","args::arg_builder::positional::PosBuilder"],"args::settings::Flags::all::__BitFlags":["args::settings::Flags"],"osstringext::OsStrExt2":["std::ffi::OsStr"],"std::clone::Clone":["app::App","app::meta::AppMeta","app::parser::ParseResult","app::parser::Parser","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::option::OptBuilder","args::arg_builder::positional::PosBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::arg_matches::ArgMatches","args::arg_matches::Indices","args::arg_matches::OsValues","args::arg_matches::Values","args::group::ArgGroup","args::matched_arg::MatchedArg","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","args::subcommand::SubCommand","completions::shell::Shell","errors::ErrorKind","fmt::ColorWhen","osstringext::OsSplit"],"std::cmp::Eq":["app::settings::Flags","args::settings::Flags"],"std::cmp::Ord":["app::settings::Flags","args::settings::Flags"],"std::cmp::PartialEq":["app::parser::ParseResult","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::option::OptBuilder","args::arg_builder::positional::PosBuilder","args::settings::ArgSettings","args::settings::Flags","errors::ErrorKind","fmt::ColorWhen","usage_parser::UsageToken"],"std::cmp::PartialOrd":["app::settings::Flags","args::settings::Flags"],"std::convert::From":["args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::option::OptBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::group::ArgGroup","errors::Error"],"std::convert::Into":["args::arg_matcher::ArgMatcher"],"std::default::Default":["app::meta::AppMeta","app::parser::Parser","app::settings::AppFlags","args::arg::Arg","args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::option::OptBuilder","args::arg_builder::positional::PosBuilder","args::arg_builder::switched::Switched","args::arg_builder::valued::Valued","args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches","args::arg_matches::Indices","args::arg_matches::OsValues","args::arg_matches::Values","args::group::ArgGroup","args::matched_arg::MatchedArg","args::settings::ArgFlags","fmt::Colorizer"],"std::error::Error":["errors::Error"],"std::fmt::Binary":["app::settings::Flags","args::settings::Flags"],"std::fmt::Debug":["app::parser::ParseResult","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder","args::arg_builder::switched::Switched","args::arg_matches::ArgMatches","args::arg_matches::Indices","args::arg_matches::OsValues","args::arg_matches::Values","args::group::ArgGroup","args::matched_arg::MatchedArg","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","args::subcommand::SubCommand","completions::shell::Shell","errors::Error","errors::ErrorKind","fmt::ColorWhen","fmt::Format","osstringext::OsSplit","usage_parser::UsageParser","usage_parser::UsageToken"],"std::fmt::Display":["app::App","args::arg_builder::flag::FlagBuilder","args::arg_builder::option::OptBuilder","args::arg_builder::positional::PosBuilder","completions::shell::Shell","errors::Error","fmt::Format"],"std::fmt::LowerHex":["app::settings::Flags","args::settings::Flags"],"std::fmt::Octal":["app::settings::Flags","args::settings::Flags"],"std::fmt::UpperHex":["app::settings::Flags","args::settings::Flags"],"std::hash::Hash":["app::settings::Flags","args::settings::Flags"],"std::iter::DoubleEndedIterator":["args::arg_matches::Indices","args::arg_matches::OsValues","args::arg_matches::Values"],"std::iter::ExactSizeIterator":["args::arg_matches::Indices","args::arg_matches::OsValues","args::arg_matches::Values"],"std::iter::Extend":["app::settings::Flags","args::settings::Flags"],"std::iter::FromIterator":["app::settings::Flags","args::settings::Flags"],"std::iter::Iterator":["args::arg_matches::Indices","args::arg_matches::OsValues","args::arg_matches::Values","osstringext::OsSplit"],"std::marker::Copy":["app::parser::ParseResult","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","args::settings::ArgFlags","args::settings::ArgSettings","args::settings::Flags","completions::shell::Shell","errors::ErrorKind","fmt::ColorWhen"],"std::marker::StructuralEq":["app::settings::Flags","args::settings::Flags"],"std::marker::StructuralPartialEq":["app::parser::ParseResult","app::settings::AppFlags","app::settings::AppSettings","app::settings::Flags","args::settings::ArgSettings","args::settings::Flags","errors::ErrorKind","fmt::ColorWhen","usage_parser::UsageToken"],"std::ops::BitAnd":["app::settings::Flags","args::settings::Flags"],"std::ops::BitAndAssign":["app::settings::Flags","args::settings::Flags"],"std::ops::BitOr":["app::settings::AppFlags","app::settings::Flags","args::settings::Flags"],"std::ops::BitOrAssign":["app::settings::Flags","args::settings::Flags"],"std::ops::BitXor":["app::settings::Flags","args::settings::Flags"],"std::ops::BitXorAssign":["app::settings::Flags","args::settings::Flags"],"std::ops::Not":["app::settings::Flags","args::settings::Flags"],"std::ops::Sub":["app::settings::Flags","args::settings::Flags"],"std::ops::SubAssign":["app::settings::Flags","args::settings::Flags"],"std::str::FromStr":["app::settings::AppSettings","args::settings::ArgSettings","completions::shell::Shell"]},"type_to_def_path":{"app::App<'a, 'b>":"app::App","app::help::CopyUntilResult":"app::help::CopyUntilResult","app::help::Help<'a>":"app::help::Help","app::meta::AppMeta<'b>":"app::meta::AppMeta","app::parser::ParseResult<'a>":"app::parser::ParseResult","app::parser::Parser<'a, 'b>":"app::parser::Parser","app::settings::AppFlags":"app::settings::AppFlags","app::settings::AppSettings":"app::settings::AppSettings","app::settings::Flags":"app::settings::Flags","app::validator::Validator<'a, 'b, 'z>":"app::validator::Validator","args::arg::Arg<'a, 'b>":"args::arg::Arg","args::arg_builder::base::Base<'a, 'b>":"args::arg_builder::base::Base","args::arg_builder::flag::FlagBuilder<'n, 'e>":"args::arg_builder::flag::FlagBuilder","args::arg_builder::option::OptBuilder<'n, 'e>":"args::arg_builder::option::OptBuilder","args::arg_builder::positional::PosBuilder<'n, 'e>":"args::arg_builder::positional::PosBuilder","args::arg_builder::switched::Switched<'b>":"args::arg_builder::switched::Switched","args::arg_builder::valued::Valued<'a, 'b>":"args::arg_builder::valued::Valued","args::arg_matcher::ArgMatcher<'a>":"args::arg_matcher::ArgMatcher","args::arg_matches::ArgMatches<'a>":"args::arg_matches::ArgMatches","args::arg_matches::Indices<'a>":"args::arg_matches::Indices","args::arg_matches::OsValues<'a>":"args::arg_matches::OsValues","args::arg_matches::Values<'a>":"args::arg_matches::Values","args::group::ArgGroup<'a>":"args::group::ArgGroup","args::matched_arg::MatchedArg":"args::matched_arg::MatchedArg","args::settings::ArgFlags":"args::settings::ArgFlags","args::settings::ArgSettings":"args::settings::ArgSettings","args::settings::Flags":"args::settings::Flags","args::subcommand::SubCommand<'a>":"args::subcommand::SubCommand","completions::ComplGen<'a, 'b>":"completions::ComplGen","completions::bash::BashGen<'a, 'b>":"completions::bash::BashGen","completions::elvish::ElvishGen<'a, 'b>":"completions::elvish::ElvishGen","completions::fish::FishGen<'a, 'b>":"completions::fish::FishGen","completions::powershell::PowerShellGen<'a, 'b>":"completions::powershell::PowerShellGen","completions::shell::Shell":"completions::shell::Shell","completions::zsh::ZshGen<'a, 'b>":"completions::zsh::ZshGen","errors::Error":"errors::Error","errors::ErrorKind":"errors::ErrorKind","fmt::ColorWhen":"fmt::ColorWhen","fmt::Colorizer":"fmt::Colorizer","fmt::ColorizerOption":"fmt::ColorizerOption","fmt::Format<T>":"fmt::Format","osstringext::OsSplit<'a>":"osstringext::OsSplit","usage_parser::UsageParser<'a>":"usage_parser::UsageParser","usage_parser::UsageToken":"usage_parser::UsageToken"}}