{"dependencies":{"<&'a str as parser::Pattern>::split_prefix":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"<F as parser::Pattern>::split_prefix":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"<ParseOptions<'a> as std::clone::Clone>::clone":["ParseOptions","std::marker::Sized","std::option::Option"],"<Url as std::clone::Clone>::clone":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Url as std::cmp::Ord>::cmp":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Url as std::cmp::PartialEq>::eq":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Url as std::cmp::PartialOrd>::partial_cmp":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Url as std::convert::AsRef<str>>::as_ref":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Url as std::convert::TryFrom<&'a str>>::try_from":["std::marker::Sized","std::result::Result"],"<Url as std::fmt::Debug>::fmt":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<Url as std::fmt::Display>::fmt":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<Url as std::hash::Hash>::hash":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<Url as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<UrlQuery<'a> as form_urlencoded::Target>::as_mut_string":["UrlQuery","alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<UrlQuery<'a> as form_urlencoded::Target>::finish":["Url","UrlQuery","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<UrlQuery<'a> as std::fmt::Debug>::fmt":["UrlQuery","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<UrlQuery<'a> as std::ops::Drop>::drop":["UrlQuery","std::marker::Sized","std::option::Option"],"<char as parser::Pattern>::split_prefix":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"<host::Host<S> as std::clone::Clone>::clone":["host::Host","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr"],"<host::Host<S> as std::cmp::Eq>::assert_receiver_is_total_eq":["host::Host","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr"],"<host::Host<S> as std::cmp::Ord>::cmp":["host::Host","std::cmp::Ordering","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr"],"<host::Host<S> as std::cmp::PartialEq>::eq":["host::Host","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr"],"<host::Host<S> as std::cmp::PartialOrd>::partial_cmp":["host::Host","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option"],"<host::Host<S> as std::fmt::Debug>::fmt":["host::Host","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::result::Result"],"<host::Host<S> as std::fmt::Display>::fmt":["host::Host","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::result::Result"],"<host::Host<S> as std::hash::Hash>::hash":["host::Host","std::hash::Hasher","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr"],"<host::HostInternal as std::clone::Clone>::clone":["host::HostInternal","std::net::Ipv4Addr","std::net::Ipv6Addr"],"<host::HostInternal as std::cmp::Eq>::assert_receiver_is_total_eq":["host::HostInternal","std::net::Ipv4Addr","std::net::Ipv6Addr"],"<host::HostInternal as std::cmp::PartialEq>::eq":["host::HostInternal","std::net::Ipv4Addr","std::net::Ipv6Addr"],"<host::HostInternal as std::convert::From<host::Host>>::from":["host::Host","host::HostInternal","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr"],"<host::HostInternal as std::fmt::Debug>::fmt":["host::HostInternal","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::result::Result"],"<origin::OpaqueOrigin as std::clone::Clone>::clone":["origin::OpaqueOrigin"],"<origin::OpaqueOrigin as std::cmp::Eq>::assert_receiver_is_total_eq":["origin::OpaqueOrigin"],"<origin::OpaqueOrigin as std::cmp::PartialEq>::eq":["origin::OpaqueOrigin"],"<origin::OpaqueOrigin as std::fmt::Debug>::fmt":["origin::OpaqueOrigin","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<origin::OpaqueOrigin as std::hash::Hash>::hash":["origin::OpaqueOrigin","std::hash::Hasher","std::marker::Sized"],"<origin::Origin as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","host::Host","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<origin::Origin as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","host::Host","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<origin::Origin as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","host::Host","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<origin::Origin as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","host::Host","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<origin::Origin as std::hash::Hash>::hash":["alloc::raw_vec::RawVec","host::Host","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<parser::Context as std::clone::Clone>::clone":["parser::Context"],"<parser::Context as std::cmp::Eq>::assert_receiver_is_total_eq":["parser::Context"],"<parser::Context as std::cmp::PartialEq>::eq":["parser::Context"],"<parser::Input<'i> as std::clone::Clone>::clone":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"<parser::Input<'i> as std::iter::Iterator>::next":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"<parser::ParseError as std::clone::Clone>::clone":["parser::ParseError"],"<parser::ParseError as std::cmp::Eq>::assert_receiver_is_total_eq":["parser::ParseError"],"<parser::ParseError as std::cmp::PartialEq>::eq":["parser::ParseError"],"<parser::ParseError as std::convert::From<idna::Errors>>::from":["idna::Errors","parser::ParseError"],"<parser::ParseError as std::fmt::Debug>::fmt":["parser::ParseError","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<parser::ParseError as std::fmt::Display>::fmt":["parser::ParseError","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<parser::SchemeType as std::clone::Clone>::clone":["parser::SchemeType"],"<parser::SchemeType as std::cmp::PartialEq>::eq":["parser::SchemeType"],"<parser::SyntaxViolation as std::clone::Clone>::clone":["parser::SyntaxViolation"],"<parser::SyntaxViolation as std::cmp::Eq>::assert_receiver_is_total_eq":["parser::SyntaxViolation"],"<parser::SyntaxViolation as std::cmp::PartialEq>::eq":["parser::SyntaxViolation"],"<parser::SyntaxViolation as std::fmt::Debug>::fmt":["parser::SyntaxViolation","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<parser::SyntaxViolation as std::fmt::Display>::fmt":["parser::SyntaxViolation","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<path_segments::PathSegmentsMut<'a> as std::fmt::Debug>::fmt":["Url","alloc::raw_vec::RawVec","host::HostInternal","path_segments::PathSegmentsMut","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<path_segments::PathSegmentsMut<'a> as std::ops::Drop>::drop":["Url","alloc::raw_vec::RawVec","host::HostInternal","path_segments::PathSegmentsMut","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<slicing::Position as std::clone::Clone>::clone":["slicing::Position"],"<slicing::Position as std::fmt::Debug>::fmt":["slicing::Position","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<std::ops::Range<u32> as RangeArg>::slice_of":["std::marker::Sized","std::ops::Range"],"<std::ops::RangeFrom<u32> as RangeArg>::slice_of":["std::marker::Sized","std::ops::RangeFrom"],"<std::ops::RangeTo<u32> as RangeArg>::slice_of":["std::marker::Sized","std::ops::RangeTo"],"ParseOptions":["ParseOptions","std::marker::Sized","std::option::Option"],"ParseOptions::<'a>::base_url":["ParseOptions","std::marker::Sized","std::option::Option"],"ParseOptions::<'a>::encoding_override":["ParseOptions","std::marker::Sized","std::option::Option"],"ParseOptions::<'a>::parse":["ParseOptions","std::marker::Sized","std::option::Option","std::result::Result"],"ParseOptions::<'a>::syntax_violation_callback":["ParseOptions","std::marker::Sized","std::option::Option"],"RangeArg::slice_of":[],"Url":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::as_str":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::byte_at":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::cannot_be_a_base":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::check_invariants":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::domain":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::fragment":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::from_directory_path":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::from_file_path":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::convert::AsRef","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::has_authority":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::has_host":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::host":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::host_str":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::into_string":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::join":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::mutate":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ops::FnOnce","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::options":["ParseOptions","std::marker::Sized","std::option::Option"],"Url::origin":["Url","alloc::raw_vec::RawVec","host::Host","host::HostInternal","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::parse":["std::marker::Sized","std::result::Result"],"Url::parse_with_params":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::borrow::Borrow","std::convert::AsRef","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::password":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::path":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::path_segments":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::path_segments_mut":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::port":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::port_or_known_default":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::query":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::query_pairs":["Url","alloc::raw_vec::RawVec","form_urlencoded::Parse","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::query_pairs_mut":["Url","UrlQuery","alloc::raw_vec::RawVec","form_urlencoded::Serializer","form_urlencoded::Target","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::restore_after_path":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::restore_already_parsed_fragment":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::scheme":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::set_fragment":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::set_host":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::set_host_internal":["Url","alloc::raw_vec::RawVec","host::Host","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::set_ip_host":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::IpAddr","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::set_password":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::set_path":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::set_port":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::set_port_internal":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::set_query":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::set_scheme":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::set_username":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::slice":["RangeArg","Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::socket_addrs":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ops::Fn","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::socket_addrs::io_result":["std::marker::Sized","std::option::Option","std::result::Result"],"Url::take_after_path":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::take_fragment":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Url::to_file_path":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"Url::username":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"UrlQuery":["UrlQuery","std::marker::Sized","std::option::Option"],"file_url_segments_to_pathbuf":["core::str::iter::SplitInternal","std::marker::Sized","std::option::Option","std::result::Result","std::str::Split","std::str::pattern::Pattern"],"file_url_segments_to_pathbuf_windows":["core::str::iter::SplitInternal","std::marker::Sized","std::option::Option","std::result::Result","std::str::Split","std::str::pattern::Pattern"],"host::Host":["host::Host","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr"],"host::Host::<&'a str>::to_owned":["host::Host","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr"],"host::Host::parse":["std::marker::Sized","std::result::Result"],"host::Host::parse_opaque":["std::marker::Sized","std::result::Result"],"host::HostInternal":["host::HostInternal","std::net::Ipv4Addr","std::net::Ipv6Addr"],"host::longest_zero_sequence":[],"host::parse_ipv4addr":["std::marker::Sized","std::result::Result"],"host::parse_ipv4number":["std::marker::Sized","std::result::Result"],"host::parse_ipv6addr":["std::marker::Sized","std::result::Result"],"host::write_ipv6":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::net::Ipv6Addr","std::option::Option","std::result::Result"],"origin::OpaqueOrigin":["origin::OpaqueOrigin"],"origin::Origin":["alloc::raw_vec::RawVec","host::Host","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"origin::Origin::ascii_serialization":["alloc::raw_vec::RawVec","host::Host","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"origin::Origin::is_tuple":["alloc::raw_vec::RawVec","host::Host","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"origin::Origin::new_opaque":["alloc::raw_vec::RawVec","host::Host","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"origin::Origin::unicode_serialization":["alloc::raw_vec::RawVec","host::Host","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"origin::url_origin":["Url","alloc::raw_vec::RawVec","host::Host","host::HostInternal","origin::OpaqueOrigin","origin::Origin","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"parser::Context":["parser::Context"],"parser::Input":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::Input::<'i>::count_matching":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::Input::<'i>::is_empty":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::Input::<'i>::new":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::Input::<'i>::next_utf8":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::Input::<'i>::no_trim":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::Input::<'i>::split_first":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::Input::<'i>::split_prefix":["<F as parser::Pattern>::F","parser::Input","parser::Pattern","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::Input::<'i>::starts_with":["<F as parser::Pattern>::F","parser::Input","parser::Pattern","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::Input::<'i>::trim_tab_and_newlines":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::Input::<'i>::with_log":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::ParseError":["parser::ParseError"],"parser::Parser":["alloc::raw_vec::RawVec","parser::Context","parser::Parser","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::after_double_slash":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::check_url_code_point":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::file_host":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::slice::Iter","std::str::Chars"],"parser::Parser::<'a>::for_setter":["alloc::raw_vec::RawVec","parser::Context","parser::Parser","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::fragment_only":["Url","alloc::raw_vec::RawVec","host::HostInternal","parser::Context","parser::Input","parser::Parser","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::get_file_host":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::slice::Iter","std::str::Chars"],"parser::Parser::<'a>::last_slash_can_be_removed":[],"parser::Parser::<'a>::log_violation":["alloc::raw_vec::RawVec","parser::Context","parser::Parser","parser::SyntaxViolation","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::log_violation_if":["alloc::raw_vec::RawVec","parser::Context","parser::Parser","parser::SyntaxViolation","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_cannot_be_a_base_path":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_file":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_file_host":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_fragment":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_host":["parser::Input","parser::SchemeType","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::slice::Iter","std::str::Chars"],"parser::Parser::<'a>::parse_host_and_port":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_non_special":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_path":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_path_start":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_port":["parser::Context","parser::Input","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::ptr::NonNull","std::result::Result","std::slice::Iter","std::str::Chars"],"parser::Parser::<'a>::parse_query":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_query_and_fragment":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_relative":["Url","alloc::raw_vec::RawVec","host::HostInternal","parser::Context","parser::Input","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_scheme":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_url":["alloc::raw_vec::RawVec","parser::Context","parser::Parser","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_userinfo":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::parse_with_scheme":["alloc::raw_vec::RawVec","parser::Context","parser::Input","parser::Parser","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::pop_path":["alloc::raw_vec::RawVec","parser::Context","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::shorten_path":["alloc::raw_vec::RawVec","parser::Context","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"parser::Parser::<'a>::with_query_and_fragment":["alloc::raw_vec::RawVec","host::HostInternal","parser::Context","parser::Input","parser::Parser","parser::SchemeType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::slice::Iter","std::str::Chars","std::string::String","std::vec::Vec"],"parser::Pattern::split_prefix":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::SchemeType":["parser::SchemeType"],"parser::SchemeType::from":["parser::SchemeType"],"parser::SchemeType::is_file":["parser::SchemeType"],"parser::SchemeType::is_special":["parser::SchemeType"],"parser::SyntaxViolation":["parser::SyntaxViolation"],"parser::SyntaxViolation::description":["parser::SyntaxViolation"],"parser::ascii_alpha":[],"parser::ascii_tab_or_new_line":[],"parser::c0_control_or_space":[],"parser::default_port":["std::marker::Sized","std::option::Option"],"parser::is_ascii_hex_digit":[],"parser::is_normalized_windows_drive_letter":[],"parser::is_url_code_point":[],"parser::is_windows_drive_letter":[],"parser::path_starts_with_windows_drive_letter":[],"parser::starts_with_windows_drive_letter":[],"parser::starts_with_windows_drive_letter_segment":["parser::Input","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"parser::to_u32":["std::marker::Sized","std::result::Result"],"path_segments::PathSegmentsMut":["Url","alloc::raw_vec::RawVec","host::HostInternal","path_segments::PathSegmentsMut","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"path_segments::PathSegmentsMut::<'a>::clear":["Url","alloc::raw_vec::RawVec","host::HostInternal","path_segments::PathSegmentsMut","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"path_segments::PathSegmentsMut::<'a>::extend":["Url","alloc::raw_vec::RawVec","host::HostInternal","path_segments::PathSegmentsMut","std::alloc::Allocator","std::convert::AsRef","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"path_segments::PathSegmentsMut::<'a>::pop":["Url","alloc::raw_vec::RawVec","host::HostInternal","path_segments::PathSegmentsMut","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"path_segments::PathSegmentsMut::<'a>::pop_if_empty":["Url","alloc::raw_vec::RawVec","host::HostInternal","path_segments::PathSegmentsMut","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"path_segments::PathSegmentsMut::<'a>::push":["Url","alloc::raw_vec::RawVec","host::HostInternal","path_segments::PathSegmentsMut","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"path_segments::new":["Url","alloc::raw_vec::RawVec","host::HostInternal","path_segments::PathSegmentsMut","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"path_to_file_url_segments":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::path::Path","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec"],"path_to_file_url_segments_windows":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::ffi::OsStr","std::marker::PhantomData","std::marker::Sized","std::path::Path","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::sys::unix::os_str::Slice","std::vec::Vec"],"quirks::domain_to_ascii":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::domain_to_unicode":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::hash":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::host":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::hostname":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::href":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::origin":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::password":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::pathname":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::port":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::protocol":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::search":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::set_hash":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::set_host":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"quirks::set_hostname":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"quirks::set_href":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"quirks::set_password":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"quirks::set_pathname":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::set_port":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"quirks::set_protocol":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"quirks::set_search":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"quirks::set_username":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"quirks::trim":[],"quirks::username":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"slicing::<impl Url>::index":["Url","alloc::raw_vec::RawVec","host::HostInternal","slicing::Position","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"slicing::<impl std::ops::Index<std::ops::Range<slicing::Position>> for Url>::index":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ops::Range","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"slicing::<impl std::ops::Index<std::ops::RangeFrom<slicing::Position>> for Url>::index":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ops::RangeFrom","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"slicing::<impl std::ops::Index<std::ops::RangeFull> for Url>::index":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ops::RangeFull","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"slicing::<impl std::ops::Index<std::ops::RangeTo<slicing::Position>> for Url>::index":["Url","alloc::raw_vec::RawVec","host::HostInternal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::net::Ipv4Addr","std::net::Ipv6Addr","std::ops::RangeTo","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"slicing::Position":["slicing::Position"]},"glob_path_import":{},"self_to_fn":{"<F as parser::Pattern>::F":["impl<F: FnMut(char) -> bool> Pattern for F {\n    fn split_prefix<'i>(self, input: &mut Input<'i>) -> bool {\n        input.next().map_or(false, self)\n    }\n}"],"ParseOptions":["Clone","Copy","impl<'a> ParseOptions<'a> {\n    /// Change the base URL\n    pub fn base_url(mut self, new: Option<&'a Url>) -> Self {\n        self.base_url = new;\n        self\n    }\n\n    /// Override the character encoding of query strings.\n    /// This is a legacy concept only relevant for HTML.\n    pub fn encoding_override(mut self, new: EncodingOverride<'a>) -> Self {\n        self.encoding_override = new;\n        self\n    }\n\n    /// Call the provided function or closure for a non-fatal `SyntaxViolation`\n    /// when it occurs during parsing. Note that since the provided function is\n    /// `Fn`, the caller might need to utilize _interior mutability_, such as with\n    /// a `RefCell`, to collect the violations.\n    ///\n    /// ## Example\n    /// ```\n    /// use std::cell::RefCell;\n    /// use url::{Url, SyntaxViolation};\n    /// # use url::ParseError;\n    /// # fn run() -> Result<(), url::ParseError> {\n    /// let violations = RefCell::new(Vec::new());\n    /// let url = Url::options()\n    ///     .syntax_violation_callback(Some(&|v| violations.borrow_mut().push(v)))\n    ///     .parse(\"https:////example.com\")?;\n    /// assert_eq!(url.as_str(), \"https://example.com/\");\n    /// assert_eq!(violations.into_inner(),\n    ///            vec!(SyntaxViolation::ExpectedDoubleSlash));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn syntax_violation_callback(mut self, new: Option<&'a dyn Fn(SyntaxViolation)>) -> Self {\n        self.violation_fn = new;\n        self\n    }\n\n    /// Parse an URL string with the configuration so far.\n    pub fn parse(self, input: &str) -> Result<Url, crate::ParseError> {\n        Parser {\n            serialization: String::with_capacity(input.len()),\n            base_url: self.base_url,\n            query_encoding_override: self.encoding_override,\n            violation_fn: self.violation_fn,\n            context: Context::UrlParser,\n        }\n        .parse_url(input)\n    }\n}"],"Url":["Clone","impl AsRef<str> for Url {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        &self.serialization\n    }\n}","impl Eq for Url {}","impl Index<Range<Position>> for Url {\n    type Output = str;\n    fn index(&self, range: Range<Position>) -> &str {\n        &self.serialization[self.index(range.start)..self.index(range.end)]\n    }\n}","impl Index<RangeFrom<Position>> for Url {\n    type Output = str;\n    fn index(&self, range: RangeFrom<Position>) -> &str {\n        &self.serialization[self.index(range.start)..]\n    }\n}","impl Index<RangeFull> for Url {\n    type Output = str;\n    fn index(&self, _: RangeFull) -> &str {\n        &self.serialization\n    }\n}","impl Index<RangeTo<Position>> for Url {\n    type Output = str;\n    fn index(&self, range: RangeTo<Position>) -> &str {\n        &self.serialization[..self.index(range.end)]\n    }\n}","impl Ord for Url {\n    #[inline]\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n        self.serialization.cmp(&other.serialization)\n    }\n}","impl PartialEq for Url {\n    #[inline]\n    fn eq(&self, other: &Self) -> bool {\n        self.serialization == other.serialization\n    }\n}","impl PartialOrd for Url {\n    #[inline]\n    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n        self.serialization.partial_cmp(&other.serialization)\n    }\n}","impl Url {\n    #[inline]\n    fn index(&self, position: Position) -> usize {\n        match position {\n            Position::BeforeScheme => 0,\n\n            Position::AfterScheme => self.scheme_end as usize,\n\n            Position::BeforeUsername => {\n                if self.has_authority() {\n                    self.scheme_end as usize + \"://\".len()\n                } else {\n                    debug_assert!(self.byte_at(self.scheme_end) == b':');\n                    debug_assert!(self.scheme_end + \":\".len() as u32 == self.username_end);\n                    self.scheme_end as usize + \":\".len()\n                }\n            }\n\n            Position::AfterUsername => self.username_end as usize,\n\n            Position::BeforePassword => {\n                if self.has_authority() && self.byte_at(self.username_end) == b':' {\n                    self.username_end as usize + \":\".len()\n                } else {\n                    debug_assert!(self.username_end == self.host_start);\n                    self.username_end as usize\n                }\n            }\n\n            Position::AfterPassword => {\n                if self.has_authority() && self.byte_at(self.username_end) == b':' {\n                    debug_assert!(self.byte_at(self.host_start - \"@\".len() as u32) == b'@');\n                    self.host_start as usize - \"@\".len()\n                } else {\n                    debug_assert!(self.username_end == self.host_start);\n                    self.host_start as usize\n                }\n            }\n\n            Position::BeforeHost => self.host_start as usize,\n\n            Position::AfterHost => self.host_end as usize,\n\n            Position::BeforePort => {\n                if self.port.is_some() {\n                    debug_assert!(self.byte_at(self.host_end) == b':');\n                    self.host_end as usize + \":\".len()\n                } else {\n                    self.host_end as usize\n                }\n            }\n\n            Position::AfterPort => self.path_start as usize,\n\n            Position::BeforePath => self.path_start as usize,\n\n            Position::AfterPath => match (self.query_start, self.fragment_start) {\n                (Some(q), _) => q as usize,\n                (None, Some(f)) => f as usize,\n                (None, None) => self.serialization.len(),\n            },\n\n            Position::BeforeQuery => match (self.query_start, self.fragment_start) {\n                (Some(q), _) => {\n                    debug_assert!(self.byte_at(q) == b'?');\n                    q as usize + \"?\".len()\n                }\n                (None, Some(f)) => f as usize,\n                (None, None) => self.serialization.len(),\n            },\n\n            Position::AfterQuery => match self.fragment_start {\n                None => self.serialization.len(),\n                Some(f) => f as usize,\n            },\n\n            Position::BeforeFragment => match self.fragment_start {\n                Some(f) => {\n                    debug_assert!(self.byte_at(f) == b'#');\n                    f as usize + \"#\".len()\n                }\n                None => self.serialization.len(),\n            },\n\n            Position::AfterFragment => self.serialization.len(),\n        }\n    }\n}","impl Url {\n    /// Parse an absolute URL from a string.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"https://example.net\")?;\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// If the function can not parse an absolute URL from the given string,\n    /// a [`ParseError`] variant will be returned.\n    ///\n    /// [`ParseError`]: enum.ParseError.html\n    #[inline]\n    pub fn parse(input: &str) -> Result<Url, crate::ParseError> {\n        Url::options().parse(input)\n    }\n\n    /// Parse an absolute URL from a string and add params to its query string.\n    ///\n    /// Existing params are not removed.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse_with_params(\"https://example.net?dont=clobberme\",\n    ///                                  &[(\"lang\", \"rust\"), (\"browser\", \"servo\")])?;\n    /// assert_eq!(\"https://example.net/?dont=clobberme&lang=rust&browser=servo\", url.as_str());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// If the function can not parse an absolute URL from the given string,\n    /// a [`ParseError`] variant will be returned.\n    ///\n    /// [`ParseError`]: enum.ParseError.html\n    #[inline]\n    pub fn parse_with_params<I, K, V>(input: &str, iter: I) -> Result<Url, crate::ParseError>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<(K, V)>,\n        K: AsRef<str>,\n        V: AsRef<str>,\n    {\n        let mut url = Url::options().parse(input);\n\n        if let Ok(ref mut url) = url {\n            url.query_pairs_mut().extend_pairs(iter);\n        }\n\n        url\n    }\n\n    /// Parse a string as an URL, with this URL as the base URL.\n    ///\n    /// Note: a trailing slash is significant.\n    /// Without it, the last path component is considered to be a “file” name\n    /// to be removed to get at the “directory” that is used as the base:\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let base = Url::parse(\"https://example.net/a/b.html\")?;\n    /// let url = base.join(\"c.png\")?;\n    /// assert_eq!(url.as_str(), \"https://example.net/a/c.png\");  // Not /a/b.html/c.png\n    ///\n    /// let base = Url::parse(\"https://example.net/a/b/\")?;\n    /// let url = base.join(\"c.png\")?;\n    /// assert_eq!(url.as_str(), \"https://example.net/a/b/c.png\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// If the function can not parse an URL from the given string\n    /// with this URL as the base URL, a [`ParseError`] variant will be returned.\n    ///\n    /// [`ParseError`]: enum.ParseError.html\n    #[inline]\n    pub fn join(&self, input: &str) -> Result<Url, crate::ParseError> {\n        Url::options().base_url(Some(self)).parse(input)\n    }\n\n    /// Return a default `ParseOptions` that can fully configure the URL parser.\n    ///\n    /// # Examples\n    ///\n    /// Get default `ParseOptions`, then change base url\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use url::ParseError;\n    /// # fn run() -> Result<(), ParseError> {\n    /// let options = Url::options();\n    /// let api = Url::parse(\"https://api.example.com\")?;\n    /// let base_url = options.base_url(Some(&api));\n    /// let version_url = base_url.parse(\"version.json\")?;\n    /// assert_eq!(version_url.as_str(), \"https://api.example.com/version.json\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn options<'a>() -> ParseOptions<'a> {\n        ParseOptions {\n            base_url: None,\n            encoding_override: None,\n            violation_fn: None,\n        }\n    }\n\n    /// Return the serialization of this URL.\n    ///\n    /// This is fast since that serialization is already stored in the `Url` struct.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url_str = \"https://example.net/\";\n    /// let url = Url::parse(url_str)?;\n    /// assert_eq!(url.as_str(), url_str);\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        &self.serialization\n    }\n\n    /// Return the serialization of this URL.\n    ///\n    /// This consumes the `Url` and takes ownership of the `String` stored in it.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url_str = \"https://example.net/\";\n    /// let url = Url::parse(url_str)?;\n    /// assert_eq!(url.into_string(), url_str);\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    #[inline]\n    pub fn into_string(self) -> String {\n        self.serialization\n    }\n\n    /// For internal testing, not part of the public API.\n    ///\n    /// Methods of the `Url` struct assume a number of invariants.\n    /// This checks each of these invariants and panic if one is not met.\n    /// This is for testing rust-url itself.\n    #[doc(hidden)]\n    pub fn check_invariants(&self) -> Result<(), String> {\n        macro_rules! assert {\n            ($x: expr) => {\n                if !$x {\n                    return Err(format!(\n                        \"!( {} ) for URL {:?}\",\n                        stringify!($x),\n                        self.serialization\n                    ));\n                }\n            };\n        }\n\n        macro_rules! assert_eq {\n            ($a: expr, $b: expr) => {\n                {\n                    let a = $a;\n                    let b = $b;\n                    if a != b {\n                        return Err(format!(\"{:?} != {:?} ({} != {}) for URL {:?}\",\n                                           a, b, stringify!($a), stringify!($b),\n                                           self.serialization))\n                    }\n                }\n            }\n        }\n\n        assert!(self.scheme_end >= 1);\n        assert!(matches!(self.byte_at(0), b'a'..=b'z' | b'A'..=b'Z'));\n        assert!(self\n            .slice(1..self.scheme_end)\n            .chars()\n            .all(|c| matches!(c, 'a'..='z' | 'A'..='Z' | '0'..='9' | '+' | '-' | '.')));\n        assert_eq!(self.byte_at(self.scheme_end), b':');\n\n        if self.slice(self.scheme_end + 1..).starts_with(\"//\") {\n            // URL with authority\n            if self.username_end != self.serialization.len() as u32 {\n                match self.byte_at(self.username_end) {\n                    b':' => {\n                        assert!(self.host_start >= self.username_end + 2);\n                        assert_eq!(self.byte_at(self.host_start - 1), b'@');\n                    }\n                    b'@' => assert!(self.host_start == self.username_end + 1),\n                    _ => assert_eq!(self.username_end, self.scheme_end + 3),\n                }\n            }\n            assert!(self.host_start >= self.username_end);\n            assert!(self.host_end >= self.host_start);\n            let host_str = self.slice(self.host_start..self.host_end);\n            match self.host {\n                HostInternal::None => assert_eq!(host_str, \"\"),\n                HostInternal::Ipv4(address) => assert_eq!(host_str, address.to_string()),\n                HostInternal::Ipv6(address) => {\n                    let h: Host<String> = Host::Ipv6(address);\n                    assert_eq!(host_str, h.to_string())\n                }\n                HostInternal::Domain => {\n                    if SchemeType::from(self.scheme()).is_special() {\n                        assert!(!host_str.is_empty())\n                    }\n                }\n            }\n            if self.path_start == self.host_end {\n                assert_eq!(self.port, None);\n            } else {\n                assert_eq!(self.byte_at(self.host_end), b':');\n                let port_str = self.slice(self.host_end + 1..self.path_start);\n                assert_eq!(\n                    self.port,\n                    Some(port_str.parse::<u16>().expect(\"Couldn't parse port?\"))\n                );\n            }\n            assert!(\n                self.path_start as usize == self.serialization.len()\n                    || matches!(self.byte_at(self.path_start), b'/' | b'#' | b'?')\n            );\n        } else {\n            // Anarchist URL (no authority)\n            assert_eq!(self.username_end, self.scheme_end + 1);\n            assert_eq!(self.host_start, self.scheme_end + 1);\n            assert_eq!(self.host_end, self.scheme_end + 1);\n            assert_eq!(self.host, HostInternal::None);\n            assert_eq!(self.port, None);\n            assert_eq!(self.path_start, self.scheme_end + 1);\n        }\n        if let Some(start) = self.query_start {\n            assert!(start >= self.path_start);\n            assert_eq!(self.byte_at(start), b'?');\n        }\n        if let Some(start) = self.fragment_start {\n            assert!(start >= self.path_start);\n            assert_eq!(self.byte_at(start), b'#');\n        }\n        if let (Some(query_start), Some(fragment_start)) = (self.query_start, self.fragment_start) {\n            assert!(fragment_start > query_start);\n        }\n\n        let other = Url::parse(self.as_str()).expect(\"Failed to parse myself?\");\n        assert_eq!(&self.serialization, &other.serialization);\n        assert_eq!(self.scheme_end, other.scheme_end);\n        assert_eq!(self.username_end, other.username_end);\n        assert_eq!(self.host_start, other.host_start);\n        assert_eq!(self.host_end, other.host_end);\n        assert!(\n            self.host == other.host ||\n                // XXX No host round-trips to empty host.\n                // See https://github.com/whatwg/url/issues/79\n                (self.host_str(), other.host_str()) == (None, Some(\"\"))\n        );\n        assert_eq!(self.port, other.port);\n        assert_eq!(self.path_start, other.path_start);\n        assert_eq!(self.query_start, other.query_start);\n        assert_eq!(self.fragment_start, other.fragment_start);\n        Ok(())\n    }\n\n    /// Return the origin of this URL (<https://url.spec.whatwg.org/#origin>)\n    ///\n    /// Note: this returns an opaque origin for `file:` URLs, which causes\n    /// `url.origin() != url.origin()`.\n    ///\n    /// # Examples\n    ///\n    /// URL with `ftp` scheme:\n    ///\n    /// ```rust\n    /// use url::{Host, Origin, Url};\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"ftp://example.com/foo\")?;\n    /// assert_eq!(url.origin(),\n    ///            Origin::Tuple(\"ftp\".into(),\n    ///                          Host::Domain(\"example.com\".into()),\n    ///                          21));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// URL with `blob` scheme:\n    ///\n    /// ```rust\n    /// use url::{Host, Origin, Url};\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"blob:https://example.com/foo\")?;\n    /// assert_eq!(url.origin(),\n    ///            Origin::Tuple(\"https\".into(),\n    ///                          Host::Domain(\"example.com\".into()),\n    ///                          443));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// URL with `file` scheme:\n    ///\n    /// ```rust\n    /// use url::{Host, Origin, Url};\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"file:///tmp/foo\")?;\n    /// assert!(!url.origin().is_tuple());\n    ///\n    /// let other_url = Url::parse(\"file:///tmp/foo\")?;\n    /// assert!(url.origin() != other_url.origin());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// URL with other scheme:\n    ///\n    /// ```rust\n    /// use url::{Host, Origin, Url};\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"foo:bar\")?;\n    /// assert!(!url.origin().is_tuple());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    #[inline]\n    pub fn origin(&self) -> Origin {\n        origin::url_origin(self)\n    }\n\n    /// Return the scheme of this URL, lower-cased, as an ASCII string without the ':' delimiter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"file:///tmp/foo\")?;\n    /// assert_eq!(url.scheme(), \"file\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    #[inline]\n    pub fn scheme(&self) -> &str {\n        self.slice(..self.scheme_end)\n    }\n\n    /// Return whether the URL has an 'authority',\n    /// which can contain a username, password, host, and port number.\n    ///\n    /// URLs that do *not* are either path-only like `unix:/run/foo.socket`\n    /// or cannot-be-a-base like `data:text/plain,Stuff`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"ftp://rms@example.com\")?;\n    /// assert!(url.has_authority());\n    ///\n    /// let url = Url::parse(\"unix:/run/foo.socket\")?;\n    /// assert!(!url.has_authority());\n    ///\n    /// let url = Url::parse(\"data:text/plain,Stuff\")?;\n    /// assert!(!url.has_authority());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    #[inline]\n    pub fn has_authority(&self) -> bool {\n        debug_assert!(self.byte_at(self.scheme_end) == b':');\n        self.slice(self.scheme_end..).starts_with(\"://\")\n    }\n\n    /// Return whether this URL is a cannot-be-a-base URL,\n    /// meaning that parsing a relative URL string with this URL as the base will return an error.\n    ///\n    /// This is the case if the scheme and `:` delimiter are not followed by a `/` slash,\n    /// as is typically the case of `data:` and `mailto:` URLs.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"ftp://rms@example.com\")?;\n    /// assert!(!url.cannot_be_a_base());\n    ///\n    /// let url = Url::parse(\"unix:/run/foo.socket\")?;\n    /// assert!(!url.cannot_be_a_base());\n    ///\n    /// let url = Url::parse(\"data:text/plain,Stuff\")?;\n    /// assert!(url.cannot_be_a_base());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    #[inline]\n    pub fn cannot_be_a_base(&self) -> bool {\n        !self.slice(self.scheme_end + 1..).starts_with('/')\n    }\n\n    /// Return the username for this URL (typically the empty string)\n    /// as a percent-encoded ASCII string.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"ftp://rms@example.com\")?;\n    /// assert_eq!(url.username(), \"rms\");\n    ///\n    /// let url = Url::parse(\"ftp://:secret123@example.com\")?;\n    /// assert_eq!(url.username(), \"\");\n    ///\n    /// let url = Url::parse(\"https://example.com\")?;\n    /// assert_eq!(url.username(), \"\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn username(&self) -> &str {\n        if self.has_authority() {\n            self.slice(self.scheme_end + (\"://\".len() as u32)..self.username_end)\n        } else {\n            \"\"\n        }\n    }\n\n    /// Return the password for this URL, if any, as a percent-encoded ASCII string.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"ftp://rms:secret123@example.com\")?;\n    /// assert_eq!(url.password(), Some(\"secret123\"));\n    ///\n    /// let url = Url::parse(\"ftp://:secret123@example.com\")?;\n    /// assert_eq!(url.password(), Some(\"secret123\"));\n    ///\n    /// let url = Url::parse(\"ftp://rms@example.com\")?;\n    /// assert_eq!(url.password(), None);\n    ///\n    /// let url = Url::parse(\"https://example.com\")?;\n    /// assert_eq!(url.password(), None);\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn password(&self) -> Option<&str> {\n        // This ':' is not the one marking a port number since a host can not be empty.\n        // (Except for file: URLs, which do not have port numbers.)\n        if self.has_authority()\n            && self.username_end != self.serialization.len() as u32\n            && self.byte_at(self.username_end) == b':'\n        {\n            debug_assert!(self.byte_at(self.host_start - 1) == b'@');\n            Some(self.slice(self.username_end + 1..self.host_start - 1))\n        } else {\n            None\n        }\n    }\n\n    /// Equivalent to `url.host().is_some()`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"ftp://rms@example.com\")?;\n    /// assert!(url.has_host());\n    ///\n    /// let url = Url::parse(\"unix:/run/foo.socket\")?;\n    /// assert!(!url.has_host());\n    ///\n    /// let url = Url::parse(\"data:text/plain,Stuff\")?;\n    /// assert!(!url.has_host());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn has_host(&self) -> bool {\n        !matches!(self.host, HostInternal::None)\n    }\n\n    /// Return the string representation of the host (domain or IP address) for this URL, if any.\n    ///\n    /// Non-ASCII domains are punycode-encoded per IDNA.\n    /// IPv6 addresses are given between `[` and `]` brackets.\n    ///\n    /// Cannot-be-a-base URLs (typical of `data:` and `mailto:`) and some `file:` URLs\n    /// don’t have a host.\n    ///\n    /// See also the `host` method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"https://127.0.0.1/index.html\")?;\n    /// assert_eq!(url.host_str(), Some(\"127.0.0.1\"));\n    ///\n    /// let url = Url::parse(\"ftp://rms@example.com\")?;\n    /// assert_eq!(url.host_str(), Some(\"example.com\"));\n    ///\n    /// let url = Url::parse(\"unix:/run/foo.socket\")?;\n    /// assert_eq!(url.host_str(), None);\n    ///\n    /// let url = Url::parse(\"data:text/plain,Stuff\")?;\n    /// assert_eq!(url.host_str(), None);\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn host_str(&self) -> Option<&str> {\n        if self.has_host() {\n            Some(self.slice(self.host_start..self.host_end))\n        } else {\n            None\n        }\n    }\n\n    /// Return the parsed representation of the host for this URL.\n    /// Non-ASCII domain labels are punycode-encoded per IDNA.\n    ///\n    /// Cannot-be-a-base URLs (typical of `data:` and `mailto:`) and some `file:` URLs\n    /// don’t have a host.\n    ///\n    /// See also the `host_str` method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"https://127.0.0.1/index.html\")?;\n    /// assert!(url.host().is_some());\n    ///\n    /// let url = Url::parse(\"ftp://rms@example.com\")?;\n    /// assert!(url.host().is_some());\n    ///\n    /// let url = Url::parse(\"unix:/run/foo.socket\")?;\n    /// assert!(url.host().is_none());\n    ///\n    /// let url = Url::parse(\"data:text/plain,Stuff\")?;\n    /// assert!(url.host().is_none());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn host(&self) -> Option<Host<&str>> {\n        match self.host {\n            HostInternal::None => None,\n            HostInternal::Domain => Some(Host::Domain(self.slice(self.host_start..self.host_end))),\n            HostInternal::Ipv4(address) => Some(Host::Ipv4(address)),\n            HostInternal::Ipv6(address) => Some(Host::Ipv6(address)),\n        }\n    }\n\n    /// If this URL has a host and it is a domain name (not an IP address), return it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"https://127.0.0.1/\")?;\n    /// assert_eq!(url.domain(), None);\n    ///\n    /// let url = Url::parse(\"mailto:rms@example.net\")?;\n    /// assert_eq!(url.domain(), None);\n    ///\n    /// let url = Url::parse(\"https://example.com/\")?;\n    /// assert_eq!(url.domain(), Some(\"example.com\"));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn domain(&self) -> Option<&str> {\n        match self.host {\n            HostInternal::Domain => Some(self.slice(self.host_start..self.host_end)),\n            _ => None,\n        }\n    }\n\n    /// Return the port number for this URL, if any.\n    ///\n    /// Note that default port numbers are never reflected by the serialization,\n    /// use the `port_or_known_default()` method if you want a default port number returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"https://example.com\")?;\n    /// assert_eq!(url.port(), None);\n    ///\n    /// let url = Url::parse(\"https://example.com:443/\")?;\n    /// assert_eq!(url.port(), None);\n    ///\n    /// let url = Url::parse(\"ssh://example.com:22\")?;\n    /// assert_eq!(url.port(), Some(22));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    #[inline]\n    pub fn port(&self) -> Option<u16> {\n        self.port\n    }\n\n    /// Return the port number for this URL, or the default port number if it is known.\n    ///\n    /// This method only knows the default port number\n    /// of the `http`, `https`, `ws`, `wss` and `ftp` schemes.\n    ///\n    /// For URLs in these schemes, this method always returns `Some(_)`.\n    /// For other schemes, it is the same as `Url::port()`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"foo://example.com\")?;\n    /// assert_eq!(url.port_or_known_default(), None);\n    ///\n    /// let url = Url::parse(\"foo://example.com:1456\")?;\n    /// assert_eq!(url.port_or_known_default(), Some(1456));\n    ///\n    /// let url = Url::parse(\"https://example.com\")?;\n    /// assert_eq!(url.port_or_known_default(), Some(443));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    #[inline]\n    pub fn port_or_known_default(&self) -> Option<u16> {\n        self.port.or_else(|| parser::default_port(self.scheme()))\n    }\n\n    /// Resolve a URL’s host and port number to `SocketAddr`.\n    ///\n    /// If the URL has the default port number of a scheme that is unknown to this library,\n    /// `default_port_number` provides an opportunity to provide the actual port number.\n    /// In non-example code this should be implemented either simply as `|| None`,\n    /// or by matching on the URL’s `.scheme()`.\n    ///\n    /// If the host is a domain, it is resolved using the standard library’s DNS support.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// let url = url::Url::parse(\"https://example.net/\").unwrap();\n    /// let addrs = url.socket_addrs(|| None).unwrap();\n    /// std::net::TcpStream::connect(&*addrs)\n    /// # ;\n    /// ```\n    ///\n    /// ```\n    /// /// With application-specific known default port numbers\n    /// fn socket_addrs(url: url::Url) -> std::io::Result<Vec<std::net::SocketAddr>> {\n    ///     url.socket_addrs(|| match url.scheme() {\n    ///         \"socks5\" | \"socks5h\" => Some(1080),\n    ///         _ => None,\n    ///     })\n    /// }\n    /// ```\n    pub fn socket_addrs(\n        &self,\n        default_port_number: impl Fn() -> Option<u16>,\n    ) -> io::Result<Vec<SocketAddr>> {\n        // Note: trying to avoid the Vec allocation by returning `impl AsRef<[SocketAddr]>`\n        // causes borrowck issues because the return value borrows `default_port_number`:\n        //\n        // https://github.com/rust-lang/rfcs/blob/master/text/1951-expand-impl-trait.md#scoping-for-type-and-lifetime-parameters\n        //\n        // > This RFC proposes that *all* type parameters are considered in scope\n        // > for `impl Trait` in return position\n\n        fn io_result<T>(opt: Option<T>, message: &str) -> io::Result<T> {\n            opt.ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, message))\n        }\n\n        let host = io_result(self.host(), \"No host name in the URL\")?;\n        let port = io_result(\n            self.port_or_known_default().or_else(default_port_number),\n            \"No port number in the URL\",\n        )?;\n        Ok(match host {\n            Host::Domain(domain) => (domain, port).to_socket_addrs()?.collect(),\n            Host::Ipv4(ip) => vec![(ip, port).into()],\n            Host::Ipv6(ip) => vec![(ip, port).into()],\n        })\n    }\n\n    /// Return the path for this URL, as a percent-encoded ASCII string.\n    /// For cannot-be-a-base URLs, this is an arbitrary string that doesn’t start with '/'.\n    /// For other URLs, this starts with a '/' slash\n    /// and continues with slash-separated path segments.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::{Url, ParseError};\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"https://example.com/api/versions?page=2\")?;\n    /// assert_eq!(url.path(), \"/api/versions\");\n    ///\n    /// let url = Url::parse(\"https://example.com\")?;\n    /// assert_eq!(url.path(), \"/\");\n    ///\n    /// let url = Url::parse(\"https://example.com/countries/việt nam\")?;\n    /// assert_eq!(url.path(), \"/countries/vi%E1%BB%87t%20nam\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn path(&self) -> &str {\n        match (self.query_start, self.fragment_start) {\n            (None, None) => self.slice(self.path_start..),\n            (Some(next_component_start), _) | (None, Some(next_component_start)) => {\n                self.slice(self.path_start..next_component_start)\n            }\n        }\n    }\n\n    /// Unless this URL is cannot-be-a-base,\n    /// return an iterator of '/' slash-separated path segments,\n    /// each as a percent-encoded ASCII string.\n    ///\n    /// Return `None` for cannot-be-a-base URLs.\n    ///\n    /// When `Some` is returned, the iterator always contains at least one string\n    /// (which may be empty).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use std::error::Error;\n    ///\n    /// # fn run() -> Result<(), Box<dyn Error>> {\n    /// let url = Url::parse(\"https://example.com/foo/bar\")?;\n    /// let mut path_segments = url.path_segments().ok_or_else(|| \"cannot be base\")?;\n    /// assert_eq!(path_segments.next(), Some(\"foo\"));\n    /// assert_eq!(path_segments.next(), Some(\"bar\"));\n    /// assert_eq!(path_segments.next(), None);\n    ///\n    /// let url = Url::parse(\"https://example.com\")?;\n    /// let mut path_segments = url.path_segments().ok_or_else(|| \"cannot be base\")?;\n    /// assert_eq!(path_segments.next(), Some(\"\"));\n    /// assert_eq!(path_segments.next(), None);\n    ///\n    /// let url = Url::parse(\"data:text/plain,HelloWorld\")?;\n    /// assert!(url.path_segments().is_none());\n    ///\n    /// let url = Url::parse(\"https://example.com/countries/việt nam\")?;\n    /// let mut path_segments = url.path_segments().ok_or_else(|| \"cannot be base\")?;\n    /// assert_eq!(path_segments.next(), Some(\"countries\"));\n    /// assert_eq!(path_segments.next(), Some(\"vi%E1%BB%87t%20nam\"));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn path_segments(&self) -> Option<str::Split<'_, char>> {\n        let path = self.path();\n        if path.starts_with('/') {\n            Some(path[1..].split('/'))\n        } else {\n            None\n        }\n    }\n\n    /// Return this URL’s query string, if any, as a percent-encoded ASCII string.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"https://example.com/products?page=2\")?;\n    /// let query = url.query();\n    /// assert_eq!(query, Some(\"page=2\"));\n    ///\n    /// let url = Url::parse(\"https://example.com/products\")?;\n    /// let query = url.query();\n    /// assert!(query.is_none());\n    ///\n    /// let url = Url::parse(\"https://example.com/?country=español\")?;\n    /// let query = url.query();\n    /// assert_eq!(query, Some(\"country=espa%C3%B1ol\"));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn query(&self) -> Option<&str> {\n        match (self.query_start, self.fragment_start) {\n            (None, _) => None,\n            (Some(query_start), None) => {\n                debug_assert!(self.byte_at(query_start) == b'?');\n                Some(self.slice(query_start + 1..))\n            }\n            (Some(query_start), Some(fragment_start)) => {\n                debug_assert!(self.byte_at(query_start) == b'?');\n                Some(self.slice(query_start + 1..fragment_start))\n            }\n        }\n    }\n\n    /// Parse the URL’s query string, if any, as `application/x-www-form-urlencoded`\n    /// and return an iterator of (key, value) pairs.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::borrow::Cow;\n    ///\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"https://example.com/products?page=2&sort=desc\")?;\n    /// let mut pairs = url.query_pairs();\n    ///\n    /// assert_eq!(pairs.count(), 2);\n    ///\n    /// assert_eq!(pairs.next(), Some((Cow::Borrowed(\"page\"), Cow::Borrowed(\"2\"))));\n    /// assert_eq!(pairs.next(), Some((Cow::Borrowed(\"sort\"), Cow::Borrowed(\"desc\"))));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    ///\n\n    #[inline]\n    pub fn query_pairs(&self) -> form_urlencoded::Parse<'_> {\n        form_urlencoded::parse(self.query().unwrap_or(\"\").as_bytes())\n    }\n\n    /// Return this URL’s fragment identifier, if any.\n    ///\n    /// A fragment is the part of the URL after the `#` symbol.\n    /// The fragment is optional and, if present, contains a fragment identifier\n    /// that identifies a secondary resource, such as a section heading\n    /// of a document.\n    ///\n    /// In HTML, the fragment identifier is usually the id attribute of a an element\n    /// that is scrolled to on load. Browsers typically will not send the fragment portion\n    /// of a URL to the server.\n    ///\n    /// **Note:** the parser did *not* percent-encode this component,\n    /// but the input may have been percent-encoded already.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let url = Url::parse(\"https://example.com/data.csv#row=4\")?;\n    ///\n    /// assert_eq!(url.fragment(), Some(\"row=4\"));\n    ///\n    /// let url = Url::parse(\"https://example.com/data.csv#cell=4,1-6,2\")?;\n    ///\n    /// assert_eq!(url.fragment(), Some(\"cell=4,1-6,2\"));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn fragment(&self) -> Option<&str> {\n        self.fragment_start.map(|start| {\n            debug_assert!(self.byte_at(start) == b'#');\n            self.slice(start + 1..)\n        })\n    }\n\n    fn mutate<F: FnOnce(&mut Parser<'_>) -> R, R>(&mut self, f: F) -> R {\n        let mut parser = Parser::for_setter(mem::replace(&mut self.serialization, String::new()));\n        let result = f(&mut parser);\n        self.serialization = parser.serialization;\n        result\n    }\n\n    /// Change this URL’s fragment identifier.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"https://example.com/data.csv\")?;\n    /// assert_eq!(url.as_str(), \"https://example.com/data.csv\");\n\n    /// url.set_fragment(Some(\"cell=4,1-6,2\"));\n    /// assert_eq!(url.as_str(), \"https://example.com/data.csv#cell=4,1-6,2\");\n    /// assert_eq!(url.fragment(), Some(\"cell=4,1-6,2\"));\n    ///\n    /// url.set_fragment(None);\n    /// assert_eq!(url.as_str(), \"https://example.com/data.csv\");\n    /// assert!(url.fragment().is_none());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn set_fragment(&mut self, fragment: Option<&str>) {\n        // Remove any previous fragment\n        if let Some(start) = self.fragment_start {\n            debug_assert!(self.byte_at(start) == b'#');\n            self.serialization.truncate(start as usize);\n        }\n        // Write the new one\n        if let Some(input) = fragment {\n            self.fragment_start = Some(to_u32(self.serialization.len()).unwrap());\n            self.serialization.push('#');\n            self.mutate(|parser| parser.parse_fragment(parser::Input::no_trim(input)))\n        } else {\n            self.fragment_start = None\n        }\n    }\n\n    fn take_fragment(&mut self) -> Option<String> {\n        self.fragment_start.take().map(|start| {\n            debug_assert!(self.byte_at(start) == b'#');\n            let fragment = self.slice(start + 1..).to_owned();\n            self.serialization.truncate(start as usize);\n            fragment\n        })\n    }\n\n    fn restore_already_parsed_fragment(&mut self, fragment: Option<String>) {\n        if let Some(ref fragment) = fragment {\n            assert!(self.fragment_start.is_none());\n            self.fragment_start = Some(to_u32(self.serialization.len()).unwrap());\n            self.serialization.push('#');\n            self.serialization.push_str(fragment);\n        }\n    }\n\n    /// Change this URL’s query string.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"https://example.com/products\")?;\n    /// assert_eq!(url.as_str(), \"https://example.com/products\");\n    ///\n    /// url.set_query(Some(\"page=2\"));\n    /// assert_eq!(url.as_str(), \"https://example.com/products?page=2\");\n    /// assert_eq!(url.query(), Some(\"page=2\"));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn set_query(&mut self, query: Option<&str>) {\n        let fragment = self.take_fragment();\n\n        // Remove any previous query\n        if let Some(start) = self.query_start.take() {\n            debug_assert!(self.byte_at(start) == b'?');\n            self.serialization.truncate(start as usize);\n        }\n        // Write the new query, if any\n        if let Some(input) = query {\n            self.query_start = Some(to_u32(self.serialization.len()).unwrap());\n            self.serialization.push('?');\n            let scheme_type = SchemeType::from(self.scheme());\n            let scheme_end = self.scheme_end;\n            self.mutate(|parser| {\n                let vfn = parser.violation_fn;\n                parser.parse_query(\n                    scheme_type,\n                    scheme_end,\n                    parser::Input::trim_tab_and_newlines(input, vfn),\n                )\n            });\n        }\n\n        self.restore_already_parsed_fragment(fragment);\n    }\n\n    /// Manipulate this URL’s query string, viewed as a sequence of name/value pairs\n    /// in `application/x-www-form-urlencoded` syntax.\n    ///\n    /// The return value has a method-chaining API:\n    ///\n    /// ```rust\n    /// # use url::{Url, ParseError};\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"https://example.net?lang=fr#nav\")?;\n    /// assert_eq!(url.query(), Some(\"lang=fr\"));\n    ///\n    /// url.query_pairs_mut().append_pair(\"foo\", \"bar\");\n    /// assert_eq!(url.query(), Some(\"lang=fr&foo=bar\"));\n    /// assert_eq!(url.as_str(), \"https://example.net/?lang=fr&foo=bar#nav\");\n    ///\n    /// url.query_pairs_mut()\n    ///     .clear()\n    ///     .append_pair(\"foo\", \"bar & baz\")\n    ///     .append_pair(\"saisons\", \"\\u{00C9}t\\u{00E9}+hiver\");\n    /// assert_eq!(url.query(), Some(\"foo=bar+%26+baz&saisons=%C3%89t%C3%A9%2Bhiver\"));\n    /// assert_eq!(url.as_str(),\n    ///            \"https://example.net/?foo=bar+%26+baz&saisons=%C3%89t%C3%A9%2Bhiver#nav\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// Note: `url.query_pairs_mut().clear();` is equivalent to `url.set_query(Some(\"\"))`,\n    /// not `url.set_query(None)`.\n    ///\n    /// The state of `Url` is unspecified if this return value is leaked without being dropped.\n    pub fn query_pairs_mut(&mut self) -> form_urlencoded::Serializer<'_, UrlQuery<'_>> {\n        let fragment = self.take_fragment();\n\n        let query_start;\n        if let Some(start) = self.query_start {\n            debug_assert!(self.byte_at(start) == b'?');\n            query_start = start as usize;\n        } else {\n            query_start = self.serialization.len();\n            self.query_start = Some(to_u32(query_start).unwrap());\n            self.serialization.push('?');\n        }\n\n        let query = UrlQuery {\n            url: Some(self),\n            fragment,\n        };\n        form_urlencoded::Serializer::for_suffix(query, query_start + \"?\".len())\n    }\n\n    fn take_after_path(&mut self) -> String {\n        match (self.query_start, self.fragment_start) {\n            (Some(i), _) | (None, Some(i)) => {\n                let after_path = self.slice(i..).to_owned();\n                self.serialization.truncate(i as usize);\n                after_path\n            }\n            (None, None) => String::new(),\n        }\n    }\n\n    /// Change this URL’s path.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"https://example.com\")?;\n    /// url.set_path(\"api/comments\");\n    /// assert_eq!(url.as_str(), \"https://example.com/api/comments\");\n    /// assert_eq!(url.path(), \"/api/comments\");\n    ///\n    /// let mut url = Url::parse(\"https://example.com/api\")?;\n    /// url.set_path(\"data/report.csv\");\n    /// assert_eq!(url.as_str(), \"https://example.com/data/report.csv\");\n    /// assert_eq!(url.path(), \"/data/report.csv\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn set_path(&mut self, mut path: &str) {\n        let after_path = self.take_after_path();\n        let old_after_path_pos = to_u32(self.serialization.len()).unwrap();\n        let cannot_be_a_base = self.cannot_be_a_base();\n        let scheme_type = SchemeType::from(self.scheme());\n        self.serialization.truncate(self.path_start as usize);\n        self.mutate(|parser| {\n            if cannot_be_a_base {\n                if path.starts_with('/') {\n                    parser.serialization.push_str(\"%2F\");\n                    path = &path[1..];\n                }\n                parser.parse_cannot_be_a_base_path(parser::Input::new(path));\n            } else {\n                let mut has_host = true; // FIXME\n                parser.parse_path_start(scheme_type, &mut has_host, parser::Input::new(path));\n            }\n        });\n        self.restore_after_path(old_after_path_pos, &after_path);\n    }\n\n    /// Return an object with methods to manipulate this URL’s path segments.\n    ///\n    /// Return `Err(())` if this URL is cannot-be-a-base.\n    pub fn path_segments_mut(&mut self) -> Result<PathSegmentsMut<'_>, ()> {\n        if self.cannot_be_a_base() {\n            Err(())\n        } else {\n            Ok(path_segments::new(self))\n        }\n    }\n\n    fn restore_after_path(&mut self, old_after_path_position: u32, after_path: &str) {\n        let new_after_path_position = to_u32(self.serialization.len()).unwrap();\n        let adjust = |index: &mut u32| {\n            *index -= old_after_path_position;\n            *index += new_after_path_position;\n        };\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n        self.serialization.push_str(after_path)\n    }\n\n    /// Change this URL’s port number.\n    ///\n    /// Note that default port numbers are not reflected in the serialization.\n    ///\n    /// If this URL is cannot-be-a-base, does not have a host, or has the `file` scheme;\n    /// do nothing and return `Err`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use std::error::Error;\n    ///\n    /// # fn run() -> Result<(), Box<dyn Error>> {\n    /// let mut url = Url::parse(\"ssh://example.net:2048/\")?;\n    ///\n    /// url.set_port(Some(4096)).map_err(|_| \"cannot be base\")?;\n    /// assert_eq!(url.as_str(), \"ssh://example.net:4096/\");\n    ///\n    /// url.set_port(None).map_err(|_| \"cannot be base\")?;\n    /// assert_eq!(url.as_str(), \"ssh://example.net/\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// Known default port numbers are not reflected:\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use std::error::Error;\n    ///\n    /// # fn run() -> Result<(), Box<dyn Error>> {\n    /// let mut url = Url::parse(\"https://example.org/\")?;\n    ///\n    /// url.set_port(Some(443)).map_err(|_| \"cannot be base\")?;\n    /// assert!(url.port().is_none());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// Cannot set port for cannot-be-a-base URLs:\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"mailto:rms@example.net\")?;\n    ///\n    /// let result = url.set_port(Some(80));\n    /// assert!(result.is_err());\n    ///\n    /// let result = url.set_port(None);\n    /// assert!(result.is_err());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn set_port(&mut self, mut port: Option<u16>) -> Result<(), ()> {\n        // has_host implies !cannot_be_a_base\n        if !self.has_host() || self.host() == Some(Host::Domain(\"\")) || self.scheme() == \"file\" {\n            return Err(());\n        }\n        if port.is_some() && port == parser::default_port(self.scheme()) {\n            port = None\n        }\n        self.set_port_internal(port);\n        Ok(())\n    }\n\n    fn set_port_internal(&mut self, port: Option<u16>) {\n        match (self.port, port) {\n            (None, None) => {}\n            (Some(_), None) => {\n                self.serialization\n                    .drain(self.host_end as usize..self.path_start as usize);\n                let offset = self.path_start - self.host_end;\n                self.path_start = self.host_end;\n                if let Some(ref mut index) = self.query_start {\n                    *index -= offset\n                }\n                if let Some(ref mut index) = self.fragment_start {\n                    *index -= offset\n                }\n            }\n            (Some(old), Some(new)) if old == new => {}\n            (_, Some(new)) => {\n                let path_and_after = self.slice(self.path_start..).to_owned();\n                self.serialization.truncate(self.host_end as usize);\n                write!(&mut self.serialization, \":{}\", new).unwrap();\n                let old_path_start = self.path_start;\n                let new_path_start = to_u32(self.serialization.len()).unwrap();\n                self.path_start = new_path_start;\n                let adjust = |index: &mut u32| {\n                    *index -= old_path_start;\n                    *index += new_path_start;\n                };\n                if let Some(ref mut index) = self.query_start {\n                    adjust(index)\n                }\n                if let Some(ref mut index) = self.fragment_start {\n                    adjust(index)\n                }\n                self.serialization.push_str(&path_and_after);\n            }\n        }\n        self.port = port;\n    }\n\n    /// Change this URL’s host.\n    ///\n    /// Removing the host (calling this with `None`)\n    /// will also remove any username, password, and port number.\n    ///\n    /// # Examples\n    ///\n    /// Change host:\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"https://example.net\")?;\n    /// let result = url.set_host(Some(\"rust-lang.org\"));\n    /// assert!(result.is_ok());\n    /// assert_eq!(url.as_str(), \"https://rust-lang.org/\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// Remove host:\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"foo://example.net\")?;\n    /// let result = url.set_host(None);\n    /// assert!(result.is_ok());\n    /// assert_eq!(url.as_str(), \"foo:/\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// Cannot remove host for 'special' schemes (e.g. `http`):\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"https://example.net\")?;\n    /// let result = url.set_host(None);\n    /// assert!(result.is_err());\n    /// assert_eq!(url.as_str(), \"https://example.net/\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// Cannot change or remove host for cannot-be-a-base URLs:\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"mailto:rms@example.net\")?;\n    ///\n    /// let result = url.set_host(Some(\"rust-lang.org\"));\n    /// assert!(result.is_err());\n    /// assert_eq!(url.as_str(), \"mailto:rms@example.net\");\n    ///\n    /// let result = url.set_host(None);\n    /// assert!(result.is_err());\n    /// assert_eq!(url.as_str(), \"mailto:rms@example.net\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// If this URL is cannot-be-a-base or there is an error parsing the given `host`,\n    /// a [`ParseError`] variant will be returned.\n    ///\n    /// [`ParseError`]: enum.ParseError.html\n    pub fn set_host(&mut self, host: Option<&str>) -> Result<(), ParseError> {\n        if self.cannot_be_a_base() {\n            return Err(ParseError::SetHostOnCannotBeABaseUrl);\n        }\n\n        if let Some(host) = host {\n            if host == \"\" && SchemeType::from(self.scheme()).is_special() {\n                return Err(ParseError::EmptyHost);\n            }\n            let mut host_substr = host;\n            // Otherwise, if c is U+003A (:) and the [] flag is unset, then\n            if !host.starts_with('[') || !host.ends_with(']') {\n                match host.find(':') {\n                    Some(0) => {\n                        // If buffer is the empty string, validation error, return failure.\n                        return Err(ParseError::InvalidDomainCharacter);\n                    }\n                    // Let host be the result of host parsing buffer\n                    Some(colon_index) => {\n                        host_substr = &host[..colon_index];\n                    }\n                    None => {}\n                }\n            }\n            if SchemeType::from(self.scheme()).is_special() {\n                self.set_host_internal(Host::parse(host_substr)?, None);\n            } else {\n                self.set_host_internal(Host::parse_opaque(host_substr)?, None);\n            }\n        } else if self.has_host() {\n            let scheme_type = SchemeType::from(self.scheme());\n            if scheme_type.is_special() {\n                return Err(ParseError::EmptyHost);\n            } else if self.serialization.len() == self.path_start as usize {\n                self.serialization.push('/');\n            }\n            debug_assert!(self.byte_at(self.scheme_end) == b':');\n            debug_assert!(self.byte_at(self.path_start) == b'/');\n            let new_path_start = self.scheme_end + 1;\n            self.serialization\n                .drain(new_path_start as usize..self.path_start as usize);\n            let offset = self.path_start - new_path_start;\n            self.path_start = new_path_start;\n            self.username_end = new_path_start;\n            self.host_start = new_path_start;\n            self.host_end = new_path_start;\n            self.port = None;\n            if let Some(ref mut index) = self.query_start {\n                *index -= offset\n            }\n            if let Some(ref mut index) = self.fragment_start {\n                *index -= offset\n            }\n        }\n        Ok(())\n    }\n\n    /// opt_new_port: None means leave unchanged, Some(None) means remove any port number.\n    fn set_host_internal(&mut self, host: Host<String>, opt_new_port: Option<Option<u16>>) {\n        let old_suffix_pos = if opt_new_port.is_some() {\n            self.path_start\n        } else {\n            self.host_end\n        };\n        let suffix = self.slice(old_suffix_pos..).to_owned();\n        self.serialization.truncate(self.host_start as usize);\n        if !self.has_authority() {\n            debug_assert!(self.slice(self.scheme_end..self.host_start) == \":\");\n            debug_assert!(self.username_end == self.host_start);\n            self.serialization.push('/');\n            self.serialization.push('/');\n            self.username_end += 2;\n            self.host_start += 2;\n        }\n        write!(&mut self.serialization, \"{}\", host).unwrap();\n        self.host_end = to_u32(self.serialization.len()).unwrap();\n        self.host = host.into();\n\n        if let Some(new_port) = opt_new_port {\n            self.port = new_port;\n            if let Some(port) = new_port {\n                write!(&mut self.serialization, \":{}\", port).unwrap();\n            }\n        }\n        let new_suffix_pos = to_u32(self.serialization.len()).unwrap();\n        self.serialization.push_str(&suffix);\n\n        let adjust = |index: &mut u32| {\n            *index -= old_suffix_pos;\n            *index += new_suffix_pos;\n        };\n        adjust(&mut self.path_start);\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n    }\n\n    /// Change this URL’s host to the given IP address.\n    ///\n    /// If this URL is cannot-be-a-base, do nothing and return `Err`.\n    ///\n    /// Compared to `Url::set_host`, this skips the host parser.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::{Url, ParseError};\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"http://example.com\")?;\n    /// url.set_ip_host(\"127.0.0.1\".parse().unwrap());\n    /// assert_eq!(url.host_str(), Some(\"127.0.0.1\"));\n    /// assert_eq!(url.as_str(), \"http://127.0.0.1/\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// Cannot change URL's from mailto(cannot-be-base) to ip:\n    ///\n    /// ```rust\n    /// use url::{Url, ParseError};\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"mailto:rms@example.com\")?;\n    /// let result = url.set_ip_host(\"127.0.0.1\".parse().unwrap());\n    ///\n    /// assert_eq!(url.as_str(), \"mailto:rms@example.com\");\n    /// assert!(result.is_err());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    pub fn set_ip_host(&mut self, address: IpAddr) -> Result<(), ()> {\n        if self.cannot_be_a_base() {\n            return Err(());\n        }\n\n        let address = match address {\n            IpAddr::V4(address) => Host::Ipv4(address),\n            IpAddr::V6(address) => Host::Ipv6(address),\n        };\n        self.set_host_internal(address, None);\n        Ok(())\n    }\n\n    /// Change this URL’s password.\n    ///\n    /// If this URL is cannot-be-a-base or does not have a host, do nothing and return `Err`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use url::{Url, ParseError};\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"mailto:rmz@example.com\")?;\n    /// let result = url.set_password(Some(\"secret_password\"));\n    /// assert!(result.is_err());\n    ///\n    /// let mut url = Url::parse(\"ftp://user1:secret1@example.com\")?;\n    /// let result = url.set_password(Some(\"secret_password\"));\n    /// assert_eq!(url.password(), Some(\"secret_password\"));\n    ///\n    /// let mut url = Url::parse(\"ftp://user2:@example.com\")?;\n    /// let result = url.set_password(Some(\"secret2\"));\n    /// assert!(result.is_ok());\n    /// assert_eq!(url.password(), Some(\"secret2\"));\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn set_password(&mut self, password: Option<&str>) -> Result<(), ()> {\n        // has_host implies !cannot_be_a_base\n        if !self.has_host() || self.host() == Some(Host::Domain(\"\")) || self.scheme() == \"file\" {\n            return Err(());\n        }\n        if let Some(password) = password {\n            let host_and_after = self.slice(self.host_start..).to_owned();\n            self.serialization.truncate(self.username_end as usize);\n            self.serialization.push(':');\n            self.serialization\n                .extend(utf8_percent_encode(password, USERINFO));\n            self.serialization.push('@');\n\n            let old_host_start = self.host_start;\n            let new_host_start = to_u32(self.serialization.len()).unwrap();\n            let adjust = |index: &mut u32| {\n                *index -= old_host_start;\n                *index += new_host_start;\n            };\n            self.host_start = new_host_start;\n            adjust(&mut self.host_end);\n            adjust(&mut self.path_start);\n            if let Some(ref mut index) = self.query_start {\n                adjust(index)\n            }\n            if let Some(ref mut index) = self.fragment_start {\n                adjust(index)\n            }\n\n            self.serialization.push_str(&host_and_after);\n        } else if self.byte_at(self.username_end) == b':' {\n            // If there is a password to remove\n            let has_username_or_password = self.byte_at(self.host_start - 1) == b'@';\n            debug_assert!(has_username_or_password);\n            let username_start = self.scheme_end + 3;\n            let empty_username = username_start == self.username_end;\n            let start = self.username_end; // Remove the ':'\n            let end = if empty_username {\n                self.host_start // Remove the '@' as well\n            } else {\n                self.host_start - 1 // Keep the '@' to separate the username from the host\n            };\n            self.serialization.drain(start as usize..end as usize);\n            let offset = end - start;\n            self.host_start -= offset;\n            self.host_end -= offset;\n            self.path_start -= offset;\n            if let Some(ref mut index) = self.query_start {\n                *index -= offset\n            }\n            if let Some(ref mut index) = self.fragment_start {\n                *index -= offset\n            }\n        }\n        Ok(())\n    }\n\n    /// Change this URL’s username.\n    ///\n    /// If this URL is cannot-be-a-base or does not have a host, do nothing and return `Err`.\n    /// # Examples\n    ///\n    /// Cannot setup username from mailto(cannot-be-base)\n    ///\n    /// ```rust\n    /// use url::{Url, ParseError};\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"mailto:rmz@example.com\")?;\n    /// let result = url.set_username(\"user1\");\n    /// assert_eq!(url.as_str(), \"mailto:rmz@example.com\");\n    /// assert!(result.is_err());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// Setup username to user1\n    ///\n    /// ```rust\n    /// use url::{Url, ParseError};\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"ftp://:secre1@example.com/\")?;\n    /// let result = url.set_username(\"user1\");\n    /// assert!(result.is_ok());\n    /// assert_eq!(url.username(), \"user1\");\n    /// assert_eq!(url.as_str(), \"ftp://user1:secre1@example.com/\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn set_username(&mut self, username: &str) -> Result<(), ()> {\n        // has_host implies !cannot_be_a_base\n        if !self.has_host() || self.host() == Some(Host::Domain(\"\")) || self.scheme() == \"file\" {\n            return Err(());\n        }\n        let username_start = self.scheme_end + 3;\n        debug_assert!(self.slice(self.scheme_end..username_start) == \"://\");\n        if self.slice(username_start..self.username_end) == username {\n            return Ok(());\n        }\n        let after_username = self.slice(self.username_end..).to_owned();\n        self.serialization.truncate(username_start as usize);\n        self.serialization\n            .extend(utf8_percent_encode(username, USERINFO));\n\n        let mut removed_bytes = self.username_end;\n        self.username_end = to_u32(self.serialization.len()).unwrap();\n        let mut added_bytes = self.username_end;\n\n        let new_username_is_empty = self.username_end == username_start;\n        match (new_username_is_empty, after_username.chars().next()) {\n            (true, Some('@')) => {\n                removed_bytes += 1;\n                self.serialization.push_str(&after_username[1..]);\n            }\n            (false, Some('@')) | (_, Some(':')) | (true, _) => {\n                self.serialization.push_str(&after_username);\n            }\n            (false, _) => {\n                added_bytes += 1;\n                self.serialization.push('@');\n                self.serialization.push_str(&after_username);\n            }\n        }\n\n        let adjust = |index: &mut u32| {\n            *index -= removed_bytes;\n            *index += added_bytes;\n        };\n        adjust(&mut self.host_start);\n        adjust(&mut self.host_end);\n        adjust(&mut self.path_start);\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n        Ok(())\n    }\n\n    /// Change this URL’s scheme.\n    ///\n    /// Do nothing and return `Err` under the following circumstances:\n    ///\n    /// * If the new scheme is not in `[a-zA-Z][a-zA-Z0-9+.-]+`\n    /// * If this URL is cannot-be-a-base and the new scheme is one of\n    ///   `http`, `https`, `ws`, `wss` or `ftp`\n    /// * If either the old or new scheme is `http`, `https`, `ws`,\n    ///   `wss` or `ftp` and the other is not one of these\n    /// * If the new scheme is `file` and this URL includes credentials\n    ///   or has a non-null port\n    /// * If this URL's scheme is `file` and its host is empty or null\n    ///\n    /// See also [the URL specification's section on legal scheme state\n    /// overrides](https://url.spec.whatwg.org/#scheme-state).\n    ///\n    /// # Examples\n    ///\n    /// Change the URL’s scheme from `https` to `foo`:\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"https://example.net\")?;\n    /// let result = url.set_scheme(\"http\");\n    /// assert_eq!(url.as_str(), \"http://example.net/\");\n    /// assert!(result.is_ok());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    /// Change the URL’s scheme from `foo` to `bar`:\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"foo://example.net\")?;\n    /// let result = url.set_scheme(\"bar\");\n    /// assert_eq!(url.as_str(), \"bar://example.net\");\n    /// assert!(result.is_ok());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// Cannot change URL’s scheme from `https` to `foõ`:\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"https://example.net\")?;\n    /// let result = url.set_scheme(\"foõ\");\n    /// assert_eq!(url.as_str(), \"https://example.net/\");\n    /// assert!(result.is_err());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// Cannot change URL’s scheme from `mailto` (cannot-be-a-base) to `https`:\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"mailto:rms@example.net\")?;\n    /// let result = url.set_scheme(\"https\");\n    /// assert_eq!(url.as_str(), \"mailto:rms@example.net\");\n    /// assert!(result.is_err());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    /// Cannot change the URL’s scheme from `foo` to `https`:\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"foo://example.net\")?;\n    /// let result = url.set_scheme(\"https\");\n    /// assert_eq!(url.as_str(), \"foo://example.net\");\n    /// assert!(result.is_err());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    /// Cannot change the URL’s scheme from `http` to `foo`:\n    ///\n    /// ```\n    /// use url::Url;\n    /// # use url::ParseError;\n    ///\n    /// # fn run() -> Result<(), ParseError> {\n    /// let mut url = Url::parse(\"http://example.net\")?;\n    /// let result = url.set_scheme(\"foo\");\n    /// assert_eq!(url.as_str(), \"http://example.net/\");\n    /// assert!(result.is_err());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn set_scheme(&mut self, scheme: &str) -> Result<(), ()> {\n        let mut parser = Parser::for_setter(String::new());\n        let remaining = parser.parse_scheme(parser::Input::new(scheme))?;\n        let new_scheme_type = SchemeType::from(&parser.serialization);\n        let old_scheme_type = SchemeType::from(self.scheme());\n        // If url’s scheme is a special scheme and buffer is not a special scheme, then return.\n        if (new_scheme_type.is_special() && !old_scheme_type.is_special()) ||\n            // If url’s scheme is not a special scheme and buffer is a special scheme, then return.\n            (!new_scheme_type.is_special() && old_scheme_type.is_special()) ||\n            // If url includes credentials or has a non-null port, and buffer is \"file\", then return.\n            // If url’s scheme is \"file\" and its host is an empty host or null, then return.\n            (new_scheme_type.is_file() && self.has_authority())\n        {\n            return Err(());\n        }\n\n        if !remaining.is_empty() || (!self.has_host() && new_scheme_type.is_special()) {\n            return Err(());\n        }\n        let old_scheme_end = self.scheme_end;\n        let new_scheme_end = to_u32(parser.serialization.len()).unwrap();\n        let adjust = |index: &mut u32| {\n            *index -= old_scheme_end;\n            *index += new_scheme_end;\n        };\n\n        self.scheme_end = new_scheme_end;\n        adjust(&mut self.username_end);\n        adjust(&mut self.host_start);\n        adjust(&mut self.host_end);\n        adjust(&mut self.path_start);\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n\n        parser.serialization.push_str(self.slice(old_scheme_end..));\n        self.serialization = parser.serialization;\n\n        // Update the port so it can be removed\n        // If it is the scheme's default\n        // we don't mind it silently failing\n        // if there was no port in the first place\n        let previous_port = self.port();\n        let _ = self.set_port(previous_port);\n\n        Ok(())\n    }\n\n    /// Convert a file name as `std::path::Path` into an URL in the `file` scheme.\n    ///\n    /// This returns `Err` if the given path is not absolute or,\n    /// on Windows, if the prefix is not a disk prefix (e.g. `C:`) or a UNC prefix (`\\\\`).\n    ///\n    /// # Examples\n    ///\n    /// On Unix-like platforms:\n    ///\n    /// ```\n    /// # if cfg!(unix) {\n    /// use url::Url;\n    ///\n    /// # fn run() -> Result<(), ()> {\n    /// let url = Url::from_file_path(\"/tmp/foo.txt\")?;\n    /// assert_eq!(url.as_str(), \"file:///tmp/foo.txt\");\n    ///\n    /// let url = Url::from_file_path(\"../foo.txt\");\n    /// assert!(url.is_err());\n    ///\n    /// let url = Url::from_file_path(\"https://google.com/\");\n    /// assert!(url.is_err());\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// # }\n    /// ```\n    #[cfg(any(unix, windows, target_os = \"redox\"))]\n    pub fn from_file_path<P: AsRef<Path>>(path: P) -> Result<Url, ()> {\n        let mut serialization = \"file://\".to_owned();\n        let host_start = serialization.len() as u32;\n        let (host_end, host) = path_to_file_url_segments(path.as_ref(), &mut serialization)?;\n        Ok(Url {\n            serialization,\n            scheme_end: \"file\".len() as u32,\n            username_end: host_start,\n            host_start,\n            host_end,\n            host,\n            port: None,\n            path_start: host_end,\n            query_start: None,\n            fragment_start: None,\n        })\n    }\n\n    /// Convert a directory name as `std::path::Path` into an URL in the `file` scheme.\n    ///\n    /// This returns `Err` if the given path is not absolute or,\n    /// on Windows, if the prefix is not a disk prefix (e.g. `C:`) or a UNC prefix (`\\\\`).\n    ///\n    /// Compared to `from_file_path`, this ensure that URL’s the path has a trailing slash\n    /// so that the entire path is considered when using this URL as a base URL.\n    ///\n    /// For example:\n    ///\n    /// * `\"index.html\"` parsed with `Url::from_directory_path(Path::new(\"/var/www\"))`\n    ///   as the base URL is `file:///var/www/index.html`\n    /// * `\"index.html\"` parsed with `Url::from_file_path(Path::new(\"/var/www\"))`\n    ///   as the base URL is `file:///var/index.html`, which might not be what was intended.\n    ///\n    /// Note that `std::path` does not consider trailing slashes significant\n    /// and usually does not include them (e.g. in `Path::parent()`).\n    #[cfg(any(unix, windows, target_os = \"redox\"))]\n    pub fn from_directory_path<P: AsRef<Path>>(path: P) -> Result<Url, ()> {\n        let mut url = Url::from_file_path(path)?;\n        if !url.serialization.ends_with('/') {\n            url.serialization.push('/')\n        }\n        Ok(url)\n    }\n\n    /// Serialize with Serde using the internal representation of the `Url` struct.\n    ///\n    /// The corresponding `deserialize_internal` method sacrifices some invariant-checking\n    /// for speed, compared to the `Deserialize` trait impl.\n    ///\n    /// This method is only available if the `serde` Cargo feature is enabled.\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn serialize_internal<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        use serde::Serialize;\n        // Destructuring first lets us ensure that adding or removing fields forces this method\n        // to be updated\n        let Url {\n            ref serialization,\n            ref scheme_end,\n            ref username_end,\n            ref host_start,\n            ref host_end,\n            ref host,\n            ref port,\n            ref path_start,\n            ref query_start,\n            ref fragment_start,\n        } = *self;\n        (\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        )\n            .serialize(serializer)\n    }\n\n    /// Serialize with Serde using the internal representation of the `Url` struct.\n    ///\n    /// The corresponding `deserialize_internal` method sacrifices some invariant-checking\n    /// for speed, compared to the `Deserialize` trait impl.\n    ///\n    /// This method is only available if the `serde` Cargo feature is enabled.\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn deserialize_internal<'de, D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        use serde::de::{Deserialize, Error, Unexpected};\n        let (\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        ) = Deserialize::deserialize(deserializer)?;\n        let url = Url {\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        };\n        if cfg!(debug_assertions) {\n            url.check_invariants().map_err(|reason| {\n                let reason: &str = &reason;\n                Error::invalid_value(Unexpected::Other(\"value\"), &reason)\n            })?\n        }\n        Ok(url)\n    }\n\n    /// Assuming the URL is in the `file` scheme or similar,\n    /// convert its path to an absolute `std::path::Path`.\n    ///\n    /// **Note:** This does not actually check the URL’s `scheme`,\n    /// and may give nonsensical results for other schemes.\n    /// It is the user’s responsibility to check the URL’s scheme before calling this.\n    ///\n    /// ```\n    /// # use url::Url;\n    /// # let url = Url::parse(\"file:///etc/passwd\").unwrap();\n    /// let path = url.to_file_path();\n    /// ```\n    ///\n    /// Returns `Err` if the host is neither empty nor `\"localhost\"` (except on Windows, where\n    /// `file:` URLs may have a non-local host),\n    /// or if `Path::new_opt()` returns `None`.\n    /// (That is, if the percent-decoded path contains a NUL byte or,\n    /// for a Windows path, is not UTF-8.)\n    #[inline]\n    #[cfg(any(unix, windows, target_os = \"redox\"))]\n    pub fn to_file_path(&self) -> Result<PathBuf, ()> {\n        if let Some(segments) = self.path_segments() {\n            let host = match self.host() {\n                None | Some(Host::Domain(\"localhost\")) => None,\n                Some(_) if cfg!(windows) && self.scheme() == \"file\" => {\n                    Some(&self.serialization[self.host_start as usize..self.host_end as usize])\n                }\n                _ => return Err(()),\n            };\n\n            return file_url_segments_to_pathbuf(host, segments);\n        }\n        Err(())\n    }\n\n    // Private helper methods:\n\n    #[inline]\n    fn slice<R>(&self, range: R) -> &str\n    where\n        R: RangeArg,\n    {\n        range.slice_of(&self.serialization)\n    }\n\n    #[inline]\n    fn byte_at(&self, i: u32) -> u8 {\n        self.serialization.as_bytes()[i as usize]\n    }\n}","impl fmt::Debug for Url {\n    #[inline]\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter\n            .debug_struct(\"Url\")\n            .field(\"scheme\", &self.scheme())\n            .field(\"host\", &self.host())\n            .field(\"port\", &self.port())\n            .field(\"path\", &self.path())\n            .field(\"query\", &self.query())\n            .field(\"fragment\", &self.fragment())\n            .finish()\n    }\n}","impl fmt::Display for Url {\n    #[inline]\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(&self.serialization, formatter)\n    }\n}","impl hash::Hash for Url {\n    #[inline]\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: hash::Hasher,\n    {\n        hash::Hash::hash(&self.serialization, state)\n    }\n}","impl str::FromStr for Url {\n    type Err = ParseError;\n\n    #[inline]\n    fn from_str(input: &str) -> Result<Url, crate::ParseError> {\n        Url::parse(input)\n    }\n}","impl<'a> TryFrom<&'a str> for Url {\n    type Error = ParseError;\n\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        Url::parse(s)\n    }\n}"],"UrlQuery":["Debug","impl<'a> Drop for UrlQuery<'a> {\n    fn drop(&mut self) {\n        if let Some(url) = self.url.take() {\n            url.restore_already_parsed_fragment(self.fragment.take())\n        }\n    }\n}","impl<'a> form_urlencoded::Target for UrlQuery<'a> {\n    fn as_mut_string(&mut self) -> &mut String {\n        &mut self.url.as_mut().unwrap().serialization\n    }\n\n    fn finish(mut self) -> &'a mut Url {\n        let url = self.url.take().unwrap();\n        url.restore_already_parsed_fragment(self.fragment.take());\n        url\n    }\n\n    type Finished = &'a mut Url;\n}"],"host::Host":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Host<String> {\n    /// Parse a host: either an IPv6 address in [] square brackets, or a domain.\n    ///\n    /// <https://url.spec.whatwg.org/#host-parsing>\n    pub fn parse(input: &str) -> Result<Self, ParseError> {\n        if input.starts_with('[') {\n            if !input.ends_with(']') {\n                return Err(ParseError::InvalidIpv6Address);\n            }\n            return parse_ipv6addr(&input[1..input.len() - 1]).map(Host::Ipv6);\n        }\n        let domain = percent_decode(input.as_bytes()).decode_utf8_lossy();\n        let domain = idna::domain_to_ascii(&domain)?;\n        if domain.is_empty() {\n            return Err(ParseError::EmptyHost);\n        }\n\n        let is_invalid_domain_char = |c| {\n            matches!(\n                c,\n                '\\0' | '\\t'\n                    | '\\n'\n                    | '\\r'\n                    | ' '\n                    | '#'\n                    | '%'\n                    | '/'\n                    | ':'\n                    | '<'\n                    | '>'\n                    | '?'\n                    | '@'\n                    | '['\n                    | '\\\\'\n                    | ']'\n                    | '^'\n            )\n        };\n\n        if domain.find(is_invalid_domain_char).is_some() {\n            Err(ParseError::InvalidDomainCharacter)\n        } else if let Some(address) = parse_ipv4addr(&domain)? {\n            Ok(Host::Ipv4(address))\n        } else {\n            Ok(Host::Domain(domain))\n        }\n    }\n\n    // <https://url.spec.whatwg.org/#concept-opaque-host-parser>\n    pub fn parse_opaque(input: &str) -> Result<Self, ParseError> {\n        if input.starts_with('[') {\n            if !input.ends_with(']') {\n                return Err(ParseError::InvalidIpv6Address);\n            }\n            return parse_ipv6addr(&input[1..input.len() - 1]).map(Host::Ipv6);\n        }\n\n        let is_invalid_host_char = |c| {\n            matches!(\n                c,\n                '\\0' | '\\t'\n                    | '\\n'\n                    | '\\r'\n                    | ' '\n                    | '#'\n                    | '/'\n                    | ':'\n                    | '<'\n                    | '>'\n                    | '?'\n                    | '@'\n                    | '['\n                    | '\\\\'\n                    | ']'\n                    | '^'\n            )\n        };\n\n        if input.find(is_invalid_host_char).is_some() {\n            Err(ParseError::InvalidDomainCharacter)\n        } else {\n            Ok(Host::Domain(\n                utf8_percent_encode(input, CONTROLS).to_string(),\n            ))\n        }\n    }\n}","impl<'a> Host<&'a str> {\n    /// Return a copy of `self` that owns an allocated `String` but does not borrow an `&Url`.\n    pub fn to_owned(&self) -> Host<String> {\n        match *self {\n            Host::Domain(domain) => Host::Domain(domain.to_owned()),\n            Host::Ipv4(address) => Host::Ipv4(address),\n            Host::Ipv6(address) => Host::Ipv6(address),\n        }\n    }\n}","impl<S: AsRef<str>> fmt::Display for Host<S> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        match *self {\n            Host::Domain(ref domain) => domain.as_ref().fmt(f),\n            Host::Ipv4(ref addr) => addr.fmt(f),\n            Host::Ipv6(ref addr) => {\n                f.write_str(\"[\")?;\n                write_ipv6(addr, f)?;\n                f.write_str(\"]\")\n            }\n        }\n    }\n}"],"host::HostInternal":["Clone","Copy","Debug","Eq","PartialEq","impl From<Host<String>> for HostInternal {\n    fn from(host: Host<String>) -> HostInternal {\n        match host {\n            Host::Domain(ref s) if s.is_empty() => HostInternal::None,\n            Host::Domain(_) => HostInternal::Domain,\n            Host::Ipv4(address) => HostInternal::Ipv4(address),\n            Host::Ipv6(address) => HostInternal::Ipv6(address),\n        }\n    }\n}"],"origin::OpaqueOrigin":["Clone","Debug","Eq","Hash","PartialEq"],"origin::Origin":["Clone","Debug","Eq","Hash","PartialEq","impl Origin {\n    /// Creates a new opaque origin that is only equal to itself.\n    pub fn new_opaque() -> Origin {\n        static COUNTER: AtomicUsize = AtomicUsize::new(0);\n        Origin::Opaque(OpaqueOrigin(COUNTER.fetch_add(1, Ordering::SeqCst)))\n    }\n\n    /// Return whether this origin is a (scheme, host, port) tuple\n    /// (as opposed to an opaque origin).\n    pub fn is_tuple(&self) -> bool {\n        matches!(*self, Origin::Tuple(..))\n    }\n\n    /// <https://html.spec.whatwg.org/multipage/#ascii-serialisation-of-an-origin>\n    pub fn ascii_serialization(&self) -> String {\n        match *self {\n            Origin::Opaque(_) => \"null\".to_owned(),\n            Origin::Tuple(ref scheme, ref host, port) => {\n                if default_port(scheme) == Some(port) {\n                    format!(\"{}://{}\", scheme, host)\n                } else {\n                    format!(\"{}://{}:{}\", scheme, host, port)\n                }\n            }\n        }\n    }\n\n    /// <https://html.spec.whatwg.org/multipage/#unicode-serialisation-of-an-origin>\n    pub fn unicode_serialization(&self) -> String {\n        match *self {\n            Origin::Opaque(_) => \"null\".to_owned(),\n            Origin::Tuple(ref scheme, ref host, port) => {\n                let host = match *host {\n                    Host::Domain(ref domain) => {\n                        let (domain, _errors) = domain_to_unicode(domain);\n                        Host::Domain(domain)\n                    }\n                    _ => host.clone(),\n                };\n                if default_port(scheme) == Some(port) {\n                    format!(\"{}://{}\", scheme, host)\n                } else {\n                    format!(\"{}://{}:{}\", scheme, host, port)\n                }\n            }\n        }\n    }\n}"],"parser::Context":["Clone","Copy","Eq","PartialEq"],"parser::Input":["Clone","impl<'i> Input<'i> {\n    pub fn new(input: &'i str) -> Self {\n        Input::with_log(input, None)\n    }\n\n    pub fn no_trim(input: &'i str) -> Self {\n        Input {\n            chars: input.chars(),\n        }\n    }\n\n    pub fn trim_tab_and_newlines(\n        original_input: &'i str,\n        vfn: Option<&dyn Fn(SyntaxViolation)>,\n    ) -> Self {\n        let input = original_input.trim_matches(ascii_tab_or_new_line);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(|c| matches!(c, '\\t' | '\\n' | '\\r')) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input {\n            chars: input.chars(),\n        }\n    }\n\n    pub fn with_log(original_input: &'i str, vfn: Option<&dyn Fn(SyntaxViolation)>) -> Self {\n        let input = original_input.trim_matches(c0_control_or_space);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(|c| matches!(c, '\\t' | '\\n' | '\\r')) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input {\n            chars: input.chars(),\n        }\n    }\n\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.clone().next().is_none()\n    }\n\n    #[inline]\n    fn starts_with<P: Pattern>(&self, p: P) -> bool {\n        p.split_prefix(&mut self.clone())\n    }\n\n    #[inline]\n    pub fn split_prefix<P: Pattern>(&self, p: P) -> Option<Self> {\n        let mut remaining = self.clone();\n        if p.split_prefix(&mut remaining) {\n            Some(remaining)\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn split_first(&self) -> (Option<char>, Self) {\n        let mut remaining = self.clone();\n        (remaining.next(), remaining)\n    }\n\n    #[inline]\n    fn count_matching<F: Fn(char) -> bool>(&self, f: F) -> (u32, Self) {\n        let mut count = 0;\n        let mut remaining = self.clone();\n        loop {\n            let mut input = remaining.clone();\n            if matches!(input.next(), Some(c) if f(c)) {\n                remaining = input;\n                count += 1;\n            } else {\n                return (count, remaining);\n            }\n        }\n    }\n\n    #[inline]\n    fn next_utf8(&mut self) -> Option<(char, &'i str)> {\n        loop {\n            let utf8 = self.chars.as_str();\n            match self.chars.next() {\n                Some(c) => {\n                    if !matches!(c, '\\t' | '\\n' | '\\r') {\n                        return Some((c, &utf8[..c.len_utf8()]));\n                    }\n                }\n                None => return None,\n            }\n        }\n    }\n}","impl<'i> Iterator for Input<'i> {\n    type Item = char;\n    fn next(&mut self) -> Option<char> {\n        self.chars\n            .by_ref()\n            .find(|&c| !matches!(c, '\\t' | '\\n' | '\\r'))\n    }\n}"],"parser::ParseError":["Clone","Copy","Debug","Eq","PartialEq","impl Error for ParseError {}","impl From<::idna::Errors> for ParseError {\n    fn from(_: ::idna::Errors) -> ParseError {\n        ParseError::IdnaError\n    }\n}","impl fmt::Display for ParseError {\n            fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n                match *self {\n                    $(\n                        ParseError::$name => fmt.write_str($description),\n                    )+\n                    ParseError::__FutureProof => {\n                        unreachable!(\"Don't abuse the FutureProof!\");\n                    }\n                }\n            }\n        }"],"parser::Parser":["impl<'a> Parser<'a> {\n    fn log_violation(&self, v: SyntaxViolation) {\n        if let Some(f) = self.violation_fn {\n            f(v)\n        }\n    }\n\n    fn log_violation_if(&self, v: SyntaxViolation, test: impl FnOnce() -> bool) {\n        if let Some(f) = self.violation_fn {\n            if test() {\n                f(v)\n            }\n        }\n    }\n\n    pub fn for_setter(serialization: String) -> Parser<'a> {\n        Parser {\n            serialization,\n            base_url: None,\n            query_encoding_override: None,\n            violation_fn: None,\n            context: Context::Setter,\n        }\n    }\n\n    /// https://url.spec.whatwg.org/#concept-basic-url-parser\n    pub fn parse_url(mut self, input: &str) -> ParseResult<Url> {\n        let input = Input::with_log(input, self.violation_fn);\n        if let Ok(remaining) = self.parse_scheme(input.clone()) {\n            return self.parse_with_scheme(remaining);\n        }\n\n        // No-scheme state\n        if let Some(base_url) = self.base_url {\n            if input.starts_with('#') {\n                self.fragment_only(base_url, input)\n            } else if base_url.cannot_be_a_base() {\n                Err(ParseError::RelativeUrlWithCannotBeABaseBase)\n            } else {\n                let scheme_type = SchemeType::from(base_url.scheme());\n                if scheme_type.is_file() {\n                    self.parse_file(input, scheme_type, Some(base_url))\n                } else {\n                    self.parse_relative(input, scheme_type, base_url)\n                }\n            }\n        } else {\n            Err(ParseError::RelativeUrlWithoutBase)\n        }\n    }\n\n    pub fn parse_scheme<'i>(&mut self, mut input: Input<'i>) -> Result<Input<'i>, ()> {\n        if input.is_empty() || !input.starts_with(ascii_alpha) {\n            return Err(());\n        }\n        debug_assert!(self.serialization.is_empty());\n        while let Some(c) = input.next() {\n            match c {\n                'a'..='z' | 'A'..='Z' | '0'..='9' | '+' | '-' | '.' => {\n                    self.serialization.push(c.to_ascii_lowercase())\n                }\n                ':' => return Ok(input),\n                _ => {\n                    self.serialization.clear();\n                    return Err(());\n                }\n            }\n        }\n        // EOF before ':'\n        if self.context == Context::Setter {\n            Ok(input)\n        } else {\n            self.serialization.clear();\n            Err(())\n        }\n    }\n\n    fn parse_with_scheme(mut self, input: Input<'_>) -> ParseResult<Url> {\n        use crate::SyntaxViolation::{ExpectedDoubleSlash, ExpectedFileDoubleSlash};\n        let scheme_end = to_u32(self.serialization.len())?;\n        let scheme_type = SchemeType::from(&self.serialization);\n        self.serialization.push(':');\n        match scheme_type {\n            SchemeType::File => {\n                self.log_violation_if(ExpectedFileDoubleSlash, || !input.starts_with(\"//\"));\n                let base_file_url = self.base_url.and_then(|base| {\n                    if base.scheme() == \"file\" {\n                        Some(base)\n                    } else {\n                        None\n                    }\n                });\n                self.serialization.clear();\n                self.parse_file(input, scheme_type, base_file_url)\n            }\n            SchemeType::SpecialNotFile => {\n                // special relative or authority state\n                let (slashes_count, remaining) = input.count_matching(|c| matches!(c, '/' | '\\\\'));\n                if let Some(base_url) = self.base_url {\n                    if slashes_count < 2\n                        && base_url.scheme() == &self.serialization[..scheme_end as usize]\n                    {\n                        // \"Cannot-be-a-base\" URLs only happen with \"not special\" schemes.\n                        debug_assert!(!base_url.cannot_be_a_base());\n                        self.serialization.clear();\n                        return self.parse_relative(input, scheme_type, base_url);\n                    }\n                }\n                // special authority slashes state\n                self.log_violation_if(ExpectedDoubleSlash, || {\n                    input\n                        .clone()\n                        .take_while(|&c| matches!(c, '/' | '\\\\'))\n                        .collect::<String>()\n                        != \"//\"\n                });\n                self.after_double_slash(remaining, scheme_type, scheme_end)\n            }\n            SchemeType::NotSpecial => self.parse_non_special(input, scheme_type, scheme_end),\n        }\n    }\n\n    /// Scheme other than file, http, https, ws, ws, ftp.\n    fn parse_non_special(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n    ) -> ParseResult<Url> {\n        // path or authority state (\n        if let Some(input) = input.split_prefix(\"//\") {\n            return self.after_double_slash(input, scheme_type, scheme_end);\n        }\n        // Anarchist URL (no authority)\n        let path_start = to_u32(self.serialization.len())?;\n        let username_end = path_start;\n        let host_start = path_start;\n        let host_end = path_start;\n        let host = HostInternal::None;\n        let port = None;\n        let remaining = if let Some(input) = input.split_prefix('/') {\n            let path_start = self.serialization.len();\n            self.serialization.push('/');\n            self.parse_path(scheme_type, &mut false, path_start, input)\n        } else {\n            self.parse_cannot_be_a_base_path(input)\n        };\n        self.with_query_and_fragment(\n            scheme_type,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            remaining,\n        )\n    }\n\n    fn parse_file(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        base_file_url: Option<&Url>,\n    ) -> ParseResult<Url> {\n        use crate::SyntaxViolation::Backslash;\n        // file state\n        debug_assert!(self.serialization.is_empty());\n        let (first_char, input_after_first_char) = input.split_first();\n        if matches!(first_char, Some('/') | Some('\\\\')) {\n            self.log_violation_if(SyntaxViolation::Backslash, || first_char == Some('\\\\'));\n            // file slash state\n            let (next_char, input_after_next_char) = input_after_first_char.split_first();\n            if matches!(next_char, Some('/') | Some('\\\\')) {\n                self.log_violation_if(Backslash, || next_char == Some('\\\\'));\n                // file host state\n                self.serialization.push_str(\"file://\");\n                let scheme_end = \"file\".len() as u32;\n                let host_start = \"file://\".len() as u32;\n                let (path_start, mut host, remaining) =\n                    self.parse_file_host(input_after_next_char)?;\n                let mut host_end = to_u32(self.serialization.len())?;\n                let mut has_host = !matches!(host, HostInternal::None);\n                let remaining = if path_start {\n                    self.parse_path_start(SchemeType::File, &mut has_host, remaining)\n                } else {\n                    let path_start = self.serialization.len();\n                    self.serialization.push('/');\n                    self.parse_path(SchemeType::File, &mut has_host, path_start, remaining)\n                };\n\n                // For file URLs that have a host and whose path starts\n                // with the windows drive letter we just remove the host.\n                if !has_host {\n                    self.serialization\n                        .drain(host_start as usize..host_end as usize);\n                    host_end = host_start;\n                    host = HostInternal::None;\n                }\n                let (query_start, fragment_start) =\n                    self.parse_query_and_fragment(scheme_type, scheme_end, remaining)?;\n                return Ok(Url {\n                    serialization: self.serialization,\n                    scheme_end,\n                    username_end: host_start,\n                    host_start,\n                    host_end,\n                    host,\n                    port: None,\n                    path_start: host_end,\n                    query_start,\n                    fragment_start,\n                });\n            } else {\n                self.serialization.push_str(\"file://\");\n                let scheme_end = \"file\".len() as u32;\n                let host_start = \"file://\".len();\n                let mut host_end = host_start;\n                let mut host = HostInternal::None;\n                if !starts_with_windows_drive_letter_segment(&input_after_first_char) {\n                    if let Some(base_url) = base_file_url {\n                        let first_segment = base_url.path_segments().unwrap().next().unwrap();\n                        if is_normalized_windows_drive_letter(first_segment) {\n                            self.serialization.push('/');\n                            self.serialization.push_str(first_segment);\n                        } else if let Some(host_str) = base_url.host_str() {\n                            self.serialization.push_str(host_str);\n                            host_end = self.serialization.len();\n                            host = base_url.host;\n                        }\n                    }\n                }\n                // If c is the EOF code point, U+002F (/), U+005C (\\), U+003F (?), or U+0023 (#), then decrease pointer by one\n                let parse_path_input = if let Some(c) = first_char {\n                    if c == '/' || c == '\\\\' || c == '?' || c == '#' {\n                        input\n                    } else {\n                        input_after_first_char\n                    }\n                } else {\n                    input_after_first_char\n                };\n\n                let remaining =\n                    self.parse_path(SchemeType::File, &mut false, host_end, parse_path_input);\n\n                let host_start = host_start as u32;\n\n                let (query_start, fragment_start) =\n                    self.parse_query_and_fragment(scheme_type, scheme_end, remaining)?;\n\n                let host_end = host_end as u32;\n                return Ok(Url {\n                    serialization: self.serialization,\n                    scheme_end,\n                    username_end: host_start,\n                    host_start,\n                    host_end,\n                    host,\n                    port: None,\n                    path_start: host_end,\n                    query_start,\n                    fragment_start,\n                });\n            }\n        }\n        if let Some(base_url) = base_file_url {\n            match first_char {\n                None => {\n                    // Copy everything except the fragment\n                    let before_fragment = match base_url.fragment_start {\n                        Some(i) => &base_url.serialization[..i as usize],\n                        None => &*base_url.serialization,\n                    };\n                    self.serialization.push_str(before_fragment);\n                    Ok(Url {\n                        serialization: self.serialization,\n                        fragment_start: None,\n                        ..*base_url\n                    })\n                }\n                Some('?') => {\n                    // Copy everything up to the query string\n                    let before_query = match (base_url.query_start, base_url.fragment_start) {\n                        (None, None) => &*base_url.serialization,\n                        (Some(i), _) | (None, Some(i)) => base_url.slice(..i),\n                    };\n                    self.serialization.push_str(before_query);\n                    let (query_start, fragment_start) =\n                        self.parse_query_and_fragment(scheme_type, base_url.scheme_end, input)?;\n                    Ok(Url {\n                        serialization: self.serialization,\n                        query_start,\n                        fragment_start,\n                        ..*base_url\n                    })\n                }\n                Some('#') => self.fragment_only(base_url, input),\n                _ => {\n                    if !starts_with_windows_drive_letter_segment(&input) {\n                        let before_query = match (base_url.query_start, base_url.fragment_start) {\n                            (None, None) => &*base_url.serialization,\n                            (Some(i), _) | (None, Some(i)) => base_url.slice(..i),\n                        };\n                        self.serialization.push_str(before_query);\n                        self.shorten_path(SchemeType::File, base_url.path_start as usize);\n                        let remaining = self.parse_path(\n                            SchemeType::File,\n                            &mut true,\n                            base_url.path_start as usize,\n                            input,\n                        );\n                        self.with_query_and_fragment(\n                            SchemeType::File,\n                            base_url.scheme_end,\n                            base_url.username_end,\n                            base_url.host_start,\n                            base_url.host_end,\n                            base_url.host,\n                            base_url.port,\n                            base_url.path_start,\n                            remaining,\n                        )\n                    } else {\n                        self.serialization.push_str(\"file:///\");\n                        let scheme_end = \"file\".len() as u32;\n                        let path_start = \"file://\".len();\n                        let remaining =\n                            self.parse_path(SchemeType::File, &mut false, path_start, input);\n                        let (query_start, fragment_start) =\n                            self.parse_query_and_fragment(SchemeType::File, scheme_end, remaining)?;\n                        let path_start = path_start as u32;\n                        Ok(Url {\n                            serialization: self.serialization,\n                            scheme_end,\n                            username_end: path_start,\n                            host_start: path_start,\n                            host_end: path_start,\n                            host: HostInternal::None,\n                            port: None,\n                            path_start,\n                            query_start,\n                            fragment_start,\n                        })\n                    }\n                }\n            }\n        } else {\n            self.serialization.push_str(\"file:///\");\n            let scheme_end = \"file\".len() as u32;\n            let path_start = \"file://\".len();\n            let remaining = self.parse_path(SchemeType::File, &mut false, path_start, input);\n            let (query_start, fragment_start) =\n                self.parse_query_and_fragment(SchemeType::File, scheme_end, remaining)?;\n            let path_start = path_start as u32;\n            Ok(Url {\n                serialization: self.serialization,\n                scheme_end,\n                username_end: path_start,\n                host_start: path_start,\n                host_end: path_start,\n                host: HostInternal::None,\n                port: None,\n                path_start,\n                query_start,\n                fragment_start,\n            })\n        }\n    }\n\n    fn parse_relative(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        base_url: &Url,\n    ) -> ParseResult<Url> {\n        // relative state\n        debug_assert!(self.serialization.is_empty());\n        let (first_char, input_after_first_char) = input.split_first();\n        match first_char {\n            None => {\n                // Copy everything except the fragment\n                let before_fragment = match base_url.fragment_start {\n                    Some(i) => &base_url.serialization[..i as usize],\n                    None => &*base_url.serialization,\n                };\n                self.serialization.push_str(before_fragment);\n                Ok(Url {\n                    serialization: self.serialization,\n                    fragment_start: None,\n                    ..*base_url\n                })\n            }\n            Some('?') => {\n                // Copy everything up to the query string\n                let before_query = match (base_url.query_start, base_url.fragment_start) {\n                    (None, None) => &*base_url.serialization,\n                    (Some(i), _) | (None, Some(i)) => base_url.slice(..i),\n                };\n                self.serialization.push_str(before_query);\n                let (query_start, fragment_start) =\n                    self.parse_query_and_fragment(scheme_type, base_url.scheme_end, input)?;\n                Ok(Url {\n                    serialization: self.serialization,\n                    query_start,\n                    fragment_start,\n                    ..*base_url\n                })\n            }\n            Some('#') => self.fragment_only(base_url, input),\n            Some('/') | Some('\\\\') => {\n                let (slashes_count, remaining) = input.count_matching(|c| matches!(c, '/' | '\\\\'));\n                if slashes_count >= 2 {\n                    self.log_violation_if(SyntaxViolation::ExpectedDoubleSlash, || {\n                        input\n                            .clone()\n                            .take_while(|&c| matches!(c, '/' | '\\\\'))\n                            .collect::<String>()\n                            != \"//\"\n                    });\n                    let scheme_end = base_url.scheme_end;\n                    debug_assert!(base_url.byte_at(scheme_end) == b':');\n                    self.serialization\n                        .push_str(base_url.slice(..scheme_end + 1));\n                    if let Some(after_prefix) = input.split_prefix(\"//\") {\n                        return self.after_double_slash(after_prefix, scheme_type, scheme_end);\n                    }\n                    return self.after_double_slash(remaining, scheme_type, scheme_end);\n                }\n                let path_start = base_url.path_start;\n                self.serialization.push_str(base_url.slice(..path_start));\n                self.serialization.push('/');\n                let remaining = self.parse_path(\n                    scheme_type,\n                    &mut true,\n                    path_start as usize,\n                    input_after_first_char,\n                );\n                self.with_query_and_fragment(\n                    scheme_type,\n                    base_url.scheme_end,\n                    base_url.username_end,\n                    base_url.host_start,\n                    base_url.host_end,\n                    base_url.host,\n                    base_url.port,\n                    base_url.path_start,\n                    remaining,\n                )\n            }\n            _ => {\n                let before_query = match (base_url.query_start, base_url.fragment_start) {\n                    (None, None) => &*base_url.serialization,\n                    (Some(i), _) | (None, Some(i)) => base_url.slice(..i),\n                };\n                self.serialization.push_str(before_query);\n                // FIXME spec says just \"remove last entry\", not the \"pop\" algorithm\n                self.pop_path(scheme_type, base_url.path_start as usize);\n                // A special url always has a path.\n                // A path always starts with '/'\n                if self.serialization.len() == base_url.path_start as usize\n                    && (SchemeType::from(base_url.scheme()).is_special() || !input.is_empty())\n                {\n                    self.serialization.push('/');\n                }\n                let remaining = match input.split_first() {\n                    (Some('/'), remaining) => self.parse_path(\n                        scheme_type,\n                        &mut true,\n                        base_url.path_start as usize,\n                        remaining,\n                    ),\n                    _ => {\n                        self.parse_path(scheme_type, &mut true, base_url.path_start as usize, input)\n                    }\n                };\n                self.with_query_and_fragment(\n                    scheme_type,\n                    base_url.scheme_end,\n                    base_url.username_end,\n                    base_url.host_start,\n                    base_url.host_end,\n                    base_url.host,\n                    base_url.port,\n                    base_url.path_start,\n                    remaining,\n                )\n            }\n        }\n    }\n\n    fn after_double_slash(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n    ) -> ParseResult<Url> {\n        self.serialization.push('/');\n        self.serialization.push('/');\n        // authority state\n        let before_authority = self.serialization.len();\n        let (username_end, remaining) = self.parse_userinfo(input, scheme_type)?;\n        let has_authority = before_authority != self.serialization.len();\n        // host state\n        let host_start = to_u32(self.serialization.len())?;\n        let (host_end, host, port, remaining) =\n            self.parse_host_and_port(remaining, scheme_end, scheme_type)?;\n        if host == HostInternal::None && has_authority {\n            return Err(ParseError::EmptyHost);\n        }\n        // path state\n        let path_start = to_u32(self.serialization.len())?;\n        let remaining = self.parse_path_start(scheme_type, &mut true, remaining);\n        self.with_query_and_fragment(\n            scheme_type,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            remaining,\n        )\n    }\n\n    /// Return (username_end, remaining)\n    fn parse_userinfo<'i>(\n        &mut self,\n        mut input: Input<'i>,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(u32, Input<'i>)> {\n        let mut last_at = None;\n        let mut remaining = input.clone();\n        let mut char_count = 0;\n        while let Some(c) = remaining.next() {\n            match c {\n                '@' => {\n                    if last_at.is_some() {\n                        self.log_violation(SyntaxViolation::UnencodedAtSign)\n                    } else {\n                        self.log_violation(SyntaxViolation::EmbeddedCredentials)\n                    }\n                    last_at = Some((char_count, remaining.clone()))\n                }\n                '/' | '?' | '#' => break,\n                '\\\\' if scheme_type.is_special() => break,\n                _ => (),\n            }\n            char_count += 1;\n        }\n        let (mut userinfo_char_count, remaining) = match last_at {\n            None => return Ok((to_u32(self.serialization.len())?, input)),\n            Some((0, remaining)) => {\n                // Otherwise, if one of the following is true\n                // c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)\n                // url is special and c is U+005C (\\)\n                // If @ flag is set and buffer is the empty string, validation error, return failure.\n                if let (Some(c), _) = remaining.split_first() {\n                    if c == '/' || c == '?' || c == '#' || (scheme_type.is_special() && c == '\\\\') {\n                        return Err(ParseError::EmptyHost);\n                    }\n                }\n                return Ok((to_u32(self.serialization.len())?, remaining));\n            }\n            Some(x) => x,\n        };\n\n        let mut username_end = None;\n        let mut has_password = false;\n        let mut has_username = false;\n        while userinfo_char_count > 0 {\n            let (c, utf8_c) = input.next_utf8().unwrap();\n            userinfo_char_count -= 1;\n            if c == ':' && username_end.is_none() {\n                // Start parsing password\n                username_end = Some(to_u32(self.serialization.len())?);\n                // We don't add a colon if the password is empty\n                if userinfo_char_count > 0 {\n                    self.serialization.push(':');\n                    has_password = true;\n                }\n            } else {\n                if !has_password {\n                    has_username = true;\n                }\n                self.check_url_code_point(c, &input);\n                self.serialization\n                    .extend(utf8_percent_encode(utf8_c, USERINFO));\n            }\n        }\n        let username_end = match username_end {\n            Some(i) => i,\n            None => to_u32(self.serialization.len())?,\n        };\n        if has_username || has_password {\n            self.serialization.push('@');\n        }\n        Ok((username_end, remaining))\n    }\n\n    fn parse_host_and_port<'i>(\n        &mut self,\n        input: Input<'i>,\n        scheme_end: u32,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(u32, HostInternal, Option<u16>, Input<'i>)> {\n        let (host, remaining) = Parser::parse_host(input, scheme_type)?;\n        write!(&mut self.serialization, \"{}\", host).unwrap();\n        let host_end = to_u32(self.serialization.len())?;\n        if let Host::Domain(h) = &host {\n            if h.is_empty() {\n                // Port with an empty host\n                if remaining.starts_with(\":\") {\n                    return Err(ParseError::EmptyHost);\n                }\n                if scheme_type.is_special() {\n                    return Err(ParseError::EmptyHost);\n                }\n            }\n        };\n\n        let (port, remaining) = if let Some(remaining) = remaining.split_prefix(':') {\n            let scheme = || default_port(&self.serialization[..scheme_end as usize]);\n            Parser::parse_port(remaining, scheme, self.context)?\n        } else {\n            (None, remaining)\n        };\n        if let Some(port) = port {\n            write!(&mut self.serialization, \":{}\", port).unwrap()\n        }\n        Ok((host_end, host.into(), port, remaining))\n    }\n\n    pub fn parse_host(\n        mut input: Input<'_>,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(Host<String>, Input<'_>)> {\n        if scheme_type.is_file() {\n            return Parser::get_file_host(input);\n        }\n        // Undo the Input abstraction here to avoid allocating in the common case\n        // where the host part of the input does not contain any tab or newline\n        let input_str = input.chars.as_str();\n        let mut inside_square_brackets = false;\n        let mut has_ignored_chars = false;\n        let mut non_ignored_chars = 0;\n        let mut bytes = 0;\n        for c in input_str.chars() {\n            match c {\n                ':' if !inside_square_brackets => break,\n                '\\\\' if scheme_type.is_special() => break,\n                '/' | '?' | '#' => break,\n                '\\t' | '\\n' | '\\r' => {\n                    has_ignored_chars = true;\n                }\n                '[' => {\n                    inside_square_brackets = true;\n                    non_ignored_chars += 1\n                }\n                ']' => {\n                    inside_square_brackets = false;\n                    non_ignored_chars += 1\n                }\n                _ => non_ignored_chars += 1,\n            }\n            bytes += c.len_utf8();\n        }\n        let replaced: String;\n        let host_str;\n        {\n            let host_input = input.by_ref().take(non_ignored_chars);\n            if has_ignored_chars {\n                replaced = host_input.collect();\n                host_str = &*replaced\n            } else {\n                for _ in host_input {}\n                host_str = &input_str[..bytes]\n            }\n        }\n        if scheme_type == SchemeType::SpecialNotFile && host_str.is_empty() {\n            return Err(ParseError::EmptyHost);\n        }\n        if !scheme_type.is_special() {\n            let host = Host::parse_opaque(host_str)?;\n            return Ok((host, input));\n        }\n        let host = Host::parse(host_str)?;\n        Ok((host, input))\n    }\n\n    fn get_file_host(input: Input<'_>) -> ParseResult<(Host<String>, Input<'_>)> {\n        let (_, host_str, remaining) = Parser::file_host(input)?;\n        let host = match Host::parse(&host_str)? {\n            Host::Domain(ref d) if d == \"localhost\" => Host::Domain(\"\".to_string()),\n            host => host,\n        };\n        Ok((host, remaining))\n    }\n\n    fn parse_file_host<'i>(\n        &mut self,\n        input: Input<'i>,\n    ) -> ParseResult<(bool, HostInternal, Input<'i>)> {\n        let has_host;\n        let (_, host_str, remaining) = Parser::file_host(input)?;\n        let host = if host_str.is_empty() {\n            has_host = false;\n            HostInternal::None\n        } else {\n            match Host::parse(&host_str)? {\n                Host::Domain(ref d) if d == \"localhost\" => {\n                    has_host = false;\n                    HostInternal::None\n                }\n                host => {\n                    write!(&mut self.serialization, \"{}\", host).unwrap();\n                    has_host = true;\n                    host.into()\n                }\n            }\n        };\n        Ok((has_host, host, remaining))\n    }\n\n    pub fn file_host<'i>(input: Input<'i>) -> ParseResult<(bool, String, Input<'i>)> {\n        // Undo the Input abstraction here to avoid allocating in the common case\n        // where the host part of the input does not contain any tab or newline\n        let input_str = input.chars.as_str();\n        let mut has_ignored_chars = false;\n        let mut non_ignored_chars = 0;\n        let mut bytes = 0;\n        for c in input_str.chars() {\n            match c {\n                '/' | '\\\\' | '?' | '#' => break,\n                '\\t' | '\\n' | '\\r' => has_ignored_chars = true,\n                _ => non_ignored_chars += 1,\n            }\n            bytes += c.len_utf8();\n        }\n        let replaced: String;\n        let host_str;\n        let mut remaining = input.clone();\n        {\n            let host_input = remaining.by_ref().take(non_ignored_chars);\n            if has_ignored_chars {\n                replaced = host_input.collect();\n                host_str = &*replaced\n            } else {\n                for _ in host_input {}\n                host_str = &input_str[..bytes]\n            }\n        }\n        if is_windows_drive_letter(host_str) {\n            return Ok((false, \"\".to_string(), input));\n        }\n        Ok((true, host_str.to_string(), remaining))\n    }\n\n    pub fn parse_port<P>(\n        mut input: Input<'_>,\n        default_port: P,\n        context: Context,\n    ) -> ParseResult<(Option<u16>, Input<'_>)>\n    where\n        P: Fn() -> Option<u16>,\n    {\n        let mut port: u32 = 0;\n        let mut has_any_digit = false;\n        while let (Some(c), remaining) = input.split_first() {\n            if let Some(digit) = c.to_digit(10) {\n                port = port * 10 + digit;\n                if port > ::std::u16::MAX as u32 {\n                    return Err(ParseError::InvalidPort);\n                }\n                has_any_digit = true;\n            } else if context == Context::UrlParser && !matches!(c, '/' | '\\\\' | '?' | '#') {\n                return Err(ParseError::InvalidPort);\n            } else {\n                break;\n            }\n            input = remaining;\n        }\n        let mut opt_port = Some(port as u16);\n        if !has_any_digit || opt_port == default_port() {\n            opt_port = None;\n        }\n        Ok((opt_port, input))\n    }\n\n    pub fn parse_path_start<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        has_host: &mut bool,\n        input: Input<'i>,\n    ) -> Input<'i> {\n        let path_start = self.serialization.len();\n        let (maybe_c, remaining) = input.split_first();\n        // If url is special, then:\n        if scheme_type.is_special() {\n            if maybe_c == Some('\\\\') {\n                // If c is U+005C (\\), validation error.\n                self.log_violation(SyntaxViolation::Backslash);\n            }\n            // A special URL always has a non-empty path.\n            if !self.serialization.ends_with('/') {\n                self.serialization.push('/');\n                // We have already made sure the forward slash is present.\n                if maybe_c == Some('/') || maybe_c == Some('\\\\') {\n                    return self.parse_path(scheme_type, has_host, path_start, remaining);\n                }\n            }\n            return self.parse_path(scheme_type, has_host, path_start, input);\n        } else if maybe_c == Some('?') || maybe_c == Some('#') {\n            // Otherwise, if state override is not given and c is U+003F (?),\n            // set url’s query to the empty string and state to query state.\n            // Otherwise, if state override is not given and c is U+0023 (#),\n            // set url’s fragment to the empty string and state to fragment state.\n            // The query and path states will be handled by the caller.\n            return input;\n        }\n\n        if maybe_c != None && maybe_c != Some('/') {\n            self.serialization.push('/');\n        }\n        // Otherwise, if c is not the EOF code point:\n        self.parse_path(scheme_type, has_host, path_start, input)\n    }\n\n    pub fn parse_path<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        has_host: &mut bool,\n        path_start: usize,\n        mut input: Input<'i>,\n    ) -> Input<'i> {\n        // Relative path state\n        loop {\n            let segment_start = self.serialization.len();\n            let mut ends_with_slash = false;\n            loop {\n                let input_before_c = input.clone();\n                let (c, utf8_c) = if let Some(x) = input.next_utf8() {\n                    x\n                } else {\n                    break;\n                };\n                match c {\n                    '/' if self.context != Context::PathSegmentSetter => {\n                        self.serialization.push(c);\n                        ends_with_slash = true;\n                        break;\n                    }\n                    '\\\\' if self.context != Context::PathSegmentSetter\n                        && scheme_type.is_special() =>\n                    {\n                        self.log_violation(SyntaxViolation::Backslash);\n                        self.serialization.push('/');\n                        ends_with_slash = true;\n                        break;\n                    }\n                    '?' | '#' if self.context == Context::UrlParser => {\n                        input = input_before_c;\n                        break;\n                    }\n                    _ => {\n                        self.check_url_code_point(c, &input);\n                        if self.context == Context::PathSegmentSetter {\n                            if scheme_type.is_special() {\n                                self.serialization\n                                    .extend(utf8_percent_encode(utf8_c, SPECIAL_PATH_SEGMENT));\n                            } else {\n                                self.serialization\n                                    .extend(utf8_percent_encode(utf8_c, PATH_SEGMENT));\n                            }\n                        } else {\n                            self.serialization.extend(utf8_percent_encode(utf8_c, PATH));\n                        }\n                    }\n                }\n            }\n            // Going from &str to String to &str to please the 1.33.0 borrow checker\n            let before_slash_string = if ends_with_slash {\n                self.serialization[segment_start..self.serialization.len() - 1].to_owned()\n            } else {\n                self.serialization[segment_start..self.serialization.len()].to_owned()\n            };\n            let segment_before_slash: &str = &before_slash_string;\n            match segment_before_slash {\n                // If buffer is a double-dot path segment, shorten url’s path,\n                \"..\" | \"%2e%2e\" | \"%2e%2E\" | \"%2E%2e\" | \"%2E%2E\" | \"%2e.\" | \"%2E.\" | \".%2e\"\n                | \".%2E\" => {\n                    debug_assert!(self.serialization.as_bytes()[segment_start - 1] == b'/');\n                    self.serialization.truncate(segment_start);\n                    if self.serialization.ends_with('/')\n                        && Parser::last_slash_can_be_removed(&self.serialization, path_start)\n                    {\n                        self.serialization.pop();\n                    }\n                    self.shorten_path(scheme_type, path_start);\n\n                    // and then if neither c is U+002F (/), nor url is special and c is U+005C (\\), append the empty string to url’s path.\n                    if ends_with_slash && !self.serialization.ends_with('/') {\n                        self.serialization.push('/');\n                    }\n                }\n                // Otherwise, if buffer is a single-dot path segment and if neither c is U+002F (/),\n                // nor url is special and c is U+005C (\\), append the empty string to url’s path.\n                \".\" | \"%2e\" | \"%2E\" => {\n                    self.serialization.truncate(segment_start);\n                    if !self.serialization.ends_with('/') {\n                        self.serialization.push('/');\n                    }\n                }\n                _ => {\n                    // If url’s scheme is \"file\", url’s path is empty, and buffer is a Windows drive letter, then\n                    if scheme_type.is_file() && is_windows_drive_letter(segment_before_slash) {\n                        // Replace the second code point in buffer with U+003A (:).\n                        if let Some(c) = segment_before_slash.chars().next() {\n                            self.serialization.truncate(segment_start);\n                            self.serialization.push(c);\n                            self.serialization.push(':');\n                            if ends_with_slash {\n                                self.serialization.push('/');\n                            }\n                        }\n                        // If url’s host is neither the empty string nor null,\n                        // validation error, set url’s host to the empty string.\n                        if *has_host {\n                            self.log_violation(SyntaxViolation::FileWithHostAndWindowsDrive);\n                            *has_host = false; // FIXME account for this in callers\n                        }\n                    }\n                }\n            }\n            if !ends_with_slash {\n                break;\n            }\n        }\n        if scheme_type.is_file() {\n            // while url’s path’s size is greater than 1\n            // and url’s path[0] is the empty string,\n            // validation error, remove the first item from url’s path.\n            //FIXME: log violation\n            let path = self.serialization.split_off(path_start);\n            self.serialization.push('/');\n            self.serialization.push_str(&path.trim_start_matches('/'));\n        }\n\n        input\n    }\n\n    fn last_slash_can_be_removed(serialization: &str, path_start: usize) -> bool {\n        let url_before_segment = &serialization[..serialization.len() - 1];\n        if let Some(segment_before_start) = url_before_segment.rfind('/') {\n            // Do not remove the root slash\n            segment_before_start >= path_start\n                // Or a windows drive letter slash\n                && !path_starts_with_windows_drive_letter(&serialization[segment_before_start..])\n        } else {\n            false\n        }\n    }\n\n    /// https://url.spec.whatwg.org/#shorten-a-urls-path\n    fn shorten_path(&mut self, scheme_type: SchemeType, path_start: usize) {\n        // If path is empty, then return.\n        if self.serialization.len() == path_start {\n            return;\n        }\n        // If url’s scheme is \"file\", path’s size is 1, and path[0] is a normalized Windows drive letter, then return.\n        if scheme_type.is_file()\n            && is_normalized_windows_drive_letter(&self.serialization[path_start..])\n        {\n            return;\n        }\n        // Remove path’s last item.\n        self.pop_path(scheme_type, path_start);\n    }\n\n    /// https://url.spec.whatwg.org/#pop-a-urls-path\n    fn pop_path(&mut self, scheme_type: SchemeType, path_start: usize) {\n        if self.serialization.len() > path_start {\n            let slash_position = self.serialization[path_start..].rfind('/').unwrap();\n            // + 1 since rfind returns the position before the slash.\n            let segment_start = path_start + slash_position + 1;\n            // Don’t pop a Windows drive letter\n            if !(scheme_type.is_file()\n                && is_normalized_windows_drive_letter(&self.serialization[segment_start..]))\n            {\n                self.serialization.truncate(segment_start);\n            }\n        }\n    }\n\n    pub fn parse_cannot_be_a_base_path<'i>(&mut self, mut input: Input<'i>) -> Input<'i> {\n        loop {\n            let input_before_c = input.clone();\n            match input.next_utf8() {\n                Some(('?', _)) | Some(('#', _)) if self.context == Context::UrlParser => {\n                    return input_before_c\n                }\n                Some((c, utf8_c)) => {\n                    self.check_url_code_point(c, &input);\n                    self.serialization\n                        .extend(utf8_percent_encode(utf8_c, CONTROLS));\n                }\n                None => return input,\n            }\n        }\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    fn with_query_and_fragment(\n        mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        username_end: u32,\n        host_start: u32,\n        host_end: u32,\n        host: HostInternal,\n        port: Option<u16>,\n        path_start: u32,\n        remaining: Input<'_>,\n    ) -> ParseResult<Url> {\n        let (query_start, fragment_start) =\n            self.parse_query_and_fragment(scheme_type, scheme_end, remaining)?;\n        Ok(Url {\n            serialization: self.serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        })\n    }\n\n    /// Return (query_start, fragment_start)\n    fn parse_query_and_fragment(\n        &mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        mut input: Input<'_>,\n    ) -> ParseResult<(Option<u32>, Option<u32>)> {\n        let mut query_start = None;\n        match input.next() {\n            Some('#') => {}\n            Some('?') => {\n                query_start = Some(to_u32(self.serialization.len())?);\n                self.serialization.push('?');\n                let remaining = self.parse_query(scheme_type, scheme_end, input);\n                if let Some(remaining) = remaining {\n                    input = remaining\n                } else {\n                    return Ok((query_start, None));\n                }\n            }\n            None => return Ok((None, None)),\n            _ => panic!(\"Programming error. parse_query_and_fragment() called without ? or #\"),\n        }\n\n        let fragment_start = to_u32(self.serialization.len())?;\n        self.serialization.push('#');\n        self.parse_fragment(input);\n        Ok((query_start, Some(fragment_start)))\n    }\n\n    pub fn parse_query<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        mut input: Input<'i>,\n    ) -> Option<Input<'i>> {\n        let mut query = String::new(); // FIXME: use a streaming decoder instead\n        let mut remaining = None;\n        while let Some(c) = input.next() {\n            if c == '#' && self.context == Context::UrlParser {\n                remaining = Some(input);\n                break;\n            } else {\n                self.check_url_code_point(c, &input);\n                query.push(c);\n            }\n        }\n\n        let encoding = match &self.serialization[..scheme_end as usize] {\n            \"http\" | \"https\" | \"file\" | \"ftp\" => self.query_encoding_override,\n            _ => None,\n        };\n        let query_bytes = if let Some(o) = encoding {\n            o(&query)\n        } else {\n            query.as_bytes().into()\n        };\n        let set = if scheme_type.is_special() {\n            SPECIAL_QUERY\n        } else {\n            QUERY\n        };\n        self.serialization.extend(percent_encode(&query_bytes, set));\n        remaining\n    }\n\n    fn fragment_only(mut self, base_url: &Url, mut input: Input<'_>) -> ParseResult<Url> {\n        let before_fragment = match base_url.fragment_start {\n            Some(i) => base_url.slice(..i),\n            None => &*base_url.serialization,\n        };\n        debug_assert!(self.serialization.is_empty());\n        self.serialization\n            .reserve(before_fragment.len() + input.chars.as_str().len());\n        self.serialization.push_str(before_fragment);\n        self.serialization.push('#');\n        let next = input.next();\n        debug_assert!(next == Some('#'));\n        self.parse_fragment(input);\n        Ok(Url {\n            serialization: self.serialization,\n            fragment_start: Some(to_u32(before_fragment.len())?),\n            ..*base_url\n        })\n    }\n\n    pub fn parse_fragment(&mut self, mut input: Input<'_>) {\n        while let Some((c, utf8_c)) = input.next_utf8() {\n            if c == '\\0' {\n                self.log_violation(SyntaxViolation::NullInFragment)\n            } else {\n                self.check_url_code_point(c, &input);\n            }\n            self.serialization\n                .extend(utf8_percent_encode(utf8_c, FRAGMENT));\n        }\n    }\n\n    fn check_url_code_point(&self, c: char, input: &Input<'_>) {\n        if let Some(vfn) = self.violation_fn {\n            if c == '%' {\n                let mut input = input.clone();\n                if !matches!((input.next(), input.next()), (Some(a), Some(b))\n                             if is_ascii_hex_digit(a) && is_ascii_hex_digit(b))\n                {\n                    vfn(SyntaxViolation::PercentDecode)\n                }\n            } else if !is_url_code_point(c) {\n                vfn(SyntaxViolation::NonUrlCodePoint)\n            }\n        }\n    }\n}"],"parser::SchemeType":["Clone","Copy","PartialEq","impl SchemeType {\n    pub fn is_special(&self) -> bool {\n        !matches!(*self, SchemeType::NotSpecial)\n    }\n\n    pub fn is_file(&self) -> bool {\n        matches!(*self, SchemeType::File)\n    }\n\n    pub fn from(s: &str) -> Self {\n        match s {\n            \"http\" | \"https\" | \"ws\" | \"wss\" | \"ftp\" => SchemeType::SpecialNotFile,\n            \"file\" => SchemeType::File,\n            _ => SchemeType::NotSpecial,\n        }\n    }\n}"],"parser::SyntaxViolation":["Clone","Copy","Debug","Eq","PartialEq","impl SyntaxViolation {\n            pub fn description(&self) -> &'static str {\n                match *self {\n                    $(\n                        SyntaxViolation::$name => $description,\n                    )+\n                    SyntaxViolation::__FutureProof => {\n                        unreachable!(\"Don't abuse the FutureProof!\");\n                    }\n                }\n            }\n        }","impl fmt::Display for SyntaxViolation {\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.description(), f)\n    }\n}"],"path_segments::PathSegmentsMut":["Debug","impl<'a> Drop for PathSegmentsMut<'a> {\n    fn drop(&mut self) {\n        self.url\n            .restore_after_path(self.old_after_path_position, &self.after_path)\n    }\n}","impl<'a> PathSegmentsMut<'a> {\n    /// Remove all segments in the path, leaving the minimal `url.path() == \"/\"`.\n    ///\n    /// Returns `&mut Self` so that method calls can be chained.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use std::error::Error;\n    ///\n    /// # fn run() -> Result<(), Box<dyn Error>> {\n    /// let mut url = Url::parse(\"https://github.com/servo/rust-url/\")?;\n    /// url.path_segments_mut().map_err(|_| \"cannot be base\")?\n    ///     .clear().push(\"logout\");\n    /// assert_eq!(url.as_str(), \"https://github.com/logout\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn clear(&mut self) -> &mut Self {\n        self.url.serialization.truncate(self.after_first_slash);\n        self\n    }\n\n    /// Remove the last segment of this URL’s path if it is empty,\n    /// except if these was only one segment to begin with.\n    ///\n    /// In other words, remove one path trailing slash, if any,\n    /// unless it is also the initial slash (so this does nothing if `url.path() == \"/\")`.\n    ///\n    /// Returns `&mut Self` so that method calls can be chained.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use std::error::Error;\n    ///\n    /// # fn run() -> Result<(), Box<dyn Error>> {\n    /// let mut url = Url::parse(\"https://github.com/servo/rust-url/\")?;\n    /// url.path_segments_mut().map_err(|_| \"cannot be base\")?\n    ///     .push(\"pulls\");\n    /// assert_eq!(url.as_str(), \"https://github.com/servo/rust-url//pulls\");\n    ///\n    /// let mut url = Url::parse(\"https://github.com/servo/rust-url/\")?;\n    /// url.path_segments_mut().map_err(|_| \"cannot be base\")?\n    ///     .pop_if_empty().push(\"pulls\");\n    /// assert_eq!(url.as_str(), \"https://github.com/servo/rust-url/pulls\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn pop_if_empty(&mut self) -> &mut Self {\n        if self.url.serialization[self.after_first_slash..].ends_with('/') {\n            self.url.serialization.pop();\n        }\n        self\n    }\n\n    /// Remove the last segment of this URL’s path.\n    ///\n    /// If the path only has one segment, make it empty such that `url.path() == \"/\"`.\n    ///\n    /// Returns `&mut Self` so that method calls can be chained.\n    pub fn pop(&mut self) -> &mut Self {\n        let last_slash = self.url.serialization[self.after_first_slash..]\n            .rfind('/')\n            .unwrap_or(0);\n        self.url\n            .serialization\n            .truncate(self.after_first_slash + last_slash);\n        self\n    }\n\n    /// Append the given segment at the end of this URL’s path.\n    ///\n    /// See the documentation for `.extend()`.\n    ///\n    /// Returns `&mut Self` so that method calls can be chained.\n    pub fn push(&mut self, segment: &str) -> &mut Self {\n        self.extend(Some(segment))\n    }\n\n    /// Append each segment from the given iterator at the end of this URL’s path.\n    ///\n    /// Each segment is percent-encoded like in `Url::parse` or `Url::join`,\n    /// except that `%` and `/` characters are also encoded (to `%25` and `%2F`).\n    /// This is unlike `Url::parse` where `%` is left as-is in case some of the input\n    /// is already percent-encoded, and `/` denotes a path segment separator.)\n    ///\n    /// Note that, in addition to slashes between new segments,\n    /// this always adds a slash between the existing path and the new segments\n    /// *except* if the existing path is `\"/\"`.\n    /// If the previous last segment was empty (if the path had a trailing slash)\n    /// the path after `.extend()` will contain two consecutive slashes.\n    /// If that is undesired, call `.pop_if_empty()` first.\n    ///\n    /// To obtain a behavior similar to `Url::join`, call `.pop()` unconditionally first.\n    ///\n    /// Returns `&mut Self` so that method calls can be chained.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use std::error::Error;\n    ///\n    /// # fn run() -> Result<(), Box<dyn Error>> {\n    /// let mut url = Url::parse(\"https://github.com/\")?;\n    /// let org = \"servo\";\n    /// let repo = \"rust-url\";\n    /// let issue_number = \"188\";\n    /// url.path_segments_mut().map_err(|_| \"cannot be base\")?\n    ///     .extend(&[org, repo, \"issues\", issue_number]);\n    /// assert_eq!(url.as_str(), \"https://github.com/servo/rust-url/issues/188\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    ///\n    /// In order to make sure that parsing the serialization of an URL gives the same URL,\n    /// a segment is ignored if it is `\".\"` or `\"..\"`:\n    ///\n    /// ```rust\n    /// use url::Url;\n    /// # use std::error::Error;\n    ///\n    /// # fn run() -> Result<(), Box<dyn Error>> {\n    /// let mut url = Url::parse(\"https://github.com/servo\")?;\n    /// url.path_segments_mut().map_err(|_| \"cannot be base\")?\n    ///     .extend(&[\"..\", \"rust-url\", \".\", \"pulls\"]);\n    /// assert_eq!(url.as_str(), \"https://github.com/servo/rust-url/pulls\");\n    /// # Ok(())\n    /// # }\n    /// # run().unwrap();\n    /// ```\n    pub fn extend<I>(&mut self, segments: I) -> &mut Self\n    where\n        I: IntoIterator,\n        I::Item: AsRef<str>,\n    {\n        let scheme_type = SchemeType::from(self.url.scheme());\n        let path_start = self.url.path_start as usize;\n        self.url.mutate(|parser| {\n            parser.context = parser::Context::PathSegmentSetter;\n            for segment in segments {\n                let segment = segment.as_ref();\n                if matches!(segment, \".\" | \"..\") {\n                    continue;\n                }\n                if parser.serialization.len() > path_start + 1\n                    // Non special url's path might still be empty\n                    || parser.serialization.len() == path_start\n                {\n                    parser.serialization.push('/');\n                }\n                let mut has_host = true; // FIXME account for this?\n                parser.parse_path(\n                    scheme_type,\n                    &mut has_host,\n                    path_start,\n                    parser::Input::new(segment),\n                );\n            }\n        });\n        self\n    }\n}"],"slicing::Position":["Clone","Copy","Debug"],"std::ops::Range":["impl RangeArg for Range<u32> {\n    #[inline]\n    fn slice_of<'a>(&self, s: &'a str) -> &'a str {\n        &s[self.start as usize..self.end as usize]\n    }\n}"],"std::ops::RangeFrom":["impl RangeArg for RangeFrom<u32> {\n    #[inline]\n    fn slice_of<'a>(&self, s: &'a str) -> &'a str {\n        &s[self.start as usize..]\n    }\n}"],"std::ops::RangeTo":["impl RangeArg for RangeTo<u32> {\n    #[inline]\n    fn slice_of<'a>(&self, s: &'a str) -> &'a str {\n        &s[..self.end as usize]\n    }\n}"]},"single_path_import":{"form_urlencoded":"form_urlencoded","form_urlencoded::EncodingOverride":"EncodingOverride","host::Host":"Host","origin::OpaqueOrigin":"OpaqueOrigin","origin::Origin":"Origin","parser::ParseError":"ParseError","parser::SyntaxViolation":"SyntaxViolation","path_segments::PathSegmentsMut":"PathSegmentsMut","slicing::Position":"Position"},"srcs":{"<&'a str as parser::Pattern>::split_prefix":["fn split_prefix<'i>(self, input: &mut Input<'i>) -> bool{\n        for c in self.chars() {\n            if input.next() != Some(c) {\n                return false;\n            }\n        }\n        true\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"<F as parser::Pattern>::split_prefix":["fn split_prefix<'i>(self, input: &mut Input<'i>) -> bool{\n        input.next().map_or(false, self)\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"<Url as std::cmp::Ord>::cmp":["#[inline]\nfn cmp(&self, other: &Self) -> cmp::Ordering{\n        self.serialization.cmp(&other.serialization)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<Url as std::cmp::PartialEq>::eq":["#[inline]\nfn eq(&self, other: &Self) -> bool{\n        self.serialization == other.serialization\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<Url as std::cmp::PartialOrd>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering>{\n        self.serialization.partial_cmp(&other.serialization)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<Url as std::convert::AsRef<str>>::as_ref":["#[inline]\nfn as_ref(&self) -> &str{\n        &self.serialization\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<Url as std::convert::TryFrom<&'a str>>::try_from":["fn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        Url::parse(s)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<Url as std::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        formatter\n            .debug_struct(\"Url\")\n            .field(\"scheme\", &self.scheme())\n            .field(\"host\", &self.host())\n            .field(\"port\", &self.port())\n            .field(\"path\", &self.path())\n            .field(\"query\", &self.query())\n            .field(\"fragment\", &self.fragment())\n            .finish()\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<Url as std::fmt::Display>::fmt":["#[inline]\nfn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(&self.serialization, formatter)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<Url as std::hash::Hash>::hash":["#[inline]\nfn hash<H>(&self, state: &mut H)\n    where\n        H: hash::Hasher,{\n        hash::Hash::hash(&self.serialization, state)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<Url as std::str::FromStr>::from_str":["#[inline]\nfn from_str(input: &str) -> Result<Url, crate::ParseError>{\n        Url::parse(input)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<UrlQuery<'a> as form_urlencoded::Target>::as_mut_string":["fn as_mut_string(&mut self) -> &mut String{\n        &mut self.url.as_mut().unwrap().serialization\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<UrlQuery<'a> as form_urlencoded::Target>::finish":["fn finish(mut self) -> &'a mut Url{\n        let url = self.url.take().unwrap();\n        url.restore_already_parsed_fragment(self.fragment.take());\n        url\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<UrlQuery<'a> as std::ops::Drop>::drop":["fn drop(&mut self){\n        if let Some(url) = self.url.take() {\n            url.restore_already_parsed_fragment(self.fragment.take())\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<char as parser::Pattern>::split_prefix":["fn split_prefix<'i>(self, input: &mut Input<'i>) -> bool{\n        input.next() == Some(self)\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"<host::Host<S> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n        match *self {\n            Host::Domain(ref domain) => domain.as_ref().fmt(f),\n            Host::Ipv4(ref addr) => addr.fmt(f),\n            Host::Ipv6(ref addr) => {\n                f.write_str(\"[\")?;\n                write_ipv6(addr, f)?;\n                f.write_str(\"]\")\n            }\n        }\n    }","Real(LocalPath(\"url/src/host.rs\"))"],"<host::HostInternal as std::convert::From<host::Host>>::from":["fn from(host: Host<String>) -> HostInternal{\n        match host {\n            Host::Domain(ref s) if s.is_empty() => HostInternal::None,\n            Host::Domain(_) => HostInternal::Domain,\n            Host::Ipv4(address) => HostInternal::Ipv4(address),\n            Host::Ipv6(address) => HostInternal::Ipv6(address),\n        }\n    }","Real(LocalPath(\"url/src/host.rs\"))"],"<parser::Input<'i> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<char>{\n        self.chars\n            .by_ref()\n            .find(|&c| !matches!(c, '\\t' | '\\n' | '\\r'))\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"<parser::ParseError as std::convert::From<idna::Errors>>::from":["fn from(_: ::idna::Errors) -> ParseError{\n        ParseError::IdnaError\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"<parser::ParseError as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result{\n                match *self {\n                    $(\n                        ParseError::$name => fmt.write_str($description),\n                    )+\n                    ParseError::__FutureProof => {\n                        unreachable!(\"Don't abuse the FutureProof!\");\n                    }\n                }\n            }","Real(LocalPath(\"url/src/parser.rs\"))"],"<parser::SyntaxViolation as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(self.description(), f)\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"<path_segments::PathSegmentsMut<'a> as std::ops::Drop>::drop":["fn drop(&mut self){\n        self.url\n            .restore_after_path(self.old_after_path_position, &self.after_path)\n    }","Real(LocalPath(\"url/src/path_segments.rs\"))"],"<std::ops::Range<u32> as RangeArg>::slice_of":["#[inline]\nfn slice_of<'a>(&self, s: &'a str) -> &'a str{\n        &s[self.start as usize..self.end as usize]\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<std::ops::RangeFrom<u32> as RangeArg>::slice_of":["#[inline]\nfn slice_of<'a>(&self, s: &'a str) -> &'a str{\n        &s[self.start as usize..]\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"<std::ops::RangeTo<u32> as RangeArg>::slice_of":["#[inline]\nfn slice_of<'a>(&self, s: &'a str) -> &'a str{\n        &s[..self.end as usize]\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"ParseOptions":["/// Full configuration for the URL parser.\npub struct ParseOptions<'a> {\n    base_url: Option<&'a Url>,\n    encoding_override: EncodingOverride<'a>,\n    violation_fn: Option<&'a dyn Fn(SyntaxViolation)>,\n}","Real(LocalPath(\"url/src/lib.rs\"))"],"ParseOptions::<'a>::base_url":["/// Change the base URL\npub fn base_url(mut self, new: Option<&'a Url>) -> Self{\n        self.base_url = new;\n        self\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"ParseOptions::<'a>::encoding_override":["/// Override the character encoding of query strings.\n/// This is a legacy concept only relevant for HTML.\npub fn encoding_override(mut self, new: EncodingOverride<'a>) -> Self{\n        self.encoding_override = new;\n        self\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"ParseOptions::<'a>::parse":["/// Parse an URL string with the configuration so far.\npub fn parse(self, input: &str) -> Result<Url, crate::ParseError>{\n        Parser {\n            serialization: String::with_capacity(input.len()),\n            base_url: self.base_url,\n            query_encoding_override: self.encoding_override,\n            violation_fn: self.violation_fn,\n            context: Context::UrlParser,\n        }\n        .parse_url(input)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"ParseOptions::<'a>::syntax_violation_callback":["/// Call the provided function or closure for a non-fatal `SyntaxViolation`\n/// when it occurs during parsing. Note that since the provided function is\n/// `Fn`, the caller might need to utilize _interior mutability_, such as with\n/// a `RefCell`, to collect the violations.\n///\n/// ## Example\n/// ```\n/// use std::cell::RefCell;\n/// use url::{Url, SyntaxViolation};\n/// # use url::ParseError;\n/// # fn run() -> Result<(), url::ParseError> {\n/// let violations = RefCell::new(Vec::new());\n/// let url = Url::options()\n///     .syntax_violation_callback(Some(&|v| violations.borrow_mut().push(v)))\n///     .parse(\"https:////example.com\")?;\n/// assert_eq!(url.as_str(), \"https://example.com/\");\n/// assert_eq!(violations.into_inner(),\n///            vec!(SyntaxViolation::ExpectedDoubleSlash));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn syntax_violation_callback(mut self, new: Option<&'a dyn Fn(SyntaxViolation)>) -> Self{\n        self.violation_fn = new;\n        self\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"RangeArg":["trait RangeArg {\n    fn slice_of<'a>(&self, s: &'a str) -> &'a str;\n}","Real(LocalPath(\"url/src/lib.rs\"))"],"Url":["/// A parsed URL record.\npub struct Url {\n    /// Syntax in pseudo-BNF:\n    ///\n    ///   url = scheme \":\" [ hierarchical | non-hierarchical ] [ \"?\" query ]? [ \"#\" fragment ]?\n    ///   non-hierarchical = non-hierarchical-path\n    ///   non-hierarchical-path = /* Does not start with \"/\" */\n    ///   hierarchical = authority? hierarchical-path\n    ///   authority = \"//\" userinfo? host [ \":\" port ]?\n    ///   userinfo = username [ \":\" password ]? \"@\"\n    ///   hierarchical-path = [ \"/\" path-segment ]+\n    serialization: String,\n\n    // Components\n    scheme_end: u32,   // Before ':'\n    username_end: u32, // Before ':' (if a password is given) or '@' (if not)\n    host_start: u32,\n    host_end: u32,\n    host: HostInternal,\n    port: Option<u16>,\n    path_start: u32,             // Before initial '/', if any\n    query_start: Option<u32>,    // Before '?', unlike Position::QueryStart\n    fragment_start: Option<u32>, // Before '#', unlike Position::FragmentStart\n}","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::as_str":["/// Return the serialization of this URL.\n///\n/// This is fast since that serialization is already stored in the `Url` struct.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url_str = \"https://example.net/\";\n/// let url = Url::parse(url_str)?;\n/// assert_eq!(url.as_str(), url_str);\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n#[inline]\npub fn as_str(&self) -> &str{\n        &self.serialization\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::byte_at":["#[inline]\nfn byte_at(&self, i: u32) -> u8{\n        self.serialization.as_bytes()[i as usize]\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::cannot_be_a_base":["/// Return whether this URL is a cannot-be-a-base URL,\n/// meaning that parsing a relative URL string with this URL as the base will return an error.\n///\n/// This is the case if the scheme and `:` delimiter are not followed by a `/` slash,\n/// as is typically the case of `data:` and `mailto:` URLs.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"ftp://rms@example.com\")?;\n/// assert!(!url.cannot_be_a_base());\n///\n/// let url = Url::parse(\"unix:/run/foo.socket\")?;\n/// assert!(!url.cannot_be_a_base());\n///\n/// let url = Url::parse(\"data:text/plain,Stuff\")?;\n/// assert!(url.cannot_be_a_base());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n#[inline]\npub fn cannot_be_a_base(&self) -> bool{\n        !self.slice(self.scheme_end + 1..).starts_with('/')\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::check_invariants":["/// For internal testing, not part of the public API.\n///\n/// Methods of the `Url` struct assume a number of invariants.\n/// This checks each of these invariants and panic if one is not met.\n/// This is for testing rust-url itself.\n#[doc(hidden)]\npub fn check_invariants(&self) -> Result<(), String>{\n        macro_rules! assert {\n            ($x: expr) => {\n                if !$x {\n                    return Err(format!(\n                        \"!( {} ) for URL {:?}\",\n                        stringify!($x),\n                        self.serialization\n                    ));\n                }\n            };\n        }\n\n        macro_rules! assert_eq {\n            ($a: expr, $b: expr) => {\n                {\n                    let a = $a;\n                    let b = $b;\n                    if a != b {\n                        return Err(format!(\"{:?} != {:?} ({} != {}) for URL {:?}\",\n                                           a, b, stringify!($a), stringify!($b),\n                                           self.serialization))\n                    }\n                }\n            }\n        }\n\n        assert!(self.scheme_end >= 1);\n        assert!(matches!(self.byte_at(0), b'a'..=b'z' | b'A'..=b'Z'));\n        assert!(self\n            .slice(1..self.scheme_end)\n            .chars()\n            .all(|c| matches!(c, 'a'..='z' | 'A'..='Z' | '0'..='9' | '+' | '-' | '.')));\n        assert_eq!(self.byte_at(self.scheme_end), b':');\n\n        if self.slice(self.scheme_end + 1..).starts_with(\"//\") {\n            // URL with authority\n            if self.username_end != self.serialization.len() as u32 {\n                match self.byte_at(self.username_end) {\n                    b':' => {\n                        assert!(self.host_start >= self.username_end + 2);\n                        assert_eq!(self.byte_at(self.host_start - 1), b'@');\n                    }\n                    b'@' => assert!(self.host_start == self.username_end + 1),\n                    _ => assert_eq!(self.username_end, self.scheme_end + 3),\n                }\n            }\n            assert!(self.host_start >= self.username_end);\n            assert!(self.host_end >= self.host_start);\n            let host_str = self.slice(self.host_start..self.host_end);\n            match self.host {\n                HostInternal::None => assert_eq!(host_str, \"\"),\n                HostInternal::Ipv4(address) => assert_eq!(host_str, address.to_string()),\n                HostInternal::Ipv6(address) => {\n                    let h: Host<String> = Host::Ipv6(address);\n                    assert_eq!(host_str, h.to_string())\n                }\n                HostInternal::Domain => {\n                    if SchemeType::from(self.scheme()).is_special() {\n                        assert!(!host_str.is_empty())\n                    }\n                }\n            }\n            if self.path_start == self.host_end {\n                assert_eq!(self.port, None);\n            } else {\n                assert_eq!(self.byte_at(self.host_end), b':');\n                let port_str = self.slice(self.host_end + 1..self.path_start);\n                assert_eq!(\n                    self.port,\n                    Some(port_str.parse::<u16>().expect(\"Couldn't parse port?\"))\n                );\n            }\n            assert!(\n                self.path_start as usize == self.serialization.len()\n                    || matches!(self.byte_at(self.path_start), b'/' | b'#' | b'?')\n            );\n        } else {\n            // Anarchist URL (no authority)\n            assert_eq!(self.username_end, self.scheme_end + 1);\n            assert_eq!(self.host_start, self.scheme_end + 1);\n            assert_eq!(self.host_end, self.scheme_end + 1);\n            assert_eq!(self.host, HostInternal::None);\n            assert_eq!(self.port, None);\n            assert_eq!(self.path_start, self.scheme_end + 1);\n        }\n        if let Some(start) = self.query_start {\n            assert!(start >= self.path_start);\n            assert_eq!(self.byte_at(start), b'?');\n        }\n        if let Some(start) = self.fragment_start {\n            assert!(start >= self.path_start);\n            assert_eq!(self.byte_at(start), b'#');\n        }\n        if let (Some(query_start), Some(fragment_start)) = (self.query_start, self.fragment_start) {\n            assert!(fragment_start > query_start);\n        }\n\n        let other = Url::parse(self.as_str()).expect(\"Failed to parse myself?\");\n        assert_eq!(&self.serialization, &other.serialization);\n        assert_eq!(self.scheme_end, other.scheme_end);\n        assert_eq!(self.username_end, other.username_end);\n        assert_eq!(self.host_start, other.host_start);\n        assert_eq!(self.host_end, other.host_end);\n        assert!(\n            self.host == other.host ||\n                // XXX No host round-trips to empty host.\n                // See https://github.com/whatwg/url/issues/79\n                (self.host_str(), other.host_str()) == (None, Some(\"\"))\n        );\n        assert_eq!(self.port, other.port);\n        assert_eq!(self.path_start, other.path_start);\n        assert_eq!(self.query_start, other.query_start);\n        assert_eq!(self.fragment_start, other.fragment_start);\n        Ok(())\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::domain":["/// If this URL has a host and it is a domain name (not an IP address), return it.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"https://127.0.0.1/\")?;\n/// assert_eq!(url.domain(), None);\n///\n/// let url = Url::parse(\"mailto:rms@example.net\")?;\n/// assert_eq!(url.domain(), None);\n///\n/// let url = Url::parse(\"https://example.com/\")?;\n/// assert_eq!(url.domain(), Some(\"example.com\"));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn domain(&self) -> Option<&str>{\n        match self.host {\n            HostInternal::Domain => Some(self.slice(self.host_start..self.host_end)),\n            _ => None,\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::fragment":["/// Return this URL’s fragment identifier, if any.\n///\n/// A fragment is the part of the URL after the `#` symbol.\n/// The fragment is optional and, if present, contains a fragment identifier\n/// that identifies a secondary resource, such as a section heading\n/// of a document.\n///\n/// In HTML, the fragment identifier is usually the id attribute of a an element\n/// that is scrolled to on load. Browsers typically will not send the fragment portion\n/// of a URL to the server.\n///\n/// **Note:** the parser did *not* percent-encode this component,\n/// but the input may have been percent-encoded already.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"https://example.com/data.csv#row=4\")?;\n///\n/// assert_eq!(url.fragment(), Some(\"row=4\"));\n///\n/// let url = Url::parse(\"https://example.com/data.csv#cell=4,1-6,2\")?;\n///\n/// assert_eq!(url.fragment(), Some(\"cell=4,1-6,2\"));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn fragment(&self) -> Option<&str>{\n        self.fragment_start.map(|start| {\n            debug_assert!(self.byte_at(start) == b'#');\n            self.slice(start + 1..)\n        })\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::from_directory_path":["/// Convert a directory name as `std::path::Path` into an URL in the `file` scheme.\n///\n/// This returns `Err` if the given path is not absolute or,\n/// on Windows, if the prefix is not a disk prefix (e.g. `C:`) or a UNC prefix (`\\\\`).\n///\n/// Compared to `from_file_path`, this ensure that URL’s the path has a trailing slash\n/// so that the entire path is considered when using this URL as a base URL.\n///\n/// For example:\n///\n/// * `\"index.html\"` parsed with `Url::from_directory_path(Path::new(\"/var/www\"))`\n///   as the base URL is `file:///var/www/index.html`\n/// * `\"index.html\"` parsed with `Url::from_file_path(Path::new(\"/var/www\"))`\n///   as the base URL is `file:///var/index.html`, which might not be what was intended.\n///\n/// Note that `std::path` does not consider trailing slashes significant\n/// and usually does not include them (e.g. in `Path::parent()`).\n#[cfg(any(unix, windows, target_os = \"redox\"))]\npub fn from_directory_path<P: AsRef<Path>>(path: P) -> Result<Url, ()>{\n        let mut url = Url::from_file_path(path)?;\n        if !url.serialization.ends_with('/') {\n            url.serialization.push('/')\n        }\n        Ok(url)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::from_file_path":["/// Convert a file name as `std::path::Path` into an URL in the `file` scheme.\n///\n/// This returns `Err` if the given path is not absolute or,\n/// on Windows, if the prefix is not a disk prefix (e.g. `C:`) or a UNC prefix (`\\\\`).\n///\n/// # Examples\n///\n/// On Unix-like platforms:\n///\n/// ```\n/// # if cfg!(unix) {\n/// use url::Url;\n///\n/// # fn run() -> Result<(), ()> {\n/// let url = Url::from_file_path(\"/tmp/foo.txt\")?;\n/// assert_eq!(url.as_str(), \"file:///tmp/foo.txt\");\n///\n/// let url = Url::from_file_path(\"../foo.txt\");\n/// assert!(url.is_err());\n///\n/// let url = Url::from_file_path(\"https://google.com/\");\n/// assert!(url.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// # }\n/// ```\n#[cfg(any(unix, windows, target_os = \"redox\"))]\npub fn from_file_path<P: AsRef<Path>>(path: P) -> Result<Url, ()>{\n        let mut serialization = \"file://\".to_owned();\n        let host_start = serialization.len() as u32;\n        let (host_end, host) = path_to_file_url_segments(path.as_ref(), &mut serialization)?;\n        Ok(Url {\n            serialization,\n            scheme_end: \"file\".len() as u32,\n            username_end: host_start,\n            host_start,\n            host_end,\n            host,\n            port: None,\n            path_start: host_end,\n            query_start: None,\n            fragment_start: None,\n        })\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::has_authority":["/// Return whether the URL has an 'authority',\n/// which can contain a username, password, host, and port number.\n///\n/// URLs that do *not* are either path-only like `unix:/run/foo.socket`\n/// or cannot-be-a-base like `data:text/plain,Stuff`.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"ftp://rms@example.com\")?;\n/// assert!(url.has_authority());\n///\n/// let url = Url::parse(\"unix:/run/foo.socket\")?;\n/// assert!(!url.has_authority());\n///\n/// let url = Url::parse(\"data:text/plain,Stuff\")?;\n/// assert!(!url.has_authority());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n#[inline]\npub fn has_authority(&self) -> bool{\n        debug_assert!(self.byte_at(self.scheme_end) == b':');\n        self.slice(self.scheme_end..).starts_with(\"://\")\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::has_host":["/// Equivalent to `url.host().is_some()`.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"ftp://rms@example.com\")?;\n/// assert!(url.has_host());\n///\n/// let url = Url::parse(\"unix:/run/foo.socket\")?;\n/// assert!(!url.has_host());\n///\n/// let url = Url::parse(\"data:text/plain,Stuff\")?;\n/// assert!(!url.has_host());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn has_host(&self) -> bool{\n        !matches!(self.host, HostInternal::None)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::host":["/// Return the parsed representation of the host for this URL.\n/// Non-ASCII domain labels are punycode-encoded per IDNA.\n///\n/// Cannot-be-a-base URLs (typical of `data:` and `mailto:`) and some `file:` URLs\n/// don’t have a host.\n///\n/// See also the `host_str` method.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"https://127.0.0.1/index.html\")?;\n/// assert!(url.host().is_some());\n///\n/// let url = Url::parse(\"ftp://rms@example.com\")?;\n/// assert!(url.host().is_some());\n///\n/// let url = Url::parse(\"unix:/run/foo.socket\")?;\n/// assert!(url.host().is_none());\n///\n/// let url = Url::parse(\"data:text/plain,Stuff\")?;\n/// assert!(url.host().is_none());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn host(&self) -> Option<Host<&str>>{\n        match self.host {\n            HostInternal::None => None,\n            HostInternal::Domain => Some(Host::Domain(self.slice(self.host_start..self.host_end))),\n            HostInternal::Ipv4(address) => Some(Host::Ipv4(address)),\n            HostInternal::Ipv6(address) => Some(Host::Ipv6(address)),\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::host_str":["/// Return the string representation of the host (domain or IP address) for this URL, if any.\n///\n/// Non-ASCII domains are punycode-encoded per IDNA.\n/// IPv6 addresses are given between `[` and `]` brackets.\n///\n/// Cannot-be-a-base URLs (typical of `data:` and `mailto:`) and some `file:` URLs\n/// don’t have a host.\n///\n/// See also the `host` method.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"https://127.0.0.1/index.html\")?;\n/// assert_eq!(url.host_str(), Some(\"127.0.0.1\"));\n///\n/// let url = Url::parse(\"ftp://rms@example.com\")?;\n/// assert_eq!(url.host_str(), Some(\"example.com\"));\n///\n/// let url = Url::parse(\"unix:/run/foo.socket\")?;\n/// assert_eq!(url.host_str(), None);\n///\n/// let url = Url::parse(\"data:text/plain,Stuff\")?;\n/// assert_eq!(url.host_str(), None);\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn host_str(&self) -> Option<&str>{\n        if self.has_host() {\n            Some(self.slice(self.host_start..self.host_end))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::into_string":["/// Return the serialization of this URL.\n///\n/// This consumes the `Url` and takes ownership of the `String` stored in it.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url_str = \"https://example.net/\";\n/// let url = Url::parse(url_str)?;\n/// assert_eq!(url.into_string(), url_str);\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n#[inline]\npub fn into_string(self) -> String{\n        self.serialization\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::join":["/// Parse a string as an URL, with this URL as the base URL.\n///\n/// Note: a trailing slash is significant.\n/// Without it, the last path component is considered to be a “file” name\n/// to be removed to get at the “directory” that is used as the base:\n///\n/// # Examples\n///\n/// ```rust\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let base = Url::parse(\"https://example.net/a/b.html\")?;\n/// let url = base.join(\"c.png\")?;\n/// assert_eq!(url.as_str(), \"https://example.net/a/c.png\");  // Not /a/b.html/c.png\n///\n/// let base = Url::parse(\"https://example.net/a/b/\")?;\n/// let url = base.join(\"c.png\")?;\n/// assert_eq!(url.as_str(), \"https://example.net/a/b/c.png\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// # Errors\n///\n/// If the function can not parse an URL from the given string\n/// with this URL as the base URL, a [`ParseError`] variant will be returned.\n///\n/// [`ParseError`]: enum.ParseError.html\n#[inline]\npub fn join(&self, input: &str) -> Result<Url, crate::ParseError>{\n        Url::options().base_url(Some(self)).parse(input)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::mutate":["fn mutate<F: FnOnce(&mut Parser<'_>) -> R, R>(&mut self, f: F) -> R{\n        let mut parser = Parser::for_setter(mem::replace(&mut self.serialization, String::new()));\n        let result = f(&mut parser);\n        self.serialization = parser.serialization;\n        result\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::options":["/// Return a default `ParseOptions` that can fully configure the URL parser.\n///\n/// # Examples\n///\n/// Get default `ParseOptions`, then change base url\n///\n/// ```rust\n/// use url::Url;\n/// # use url::ParseError;\n/// # fn run() -> Result<(), ParseError> {\n/// let options = Url::options();\n/// let api = Url::parse(\"https://api.example.com\")?;\n/// let base_url = options.base_url(Some(&api));\n/// let version_url = base_url.parse(\"version.json\")?;\n/// assert_eq!(version_url.as_str(), \"https://api.example.com/version.json\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn options<'a>() -> ParseOptions<'a>{\n        ParseOptions {\n            base_url: None,\n            encoding_override: None,\n            violation_fn: None,\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::origin":["/// Return the origin of this URL (<https://url.spec.whatwg.org/#origin>)\n///\n/// Note: this returns an opaque origin for `file:` URLs, which causes\n/// `url.origin() != url.origin()`.\n///\n/// # Examples\n///\n/// URL with `ftp` scheme:\n///\n/// ```rust\n/// use url::{Host, Origin, Url};\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"ftp://example.com/foo\")?;\n/// assert_eq!(url.origin(),\n///            Origin::Tuple(\"ftp\".into(),\n///                          Host::Domain(\"example.com\".into()),\n///                          21));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// URL with `blob` scheme:\n///\n/// ```rust\n/// use url::{Host, Origin, Url};\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"blob:https://example.com/foo\")?;\n/// assert_eq!(url.origin(),\n///            Origin::Tuple(\"https\".into(),\n///                          Host::Domain(\"example.com\".into()),\n///                          443));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// URL with `file` scheme:\n///\n/// ```rust\n/// use url::{Host, Origin, Url};\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"file:///tmp/foo\")?;\n/// assert!(!url.origin().is_tuple());\n///\n/// let other_url = Url::parse(\"file:///tmp/foo\")?;\n/// assert!(url.origin() != other_url.origin());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// URL with other scheme:\n///\n/// ```rust\n/// use url::{Host, Origin, Url};\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"foo:bar\")?;\n/// assert!(!url.origin().is_tuple());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n#[inline]\npub fn origin(&self) -> Origin{\n        origin::url_origin(self)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::parse":["/// Parse an absolute URL from a string.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"https://example.net\")?;\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// # Errors\n///\n/// If the function can not parse an absolute URL from the given string,\n/// a [`ParseError`] variant will be returned.\n///\n/// [`ParseError`]: enum.ParseError.html\n#[inline]\npub fn parse(input: &str) -> Result<Url, crate::ParseError>{\n        Url::options().parse(input)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::parse_with_params":["/// Parse an absolute URL from a string and add params to its query string.\n///\n/// Existing params are not removed.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse_with_params(\"https://example.net?dont=clobberme\",\n///                                  &[(\"lang\", \"rust\"), (\"browser\", \"servo\")])?;\n/// assert_eq!(\"https://example.net/?dont=clobberme&lang=rust&browser=servo\", url.as_str());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// # Errors\n///\n/// If the function can not parse an absolute URL from the given string,\n/// a [`ParseError`] variant will be returned.\n///\n/// [`ParseError`]: enum.ParseError.html\n#[inline]\npub fn parse_with_params<I, K, V>(input: &str, iter: I) -> Result<Url, crate::ParseError>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<(K, V)>,\n        K: AsRef<str>,\n        V: AsRef<str>,{\n        let mut url = Url::options().parse(input);\n\n        if let Ok(ref mut url) = url {\n            url.query_pairs_mut().extend_pairs(iter);\n        }\n\n        url\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::password":["/// Return the password for this URL, if any, as a percent-encoded ASCII string.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"ftp://rms:secret123@example.com\")?;\n/// assert_eq!(url.password(), Some(\"secret123\"));\n///\n/// let url = Url::parse(\"ftp://:secret123@example.com\")?;\n/// assert_eq!(url.password(), Some(\"secret123\"));\n///\n/// let url = Url::parse(\"ftp://rms@example.com\")?;\n/// assert_eq!(url.password(), None);\n///\n/// let url = Url::parse(\"https://example.com\")?;\n/// assert_eq!(url.password(), None);\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn password(&self) -> Option<&str>{\n        // This ':' is not the one marking a port number since a host can not be empty.\n        // (Except for file: URLs, which do not have port numbers.)\n        if self.has_authority()\n            && self.username_end != self.serialization.len() as u32\n            && self.byte_at(self.username_end) == b':'\n        {\n            debug_assert!(self.byte_at(self.host_start - 1) == b'@');\n            Some(self.slice(self.username_end + 1..self.host_start - 1))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::path":["/// Return the path for this URL, as a percent-encoded ASCII string.\n/// For cannot-be-a-base URLs, this is an arbitrary string that doesn’t start with '/'.\n/// For other URLs, this starts with a '/' slash\n/// and continues with slash-separated path segments.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::{Url, ParseError};\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"https://example.com/api/versions?page=2\")?;\n/// assert_eq!(url.path(), \"/api/versions\");\n///\n/// let url = Url::parse(\"https://example.com\")?;\n/// assert_eq!(url.path(), \"/\");\n///\n/// let url = Url::parse(\"https://example.com/countries/việt nam\")?;\n/// assert_eq!(url.path(), \"/countries/vi%E1%BB%87t%20nam\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn path(&self) -> &str{\n        match (self.query_start, self.fragment_start) {\n            (None, None) => self.slice(self.path_start..),\n            (Some(next_component_start), _) | (None, Some(next_component_start)) => {\n                self.slice(self.path_start..next_component_start)\n            }\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::path_segments":["/// Unless this URL is cannot-be-a-base,\n/// return an iterator of '/' slash-separated path segments,\n/// each as a percent-encoded ASCII string.\n///\n/// Return `None` for cannot-be-a-base URLs.\n///\n/// When `Some` is returned, the iterator always contains at least one string\n/// (which may be empty).\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use std::error::Error;\n///\n/// # fn run() -> Result<(), Box<dyn Error>> {\n/// let url = Url::parse(\"https://example.com/foo/bar\")?;\n/// let mut path_segments = url.path_segments().ok_or_else(|| \"cannot be base\")?;\n/// assert_eq!(path_segments.next(), Some(\"foo\"));\n/// assert_eq!(path_segments.next(), Some(\"bar\"));\n/// assert_eq!(path_segments.next(), None);\n///\n/// let url = Url::parse(\"https://example.com\")?;\n/// let mut path_segments = url.path_segments().ok_or_else(|| \"cannot be base\")?;\n/// assert_eq!(path_segments.next(), Some(\"\"));\n/// assert_eq!(path_segments.next(), None);\n///\n/// let url = Url::parse(\"data:text/plain,HelloWorld\")?;\n/// assert!(url.path_segments().is_none());\n///\n/// let url = Url::parse(\"https://example.com/countries/việt nam\")?;\n/// let mut path_segments = url.path_segments().ok_or_else(|| \"cannot be base\")?;\n/// assert_eq!(path_segments.next(), Some(\"countries\"));\n/// assert_eq!(path_segments.next(), Some(\"vi%E1%BB%87t%20nam\"));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn path_segments(&self) -> Option<str::Split<'_, char>>{\n        let path = self.path();\n        if path.starts_with('/') {\n            Some(path[1..].split('/'))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::path_segments_mut":["/// Return an object with methods to manipulate this URL’s path segments.\n///\n/// Return `Err(())` if this URL is cannot-be-a-base.\npub fn path_segments_mut(&mut self) -> Result<PathSegmentsMut<'_>, ()>{\n        if self.cannot_be_a_base() {\n            Err(())\n        } else {\n            Ok(path_segments::new(self))\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::port":["/// Return the port number for this URL, if any.\n///\n/// Note that default port numbers are never reflected by the serialization,\n/// use the `port_or_known_default()` method if you want a default port number returned.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"https://example.com\")?;\n/// assert_eq!(url.port(), None);\n///\n/// let url = Url::parse(\"https://example.com:443/\")?;\n/// assert_eq!(url.port(), None);\n///\n/// let url = Url::parse(\"ssh://example.com:22\")?;\n/// assert_eq!(url.port(), Some(22));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n#[inline]\npub fn port(&self) -> Option<u16>{\n        self.port\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::port_or_known_default":["/// Return the port number for this URL, or the default port number if it is known.\n///\n/// This method only knows the default port number\n/// of the `http`, `https`, `ws`, `wss` and `ftp` schemes.\n///\n/// For URLs in these schemes, this method always returns `Some(_)`.\n/// For other schemes, it is the same as `Url::port()`.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"foo://example.com\")?;\n/// assert_eq!(url.port_or_known_default(), None);\n///\n/// let url = Url::parse(\"foo://example.com:1456\")?;\n/// assert_eq!(url.port_or_known_default(), Some(1456));\n///\n/// let url = Url::parse(\"https://example.com\")?;\n/// assert_eq!(url.port_or_known_default(), Some(443));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n#[inline]\npub fn port_or_known_default(&self) -> Option<u16>{\n        self.port.or_else(|| parser::default_port(self.scheme()))\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::query":["/// Return this URL’s query string, if any, as a percent-encoded ASCII string.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"https://example.com/products?page=2\")?;\n/// let query = url.query();\n/// assert_eq!(query, Some(\"page=2\"));\n///\n/// let url = Url::parse(\"https://example.com/products\")?;\n/// let query = url.query();\n/// assert!(query.is_none());\n///\n/// let url = Url::parse(\"https://example.com/?country=español\")?;\n/// let query = url.query();\n/// assert_eq!(query, Some(\"country=espa%C3%B1ol\"));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn query(&self) -> Option<&str>{\n        match (self.query_start, self.fragment_start) {\n            (None, _) => None,\n            (Some(query_start), None) => {\n                debug_assert!(self.byte_at(query_start) == b'?');\n                Some(self.slice(query_start + 1..))\n            }\n            (Some(query_start), Some(fragment_start)) => {\n                debug_assert!(self.byte_at(query_start) == b'?');\n                Some(self.slice(query_start + 1..fragment_start))\n            }\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::query_pairs":["/// Parse the URL’s query string, if any, as `application/x-www-form-urlencoded`\n/// and return an iterator of (key, value) pairs.\n///\n/// # Examples\n///\n/// ```rust\n/// use std::borrow::Cow;\n///\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"https://example.com/products?page=2&sort=desc\")?;\n/// let mut pairs = url.query_pairs();\n///\n/// assert_eq!(pairs.count(), 2);\n///\n/// assert_eq!(pairs.next(), Some((Cow::Borrowed(\"page\"), Cow::Borrowed(\"2\"))));\n/// assert_eq!(pairs.next(), Some((Cow::Borrowed(\"sort\"), Cow::Borrowed(\"desc\"))));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n///\n#[inline]\npub fn query_pairs(&self) -> form_urlencoded::Parse<'_>{\n        form_urlencoded::parse(self.query().unwrap_or(\"\").as_bytes())\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::query_pairs_mut":["/// Manipulate this URL’s query string, viewed as a sequence of name/value pairs\n/// in `application/x-www-form-urlencoded` syntax.\n///\n/// The return value has a method-chaining API:\n///\n/// ```rust\n/// # use url::{Url, ParseError};\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.net?lang=fr#nav\")?;\n/// assert_eq!(url.query(), Some(\"lang=fr\"));\n///\n/// url.query_pairs_mut().append_pair(\"foo\", \"bar\");\n/// assert_eq!(url.query(), Some(\"lang=fr&foo=bar\"));\n/// assert_eq!(url.as_str(), \"https://example.net/?lang=fr&foo=bar#nav\");\n///\n/// url.query_pairs_mut()\n///     .clear()\n///     .append_pair(\"foo\", \"bar & baz\")\n///     .append_pair(\"saisons\", \"\\u{00C9}t\\u{00E9}+hiver\");\n/// assert_eq!(url.query(), Some(\"foo=bar+%26+baz&saisons=%C3%89t%C3%A9%2Bhiver\"));\n/// assert_eq!(url.as_str(),\n///            \"https://example.net/?foo=bar+%26+baz&saisons=%C3%89t%C3%A9%2Bhiver#nav\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Note: `url.query_pairs_mut().clear();` is equivalent to `url.set_query(Some(\"\"))`,\n/// not `url.set_query(None)`.\n///\n/// The state of `Url` is unspecified if this return value is leaked without being dropped.\npub fn query_pairs_mut(&mut self) -> form_urlencoded::Serializer<'_, UrlQuery<'_>>{\n        let fragment = self.take_fragment();\n\n        let query_start;\n        if let Some(start) = self.query_start {\n            debug_assert!(self.byte_at(start) == b'?');\n            query_start = start as usize;\n        } else {\n            query_start = self.serialization.len();\n            self.query_start = Some(to_u32(query_start).unwrap());\n            self.serialization.push('?');\n        }\n\n        let query = UrlQuery {\n            url: Some(self),\n            fragment,\n        };\n        form_urlencoded::Serializer::for_suffix(query, query_start + \"?\".len())\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::restore_after_path":["fn restore_after_path(&mut self, old_after_path_position: u32, after_path: &str){\n        let new_after_path_position = to_u32(self.serialization.len()).unwrap();\n        let adjust = |index: &mut u32| {\n            *index -= old_after_path_position;\n            *index += new_after_path_position;\n        };\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n        self.serialization.push_str(after_path)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::restore_already_parsed_fragment":["fn restore_already_parsed_fragment(&mut self, fragment: Option<String>){\n        if let Some(ref fragment) = fragment {\n            assert!(self.fragment_start.is_none());\n            self.fragment_start = Some(to_u32(self.serialization.len()).unwrap());\n            self.serialization.push('#');\n            self.serialization.push_str(fragment);\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::scheme":["/// Return the scheme of this URL, lower-cased, as an ASCII string without the ':' delimiter.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"file:///tmp/foo\")?;\n/// assert_eq!(url.scheme(), \"file\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n#[inline]\npub fn scheme(&self) -> &str{\n        self.slice(..self.scheme_end)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::set_fragment":["/// Change this URL’s fragment identifier.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.com/data.csv\")?;\n/// assert_eq!(url.as_str(), \"https://example.com/data.csv\");\n/// url.set_fragment(Some(\"cell=4,1-6,2\"));\n/// assert_eq!(url.as_str(), \"https://example.com/data.csv#cell=4,1-6,2\");\n/// assert_eq!(url.fragment(), Some(\"cell=4,1-6,2\"));\n///\n/// url.set_fragment(None);\n/// assert_eq!(url.as_str(), \"https://example.com/data.csv\");\n/// assert!(url.fragment().is_none());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn set_fragment(&mut self, fragment: Option<&str>){\n        // Remove any previous fragment\n        if let Some(start) = self.fragment_start {\n            debug_assert!(self.byte_at(start) == b'#');\n            self.serialization.truncate(start as usize);\n        }\n        // Write the new one\n        if let Some(input) = fragment {\n            self.fragment_start = Some(to_u32(self.serialization.len()).unwrap());\n            self.serialization.push('#');\n            self.mutate(|parser| parser.parse_fragment(parser::Input::no_trim(input)))\n        } else {\n            self.fragment_start = None\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::set_host":["/// Change this URL’s host.\n///\n/// Removing the host (calling this with `None`)\n/// will also remove any username, password, and port number.\n///\n/// # Examples\n///\n/// Change host:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.net\")?;\n/// let result = url.set_host(Some(\"rust-lang.org\"));\n/// assert!(result.is_ok());\n/// assert_eq!(url.as_str(), \"https://rust-lang.org/\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Remove host:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"foo://example.net\")?;\n/// let result = url.set_host(None);\n/// assert!(result.is_ok());\n/// assert_eq!(url.as_str(), \"foo:/\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Cannot remove host for 'special' schemes (e.g. `http`):\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.net\")?;\n/// let result = url.set_host(None);\n/// assert!(result.is_err());\n/// assert_eq!(url.as_str(), \"https://example.net/\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Cannot change or remove host for cannot-be-a-base URLs:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"mailto:rms@example.net\")?;\n///\n/// let result = url.set_host(Some(\"rust-lang.org\"));\n/// assert!(result.is_err());\n/// assert_eq!(url.as_str(), \"mailto:rms@example.net\");\n///\n/// let result = url.set_host(None);\n/// assert!(result.is_err());\n/// assert_eq!(url.as_str(), \"mailto:rms@example.net\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// # Errors\n///\n/// If this URL is cannot-be-a-base or there is an error parsing the given `host`,\n/// a [`ParseError`] variant will be returned.\n///\n/// [`ParseError`]: enum.ParseError.html\npub fn set_host(&mut self, host: Option<&str>) -> Result<(), ParseError>{\n        if self.cannot_be_a_base() {\n            return Err(ParseError::SetHostOnCannotBeABaseUrl);\n        }\n\n        if let Some(host) = host {\n            if host == \"\" && SchemeType::from(self.scheme()).is_special() {\n                return Err(ParseError::EmptyHost);\n            }\n            let mut host_substr = host;\n            // Otherwise, if c is U+003A (:) and the [] flag is unset, then\n            if !host.starts_with('[') || !host.ends_with(']') {\n                match host.find(':') {\n                    Some(0) => {\n                        // If buffer is the empty string, validation error, return failure.\n                        return Err(ParseError::InvalidDomainCharacter);\n                    }\n                    // Let host be the result of host parsing buffer\n                    Some(colon_index) => {\n                        host_substr = &host[..colon_index];\n                    }\n                    None => {}\n                }\n            }\n            if SchemeType::from(self.scheme()).is_special() {\n                self.set_host_internal(Host::parse(host_substr)?, None);\n            } else {\n                self.set_host_internal(Host::parse_opaque(host_substr)?, None);\n            }\n        } else if self.has_host() {\n            let scheme_type = SchemeType::from(self.scheme());\n            if scheme_type.is_special() {\n                return Err(ParseError::EmptyHost);\n            } else if self.serialization.len() == self.path_start as usize {\n                self.serialization.push('/');\n            }\n            debug_assert!(self.byte_at(self.scheme_end) == b':');\n            debug_assert!(self.byte_at(self.path_start) == b'/');\n            let new_path_start = self.scheme_end + 1;\n            self.serialization\n                .drain(new_path_start as usize..self.path_start as usize);\n            let offset = self.path_start - new_path_start;\n            self.path_start = new_path_start;\n            self.username_end = new_path_start;\n            self.host_start = new_path_start;\n            self.host_end = new_path_start;\n            self.port = None;\n            if let Some(ref mut index) = self.query_start {\n                *index -= offset\n            }\n            if let Some(ref mut index) = self.fragment_start {\n                *index -= offset\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::set_host_internal":["/// opt_new_port: None means leave unchanged, Some(None) means remove any port number.\nfn set_host_internal(&mut self, host: Host<String>, opt_new_port: Option<Option<u16>>){\n        let old_suffix_pos = if opt_new_port.is_some() {\n            self.path_start\n        } else {\n            self.host_end\n        };\n        let suffix = self.slice(old_suffix_pos..).to_owned();\n        self.serialization.truncate(self.host_start as usize);\n        if !self.has_authority() {\n            debug_assert!(self.slice(self.scheme_end..self.host_start) == \":\");\n            debug_assert!(self.username_end == self.host_start);\n            self.serialization.push('/');\n            self.serialization.push('/');\n            self.username_end += 2;\n            self.host_start += 2;\n        }\n        write!(&mut self.serialization, \"{}\", host).unwrap();\n        self.host_end = to_u32(self.serialization.len()).unwrap();\n        self.host = host.into();\n\n        if let Some(new_port) = opt_new_port {\n            self.port = new_port;\n            if let Some(port) = new_port {\n                write!(&mut self.serialization, \":{}\", port).unwrap();\n            }\n        }\n        let new_suffix_pos = to_u32(self.serialization.len()).unwrap();\n        self.serialization.push_str(&suffix);\n\n        let adjust = |index: &mut u32| {\n            *index -= old_suffix_pos;\n            *index += new_suffix_pos;\n        };\n        adjust(&mut self.path_start);\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::set_ip_host":["/// Change this URL’s host to the given IP address.\n///\n/// If this URL is cannot-be-a-base, do nothing and return `Err`.\n///\n/// Compared to `Url::set_host`, this skips the host parser.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::{Url, ParseError};\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"http://example.com\")?;\n/// url.set_ip_host(\"127.0.0.1\".parse().unwrap());\n/// assert_eq!(url.host_str(), Some(\"127.0.0.1\"));\n/// assert_eq!(url.as_str(), \"http://127.0.0.1/\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Cannot change URL's from mailto(cannot-be-base) to ip:\n///\n/// ```rust\n/// use url::{Url, ParseError};\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"mailto:rms@example.com\")?;\n/// let result = url.set_ip_host(\"127.0.0.1\".parse().unwrap());\n///\n/// assert_eq!(url.as_str(), \"mailto:rms@example.com\");\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\npub fn set_ip_host(&mut self, address: IpAddr) -> Result<(), ()>{\n        if self.cannot_be_a_base() {\n            return Err(());\n        }\n\n        let address = match address {\n            IpAddr::V4(address) => Host::Ipv4(address),\n            IpAddr::V6(address) => Host::Ipv6(address),\n        };\n        self.set_host_internal(address, None);\n        Ok(())\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::set_password":["/// Change this URL’s password.\n///\n/// If this URL is cannot-be-a-base or does not have a host, do nothing and return `Err`.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::{Url, ParseError};\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"mailto:rmz@example.com\")?;\n/// let result = url.set_password(Some(\"secret_password\"));\n/// assert!(result.is_err());\n///\n/// let mut url = Url::parse(\"ftp://user1:secret1@example.com\")?;\n/// let result = url.set_password(Some(\"secret_password\"));\n/// assert_eq!(url.password(), Some(\"secret_password\"));\n///\n/// let mut url = Url::parse(\"ftp://user2:@example.com\")?;\n/// let result = url.set_password(Some(\"secret2\"));\n/// assert!(result.is_ok());\n/// assert_eq!(url.password(), Some(\"secret2\"));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn set_password(&mut self, password: Option<&str>) -> Result<(), ()>{\n        // has_host implies !cannot_be_a_base\n        if !self.has_host() || self.host() == Some(Host::Domain(\"\")) || self.scheme() == \"file\" {\n            return Err(());\n        }\n        if let Some(password) = password {\n            let host_and_after = self.slice(self.host_start..).to_owned();\n            self.serialization.truncate(self.username_end as usize);\n            self.serialization.push(':');\n            self.serialization\n                .extend(utf8_percent_encode(password, USERINFO));\n            self.serialization.push('@');\n\n            let old_host_start = self.host_start;\n            let new_host_start = to_u32(self.serialization.len()).unwrap();\n            let adjust = |index: &mut u32| {\n                *index -= old_host_start;\n                *index += new_host_start;\n            };\n            self.host_start = new_host_start;\n            adjust(&mut self.host_end);\n            adjust(&mut self.path_start);\n            if let Some(ref mut index) = self.query_start {\n                adjust(index)\n            }\n            if let Some(ref mut index) = self.fragment_start {\n                adjust(index)\n            }\n\n            self.serialization.push_str(&host_and_after);\n        } else if self.byte_at(self.username_end) == b':' {\n            // If there is a password to remove\n            let has_username_or_password = self.byte_at(self.host_start - 1) == b'@';\n            debug_assert!(has_username_or_password);\n            let username_start = self.scheme_end + 3;\n            let empty_username = username_start == self.username_end;\n            let start = self.username_end; // Remove the ':'\n            let end = if empty_username {\n                self.host_start // Remove the '@' as well\n            } else {\n                self.host_start - 1 // Keep the '@' to separate the username from the host\n            };\n            self.serialization.drain(start as usize..end as usize);\n            let offset = end - start;\n            self.host_start -= offset;\n            self.host_end -= offset;\n            self.path_start -= offset;\n            if let Some(ref mut index) = self.query_start {\n                *index -= offset\n            }\n            if let Some(ref mut index) = self.fragment_start {\n                *index -= offset\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::set_path":["/// Change this URL’s path.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.com\")?;\n/// url.set_path(\"api/comments\");\n/// assert_eq!(url.as_str(), \"https://example.com/api/comments\");\n/// assert_eq!(url.path(), \"/api/comments\");\n///\n/// let mut url = Url::parse(\"https://example.com/api\")?;\n/// url.set_path(\"data/report.csv\");\n/// assert_eq!(url.as_str(), \"https://example.com/data/report.csv\");\n/// assert_eq!(url.path(), \"/data/report.csv\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn set_path(&mut self, mut path: &str){\n        let after_path = self.take_after_path();\n        let old_after_path_pos = to_u32(self.serialization.len()).unwrap();\n        let cannot_be_a_base = self.cannot_be_a_base();\n        let scheme_type = SchemeType::from(self.scheme());\n        self.serialization.truncate(self.path_start as usize);\n        self.mutate(|parser| {\n            if cannot_be_a_base {\n                if path.starts_with('/') {\n                    parser.serialization.push_str(\"%2F\");\n                    path = &path[1..];\n                }\n                parser.parse_cannot_be_a_base_path(parser::Input::new(path));\n            } else {\n                let mut has_host = true; // FIXME\n                parser.parse_path_start(scheme_type, &mut has_host, parser::Input::new(path));\n            }\n        });\n        self.restore_after_path(old_after_path_pos, &after_path);\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::set_port":["/// Change this URL’s port number.\n///\n/// Note that default port numbers are not reflected in the serialization.\n///\n/// If this URL is cannot-be-a-base, does not have a host, or has the `file` scheme;\n/// do nothing and return `Err`.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use std::error::Error;\n///\n/// # fn run() -> Result<(), Box<dyn Error>> {\n/// let mut url = Url::parse(\"ssh://example.net:2048/\")?;\n///\n/// url.set_port(Some(4096)).map_err(|_| \"cannot be base\")?;\n/// assert_eq!(url.as_str(), \"ssh://example.net:4096/\");\n///\n/// url.set_port(None).map_err(|_| \"cannot be base\")?;\n/// assert_eq!(url.as_str(), \"ssh://example.net/\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Known default port numbers are not reflected:\n///\n/// ```rust\n/// use url::Url;\n/// # use std::error::Error;\n///\n/// # fn run() -> Result<(), Box<dyn Error>> {\n/// let mut url = Url::parse(\"https://example.org/\")?;\n///\n/// url.set_port(Some(443)).map_err(|_| \"cannot be base\")?;\n/// assert!(url.port().is_none());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Cannot set port for cannot-be-a-base URLs:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"mailto:rms@example.net\")?;\n///\n/// let result = url.set_port(Some(80));\n/// assert!(result.is_err());\n///\n/// let result = url.set_port(None);\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn set_port(&mut self, mut port: Option<u16>) -> Result<(), ()>{\n        // has_host implies !cannot_be_a_base\n        if !self.has_host() || self.host() == Some(Host::Domain(\"\")) || self.scheme() == \"file\" {\n            return Err(());\n        }\n        if port.is_some() && port == parser::default_port(self.scheme()) {\n            port = None\n        }\n        self.set_port_internal(port);\n        Ok(())\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::set_port_internal":["fn set_port_internal(&mut self, port: Option<u16>){\n        match (self.port, port) {\n            (None, None) => {}\n            (Some(_), None) => {\n                self.serialization\n                    .drain(self.host_end as usize..self.path_start as usize);\n                let offset = self.path_start - self.host_end;\n                self.path_start = self.host_end;\n                if let Some(ref mut index) = self.query_start {\n                    *index -= offset\n                }\n                if let Some(ref mut index) = self.fragment_start {\n                    *index -= offset\n                }\n            }\n            (Some(old), Some(new)) if old == new => {}\n            (_, Some(new)) => {\n                let path_and_after = self.slice(self.path_start..).to_owned();\n                self.serialization.truncate(self.host_end as usize);\n                write!(&mut self.serialization, \":{}\", new).unwrap();\n                let old_path_start = self.path_start;\n                let new_path_start = to_u32(self.serialization.len()).unwrap();\n                self.path_start = new_path_start;\n                let adjust = |index: &mut u32| {\n                    *index -= old_path_start;\n                    *index += new_path_start;\n                };\n                if let Some(ref mut index) = self.query_start {\n                    adjust(index)\n                }\n                if let Some(ref mut index) = self.fragment_start {\n                    adjust(index)\n                }\n                self.serialization.push_str(&path_and_after);\n            }\n        }\n        self.port = port;\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::set_query":["/// Change this URL’s query string.\n///\n/// # Examples\n///\n/// ```rust\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.com/products\")?;\n/// assert_eq!(url.as_str(), \"https://example.com/products\");\n///\n/// url.set_query(Some(\"page=2\"));\n/// assert_eq!(url.as_str(), \"https://example.com/products?page=2\");\n/// assert_eq!(url.query(), Some(\"page=2\"));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn set_query(&mut self, query: Option<&str>){\n        let fragment = self.take_fragment();\n\n        // Remove any previous query\n        if let Some(start) = self.query_start.take() {\n            debug_assert!(self.byte_at(start) == b'?');\n            self.serialization.truncate(start as usize);\n        }\n        // Write the new query, if any\n        if let Some(input) = query {\n            self.query_start = Some(to_u32(self.serialization.len()).unwrap());\n            self.serialization.push('?');\n            let scheme_type = SchemeType::from(self.scheme());\n            let scheme_end = self.scheme_end;\n            self.mutate(|parser| {\n                let vfn = parser.violation_fn;\n                parser.parse_query(\n                    scheme_type,\n                    scheme_end,\n                    parser::Input::trim_tab_and_newlines(input, vfn),\n                )\n            });\n        }\n\n        self.restore_already_parsed_fragment(fragment);\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::set_scheme":["/// Change this URL’s scheme.\n///\n/// Do nothing and return `Err` under the following circumstances:\n///\n/// * If the new scheme is not in `[a-zA-Z][a-zA-Z0-9+.-]+`\n/// * If this URL is cannot-be-a-base and the new scheme is one of\n///   `http`, `https`, `ws`, `wss` or `ftp`\n/// * If either the old or new scheme is `http`, `https`, `ws`,\n///   `wss` or `ftp` and the other is not one of these\n/// * If the new scheme is `file` and this URL includes credentials\n///   or has a non-null port\n/// * If this URL's scheme is `file` and its host is empty or null\n///\n/// See also [the URL specification's section on legal scheme state\n/// overrides](https://url.spec.whatwg.org/#scheme-state).\n///\n/// # Examples\n///\n/// Change the URL’s scheme from `https` to `foo`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.net\")?;\n/// let result = url.set_scheme(\"http\");\n/// assert_eq!(url.as_str(), \"http://example.net/\");\n/// assert!(result.is_ok());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n/// Change the URL’s scheme from `foo` to `bar`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"foo://example.net\")?;\n/// let result = url.set_scheme(\"bar\");\n/// assert_eq!(url.as_str(), \"bar://example.net\");\n/// assert!(result.is_ok());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Cannot change URL’s scheme from `https` to `foõ`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.net\")?;\n/// let result = url.set_scheme(\"foõ\");\n/// assert_eq!(url.as_str(), \"https://example.net/\");\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Cannot change URL’s scheme from `mailto` (cannot-be-a-base) to `https`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"mailto:rms@example.net\")?;\n/// let result = url.set_scheme(\"https\");\n/// assert_eq!(url.as_str(), \"mailto:rms@example.net\");\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n/// Cannot change the URL’s scheme from `foo` to `https`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"foo://example.net\")?;\n/// let result = url.set_scheme(\"https\");\n/// assert_eq!(url.as_str(), \"foo://example.net\");\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n/// Cannot change the URL’s scheme from `http` to `foo`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"http://example.net\")?;\n/// let result = url.set_scheme(\"foo\");\n/// assert_eq!(url.as_str(), \"http://example.net/\");\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn set_scheme(&mut self, scheme: &str) -> Result<(), ()>{\n        let mut parser = Parser::for_setter(String::new());\n        let remaining = parser.parse_scheme(parser::Input::new(scheme))?;\n        let new_scheme_type = SchemeType::from(&parser.serialization);\n        let old_scheme_type = SchemeType::from(self.scheme());\n        // If url’s scheme is a special scheme and buffer is not a special scheme, then return.\n        if (new_scheme_type.is_special() && !old_scheme_type.is_special()) ||\n            // If url’s scheme is not a special scheme and buffer is a special scheme, then return.\n            (!new_scheme_type.is_special() && old_scheme_type.is_special()) ||\n            // If url includes credentials or has a non-null port, and buffer is \"file\", then return.\n            // If url’s scheme is \"file\" and its host is an empty host or null, then return.\n            (new_scheme_type.is_file() && self.has_authority())\n        {\n            return Err(());\n        }\n\n        if !remaining.is_empty() || (!self.has_host() && new_scheme_type.is_special()) {\n            return Err(());\n        }\n        let old_scheme_end = self.scheme_end;\n        let new_scheme_end = to_u32(parser.serialization.len()).unwrap();\n        let adjust = |index: &mut u32| {\n            *index -= old_scheme_end;\n            *index += new_scheme_end;\n        };\n\n        self.scheme_end = new_scheme_end;\n        adjust(&mut self.username_end);\n        adjust(&mut self.host_start);\n        adjust(&mut self.host_end);\n        adjust(&mut self.path_start);\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n\n        parser.serialization.push_str(self.slice(old_scheme_end..));\n        self.serialization = parser.serialization;\n\n        // Update the port so it can be removed\n        // If it is the scheme's default\n        // we don't mind it silently failing\n        // if there was no port in the first place\n        let previous_port = self.port();\n        let _ = self.set_port(previous_port);\n\n        Ok(())\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::set_username":["/// Change this URL’s username.\n///\n/// If this URL is cannot-be-a-base or does not have a host, do nothing and return `Err`.\n/// # Examples\n///\n/// Cannot setup username from mailto(cannot-be-base)\n///\n/// ```rust\n/// use url::{Url, ParseError};\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"mailto:rmz@example.com\")?;\n/// let result = url.set_username(\"user1\");\n/// assert_eq!(url.as_str(), \"mailto:rmz@example.com\");\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Setup username to user1\n///\n/// ```rust\n/// use url::{Url, ParseError};\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"ftp://:secre1@example.com/\")?;\n/// let result = url.set_username(\"user1\");\n/// assert!(result.is_ok());\n/// assert_eq!(url.username(), \"user1\");\n/// assert_eq!(url.as_str(), \"ftp://user1:secre1@example.com/\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn set_username(&mut self, username: &str) -> Result<(), ()>{\n        // has_host implies !cannot_be_a_base\n        if !self.has_host() || self.host() == Some(Host::Domain(\"\")) || self.scheme() == \"file\" {\n            return Err(());\n        }\n        let username_start = self.scheme_end + 3;\n        debug_assert!(self.slice(self.scheme_end..username_start) == \"://\");\n        if self.slice(username_start..self.username_end) == username {\n            return Ok(());\n        }\n        let after_username = self.slice(self.username_end..).to_owned();\n        self.serialization.truncate(username_start as usize);\n        self.serialization\n            .extend(utf8_percent_encode(username, USERINFO));\n\n        let mut removed_bytes = self.username_end;\n        self.username_end = to_u32(self.serialization.len()).unwrap();\n        let mut added_bytes = self.username_end;\n\n        let new_username_is_empty = self.username_end == username_start;\n        match (new_username_is_empty, after_username.chars().next()) {\n            (true, Some('@')) => {\n                removed_bytes += 1;\n                self.serialization.push_str(&after_username[1..]);\n            }\n            (false, Some('@')) | (_, Some(':')) | (true, _) => {\n                self.serialization.push_str(&after_username);\n            }\n            (false, _) => {\n                added_bytes += 1;\n                self.serialization.push('@');\n                self.serialization.push_str(&after_username);\n            }\n        }\n\n        let adjust = |index: &mut u32| {\n            *index -= removed_bytes;\n            *index += added_bytes;\n        };\n        adjust(&mut self.host_start);\n        adjust(&mut self.host_end);\n        adjust(&mut self.path_start);\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n        Ok(())\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::slice":["#[inline]\nfn slice<R>(&self, range: R) -> &str\n    where\n        R: RangeArg,{\n        range.slice_of(&self.serialization)\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::socket_addrs":["/// Resolve a URL’s host and port number to `SocketAddr`.\n///\n/// If the URL has the default port number of a scheme that is unknown to this library,\n/// `default_port_number` provides an opportunity to provide the actual port number.\n/// In non-example code this should be implemented either simply as `|| None`,\n/// or by matching on the URL’s `.scheme()`.\n///\n/// If the host is a domain, it is resolved using the standard library’s DNS support.\n///\n/// # Examples\n///\n/// ```no_run\n/// let url = url::Url::parse(\"https://example.net/\").unwrap();\n/// let addrs = url.socket_addrs(|| None).unwrap();\n/// std::net::TcpStream::connect(&*addrs)\n/// # ;\n/// ```\n///\n/// ```\n/// /// With application-specific known default port numbers\n/// fn socket_addrs(url: url::Url) -> std::io::Result<Vec<std::net::SocketAddr>> {\n///     url.socket_addrs(|| match url.scheme() {\n///         \"socks5\" | \"socks5h\" => Some(1080),\n///         _ => None,\n///     })\n/// }\n/// ```\npub fn socket_addrs(\n        &self,\n        default_port_number: impl Fn() -> Option<u16>,\n    ) -> io::Result<Vec<SocketAddr>>{\n        // Note: trying to avoid the Vec allocation by returning `impl AsRef<[SocketAddr]>`\n        // causes borrowck issues because the return value borrows `default_port_number`:\n        //\n        // https://github.com/rust-lang/rfcs/blob/master/text/1951-expand-impl-trait.md#scoping-for-type-and-lifetime-parameters\n        //\n        // > This RFC proposes that *all* type parameters are considered in scope\n        // > for `impl Trait` in return position\n\n        fn io_result<T>(opt: Option<T>, message: &str) -> io::Result<T> {\n            opt.ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, message))\n        }\n\n        let host = io_result(self.host(), \"No host name in the URL\")?;\n        let port = io_result(\n            self.port_or_known_default().or_else(default_port_number),\n            \"No port number in the URL\",\n        )?;\n        Ok(match host {\n            Host::Domain(domain) => (domain, port).to_socket_addrs()?.collect(),\n            Host::Ipv4(ip) => vec![(ip, port).into()],\n            Host::Ipv6(ip) => vec![(ip, port).into()],\n        })\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::socket_addrs::io_result":["fn io_result<T>(opt: Option<T>, message: &str) -> io::Result<T>{\n            opt.ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, message))\n        }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::take_after_path":["fn take_after_path(&mut self) -> String{\n        match (self.query_start, self.fragment_start) {\n            (Some(i), _) | (None, Some(i)) => {\n                let after_path = self.slice(i..).to_owned();\n                self.serialization.truncate(i as usize);\n                after_path\n            }\n            (None, None) => String::new(),\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::take_fragment":["fn take_fragment(&mut self) -> Option<String>{\n        self.fragment_start.take().map(|start| {\n            debug_assert!(self.byte_at(start) == b'#');\n            let fragment = self.slice(start + 1..).to_owned();\n            self.serialization.truncate(start as usize);\n            fragment\n        })\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::to_file_path":["/// Assuming the URL is in the `file` scheme or similar,\n/// convert its path to an absolute `std::path::Path`.\n///\n/// **Note:** This does not actually check the URL’s `scheme`,\n/// and may give nonsensical results for other schemes.\n/// It is the user’s responsibility to check the URL’s scheme before calling this.\n///\n/// ```\n/// # use url::Url;\n/// # let url = Url::parse(\"file:///etc/passwd\").unwrap();\n/// let path = url.to_file_path();\n/// ```\n///\n/// Returns `Err` if the host is neither empty nor `\"localhost\"` (except on Windows, where\n/// `file:` URLs may have a non-local host),\n/// or if `Path::new_opt()` returns `None`.\n/// (That is, if the percent-decoded path contains a NUL byte or,\n/// for a Windows path, is not UTF-8.)\n#[inline]\n#[cfg(any(unix, windows, target_os = \"redox\"))]\npub fn to_file_path(&self) -> Result<PathBuf, ()>{\n        if let Some(segments) = self.path_segments() {\n            let host = match self.host() {\n                None | Some(Host::Domain(\"localhost\")) => None,\n                Some(_) if cfg!(windows) && self.scheme() == \"file\" => {\n                    Some(&self.serialization[self.host_start as usize..self.host_end as usize])\n                }\n                _ => return Err(()),\n            };\n\n            return file_url_segments_to_pathbuf(host, segments);\n        }\n        Err(())\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"Url::username":["/// Return the username for this URL (typically the empty string)\n/// as a percent-encoded ASCII string.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"ftp://rms@example.com\")?;\n/// assert_eq!(url.username(), \"rms\");\n///\n/// let url = Url::parse(\"ftp://:secret123@example.com\")?;\n/// assert_eq!(url.username(), \"\");\n///\n/// let url = Url::parse(\"https://example.com\")?;\n/// assert_eq!(url.username(), \"\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn username(&self) -> &str{\n        if self.has_authority() {\n            self.slice(self.scheme_end + (\"://\".len() as u32)..self.username_end)\n        } else {\n            \"\"\n        }\n    }","Real(LocalPath(\"url/src/lib.rs\"))"],"UrlQuery":["/// Implementation detail of `Url::query_pairs_mut`. Typically not used directly.\npub struct UrlQuery<'a> {\n    url: Option<&'a mut Url>,\n    fragment: Option<String>,\n}","Real(LocalPath(\"url/src/lib.rs\"))"],"file_url_segments_to_pathbuf":["#[cfg(any(unix, target_os = \"redox\"))]\nfn file_url_segments_to_pathbuf(\n    host: Option<&str>,\n    segments: str::Split<'_, char>,\n) -> Result<PathBuf, ()>{\n    use std::ffi::OsStr;\n    use std::os::unix::prelude::OsStrExt;\n\n    if host.is_some() {\n        return Err(());\n    }\n\n    let mut bytes = if cfg!(target_os = \"redox\") {\n        b\"file:\".to_vec()\n    } else {\n        Vec::new()\n    };\n    for segment in segments {\n        bytes.push(b'/');\n        bytes.extend(percent_decode(segment.as_bytes()));\n    }\n    // A windows drive letter must end with a slash.\n    if bytes.len() > 2\n        && matches!(bytes[bytes.len() - 2], b'a'..=b'z' | b'A'..=b'Z')\n        && matches!(bytes[bytes.len() - 1], b':' | b'|')\n    {\n        bytes.push(b'/');\n    }\n    let os_str = OsStr::from_bytes(&bytes);\n    let path = PathBuf::from(os_str);\n    debug_assert!(\n        path.is_absolute(),\n        \"to_file_path() failed to produce an absolute Path\"\n    );\n    Ok(path)\n}","Real(LocalPath(\"url/src/lib.rs\"))"],"file_url_segments_to_pathbuf_windows":["allow(dead_code)\nfn file_url_segments_to_pathbuf_windows(\n    host: Option<&str>,\n    mut segments: str::Split<'_, char>,\n) -> Result<PathBuf, ()>{\n    let mut string = if let Some(host) = host {\n        r\"\\\\\".to_owned() + host\n    } else {\n        let first = segments.next().ok_or(())?;\n\n        match first.len() {\n            2 => {\n                if !first.starts_with(parser::ascii_alpha) || first.as_bytes()[1] != b':' {\n                    return Err(());\n                }\n\n                first.to_owned()\n            }\n\n            4 => {\n                if !first.starts_with(parser::ascii_alpha) {\n                    return Err(());\n                }\n                let bytes = first.as_bytes();\n                if bytes[1] != b'%' || bytes[2] != b'3' || (bytes[3] != b'a' && bytes[3] != b'A') {\n                    return Err(());\n                }\n\n                first[0..1].to_owned() + \":\"\n            }\n\n            _ => return Err(()),\n        }\n    };\n\n    for segment in segments {\n        string.push('\\\\');\n\n        // Currently non-unicode windows paths cannot be represented\n        match String::from_utf8(percent_decode(segment.as_bytes()).collect()) {\n            Ok(s) => string.push_str(&s),\n            Err(..) => return Err(()),\n        }\n    }\n    let path = PathBuf::from(string);\n    debug_assert!(\n        path.is_absolute(),\n        \"to_file_path() failed to produce an absolute Path\"\n    );\n    Ok(path)\n}","Real(LocalPath(\"url/src/lib.rs\"))"],"host::Host":["/// The host name of an URL.\npub enum Host<S = String> {\n    /// A DNS domain name, as '.' dot-separated labels.\n    /// Non-ASCII labels are encoded in punycode per IDNA if this is the host of\n    /// a special URL, or percent encoded for non-special URLs. Hosts for\n    /// non-special URLs are also called opaque hosts.\n    Domain(S),\n\n    /// An IPv4 address.\n    /// `Url::host_str` returns the serialization of this address,\n    /// as four decimal integers separated by `.` dots.\n    Ipv4(Ipv4Addr),\n\n    /// An IPv6 address.\n    /// `Url::host_str` returns the serialization of that address between `[` and `]` brackets,\n    /// in the format per [RFC 5952 *A Recommendation\n    /// for IPv6 Address Text Representation*](https://tools.ietf.org/html/rfc5952):\n    /// lowercase hexadecimal with maximal `::` compression.\n    Ipv6(Ipv6Addr),\n}","Real(LocalPath(\"url/src/host.rs\"))"],"host::Host::<&'a str>::to_owned":["/// Return a copy of `self` that owns an allocated `String` but does not borrow an `&Url`.\npub fn to_owned(&self) -> Host<String>{\n        match *self {\n            Host::Domain(domain) => Host::Domain(domain.to_owned()),\n            Host::Ipv4(address) => Host::Ipv4(address),\n            Host::Ipv6(address) => Host::Ipv6(address),\n        }\n    }","Real(LocalPath(\"url/src/host.rs\"))"],"host::Host::parse":["/// Parse a host: either an IPv6 address in [] square brackets, or a domain.\n///\n/// <https://url.spec.whatwg.org/#host-parsing>\npub fn parse(input: &str) -> Result<Self, ParseError>{\n        if input.starts_with('[') {\n            if !input.ends_with(']') {\n                return Err(ParseError::InvalidIpv6Address);\n            }\n            return parse_ipv6addr(&input[1..input.len() - 1]).map(Host::Ipv6);\n        }\n        let domain = percent_decode(input.as_bytes()).decode_utf8_lossy();\n        let domain = idna::domain_to_ascii(&domain)?;\n        if domain.is_empty() {\n            return Err(ParseError::EmptyHost);\n        }\n\n        let is_invalid_domain_char = |c| {\n            matches!(\n                c,\n                '\\0' | '\\t'\n                    | '\\n'\n                    | '\\r'\n                    | ' '\n                    | '#'\n                    | '%'\n                    | '/'\n                    | ':'\n                    | '<'\n                    | '>'\n                    | '?'\n                    | '@'\n                    | '['\n                    | '\\\\'\n                    | ']'\n                    | '^'\n            )\n        };\n\n        if domain.find(is_invalid_domain_char).is_some() {\n            Err(ParseError::InvalidDomainCharacter)\n        } else if let Some(address) = parse_ipv4addr(&domain)? {\n            Ok(Host::Ipv4(address))\n        } else {\n            Ok(Host::Domain(domain))\n        }\n    }","Real(LocalPath(\"url/src/host.rs\"))"],"host::Host::parse_opaque":["pub fn parse_opaque(input: &str) -> Result<Self, ParseError>{\n        if input.starts_with('[') {\n            if !input.ends_with(']') {\n                return Err(ParseError::InvalidIpv6Address);\n            }\n            return parse_ipv6addr(&input[1..input.len() - 1]).map(Host::Ipv6);\n        }\n\n        let is_invalid_host_char = |c| {\n            matches!(\n                c,\n                '\\0' | '\\t'\n                    | '\\n'\n                    | '\\r'\n                    | ' '\n                    | '#'\n                    | '/'\n                    | ':'\n                    | '<'\n                    | '>'\n                    | '?'\n                    | '@'\n                    | '['\n                    | '\\\\'\n                    | ']'\n                    | '^'\n            )\n        };\n\n        if input.find(is_invalid_host_char).is_some() {\n            Err(ParseError::InvalidDomainCharacter)\n        } else {\n            Ok(Host::Domain(\n                utf8_percent_encode(input, CONTROLS).to_string(),\n            ))\n        }\n    }","Real(LocalPath(\"url/src/host.rs\"))"],"host::HostInternal":["pub(crate) enum HostInternal {\n    None,\n    Domain,\n    Ipv4(Ipv4Addr),\n    Ipv6(Ipv6Addr),\n}","Real(LocalPath(\"url/src/host.rs\"))"],"host::longest_zero_sequence":["fn longest_zero_sequence(pieces: &[u16; 8]) -> (isize, isize){\n    let mut longest = -1;\n    let mut longest_length = -1;\n    let mut start = -1;\n    macro_rules! finish_sequence(\n        ($end: expr) => {\n            if start >= 0 {\n                let length = $end - start;\n                if length > longest_length {\n                    longest = start;\n                    longest_length = length;\n                }\n            }\n        };\n    );\n    for i in 0..8 {\n        if pieces[i as usize] == 0 {\n            if start < 0 {\n                start = i;\n            }\n        } else {\n            finish_sequence!(i);\n            start = -1;\n        }\n    }\n    finish_sequence!(8);\n    // https://url.spec.whatwg.org/#concept-ipv6-serializer\n    // step 3: ignore lone zeroes\n    if longest_length < 2 {\n        (-1, -2)\n    } else {\n        (longest, longest + longest_length)\n    }\n}","Real(LocalPath(\"url/src/host.rs\"))"],"host::parse_ipv4addr":["/// <https://url.spec.whatwg.org/#concept-ipv4-parser>\nfn parse_ipv4addr(input: &str) -> ParseResult<Option<Ipv4Addr>>{\n    if input.is_empty() {\n        return Ok(None);\n    }\n    let mut parts: Vec<&str> = input.split('.').collect();\n    if parts.last() == Some(&\"\") {\n        parts.pop();\n    }\n    if parts.len() > 4 {\n        return Ok(None);\n    }\n    let mut numbers: Vec<u32> = Vec::new();\n    let mut overflow = false;\n    for part in parts {\n        if part == \"\" {\n            return Ok(None);\n        }\n        match parse_ipv4number(part) {\n            Ok(Some(n)) => numbers.push(n),\n            Ok(None) => return Ok(None),\n            Err(()) => overflow = true,\n        };\n    }\n    if overflow {\n        return Err(ParseError::InvalidIpv4Address);\n    }\n    let mut ipv4 = numbers.pop().expect(\"a non-empty list of numbers\");\n    // Equivalent to: ipv4 >= 256 ** (4 − numbers.len())\n    if ipv4 > u32::max_value() >> (8 * numbers.len() as u32) {\n        return Err(ParseError::InvalidIpv4Address);\n    }\n    if numbers.iter().any(|x| *x > 255) {\n        return Err(ParseError::InvalidIpv4Address);\n    }\n    for (counter, n) in numbers.iter().enumerate() {\n        ipv4 += n << (8 * (3 - counter as u32))\n    }\n    Ok(Some(Ipv4Addr::from(ipv4)))\n}","Real(LocalPath(\"url/src/host.rs\"))"],"host::parse_ipv4number":["/// <https://url.spec.whatwg.org/#ipv4-number-parser>\nfn parse_ipv4number(mut input: &str) -> Result<Option<u32>, ()>{\n    let mut r = 10;\n    if input.starts_with(\"0x\") || input.starts_with(\"0X\") {\n        input = &input[2..];\n        r = 16;\n    } else if input.len() >= 2 && input.starts_with('0') {\n        input = &input[1..];\n        r = 8;\n    }\n\n    // At the moment we can't know the reason why from_str_radix fails\n    // https://github.com/rust-lang/rust/issues/22639\n    // So instead we check if the input looks like a real number and only return\n    // an error when it's an overflow.\n    let valid_number = match r {\n        8 => input.chars().all(|c| c >= '0' && c <= '7'),\n        10 => input.chars().all(|c| c >= '0' && c <= '9'),\n        16 => input\n            .chars()\n            .all(|c| (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')),\n        _ => false,\n    };\n\n    if !valid_number {\n        return Ok(None);\n    }\n\n    if input.is_empty() {\n        return Ok(Some(0));\n    }\n    if input.starts_with('+') {\n        return Ok(None);\n    }\n    match u32::from_str_radix(input, r) {\n        Ok(number) => Ok(Some(number)),\n        Err(_) => Err(()),\n    }\n}","Real(LocalPath(\"url/src/host.rs\"))"],"host::parse_ipv6addr":["/// <https://url.spec.whatwg.org/#concept-ipv6-parser>\nfn parse_ipv6addr(input: &str) -> ParseResult<Ipv6Addr>{\n    let input = input.as_bytes();\n    let len = input.len();\n    let mut is_ip_v4 = false;\n    let mut pieces = [0, 0, 0, 0, 0, 0, 0, 0];\n    let mut piece_pointer = 0;\n    let mut compress_pointer = None;\n    let mut i = 0;\n\n    if len < 2 {\n        return Err(ParseError::InvalidIpv6Address);\n    }\n\n    if input[0] == b':' {\n        if input[1] != b':' {\n            return Err(ParseError::InvalidIpv6Address);\n        }\n        i = 2;\n        piece_pointer = 1;\n        compress_pointer = Some(1);\n    }\n\n    while i < len {\n        if piece_pointer == 8 {\n            return Err(ParseError::InvalidIpv6Address);\n        }\n        if input[i] == b':' {\n            if compress_pointer.is_some() {\n                return Err(ParseError::InvalidIpv6Address);\n            }\n            i += 1;\n            piece_pointer += 1;\n            compress_pointer = Some(piece_pointer);\n            continue;\n        }\n        let start = i;\n        let end = cmp::min(len, start + 4);\n        let mut value = 0u16;\n        while i < end {\n            match (input[i] as char).to_digit(16) {\n                Some(digit) => {\n                    value = value * 0x10 + digit as u16;\n                    i += 1;\n                }\n                None => break,\n            }\n        }\n        if i < len {\n            match input[i] {\n                b'.' => {\n                    if i == start {\n                        return Err(ParseError::InvalidIpv6Address);\n                    }\n                    i = start;\n                    if piece_pointer > 6 {\n                        return Err(ParseError::InvalidIpv6Address);\n                    }\n                    is_ip_v4 = true;\n                }\n                b':' => {\n                    i += 1;\n                    if i == len {\n                        return Err(ParseError::InvalidIpv6Address);\n                    }\n                }\n                _ => return Err(ParseError::InvalidIpv6Address),\n            }\n        }\n        if is_ip_v4 {\n            break;\n        }\n        pieces[piece_pointer] = value;\n        piece_pointer += 1;\n    }\n\n    if is_ip_v4 {\n        if piece_pointer > 6 {\n            return Err(ParseError::InvalidIpv6Address);\n        }\n        let mut numbers_seen = 0;\n        while i < len {\n            if numbers_seen > 0 {\n                if numbers_seen < 4 && (i < len && input[i] == b'.') {\n                    i += 1\n                } else {\n                    return Err(ParseError::InvalidIpv6Address);\n                }\n            }\n\n            let mut ipv4_piece = None;\n            while i < len {\n                let digit = match input[i] {\n                    c @ b'0'..=b'9' => c - b'0',\n                    _ => break,\n                };\n                match ipv4_piece {\n                    None => ipv4_piece = Some(digit as u16),\n                    Some(0) => return Err(ParseError::InvalidIpv6Address), // No leading zero\n                    Some(ref mut v) => {\n                        *v = *v * 10 + digit as u16;\n                        if *v > 255 {\n                            return Err(ParseError::InvalidIpv6Address);\n                        }\n                    }\n                }\n                i += 1;\n            }\n\n            pieces[piece_pointer] = if let Some(v) = ipv4_piece {\n                pieces[piece_pointer] * 0x100 + v\n            } else {\n                return Err(ParseError::InvalidIpv6Address);\n            };\n            numbers_seen += 1;\n\n            if numbers_seen == 2 || numbers_seen == 4 {\n                piece_pointer += 1;\n            }\n        }\n\n        if numbers_seen != 4 {\n            return Err(ParseError::InvalidIpv6Address);\n        }\n    }\n\n    if i < len {\n        return Err(ParseError::InvalidIpv6Address);\n    }\n\n    match compress_pointer {\n        Some(compress_pointer) => {\n            let mut swaps = piece_pointer - compress_pointer;\n            piece_pointer = 7;\n            while swaps > 0 {\n                pieces.swap(piece_pointer, compress_pointer + swaps - 1);\n                swaps -= 1;\n                piece_pointer -= 1;\n            }\n        }\n        _ => {\n            if piece_pointer != 8 {\n                return Err(ParseError::InvalidIpv6Address);\n            }\n        }\n    }\n    Ok(Ipv6Addr::new(\n        pieces[0], pieces[1], pieces[2], pieces[3], pieces[4], pieces[5], pieces[6], pieces[7],\n    ))\n}","Real(LocalPath(\"url/src/host.rs\"))"],"host::write_ipv6":["fn write_ipv6(addr: &Ipv6Addr, f: &mut Formatter<'_>) -> fmt::Result{\n    let segments = addr.segments();\n    let (compress_start, compress_end) = longest_zero_sequence(&segments);\n    let mut i = 0;\n    while i < 8 {\n        if i == compress_start {\n            f.write_str(\":\")?;\n            if i == 0 {\n                f.write_str(\":\")?;\n            }\n            if compress_end < 8 {\n                i = compress_end;\n            } else {\n                break;\n            }\n        }\n        write!(f, \"{:x}\", segments[i as usize])?;\n        if i < 7 {\n            f.write_str(\":\")?;\n        }\n        i += 1;\n    }\n    Ok(())\n}","Real(LocalPath(\"url/src/host.rs\"))"],"origin::OpaqueOrigin":["/// Opaque identifier for URLs that have file or other schemes\npub struct OpaqueOrigin(usize);","Real(LocalPath(\"url/src/origin.rs\"))"],"origin::Origin":["/// The origin of an URL\n///\n/// Two URLs with the same origin are considered\n/// to originate from the same entity and can therefore trust\n/// each other.\n///\n/// The origin is determined based on the scheme as follows:\n///\n/// - If the scheme is \"blob\" the origin is the origin of the\n///   URL contained in the path component. If parsing fails,\n///   it is an opaque origin.\n/// - If the scheme is \"ftp\", \"http\", \"https\", \"ws\", or \"wss\",\n///   then the origin is a tuple of the scheme, host, and port.\n/// - If the scheme is anything else, the origin is opaque, meaning\n///   the URL does not have the same origin as any other URL.\n///\n/// For more information see <https://url.spec.whatwg.org/#origin>\npub enum Origin {\n    /// A globally unique identifier\n    Opaque(OpaqueOrigin),\n\n    /// Consists of the URL's scheme, host and port\n    Tuple(String, Host<String>, u16),\n}","Real(LocalPath(\"url/src/origin.rs\"))"],"origin::Origin::ascii_serialization":["/// <https://html.spec.whatwg.org/multipage/#ascii-serialisation-of-an-origin>\npub fn ascii_serialization(&self) -> String{\n        match *self {\n            Origin::Opaque(_) => \"null\".to_owned(),\n            Origin::Tuple(ref scheme, ref host, port) => {\n                if default_port(scheme) == Some(port) {\n                    format!(\"{}://{}\", scheme, host)\n                } else {\n                    format!(\"{}://{}:{}\", scheme, host, port)\n                }\n            }\n        }\n    }","Real(LocalPath(\"url/src/origin.rs\"))"],"origin::Origin::is_tuple":["/// Return whether this origin is a (scheme, host, port) tuple\n/// (as opposed to an opaque origin).\npub fn is_tuple(&self) -> bool{\n        matches!(*self, Origin::Tuple(..))\n    }","Real(LocalPath(\"url/src/origin.rs\"))"],"origin::Origin::new_opaque":["/// Creates a new opaque origin that is only equal to itself.\npub fn new_opaque() -> Origin{\n        static COUNTER: AtomicUsize = AtomicUsize::new(0);\n        Origin::Opaque(OpaqueOrigin(COUNTER.fetch_add(1, Ordering::SeqCst)))\n    }","Real(LocalPath(\"url/src/origin.rs\"))"],"origin::Origin::unicode_serialization":["/// <https://html.spec.whatwg.org/multipage/#unicode-serialisation-of-an-origin>\npub fn unicode_serialization(&self) -> String{\n        match *self {\n            Origin::Opaque(_) => \"null\".to_owned(),\n            Origin::Tuple(ref scheme, ref host, port) => {\n                let host = match *host {\n                    Host::Domain(ref domain) => {\n                        let (domain, _errors) = domain_to_unicode(domain);\n                        Host::Domain(domain)\n                    }\n                    _ => host.clone(),\n                };\n                if default_port(scheme) == Some(port) {\n                    format!(\"{}://{}\", scheme, host)\n                } else {\n                    format!(\"{}://{}:{}\", scheme, host, port)\n                }\n            }\n        }\n    }","Real(LocalPath(\"url/src/origin.rs\"))"],"origin::url_origin":["pub fn url_origin(url: &Url) -> Origin{\n    let scheme = url.scheme();\n    match scheme {\n        \"blob\" => {\n            let result = Url::parse(url.path());\n            match result {\n                Ok(ref url) => url_origin(url),\n                Err(_) => Origin::new_opaque(),\n            }\n        }\n        \"ftp\" | \"http\" | \"https\" | \"ws\" | \"wss\" => Origin::Tuple(\n            scheme.to_owned(),\n            url.host().unwrap().to_owned(),\n            url.port_or_known_default().unwrap(),\n        ),\n        // TODO: Figure out what to do if the scheme is a file\n        \"file\" => Origin::new_opaque(),\n        _ => Origin::new_opaque(),\n    }\n}","Real(LocalPath(\"url/src/origin.rs\"))"],"parser::Context":["pub enum Context {\n    UrlParser,\n    Setter,\n    PathSegmentSetter,\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Input":["pub struct Input<'i> {\n    chars: str::Chars<'i>,\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Input::<'i>::count_matching":["#[inline]\nfn count_matching<F: Fn(char) -> bool>(&self, f: F) -> (u32, Self){\n        let mut count = 0;\n        let mut remaining = self.clone();\n        loop {\n            let mut input = remaining.clone();\n            if matches!(input.next(), Some(c) if f(c)) {\n                remaining = input;\n                count += 1;\n            } else {\n                return (count, remaining);\n            }\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Input::<'i>::is_empty":["#[inline]\npub fn is_empty(&self) -> bool{\n        self.clone().next().is_none()\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Input::<'i>::new":["pub fn new(input: &'i str) -> Self{\n        Input::with_log(input, None)\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Input::<'i>::next_utf8":["#[inline]\nfn next_utf8(&mut self) -> Option<(char, &'i str)>{\n        loop {\n            let utf8 = self.chars.as_str();\n            match self.chars.next() {\n                Some(c) => {\n                    if !matches!(c, '\\t' | '\\n' | '\\r') {\n                        return Some((c, &utf8[..c.len_utf8()]));\n                    }\n                }\n                None => return None,\n            }\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Input::<'i>::no_trim":["pub fn no_trim(input: &'i str) -> Self{\n        Input {\n            chars: input.chars(),\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Input::<'i>::split_first":["#[inline]\nfn split_first(&self) -> (Option<char>, Self){\n        let mut remaining = self.clone();\n        (remaining.next(), remaining)\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Input::<'i>::split_prefix":["#[inline]\npub fn split_prefix<P: Pattern>(&self, p: P) -> Option<Self>{\n        let mut remaining = self.clone();\n        if p.split_prefix(&mut remaining) {\n            Some(remaining)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Input::<'i>::starts_with":["#[inline]\nfn starts_with<P: Pattern>(&self, p: P) -> bool{\n        p.split_prefix(&mut self.clone())\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Input::<'i>::trim_tab_and_newlines":["pub fn trim_tab_and_newlines(\n        original_input: &'i str,\n        vfn: Option<&dyn Fn(SyntaxViolation)>,\n    ) -> Self{\n        let input = original_input.trim_matches(ascii_tab_or_new_line);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(|c| matches!(c, '\\t' | '\\n' | '\\r')) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input {\n            chars: input.chars(),\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Input::<'i>::with_log":["pub fn with_log(original_input: &'i str, vfn: Option<&dyn Fn(SyntaxViolation)>) -> Self{\n        let input = original_input.trim_matches(c0_control_or_space);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(|c| matches!(c, '\\t' | '\\n' | '\\r')) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input {\n            chars: input.chars(),\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::ParseError":["/// Errors that can occur during parsing.\n///\n/// This may be extended in the future so exhaustive matching is\n/// discouraged with an unused variant.\n#[allow(clippy::manual_non_exhaustive)]\npub enum ParseError {\n            $(\n                $name,\n            )+\n            /// Unused variant enable non-exhaustive matching\n            #[doc(hidden)]\n            __FutureProof,\n        }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser":["pub struct Parser<'a> {\n    pub serialization: String,\n    pub base_url: Option<&'a Url>,\n    pub query_encoding_override: EncodingOverride<'a>,\n    pub violation_fn: Option<&'a dyn Fn(SyntaxViolation)>,\n    pub context: Context,\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::after_double_slash":["fn after_double_slash(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n    ) -> ParseResult<Url>{\n        self.serialization.push('/');\n        self.serialization.push('/');\n        // authority state\n        let before_authority = self.serialization.len();\n        let (username_end, remaining) = self.parse_userinfo(input, scheme_type)?;\n        let has_authority = before_authority != self.serialization.len();\n        // host state\n        let host_start = to_u32(self.serialization.len())?;\n        let (host_end, host, port, remaining) =\n            self.parse_host_and_port(remaining, scheme_end, scheme_type)?;\n        if host == HostInternal::None && has_authority {\n            return Err(ParseError::EmptyHost);\n        }\n        // path state\n        let path_start = to_u32(self.serialization.len())?;\n        let remaining = self.parse_path_start(scheme_type, &mut true, remaining);\n        self.with_query_and_fragment(\n            scheme_type,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            remaining,\n        )\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::check_url_code_point":["fn check_url_code_point(&self, c: char, input: &Input<'_>){\n        if let Some(vfn) = self.violation_fn {\n            if c == '%' {\n                let mut input = input.clone();\n                if !matches!((input.next(), input.next()), (Some(a), Some(b))\n                             if is_ascii_hex_digit(a) && is_ascii_hex_digit(b))\n                {\n                    vfn(SyntaxViolation::PercentDecode)\n                }\n            } else if !is_url_code_point(c) {\n                vfn(SyntaxViolation::NonUrlCodePoint)\n            }\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::file_host":["pub fn file_host<'i>(input: Input<'i>) -> ParseResult<(bool, String, Input<'i>)>{\n        // Undo the Input abstraction here to avoid allocating in the common case\n        // where the host part of the input does not contain any tab or newline\n        let input_str = input.chars.as_str();\n        let mut has_ignored_chars = false;\n        let mut non_ignored_chars = 0;\n        let mut bytes = 0;\n        for c in input_str.chars() {\n            match c {\n                '/' | '\\\\' | '?' | '#' => break,\n                '\\t' | '\\n' | '\\r' => has_ignored_chars = true,\n                _ => non_ignored_chars += 1,\n            }\n            bytes += c.len_utf8();\n        }\n        let replaced: String;\n        let host_str;\n        let mut remaining = input.clone();\n        {\n            let host_input = remaining.by_ref().take(non_ignored_chars);\n            if has_ignored_chars {\n                replaced = host_input.collect();\n                host_str = &*replaced\n            } else {\n                for _ in host_input {}\n                host_str = &input_str[..bytes]\n            }\n        }\n        if is_windows_drive_letter(host_str) {\n            return Ok((false, \"\".to_string(), input));\n        }\n        Ok((true, host_str.to_string(), remaining))\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::for_setter":["pub fn for_setter(serialization: String) -> Parser<'a>{\n        Parser {\n            serialization,\n            base_url: None,\n            query_encoding_override: None,\n            violation_fn: None,\n            context: Context::Setter,\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::fragment_only":["fn fragment_only(mut self, base_url: &Url, mut input: Input<'_>) -> ParseResult<Url>{\n        let before_fragment = match base_url.fragment_start {\n            Some(i) => base_url.slice(..i),\n            None => &*base_url.serialization,\n        };\n        debug_assert!(self.serialization.is_empty());\n        self.serialization\n            .reserve(before_fragment.len() + input.chars.as_str().len());\n        self.serialization.push_str(before_fragment);\n        self.serialization.push('#');\n        let next = input.next();\n        debug_assert!(next == Some('#'));\n        self.parse_fragment(input);\n        Ok(Url {\n            serialization: self.serialization,\n            fragment_start: Some(to_u32(before_fragment.len())?),\n            ..*base_url\n        })\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::get_file_host":["fn get_file_host(input: Input<'_>) -> ParseResult<(Host<String>, Input<'_>)>{\n        let (_, host_str, remaining) = Parser::file_host(input)?;\n        let host = match Host::parse(&host_str)? {\n            Host::Domain(ref d) if d == \"localhost\" => Host::Domain(\"\".to_string()),\n            host => host,\n        };\n        Ok((host, remaining))\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::last_slash_can_be_removed":["fn last_slash_can_be_removed(serialization: &str, path_start: usize) -> bool{\n        let url_before_segment = &serialization[..serialization.len() - 1];\n        if let Some(segment_before_start) = url_before_segment.rfind('/') {\n            // Do not remove the root slash\n            segment_before_start >= path_start\n                // Or a windows drive letter slash\n                && !path_starts_with_windows_drive_letter(&serialization[segment_before_start..])\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::log_violation":["fn log_violation(&self, v: SyntaxViolation){\n        if let Some(f) = self.violation_fn {\n            f(v)\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::log_violation_if":["fn log_violation_if(&self, v: SyntaxViolation, test: impl FnOnce() -> bool){\n        if let Some(f) = self.violation_fn {\n            if test() {\n                f(v)\n            }\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_cannot_be_a_base_path":["pub fn parse_cannot_be_a_base_path<'i>(&mut self, mut input: Input<'i>) -> Input<'i>{\n        loop {\n            let input_before_c = input.clone();\n            match input.next_utf8() {\n                Some(('?', _)) | Some(('#', _)) if self.context == Context::UrlParser => {\n                    return input_before_c\n                }\n                Some((c, utf8_c)) => {\n                    self.check_url_code_point(c, &input);\n                    self.serialization\n                        .extend(utf8_percent_encode(utf8_c, CONTROLS));\n                }\n                None => return input,\n            }\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_file":["fn parse_file(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        base_file_url: Option<&Url>,\n    ) -> ParseResult<Url>{\n        use crate::SyntaxViolation::Backslash;\n        // file state\n        debug_assert!(self.serialization.is_empty());\n        let (first_char, input_after_first_char) = input.split_first();\n        if matches!(first_char, Some('/') | Some('\\\\')) {\n            self.log_violation_if(SyntaxViolation::Backslash, || first_char == Some('\\\\'));\n            // file slash state\n            let (next_char, input_after_next_char) = input_after_first_char.split_first();\n            if matches!(next_char, Some('/') | Some('\\\\')) {\n                self.log_violation_if(Backslash, || next_char == Some('\\\\'));\n                // file host state\n                self.serialization.push_str(\"file://\");\n                let scheme_end = \"file\".len() as u32;\n                let host_start = \"file://\".len() as u32;\n                let (path_start, mut host, remaining) =\n                    self.parse_file_host(input_after_next_char)?;\n                let mut host_end = to_u32(self.serialization.len())?;\n                let mut has_host = !matches!(host, HostInternal::None);\n                let remaining = if path_start {\n                    self.parse_path_start(SchemeType::File, &mut has_host, remaining)\n                } else {\n                    let path_start = self.serialization.len();\n                    self.serialization.push('/');\n                    self.parse_path(SchemeType::File, &mut has_host, path_start, remaining)\n                };\n\n                // For file URLs that have a host and whose path starts\n                // with the windows drive letter we just remove the host.\n                if !has_host {\n                    self.serialization\n                        .drain(host_start as usize..host_end as usize);\n                    host_end = host_start;\n                    host = HostInternal::None;\n                }\n                let (query_start, fragment_start) =\n                    self.parse_query_and_fragment(scheme_type, scheme_end, remaining)?;\n                return Ok(Url {\n                    serialization: self.serialization,\n                    scheme_end,\n                    username_end: host_start,\n                    host_start,\n                    host_end,\n                    host,\n                    port: None,\n                    path_start: host_end,\n                    query_start,\n                    fragment_start,\n                });\n            } else {\n                self.serialization.push_str(\"file://\");\n                let scheme_end = \"file\".len() as u32;\n                let host_start = \"file://\".len();\n                let mut host_end = host_start;\n                let mut host = HostInternal::None;\n                if !starts_with_windows_drive_letter_segment(&input_after_first_char) {\n                    if let Some(base_url) = base_file_url {\n                        let first_segment = base_url.path_segments().unwrap().next().unwrap();\n                        if is_normalized_windows_drive_letter(first_segment) {\n                            self.serialization.push('/');\n                            self.serialization.push_str(first_segment);\n                        } else if let Some(host_str) = base_url.host_str() {\n                            self.serialization.push_str(host_str);\n                            host_end = self.serialization.len();\n                            host = base_url.host;\n                        }\n                    }\n                }\n                // If c is the EOF code point, U+002F (/), U+005C (\\), U+003F (?), or U+0023 (#), then decrease pointer by one\n                let parse_path_input = if let Some(c) = first_char {\n                    if c == '/' || c == '\\\\' || c == '?' || c == '#' {\n                        input\n                    } else {\n                        input_after_first_char\n                    }\n                } else {\n                    input_after_first_char\n                };\n\n                let remaining =\n                    self.parse_path(SchemeType::File, &mut false, host_end, parse_path_input);\n\n                let host_start = host_start as u32;\n\n                let (query_start, fragment_start) =\n                    self.parse_query_and_fragment(scheme_type, scheme_end, remaining)?;\n\n                let host_end = host_end as u32;\n                return Ok(Url {\n                    serialization: self.serialization,\n                    scheme_end,\n                    username_end: host_start,\n                    host_start,\n                    host_end,\n                    host,\n                    port: None,\n                    path_start: host_end,\n                    query_start,\n                    fragment_start,\n                });\n            }\n        }\n        if let Some(base_url) = base_file_url {\n            match first_char {\n                None => {\n                    // Copy everything except the fragment\n                    let before_fragment = match base_url.fragment_start {\n                        Some(i) => &base_url.serialization[..i as usize],\n                        None => &*base_url.serialization,\n                    };\n                    self.serialization.push_str(before_fragment);\n                    Ok(Url {\n                        serialization: self.serialization,\n                        fragment_start: None,\n                        ..*base_url\n                    })\n                }\n                Some('?') => {\n                    // Copy everything up to the query string\n                    let before_query = match (base_url.query_start, base_url.fragment_start) {\n                        (None, None) => &*base_url.serialization,\n                        (Some(i), _) | (None, Some(i)) => base_url.slice(..i),\n                    };\n                    self.serialization.push_str(before_query);\n                    let (query_start, fragment_start) =\n                        self.parse_query_and_fragment(scheme_type, base_url.scheme_end, input)?;\n                    Ok(Url {\n                        serialization: self.serialization,\n                        query_start,\n                        fragment_start,\n                        ..*base_url\n                    })\n                }\n                Some('#') => self.fragment_only(base_url, input),\n                _ => {\n                    if !starts_with_windows_drive_letter_segment(&input) {\n                        let before_query = match (base_url.query_start, base_url.fragment_start) {\n                            (None, None) => &*base_url.serialization,\n                            (Some(i), _) | (None, Some(i)) => base_url.slice(..i),\n                        };\n                        self.serialization.push_str(before_query);\n                        self.shorten_path(SchemeType::File, base_url.path_start as usize);\n                        let remaining = self.parse_path(\n                            SchemeType::File,\n                            &mut true,\n                            base_url.path_start as usize,\n                            input,\n                        );\n                        self.with_query_and_fragment(\n                            SchemeType::File,\n                            base_url.scheme_end,\n                            base_url.username_end,\n                            base_url.host_start,\n                            base_url.host_end,\n                            base_url.host,\n                            base_url.port,\n                            base_url.path_start,\n                            remaining,\n                        )\n                    } else {\n                        self.serialization.push_str(\"file:///\");\n                        let scheme_end = \"file\".len() as u32;\n                        let path_start = \"file://\".len();\n                        let remaining =\n                            self.parse_path(SchemeType::File, &mut false, path_start, input);\n                        let (query_start, fragment_start) =\n                            self.parse_query_and_fragment(SchemeType::File, scheme_end, remaining)?;\n                        let path_start = path_start as u32;\n                        Ok(Url {\n                            serialization: self.serialization,\n                            scheme_end,\n                            username_end: path_start,\n                            host_start: path_start,\n                            host_end: path_start,\n                            host: HostInternal::None,\n                            port: None,\n                            path_start,\n                            query_start,\n                            fragment_start,\n                        })\n                    }\n                }\n            }\n        } else {\n            self.serialization.push_str(\"file:///\");\n            let scheme_end = \"file\".len() as u32;\n            let path_start = \"file://\".len();\n            let remaining = self.parse_path(SchemeType::File, &mut false, path_start, input);\n            let (query_start, fragment_start) =\n                self.parse_query_and_fragment(SchemeType::File, scheme_end, remaining)?;\n            let path_start = path_start as u32;\n            Ok(Url {\n                serialization: self.serialization,\n                scheme_end,\n                username_end: path_start,\n                host_start: path_start,\n                host_end: path_start,\n                host: HostInternal::None,\n                port: None,\n                path_start,\n                query_start,\n                fragment_start,\n            })\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_file_host":["fn parse_file_host<'i>(\n        &mut self,\n        input: Input<'i>,\n    ) -> ParseResult<(bool, HostInternal, Input<'i>)>{\n        let has_host;\n        let (_, host_str, remaining) = Parser::file_host(input)?;\n        let host = if host_str.is_empty() {\n            has_host = false;\n            HostInternal::None\n        } else {\n            match Host::parse(&host_str)? {\n                Host::Domain(ref d) if d == \"localhost\" => {\n                    has_host = false;\n                    HostInternal::None\n                }\n                host => {\n                    write!(&mut self.serialization, \"{}\", host).unwrap();\n                    has_host = true;\n                    host.into()\n                }\n            }\n        };\n        Ok((has_host, host, remaining))\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_fragment":["pub fn parse_fragment(&mut self, mut input: Input<'_>){\n        while let Some((c, utf8_c)) = input.next_utf8() {\n            if c == '\\0' {\n                self.log_violation(SyntaxViolation::NullInFragment)\n            } else {\n                self.check_url_code_point(c, &input);\n            }\n            self.serialization\n                .extend(utf8_percent_encode(utf8_c, FRAGMENT));\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_host":["pub fn parse_host(\n        mut input: Input<'_>,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(Host<String>, Input<'_>)>{\n        if scheme_type.is_file() {\n            return Parser::get_file_host(input);\n        }\n        // Undo the Input abstraction here to avoid allocating in the common case\n        // where the host part of the input does not contain any tab or newline\n        let input_str = input.chars.as_str();\n        let mut inside_square_brackets = false;\n        let mut has_ignored_chars = false;\n        let mut non_ignored_chars = 0;\n        let mut bytes = 0;\n        for c in input_str.chars() {\n            match c {\n                ':' if !inside_square_brackets => break,\n                '\\\\' if scheme_type.is_special() => break,\n                '/' | '?' | '#' => break,\n                '\\t' | '\\n' | '\\r' => {\n                    has_ignored_chars = true;\n                }\n                '[' => {\n                    inside_square_brackets = true;\n                    non_ignored_chars += 1\n                }\n                ']' => {\n                    inside_square_brackets = false;\n                    non_ignored_chars += 1\n                }\n                _ => non_ignored_chars += 1,\n            }\n            bytes += c.len_utf8();\n        }\n        let replaced: String;\n        let host_str;\n        {\n            let host_input = input.by_ref().take(non_ignored_chars);\n            if has_ignored_chars {\n                replaced = host_input.collect();\n                host_str = &*replaced\n            } else {\n                for _ in host_input {}\n                host_str = &input_str[..bytes]\n            }\n        }\n        if scheme_type == SchemeType::SpecialNotFile && host_str.is_empty() {\n            return Err(ParseError::EmptyHost);\n        }\n        if !scheme_type.is_special() {\n            let host = Host::parse_opaque(host_str)?;\n            return Ok((host, input));\n        }\n        let host = Host::parse(host_str)?;\n        Ok((host, input))\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_host_and_port":["fn parse_host_and_port<'i>(\n        &mut self,\n        input: Input<'i>,\n        scheme_end: u32,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(u32, HostInternal, Option<u16>, Input<'i>)>{\n        let (host, remaining) = Parser::parse_host(input, scheme_type)?;\n        write!(&mut self.serialization, \"{}\", host).unwrap();\n        let host_end = to_u32(self.serialization.len())?;\n        if let Host::Domain(h) = &host {\n            if h.is_empty() {\n                // Port with an empty host\n                if remaining.starts_with(\":\") {\n                    return Err(ParseError::EmptyHost);\n                }\n                if scheme_type.is_special() {\n                    return Err(ParseError::EmptyHost);\n                }\n            }\n        };\n\n        let (port, remaining) = if let Some(remaining) = remaining.split_prefix(':') {\n            let scheme = || default_port(&self.serialization[..scheme_end as usize]);\n            Parser::parse_port(remaining, scheme, self.context)?\n        } else {\n            (None, remaining)\n        };\n        if let Some(port) = port {\n            write!(&mut self.serialization, \":{}\", port).unwrap()\n        }\n        Ok((host_end, host.into(), port, remaining))\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_non_special":["/// Scheme other than file, http, https, ws, ws, ftp.\nfn parse_non_special(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n    ) -> ParseResult<Url>{\n        // path or authority state (\n        if let Some(input) = input.split_prefix(\"//\") {\n            return self.after_double_slash(input, scheme_type, scheme_end);\n        }\n        // Anarchist URL (no authority)\n        let path_start = to_u32(self.serialization.len())?;\n        let username_end = path_start;\n        let host_start = path_start;\n        let host_end = path_start;\n        let host = HostInternal::None;\n        let port = None;\n        let remaining = if let Some(input) = input.split_prefix('/') {\n            let path_start = self.serialization.len();\n            self.serialization.push('/');\n            self.parse_path(scheme_type, &mut false, path_start, input)\n        } else {\n            self.parse_cannot_be_a_base_path(input)\n        };\n        self.with_query_and_fragment(\n            scheme_type,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            remaining,\n        )\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_path":["pub fn parse_path<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        has_host: &mut bool,\n        path_start: usize,\n        mut input: Input<'i>,\n    ) -> Input<'i>{\n        // Relative path state\n        loop {\n            let segment_start = self.serialization.len();\n            let mut ends_with_slash = false;\n            loop {\n                let input_before_c = input.clone();\n                let (c, utf8_c) = if let Some(x) = input.next_utf8() {\n                    x\n                } else {\n                    break;\n                };\n                match c {\n                    '/' if self.context != Context::PathSegmentSetter => {\n                        self.serialization.push(c);\n                        ends_with_slash = true;\n                        break;\n                    }\n                    '\\\\' if self.context != Context::PathSegmentSetter\n                        && scheme_type.is_special() =>\n                    {\n                        self.log_violation(SyntaxViolation::Backslash);\n                        self.serialization.push('/');\n                        ends_with_slash = true;\n                        break;\n                    }\n                    '?' | '#' if self.context == Context::UrlParser => {\n                        input = input_before_c;\n                        break;\n                    }\n                    _ => {\n                        self.check_url_code_point(c, &input);\n                        if self.context == Context::PathSegmentSetter {\n                            if scheme_type.is_special() {\n                                self.serialization\n                                    .extend(utf8_percent_encode(utf8_c, SPECIAL_PATH_SEGMENT));\n                            } else {\n                                self.serialization\n                                    .extend(utf8_percent_encode(utf8_c, PATH_SEGMENT));\n                            }\n                        } else {\n                            self.serialization.extend(utf8_percent_encode(utf8_c, PATH));\n                        }\n                    }\n                }\n            }\n            // Going from &str to String to &str to please the 1.33.0 borrow checker\n            let before_slash_string = if ends_with_slash {\n                self.serialization[segment_start..self.serialization.len() - 1].to_owned()\n            } else {\n                self.serialization[segment_start..self.serialization.len()].to_owned()\n            };\n            let segment_before_slash: &str = &before_slash_string;\n            match segment_before_slash {\n                // If buffer is a double-dot path segment, shorten url’s path,\n                \"..\" | \"%2e%2e\" | \"%2e%2E\" | \"%2E%2e\" | \"%2E%2E\" | \"%2e.\" | \"%2E.\" | \".%2e\"\n                | \".%2E\" => {\n                    debug_assert!(self.serialization.as_bytes()[segment_start - 1] == b'/');\n                    self.serialization.truncate(segment_start);\n                    if self.serialization.ends_with('/')\n                        && Parser::last_slash_can_be_removed(&self.serialization, path_start)\n                    {\n                        self.serialization.pop();\n                    }\n                    self.shorten_path(scheme_type, path_start);\n\n                    // and then if neither c is U+002F (/), nor url is special and c is U+005C (\\), append the empty string to url’s path.\n                    if ends_with_slash && !self.serialization.ends_with('/') {\n                        self.serialization.push('/');\n                    }\n                }\n                // Otherwise, if buffer is a single-dot path segment and if neither c is U+002F (/),\n                // nor url is special and c is U+005C (\\), append the empty string to url’s path.\n                \".\" | \"%2e\" | \"%2E\" => {\n                    self.serialization.truncate(segment_start);\n                    if !self.serialization.ends_with('/') {\n                        self.serialization.push('/');\n                    }\n                }\n                _ => {\n                    // If url’s scheme is \"file\", url’s path is empty, and buffer is a Windows drive letter, then\n                    if scheme_type.is_file() && is_windows_drive_letter(segment_before_slash) {\n                        // Replace the second code point in buffer with U+003A (:).\n                        if let Some(c) = segment_before_slash.chars().next() {\n                            self.serialization.truncate(segment_start);\n                            self.serialization.push(c);\n                            self.serialization.push(':');\n                            if ends_with_slash {\n                                self.serialization.push('/');\n                            }\n                        }\n                        // If url’s host is neither the empty string nor null,\n                        // validation error, set url’s host to the empty string.\n                        if *has_host {\n                            self.log_violation(SyntaxViolation::FileWithHostAndWindowsDrive);\n                            *has_host = false; // FIXME account for this in callers\n                        }\n                    }\n                }\n            }\n            if !ends_with_slash {\n                break;\n            }\n        }\n        if scheme_type.is_file() {\n            // while url’s path’s size is greater than 1\n            // and url’s path[0] is the empty string,\n            // validation error, remove the first item from url’s path.\n            //FIXME: log violation\n            let path = self.serialization.split_off(path_start);\n            self.serialization.push('/');\n            self.serialization.push_str(&path.trim_start_matches('/'));\n        }\n\n        input\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_path_start":["pub fn parse_path_start<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        has_host: &mut bool,\n        input: Input<'i>,\n    ) -> Input<'i>{\n        let path_start = self.serialization.len();\n        let (maybe_c, remaining) = input.split_first();\n        // If url is special, then:\n        if scheme_type.is_special() {\n            if maybe_c == Some('\\\\') {\n                // If c is U+005C (\\), validation error.\n                self.log_violation(SyntaxViolation::Backslash);\n            }\n            // A special URL always has a non-empty path.\n            if !self.serialization.ends_with('/') {\n                self.serialization.push('/');\n                // We have already made sure the forward slash is present.\n                if maybe_c == Some('/') || maybe_c == Some('\\\\') {\n                    return self.parse_path(scheme_type, has_host, path_start, remaining);\n                }\n            }\n            return self.parse_path(scheme_type, has_host, path_start, input);\n        } else if maybe_c == Some('?') || maybe_c == Some('#') {\n            // Otherwise, if state override is not given and c is U+003F (?),\n            // set url’s query to the empty string and state to query state.\n            // Otherwise, if state override is not given and c is U+0023 (#),\n            // set url’s fragment to the empty string and state to fragment state.\n            // The query and path states will be handled by the caller.\n            return input;\n        }\n\n        if maybe_c != None && maybe_c != Some('/') {\n            self.serialization.push('/');\n        }\n        // Otherwise, if c is not the EOF code point:\n        self.parse_path(scheme_type, has_host, path_start, input)\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_port":["pub fn parse_port<P>(\n        mut input: Input<'_>,\n        default_port: P,\n        context: Context,\n    ) -> ParseResult<(Option<u16>, Input<'_>)>\n    where\n        P: Fn() -> Option<u16>,{\n        let mut port: u32 = 0;\n        let mut has_any_digit = false;\n        while let (Some(c), remaining) = input.split_first() {\n            if let Some(digit) = c.to_digit(10) {\n                port = port * 10 + digit;\n                if port > ::std::u16::MAX as u32 {\n                    return Err(ParseError::InvalidPort);\n                }\n                has_any_digit = true;\n            } else if context == Context::UrlParser && !matches!(c, '/' | '\\\\' | '?' | '#') {\n                return Err(ParseError::InvalidPort);\n            } else {\n                break;\n            }\n            input = remaining;\n        }\n        let mut opt_port = Some(port as u16);\n        if !has_any_digit || opt_port == default_port() {\n            opt_port = None;\n        }\n        Ok((opt_port, input))\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_query":["pub fn parse_query<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        mut input: Input<'i>,\n    ) -> Option<Input<'i>>{\n        let mut query = String::new(); // FIXME: use a streaming decoder instead\n        let mut remaining = None;\n        while let Some(c) = input.next() {\n            if c == '#' && self.context == Context::UrlParser {\n                remaining = Some(input);\n                break;\n            } else {\n                self.check_url_code_point(c, &input);\n                query.push(c);\n            }\n        }\n\n        let encoding = match &self.serialization[..scheme_end as usize] {\n            \"http\" | \"https\" | \"file\" | \"ftp\" => self.query_encoding_override,\n            _ => None,\n        };\n        let query_bytes = if let Some(o) = encoding {\n            o(&query)\n        } else {\n            query.as_bytes().into()\n        };\n        let set = if scheme_type.is_special() {\n            SPECIAL_QUERY\n        } else {\n            QUERY\n        };\n        self.serialization.extend(percent_encode(&query_bytes, set));\n        remaining\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_query_and_fragment":["/// Return (query_start, fragment_start)\nfn parse_query_and_fragment(\n        &mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        mut input: Input<'_>,\n    ) -> ParseResult<(Option<u32>, Option<u32>)>{\n        let mut query_start = None;\n        match input.next() {\n            Some('#') => {}\n            Some('?') => {\n                query_start = Some(to_u32(self.serialization.len())?);\n                self.serialization.push('?');\n                let remaining = self.parse_query(scheme_type, scheme_end, input);\n                if let Some(remaining) = remaining {\n                    input = remaining\n                } else {\n                    return Ok((query_start, None));\n                }\n            }\n            None => return Ok((None, None)),\n            _ => panic!(\"Programming error. parse_query_and_fragment() called without ? or #\"),\n        }\n\n        let fragment_start = to_u32(self.serialization.len())?;\n        self.serialization.push('#');\n        self.parse_fragment(input);\n        Ok((query_start, Some(fragment_start)))\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_relative":["fn parse_relative(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        base_url: &Url,\n    ) -> ParseResult<Url>{\n        // relative state\n        debug_assert!(self.serialization.is_empty());\n        let (first_char, input_after_first_char) = input.split_first();\n        match first_char {\n            None => {\n                // Copy everything except the fragment\n                let before_fragment = match base_url.fragment_start {\n                    Some(i) => &base_url.serialization[..i as usize],\n                    None => &*base_url.serialization,\n                };\n                self.serialization.push_str(before_fragment);\n                Ok(Url {\n                    serialization: self.serialization,\n                    fragment_start: None,\n                    ..*base_url\n                })\n            }\n            Some('?') => {\n                // Copy everything up to the query string\n                let before_query = match (base_url.query_start, base_url.fragment_start) {\n                    (None, None) => &*base_url.serialization,\n                    (Some(i), _) | (None, Some(i)) => base_url.slice(..i),\n                };\n                self.serialization.push_str(before_query);\n                let (query_start, fragment_start) =\n                    self.parse_query_and_fragment(scheme_type, base_url.scheme_end, input)?;\n                Ok(Url {\n                    serialization: self.serialization,\n                    query_start,\n                    fragment_start,\n                    ..*base_url\n                })\n            }\n            Some('#') => self.fragment_only(base_url, input),\n            Some('/') | Some('\\\\') => {\n                let (slashes_count, remaining) = input.count_matching(|c| matches!(c, '/' | '\\\\'));\n                if slashes_count >= 2 {\n                    self.log_violation_if(SyntaxViolation::ExpectedDoubleSlash, || {\n                        input\n                            .clone()\n                            .take_while(|&c| matches!(c, '/' | '\\\\'))\n                            .collect::<String>()\n                            != \"//\"\n                    });\n                    let scheme_end = base_url.scheme_end;\n                    debug_assert!(base_url.byte_at(scheme_end) == b':');\n                    self.serialization\n                        .push_str(base_url.slice(..scheme_end + 1));\n                    if let Some(after_prefix) = input.split_prefix(\"//\") {\n                        return self.after_double_slash(after_prefix, scheme_type, scheme_end);\n                    }\n                    return self.after_double_slash(remaining, scheme_type, scheme_end);\n                }\n                let path_start = base_url.path_start;\n                self.serialization.push_str(base_url.slice(..path_start));\n                self.serialization.push('/');\n                let remaining = self.parse_path(\n                    scheme_type,\n                    &mut true,\n                    path_start as usize,\n                    input_after_first_char,\n                );\n                self.with_query_and_fragment(\n                    scheme_type,\n                    base_url.scheme_end,\n                    base_url.username_end,\n                    base_url.host_start,\n                    base_url.host_end,\n                    base_url.host,\n                    base_url.port,\n                    base_url.path_start,\n                    remaining,\n                )\n            }\n            _ => {\n                let before_query = match (base_url.query_start, base_url.fragment_start) {\n                    (None, None) => &*base_url.serialization,\n                    (Some(i), _) | (None, Some(i)) => base_url.slice(..i),\n                };\n                self.serialization.push_str(before_query);\n                // FIXME spec says just \"remove last entry\", not the \"pop\" algorithm\n                self.pop_path(scheme_type, base_url.path_start as usize);\n                // A special url always has a path.\n                // A path always starts with '/'\n                if self.serialization.len() == base_url.path_start as usize\n                    && (SchemeType::from(base_url.scheme()).is_special() || !input.is_empty())\n                {\n                    self.serialization.push('/');\n                }\n                let remaining = match input.split_first() {\n                    (Some('/'), remaining) => self.parse_path(\n                        scheme_type,\n                        &mut true,\n                        base_url.path_start as usize,\n                        remaining,\n                    ),\n                    _ => {\n                        self.parse_path(scheme_type, &mut true, base_url.path_start as usize, input)\n                    }\n                };\n                self.with_query_and_fragment(\n                    scheme_type,\n                    base_url.scheme_end,\n                    base_url.username_end,\n                    base_url.host_start,\n                    base_url.host_end,\n                    base_url.host,\n                    base_url.port,\n                    base_url.path_start,\n                    remaining,\n                )\n            }\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_scheme":["pub fn parse_scheme<'i>(&mut self, mut input: Input<'i>) -> Result<Input<'i>, ()>{\n        if input.is_empty() || !input.starts_with(ascii_alpha) {\n            return Err(());\n        }\n        debug_assert!(self.serialization.is_empty());\n        while let Some(c) = input.next() {\n            match c {\n                'a'..='z' | 'A'..='Z' | '0'..='9' | '+' | '-' | '.' => {\n                    self.serialization.push(c.to_ascii_lowercase())\n                }\n                ':' => return Ok(input),\n                _ => {\n                    self.serialization.clear();\n                    return Err(());\n                }\n            }\n        }\n        // EOF before ':'\n        if self.context == Context::Setter {\n            Ok(input)\n        } else {\n            self.serialization.clear();\n            Err(())\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_url":["/// https://url.spec.whatwg.org/#concept-basic-url-parser\npub fn parse_url(mut self, input: &str) -> ParseResult<Url>{\n        let input = Input::with_log(input, self.violation_fn);\n        if let Ok(remaining) = self.parse_scheme(input.clone()) {\n            return self.parse_with_scheme(remaining);\n        }\n\n        // No-scheme state\n        if let Some(base_url) = self.base_url {\n            if input.starts_with('#') {\n                self.fragment_only(base_url, input)\n            } else if base_url.cannot_be_a_base() {\n                Err(ParseError::RelativeUrlWithCannotBeABaseBase)\n            } else {\n                let scheme_type = SchemeType::from(base_url.scheme());\n                if scheme_type.is_file() {\n                    self.parse_file(input, scheme_type, Some(base_url))\n                } else {\n                    self.parse_relative(input, scheme_type, base_url)\n                }\n            }\n        } else {\n            Err(ParseError::RelativeUrlWithoutBase)\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_userinfo":["/// Return (username_end, remaining)\nfn parse_userinfo<'i>(\n        &mut self,\n        mut input: Input<'i>,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(u32, Input<'i>)>{\n        let mut last_at = None;\n        let mut remaining = input.clone();\n        let mut char_count = 0;\n        while let Some(c) = remaining.next() {\n            match c {\n                '@' => {\n                    if last_at.is_some() {\n                        self.log_violation(SyntaxViolation::UnencodedAtSign)\n                    } else {\n                        self.log_violation(SyntaxViolation::EmbeddedCredentials)\n                    }\n                    last_at = Some((char_count, remaining.clone()))\n                }\n                '/' | '?' | '#' => break,\n                '\\\\' if scheme_type.is_special() => break,\n                _ => (),\n            }\n            char_count += 1;\n        }\n        let (mut userinfo_char_count, remaining) = match last_at {\n            None => return Ok((to_u32(self.serialization.len())?, input)),\n            Some((0, remaining)) => {\n                // Otherwise, if one of the following is true\n                // c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)\n                // url is special and c is U+005C (\\)\n                // If @ flag is set and buffer is the empty string, validation error, return failure.\n                if let (Some(c), _) = remaining.split_first() {\n                    if c == '/' || c == '?' || c == '#' || (scheme_type.is_special() && c == '\\\\') {\n                        return Err(ParseError::EmptyHost);\n                    }\n                }\n                return Ok((to_u32(self.serialization.len())?, remaining));\n            }\n            Some(x) => x,\n        };\n\n        let mut username_end = None;\n        let mut has_password = false;\n        let mut has_username = false;\n        while userinfo_char_count > 0 {\n            let (c, utf8_c) = input.next_utf8().unwrap();\n            userinfo_char_count -= 1;\n            if c == ':' && username_end.is_none() {\n                // Start parsing password\n                username_end = Some(to_u32(self.serialization.len())?);\n                // We don't add a colon if the password is empty\n                if userinfo_char_count > 0 {\n                    self.serialization.push(':');\n                    has_password = true;\n                }\n            } else {\n                if !has_password {\n                    has_username = true;\n                }\n                self.check_url_code_point(c, &input);\n                self.serialization\n                    .extend(utf8_percent_encode(utf8_c, USERINFO));\n            }\n        }\n        let username_end = match username_end {\n            Some(i) => i,\n            None => to_u32(self.serialization.len())?,\n        };\n        if has_username || has_password {\n            self.serialization.push('@');\n        }\n        Ok((username_end, remaining))\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::parse_with_scheme":["fn parse_with_scheme(mut self, input: Input<'_>) -> ParseResult<Url>{\n        use crate::SyntaxViolation::{ExpectedDoubleSlash, ExpectedFileDoubleSlash};\n        let scheme_end = to_u32(self.serialization.len())?;\n        let scheme_type = SchemeType::from(&self.serialization);\n        self.serialization.push(':');\n        match scheme_type {\n            SchemeType::File => {\n                self.log_violation_if(ExpectedFileDoubleSlash, || !input.starts_with(\"//\"));\n                let base_file_url = self.base_url.and_then(|base| {\n                    if base.scheme() == \"file\" {\n                        Some(base)\n                    } else {\n                        None\n                    }\n                });\n                self.serialization.clear();\n                self.parse_file(input, scheme_type, base_file_url)\n            }\n            SchemeType::SpecialNotFile => {\n                // special relative or authority state\n                let (slashes_count, remaining) = input.count_matching(|c| matches!(c, '/' | '\\\\'));\n                if let Some(base_url) = self.base_url {\n                    if slashes_count < 2\n                        && base_url.scheme() == &self.serialization[..scheme_end as usize]\n                    {\n                        // \"Cannot-be-a-base\" URLs only happen with \"not special\" schemes.\n                        debug_assert!(!base_url.cannot_be_a_base());\n                        self.serialization.clear();\n                        return self.parse_relative(input, scheme_type, base_url);\n                    }\n                }\n                // special authority slashes state\n                self.log_violation_if(ExpectedDoubleSlash, || {\n                    input\n                        .clone()\n                        .take_while(|&c| matches!(c, '/' | '\\\\'))\n                        .collect::<String>()\n                        != \"//\"\n                });\n                self.after_double_slash(remaining, scheme_type, scheme_end)\n            }\n            SchemeType::NotSpecial => self.parse_non_special(input, scheme_type, scheme_end),\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::pop_path":["/// https://url.spec.whatwg.org/#pop-a-urls-path\nfn pop_path(&mut self, scheme_type: SchemeType, path_start: usize){\n        if self.serialization.len() > path_start {\n            let slash_position = self.serialization[path_start..].rfind('/').unwrap();\n            // + 1 since rfind returns the position before the slash.\n            let segment_start = path_start + slash_position + 1;\n            // Don’t pop a Windows drive letter\n            if !(scheme_type.is_file()\n                && is_normalized_windows_drive_letter(&self.serialization[segment_start..]))\n            {\n                self.serialization.truncate(segment_start);\n            }\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::shorten_path":["/// https://url.spec.whatwg.org/#shorten-a-urls-path\nfn shorten_path(&mut self, scheme_type: SchemeType, path_start: usize){\n        // If path is empty, then return.\n        if self.serialization.len() == path_start {\n            return;\n        }\n        // If url’s scheme is \"file\", path’s size is 1, and path[0] is a normalized Windows drive letter, then return.\n        if scheme_type.is_file()\n            && is_normalized_windows_drive_letter(&self.serialization[path_start..])\n        {\n            return;\n        }\n        // Remove path’s last item.\n        self.pop_path(scheme_type, path_start);\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Parser::<'a>::with_query_and_fragment":["#[allow(clippy::too_many_arguments)]\nfn with_query_and_fragment(\n        mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        username_end: u32,\n        host_start: u32,\n        host_end: u32,\n        host: HostInternal,\n        port: Option<u16>,\n        path_start: u32,\n        remaining: Input<'_>,\n    ) -> ParseResult<Url>{\n        let (query_start, fragment_start) =\n            self.parse_query_and_fragment(scheme_type, scheme_end, remaining)?;\n        Ok(Url {\n            serialization: self.serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        })\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::Pattern":["pub trait Pattern {\n    fn split_prefix<'i>(self, input: &mut Input<'i>) -> bool;\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::SchemeType":["pub enum SchemeType {\n    File,\n    SpecialNotFile,\n    NotSpecial,\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::SchemeType::from":["pub fn from(s: &str) -> Self{\n        match s {\n            \"http\" | \"https\" | \"ws\" | \"wss\" | \"ftp\" => SchemeType::SpecialNotFile,\n            \"file\" => SchemeType::File,\n            _ => SchemeType::NotSpecial,\n        }\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::SchemeType::is_file":["pub fn is_file(&self) -> bool{\n        matches!(*self, SchemeType::File)\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::SchemeType::is_special":["pub fn is_special(&self) -> bool{\n        !matches!(*self, SchemeType::NotSpecial)\n    }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::SyntaxViolation":["/// Non-fatal syntax violations that can occur during parsing.\n///\n/// This may be extended in the future so exhaustive matching is\n/// discouraged with an unused variant.\n#[allow(clippy::manual_non_exhaustive)]\npub enum SyntaxViolation {\n            $(\n                $name,\n            )+\n            /// Unused variant enable non-exhaustive matching\n            #[doc(hidden)]\n            __FutureProof,\n        }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::SyntaxViolation::description":["pub fn description(&self) -> &'static str{\n                match *self {\n                    $(\n                        SyntaxViolation::$name => $description,\n                    )+\n                    SyntaxViolation::__FutureProof => {\n                        unreachable!(\"Don't abuse the FutureProof!\");\n                    }\n                }\n            }","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::ascii_alpha":["/// https://url.spec.whatwg.org/#ascii-alpha\n#[inline]\npub fn ascii_alpha(ch: char) -> bool{\n    matches!(ch, 'a'..='z' | 'A'..='Z')\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::ascii_tab_or_new_line":["/// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n#[inline]\nfn ascii_tab_or_new_line(ch: char) -> bool{\n    matches!(ch, '\\t' | '\\r' | '\\n')\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::c0_control_or_space":["/// https://url.spec.whatwg.org/#c0-controls-and-space\n#[inline]\nfn c0_control_or_space(ch: char) -> bool{\n    ch <= ' ' // U+0000 to U+0020\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::default_port":["pub fn default_port(scheme: &str) -> Option<u16>{\n    match scheme {\n        \"http\" | \"ws\" => Some(80),\n        \"https\" | \"wss\" => Some(443),\n        \"ftp\" => Some(21),\n        _ => None,\n    }\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::is_ascii_hex_digit":["#[inline]\nfn is_ascii_hex_digit(c: char) -> bool{\n    matches!(c, 'a'..='f' | 'A'..='F' | '0'..='9')\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::is_normalized_windows_drive_letter":["fn is_normalized_windows_drive_letter(segment: &str) -> bool{\n    is_windows_drive_letter(segment) && segment.as_bytes()[1] == b':'\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::is_url_code_point":["#[inline]\nfn is_url_code_point(c: char) -> bool{\n    matches!(c,\n        'a'..='z' |\n        'A'..='Z' |\n        '0'..='9' |\n        '!' | '$' | '&' | '\\'' | '(' | ')' | '*' | '+' | ',' | '-' |\n        '.' | '/' | ':' | ';' | '=' | '?' | '@' | '_' | '~' |\n        '\\u{A0}'..='\\u{D7FF}' | '\\u{E000}'..='\\u{FDCF}' | '\\u{FDF0}'..='\\u{FFFD}' |\n        '\\u{10000}'..='\\u{1FFFD}' | '\\u{20000}'..='\\u{2FFFD}' |\n        '\\u{30000}'..='\\u{3FFFD}' | '\\u{40000}'..='\\u{4FFFD}' |\n        '\\u{50000}'..='\\u{5FFFD}' | '\\u{60000}'..='\\u{6FFFD}' |\n        '\\u{70000}'..='\\u{7FFFD}' | '\\u{80000}'..='\\u{8FFFD}' |\n        '\\u{90000}'..='\\u{9FFFD}' | '\\u{A0000}'..='\\u{AFFFD}' |\n        '\\u{B0000}'..='\\u{BFFFD}' | '\\u{C0000}'..='\\u{CFFFD}' |\n        '\\u{D0000}'..='\\u{DFFFD}' | '\\u{E1000}'..='\\u{EFFFD}' |\n        '\\u{F0000}'..='\\u{FFFFD}' | '\\u{100000}'..='\\u{10FFFD}')\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::is_windows_drive_letter":["/// Wether the scheme is file:, the path has a single segment, and that segment\n/// is a Windows drive letter\n#[inline]\npub fn is_windows_drive_letter(segment: &str) -> bool{\n    segment.len() == 2 && starts_with_windows_drive_letter(segment)\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::path_starts_with_windows_drive_letter":["/// Wether path starts with a root slash\n/// and a windows drive letter eg: \"/c:\" or \"/a:/\"\nfn path_starts_with_windows_drive_letter(s: &str) -> bool{\n    if let Some(c) = s.as_bytes().get(0) {\n        matches!(c, b'/' | b'\\\\' | b'?' | b'#') && starts_with_windows_drive_letter(&s[1..])\n    } else {\n        false\n    }\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::starts_with_windows_drive_letter":["fn starts_with_windows_drive_letter(s: &str) -> bool{\n    s.len() >= 2\n        && ascii_alpha(s.as_bytes()[0] as char)\n        && matches!(s.as_bytes()[1], b':' | b'|')\n        && (s.len() == 2 || matches!(s.as_bytes()[2], b'/' | b'\\\\' | b'?' | b'#'))\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::starts_with_windows_drive_letter_segment":["/// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter\nfn starts_with_windows_drive_letter_segment(input: &Input<'_>) -> bool{\n    let mut input = input.clone();\n    match (input.next(), input.next(), input.next()) {\n        // its first two code points are a Windows drive letter\n        // its third code point is U+002F (/), U+005C (\\), U+003F (?), or U+0023 (#).\n        (Some(a), Some(b), Some(c))\n            if ascii_alpha(a) && matches!(b, ':' | '|') && matches!(c, '/' | '\\\\' | '?' | '#') =>\n        {\n            true\n        }\n        // its first two code points are a Windows drive letter\n        // its length is 2\n        (Some(a), Some(b), None) if ascii_alpha(a) && matches!(b, ':' | '|') => true,\n        _ => false,\n    }\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"parser::to_u32":["#[inline]\npub fn to_u32(i: usize) -> ParseResult<u32>{\n    if i <= ::std::u32::MAX as usize {\n        Ok(i as u32)\n    } else {\n        Err(ParseError::Overflow)\n    }\n}","Real(LocalPath(\"url/src/parser.rs\"))"],"path_segments::PathSegmentsMut":["/// Exposes methods to manipulate the path of an URL that is not cannot-be-base.\n///\n/// The path always starts with a `/` slash, and is made of slash-separated segments.\n/// There is always at least one segment (which may be the empty string).\n///\n/// Examples:\n///\n/// ```rust\n/// use url::Url;\n/// # use std::error::Error;\n///\n/// # fn run() -> Result<(), Box<dyn Error>> {\n/// let mut url = Url::parse(\"mailto:me@example.com\")?;\n/// assert!(url.path_segments_mut().is_err());\n///\n/// let mut url = Url::parse(\"http://example.net/foo/index.html\")?;\n/// url.path_segments_mut().map_err(|_| \"cannot be base\")?\n///     .pop().push(\"img\").push(\"2/100%.png\");\n/// assert_eq!(url.as_str(), \"http://example.net/foo/img/2%2F100%25.png\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub struct PathSegmentsMut<'a> {\n    url: &'a mut Url,\n    after_first_slash: usize,\n    after_path: String,\n    old_after_path_position: u32,\n}","Real(LocalPath(\"url/src/path_segments.rs\"))"],"path_segments::PathSegmentsMut::<'a>::clear":["/// Remove all segments in the path, leaving the minimal `url.path() == \"/\"`.\n///\n/// Returns `&mut Self` so that method calls can be chained.\n///\n/// Example:\n///\n/// ```rust\n/// use url::Url;\n/// # use std::error::Error;\n///\n/// # fn run() -> Result<(), Box<dyn Error>> {\n/// let mut url = Url::parse(\"https://github.com/servo/rust-url/\")?;\n/// url.path_segments_mut().map_err(|_| \"cannot be base\")?\n///     .clear().push(\"logout\");\n/// assert_eq!(url.as_str(), \"https://github.com/logout\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn clear(&mut self) -> &mut Self{\n        self.url.serialization.truncate(self.after_first_slash);\n        self\n    }","Real(LocalPath(\"url/src/path_segments.rs\"))"],"path_segments::PathSegmentsMut::<'a>::extend":["/// Append each segment from the given iterator at the end of this URL’s path.\n///\n/// Each segment is percent-encoded like in `Url::parse` or `Url::join`,\n/// except that `%` and `/` characters are also encoded (to `%25` and `%2F`).\n/// This is unlike `Url::parse` where `%` is left as-is in case some of the input\n/// is already percent-encoded, and `/` denotes a path segment separator.)\n///\n/// Note that, in addition to slashes between new segments,\n/// this always adds a slash between the existing path and the new segments\n/// *except* if the existing path is `\"/\"`.\n/// If the previous last segment was empty (if the path had a trailing slash)\n/// the path after `.extend()` will contain two consecutive slashes.\n/// If that is undesired, call `.pop_if_empty()` first.\n///\n/// To obtain a behavior similar to `Url::join`, call `.pop()` unconditionally first.\n///\n/// Returns `&mut Self` so that method calls can be chained.\n///\n/// Example:\n///\n/// ```rust\n/// use url::Url;\n/// # use std::error::Error;\n///\n/// # fn run() -> Result<(), Box<dyn Error>> {\n/// let mut url = Url::parse(\"https://github.com/\")?;\n/// let org = \"servo\";\n/// let repo = \"rust-url\";\n/// let issue_number = \"188\";\n/// url.path_segments_mut().map_err(|_| \"cannot be base\")?\n///     .extend(&[org, repo, \"issues\", issue_number]);\n/// assert_eq!(url.as_str(), \"https://github.com/servo/rust-url/issues/188\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// In order to make sure that parsing the serialization of an URL gives the same URL,\n/// a segment is ignored if it is `\".\"` or `\"..\"`:\n///\n/// ```rust\n/// use url::Url;\n/// # use std::error::Error;\n///\n/// # fn run() -> Result<(), Box<dyn Error>> {\n/// let mut url = Url::parse(\"https://github.com/servo\")?;\n/// url.path_segments_mut().map_err(|_| \"cannot be base\")?\n///     .extend(&[\"..\", \"rust-url\", \".\", \"pulls\"]);\n/// assert_eq!(url.as_str(), \"https://github.com/servo/rust-url/pulls\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn extend<I>(&mut self, segments: I) -> &mut Self\n    where\n        I: IntoIterator,\n        I::Item: AsRef<str>,{\n        let scheme_type = SchemeType::from(self.url.scheme());\n        let path_start = self.url.path_start as usize;\n        self.url.mutate(|parser| {\n            parser.context = parser::Context::PathSegmentSetter;\n            for segment in segments {\n                let segment = segment.as_ref();\n                if matches!(segment, \".\" | \"..\") {\n                    continue;\n                }\n                if parser.serialization.len() > path_start + 1\n                    // Non special url's path might still be empty\n                    || parser.serialization.len() == path_start\n                {\n                    parser.serialization.push('/');\n                }\n                let mut has_host = true; // FIXME account for this?\n                parser.parse_path(\n                    scheme_type,\n                    &mut has_host,\n                    path_start,\n                    parser::Input::new(segment),\n                );\n            }\n        });\n        self\n    }","Real(LocalPath(\"url/src/path_segments.rs\"))"],"path_segments::PathSegmentsMut::<'a>::pop":["/// Remove the last segment of this URL’s path.\n///\n/// If the path only has one segment, make it empty such that `url.path() == \"/\"`.\n///\n/// Returns `&mut Self` so that method calls can be chained.\npub fn pop(&mut self) -> &mut Self{\n        let last_slash = self.url.serialization[self.after_first_slash..]\n            .rfind('/')\n            .unwrap_or(0);\n        self.url\n            .serialization\n            .truncate(self.after_first_slash + last_slash);\n        self\n    }","Real(LocalPath(\"url/src/path_segments.rs\"))"],"path_segments::PathSegmentsMut::<'a>::pop_if_empty":["/// Remove the last segment of this URL’s path if it is empty,\n/// except if these was only one segment to begin with.\n///\n/// In other words, remove one path trailing slash, if any,\n/// unless it is also the initial slash (so this does nothing if `url.path() == \"/\")`.\n///\n/// Returns `&mut Self` so that method calls can be chained.\n///\n/// Example:\n///\n/// ```rust\n/// use url::Url;\n/// # use std::error::Error;\n///\n/// # fn run() -> Result<(), Box<dyn Error>> {\n/// let mut url = Url::parse(\"https://github.com/servo/rust-url/\")?;\n/// url.path_segments_mut().map_err(|_| \"cannot be base\")?\n///     .push(\"pulls\");\n/// assert_eq!(url.as_str(), \"https://github.com/servo/rust-url//pulls\");\n///\n/// let mut url = Url::parse(\"https://github.com/servo/rust-url/\")?;\n/// url.path_segments_mut().map_err(|_| \"cannot be base\")?\n///     .pop_if_empty().push(\"pulls\");\n/// assert_eq!(url.as_str(), \"https://github.com/servo/rust-url/pulls\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\npub fn pop_if_empty(&mut self) -> &mut Self{\n        if self.url.serialization[self.after_first_slash..].ends_with('/') {\n            self.url.serialization.pop();\n        }\n        self\n    }","Real(LocalPath(\"url/src/path_segments.rs\"))"],"path_segments::PathSegmentsMut::<'a>::push":["/// Append the given segment at the end of this URL’s path.\n///\n/// See the documentation for `.extend()`.\n///\n/// Returns `&mut Self` so that method calls can be chained.\npub fn push(&mut self, segment: &str) -> &mut Self{\n        self.extend(Some(segment))\n    }","Real(LocalPath(\"url/src/path_segments.rs\"))"],"path_segments::new":["pub fn new(url: &mut Url) -> PathSegmentsMut<'_>{\n    let after_path = url.take_after_path();\n    let old_after_path_position = to_u32(url.serialization.len()).unwrap();\n    // Special urls always have a non empty path\n    if SchemeType::from(url.scheme()).is_special() {\n        debug_assert!(url.byte_at(url.path_start) == b'/');\n    } else {\n        debug_assert!(\n            url.serialization.len() == url.path_start as usize\n                || url.byte_at(url.path_start) == b'/'\n        );\n    }\n    PathSegmentsMut {\n        after_first_slash: url.path_start as usize + \"/\".len(),\n        url,\n        old_after_path_position,\n        after_path,\n    }\n}","Real(LocalPath(\"url/src/path_segments.rs\"))"],"path_to_file_url_segments":["#[cfg(any(unix, target_os = \"redox\"))]\nfn path_to_file_url_segments(\n    path: &Path,\n    serialization: &mut String,\n) -> Result<(u32, HostInternal), ()>{\n    use std::os::unix::prelude::OsStrExt;\n    if !path.is_absolute() {\n        return Err(());\n    }\n    let host_end = to_u32(serialization.len()).unwrap();\n    let mut empty = true;\n    // skip the root component\n    for component in path.components().skip(1) {\n        empty = false;\n        serialization.push('/');\n        serialization.extend(percent_encode(\n            component.as_os_str().as_bytes(),\n            PATH_SEGMENT,\n        ));\n    }\n    if empty {\n        // An URL’s path must not be empty.\n        serialization.push('/');\n    }\n    Ok((host_end, HostInternal::None))\n}","Real(LocalPath(\"url/src/lib.rs\"))"],"path_to_file_url_segments_windows":["allow(dead_code)\nfn path_to_file_url_segments_windows(\n    path: &Path,\n    serialization: &mut String,\n) -> Result<(u32, HostInternal), ()>{\n    use std::path::{Component, Prefix};\n    if !path.is_absolute() {\n        return Err(());\n    }\n    let mut components = path.components();\n\n    let host_start = serialization.len() + 1;\n    let host_end;\n    let host_internal;\n    match components.next() {\n        Some(Component::Prefix(ref p)) => match p.kind() {\n            Prefix::Disk(letter) | Prefix::VerbatimDisk(letter) => {\n                host_end = to_u32(serialization.len()).unwrap();\n                host_internal = HostInternal::None;\n                serialization.push('/');\n                serialization.push(letter as char);\n                serialization.push(':');\n            }\n            Prefix::UNC(server, share) | Prefix::VerbatimUNC(server, share) => {\n                let host = Host::parse(server.to_str().ok_or(())?).map_err(|_| ())?;\n                write!(serialization, \"{}\", host).unwrap();\n                host_end = to_u32(serialization.len()).unwrap();\n                host_internal = host.into();\n                serialization.push('/');\n                let share = share.to_str().ok_or(())?;\n                serialization.extend(percent_encode(share.as_bytes(), PATH_SEGMENT));\n            }\n            _ => return Err(()),\n        },\n\n        _ => return Err(()),\n    }\n\n    let mut path_only_has_prefix = true;\n    for component in components {\n        if component == Component::RootDir {\n            continue;\n        }\n        path_only_has_prefix = false;\n        // FIXME: somehow work with non-unicode?\n        let component = component.as_os_str().to_str().ok_or(())?;\n        serialization.push('/');\n        serialization.extend(percent_encode(component.as_bytes(), PATH_SEGMENT));\n    }\n    // A windows drive letter must end with a slash.\n    if serialization.len() > host_start\n        && parser::is_windows_drive_letter(&serialization[host_start..])\n        && path_only_has_prefix\n    {\n        serialization.push('/');\n    }\n    Ok((host_end, host_internal))\n}","Real(LocalPath(\"url/src/lib.rs\"))"],"quirks::domain_to_ascii":["/// https://url.spec.whatwg.org/#dom-url-domaintoascii\npub fn domain_to_ascii(domain: &str) -> String{\n    match Host::parse(domain) {\n        Ok(Host::Domain(domain)) => domain,\n        _ => String::new(),\n    }\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::domain_to_unicode":["/// https://url.spec.whatwg.org/#dom-url-domaintounicode\npub fn domain_to_unicode(domain: &str) -> String{\n    match Host::parse(domain) {\n        Ok(Host::Domain(ref domain)) => {\n            let (unicode, _errors) = idna::domain_to_unicode(domain);\n            unicode\n        }\n        _ => String::new(),\n    }\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::hash":["/// Getter for https://url.spec.whatwg.org/#dom-url-hash\npub fn hash(url: &Url) -> &str{\n    trim(&url[Position::AfterQuery..])\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::host":["/// Getter for https://url.spec.whatwg.org/#dom-url-host\n#[inline]\npub fn host(url: &Url) -> &str{\n    &url[Position::BeforeHost..Position::AfterPort]\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::hostname":["/// Getter for https://url.spec.whatwg.org/#dom-url-hostname\n#[inline]\npub fn hostname(url: &Url) -> &str{\n    url.host_str().unwrap_or(\"\")\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::href":["/// Getter for https://url.spec.whatwg.org/#dom-url-href\npub fn href(url: &Url) -> &str{\n    url.as_str()\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::origin":["/// Getter for https://url.spec.whatwg.org/#dom-url-origin\npub fn origin(url: &Url) -> String{\n    url.origin().ascii_serialization()\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::password":["/// Getter for https://url.spec.whatwg.org/#dom-url-password\n#[inline]\npub fn password(url: &Url) -> &str{\n    url.password().unwrap_or(\"\")\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::pathname":["/// Getter for https://url.spec.whatwg.org/#dom-url-pathname\n#[inline]\npub fn pathname(url: &Url) -> &str{\n    url.path()\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::port":["/// Getter for https://url.spec.whatwg.org/#dom-url-port\n#[inline]\npub fn port(url: &Url) -> &str{\n    &url[Position::BeforePort..Position::AfterPort]\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::protocol":["/// Getter for https://url.spec.whatwg.org/#dom-url-protocol\n#[inline]\npub fn protocol(url: &Url) -> &str{\n    &url.as_str()[..url.scheme().len() + \":\".len()]\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::search":["/// Getter for https://url.spec.whatwg.org/#dom-url-search\npub fn search(url: &Url) -> &str{\n    trim(&url[Position::AfterPath..Position::AfterQuery])\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::set_hash":["/// Setter for https://url.spec.whatwg.org/#dom-url-hash\npub fn set_hash(url: &mut Url, new_hash: &str){\n    url.set_fragment(match new_hash {\n        // If the given value is the empty string,\n        // then set context object’s url’s fragment to null and return.\n        \"\" => None,\n        // Let input be the given value with a single leading U+0023 (#) removed, if any.\n        _ if new_hash.starts_with('#') => Some(&new_hash[1..]),\n        _ => Some(new_hash),\n    })\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::set_host":["/// Setter for https://url.spec.whatwg.org/#dom-url-host\npub fn set_host(url: &mut Url, new_host: &str) -> Result<(), ()>{\n    // If context object’s url’s cannot-be-a-base-URL flag is set, then return.\n    if url.cannot_be_a_base() {\n        return Err(());\n    }\n    // Host parsing rules are strict,\n    // We don't want to trim the input\n    let input = Input::no_trim(new_host);\n    let host;\n    let opt_port;\n    {\n        let scheme = url.scheme();\n        let scheme_type = SchemeType::from(scheme);\n        if scheme_type == SchemeType::File && new_host.is_empty() {\n            url.set_host_internal(Host::Domain(String::new()), None);\n            return Ok(());\n        }\n\n        if let Ok((h, remaining)) = Parser::parse_host(input, scheme_type) {\n            host = h;\n            opt_port = if let Some(remaining) = remaining.split_prefix(':') {\n                if remaining.is_empty() {\n                    None\n                } else {\n                    Parser::parse_port(remaining, || default_port(scheme), Context::Setter)\n                        .ok()\n                        .map(|(port, _remaining)| port)\n                }\n            } else {\n                None\n            };\n        } else {\n            return Err(());\n        }\n    }\n    // Make sure we won't set an empty host to a url with a username or a port\n    if host == Host::Domain(\"\".to_string()) {\n        if !username(&url).is_empty() {\n            return Err(());\n        } else if let Some(Some(_)) = opt_port {\n            return Err(());\n        } else if url.port().is_some() {\n            return Err(());\n        }\n    }\n    url.set_host_internal(host, opt_port);\n    Ok(())\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::set_hostname":["/// Setter for https://url.spec.whatwg.org/#dom-url-hostname\npub fn set_hostname(url: &mut Url, new_hostname: &str) -> Result<(), ()>{\n    if url.cannot_be_a_base() {\n        return Err(());\n    }\n    // Host parsing rules are strict we don't want to trim the input\n    let input = Input::no_trim(new_hostname);\n    let scheme_type = SchemeType::from(url.scheme());\n    if scheme_type == SchemeType::File && new_hostname.is_empty() {\n        url.set_host_internal(Host::Domain(String::new()), None);\n        return Ok(());\n    }\n\n    if let Ok((host, _remaining)) = Parser::parse_host(input, scheme_type) {\n        if let Host::Domain(h) = &host {\n            if h.is_empty() {\n                // Empty host on special not file url\n                if SchemeType::from(url.scheme()) == SchemeType::SpecialNotFile\n                    // Port with an empty host\n                    ||!port(&url).is_empty()\n                    // Empty host that includes credentials\n                    || !url.username().is_empty()\n                    || !url.password().unwrap_or(&\"\").is_empty()\n                {\n                    return Err(());\n                }\n            }\n        }\n        url.set_host_internal(host, None);\n        Ok(())\n    } else {\n        Err(())\n    }\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::set_href":["/// Setter for https://url.spec.whatwg.org/#dom-url-href\npub fn set_href(url: &mut Url, value: &str) -> Result<(), ParseError>{\n    *url = Url::parse(value)?;\n    Ok(())\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::set_password":["/// Setter for https://url.spec.whatwg.org/#dom-url-password\npub fn set_password(url: &mut Url, new_password: &str) -> Result<(), ()>{\n    url.set_password(if new_password.is_empty() {\n        None\n    } else {\n        Some(new_password)\n    })\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::set_pathname":["/// Setter for https://url.spec.whatwg.org/#dom-url-pathname\npub fn set_pathname(url: &mut Url, new_pathname: &str){\n    if url.cannot_be_a_base() {\n        return;\n    }\n    if new_pathname.starts_with('/')\n        || (SchemeType::from(url.scheme()).is_special()\n            // \\ is a segment delimiter for 'special' URLs\"\n            && new_pathname.starts_with('\\\\'))\n    {\n        url.set_path(new_pathname)\n    } else {\n        let mut path_to_set = String::from(\"/\");\n        path_to_set.push_str(new_pathname);\n        url.set_path(&path_to_set)\n    }\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::set_port":["/// Setter for https://url.spec.whatwg.org/#dom-url-port\npub fn set_port(url: &mut Url, new_port: &str) -> Result<(), ()>{\n    let result;\n    {\n        // has_host implies !cannot_be_a_base\n        let scheme = url.scheme();\n        if !url.has_host() || url.host() == Some(Host::Domain(\"\")) || scheme == \"file\" {\n            return Err(());\n        }\n        result = Parser::parse_port(\n            Input::new(new_port),\n            || default_port(scheme),\n            Context::Setter,\n        )\n    }\n    if let Ok((new_port, _remaining)) = result {\n        url.set_port_internal(new_port);\n        Ok(())\n    } else {\n        Err(())\n    }\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::set_protocol":["/// Setter for https://url.spec.whatwg.org/#dom-url-protocol\npub fn set_protocol(url: &mut Url, mut new_protocol: &str) -> Result<(), ()>{\n    // The scheme state in the spec ignores everything after the first `:`,\n    // but `set_scheme` errors if there is more.\n    if let Some(position) = new_protocol.find(':') {\n        new_protocol = &new_protocol[..position];\n    }\n    url.set_scheme(new_protocol)\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::set_search":["/// Setter for https://url.spec.whatwg.org/#dom-url-search\npub fn set_search(url: &mut Url, new_search: &str){\n    url.set_query(match new_search {\n        \"\" => None,\n        _ if new_search.starts_with('?') => Some(&new_search[1..]),\n        _ => Some(new_search),\n    })\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::set_username":["/// Setter for https://url.spec.whatwg.org/#dom-url-username\npub fn set_username(url: &mut Url, new_username: &str) -> Result<(), ()>{\n    url.set_username(new_username)\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::trim":["fn trim(s: &str) -> &str{\n    if s.len() == 1 {\n        \"\"\n    } else {\n        s\n    }\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"quirks::username":["/// Getter for https://url.spec.whatwg.org/#dom-url-username\n#[inline]\npub fn username(url: &Url) -> &str{\n    url.username()\n}","Real(LocalPath(\"url/src/quirks.rs\"))"],"slicing::<impl Url>::index":["#[inline]\nfn index(&self, position: Position) -> usize{\n        match position {\n            Position::BeforeScheme => 0,\n\n            Position::AfterScheme => self.scheme_end as usize,\n\n            Position::BeforeUsername => {\n                if self.has_authority() {\n                    self.scheme_end as usize + \"://\".len()\n                } else {\n                    debug_assert!(self.byte_at(self.scheme_end) == b':');\n                    debug_assert!(self.scheme_end + \":\".len() as u32 == self.username_end);\n                    self.scheme_end as usize + \":\".len()\n                }\n            }\n\n            Position::AfterUsername => self.username_end as usize,\n\n            Position::BeforePassword => {\n                if self.has_authority() && self.byte_at(self.username_end) == b':' {\n                    self.username_end as usize + \":\".len()\n                } else {\n                    debug_assert!(self.username_end == self.host_start);\n                    self.username_end as usize\n                }\n            }\n\n            Position::AfterPassword => {\n                if self.has_authority() && self.byte_at(self.username_end) == b':' {\n                    debug_assert!(self.byte_at(self.host_start - \"@\".len() as u32) == b'@');\n                    self.host_start as usize - \"@\".len()\n                } else {\n                    debug_assert!(self.username_end == self.host_start);\n                    self.host_start as usize\n                }\n            }\n\n            Position::BeforeHost => self.host_start as usize,\n\n            Position::AfterHost => self.host_end as usize,\n\n            Position::BeforePort => {\n                if self.port.is_some() {\n                    debug_assert!(self.byte_at(self.host_end) == b':');\n                    self.host_end as usize + \":\".len()\n                } else {\n                    self.host_end as usize\n                }\n            }\n\n            Position::AfterPort => self.path_start as usize,\n\n            Position::BeforePath => self.path_start as usize,\n\n            Position::AfterPath => match (self.query_start, self.fragment_start) {\n                (Some(q), _) => q as usize,\n                (None, Some(f)) => f as usize,\n                (None, None) => self.serialization.len(),\n            },\n\n            Position::BeforeQuery => match (self.query_start, self.fragment_start) {\n                (Some(q), _) => {\n                    debug_assert!(self.byte_at(q) == b'?');\n                    q as usize + \"?\".len()\n                }\n                (None, Some(f)) => f as usize,\n                (None, None) => self.serialization.len(),\n            },\n\n            Position::AfterQuery => match self.fragment_start {\n                None => self.serialization.len(),\n                Some(f) => f as usize,\n            },\n\n            Position::BeforeFragment => match self.fragment_start {\n                Some(f) => {\n                    debug_assert!(self.byte_at(f) == b'#');\n                    f as usize + \"#\".len()\n                }\n                None => self.serialization.len(),\n            },\n\n            Position::AfterFragment => self.serialization.len(),\n        }\n    }","Real(LocalPath(\"url/src/slicing.rs\"))"],"slicing::<impl std::ops::Index<std::ops::Range<slicing::Position>> for Url>::index":["fn index(&self, range: Range<Position>) -> &str{\n        &self.serialization[self.index(range.start)..self.index(range.end)]\n    }","Real(LocalPath(\"url/src/slicing.rs\"))"],"slicing::<impl std::ops::Index<std::ops::RangeFrom<slicing::Position>> for Url>::index":["fn index(&self, range: RangeFrom<Position>) -> &str{\n        &self.serialization[self.index(range.start)..]\n    }","Real(LocalPath(\"url/src/slicing.rs\"))"],"slicing::<impl std::ops::Index<std::ops::RangeFull> for Url>::index":["fn index(&self, _: RangeFull) -> &str{\n        &self.serialization\n    }","Real(LocalPath(\"url/src/slicing.rs\"))"],"slicing::<impl std::ops::Index<std::ops::RangeTo<slicing::Position>> for Url>::index":["fn index(&self, range: RangeTo<Position>) -> &str{\n        &self.serialization[..self.index(range.end)]\n    }","Real(LocalPath(\"url/src/slicing.rs\"))"],"slicing::Position":["/// Indicates a position within a URL based on its components.\n///\n/// A range of positions can be used for slicing `Url`:\n///\n/// ```rust\n/// # use url::{Url, Position};\n/// # fn something(some_url: Url) {\n/// let serialization: &str = &some_url[..];\n/// let serialization_without_fragment: &str = &some_url[..Position::AfterQuery];\n/// let authority: &str = &some_url[Position::BeforeUsername..Position::AfterPort];\n/// let data_url_payload: &str = &some_url[Position::BeforePath..Position::AfterQuery];\n/// let scheme_relative: &str = &some_url[Position::BeforeUsername..];\n/// # }\n/// ```\n///\n/// In a pseudo-grammar (where `[`…`]?` makes a sub-sequence optional),\n/// URL components and delimiters that separate them are:\n///\n/// ```notrust\n/// url =\n///     scheme \":\"\n///     [ \"//\" [ username [ \":\" password ]? \"@\" ]? host [ \":\" port ]? ]?\n///     path [ \"?\" query ]? [ \"#\" fragment ]?\n/// ```\n///\n/// When a given component is not present,\n/// its \"before\" and \"after\" position are the same\n/// (so that `&some_url[BeforeFoo..AfterFoo]` is the empty string)\n/// and component ordering is preserved\n/// (so that a missing query \"is between\" a path and a fragment).\n///\n/// The end of a component and the start of the next are either the same or separate\n/// by a delimiter.\n/// (Not that the initial `/` of a path is considered part of the path here, not a delimiter.)\n/// For example, `&url[..BeforeFragment]` would include a `#` delimiter (if present in `url`),\n/// so `&url[..AfterQuery]` might be desired instead.\n///\n/// `BeforeScheme` and `AfterFragment` are always the start and end of the entire URL,\n/// so `&url[BeforeScheme..X]` is the same as `&url[..X]`\n/// and `&url[X..AfterFragment]` is the same as `&url[X..]`.\npub enum Position {\n    BeforeScheme,\n    AfterScheme,\n    BeforeUsername,\n    AfterUsername,\n    BeforePassword,\n    AfterPassword,\n    BeforeHost,\n    AfterHost,\n    BeforePort,\n    AfterPort,\n    BeforePath,\n    AfterPath,\n    BeforeQuery,\n    AfterQuery,\n    BeforeFragment,\n    AfterFragment,\n}","Real(LocalPath(\"url/src/slicing.rs\"))"]},"struct_constructor":{"&'a mut Url":["finish"],"&'static str":["description"],"&mut std::string::String":["as_mut_string"],"&str":["as_ref","as_str","domain","fragment","hash","host","host_str","hostname","href","index","password","path","pathname","port","protocol","query","scheme","search","slice","username"],"(bool, host::HostInternal, parser::Input<'i>)":["parse_file_host"],"(bool, std::string::String, parser::Input<'i>)":["file_host"],"(char, &'i str)":["next_utf8"],"(host::Host, parser::Input<'_>)":["get_file_host","parse_host"],"(isize, isize)":["longest_zero_sequence"],"(std::option::Option<char>, parser::Input<'i>)":["split_first"],"(std::option::Option<u16>, parser::Input<'_>)":["parse_port"],"(std::option::Option<u32>, std::option::Option<u32>)":["parse_query_and_fragment"],"(u32, host::HostInternal)":["path_to_file_url_segments","path_to_file_url_segments_windows"],"(u32, host::HostInternal, std::option::Option<u16>, parser::Input<'i>)":["parse_host_and_port"],"(u32, parser::Input<'i>)":["count_matching","parse_userinfo"],"ParseOptions":["clone","options"],"Url":["after_double_slash","clone","fragment_only","from_directory_path","from_file_path","from_str","join","parse","parse_file","parse_non_special","parse_relative","parse_url","parse_with_params","parse_with_scheme","try_from","with_query_and_fragment"],"bool":["ascii_alpha","ascii_tab_or_new_line","c0_control_or_space","cannot_be_a_base","eq","has_authority","has_host","is_ascii_hex_digit","is_empty","is_file","is_normalized_windows_drive_letter","is_special","is_tuple","is_url_code_point","is_windows_drive_letter","last_slash_can_be_removed","path_starts_with_windows_drive_letter","split_prefix","starts_with","starts_with_windows_drive_letter","starts_with_windows_drive_letter_segment"],"char":["next"],"form_urlencoded::Parse":["query_pairs"],"form_urlencoded::Serializer":["query_pairs_mut"],"host::Host":["clone","host","parse","parse_opaque","to_owned"],"host::HostInternal":["clone","from"],"origin::OpaqueOrigin":["clone"],"origin::Origin":["clone","new_opaque","origin","url_origin"],"parser::Context":["clone"],"parser::Input":["clone","new","no_trim","split_prefix","trim_tab_and_newlines","with_log"],"parser::ParseError":["clone","from"],"parser::Parser":["for_setter"],"parser::SchemeType":["clone","from"],"parser::SyntaxViolation":["clone"],"path_segments::PathSegmentsMut":["new","path_segments_mut"],"slicing::Position":["clone"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::net::Ipv4Addr":["parse_ipv4addr"],"std::net::Ipv6Addr":["parse_ipv6addr"],"std::path::PathBuf":["file_url_segments_to_pathbuf","file_url_segments_to_pathbuf_windows","to_file_path"],"std::str::Split":["path_segments"],"std::string::String":["ascii_serialization","domain_to_ascii","domain_to_unicode","into_string","origin","take_after_path","take_fragment","unicode_serialization"],"std::vec::Vec":["socket_addrs"],"u16":["default_port","port","port_or_known_default"],"u32":["parse_ipv4number","to_u32"],"u8":["byte_at"],"usize":["index"]},"struct_to_trait":{"<F as parser::Pattern>::F":["parser::Pattern"],"ParseOptions":["std::clone::Clone","std::marker::Copy"],"Url":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::TryFrom","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::ops::Index","std::str::FromStr"],"UrlQuery":["form_urlencoded::Target","std::fmt::Debug","std::ops::Drop"],"host::Host":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"host::HostInternal":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"origin::OpaqueOrigin":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"origin::Origin":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"parser::Context":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"parser::Input":["std::clone::Clone","std::iter::Iterator"],"parser::ParseError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"parser::SchemeType":["std::clone::Clone","std::cmp::PartialEq","std::marker::Copy","std::marker::StructuralPartialEq"],"parser::SyntaxViolation":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"path_segments::PathSegmentsMut":["std::fmt::Debug","std::ops::Drop"],"slicing::Position":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"std::ops::Range":["RangeArg"],"std::ops::RangeFrom":["RangeArg"],"std::ops::RangeTo":["RangeArg"]},"targets":{"<&'a str as parser::Pattern>::split_prefix":["split_prefix","Real(LocalPath(\"url/src/parser.rs\"))","parser::Pattern"],"<F as parser::Pattern>::split_prefix":["split_prefix","Real(LocalPath(\"url/src/parser.rs\"))","parser::Pattern"],"<Url as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"url/src/lib.rs\"))","std::cmp::Ord"],"<Url as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"url/src/lib.rs\"))","std::cmp::PartialEq"],"<Url as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"url/src/lib.rs\"))","std::cmp::PartialOrd"],"<Url as std::convert::AsRef<str>>::as_ref":["as_ref","Real(LocalPath(\"url/src/lib.rs\"))","std::convert::AsRef"],"<Url as std::convert::TryFrom<&'a str>>::try_from":["try_from","Real(LocalPath(\"url/src/lib.rs\"))","std::convert::TryFrom"],"<Url as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"url/src/lib.rs\"))","std::fmt::Debug"],"<Url as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"url/src/lib.rs\"))","std::fmt::Display"],"<Url as std::hash::Hash>::hash":["hash","Real(LocalPath(\"url/src/lib.rs\"))","std::hash::Hash"],"<Url as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"url/src/lib.rs\"))","std::str::FromStr"],"<UrlQuery<'a> as form_urlencoded::Target>::as_mut_string":["as_mut_string","Real(LocalPath(\"url/src/lib.rs\"))","form_urlencoded::Target"],"<UrlQuery<'a> as form_urlencoded::Target>::finish":["finish","Real(LocalPath(\"url/src/lib.rs\"))","form_urlencoded::Target"],"<UrlQuery<'a> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"url/src/lib.rs\"))","std::ops::Drop"],"<char as parser::Pattern>::split_prefix":["split_prefix","Real(LocalPath(\"url/src/parser.rs\"))","parser::Pattern"],"<host::Host<S> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"url/src/host.rs\"))","std::fmt::Display"],"<host::HostInternal as std::convert::From<host::Host>>::from":["from","Real(LocalPath(\"url/src/host.rs\"))","std::convert::From"],"<parser::Input<'i> as std::iter::Iterator>::next":["next","Real(LocalPath(\"url/src/parser.rs\"))","std::iter::Iterator"],"<parser::ParseError as std::convert::From<idna::Errors>>::from":["from","Real(LocalPath(\"url/src/parser.rs\"))","std::convert::From"],"<parser::ParseError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"url/src/parser.rs\"))","std::fmt::Display"],"<parser::SyntaxViolation as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"url/src/parser.rs\"))","std::fmt::Display"],"<path_segments::PathSegmentsMut<'a> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"url/src/path_segments.rs\"))","std::ops::Drop"],"<std::ops::Range<u32> as RangeArg>::slice_of":["slice_of","Real(LocalPath(\"url/src/lib.rs\"))","RangeArg"],"<std::ops::RangeFrom<u32> as RangeArg>::slice_of":["slice_of","Real(LocalPath(\"url/src/lib.rs\"))","RangeArg"],"<std::ops::RangeTo<u32> as RangeArg>::slice_of":["slice_of","Real(LocalPath(\"url/src/lib.rs\"))","RangeArg"],"ParseOptions::<'a>::base_url":["base_url","Real(LocalPath(\"url/src/lib.rs\"))",""],"ParseOptions::<'a>::encoding_override":["encoding_override","Real(LocalPath(\"url/src/lib.rs\"))",""],"ParseOptions::<'a>::parse":["parse","Real(LocalPath(\"url/src/lib.rs\"))",""],"ParseOptions::<'a>::syntax_violation_callback":["syntax_violation_callback","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::as_str":["as_str","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::byte_at":["byte_at","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::cannot_be_a_base":["cannot_be_a_base","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::check_invariants":["check_invariants","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::domain":["domain","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::fragment":["fragment","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::from_directory_path":["from_directory_path","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::from_file_path":["from_file_path","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::has_authority":["has_authority","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::has_host":["has_host","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::host":["host","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::host_str":["host_str","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::into_string":["into_string","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::join":["join","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::mutate":["mutate","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::options":["options","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::origin":["origin","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::parse":["parse","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::parse_with_params":["parse_with_params","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::password":["password","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::path":["path","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::path_segments":["path_segments","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::path_segments_mut":["path_segments_mut","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::port":["port","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::port_or_known_default":["port_or_known_default","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::query":["query","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::query_pairs":["query_pairs","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::query_pairs_mut":["query_pairs_mut","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::restore_after_path":["restore_after_path","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::restore_already_parsed_fragment":["restore_already_parsed_fragment","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::scheme":["scheme","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::set_fragment":["set_fragment","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::set_host":["set_host","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::set_host_internal":["set_host_internal","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::set_ip_host":["set_ip_host","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::set_password":["set_password","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::set_path":["set_path","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::set_port":["set_port","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::set_port_internal":["set_port_internal","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::set_query":["set_query","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::set_scheme":["set_scheme","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::set_username":["set_username","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::slice":["slice","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::socket_addrs":["socket_addrs","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::socket_addrs::io_result":["io_result","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::take_after_path":["take_after_path","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::take_fragment":["take_fragment","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::to_file_path":["to_file_path","Real(LocalPath(\"url/src/lib.rs\"))",""],"Url::username":["username","Real(LocalPath(\"url/src/lib.rs\"))",""],"file_url_segments_to_pathbuf":["file_url_segments_to_pathbuf","Real(LocalPath(\"url/src/lib.rs\"))",""],"file_url_segments_to_pathbuf_windows":["file_url_segments_to_pathbuf_windows","Real(LocalPath(\"url/src/lib.rs\"))",""],"host::Host::<&'a str>::to_owned":["to_owned","Real(LocalPath(\"url/src/host.rs\"))",""],"host::Host::parse":["parse","Real(LocalPath(\"url/src/host.rs\"))",""],"host::Host::parse_opaque":["parse_opaque","Real(LocalPath(\"url/src/host.rs\"))",""],"host::longest_zero_sequence":["longest_zero_sequence","Real(LocalPath(\"url/src/host.rs\"))",""],"host::parse_ipv4addr":["parse_ipv4addr","Real(LocalPath(\"url/src/host.rs\"))",""],"host::parse_ipv4number":["parse_ipv4number","Real(LocalPath(\"url/src/host.rs\"))",""],"host::parse_ipv6addr":["parse_ipv6addr","Real(LocalPath(\"url/src/host.rs\"))",""],"host::write_ipv6":["write_ipv6","Real(LocalPath(\"url/src/host.rs\"))",""],"origin::Origin::ascii_serialization":["ascii_serialization","Real(LocalPath(\"url/src/origin.rs\"))",""],"origin::Origin::is_tuple":["is_tuple","Real(LocalPath(\"url/src/origin.rs\"))",""],"origin::Origin::new_opaque":["new_opaque","Real(LocalPath(\"url/src/origin.rs\"))",""],"origin::Origin::unicode_serialization":["unicode_serialization","Real(LocalPath(\"url/src/origin.rs\"))",""],"origin::url_origin":["url_origin","Real(LocalPath(\"url/src/origin.rs\"))",""],"parser::Input::<'i>::count_matching":["count_matching","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Input::<'i>::is_empty":["is_empty","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Input::<'i>::new":["new","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Input::<'i>::next_utf8":["next_utf8","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Input::<'i>::no_trim":["no_trim","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Input::<'i>::split_first":["split_first","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Input::<'i>::split_prefix":["split_prefix","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Input::<'i>::starts_with":["starts_with","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Input::<'i>::trim_tab_and_newlines":["trim_tab_and_newlines","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Input::<'i>::with_log":["with_log","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::after_double_slash":["after_double_slash","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::check_url_code_point":["check_url_code_point","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::file_host":["file_host","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::for_setter":["for_setter","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::fragment_only":["fragment_only","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::get_file_host":["get_file_host","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::last_slash_can_be_removed":["last_slash_can_be_removed","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::log_violation":["log_violation","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::log_violation_if":["log_violation_if","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_cannot_be_a_base_path":["parse_cannot_be_a_base_path","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_file":["parse_file","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_file_host":["parse_file_host","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_fragment":["parse_fragment","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_host":["parse_host","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_host_and_port":["parse_host_and_port","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_non_special":["parse_non_special","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_path":["parse_path","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_path_start":["parse_path_start","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_port":["parse_port","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_query":["parse_query","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_query_and_fragment":["parse_query_and_fragment","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_relative":["parse_relative","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_scheme":["parse_scheme","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_url":["parse_url","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_userinfo":["parse_userinfo","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::parse_with_scheme":["parse_with_scheme","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::pop_path":["pop_path","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::shorten_path":["shorten_path","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::Parser::<'a>::with_query_and_fragment":["with_query_and_fragment","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::SchemeType::from":["from","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::SchemeType::is_file":["is_file","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::SchemeType::is_special":["is_special","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::SyntaxViolation::description":["description","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::ascii_alpha":["ascii_alpha","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::ascii_tab_or_new_line":["ascii_tab_or_new_line","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::c0_control_or_space":["c0_control_or_space","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::default_port":["default_port","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::is_ascii_hex_digit":["is_ascii_hex_digit","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::is_normalized_windows_drive_letter":["is_normalized_windows_drive_letter","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::is_url_code_point":["is_url_code_point","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::is_windows_drive_letter":["is_windows_drive_letter","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::path_starts_with_windows_drive_letter":["path_starts_with_windows_drive_letter","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::starts_with_windows_drive_letter":["starts_with_windows_drive_letter","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::starts_with_windows_drive_letter_segment":["starts_with_windows_drive_letter_segment","Real(LocalPath(\"url/src/parser.rs\"))",""],"parser::to_u32":["to_u32","Real(LocalPath(\"url/src/parser.rs\"))",""],"path_segments::PathSegmentsMut::<'a>::clear":["clear","Real(LocalPath(\"url/src/path_segments.rs\"))",""],"path_segments::PathSegmentsMut::<'a>::extend":["extend","Real(LocalPath(\"url/src/path_segments.rs\"))",""],"path_segments::PathSegmentsMut::<'a>::pop":["pop","Real(LocalPath(\"url/src/path_segments.rs\"))",""],"path_segments::PathSegmentsMut::<'a>::pop_if_empty":["pop_if_empty","Real(LocalPath(\"url/src/path_segments.rs\"))",""],"path_segments::PathSegmentsMut::<'a>::push":["push","Real(LocalPath(\"url/src/path_segments.rs\"))",""],"path_segments::new":["new","Real(LocalPath(\"url/src/path_segments.rs\"))",""],"path_to_file_url_segments":["path_to_file_url_segments","Real(LocalPath(\"url/src/lib.rs\"))",""],"path_to_file_url_segments_windows":["path_to_file_url_segments_windows","Real(LocalPath(\"url/src/lib.rs\"))",""],"quirks::domain_to_ascii":["domain_to_ascii","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::domain_to_unicode":["domain_to_unicode","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::hash":["hash","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::host":["host","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::hostname":["hostname","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::href":["href","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::origin":["origin","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::password":["password","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::pathname":["pathname","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::port":["port","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::protocol":["protocol","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::search":["search","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::set_hash":["set_hash","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::set_host":["set_host","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::set_hostname":["set_hostname","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::set_href":["set_href","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::set_password":["set_password","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::set_pathname":["set_pathname","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::set_port":["set_port","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::set_protocol":["set_protocol","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::set_search":["set_search","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::set_username":["set_username","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::trim":["trim","Real(LocalPath(\"url/src/quirks.rs\"))",""],"quirks::username":["username","Real(LocalPath(\"url/src/quirks.rs\"))",""],"slicing::<impl Url>::index":["index","Real(LocalPath(\"url/src/slicing.rs\"))",""],"slicing::<impl std::ops::Index<std::ops::Range<slicing::Position>> for Url>::index":["index","Real(LocalPath(\"url/src/slicing.rs\"))","std::ops::Index"],"slicing::<impl std::ops::Index<std::ops::RangeFrom<slicing::Position>> for Url>::index":["index","Real(LocalPath(\"url/src/slicing.rs\"))","std::ops::Index"],"slicing::<impl std::ops::Index<std::ops::RangeFull> for Url>::index":["index","Real(LocalPath(\"url/src/slicing.rs\"))","std::ops::Index"],"slicing::<impl std::ops::Index<std::ops::RangeTo<slicing::Position>> for Url>::index":["index","Real(LocalPath(\"url/src/slicing.rs\"))","std::ops::Index"]},"trait_to_struct":{"RangeArg":["std::ops::Range","std::ops::RangeFrom","std::ops::RangeTo"],"form_urlencoded::Target":["UrlQuery"],"parser::Pattern":["<F as parser::Pattern>::F"],"std::clone::Clone":["ParseOptions","Url","host::Host","host::HostInternal","origin::OpaqueOrigin","origin::Origin","parser::Context","parser::Input","parser::ParseError","parser::SchemeType","parser::SyntaxViolation","slicing::Position"],"std::cmp::Eq":["Url","host::Host","host::HostInternal","origin::OpaqueOrigin","origin::Origin","parser::Context","parser::ParseError","parser::SyntaxViolation"],"std::cmp::Ord":["Url","host::Host"],"std::cmp::PartialEq":["Url","host::Host","host::HostInternal","origin::OpaqueOrigin","origin::Origin","parser::Context","parser::ParseError","parser::SchemeType","parser::SyntaxViolation"],"std::cmp::PartialOrd":["Url","host::Host"],"std::convert::AsRef":["Url"],"std::convert::From":["host::HostInternal","parser::ParseError"],"std::convert::TryFrom":["Url"],"std::error::Error":["parser::ParseError"],"std::fmt::Debug":["Url","UrlQuery","host::Host","host::HostInternal","origin::OpaqueOrigin","origin::Origin","parser::ParseError","parser::SyntaxViolation","path_segments::PathSegmentsMut","slicing::Position"],"std::fmt::Display":["Url","host::Host","parser::ParseError","parser::SyntaxViolation"],"std::hash::Hash":["Url","host::Host","origin::OpaqueOrigin","origin::Origin"],"std::iter::Iterator":["parser::Input"],"std::marker::Copy":["ParseOptions","host::HostInternal","parser::Context","parser::ParseError","parser::SchemeType","parser::SyntaxViolation","slicing::Position"],"std::marker::StructuralEq":["host::Host","host::HostInternal","origin::OpaqueOrigin","origin::Origin","parser::Context","parser::ParseError","parser::SyntaxViolation"],"std::marker::StructuralPartialEq":["host::Host","host::HostInternal","origin::OpaqueOrigin","origin::Origin","parser::Context","parser::ParseError","parser::SchemeType","parser::SyntaxViolation"],"std::ops::Drop":["UrlQuery","path_segments::PathSegmentsMut"],"std::ops::Index":["Url"],"std::str::FromStr":["Url"]},"type_to_def_path":{"ParseOptions<'a>":"ParseOptions","Url":"Url","UrlQuery<'a>":"UrlQuery","host::Host<S>":"host::Host","host::HostInternal":"host::HostInternal","origin::OpaqueOrigin":"origin::OpaqueOrigin","origin::Origin":"origin::Origin","parser::Context":"parser::Context","parser::Input<'i>":"parser::Input","parser::ParseError":"parser::ParseError","parser::Parser<'a>":"parser::Parser","parser::SchemeType":"parser::SchemeType","parser::SyntaxViolation":"parser::SyntaxViolation","path_segments::PathSegmentsMut<'a>":"path_segments::PathSegmentsMut","slicing::Position":"slicing::Position"}}