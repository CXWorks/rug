//! <https://infra.spec.whatwg.org/#forgiving-base64-decode>
#[derive(Debug)]
pub struct InvalidBase64(InvalidBase64Details);
#[derive(Debug)]
enum InvalidBase64Details {
    UnexpectedSymbol(u8),
    AlphabetSymbolAfterPadding,
    LoneAlphabetSymbol,
    Padding,
}
#[derive(Debug)]
pub enum DecodeError<E> {
    InvalidBase64(InvalidBase64),
    WriteError(E),
}
impl<E> From<InvalidBase64Details> for DecodeError<E> {
    fn from(e: InvalidBase64Details) -> Self {
        DecodeError::InvalidBase64(InvalidBase64(e))
    }
}
pub(crate) enum Impossible {}
impl From<DecodeError<Impossible>> for InvalidBase64 {
    fn from(e: DecodeError<Impossible>) -> Self {
        match e {
            DecodeError::InvalidBase64(e) => e,
            DecodeError::WriteError(e) => match e {}
        }
    }
}
/// `input` is assumed to be in an ASCII-compatible encoding
pub fn decode_to_vec(input: &[u8]) -> Result<Vec<u8>, InvalidBase64> {
    let mut v = Vec::new();
    {
        let mut decoder = Decoder::new(|bytes| {
            v.extend_from_slice(bytes);
            Ok(())
        });
        decoder.feed(input)?;
        decoder.finish()?;
    }
    Ok(v)
}
/// <https://infra.spec.whatwg.org/#forgiving-base64-decode>
pub struct Decoder<F, E>
where
    F: FnMut(&[u8]) -> Result<(), E>,
{
    write_bytes: F,
    bit_buffer: u32,
    buffer_bit_length: u8,
    padding_symbols: u8,
}
impl<F, E> Decoder<F, E>
where
    F: FnMut(&[u8]) -> Result<(), E>,
{
    pub fn new(write_bytes: F) -> Self {
        Self {
            write_bytes,
            bit_buffer: 0,
            buffer_bit_length: 0,
            padding_symbols: 0,
        }
    }
    /// Feed to the decoder partial input in an ASCII-compatible encoding
    pub fn feed(&mut self, input: &[u8]) -> Result<(), DecodeError<E>> {
        for &byte in input.iter() {
            let value = BASE64_DECODE_TABLE[byte as usize];
            if value < 0 {
                if matches!(byte, b' ' | b'\t' | b'\n' | b'\r' | b'\x0C') {
                    continue;
                }
                if byte == b'=' {
                    self.padding_symbols = self.padding_symbols.saturating_add(1);
                    continue;
                }
                return Err(InvalidBase64Details::UnexpectedSymbol(byte).into());
            }
            if self.padding_symbols > 0 {
                return Err(InvalidBase64Details::AlphabetSymbolAfterPadding.into());
            }
            self.bit_buffer <<= 6;
            self.bit_buffer |= value as u32;
            if self.buffer_bit_length < 18 {
                self.buffer_bit_length += 6;
            } else {
                let byte_buffer = [
                    (self.bit_buffer >> 16) as u8,
                    (self.bit_buffer >> 8) as u8,
                    self.bit_buffer as u8,
                ];
                (self.write_bytes)(&byte_buffer).map_err(DecodeError::WriteError)?;
                self.buffer_bit_length = 0;
            }
        }
        Ok(())
    }
    /// Call this to signal the end of the input
    pub fn finish(mut self) -> Result<(), DecodeError<E>> {
        match (self.buffer_bit_length, self.padding_symbols) {
            (0, 0) => {}
            (12, 2) | (12, 0) => {
                let byte_buffer = [(self.bit_buffer >> 4) as u8];
                (self.write_bytes)(&byte_buffer).map_err(DecodeError::WriteError)?;
            }
            (18, 1) | (18, 0) => {
                let byte_buffer = [
                    (self.bit_buffer >> 10) as u8,
                    (self.bit_buffer >> 2) as u8,
                ];
                (self.write_bytes)(&byte_buffer).map_err(DecodeError::WriteError)?;
            }
            (6, _) => return Err(InvalidBase64Details::LoneAlphabetSymbol.into()),
            _ => return Err(InvalidBase64Details::Padding.into()),
        }
        Ok(())
    }
}
/// Generated by `make_base64_decode_table.py` based on "Table 1: The Base 64 Alphabet"
/// at <https://tools.ietf.org/html/rfc4648#section-4>
///
/// Array indices are the byte value of symbols.
/// Array values are their positions in the base64 alphabet,
/// or -1 for symbols not in the alphabet.
/// The position contributes 6 bits to the decoded bytes.
#[rustfmt::skip]
const BASE64_DECODE_TABLE: [i8; 256] = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    62,
    -1,
    -1,
    -1,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
];
#[cfg(test)]
mod tests_llm_16_1 {
    use super::*;
    use crate::*;
    use forgiving_base64::{DecodeError, InvalidBase64Details, InvalidBase64};
    #[test]
    fn test_from() {
        let _rug_st_tests_llm_16_1_rrrruuuugggg_test_from = 0;
        let rug_fuzz_0 = b'A';
        let e = InvalidBase64Details::UnexpectedSymbol(rug_fuzz_0);
        let result: DecodeError<()> = DecodeError::InvalidBase64(InvalidBase64(e));
        debug_assert_eq!(result, from(e));
        let _rug_ed_tests_llm_16_1_rrrruuuugggg_test_from = 0;
    }
}
#[cfg(test)]
mod tests_llm_16_2 {
    use super::*;
    use crate::*;
    use forgiving_base64::{DecodeError, InvalidBase64, InvalidBase64Details, Impossible};
    #[test]
    fn test_from() {
        let _rug_st_tests_llm_16_2_rrrruuuugggg_test_from = 0;
        let rug_fuzz_0 = 0;
        let e: DecodeError<Impossible> = DecodeError::InvalidBase64(
            InvalidBase64(InvalidBase64Details::UnexpectedSymbol(rug_fuzz_0)),
        );
        let res: InvalidBase64 = from(e);
        debug_assert_eq!(res, InvalidBase64(InvalidBase64Details::UnexpectedSymbol(0)));
        let _rug_ed_tests_llm_16_2_rrrruuuugggg_test_from = 0;
    }
}
#[cfg(test)]
mod tests_llm_16_12 {
    use super::*;
    use crate::*;
    #[test]
    fn test_feed() {
        let _rug_st_tests_llm_16_12_rrrruuuugggg_test_feed = 0;
        let rug_fuzz_0 = 66;
        let rug_fuzz_1 = 67;
        let rug_fuzz_2 = 65;
        let rug_fuzz_3 = 61;
        let rug_fuzz_4 = 61;
        let rug_fuzz_5 = 66;
        let rug_fuzz_6 = 67;
        let rug_fuzz_7 = 65;
        let rug_fuzz_8 = 61;
        let rug_fuzz_9 = 61;
        let mut decoder = Decoder::new(|bytes| {
            debug_assert_eq!(bytes, & [0, 0, 0]);
            Ok(())
        });
        let input = [
            rug_fuzz_0,
            rug_fuzz_1,
            rug_fuzz_2,
            rug_fuzz_3,
            rug_fuzz_4,
            rug_fuzz_5,
            rug_fuzz_6,
            rug_fuzz_7,
            rug_fuzz_8,
            rug_fuzz_9,
        ];
        let result = decoder.feed(&input);
        debug_assert!(result.is_ok());
        let _rug_ed_tests_llm_16_12_rrrruuuugggg_test_feed = 0;
    }
}
#[cfg(test)]
mod tests_llm_16_13 {
    use super::*;
    use crate::*;
    use std::result::Result;
    #[test]
    fn test_finish() -> Result<(), DecodeError<()>> {
        let decoder = Decoder::new(|_: &[u8]| Ok(()));
        decoder.finish()
    }
}
#[cfg(test)]
mod tests_llm_16_14 {
    use super::*;
    use crate::*;
    use std::error::Error;
    fn write_bytes_mock(bytes: &[u8]) -> Result<(), Box<dyn Error>> {
        Ok(())
    }
    #[test]
    fn test_new() {
        let decoder: Decoder<_, Box<dyn Error>> = Decoder::<
            _,
            Box<dyn Error>,
        >::new(write_bytes_mock);
    }
}
#[cfg(test)]
mod tests_llm_16_15 {
    use super::*;
    use crate::*;
    use crate::forgiving_base64::InvalidBase64;
    use crate::forgiving_base64::Decoder;
    #[test]
    fn test_decode_to_vec() {
        let _rug_st_tests_llm_16_15_rrrruuuugggg_test_decode_to_vec = 0;
        let rug_fuzz_0 = 97;
        let rug_fuzz_1 = 98;
        let rug_fuzz_2 = 99;
        let rug_fuzz_3 = 100;
        let rug_fuzz_4 = 0b01100001;
        let test_input: &[u8] = &[rug_fuzz_0, rug_fuzz_1, rug_fuzz_2, rug_fuzz_3];
        let expected_result: Result<Vec<u8>, InvalidBase64> = Ok(
            vec![rug_fuzz_4, 0b01100010, 0b01100011, 0b01100100],
        );
        let result = decode_to_vec(test_input);
        debug_assert_eq!(result, expected_result);
        let _rug_ed_tests_llm_16_15_rrrruuuugggg_test_decode_to_vec = 0;
    }
}
