{"dependencies":{"<DataUrlError as std::fmt::Debug>::fmt":["DataUrlError","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<forgiving_base64::DecodeError<E> as std::convert::From<forgiving_base64::InvalidBase64Details>>::from":["forgiving_base64::DecodeError","forgiving_base64::InvalidBase64","forgiving_base64::InvalidBase64Details","std::marker::Sized"],"<forgiving_base64::DecodeError<E> as std::fmt::Debug>::fmt":["forgiving_base64::DecodeError","forgiving_base64::InvalidBase64","forgiving_base64::InvalidBase64Details","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<forgiving_base64::InvalidBase64 as std::convert::From<forgiving_base64::DecodeError<forgiving_base64::Impossible>>>::from":["forgiving_base64::DecodeError","forgiving_base64::InvalidBase64","forgiving_base64::InvalidBase64Details","std::marker::Sized"],"<forgiving_base64::InvalidBase64 as std::fmt::Debug>::fmt":["forgiving_base64::InvalidBase64","forgiving_base64::InvalidBase64Details","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<forgiving_base64::InvalidBase64Details as std::fmt::Debug>::fmt":["forgiving_base64::InvalidBase64Details","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<mime::Mime as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","mime::Mime","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<mime::Mime as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","mime::Mime","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<mime::Mime as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","mime::Mime","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<mime::Mime as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","mime::Mime","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<mime::Mime as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<mime::MimeParsingError as std::fmt::Debug>::fmt":["mime::MimeParsingError","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"DataUrl":["DataUrl","alloc::raw_vec::RawVec","mime::Mime","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"DataUrl::<'a>::decode":["DataUrl","alloc::raw_vec::RawVec","mime::Mime","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"DataUrl::<'a>::decode_to_vec":["DataUrl","alloc::raw_vec::RawVec","mime::Mime","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"DataUrl::<'a>::mime_type":["DataUrl","alloc::raw_vec::RawVec","mime::Mime","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"DataUrl::<'a>::process":["std::marker::Sized","std::result::Result"],"DataUrlError":["DataUrlError"],"FragmentIdentifier":["FragmentIdentifier"],"FragmentIdentifier::<'a>::to_percent_encoded":["FragmentIdentifier","alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"decode_with_base64":["std::marker::Sized","std::ops::FnMut","std::result::Result"],"decode_without_base64":["std::marker::Sized","std::ops::FnMut","std::result::Result"],"find_comma_before_fragment":["std::marker::Sized","std::option::Option"],"forgiving_base64::DecodeError":["forgiving_base64::DecodeError","forgiving_base64::InvalidBase64","forgiving_base64::InvalidBase64Details","std::marker::Sized"],"forgiving_base64::Decoder":["forgiving_base64::Decoder","std::marker::Sized","std::ops::FnMut"],"forgiving_base64::Decoder::<F, E>::feed":["forgiving_base64::Decoder","std::marker::Sized","std::ops::FnMut","std::result::Result"],"forgiving_base64::Decoder::<F, E>::finish":["forgiving_base64::Decoder","std::marker::Sized","std::ops::FnMut","std::result::Result"],"forgiving_base64::Decoder::<F, E>::new":["forgiving_base64::Decoder","std::marker::Sized","std::ops::FnMut"],"forgiving_base64::Impossible":["forgiving_base64::Impossible"],"forgiving_base64::InvalidBase64":["forgiving_base64::InvalidBase64","forgiving_base64::InvalidBase64Details"],"forgiving_base64::InvalidBase64Details":["forgiving_base64::InvalidBase64Details"],"forgiving_base64::decode_to_vec":["std::marker::Sized","std::result::Result"],"mime::Mime":["alloc::raw_vec::RawVec","mime::Mime","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"mime::Mime::get_parameter":["alloc::raw_vec::RawVec","mime::Mime","std::alloc::Allocator","std::cmp::PartialEq","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"mime::MimeParsingError":["mime::MimeParsingError"],"mime::ascii_whitespace":[],"mime::contains":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"mime::only_http_token_code_points":[],"mime::parse":["std::marker::Sized","std::option::Option"],"mime::parse_parameters":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"mime::split2":["std::marker::Sized","std::option::Option"],"mime::valid_value":[],"parse_header":["alloc::raw_vec::RawVec","mime::Mime","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"percent_encode":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"pretend_parse_data_url":["std::marker::Sized","std::option::Option"],"remove_base64_suffix":["std::marker::Sized","std::option::Option"]},"glob_path_import":{},"self_to_fn":{"DataUrl":["impl<'a> DataUrl<'a> {\n    /// <https://fetch.spec.whatwg.org/#data-url-processor>\n    /// but starting from a string rather than a parsed `Url`, to avoid extra string copies.\n    pub fn process(input: &'a str) -> Result<Self, DataUrlError> {\n        use crate::DataUrlError::*;\n\n        let after_colon = pretend_parse_data_url(input).ok_or(NotADataUrl)?;\n\n        let (from_colon_to_comma, encoded_body_plus_fragment) =\n            find_comma_before_fragment(after_colon).ok_or(NoComma)?;\n\n        let (mime_type, base64) = parse_header(from_colon_to_comma);\n\n        Ok(DataUrl {\n            mime_type,\n            base64,\n            encoded_body_plus_fragment,\n        })\n    }\n\n    pub fn mime_type(&self) -> &mime::Mime {\n        &self.mime_type\n    }\n\n    /// Streaming-decode the data URL’s body to `write_body_bytes`,\n    /// and return the URL’s fragment identifier if it has one.\n    pub fn decode<F, E>(\n        &self,\n        write_body_bytes: F,\n    ) -> Result<Option<FragmentIdentifier<'a>>, forgiving_base64::DecodeError<E>>\n    where\n        F: FnMut(&[u8]) -> Result<(), E>,\n    {\n        if self.base64 {\n            decode_with_base64(self.encoded_body_plus_fragment, write_body_bytes)\n        } else {\n            decode_without_base64(self.encoded_body_plus_fragment, write_body_bytes)\n                .map_err(forgiving_base64::DecodeError::WriteError)\n        }\n    }\n\n    /// Return the decoded body, and the URL’s fragment identifier if it has one.\n    pub fn decode_to_vec(\n        &self,\n    ) -> Result<(Vec<u8>, Option<FragmentIdentifier<'a>>), forgiving_base64::InvalidBase64> {\n        let mut body = Vec::new();\n        let fragment = self.decode(|bytes| {\n            body.extend_from_slice(bytes);\n            Ok(())\n        })?;\n        Ok((body, fragment))\n    }\n}"],"DataUrlError":["Debug"],"FragmentIdentifier":["impl<'a> FragmentIdentifier<'a> {\n    /// Like in a parsed URL\n    pub fn to_percent_encoded(&self) -> String {\n        let mut string = String::new();\n        for byte in self.0.bytes() {\n            match byte {\n                // Ignore ASCII tabs or newlines like the URL parser would\n                b'\\t' | b'\\n' | b'\\r' => continue,\n                // https://url.spec.whatwg.org/#fragment-percent-encode-set\n                b'\\0'..=b' ' | b'\"' | b'<' | b'>' | b'`' | b'\\x7F'..=b'\\xFF' => {\n                    percent_encode(byte, &mut string)\n                }\n                // Printable ASCII\n                _ => string.push(byte as char),\n            }\n        }\n        string\n    }\n}"],"forgiving_base64::DecodeError":["Debug","impl<E> From<InvalidBase64Details> for DecodeError<E> {\n    fn from(e: InvalidBase64Details) -> Self {\n        DecodeError::InvalidBase64(InvalidBase64(e))\n    }\n}"],"forgiving_base64::Decoder":["impl<F, E> Decoder<F, E>\nwhere\n    F: FnMut(&[u8]) -> Result<(), E>,\n{\n    pub fn new(write_bytes: F) -> Self {\n        Self {\n            write_bytes,\n            bit_buffer: 0,\n            buffer_bit_length: 0,\n            padding_symbols: 0,\n        }\n    }\n\n    /// Feed to the decoder partial input in an ASCII-compatible encoding\n    pub fn feed(&mut self, input: &[u8]) -> Result<(), DecodeError<E>> {\n        for &byte in input.iter() {\n            let value = BASE64_DECODE_TABLE[byte as usize];\n            if value < 0 {\n                // A character that’s not part of the alphabet\n\n                // Remove ASCII whitespace\n                if matches!(byte, b' ' | b'\\t' | b'\\n' | b'\\r' | b'\\x0C') {\n                    continue;\n                }\n\n                if byte == b'=' {\n                    self.padding_symbols = self.padding_symbols.saturating_add(1);\n                    continue;\n                }\n\n                return Err(InvalidBase64Details::UnexpectedSymbol(byte).into());\n            }\n            if self.padding_symbols > 0 {\n                return Err(InvalidBase64Details::AlphabetSymbolAfterPadding.into());\n            }\n            self.bit_buffer <<= 6;\n            self.bit_buffer |= value as u32;\n            // 18 before incrementing means we’ve just reached 24\n            if self.buffer_bit_length < 18 {\n                self.buffer_bit_length += 6;\n            } else {\n                // We’ve accumulated four times 6 bits, which equals three times 8 bits.\n                let byte_buffer = [\n                    (self.bit_buffer >> 16) as u8,\n                    (self.bit_buffer >> 8) as u8,\n                    self.bit_buffer as u8,\n                ];\n                (self.write_bytes)(&byte_buffer).map_err(DecodeError::WriteError)?;\n                self.buffer_bit_length = 0;\n                // No need to reset bit_buffer,\n                // since next time we’re only gonna read relevant bits.\n            }\n        }\n        Ok(())\n    }\n\n    /// Call this to signal the end of the input\n    pub fn finish(mut self) -> Result<(), DecodeError<E>> {\n        match (self.buffer_bit_length, self.padding_symbols) {\n            (0, 0) => {\n                // A multiple of four of alphabet symbols, and nothing else.\n            }\n            (12, 2) | (12, 0) => {\n                // A multiple of four of alphabet symbols, followed by two more symbols,\n                // optionally followed by two padding characters (which make a total multiple of four).\n                let byte_buffer = [(self.bit_buffer >> 4) as u8];\n                (self.write_bytes)(&byte_buffer).map_err(DecodeError::WriteError)?;\n            }\n            (18, 1) | (18, 0) => {\n                // A multiple of four of alphabet symbols, followed by three more symbols,\n                // optionally followed by one padding character (which make a total multiple of four).\n                let byte_buffer = [(self.bit_buffer >> 10) as u8, (self.bit_buffer >> 2) as u8];\n                (self.write_bytes)(&byte_buffer).map_err(DecodeError::WriteError)?;\n            }\n            (6, _) => return Err(InvalidBase64Details::LoneAlphabetSymbol.into()),\n            _ => return Err(InvalidBase64Details::Padding.into()),\n        }\n        Ok(())\n    }\n}"],"forgiving_base64::InvalidBase64":["Debug","impl From<DecodeError<Impossible>> for InvalidBase64 {\n    fn from(e: DecodeError<Impossible>) -> Self {\n        match e {\n            DecodeError::InvalidBase64(e) => e,\n            DecodeError::WriteError(e) => match e {},\n        }\n    }\n}"],"forgiving_base64::InvalidBase64Details":["Debug"],"mime::Mime":["Debug","Eq","PartialEq","impl FromStr for Mime {\n    type Err = MimeParsingError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        parse(s).ok_or(MimeParsingError(()))\n    }\n}","impl Mime {\n    pub fn get_parameter<P>(&self, name: &P) -> Option<&str>\n    where\n        P: ?Sized + PartialEq<str>,\n    {\n        self.parameters\n            .iter()\n            .find(|&&(ref n, _)| name == &**n)\n            .map(|&(_, ref v)| &**v)\n    }\n}","impl fmt::Display for Mime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(&self.type_)?;\n        f.write_str(\"/\")?;\n        f.write_str(&self.subtype)?;\n        for &(ref name, ref value) in &self.parameters {\n            f.write_str(\";\")?;\n            f.write_str(name)?;\n            f.write_str(\"=\")?;\n            if only_http_token_code_points(value) {\n                f.write_str(value)?\n            } else {\n                f.write_str(\"\\\"\")?;\n                for c in value.chars() {\n                    if c == '\"' || c == '\\\\' {\n                        f.write_str(\"\\\\\")?\n                    }\n                    f.write_char(c)?\n                }\n                f.write_str(\"\\\"\")?\n            }\n        }\n        Ok(())\n    }\n}"],"mime::MimeParsingError":["Debug"]},"single_path_import":{},"srcs":{"<forgiving_base64::DecodeError<E> as std::convert::From<forgiving_base64::InvalidBase64Details>>::from":["fn from(e: InvalidBase64Details) -> Self{\n        DecodeError::InvalidBase64(InvalidBase64(e))\n    }","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))"],"<forgiving_base64::InvalidBase64 as std::convert::From<forgiving_base64::DecodeError<forgiving_base64::Impossible>>>::from":["fn from(e: DecodeError<Impossible>) -> Self{\n        match e {\n            DecodeError::InvalidBase64(e) => e,\n            DecodeError::WriteError(e) => match e {},\n        }\n    }","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))"],"<mime::Mime as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(&self.type_)?;\n        f.write_str(\"/\")?;\n        f.write_str(&self.subtype)?;\n        for &(ref name, ref value) in &self.parameters {\n            f.write_str(\";\")?;\n            f.write_str(name)?;\n            f.write_str(\"=\")?;\n            if only_http_token_code_points(value) {\n                f.write_str(value)?\n            } else {\n                f.write_str(\"\\\"\")?;\n                for c in value.chars() {\n                    if c == '\"' || c == '\\\\' {\n                        f.write_str(\"\\\\\")?\n                    }\n                    f.write_char(c)?\n                }\n                f.write_str(\"\\\"\")?\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"data-url/src/mime.rs\"))"],"<mime::Mime as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Self, Self::Err>{\n        parse(s).ok_or(MimeParsingError(()))\n    }","Real(LocalPath(\"data-url/src/mime.rs\"))"],"DataUrl":["pub struct DataUrl<'a> {\n    mime_type: mime::Mime,\n    base64: bool,\n    encoded_body_plus_fragment: &'a str,\n}","Real(LocalPath(\"data-url/src/lib.rs\"))"],"DataUrl::<'a>::decode":["/// Streaming-decode the data URL’s body to `write_body_bytes`,\n/// and return the URL’s fragment identifier if it has one.\npub fn decode<F, E>(\n        &self,\n        write_body_bytes: F,\n    ) -> Result<Option<FragmentIdentifier<'a>>, forgiving_base64::DecodeError<E>>\n    where\n        F: FnMut(&[u8]) -> Result<(), E>,{\n        if self.base64 {\n            decode_with_base64(self.encoded_body_plus_fragment, write_body_bytes)\n        } else {\n            decode_without_base64(self.encoded_body_plus_fragment, write_body_bytes)\n                .map_err(forgiving_base64::DecodeError::WriteError)\n        }\n    }","Real(LocalPath(\"data-url/src/lib.rs\"))"],"DataUrl::<'a>::decode_to_vec":["/// Return the decoded body, and the URL’s fragment identifier if it has one.\npub fn decode_to_vec(\n        &self,\n    ) -> Result<(Vec<u8>, Option<FragmentIdentifier<'a>>), forgiving_base64::InvalidBase64>{\n        let mut body = Vec::new();\n        let fragment = self.decode(|bytes| {\n            body.extend_from_slice(bytes);\n            Ok(())\n        })?;\n        Ok((body, fragment))\n    }","Real(LocalPath(\"data-url/src/lib.rs\"))"],"DataUrl::<'a>::mime_type":["pub fn mime_type(&self) -> &mime::Mime{\n        &self.mime_type\n    }","Real(LocalPath(\"data-url/src/lib.rs\"))"],"DataUrl::<'a>::process":["/// <https://fetch.spec.whatwg.org/#data-url-processor>\n/// but starting from a string rather than a parsed `Url`, to avoid extra string copies.\npub fn process(input: &'a str) -> Result<Self, DataUrlError>{\n        use crate::DataUrlError::*;\n\n        let after_colon = pretend_parse_data_url(input).ok_or(NotADataUrl)?;\n\n        let (from_colon_to_comma, encoded_body_plus_fragment) =\n            find_comma_before_fragment(after_colon).ok_or(NoComma)?;\n\n        let (mime_type, base64) = parse_header(from_colon_to_comma);\n\n        Ok(DataUrl {\n            mime_type,\n            base64,\n            encoded_body_plus_fragment,\n        })\n    }","Real(LocalPath(\"data-url/src/lib.rs\"))"],"DataUrlError":["pub enum DataUrlError {\n    NotADataUrl,\n    NoComma,\n}","Real(LocalPath(\"data-url/src/lib.rs\"))"],"FragmentIdentifier":["/// The URL’s fragment identifier (after `#`)\npub struct FragmentIdentifier<'a>(&'a str);","Real(LocalPath(\"data-url/src/lib.rs\"))"],"FragmentIdentifier::<'a>::to_percent_encoded":["/// Like in a parsed URL\npub fn to_percent_encoded(&self) -> String{\n        let mut string = String::new();\n        for byte in self.0.bytes() {\n            match byte {\n                // Ignore ASCII tabs or newlines like the URL parser would\n                b'\\t' | b'\\n' | b'\\r' => continue,\n                // https://url.spec.whatwg.org/#fragment-percent-encode-set\n                b'\\0'..=b' ' | b'\"' | b'<' | b'>' | b'`' | b'\\x7F'..=b'\\xFF' => {\n                    percent_encode(byte, &mut string)\n                }\n                // Printable ASCII\n                _ => string.push(byte as char),\n            }\n        }\n        string\n    }","Real(LocalPath(\"data-url/src/lib.rs\"))"],"decode_with_base64":["/// `decode_without_base64()` composed with\n/// <https://infra.spec.whatwg.org/#isomorphic-decode> composed with\n/// <https://infra.spec.whatwg.org/#forgiving-base64-decode>.\nfn decode_with_base64<F, E>(\n    encoded_body_plus_fragment: &str,\n    write_bytes: F,\n) -> Result<Option<FragmentIdentifier<'_>>, forgiving_base64::DecodeError<E>>\nwhere\n    F: FnMut(&[u8]) -> Result<(), E>,{\n    let mut decoder = forgiving_base64::Decoder::new(write_bytes);\n    let fragment = decode_without_base64(encoded_body_plus_fragment, |bytes| decoder.feed(bytes))?;\n    decoder.finish()?;\n    Ok(fragment)\n}","Real(LocalPath(\"data-url/src/lib.rs\"))"],"decode_without_base64":["/// This is <https://url.spec.whatwg.org/#string-percent-decode> while also:\n///\n/// * Ignoring ASCII tab or newlines\n/// * Stopping at the first '#' (which indicates the start of the fragment)\n///\n/// Anything that would have been UTF-8 percent-encoded by the URL parser\n/// would be percent-decoded here.\n/// We skip that round-trip and pass it through unchanged.\nfn decode_without_base64<F, E>(\n    encoded_body_plus_fragment: &str,\n    mut write_bytes: F,\n) -> Result<Option<FragmentIdentifier<'_>>, E>\nwhere\n    F: FnMut(&[u8]) -> Result<(), E>,{\n    let bytes = encoded_body_plus_fragment.as_bytes();\n    let mut slice_start = 0;\n    for (i, &byte) in bytes.iter().enumerate() {\n        // We only need to look for 5 different \"special\" byte values.\n        // For everything else we make slices as large as possible, borrowing the input,\n        // in order to make fewer write_all() calls.\n        if matches!(byte, b'%' | b'#' | b'\\t' | b'\\n' | b'\\r') {\n            // Write everything (if anything) \"non-special\" we’ve accumulated\n            // before this special byte\n            if i > slice_start {\n                write_bytes(&bytes[slice_start..i])?;\n            }\n            // Then deal with the special byte.\n            match byte {\n                b'%' => {\n                    let l = bytes.get(i + 2).and_then(|&b| (b as char).to_digit(16));\n                    let h = bytes.get(i + 1).and_then(|&b| (b as char).to_digit(16));\n                    if let (Some(h), Some(l)) = (h, l) {\n                        // '%' followed by two ASCII hex digits\n                        let one_byte = h as u8 * 0x10 + l as u8;\n                        write_bytes(&[one_byte])?;\n                        slice_start = i + 3;\n                    } else {\n                        // Do nothing. Leave slice_start unchanged.\n                        // The % sign will be part of the next slice.\n                    }\n                }\n\n                b'#' => {\n                    let fragment_start = i + 1;\n                    let fragment = &encoded_body_plus_fragment[fragment_start..];\n                    return Ok(Some(FragmentIdentifier(fragment)));\n                }\n\n                // Ignore over '\\t' | '\\n' | '\\r'\n                _ => slice_start = i + 1,\n            }\n        }\n    }\n    write_bytes(&bytes[slice_start..])?;\n    Ok(None)\n}","Real(LocalPath(\"data-url/src/lib.rs\"))"],"find_comma_before_fragment":["fn find_comma_before_fragment(after_colon: &str) -> Option<(&str, &str)>{\n    for (i, byte) in after_colon.bytes().enumerate() {\n        if byte == b',' {\n            return Some((&after_colon[..i], &after_colon[i + 1..]));\n        }\n        if byte == b'#' {\n            break;\n        }\n    }\n    None\n}","Real(LocalPath(\"data-url/src/lib.rs\"))"],"forgiving_base64::DecodeError":["pub enum DecodeError<E> {\n    InvalidBase64(InvalidBase64),\n    WriteError(E),\n}","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))"],"forgiving_base64::Decoder":["/// <https://infra.spec.whatwg.org/#forgiving-base64-decode>\npub struct Decoder<F, E>\nwhere\n    F: FnMut(&[u8]) -> Result<(), E>,\n{\n    write_bytes: F,\n    bit_buffer: u32,\n    buffer_bit_length: u8,\n    padding_symbols: u8,\n}","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))"],"forgiving_base64::Decoder::<F, E>::feed":["/// Feed to the decoder partial input in an ASCII-compatible encoding\npub fn feed(&mut self, input: &[u8]) -> Result<(), DecodeError<E>>{\n        for &byte in input.iter() {\n            let value = BASE64_DECODE_TABLE[byte as usize];\n            if value < 0 {\n                // A character that’s not part of the alphabet\n\n                // Remove ASCII whitespace\n                if matches!(byte, b' ' | b'\\t' | b'\\n' | b'\\r' | b'\\x0C') {\n                    continue;\n                }\n\n                if byte == b'=' {\n                    self.padding_symbols = self.padding_symbols.saturating_add(1);\n                    continue;\n                }\n\n                return Err(InvalidBase64Details::UnexpectedSymbol(byte).into());\n            }\n            if self.padding_symbols > 0 {\n                return Err(InvalidBase64Details::AlphabetSymbolAfterPadding.into());\n            }\n            self.bit_buffer <<= 6;\n            self.bit_buffer |= value as u32;\n            // 18 before incrementing means we’ve just reached 24\n            if self.buffer_bit_length < 18 {\n                self.buffer_bit_length += 6;\n            } else {\n                // We’ve accumulated four times 6 bits, which equals three times 8 bits.\n                let byte_buffer = [\n                    (self.bit_buffer >> 16) as u8,\n                    (self.bit_buffer >> 8) as u8,\n                    self.bit_buffer as u8,\n                ];\n                (self.write_bytes)(&byte_buffer).map_err(DecodeError::WriteError)?;\n                self.buffer_bit_length = 0;\n                // No need to reset bit_buffer,\n                // since next time we’re only gonna read relevant bits.\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))"],"forgiving_base64::Decoder::<F, E>::finish":["/// Call this to signal the end of the input\npub fn finish(mut self) -> Result<(), DecodeError<E>>{\n        match (self.buffer_bit_length, self.padding_symbols) {\n            (0, 0) => {\n                // A multiple of four of alphabet symbols, and nothing else.\n            }\n            (12, 2) | (12, 0) => {\n                // A multiple of four of alphabet symbols, followed by two more symbols,\n                // optionally followed by two padding characters (which make a total multiple of four).\n                let byte_buffer = [(self.bit_buffer >> 4) as u8];\n                (self.write_bytes)(&byte_buffer).map_err(DecodeError::WriteError)?;\n            }\n            (18, 1) | (18, 0) => {\n                // A multiple of four of alphabet symbols, followed by three more symbols,\n                // optionally followed by one padding character (which make a total multiple of four).\n                let byte_buffer = [(self.bit_buffer >> 10) as u8, (self.bit_buffer >> 2) as u8];\n                (self.write_bytes)(&byte_buffer).map_err(DecodeError::WriteError)?;\n            }\n            (6, _) => return Err(InvalidBase64Details::LoneAlphabetSymbol.into()),\n            _ => return Err(InvalidBase64Details::Padding.into()),\n        }\n        Ok(())\n    }","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))"],"forgiving_base64::Decoder::<F, E>::new":["pub fn new(write_bytes: F) -> Self{\n        Self {\n            write_bytes,\n            bit_buffer: 0,\n            buffer_bit_length: 0,\n            padding_symbols: 0,\n        }\n    }","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))"],"forgiving_base64::Impossible":["pub(crate) enum Impossible {}","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))"],"forgiving_base64::InvalidBase64":["pub struct InvalidBase64(InvalidBase64Details);","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))"],"forgiving_base64::InvalidBase64Details":["enum InvalidBase64Details {\n    UnexpectedSymbol(u8),\n    AlphabetSymbolAfterPadding,\n    LoneAlphabetSymbol,\n    Padding,\n}","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))"],"forgiving_base64::decode_to_vec":["/// `input` is assumed to be in an ASCII-compatible encoding\npub fn decode_to_vec(input: &[u8]) -> Result<Vec<u8>, InvalidBase64>{\n    let mut v = Vec::new();\n    {\n        let mut decoder = Decoder::new(|bytes| {\n            v.extend_from_slice(bytes);\n            Ok(())\n        });\n        decoder.feed(input)?;\n        decoder.finish()?;\n    }\n    Ok(v)\n}","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))"],"mime::Mime":["/// <https://mimesniff.spec.whatwg.org/#mime-type-representation>\npub struct Mime {\n    pub type_: String,\n    pub subtype: String,\n    /// (name, value)\n    pub parameters: Vec<(String, String)>,\n}","Real(LocalPath(\"data-url/src/mime.rs\"))"],"mime::Mime::get_parameter":["pub fn get_parameter<P>(&self, name: &P) -> Option<&str>\n    where\n        P: ?Sized + PartialEq<str>,{\n        self.parameters\n            .iter()\n            .find(|&&(ref n, _)| name == &**n)\n            .map(|&(_, ref v)| &**v)\n    }","Real(LocalPath(\"data-url/src/mime.rs\"))"],"mime::MimeParsingError":["pub struct MimeParsingError(());","Real(LocalPath(\"data-url/src/mime.rs\"))"],"mime::ascii_whitespace":["fn ascii_whitespace(c: char) -> bool{\n    matches!(c, ' ' | '\\t' | '\\n' | '\\r' | '\\x0C')\n}","Real(LocalPath(\"data-url/src/mime.rs\"))"],"mime::contains":["fn contains(parameters: &[(String, String)], name: &str) -> bool{\n    parameters.iter().any(|&(ref n, _)| n == name)\n}","Real(LocalPath(\"data-url/src/mime.rs\"))"],"mime::only_http_token_code_points":["fn only_http_token_code_points(s: &str) -> bool{\n    s.bytes().all(|byte| IS_HTTP_TOKEN[byte as usize])\n}","Real(LocalPath(\"data-url/src/mime.rs\"))"],"mime::parse":["fn parse(s: &str) -> Option<Mime>{\n    let trimmed = s.trim_matches(ascii_whitespace);\n\n    let (type_, rest) = split2(trimmed, '/');\n    require!(only_http_token_code_points(type_) && !type_.is_empty());\n\n    let (subtype, rest) = split2(rest?, ';');\n    let subtype = subtype.trim_end_matches(ascii_whitespace);\n    require!(only_http_token_code_points(subtype) && !subtype.is_empty());\n\n    let mut parameters = Vec::new();\n    if let Some(rest) = rest {\n        parse_parameters(rest, &mut parameters)\n    }\n\n    Some(Mime {\n        type_: type_.to_ascii_lowercase(),\n        subtype: subtype.to_ascii_lowercase(),\n        parameters,\n    })\n}","Real(LocalPath(\"data-url/src/mime.rs\"))"],"mime::parse_parameters":["fn parse_parameters(s: &str, parameters: &mut Vec<(String, String)>){\n    let mut semicolon_separated = s.split(';');\n\n    while let Some(piece) = semicolon_separated.next() {\n        let piece = piece.trim_start_matches(ascii_whitespace);\n        let (name, value) = split2(piece, '=');\n        if name.is_empty() || !only_http_token_code_points(name) || contains(&parameters, name) {\n            continue;\n        }\n        if let Some(value) = value {\n            let value = if value.starts_with('\"') {\n                let max_len = value.len().saturating_sub(2); // without start or end quotes\n                let mut unescaped_value = String::with_capacity(max_len);\n                let mut chars = value[1..].chars();\n                'until_closing_quote: loop {\n                    while let Some(c) = chars.next() {\n                        match c {\n                            '\"' => break 'until_closing_quote,\n                            '\\\\' => unescaped_value.push(chars.next().unwrap_or('\\\\')),\n                            _ => unescaped_value.push(c),\n                        }\n                    }\n                    if let Some(piece) = semicolon_separated.next() {\n                        // A semicolon inside a quoted value is not a separator\n                        // for the next parameter, but part of the value.\n                        unescaped_value.push(';');\n                        chars = piece.chars()\n                    } else {\n                        break;\n                    }\n                }\n                if !valid_value(&unescaped_value) {\n                    continue;\n                }\n                unescaped_value\n            } else {\n                let value = value.trim_end_matches(ascii_whitespace);\n                if !valid_value(value) {\n                    continue;\n                }\n                value.to_owned()\n            };\n            parameters.push((name.to_ascii_lowercase(), value))\n        }\n    }\n}","Real(LocalPath(\"data-url/src/mime.rs\"))"],"mime::split2":["fn split2(s: &str, separator: char) -> (&str, Option<&str>){\n    let mut iter = s.splitn(2, separator);\n    let first = iter.next().unwrap();\n    (first, iter.next())\n}","Real(LocalPath(\"data-url/src/mime.rs\"))"],"mime::valid_value":["fn valid_value(s: &str) -> bool{\n    s.chars().all(|c| {\n        // <https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point>\n        matches!(c, '\\t' | ' '..='~' | '\\u{80}'..='\\u{FF}')\n    }) && !s.is_empty()\n}","Real(LocalPath(\"data-url/src/mime.rs\"))"],"parse_header":["fn parse_header(from_colon_to_comma: &str) -> (mime::Mime, bool){\n    // \"Strip leading and trailing ASCII whitespace\"\n    //     \\t, \\n, and \\r would have been filtered by the URL parser\n    //     \\f percent-encoded by the URL parser\n    //     space is the only remaining ASCII whitespace\n    let trimmed = from_colon_to_comma.trim_matches(|c| matches!(c, ' ' | '\\t' | '\\n' | '\\r'));\n\n    let without_base64_suffix = remove_base64_suffix(trimmed);\n    let base64 = without_base64_suffix.is_some();\n    let mime_type = without_base64_suffix.unwrap_or(trimmed);\n\n    let mut string = String::new();\n    if mime_type.starts_with(';') {\n        string.push_str(\"text/plain\")\n    }\n    let mut in_query = false;\n    for byte in mime_type.bytes() {\n        match byte {\n            // Ignore ASCII tabs or newlines like the URL parser would\n            b'\\t' | b'\\n' | b'\\r' => continue,\n\n            // https://url.spec.whatwg.org/#c0-control-percent-encode-set\n            b'\\0'..=b'\\x1F' | b'\\x7F'..=b'\\xFF' => percent_encode(byte, &mut string),\n\n            // Bytes other than the C0 percent-encode set that are percent-encoded\n            // by the URL parser in the query state.\n            // '#' is also in that list but cannot occur here\n            // since it indicates the start of the URL’s fragment.\n            b' ' | b'\"' | b'<' | b'>' if in_query => percent_encode(byte, &mut string),\n\n            b'?' => {\n                in_query = true;\n                string.push('?')\n            }\n\n            // Printable ASCII\n            _ => string.push(byte as char),\n        }\n    }\n\n    // FIXME: does Mime::from_str match the MIME Sniffing Standard’s parsing algorithm?\n    // <https://mimesniff.spec.whatwg.org/#parse-a-mime-type>\n    let mime_type = string.parse().unwrap_or_else(|_| mime::Mime {\n        type_: String::from(\"text\"),\n        subtype: String::from(\"plain\"),\n        parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))],\n    });\n\n    (mime_type, base64)\n}","Real(LocalPath(\"data-url/src/lib.rs\"))"],"percent_encode":["fn percent_encode(byte: u8, string: &mut String){\n    const HEX_UPPER: [u8; 16] = *b\"0123456789ABCDEF\";\n    string.push('%');\n    string.push(HEX_UPPER[(byte >> 4) as usize] as char);\n    string.push(HEX_UPPER[(byte & 0x0f) as usize] as char);\n}","Real(LocalPath(\"data-url/src/lib.rs\"))"],"pretend_parse_data_url":["/// Similar to <https://url.spec.whatwg.org/#concept-basic-url-parser>\n/// followed by <https://url.spec.whatwg.org/#concept-url-serializer>\n///\n/// * `None`: not a data URL.\n///\n/// * `Some(s)`: sort of the result of serialization, except:\n///\n///   - `data:` prefix removed\n///   - The fragment is included\n///   - Other components are **not** UTF-8 percent-encoded\n///   - ASCII tabs and newlines in the middle are **not** removed\nfn pretend_parse_data_url(input: &str) -> Option<&str>{\n    // Trim C0 control or space\n    let left_trimmed = input.trim_start_matches(|ch| ch <= ' ');\n\n    let mut bytes = left_trimmed.bytes();\n    {\n        // Ignore ASCII tabs or newlines like the URL parser would\n        let mut iter = bytes\n            .by_ref()\n            .filter(|&byte| !matches!(byte, b'\\t' | b'\\n' | b'\\r'));\n        require!(iter.next()?.to_ascii_lowercase() == b'd');\n        require!(iter.next()?.to_ascii_lowercase() == b'a');\n        require!(iter.next()?.to_ascii_lowercase() == b't');\n        require!(iter.next()?.to_ascii_lowercase() == b'a');\n        require!(iter.next()? == b':');\n    }\n    let bytes_consumed = left_trimmed.len() - bytes.len();\n    let after_colon = &left_trimmed[bytes_consumed..];\n\n    // Trim C0 control or space\n    Some(after_colon.trim_end_matches(|ch| ch <= ' '))\n}","Real(LocalPath(\"data-url/src/lib.rs\"))"],"remove_base64_suffix":["/// None: no base64 suffix\n#[allow(clippy::skip_while_next)]\nfn remove_base64_suffix(s: &str) -> Option<&str>{\n    let mut bytes = s.bytes();\n    {\n        // Ignore ASCII tabs or newlines like the URL parser would\n        let iter = bytes\n            .by_ref()\n            .filter(|&byte| !matches!(byte, b'\\t' | b'\\n' | b'\\r'));\n\n        // Search from the end\n        let mut iter = iter.rev();\n\n        require!(iter.next()? == b'4');\n        require!(iter.next()? == b'6');\n        require!(iter.next()?.to_ascii_lowercase() == b'e');\n        require!(iter.next()?.to_ascii_lowercase() == b's');\n        require!(iter.next()?.to_ascii_lowercase() == b'a');\n        require!(iter.next()?.to_ascii_lowercase() == b'b');\n        require!(iter.skip_while(|&byte| byte == b' ').next()? == b';');\n    }\n    Some(&s[..bytes.len()])\n}","Real(LocalPath(\"data-url/src/lib.rs\"))"]},"struct_constructor":{"&mime::Mime":["mime_type"],"&str":["get_parameter"],"(&str, &str)":["find_comma_before_fragment"],"(&str, std::option::Option<&str>)":["split2"],"(mime::Mime, bool)":["parse_header"],"(std::vec::Vec<u8>, std::option::Option<FragmentIdentifier<'a>>)":["decode_to_vec"],"DataUrl":["process"],"FragmentIdentifier":["decode","decode_with_base64","decode_without_base64"],"bool":["ascii_whitespace","contains","eq","only_http_token_code_points","valid_value"],"forgiving_base64::DecodeError":["from"],"forgiving_base64::Decoder":["new"],"forgiving_base64::InvalidBase64":["from"],"mime::Mime":["from_str","parse"],"std::string::String":["to_percent_encoded"],"std::vec::Vec":["decode_to_vec"]},"struct_to_trait":{"DataUrlError":["std::fmt::Debug"],"forgiving_base64::DecodeError":["std::convert::From","std::fmt::Debug"],"forgiving_base64::InvalidBase64":["std::convert::From","std::fmt::Debug"],"forgiving_base64::InvalidBase64Details":["std::fmt::Debug"],"mime::Mime":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"mime::MimeParsingError":["std::fmt::Debug"]},"targets":{"<forgiving_base64::DecodeError<E> as std::convert::From<forgiving_base64::InvalidBase64Details>>::from":["from","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))","std::convert::From"],"<forgiving_base64::InvalidBase64 as std::convert::From<forgiving_base64::DecodeError<forgiving_base64::Impossible>>>::from":["from","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))","std::convert::From"],"<mime::Mime as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"data-url/src/mime.rs\"))","std::fmt::Display"],"<mime::Mime as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"data-url/src/mime.rs\"))","std::str::FromStr"],"DataUrl::<'a>::decode":["decode","Real(LocalPath(\"data-url/src/lib.rs\"))",""],"DataUrl::<'a>::decode_to_vec":["decode_to_vec","Real(LocalPath(\"data-url/src/lib.rs\"))",""],"DataUrl::<'a>::mime_type":["mime_type","Real(LocalPath(\"data-url/src/lib.rs\"))",""],"DataUrl::<'a>::process":["process","Real(LocalPath(\"data-url/src/lib.rs\"))",""],"FragmentIdentifier::<'a>::to_percent_encoded":["to_percent_encoded","Real(LocalPath(\"data-url/src/lib.rs\"))",""],"decode_with_base64":["decode_with_base64","Real(LocalPath(\"data-url/src/lib.rs\"))",""],"decode_without_base64":["decode_without_base64","Real(LocalPath(\"data-url/src/lib.rs\"))",""],"find_comma_before_fragment":["find_comma_before_fragment","Real(LocalPath(\"data-url/src/lib.rs\"))",""],"forgiving_base64::Decoder::<F, E>::feed":["feed","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))",""],"forgiving_base64::Decoder::<F, E>::finish":["finish","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))",""],"forgiving_base64::Decoder::<F, E>::new":["new","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))",""],"forgiving_base64::decode_to_vec":["decode_to_vec","Real(LocalPath(\"data-url/src/forgiving_base64.rs\"))",""],"mime::Mime::get_parameter":["get_parameter","Real(LocalPath(\"data-url/src/mime.rs\"))",""],"mime::ascii_whitespace":["ascii_whitespace","Real(LocalPath(\"data-url/src/mime.rs\"))",""],"mime::contains":["contains","Real(LocalPath(\"data-url/src/mime.rs\"))",""],"mime::only_http_token_code_points":["only_http_token_code_points","Real(LocalPath(\"data-url/src/mime.rs\"))",""],"mime::parse":["parse","Real(LocalPath(\"data-url/src/mime.rs\"))",""],"mime::parse_parameters":["parse_parameters","Real(LocalPath(\"data-url/src/mime.rs\"))",""],"mime::split2":["split2","Real(LocalPath(\"data-url/src/mime.rs\"))",""],"mime::valid_value":["valid_value","Real(LocalPath(\"data-url/src/mime.rs\"))",""],"parse_header":["parse_header","Real(LocalPath(\"data-url/src/lib.rs\"))",""],"percent_encode":["percent_encode","Real(LocalPath(\"data-url/src/lib.rs\"))",""],"pretend_parse_data_url":["pretend_parse_data_url","Real(LocalPath(\"data-url/src/lib.rs\"))",""],"remove_base64_suffix":["remove_base64_suffix","Real(LocalPath(\"data-url/src/lib.rs\"))",""]},"trait_to_struct":{"std::cmp::Eq":["mime::Mime"],"std::cmp::PartialEq":["mime::Mime"],"std::convert::From":["forgiving_base64::DecodeError","forgiving_base64::InvalidBase64"],"std::fmt::Debug":["DataUrlError","forgiving_base64::DecodeError","forgiving_base64::InvalidBase64","forgiving_base64::InvalidBase64Details","mime::Mime","mime::MimeParsingError"],"std::fmt::Display":["mime::Mime"],"std::marker::StructuralEq":["mime::Mime"],"std::marker::StructuralPartialEq":["mime::Mime"],"std::str::FromStr":["mime::Mime"]},"type_to_def_path":{"DataUrl<'a>":"DataUrl","DataUrlError":"DataUrlError","FragmentIdentifier<'a>":"FragmentIdentifier","forgiving_base64::DecodeError<E>":"forgiving_base64::DecodeError","forgiving_base64::Decoder<F, E>":"forgiving_base64::Decoder","forgiving_base64::Impossible":"forgiving_base64::Impossible","forgiving_base64::InvalidBase64":"forgiving_base64::InvalidBase64","forgiving_base64::InvalidBase64Details":"forgiving_base64::InvalidBase64Details","mime::Mime":"mime::Mime","mime::MimeParsingError":"mime::MimeParsingError"}}