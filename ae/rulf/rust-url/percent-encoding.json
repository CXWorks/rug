{"dependencies":{"<PercentDecode<'a> as std::clone::Clone>::clone":["PercentDecode","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"<PercentDecode<'a> as std::fmt::Debug>::fmt":["PercentDecode","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::slice::Iter"],"<PercentDecode<'a> as std::iter::Iterator>::next":["PercentDecode","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<PercentDecode<'a> as std::iter::Iterator>::size_hint":["PercentDecode","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<PercentEncode<'a> as std::clone::Clone>::clone":["AsciiSet","PercentEncode"],"<PercentEncode<'a> as std::fmt::Display>::fmt":["AsciiSet","PercentEncode","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<PercentEncode<'a> as std::iter::Iterator>::next":["AsciiSet","PercentEncode","std::marker::Sized","std::option::Option"],"<PercentEncode<'a> as std::iter::Iterator>::size_hint":["AsciiSet","PercentEncode","std::marker::Sized","std::option::Option"],"<impl std::convert::From<PercentDecode<'a>> for std::borrow::Cow<'a, [u8]>>::from":["PercentDecode","std::borrow::Cow","std::borrow::ToOwned","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"<impl std::convert::From<PercentEncode<'a>> for std::borrow::Cow<'a, str>>::from":["AsciiSet","PercentEncode","std::borrow::Cow","std::borrow::ToOwned"],"AsciiSet":["AsciiSet"],"AsciiSet::add":["AsciiSet"],"AsciiSet::contains":["AsciiSet"],"AsciiSet::remove":["AsciiSet"],"AsciiSet::should_percent_encode":["AsciiSet"],"PercentDecode":["PercentDecode","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"PercentDecode::<'a>::decode_utf8":["PercentDecode","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::slice::Iter"],"PercentDecode::<'a>::decode_utf8_lossy":["PercentDecode","std::borrow::Cow","std::borrow::ToOwned","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"PercentDecode::<'a>::if_any":["PercentDecode","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"PercentEncode":["AsciiSet","PercentEncode"],"_static_assert":[],"after_percent_sign":["std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"decode_utf8_lossy":["std::borrow::Cow","std::borrow::ToOwned"],"percent_decode":["PercentDecode","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"percent_decode_str":["PercentDecode","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"percent_encode":["AsciiSet","PercentEncode"],"percent_encode_byte":[],"utf8_percent_encode":["AsciiSet","PercentEncode"]},"glob_path_import":{},"self_to_fn":{"AsciiSet":["impl AsciiSet {\n    /// Called with UTF-8 bytes rather than code points.\n    /// Not used for non-ASCII bytes.\n    const fn contains(&self, byte: u8) -> bool {\n        let chunk = self.mask[byte as usize / BITS_PER_CHUNK];\n        let mask = 1 << (byte as usize % BITS_PER_CHUNK);\n        (chunk & mask) != 0\n    }\n\n    fn should_percent_encode(&self, byte: u8) -> bool {\n        !byte.is_ascii() || self.contains(byte)\n    }\n\n    pub const fn add(&self, byte: u8) -> Self {\n        let mut mask = self.mask;\n        mask[byte as usize / BITS_PER_CHUNK] |= 1 << (byte as usize % BITS_PER_CHUNK);\n        AsciiSet { mask }\n    }\n\n    pub const fn remove(&self, byte: u8) -> Self {\n        let mut mask = self.mask;\n        mask[byte as usize / BITS_PER_CHUNK] &= !(1 << (byte as usize % BITS_PER_CHUNK));\n        AsciiSet { mask }\n    }\n}"],"PercentDecode":["Clone","Debug","impl<'a> Iterator for PercentDecode<'a> {\n    type Item = u8;\n\n    fn next(&mut self) -> Option<u8> {\n        self.bytes.next().map(|&byte| {\n            if byte == b'%' {\n                after_percent_sign(&mut self.bytes).unwrap_or(byte)\n            } else {\n                byte\n            }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let bytes = self.bytes.len();\n        ((bytes + 2) / 3, Some(bytes))\n    }\n}","impl<'a> PercentDecode<'a> {\n    /// If the percent-decoding is different from the input, return it as a new bytes vector.\n    #[cfg(feature = \"std\")]\n    fn if_any(&self) -> Option<Vec<u8>> {\n        let mut bytes_iter = self.bytes.clone();\n        while bytes_iter.any(|&b| b == b'%') {\n            if let Some(decoded_byte) = after_percent_sign(&mut bytes_iter) {\n                let initial_bytes = self.bytes.as_slice();\n                let unchanged_bytes_len = initial_bytes.len() - bytes_iter.len() - 3;\n                let mut decoded = initial_bytes[..unchanged_bytes_len].to_owned();\n                decoded.push(decoded_byte);\n                decoded.extend(PercentDecode { bytes: bytes_iter });\n                return Some(decoded);\n            }\n        }\n        // Nothing to decode\n        None\n    }\n\n    /// Decode the result of percent-decoding as UTF-8.\n    ///\n    /// This is return `Err` when the percent-decoded bytes are not well-formed in UTF-8.\n    #[cfg(feature = \"std\")]\n    pub fn decode_utf8(self) -> Result<Cow<'a, str>, str::Utf8Error> {\n        match self.clone().into() {\n            Cow::Borrowed(bytes) => match str::from_utf8(bytes) {\n                Ok(s) => Ok(s.into()),\n                Err(e) => Err(e),\n            },\n            Cow::Owned(bytes) => match String::from_utf8(bytes) {\n                Ok(s) => Ok(s.into()),\n                Err(e) => Err(e.utf8_error()),\n            },\n        }\n    }\n\n    /// Decode the result of percent-decoding as UTF-8, lossily.\n    ///\n    /// Invalid UTF-8 percent-encoded byte sequences will be replaced ï¿½ U+FFFD,\n    /// the replacement character.\n    #[cfg(feature = \"std\")]\n    pub fn decode_utf8_lossy(self) -> Cow<'a, str> {\n        decode_utf8_lossy(self.clone().into())\n    }\n}"],"PercentEncode":["Clone","impl<'a> Iterator for PercentEncode<'a> {\n    type Item = &'a str;\n\n    fn next(&mut self) -> Option<&'a str> {\n        if let Some((&first_byte, remaining)) = self.bytes.split_first() {\n            if self.ascii_set.should_percent_encode(first_byte) {\n                self.bytes = remaining;\n                Some(percent_encode_byte(first_byte))\n            } else {\n                // The unsafe blocks here are appropriate because the bytes are\n                // confirmed as a subset of UTF-8 in should_percent_encode.\n                for (i, &byte) in remaining.iter().enumerate() {\n                    if self.ascii_set.should_percent_encode(byte) {\n                        // 1 for first_byte + i for previous iterations of this loop\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n                    }\n                }\n                let unchanged_slice = self.bytes;\n                self.bytes = &[][..];\n                Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n            }\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.bytes.is_empty() {\n            (0, Some(0))\n        } else {\n            (1, Some(self.bytes.len()))\n        }\n    }\n}","impl<'a> fmt::Display for PercentEncode<'a> {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        for c in (*self).clone() {\n            formatter.write_str(c)?\n        }\n        Ok(())\n    }\n}"],"std::borrow::Cow":["impl<'a> From<PercentDecode<'a>> for Cow<'a, [u8]> {\n    fn from(iter: PercentDecode<'a>) -> Self {\n        match iter.if_any() {\n            Some(vec) => Cow::Owned(vec),\n            None => Cow::Borrowed(iter.bytes.as_slice()),\n        }\n    }\n}","impl<'a> From<PercentEncode<'a>> for Cow<'a, str> {\n    fn from(mut iter: PercentEncode<'a>) -> Self {\n        match iter.next() {\n            None => \"\".into(),\n            Some(first) => match iter.next() {\n                None => first.into(),\n                Some(second) => {\n                    let mut string = first.to_owned();\n                    string.push_str(second);\n                    string.extend(iter);\n                    string.into()\n                }\n            },\n        }\n    }\n}"]},"single_path_import":{},"srcs":{"<PercentDecode<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<u8>{\n        self.bytes.next().map(|&byte| {\n            if byte == b'%' {\n                after_percent_sign(&mut self.bytes).unwrap_or(byte)\n            } else {\n                byte\n            }\n        })\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"<PercentDecode<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let bytes = self.bytes.len();\n        ((bytes + 2) / 3, Some(bytes))\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"<PercentEncode<'a> as std::fmt::Display>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result{\n        for c in (*self).clone() {\n            formatter.write_str(c)?\n        }\n        Ok(())\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"<PercentEncode<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a str>{\n        if let Some((&first_byte, remaining)) = self.bytes.split_first() {\n            if self.ascii_set.should_percent_encode(first_byte) {\n                self.bytes = remaining;\n                Some(percent_encode_byte(first_byte))\n            } else {\n                // The unsafe blocks here are appropriate because the bytes are\n                // confirmed as a subset of UTF-8 in should_percent_encode.\n                for (i, &byte) in remaining.iter().enumerate() {\n                    if self.ascii_set.should_percent_encode(byte) {\n                        // 1 for first_byte + i for previous iterations of this loop\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n                    }\n                }\n                let unchanged_slice = self.bytes;\n                self.bytes = &[][..];\n                Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"<PercentEncode<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        if self.bytes.is_empty() {\n            (0, Some(0))\n        } else {\n            (1, Some(self.bytes.len()))\n        }\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"<impl std::convert::From<PercentDecode<'a>> for std::borrow::Cow<'a, [u8]>>::from":["fn from(iter: PercentDecode<'a>) -> Self{\n        match iter.if_any() {\n            Some(vec) => Cow::Owned(vec),\n            None => Cow::Borrowed(iter.bytes.as_slice()),\n        }\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"<impl std::convert::From<PercentEncode<'a>> for std::borrow::Cow<'a, str>>::from":["fn from(mut iter: PercentEncode<'a>) -> Self{\n        match iter.next() {\n            None => \"\".into(),\n            Some(first) => match iter.next() {\n                None => first.into(),\n                Some(second) => {\n                    let mut string = first.to_owned();\n                    string.push_str(second);\n                    string.extend(iter);\n                    string.into()\n                }\n            },\n        }\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"AsciiSet":["/// Represents a set of characters or bytes in the ASCII range.\n///\n/// This used in [`percent_encode`] and [`utf8_percent_encode`].\n/// This is simlar to [percent-encode sets](https://url.spec.whatwg.org/#percent-encoded-bytes).\n///\n/// Use the `add` method of an existing set to define a new set. For example:\n///\n/// ```\n/// use percent_encoding::{AsciiSet, CONTROLS};\n///\n/// /// https://url.spec.whatwg.org/#fragment-percent-encode-set\n/// const FRAGMENT: &AsciiSet = &CONTROLS.add(b' ').add(b'\"').add(b'<').add(b'>').add(b'`');\n/// ```\npub struct AsciiSet {\n    mask: [Chunk; ASCII_RANGE_LEN / BITS_PER_CHUNK],\n}","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"AsciiSet::add":["pub const fn add(&self, byte: u8) -> Self{\n        let mut mask = self.mask;\n        mask[byte as usize / BITS_PER_CHUNK] |= 1 << (byte as usize % BITS_PER_CHUNK);\n        AsciiSet { mask }\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"AsciiSet::contains":["/// Called with UTF-8 bytes rather than code points.\n/// Not used for non-ASCII bytes.\nconst fn contains(&self, byte: u8) -> bool{\n        let chunk = self.mask[byte as usize / BITS_PER_CHUNK];\n        let mask = 1 << (byte as usize % BITS_PER_CHUNK);\n        (chunk & mask) != 0\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"AsciiSet::remove":["pub const fn remove(&self, byte: u8) -> Self{\n        let mut mask = self.mask;\n        mask[byte as usize / BITS_PER_CHUNK] &= !(1 << (byte as usize % BITS_PER_CHUNK));\n        AsciiSet { mask }\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"AsciiSet::should_percent_encode":["fn should_percent_encode(&self, byte: u8) -> bool{\n        !byte.is_ascii() || self.contains(byte)\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"PercentDecode":["/// The return type of [`percent_decode`].\npub struct PercentDecode<'a> {\n    bytes: slice::Iter<'a, u8>,\n}","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"PercentDecode::<'a>::decode_utf8":["/// Decode the result of percent-decoding as UTF-8.\n///\n/// This is return `Err` when the percent-decoded bytes are not well-formed in UTF-8.\n#[cfg(feature = \"std\")]\npub fn decode_utf8(self) -> Result<Cow<'a, str>, str::Utf8Error>{\n        match self.clone().into() {\n            Cow::Borrowed(bytes) => match str::from_utf8(bytes) {\n                Ok(s) => Ok(s.into()),\n                Err(e) => Err(e),\n            },\n            Cow::Owned(bytes) => match String::from_utf8(bytes) {\n                Ok(s) => Ok(s.into()),\n                Err(e) => Err(e.utf8_error()),\n            },\n        }\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"PercentDecode::<'a>::decode_utf8_lossy":["/// Decode the result of percent-decoding as UTF-8, lossily.\n///\n/// Invalid UTF-8 percent-encoded byte sequences will be replaced ï¿½ U+FFFD,\n/// the replacement character.\n#[cfg(feature = \"std\")]\npub fn decode_utf8_lossy(self) -> Cow<'a, str>{\n        decode_utf8_lossy(self.clone().into())\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"PercentDecode::<'a>::if_any":["/// If the percent-decoding is different from the input, return it as a new bytes vector.\n#[cfg(feature = \"std\")]\nfn if_any(&self) -> Option<Vec<u8>>{\n        let mut bytes_iter = self.bytes.clone();\n        while bytes_iter.any(|&b| b == b'%') {\n            if let Some(decoded_byte) = after_percent_sign(&mut bytes_iter) {\n                let initial_bytes = self.bytes.as_slice();\n                let unchanged_bytes_len = initial_bytes.len() - bytes_iter.len() - 3;\n                let mut decoded = initial_bytes[..unchanged_bytes_len].to_owned();\n                decoded.push(decoded_byte);\n                decoded.extend(PercentDecode { bytes: bytes_iter });\n                return Some(decoded);\n            }\n        }\n        // Nothing to decode\n        None\n    }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"PercentEncode":["/// The return type of [`percent_encode`] and [`utf8_percent_encode`].\npub struct PercentEncode<'a> {\n    bytes: &'a [u8],\n    ascii_set: &'static AsciiSet,\n}","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"_static_assert":["fn _static_assert(){\n            $(\n                let _ = mem::transmute::<[u8; $bool as usize], u8>;\n            )+\n        }","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"after_percent_sign":["fn after_percent_sign(iter: &mut slice::Iter<'_, u8>) -> Option<u8>{\n    let mut cloned_iter = iter.clone();\n    let h = char::from(*cloned_iter.next()?).to_digit(16)?;\n    let l = char::from(*cloned_iter.next()?).to_digit(16)?;\n    *iter = cloned_iter;\n    Some(h as u8 * 0x10 + l as u8)\n}","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"decode_utf8_lossy":["#[cfg(feature = \"std\")]\nfn decode_utf8_lossy(input: Cow<'_, [u8]>) -> Cow<'_, str>{\n    // Note: This function is duplicated in `form_urlencoded/src/query_encoding.rs`.\n    match input {\n        Cow::Borrowed(bytes) => String::from_utf8_lossy(bytes),\n        Cow::Owned(bytes) => {\n            match String::from_utf8_lossy(&bytes) {\n                Cow::Borrowed(utf8) => {\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8];\n                    raw_utf8 = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }\n                Cow::Owned(s) => Cow::Owned(s),\n            }\n        }\n    }\n}","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"percent_decode":["/// Percent-decode the given bytes.\n///\n/// <https://url.spec.whatwg.org/#percent-decode>\n///\n/// Any sequence of `%` followed by two hexadecimal digits is decoded.\n/// The return type:\n///\n/// * Implements `Into<Cow<u8>>` borrowing `input` when it contains no percent-encoded sequence,\n/// * Implements `Iterator<Item = u8>` and therefore has a `.collect::<Vec<u8>>()` method,\n/// * Has `decode_utf8()` and `decode_utf8_lossy()` methods.\n///\ndoc = r##\"\n# Examples\n\n```\nuse percent_encoding::percent_decode;\n\nassert_eq!(percent_decode(b\"foo%20bar%3f\").decode_utf8().unwrap(), \"foo bar?\");\n```\n\"##\n#[inline]\npub fn percent_decode(input: &[u8]) -> PercentDecode<'_>{\n    PercentDecode {\n        bytes: input.iter(),\n    }\n}","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"percent_decode_str":["/// Percent-decode the given string.\n///\n/// <https://url.spec.whatwg.org/#string-percent-decode>\n///\n/// See [`percent_decode`] regarding the return type.\n#[inline]\npub fn percent_decode_str(input: &str) -> PercentDecode<'_>{\n    percent_decode(input.as_bytes())\n}","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"percent_encode":["/// Percent-encode the given bytes with the given set.\n///\n/// Non-ASCII bytes and bytes in `ascii_set` are encoded.\n///\n/// The return type:\n///\n/// * Implements `Iterator<Item = &str>` and therefore has a `.collect::<String>()` method,\n/// * Implements `Display` and therefore has a `.to_string()` method,\n/// * Implements `Into<Cow<str>>` borrowing `input` when none of its bytes are encoded.\n///\n/// # Examples\n///\n/// ```\n/// use percent_encoding::{percent_encode, NON_ALPHANUMERIC};\n///\n/// assert_eq!(percent_encode(b\"foo bar?\", NON_ALPHANUMERIC).to_string(), \"foo%20bar%3F\");\n/// ```\n#[inline]\npub fn percent_encode<'a>(input: &'a [u8], ascii_set: &'static AsciiSet) -> PercentEncode<'a>{\n    PercentEncode {\n        bytes: input,\n        ascii_set,\n    }\n}","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"percent_encode_byte":["/// Return the percent-encoding of the given byte.\n///\n/// This is unconditional, unlike `percent_encode()` which has an `AsciiSet` parameter.\n///\n/// # Examples\n///\n/// ```\n/// use percent_encoding::percent_encode_byte;\n///\n/// assert_eq!(\"foo bar\".bytes().map(percent_encode_byte).collect::<String>(),\n///            \"%66%6F%6F%20%62%61%72\");\n/// ```\npub fn percent_encode_byte(byte: u8) -> &'static str{\n    let index = usize::from(byte) * 3;\n    &\"\\\n      %00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F\\\n      %10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F\\\n      %20%21%22%23%24%25%26%27%28%29%2A%2B%2C%2D%2E%2F\\\n      %30%31%32%33%34%35%36%37%38%39%3A%3B%3C%3D%3E%3F\\\n      %40%41%42%43%44%45%46%47%48%49%4A%4B%4C%4D%4E%4F\\\n      %50%51%52%53%54%55%56%57%58%59%5A%5B%5C%5D%5E%5F\\\n      %60%61%62%63%64%65%66%67%68%69%6A%6B%6C%6D%6E%6F\\\n      %70%71%72%73%74%75%76%77%78%79%7A%7B%7C%7D%7E%7F\\\n      %80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F\\\n      %90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F\\\n      %A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF\\\n      %B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF\\\n      %C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF\\\n      %D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF\\\n      %E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF\\\n      %F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF\\\n      \"[index..index + 3]\n}","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"],"utf8_percent_encode":["/// Percent-encode the UTF-8 encoding of the given string.\n///\n/// See [`percent_encode`] regarding the return type.\n///\n/// # Examples\n///\n/// ```\n/// use percent_encoding::{utf8_percent_encode, NON_ALPHANUMERIC};\n///\n/// assert_eq!(utf8_percent_encode(\"foo bar?\", NON_ALPHANUMERIC).to_string(), \"foo%20bar%3F\");\n/// ```\n#[inline]\npub fn utf8_percent_encode<'a>(input: &'a str, ascii_set: &'static AsciiSet) -> PercentEncode<'a>{\n    percent_encode(input.as_bytes(), ascii_set)\n}","Real(LocalPath(\"percent_encoding/src/lib.rs\"))"]},"struct_constructor":{"&'a str":["next"],"&'static str":["percent_encode_byte"],"(usize, std::option::Option<usize>)":["size_hint"],"AsciiSet":["add","remove"],"PercentDecode":["clone","percent_decode","percent_decode_str"],"PercentEncode":["clone","percent_encode","utf8_percent_encode"],"bool":["contains","should_percent_encode"],"std::borrow::Cow":["decode_utf8","decode_utf8_lossy","from"],"std::vec::Vec":["if_any"],"u8":["after_percent_sign","next"]},"struct_to_trait":{"PercentDecode":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"PercentEncode":["std::clone::Clone","std::fmt::Display","std::iter::Iterator"],"std::borrow::Cow":["std::convert::From"]},"targets":{"<PercentDecode<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"percent_encoding/src/lib.rs\"))","std::iter::Iterator"],"<PercentDecode<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"percent_encoding/src/lib.rs\"))","std::iter::Iterator"],"<PercentEncode<'a> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"percent_encoding/src/lib.rs\"))","std::fmt::Display"],"<PercentEncode<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"percent_encoding/src/lib.rs\"))","std::iter::Iterator"],"<PercentEncode<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"percent_encoding/src/lib.rs\"))","std::iter::Iterator"],"<impl std::convert::From<PercentDecode<'a>> for std::borrow::Cow<'a, [u8]>>::from":["from","Real(LocalPath(\"percent_encoding/src/lib.rs\"))","std::convert::From"],"<impl std::convert::From<PercentEncode<'a>> for std::borrow::Cow<'a, str>>::from":["from","Real(LocalPath(\"percent_encoding/src/lib.rs\"))","std::convert::From"],"AsciiSet::add":["add","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"AsciiSet::contains":["contains","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"AsciiSet::remove":["remove","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"AsciiSet::should_percent_encode":["should_percent_encode","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"PercentDecode::<'a>::decode_utf8":["decode_utf8","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"PercentDecode::<'a>::decode_utf8_lossy":["decode_utf8_lossy","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"PercentDecode::<'a>::if_any":["if_any","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"_static_assert":["_static_assert","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"after_percent_sign":["after_percent_sign","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"decode_utf8_lossy":["decode_utf8_lossy","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"percent_decode":["percent_decode","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"percent_decode_str":["percent_decode_str","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"percent_encode":["percent_encode","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"percent_encode_byte":["percent_encode_byte","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""],"utf8_percent_encode":["utf8_percent_encode","Real(LocalPath(\"percent_encoding/src/lib.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["PercentDecode","PercentEncode"],"std::convert::From":["std::borrow::Cow"],"std::fmt::Debug":["PercentDecode"],"std::fmt::Display":["PercentEncode"],"std::iter::Iterator":["PercentDecode","PercentEncode"]},"type_to_def_path":{"AsciiSet":"AsciiSet","PercentDecode<'a>":"PercentDecode","PercentEncode<'a>":"PercentEncode"}}