{"dependencies":{"<&'a mut std::string::String as Target>::as_mut_string":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<&'a mut std::string::String as Target>::finish":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ByteSerialize<'a> as std::fmt::Debug>::fmt":["ByteSerialize","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ByteSerialize<'a> as std::iter::Iterator>::next":["ByteSerialize","std::marker::Sized","std::option::Option"],"<ByteSerialize<'a> as std::iter::Iterator>::size_hint":["ByteSerialize","std::marker::Sized","std::option::Option"],"<Parse<'a> as std::clone::Clone>::clone":["Parse"],"<Parse<'a> as std::iter::Iterator>::next":["Parse","std::marker::Sized","std::option::Option"],"<ParseIntoOwned<'a> as std::iter::Iterator>::next":["Parse","ParseIntoOwned","std::marker::Sized","std::option::Option"],"<std::string::String as Target>::as_mut_string":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<std::string::String as Target>::finish":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ByteSerialize":["ByteSerialize"],"Parse":["Parse"],"Parse::<'a>::into_owned":["Parse","ParseIntoOwned"],"ParseIntoOwned":["Parse","ParseIntoOwned"],"Serializer":["Serializer","Target","std::marker::Sized","std::option::Option","std::string::String"],"Serializer::<'a, T>::append_key_only":["Serializer","Target","std::marker::Sized","std::option::Option","std::string::String"],"Serializer::<'a, T>::append_pair":["Serializer","Target","std::marker::Sized","std::option::Option","std::string::String"],"Serializer::<'a, T>::clear":["Serializer","Target","std::marker::Sized","std::option::Option","std::string::String"],"Serializer::<'a, T>::encoding_override":["Serializer","Target","std::marker::Sized","std::option::Option","std::string::String"],"Serializer::<'a, T>::extend_keys_only":["Serializer","Target","std::borrow::Borrow","std::convert::AsRef","std::iter::IntoIterator","std::marker::Sized","std::option::Option","std::string::String"],"Serializer::<'a, T>::extend_pairs":["Serializer","Target","std::borrow::Borrow","std::convert::AsRef","std::iter::IntoIterator","std::marker::Sized","std::option::Option","std::string::String"],"Serializer::<'a, T>::finish":["Serializer","Target","std::marker::Sized","std::option::Option","std::string::String"],"Serializer::<'a, T>::for_suffix":["Serializer","Target","std::marker::Sized","std::option::Option","std::string::String"],"Serializer::<'a, T>::new":["Serializer","Target","std::marker::Sized","std::option::Option","std::string::String"],"Target::as_mut_string":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"Target::finish":[],"append_encoded":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"append_key_only":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"append_pair":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"append_separator_if_needed":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"byte_serialize":["ByteSerialize"],"byte_serialized_unchanged":[],"decode":["std::borrow::Cow","std::borrow::ToOwned"],"decode_utf8_lossy":["std::borrow::Cow","std::borrow::ToOwned"],"encode":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"parse":["Parse"],"replace_plus":["std::borrow::Cow","std::borrow::ToOwned"],"string":["Target","alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"]},"glob_path_import":{},"self_to_fn":{"ByteSerialize":["Debug","impl<'a> Iterator for ByteSerialize<'a> {\n    type Item = &'a str;\n\n    fn next(&mut self) -> Option<&'a str> {\n        if let Some((&first, tail)) = self.bytes.split_first() {\n            if !byte_serialized_unchanged(first) {\n                self.bytes = tail;\n                return Some(if first == b' ' {\n                    \"+\"\n                } else {\n                    percent_encode_byte(first)\n                });\n            }\n            let position = tail.iter().position(|&b| !byte_serialized_unchanged(b));\n            let (unchanged_slice, remaining) = match position {\n                // 1 for first_byte + i unchanged in tail\n                Some(i) => self.bytes.split_at(1 + i),\n                None => (self.bytes, &[][..]),\n            };\n            self.bytes = remaining;\n            // This unsafe is appropriate because we have already checked these\n            // bytes in byte_serialized_unchanged, which checks for a subset\n            // of UTF-8. So we know these bytes are valid UTF-8, and doing\n            // another UTF-8 check would be wasteful.\n            Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.bytes.is_empty() {\n            (0, Some(0))\n        } else {\n            (1, Some(self.bytes.len()))\n        }\n    }\n}"],"Parse":["Clone","Copy","impl<'a> Iterator for Parse<'a> {\n    type Item = (Cow<'a, str>, Cow<'a, str>);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            if self.input.is_empty() {\n                return None;\n            }\n            let mut split2 = self.input.splitn(2, |&b| b == b'&');\n            let sequence = split2.next().unwrap();\n            self.input = split2.next().unwrap_or(&[][..]);\n            if sequence.is_empty() {\n                continue;\n            }\n            let mut split2 = sequence.splitn(2, |&b| b == b'=');\n            let name = split2.next().unwrap();\n            let value = split2.next().unwrap_or(&[][..]);\n            return Some((decode(name), decode(value)));\n        }\n    }\n}","impl<'a> Parse<'a> {\n    /// Return a new iterator that yields pairs of `String` instead of pairs of `Cow<str>`.\n    pub fn into_owned(self) -> ParseIntoOwned<'a> {\n        ParseIntoOwned { inner: self }\n    }\n}"],"ParseIntoOwned":["impl<'a> Iterator for ParseIntoOwned<'a> {\n    type Item = (String, String);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner\n            .next()\n            .map(|(k, v)| (k.into_owned(), v.into_owned()))\n    }\n}"],"Serializer":["impl<'a, T: Target> Serializer<'a, T> {\n    /// Create a new `application/x-www-form-urlencoded` serializer for the given target.\n    ///\n    /// If the target is non-empty,\n    /// its content is assumed to already be in `application/x-www-form-urlencoded` syntax.\n    pub fn new(target: T) -> Self {\n        Self::for_suffix(target, 0)\n    }\n\n    /// Create a new `application/x-www-form-urlencoded` serializer\n    /// for a suffix of the given target.\n    ///\n    /// If that suffix is non-empty,\n    /// its content is assumed to already be in `application/x-www-form-urlencoded` syntax.\n    pub fn for_suffix(mut target: T, start_position: usize) -> Self {\n        if target.as_mut_string().len() < start_position {\n            panic!(\n                \"invalid length {} for target of length {}\",\n                start_position,\n                target.as_mut_string().len()\n            );\n        }\n\n        Serializer {\n            target: Some(target),\n            start_position,\n            encoding: None,\n        }\n    }\n\n    /// Remove any existing name/value pair.\n    ///\n    /// Panics if called after `.finish()`.\n    pub fn clear(&mut self) -> &mut Self {\n        string(&mut self.target).truncate(self.start_position);\n        self\n    }\n\n    /// Set the character encoding to be used for names and values before percent-encoding.\n    pub fn encoding_override(&mut self, new: EncodingOverride<'a>) -> &mut Self {\n        self.encoding = new;\n        self\n    }\n\n    /// Serialize and append a name/value pair.\n    ///\n    /// Panics if called after `.finish()`.\n    pub fn append_pair(&mut self, name: &str, value: &str) -> &mut Self {\n        append_pair(\n            string(&mut self.target),\n            self.start_position,\n            self.encoding,\n            name,\n            value,\n        );\n        self\n    }\n\n    /// Serialize and append a name of parameter without any value.\n    ///\n    /// Panics if called after `.finish()`.\n    pub fn append_key_only(&mut self, name: &str) -> &mut Self {\n        append_key_only(\n            string(&mut self.target),\n            self.start_position,\n            self.encoding,\n            name,\n        );\n        self\n    }\n\n    /// Serialize and append a number of name/value pairs.\n    ///\n    /// This simply calls `append_pair` repeatedly.\n    /// This can be more convenient, so the user doesnâ€™t need to introduce a block\n    /// to limit the scope of `Serializer`â€™s borrow of its string.\n    ///\n    /// Panics if called after `.finish()`.\n    pub fn extend_pairs<I, K, V>(&mut self, iter: I) -> &mut Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<(K, V)>,\n        K: AsRef<str>,\n        V: AsRef<str>,\n    {\n        {\n            let string = string(&mut self.target);\n            for pair in iter {\n                let &(ref k, ref v) = pair.borrow();\n                append_pair(\n                    string,\n                    self.start_position,\n                    self.encoding,\n                    k.as_ref(),\n                    v.as_ref(),\n                );\n            }\n        }\n        self\n    }\n\n    /// Serialize and append a number of names without values.\n    ///\n    /// This simply calls `append_key_only` repeatedly.\n    /// This can be more convenient, so the user doesnâ€™t need to introduce a block\n    /// to limit the scope of `Serializer`â€™s borrow of its string.\n    ///\n    /// Panics if called after `.finish()`.\n    pub fn extend_keys_only<I, K>(&mut self, iter: I) -> &mut Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<K>,\n        K: AsRef<str>,\n    {\n        {\n            let string = string(&mut self.target);\n            for key in iter {\n                let k = key.borrow().as_ref();\n                append_key_only(string, self.start_position, self.encoding, k);\n            }\n        }\n        self\n    }\n\n    /// If this serializer was constructed with a string, take and return that string.\n    ///\n    /// ```rust\n    /// use form_urlencoded;\n    /// let encoded: String = form_urlencoded::Serializer::new(String::new())\n    ///     .append_pair(\"foo\", \"bar & baz\")\n    ///     .append_pair(\"saison\", \"Ã‰tÃ©+hiver\")\n    ///     .finish();\n    /// assert_eq!(encoded, \"foo=bar+%26+baz&saison=%C3%89t%C3%A9%2Bhiver\");\n    /// ```\n    ///\n    /// Panics if called more than once.\n    pub fn finish(&mut self) -> T::Finished {\n        self.target\n            .take()\n            .expect(\"url::form_urlencoded::Serializer double finish\")\n            .finish()\n    }\n}"],"std::string::String":["impl Target for String {\n    fn as_mut_string(&mut self) -> &mut String {\n        self\n    }\n    fn finish(self) -> Self {\n        self\n    }\n    type Finished = Self;\n}"]},"single_path_import":{},"srcs":{"<&'a mut std::string::String as Target>::as_mut_string":["fn as_mut_string(&mut self) -> &mut String{\n        &mut **self\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"<&'a mut std::string::String as Target>::finish":["fn finish(self) -> Self{\n        self\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"<ByteSerialize<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a str>{\n        if let Some((&first, tail)) = self.bytes.split_first() {\n            if !byte_serialized_unchanged(first) {\n                self.bytes = tail;\n                return Some(if first == b' ' {\n                    \"+\"\n                } else {\n                    percent_encode_byte(first)\n                });\n            }\n            let position = tail.iter().position(|&b| !byte_serialized_unchanged(b));\n            let (unchanged_slice, remaining) = match position {\n                // 1 for first_byte + i unchanged in tail\n                Some(i) => self.bytes.split_at(1 + i),\n                None => (self.bytes, &[][..]),\n            };\n            self.bytes = remaining;\n            // This unsafe is appropriate because we have already checked these\n            // bytes in byte_serialized_unchanged, which checks for a subset\n            // of UTF-8. So we know these bytes are valid UTF-8, and doing\n            // another UTF-8 check would be wasteful.\n            Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"<ByteSerialize<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        if self.bytes.is_empty() {\n            (0, Some(0))\n        } else {\n            (1, Some(self.bytes.len()))\n        }\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"<Parse<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        loop {\n            if self.input.is_empty() {\n                return None;\n            }\n            let mut split2 = self.input.splitn(2, |&b| b == b'&');\n            let sequence = split2.next().unwrap();\n            self.input = split2.next().unwrap_or(&[][..]);\n            if sequence.is_empty() {\n                continue;\n            }\n            let mut split2 = sequence.splitn(2, |&b| b == b'=');\n            let name = split2.next().unwrap();\n            let value = split2.next().unwrap_or(&[][..]);\n            return Some((decode(name), decode(value)));\n        }\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"<ParseIntoOwned<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.inner\n            .next()\n            .map(|(k, v)| (k.into_owned(), v.into_owned()))\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"<std::string::String as Target>::as_mut_string":["fn as_mut_string(&mut self) -> &mut String{\n        self\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"<std::string::String as Target>::finish":["fn finish(self) -> Self{\n        self\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"ByteSerialize":["/// Return value of `byte_serialize()`.\npub struct ByteSerialize<'a> {\n    bytes: &'a [u8],\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Parse":["/// The return type of `parse()`.\npub struct Parse<'a> {\n    input: &'a [u8],\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Parse::<'a>::into_owned":["/// Return a new iterator that yields pairs of `String` instead of pairs of `Cow<str>`.\npub fn into_owned(self) -> ParseIntoOwned<'a>{\n        ParseIntoOwned { inner: self }\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"ParseIntoOwned":["/// Like `Parse`, but yields pairs of `String` instead of pairs of `Cow<str>`.\npub struct ParseIntoOwned<'a> {\n    inner: Parse<'a>,\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Serializer":["/// The [`application/x-www-form-urlencoded` serializer](\n/// https://url.spec.whatwg.org/#concept-urlencoded-serializer).\npub struct Serializer<'a, T: Target> {\n    target: Option<T>,\n    start_position: usize,\n    encoding: EncodingOverride<'a>,\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Serializer::<'a, T>::append_key_only":["/// Serialize and append a name of parameter without any value.\n///\n/// Panics if called after `.finish()`.\npub fn append_key_only(&mut self, name: &str) -> &mut Self{\n        append_key_only(\n            string(&mut self.target),\n            self.start_position,\n            self.encoding,\n            name,\n        );\n        self\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Serializer::<'a, T>::append_pair":["/// Serialize and append a name/value pair.\n///\n/// Panics if called after `.finish()`.\npub fn append_pair(&mut self, name: &str, value: &str) -> &mut Self{\n        append_pair(\n            string(&mut self.target),\n            self.start_position,\n            self.encoding,\n            name,\n            value,\n        );\n        self\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Serializer::<'a, T>::clear":["/// Remove any existing name/value pair.\n///\n/// Panics if called after `.finish()`.\npub fn clear(&mut self) -> &mut Self{\n        string(&mut self.target).truncate(self.start_position);\n        self\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Serializer::<'a, T>::encoding_override":["/// Set the character encoding to be used for names and values before percent-encoding.\npub fn encoding_override(&mut self, new: EncodingOverride<'a>) -> &mut Self{\n        self.encoding = new;\n        self\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Serializer::<'a, T>::extend_keys_only":["/// Serialize and append a number of names without values.\n///\n/// This simply calls `append_key_only` repeatedly.\n/// This can be more convenient, so the user doesnâ€™t need to introduce a block\n/// to limit the scope of `Serializer`â€™s borrow of its string.\n///\n/// Panics if called after `.finish()`.\npub fn extend_keys_only<I, K>(&mut self, iter: I) -> &mut Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<K>,\n        K: AsRef<str>,{\n        {\n            let string = string(&mut self.target);\n            for key in iter {\n                let k = key.borrow().as_ref();\n                append_key_only(string, self.start_position, self.encoding, k);\n            }\n        }\n        self\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Serializer::<'a, T>::extend_pairs":["/// Serialize and append a number of name/value pairs.\n///\n/// This simply calls `append_pair` repeatedly.\n/// This can be more convenient, so the user doesnâ€™t need to introduce a block\n/// to limit the scope of `Serializer`â€™s borrow of its string.\n///\n/// Panics if called after `.finish()`.\npub fn extend_pairs<I, K, V>(&mut self, iter: I) -> &mut Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<(K, V)>,\n        K: AsRef<str>,\n        V: AsRef<str>,{\n        {\n            let string = string(&mut self.target);\n            for pair in iter {\n                let &(ref k, ref v) = pair.borrow();\n                append_pair(\n                    string,\n                    self.start_position,\n                    self.encoding,\n                    k.as_ref(),\n                    v.as_ref(),\n                );\n            }\n        }\n        self\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Serializer::<'a, T>::finish":["/// If this serializer was constructed with a string, take and return that string.\n///\n/// ```rust\n/// use form_urlencoded;\n/// let encoded: String = form_urlencoded::Serializer::new(String::new())\n///     .append_pair(\"foo\", \"bar & baz\")\n///     .append_pair(\"saison\", \"Ã‰tÃ©+hiver\")\n///     .finish();\n/// assert_eq!(encoded, \"foo=bar+%26+baz&saison=%C3%89t%C3%A9%2Bhiver\");\n/// ```\n///\n/// Panics if called more than once.\npub fn finish(&mut self) -> T::Finished{\n        self.target\n            .take()\n            .expect(\"url::form_urlencoded::Serializer double finish\")\n            .finish()\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Serializer::<'a, T>::for_suffix":["/// Create a new `application/x-www-form-urlencoded` serializer\n/// for a suffix of the given target.\n///\n/// If that suffix is non-empty,\n/// its content is assumed to already be in `application/x-www-form-urlencoded` syntax.\npub fn for_suffix(mut target: T, start_position: usize) -> Self{\n        if target.as_mut_string().len() < start_position {\n            panic!(\n                \"invalid length {} for target of length {}\",\n                start_position,\n                target.as_mut_string().len()\n            );\n        }\n\n        Serializer {\n            target: Some(target),\n            start_position,\n            encoding: None,\n        }\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Serializer::<'a, T>::new":["/// Create a new `application/x-www-form-urlencoded` serializer for the given target.\n///\n/// If the target is non-empty,\n/// its content is assumed to already be in `application/x-www-form-urlencoded` syntax.\npub fn new(target: T) -> Self{\n        Self::for_suffix(target, 0)\n    }","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"Target":["pub trait Target {\n    fn as_mut_string(&mut self) -> &mut String;\n    fn finish(self) -> Self::Finished;\n    type Finished;\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"append_encoded":["fn append_encoded(s: &str, string: &mut String, encoding: EncodingOverride<'_>){\n    string.extend(byte_serialize(&encode(encoding, s)))\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"append_key_only":["fn append_key_only(\n    string: &mut String,\n    start_position: usize,\n    encoding: EncodingOverride,\n    name: &str,\n){\n    append_separator_if_needed(string, start_position);\n    append_encoded(name, string, encoding);\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"append_pair":["fn append_pair(\n    string: &mut String,\n    start_position: usize,\n    encoding: EncodingOverride<'_>,\n    name: &str,\n    value: &str,\n){\n    append_separator_if_needed(string, start_position);\n    append_encoded(name, string, encoding);\n    string.push('=');\n    append_encoded(value, string, encoding);\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"append_separator_if_needed":["fn append_separator_if_needed(string: &mut String, start_position: usize){\n    if string.len() > start_position {\n        string.push('&')\n    }\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"byte_serialize":["/// The [`application/x-www-form-urlencoded` byte serializer](\n/// https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer).\n///\n/// Return an iterator of `&str` slices.\npub fn byte_serialize(input: &[u8]) -> ByteSerialize<'_>{\n    ByteSerialize { bytes: input }\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"byte_serialized_unchanged":["fn byte_serialized_unchanged(byte: u8) -> bool{\n    matches!(byte, b'*' | b'-' | b'.' | b'0' ..= b'9' | b'A' ..= b'Z' | b'_' | b'a' ..= b'z')\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"decode":["fn decode(input: &[u8]) -> Cow<'_, str>{\n    let replaced = replace_plus(input);\n    decode_utf8_lossy(match percent_decode(&replaced).into() {\n        Cow::Owned(vec) => Cow::Owned(vec),\n        Cow::Borrowed(_) => replaced,\n    })\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"decode_utf8_lossy":["pub(crate) fn decode_utf8_lossy(input: Cow<'_, [u8]>) -> Cow<'_, str>{\n    // Note: This function is duplicated in `percent_encoding/lib.rs`.\n    match input {\n        Cow::Borrowed(bytes) => String::from_utf8_lossy(bytes),\n        Cow::Owned(bytes) => {\n            match String::from_utf8_lossy(&bytes) {\n                Cow::Borrowed(utf8) => {\n                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n                    // be sure our original bytes were valid UTF-8. This is because\n                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n                    // to allocate a new owned string to back the Cow so it could\n                    // replace invalid bytes with a placeholder.\n\n                    // First we do a debug_assert to confirm our description above.\n                    let raw_utf8: *const [u8];\n                    raw_utf8 = utf8.as_bytes();\n                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n\n                    // Given we know the original input bytes are valid UTF-8,\n                    // and we have ownership of those bytes, we re-use them and\n                    // return a Cow::Owned here.\n                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n                }\n                Cow::Owned(s) => Cow::Owned(s),\n            }\n        }\n    }\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"encode":["pub(crate) fn encode<'a>(encoding_override: EncodingOverride<'_>, input: &'a str) -> Cow<'a, [u8]>{\n    if let Some(o) = encoding_override {\n        return o(input);\n    }\n    input.as_bytes().into()\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"parse":["/// Convert a byte string in the `application/x-www-form-urlencoded` syntax\n/// into a iterator of (name, value) pairs.\n///\n/// Use `parse(input.as_bytes())` to parse a `&str` string.\n///\n/// The names and values are percent-decoded. For instance, `%23first=%25try%25` will be\n/// converted to `[(\"#first\", \"%try%\")]`.\n#[inline]\npub fn parse(input: &[u8]) -> Parse<'_>{\n    Parse { input }\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"replace_plus":["/// Replace b'+' with b' '\nfn replace_plus(input: &[u8]) -> Cow<'_, [u8]>{\n    match input.iter().position(|&b| b == b'+') {\n        None => Cow::Borrowed(input),\n        Some(first_position) => {\n            let mut replaced = input.to_owned();\n            replaced[first_position] = b' ';\n            for byte in &mut replaced[first_position + 1..] {\n                if *byte == b'+' {\n                    *byte = b' ';\n                }\n            }\n            Cow::Owned(replaced)\n        }\n    }\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"],"string":["fn string<T: Target>(target: &mut Option<T>) -> &mut String{\n    target\n        .as_mut()\n        .expect(\"url::form_urlencoded::Serializer finished\")\n        .as_mut_string()\n}","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))"]},"struct_constructor":{"&'a str":["next"],"&mut std::string::String":["as_mut_string","string"],"(usize, std::option::Option<usize>)":["size_hint"],"<Parse<'a> as std::iter::Iterator>::Item":["next"],"<ParseIntoOwned<'a> as std::iter::Iterator>::Item":["next"],"<Self as Target>::Finished":["finish"],"<T as Target>::Finished":["finish"],"ByteSerialize":["byte_serialize"],"Parse":["clone","parse"],"ParseIntoOwned":["into_owned"],"Serializer":["for_suffix","new"],"bool":["byte_serialized_unchanged"],"std::borrow::Cow":["decode","encode","replace_plus"]},"struct_to_trait":{"ByteSerialize":["std::fmt::Debug","std::iter::Iterator"],"Parse":["std::clone::Clone","std::iter::Iterator","std::marker::Copy"],"ParseIntoOwned":["std::iter::Iterator"],"std::string::String":["Target"]},"targets":{"<&'a mut std::string::String as Target>::as_mut_string":["as_mut_string","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))","Target"],"<&'a mut std::string::String as Target>::finish":["finish","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))","Target"],"<ByteSerialize<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))","std::iter::Iterator"],"<ByteSerialize<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))","std::iter::Iterator"],"<Parse<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))","std::iter::Iterator"],"<ParseIntoOwned<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))","std::iter::Iterator"],"<std::string::String as Target>::as_mut_string":["as_mut_string","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))","Target"],"<std::string::String as Target>::finish":["finish","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))","Target"],"Parse::<'a>::into_owned":["into_owned","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"Serializer::<'a, T>::append_key_only":["append_key_only","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"Serializer::<'a, T>::append_pair":["append_pair","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"Serializer::<'a, T>::clear":["clear","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"Serializer::<'a, T>::encoding_override":["encoding_override","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"Serializer::<'a, T>::extend_keys_only":["extend_keys_only","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"Serializer::<'a, T>::extend_pairs":["extend_pairs","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"Serializer::<'a, T>::finish":["finish","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"Serializer::<'a, T>::for_suffix":["for_suffix","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"Serializer::<'a, T>::new":["new","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"append_encoded":["append_encoded","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"append_key_only":["append_key_only","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"append_pair":["append_pair","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"append_separator_if_needed":["append_separator_if_needed","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"byte_serialize":["byte_serialize","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"byte_serialized_unchanged":["byte_serialized_unchanged","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"decode":["decode","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"decode_utf8_lossy":["decode_utf8_lossy","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"encode":["encode","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"parse":["parse","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"replace_plus":["replace_plus","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""],"string":["string","Real(LocalPath(\"form_urlencoded/src/lib.rs\"))",""]},"trait_to_struct":{"Target":["std::string::String"],"std::clone::Clone":["Parse"],"std::fmt::Debug":["ByteSerialize"],"std::iter::Iterator":["ByteSerialize","Parse","ParseIntoOwned"],"std::marker::Copy":["Parse"]},"type_to_def_path":{"ByteSerialize<'a>":"ByteSerialize","Parse<'a>":"Parse","ParseIntoOwned<'a>":"ParseIntoOwned","Serializer<'a, T>":"Serializer"}}