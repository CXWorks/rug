{"dependencies":{"<uts46::Config as std::clone::Clone>::clone":["uts46::Config"],"<uts46::Config as std::default::Default>::default":["uts46::Config"],"<uts46::Errors as std::default::Default>::default":["uts46::Errors"],"<uts46::Errors as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","uts46::Errors"],"<uts46::Errors as std::fmt::Display>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","uts46::Errors"],"<uts46::Mapping as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","uts46::Mapping","uts46::StringTableSlice"],"<uts46::StringTableSlice as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","uts46::StringTableSlice"],"domain_to_ascii":["std::marker::Sized","std::result::Result"],"domain_to_ascii_strict":["std::marker::Sized","std::result::Result"],"domain_to_unicode":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"punycode::adapt":[],"punycode::decode":["std::marker::Sized","std::option::Option"],"punycode::decode_to_string":["std::marker::Sized","std::option::Option"],"punycode::encode":["std::marker::Sized","std::option::Option"],"punycode::encode_into":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::clone::Clone","std::iter::Iterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","uts46::Config"],"punycode::encode_str":["std::marker::Sized","std::option::Option"],"punycode::value_to_digit":[],"uts46::<impl std::convert::From<uts46::Errors> for std::result::Result<(), uts46::Errors>>::from":["std::marker::Sized","std::result::Result","uts46::Errors"],"uts46::Config":["uts46::Config"],"uts46::Config::check_hyphens":["uts46::Config"],"uts46::Config::to_ascii":["std::marker::Sized","std::result::Result","uts46::Config"],"uts46::Config::to_unicode":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","uts46::Config"],"uts46::Config::transitional_processing":["uts46::Config"],"uts46::Config::use_std3_ascii_rules":["uts46::Config"],"uts46::Config::verify_dns_length":["uts46::Config"],"uts46::Errors":["uts46::Errors"],"uts46::Mapping":["uts46::Mapping","uts46::StringTableSlice"],"uts46::Range":["uts46::Range"],"uts46::StringTableSlice":["uts46::StringTableSlice"],"uts46::decode_slice":["uts46::StringTableSlice"],"uts46::find_char":["uts46::Mapping","uts46::StringTableSlice"],"uts46::is_bidi_domain":[],"uts46::is_valid":["uts46::Config"],"uts46::map_char":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","uts46::Config","uts46::Errors"],"uts46::passes_bidi":[],"uts46::processing":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","uts46::Config","uts46::Errors"]},"glob_path_import":{},"self_to_fn":{"std::result::Result":["impl From<Errors> for Result<(), Errors> {\n    fn from(e: Errors) -> Result<(), Errors> {\n        let failed = e.punycode\n            || e.validity_criteria\n            || e.disallowed_by_std3_ascii_rules\n            || e.disallowed_mapped_in_std3\n            || e.disallowed_character\n            || e.too_long_for_dns\n            || e.too_short_for_dns;\n        if !failed {\n            Ok(())\n        } else {\n            Err(e)\n        }\n    }\n}"],"uts46::Config":["Clone","Copy","impl Config {\n    #[inline]\n    pub fn use_std3_ascii_rules(mut self, value: bool) -> Self {\n        self.use_std3_ascii_rules = value;\n        self\n    }\n\n    #[inline]\n    pub fn transitional_processing(mut self, value: bool) -> Self {\n        self.transitional_processing = value;\n        self\n    }\n\n    #[inline]\n    pub fn verify_dns_length(mut self, value: bool) -> Self {\n        self.verify_dns_length = value;\n        self\n    }\n\n    #[inline]\n    pub fn check_hyphens(mut self, value: bool) -> Self {\n        self.check_hyphens = value;\n        self\n    }\n\n    /// http://www.unicode.org/reports/tr46/#ToASCII\n    pub fn to_ascii(self, domain: &str) -> Result<String, Errors> {\n        let mut result = String::new();\n        let mut first = true;\n        let (domain, mut errors) = processing(domain, self);\n        for label in domain.split('.') {\n            if !first {\n                result.push('.');\n            }\n            first = false;\n            if label.is_ascii() {\n                result.push_str(label);\n            } else {\n                match punycode::encode_str(label) {\n                    Some(x) => {\n                        result.push_str(PUNYCODE_PREFIX);\n                        result.push_str(&x);\n                    }\n                    None => {\n                        errors.punycode = true;\n                    }\n                }\n            }\n        }\n\n        if self.verify_dns_length {\n            let domain = if result.ends_with('.') {\n                &result[..result.len() - 1]\n            } else {\n                &*result\n            };\n            if domain.is_empty() || domain.split('.').any(|label| label.is_empty()) {\n                errors.too_short_for_dns = true;\n            }\n            if domain.len() > 253 || domain.split('.').any(|label| label.len() > 63) {\n                errors.too_long_for_dns = true;\n            }\n        }\n\n        Result::from(errors).map(|()| result)\n    }\n\n    /// http://www.unicode.org/reports/tr46/#ToUnicode\n    pub fn to_unicode(self, domain: &str) -> (String, Result<(), Errors>) {\n        let (domain, errors) = processing(domain, self);\n        (domain, errors.into())\n    }\n}","impl Default for Config {\n    fn default() -> Self {\n        Config {\n            use_std3_ascii_rules: false,\n            transitional_processing: false,\n            check_hyphens: false,\n            // check_bidi: true,\n            // check_joiners: true,\n\n            // Only use for to_ascii, not to_unicode\n            verify_dns_length: false,\n        }\n    }\n}"],"uts46::Errors":["Debug","Default","impl StdError for Errors {}","impl fmt::Display for Errors {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self, f)\n    }\n}"],"uts46::Mapping":["Debug"],"uts46::StringTableSlice":["Debug"]},"single_path_import":{"uts46::Config":"Config","uts46::Errors":"Errors"},"srcs":{"<uts46::Config as std::default::Default>::default":["fn default() -> Self{\n        Config {\n            use_std3_ascii_rules: false,\n            transitional_processing: false,\n            check_hyphens: false,\n            // check_bidi: true,\n            // check_joiners: true,\n\n            // Only use for to_ascii, not to_unicode\n            verify_dns_length: false,\n        }\n    }","Real(LocalPath(\"idna/src/uts46.rs\"))"],"<uts46::Errors as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Debug::fmt(self, f)\n    }","Real(LocalPath(\"idna/src/uts46.rs\"))"],"domain_to_ascii":["/// The [domain to ASCII](https://url.spec.whatwg.org/#concept-domain-to-ascii) algorithm.\n///\n/// Return the ASCII representation a domain name,\n/// normalizing characters (upper-case to lower-case and other kinds of equivalence)\n/// and using Punycode as necessary.\n///\n/// This process may fail.\npub fn domain_to_ascii(domain: &str) -> Result<String, uts46::Errors>{\n    Config::default().to_ascii(domain)\n}","Real(LocalPath(\"idna/src/lib.rs\"))"],"domain_to_ascii_strict":["/// The [domain to ASCII](https://url.spec.whatwg.org/#concept-domain-to-ascii) algorithm,\n/// with the `beStrict` flag set.\npub fn domain_to_ascii_strict(domain: &str) -> Result<String, uts46::Errors>{\n    Config::default()\n        .use_std3_ascii_rules(true)\n        .verify_dns_length(true)\n        .to_ascii(domain)\n}","Real(LocalPath(\"idna/src/lib.rs\"))"],"domain_to_unicode":["/// The [domain to Unicode](https://url.spec.whatwg.org/#concept-domain-to-unicode) algorithm.\n///\n/// Return the Unicode representation of a domain name,\n/// normalizing characters (upper-case to lower-case and other kinds of equivalence)\n/// and decoding Punycode as necessary.\n///\n/// This may indicate [syntax violations](https://url.spec.whatwg.org/#syntax-violation)\n/// but always returns a string for the mapped domain.\npub fn domain_to_unicode(domain: &str) -> (String, Result<(), uts46::Errors>){\n    Config::default().to_unicode(domain)\n}","Real(LocalPath(\"idna/src/lib.rs\"))"],"punycode::adapt":["#[inline]\nfn adapt(mut delta: u32, num_points: u32, first_time: bool) -> u32{\n    delta /= if first_time { DAMP } else { 2 };\n    delta += delta / num_points;\n    let mut k = 0;\n    while delta > ((BASE - T_MIN) * T_MAX) / 2 {\n        delta /= BASE - T_MIN;\n        k += BASE;\n    }\n    k + (((BASE - T_MIN + 1) * delta) / (delta + SKEW))\n}","Real(LocalPath(\"idna/src/punycode.rs\"))"],"punycode::decode":["/// Convert Punycode to Unicode.\n///\n/// Return None on malformed input or overflow.\n/// Overflow can only happen on inputs that take more than\n/// 63 encoded bytes, the DNS limit on domain name labels.\npub fn decode(input: &str) -> Option<Vec<char>>{\n    // Handle \"basic\" (ASCII) code points.\n    // They are encoded as-is before the last delimiter, if any.\n    let (mut output, input) = match input.rfind(DELIMITER) {\n        None => (Vec::new(), input),\n        Some(position) => (\n            input[..position].chars().collect(),\n            if position > 0 {\n                &input[position + 1..]\n            } else {\n                input\n            },\n        ),\n    };\n    let mut code_point = INITIAL_N;\n    let mut bias = INITIAL_BIAS;\n    let mut i = 0;\n    let mut iter = input.bytes();\n    loop {\n        let previous_i = i;\n        let mut weight = 1;\n        let mut k = BASE;\n        let mut byte = match iter.next() {\n            None => break,\n            Some(byte) => byte,\n        };\n        // Decode a generalized variable-length integer into delta,\n        // which gets added to i.\n        loop {\n            let digit = match byte {\n                byte @ b'0'..=b'9' => byte - b'0' + 26,\n                byte @ b'A'..=b'Z' => byte - b'A',\n                byte @ b'a'..=b'z' => byte - b'a',\n                _ => return None,\n            } as u32;\n            if digit > (u32::MAX - i) / weight {\n                return None; // Overflow\n            }\n            i += digit * weight;\n            let t = if k <= bias {\n                T_MIN\n            } else if k >= bias + T_MAX {\n                T_MAX\n            } else {\n                k - bias\n            };\n            if digit < t {\n                break;\n            }\n            if weight > u32::MAX / (BASE - t) {\n                return None; // Overflow\n            }\n            weight *= BASE - t;\n            k += BASE;\n            byte = match iter.next() {\n                None => return None, // End of input before the end of this delta\n                Some(byte) => byte,\n            };\n        }\n        let length = output.len() as u32;\n        bias = adapt(i - previous_i, length + 1, previous_i == 0);\n        if i / (length + 1) > u32::MAX - code_point {\n            return None; // Overflow\n        }\n        // i was supposed to wrap around from length+1 to 0,\n        // incrementing code_point each time.\n        code_point += i / (length + 1);\n        i %= length + 1;\n        let c = match char::from_u32(code_point) {\n            Some(c) => c,\n            None => return None,\n        };\n        output.insert(i as usize, c);\n        i += 1;\n    }\n    Some(output)\n}","Real(LocalPath(\"idna/src/punycode.rs\"))"],"punycode::decode_to_string":["/// Convert Punycode to an Unicode `String`.\n///\n/// This is a convenience wrapper around `decode`.\n#[inline]\npub fn decode_to_string(input: &str) -> Option<String>{\n    decode(input).map(|chars| chars.into_iter().collect())\n}","Real(LocalPath(\"idna/src/punycode.rs\"))"],"punycode::encode":["/// Convert Unicode to Punycode.\n///\n/// Return None on overflow, which can only happen on inputs that would take more than\n/// 63 encoded bytes, the DNS limit on domain name labels.\npub fn encode(input: &[char]) -> Option<String>{\n    let mut buf = String::with_capacity(input.len());\n    encode_into(input.iter().copied(), &mut buf)\n        .ok()\n        .map(|()| buf)\n}","Real(LocalPath(\"idna/src/punycode.rs\"))"],"punycode::encode_into":["fn encode_into<I>(input: I, output: &mut String) -> Result<(), ()>\nwhere\n    I: Iterator<Item = char> + Clone,{\n    // Handle \"basic\" (ASCII) code points. They are encoded as-is.\n    let (mut input_length, mut basic_length) = (0, 0);\n    for c in input.clone() {\n        input_length += 1;\n        if c.is_ascii() {\n            output.push(c);\n            basic_length += 1;\n        }\n    }\n\n    if basic_length > 0 {\n        output.push_str(\"-\")\n    }\n    let mut code_point = INITIAL_N;\n    let mut delta = 0;\n    let mut bias = INITIAL_BIAS;\n    let mut processed = basic_length;\n    while processed < input_length {\n        // All code points < code_point have been handled already.\n        // Find the next larger one.\n        let min_code_point = input\n            .clone()\n            .map(|c| c as u32)\n            .filter(|&c| c >= code_point)\n            .min()\n            .unwrap();\n        if min_code_point - code_point > (u32::MAX - delta) / (processed + 1) {\n            return Err(()); // Overflow\n        }\n        // Increase delta to advance the decoder’s <code_point,i> state to <min_code_point,0>\n        delta += (min_code_point - code_point) * (processed + 1);\n        code_point = min_code_point;\n        for c in input.clone() {\n            let c = c as u32;\n            if c < code_point {\n                delta += 1;\n                if delta == 0 {\n                    return Err(()); // Overflow\n                }\n            }\n            if c == code_point {\n                // Represent delta as a generalized variable-length integer:\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.push(value_to_digit(value));\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.push(value_to_digit(q));\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }\n        }\n        delta += 1;\n        code_point += 1;\n    }\n    Ok(())\n}","Real(LocalPath(\"idna/src/punycode.rs\"))"],"punycode::encode_str":["/// Convert an Unicode `str` to Punycode.\n///\n/// This is a convenience wrapper around `encode`.\n#[inline]\npub fn encode_str(input: &str) -> Option<String>{\n    let mut buf = String::with_capacity(input.len());\n    encode_into(input.chars(), &mut buf).ok().map(|()| buf)\n}","Real(LocalPath(\"idna/src/punycode.rs\"))"],"punycode::value_to_digit":["#[inline]\nfn value_to_digit(value: u32) -> char{\n    match value {\n        0..=25 => (value as u8 + b'a') as char,       // a..z\n        26..=35 => (value as u8 - 26 + b'0') as char, // 0..9\n        _ => panic!(),\n    }\n}","Real(LocalPath(\"idna/src/punycode.rs\"))"],"uts46::<impl std::convert::From<uts46::Errors> for std::result::Result<(), uts46::Errors>>::from":["fn from(e: Errors) -> Result<(), Errors>{\n        let failed = e.punycode\n            || e.validity_criteria\n            || e.disallowed_by_std3_ascii_rules\n            || e.disallowed_mapped_in_std3\n            || e.disallowed_character\n            || e.too_long_for_dns\n            || e.too_short_for_dns;\n        if !failed {\n            Ok(())\n        } else {\n            Err(e)\n        }\n    }","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::Config":["pub struct Config {\n    use_std3_ascii_rules: bool,\n    transitional_processing: bool,\n    verify_dns_length: bool,\n    check_hyphens: bool,\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::Config::check_hyphens":["#[inline]\npub fn check_hyphens(mut self, value: bool) -> Self{\n        self.check_hyphens = value;\n        self\n    }","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::Config::to_ascii":["/// http://www.unicode.org/reports/tr46/#ToASCII\npub fn to_ascii(self, domain: &str) -> Result<String, Errors>{\n        let mut result = String::new();\n        let mut first = true;\n        let (domain, mut errors) = processing(domain, self);\n        for label in domain.split('.') {\n            if !first {\n                result.push('.');\n            }\n            first = false;\n            if label.is_ascii() {\n                result.push_str(label);\n            } else {\n                match punycode::encode_str(label) {\n                    Some(x) => {\n                        result.push_str(PUNYCODE_PREFIX);\n                        result.push_str(&x);\n                    }\n                    None => {\n                        errors.punycode = true;\n                    }\n                }\n            }\n        }\n\n        if self.verify_dns_length {\n            let domain = if result.ends_with('.') {\n                &result[..result.len() - 1]\n            } else {\n                &*result\n            };\n            if domain.is_empty() || domain.split('.').any(|label| label.is_empty()) {\n                errors.too_short_for_dns = true;\n            }\n            if domain.len() > 253 || domain.split('.').any(|label| label.len() > 63) {\n                errors.too_long_for_dns = true;\n            }\n        }\n\n        Result::from(errors).map(|()| result)\n    }","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::Config::to_unicode":["/// http://www.unicode.org/reports/tr46/#ToUnicode\npub fn to_unicode(self, domain: &str) -> (String, Result<(), Errors>){\n        let (domain, errors) = processing(domain, self);\n        (domain, errors.into())\n    }","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::Config::transitional_processing":["#[inline]\npub fn transitional_processing(mut self, value: bool) -> Self{\n        self.transitional_processing = value;\n        self\n    }","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::Config::use_std3_ascii_rules":["#[inline]\npub fn use_std3_ascii_rules(mut self, value: bool) -> Self{\n        self.use_std3_ascii_rules = value;\n        self\n    }","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::Config::verify_dns_length":["#[inline]\npub fn verify_dns_length(mut self, value: bool) -> Self{\n        self.verify_dns_length = value;\n        self\n    }","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::Errors":["/// Errors recorded during UTS #46 processing.\n///\n/// This is opaque for now, indicating what types of errors have been encountered at least once.\n/// More details may be exposed in the future.\npub struct Errors {\n    punycode: bool,\n    // https://unicode.org/reports/tr46/#Validity_Criteria\n    validity_criteria: bool,\n    disallowed_by_std3_ascii_rules: bool,\n    disallowed_mapped_in_std3: bool,\n    disallowed_character: bool,\n    too_long_for_dns: bool,\n    too_short_for_dns: bool,\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::Mapping":["#[repr(u8)]\nenum Mapping {\n    Valid,\n    Ignored,\n    Mapped(StringTableSlice),\n    Deviation(StringTableSlice),\n    Disallowed,\n    DisallowedStd3Valid,\n    DisallowedStd3Mapped(StringTableSlice),\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::Range":["struct Range {\n    from: char,\n    to: char,\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::StringTableSlice":["struct StringTableSlice {\n    // Store these as separate fields so the structure will have an\n    // alignment of 1 and thus pack better into the Mapping enum, below.\n    byte_start_lo: u8,\n    byte_start_hi: u8,\n    byte_len: u8,\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::decode_slice":["fn decode_slice(slice: &StringTableSlice) -> &'static str{\n    let lo = slice.byte_start_lo as usize;\n    let hi = slice.byte_start_hi as usize;\n    let start = (hi << 8) | lo;\n    let len = slice.byte_len as usize;\n    &STRING_TABLE[start..(start + len)]\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::find_char":["fn find_char(codepoint: char) -> &'static Mapping{\n    let r = TABLE.binary_search_by(|ref range| {\n        if codepoint > range.to {\n            Less\n        } else if codepoint < range.from {\n            Greater\n        } else {\n            Equal\n        }\n    });\n    r.ok()\n        .map(|i| {\n            const SINGLE_MARKER: u16 = 1 << 15;\n\n            let x = INDEX_TABLE[i];\n            let single = (x & SINGLE_MARKER) != 0;\n            let offset = !SINGLE_MARKER & x;\n\n            if single {\n                &MAPPING_TABLE[offset as usize]\n            } else {\n                &MAPPING_TABLE[(offset + (codepoint as u16 - TABLE[i].from as u16)) as usize]\n            }\n        })\n        .unwrap()\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::is_bidi_domain":["fn is_bidi_domain(s: &str) -> bool{\n    for c in s.chars() {\n        if c.is_ascii_graphic() {\n            continue;\n        }\n        match bidi_class(c) {\n            BidiClass::R | BidiClass::AL | BidiClass::AN => return true,\n            _ => {}\n        }\n    }\n    false\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::is_valid":["/// Check the validity criteria for the given label\n///\n/// V1 (NFC) and V8 (Bidi) are checked inside `processing()` to prevent doing duplicate work.\n///\n/// http://www.unicode.org/reports/tr46/#Validity_Criteria\nfn is_valid(label: &str, config: Config) -> bool{\n    let first_char = label.chars().next();\n    if first_char == None {\n        // Empty string, pass\n        return true;\n    }\n\n    // V2: No U+002D HYPHEN-MINUS in both third and fourth positions.\n    //\n    // NOTE: Spec says that the label must not contain a HYPHEN-MINUS character in both the\n    // third and fourth positions. But nobody follows this criteria. See the spec issue below:\n    // https://github.com/whatwg/url/issues/53\n\n    // V3: neither begin nor end with a U+002D HYPHEN-MINUS\n    if config.check_hyphens && (label.starts_with('-') || label.ends_with('-')) {\n        return false;\n    }\n\n    // V4: not contain a U+002E FULL STOP\n    //\n    // Here, label can't contain '.' since the input is from .split('.')\n\n    // V5: not begin with a GC=Mark\n    if is_combining_mark(first_char.unwrap()) {\n        return false;\n    }\n\n    // V6: Check against Mapping Table\n    if label.chars().any(|c| match *find_char(c) {\n        Mapping::Valid => false,\n        Mapping::Deviation(_) => config.transitional_processing,\n        Mapping::DisallowedStd3Valid => config.use_std3_ascii_rules,\n        _ => true,\n    }) {\n        return false;\n    }\n\n    // V7: ContextJ rules\n    //\n    // TODO: Implement rules and add *CheckJoiners* flag.\n\n    // V8: Bidi rules are checked inside `processing()`\n    true\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::map_char":["fn map_char(codepoint: char, config: Config, output: &mut String, errors: &mut Errors){\n    if let '.' | '-' | 'a'..='z' | '0'..='9' = codepoint {\n        output.push(codepoint);\n        return;\n    }\n\n    match *find_char(codepoint) {\n        Mapping::Valid => output.push(codepoint),\n        Mapping::Ignored => {}\n        Mapping::Mapped(ref slice) => output.push_str(decode_slice(slice)),\n        Mapping::Deviation(ref slice) => {\n            if config.transitional_processing {\n                output.push_str(decode_slice(slice))\n            } else {\n                output.push(codepoint)\n            }\n        }\n        Mapping::Disallowed => {\n            errors.disallowed_character = true;\n            output.push(codepoint);\n        }\n        Mapping::DisallowedStd3Valid => {\n            if config.use_std3_ascii_rules {\n                errors.disallowed_by_std3_ascii_rules = true;\n            }\n            output.push(codepoint)\n        }\n        Mapping::DisallowedStd3Mapped(ref slice) => {\n            if config.use_std3_ascii_rules {\n                errors.disallowed_mapped_in_std3 = true;\n            }\n            output.push_str(decode_slice(slice))\n        }\n    }\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::passes_bidi":["fn passes_bidi(label: &str, is_bidi_domain: bool) -> bool{\n    // Rule 0: Bidi Rules apply to Bidi Domain Names: a name with at least one RTL label.  A label\n    // is RTL if it contains at least one character of bidi class R, AL or AN.\n    if !is_bidi_domain {\n        return true;\n    }\n\n    let mut chars = label.chars();\n    let first_char_class = match chars.next() {\n        Some(c) => bidi_class(c),\n        None => return true, // empty string\n    };\n\n    match first_char_class {\n        // LTR label\n        BidiClass::L => {\n            // Rule 5\n            while let Some(c) = chars.next() {\n                if !matches!(\n                    bidi_class(c),\n                    BidiClass::L\n                        | BidiClass::EN\n                        | BidiClass::ES\n                        | BidiClass::CS\n                        | BidiClass::ET\n                        | BidiClass::ON\n                        | BidiClass::BN\n                        | BidiClass::NSM\n                ) {\n                    return false;\n                }\n            }\n\n            // Rule 6\n            // must end in L or EN followed by 0 or more NSM\n            let mut rev_chars = label.chars().rev();\n            let mut last_non_nsm = rev_chars.next();\n            loop {\n                match last_non_nsm {\n                    Some(c) if bidi_class(c) == BidiClass::NSM => {\n                        last_non_nsm = rev_chars.next();\n                        continue;\n                    }\n                    _ => {\n                        break;\n                    }\n                }\n            }\n            match last_non_nsm {\n                Some(c) if bidi_class(c) == BidiClass::L || bidi_class(c) == BidiClass::EN => {}\n                Some(_) => {\n                    return false;\n                }\n                _ => {}\n            }\n        }\n\n        // RTL label\n        BidiClass::R | BidiClass::AL => {\n            let mut found_en = false;\n            let mut found_an = false;\n\n            // Rule 2\n            for c in chars {\n                let char_class = bidi_class(c);\n                if char_class == BidiClass::EN {\n                    found_en = true;\n                } else if char_class == BidiClass::AN {\n                    found_an = true;\n                }\n\n                if !matches!(\n                    char_class,\n                    BidiClass::R\n                        | BidiClass::AL\n                        | BidiClass::AN\n                        | BidiClass::EN\n                        | BidiClass::ES\n                        | BidiClass::CS\n                        | BidiClass::ET\n                        | BidiClass::ON\n                        | BidiClass::BN\n                        | BidiClass::NSM\n                ) {\n                    return false;\n                }\n            }\n            // Rule 3\n            let mut rev_chars = label.chars().rev();\n            let mut last = rev_chars.next();\n            loop {\n                // must end in L or EN followed by 0 or more NSM\n                match last {\n                    Some(c) if bidi_class(c) == BidiClass::NSM => {\n                        last = rev_chars.next();\n                        continue;\n                    }\n                    _ => {\n                        break;\n                    }\n                }\n            }\n            match last {\n                Some(c)\n                    if matches!(\n                        bidi_class(c),\n                        BidiClass::R | BidiClass::AL | BidiClass::EN | BidiClass::AN\n                    ) => {}\n                _ => {\n                    return false;\n                }\n            }\n\n            // Rule 4\n            if found_an && found_en {\n                return false;\n            }\n        }\n\n        // Rule 1: Should start with L or R/AL\n        _ => {\n            return false;\n        }\n    }\n\n    true\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"],"uts46::processing":["/// http://www.unicode.org/reports/tr46/#Processing\nfn processing(domain: &str, config: Config) -> (String, Errors){\n    // Weed out the simple cases: only allow all lowercase ASCII characters and digits where none\n    // of the labels start with PUNYCODE_PREFIX and labels don't start or end with hyphen.\n    let (mut prev, mut simple, mut puny_prefix) = ('?', !domain.is_empty(), 0);\n    for c in domain.chars() {\n        if c == '.' {\n            if prev == '-' {\n                simple = false;\n                break;\n            }\n            puny_prefix = 0;\n            continue;\n        } else if puny_prefix == 0 && c == '-' {\n            simple = false;\n            break;\n        } else if puny_prefix < 5 {\n            if c == ['x', 'n', '-', '-'][puny_prefix] {\n                puny_prefix += 1;\n                if puny_prefix == 4 {\n                    simple = false;\n                    break;\n                }\n            } else {\n                puny_prefix = 5;\n            }\n        }\n        if !c.is_ascii_lowercase() && !c.is_ascii_digit() {\n            simple = false;\n            break;\n        }\n        prev = c;\n    }\n    if simple {\n        return (domain.to_owned(), Errors::default());\n    }\n\n    let mut errors = Errors::default();\n    let mut mapped = String::with_capacity(domain.len());\n    for c in domain.chars() {\n        map_char(c, config, &mut mapped, &mut errors)\n    }\n    let mut normalized = String::with_capacity(mapped.len());\n    normalized.extend(mapped.nfc());\n\n    let mut validated = String::new();\n    let non_transitional = config.transitional_processing(false);\n    let (mut first, mut valid, mut has_bidi_labels) = (true, true, false);\n    for label in normalized.split('.') {\n        if !first {\n            validated.push('.');\n        }\n        first = false;\n        if label.starts_with(PUNYCODE_PREFIX) {\n            match punycode::decode_to_string(&label[PUNYCODE_PREFIX.len()..]) {\n                Some(decoded_label) => {\n                    if !has_bidi_labels {\n                        has_bidi_labels |= is_bidi_domain(&decoded_label);\n                    }\n\n                    if valid\n                        && (!is_nfc(&decoded_label) || !is_valid(&decoded_label, non_transitional))\n                    {\n                        valid = false;\n                    }\n                    validated.push_str(&decoded_label)\n                }\n                None => {\n                    has_bidi_labels = true;\n                    errors.punycode = true;\n                }\n            }\n        } else {\n            if !has_bidi_labels {\n                has_bidi_labels |= is_bidi_domain(label);\n            }\n\n            // `normalized` is already `NFC` so we can skip that check\n            valid &= is_valid(label, config);\n            validated.push_str(label)\n        }\n    }\n\n    for label in validated.split('.') {\n        // V8: Bidi rules\n        //\n        // TODO: Add *CheckBidi* flag\n        if !passes_bidi(label, has_bidi_labels) {\n            valid = false;\n            break;\n        }\n    }\n\n    if !valid {\n        errors.validity_criteria = true;\n    }\n\n    (validated, errors)\n}","Real(LocalPath(\"idna/src/uts46.rs\"))"]},"struct_constructor":{"&'static str":["decode_slice"],"&'static uts46::Mapping":["find_char"],"(std::string::String, std::result::Result<(), uts46::Errors>)":["domain_to_unicode","to_unicode"],"(std::string::String, uts46::Errors)":["processing"],"bool":["is_bidi_domain","is_valid"],"char":["value_to_digit"],"std::string::String":["decode_to_string","domain_to_ascii","domain_to_ascii_strict","encode","encode_str","to_ascii"],"std::vec::Vec":["decode"],"uts46::Config":["clone","default"],"uts46::Errors":["default"]},"struct_to_trait":{"std::result::Result":["std::convert::From"],"uts46::Config":["std::clone::Clone","std::default::Default","std::marker::Copy"],"uts46::Errors":["std::default::Default","std::error::Error","std::fmt::Debug","std::fmt::Display"],"uts46::Mapping":["std::fmt::Debug"],"uts46::StringTableSlice":["std::fmt::Debug"]},"targets":{"<uts46::Config as std::default::Default>::default":["default","Real(LocalPath(\"idna/src/uts46.rs\"))","std::default::Default"],"<uts46::Errors as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"idna/src/uts46.rs\"))","std::fmt::Display"],"domain_to_ascii":["domain_to_ascii","Real(LocalPath(\"idna/src/lib.rs\"))",""],"domain_to_ascii_strict":["domain_to_ascii_strict","Real(LocalPath(\"idna/src/lib.rs\"))",""],"domain_to_unicode":["domain_to_unicode","Real(LocalPath(\"idna/src/lib.rs\"))",""],"punycode::adapt":["adapt","Real(LocalPath(\"idna/src/punycode.rs\"))",""],"punycode::decode":["decode","Real(LocalPath(\"idna/src/punycode.rs\"))",""],"punycode::decode_to_string":["decode_to_string","Real(LocalPath(\"idna/src/punycode.rs\"))",""],"punycode::encode":["encode","Real(LocalPath(\"idna/src/punycode.rs\"))",""],"punycode::encode_into":["encode_into","Real(LocalPath(\"idna/src/punycode.rs\"))",""],"punycode::encode_str":["encode_str","Real(LocalPath(\"idna/src/punycode.rs\"))",""],"punycode::value_to_digit":["value_to_digit","Real(LocalPath(\"idna/src/punycode.rs\"))",""],"uts46::<impl std::convert::From<uts46::Errors> for std::result::Result<(), uts46::Errors>>::from":["from","Real(LocalPath(\"idna/src/uts46.rs\"))","std::convert::From"],"uts46::Config::check_hyphens":["check_hyphens","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::Config::to_ascii":["to_ascii","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::Config::to_unicode":["to_unicode","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::Config::transitional_processing":["transitional_processing","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::Config::use_std3_ascii_rules":["use_std3_ascii_rules","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::Config::verify_dns_length":["verify_dns_length","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::decode_slice":["decode_slice","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::find_char":["find_char","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::is_bidi_domain":["is_bidi_domain","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::is_valid":["is_valid","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::map_char":["map_char","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::passes_bidi":["passes_bidi","Real(LocalPath(\"idna/src/uts46.rs\"))",""],"uts46::processing":["processing","Real(LocalPath(\"idna/src/uts46.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["uts46::Config"],"std::convert::From":["std::result::Result"],"std::default::Default":["uts46::Config","uts46::Errors"],"std::error::Error":["uts46::Errors"],"std::fmt::Debug":["uts46::Errors","uts46::Mapping","uts46::StringTableSlice"],"std::fmt::Display":["uts46::Errors"],"std::marker::Copy":["uts46::Config"]},"type_to_def_path":{"uts46::Config":"uts46::Config","uts46::Errors":"uts46::Errors","uts46::Mapping":"uts46::Mapping","uts46::Range":"uts46::Range","uts46::StringTableSlice":"uts46::StringTableSlice"}}