{"dependencies":{"<F32<S> as rand_distr::Distribution<f32>>::sample":["F32","rand::Rng","std::marker::Sized"],"<F32<S> as std::clone::Clone>::clone":["F32","std::marker::Sized"],"<F32<S> as std::fmt::Debug>::fmt":["F32","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<SamplingStrategy as std::clone::Clone>::clone":["SamplingStrategy"],"<SamplingStrategy as std::fmt::Debug>::fmt":["SamplingStrategy","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::random":["F32","ndarray::ArrayBase","ndarray::RawData","ndarray::ShapeBuilder","rand_distr::Distribution","std::marker::Sized"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::random_using":["F32","ndarray::ArrayBase","ndarray::RawData","ndarray::ShapeBuilder","rand::Rng","rand_distr::Distribution","std::marker::Sized"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::sample_axis":["F32","SamplingStrategy","ndarray::ArrayBase","ndarray::Axis","ndarray::RawData","ndarray::RemoveAxis","std::marker::Copy","std::marker::Sized"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::sample_axis_using":["F32","SamplingStrategy","ndarray::ArrayBase","ndarray::Axis","ndarray::RawData","ndarray::RemoveAxis","rand::Rng","std::marker::Copy","std::marker::Sized"],"F32":["F32","std::marker::Sized"],"RandomExt::random":["F32","ndarray::ArrayBase","ndarray::RawData","ndarray::ShapeBuilder","rand_distr::Distribution","std::marker::Sized"],"RandomExt::random_using":["F32","ndarray::ArrayBase","ndarray::RawData","ndarray::ShapeBuilder","rand::Rng","rand_distr::Distribution","std::marker::Sized"],"RandomExt::sample_axis":["F32","SamplingStrategy","ndarray::ArrayBase","ndarray::Axis","ndarray::RawData","ndarray::RemoveAxis","std::marker::Copy","std::marker::Sized"],"RandomExt::sample_axis_using":["F32","SamplingStrategy","ndarray::ArrayBase","ndarray::Axis","ndarray::RawData","ndarray::RemoveAxis","rand::Rng","std::marker::Copy","std::marker::Sized"],"SamplingStrategy":["SamplingStrategy"],"get_rng":["rand::prelude::SmallRng"]},"glob_path_import":{"rand":"rand::","rand_distr":"rand_distr::"},"self_to_fn":{"F32":["Clone","Copy","Debug","impl<S> Distribution<f32> for F32<S>\nwhere\n    S: Distribution<f64>,\n{\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> f32 {\n        self.0.sample(rng) as f32\n    }\n}"],"SamplingStrategy":["Clone","Debug"],"ndarray::ArrayBase":["impl<S, A, D> RandomExt<S, A, D> for ArrayBase<S, D>\nwhere\n    S: DataOwned<Elem = A>,\n    D: Dimension,\n{\n    fn random<Sh, IdS>(shape: Sh, dist: IdS) -> ArrayBase<S, D>\n    where\n        IdS: Distribution<S::Elem>,\n        Sh: ShapeBuilder<Dim = D>,\n    {\n        Self::random_using(shape, dist, &mut get_rng())\n    }\n\n    fn random_using<Sh, IdS, R>(shape: Sh, dist: IdS, rng: &mut R) -> ArrayBase<S, D>\n    where\n        IdS: Distribution<S::Elem>,\n        R: Rng + ?Sized,\n        Sh: ShapeBuilder<Dim = D>,\n    {\n        Self::from_shape_simple_fn(shape, move || dist.sample(rng))\n    }\n\n    fn sample_axis(&self, axis: Axis, n_samples: usize, strategy: SamplingStrategy) -> Array<A, D>\n    where\n        A: Copy,\n        D: RemoveAxis,\n    {\n        self.sample_axis_using(axis, n_samples, strategy, &mut get_rng())\n    }\n\n    fn sample_axis_using<R>(\n        &self,\n        axis: Axis,\n        n_samples: usize,\n        strategy: SamplingStrategy,\n        rng: &mut R,\n    ) -> Array<A, D>\n    where\n        R: Rng + ?Sized,\n        A: Copy,\n        D: RemoveAxis,\n    {\n        let indices: Vec<_> = match strategy {\n            SamplingStrategy::WithReplacement => {\n                let distribution = Uniform::from(0..self.len_of(axis));\n                (0..n_samples).map(|_| distribution.sample(rng)).collect()\n            }\n            SamplingStrategy::WithoutReplacement => {\n                index::sample(rng, self.len_of(axis), n_samples).into_vec()\n            }\n        };\n        self.select(axis, &indices)\n    }\n}"]},"single_path_import":{},"srcs":{"<F32<S> as rand_distr::Distribution<f32>>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> f32{\n        self.0.sample(rng) as f32\n    }","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::random":["fn random<Sh, IdS>(shape: Sh, dist: IdS) -> ArrayBase<S, D>\n    where\n        IdS: Distribution<S::Elem>,\n        Sh: ShapeBuilder<Dim = D>,{\n        Self::random_using(shape, dist, &mut get_rng())\n    }","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::random_using":["fn random_using<Sh, IdS, R>(shape: Sh, dist: IdS, rng: &mut R) -> ArrayBase<S, D>\n    where\n        IdS: Distribution<S::Elem>,\n        R: Rng + ?Sized,\n        Sh: ShapeBuilder<Dim = D>,{\n        Self::from_shape_simple_fn(shape, move || dist.sample(rng))\n    }","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::sample_axis":["fn sample_axis(&self, axis: Axis, n_samples: usize, strategy: SamplingStrategy) -> Array<A, D>\n    where\n        A: Copy,\n        D: RemoveAxis,{\n        self.sample_axis_using(axis, n_samples, strategy, &mut get_rng())\n    }","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::sample_axis_using":["fn sample_axis_using<R>(\n        &self,\n        axis: Axis,\n        n_samples: usize,\n        strategy: SamplingStrategy,\n        rng: &mut R,\n    ) -> Array<A, D>\n    where\n        R: Rng + ?Sized,\n        A: Copy,\n        D: RemoveAxis,{\n        let indices: Vec<_> = match strategy {\n            SamplingStrategy::WithReplacement => {\n                let distribution = Uniform::from(0..self.len_of(axis));\n                (0..n_samples).map(|_| distribution.sample(rng)).collect()\n            }\n            SamplingStrategy::WithoutReplacement => {\n                index::sample(rng, self.len_of(axis), n_samples).into_vec()\n            }\n        };\n        self.select(axis, &indices)\n    }","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))"],"F32":["/// A wrapper type that allows casting f64 distributions to f32\n///\n/// ```\n/// use ndarray::Array;\n/// use ndarray_rand::{RandomExt, F32};\n/// use ndarray_rand::rand_distr::Normal;\n///\n/// # fn main() {\n/// let distribution_f64 = Normal::new(0., 1.).expect(\"Failed to create normal distribution\");\n/// let a = Array::random((2, 5), F32(distribution_f64));\n/// println!(\"{:8.4}\", a);\n/// // Example Output:\n/// // [[ -0.6910,   1.1730,   1.0902,  -0.4092,  -1.7340],\n/// //  [ -0.6810,   0.1678,  -0.9487,   0.3150,   1.2981]]\n/// # }\npub struct F32<S>(pub S);","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))"],"RandomExt":["/// Constructors for n-dimensional arrays with random elements.\n///\n/// This trait extends ndarrayâ€™s `ArrayBase` and can not be implemented\n/// for other types.\n///\n/// The default RNG is a fast automatically seeded rng (currently\n/// [`rand::rngs::SmallRng`](https://docs.rs/rand/0.7/rand/rngs/struct.SmallRng.html)\n/// seeded from [`rand::thread_rng`](https://docs.rs/rand/0.7/rand/fn.thread_rng.html)).\n///\n/// Note that `SmallRng` is cheap to initialize and fast, but it may generate\n/// low-quality random numbers, and reproducibility is not guaranteed. See its\n/// documentation for information. You can select a different RNG with\n/// [`.random_using()`](#tymethod.random_using).\npub trait RandomExt<S, A, D>\nwhere\n    S: DataOwned<Elem = A>,\n    D: Dimension,\n{\n    /// Create an array with shape `dim` with elements drawn from\n    /// `distribution` using the default RNG.\n    ///\n    /// ***Panics*** if creation of the RNG fails or if the number of elements\n    /// overflows usize.\n    ///\n    /// ```\n    /// use ndarray::Array;\n    /// use ndarray_rand::RandomExt;\n    /// use ndarray_rand::rand_distr::Uniform;\n    ///\n    /// # fn main() {\n    /// let a = Array::random((2, 5), Uniform::new(0., 10.));\n    /// println!(\"{:8.4}\", a);\n    /// // Example Output:\n    /// // [[  8.6900,   6.9824,   3.8922,   6.5861,   2.4890],\n    /// //  [  0.0914,   5.5186,   5.8135,   5.2361,   3.1879]]\n    /// # }\n    fn random<Sh, IdS>(shape: Sh, distribution: IdS) -> ArrayBase<S, D>\n    where\n        IdS: Distribution<S::Elem>,\n        Sh: ShapeBuilder<Dim = D>;\n\n    /// Create an array with shape `dim` with elements drawn from\n    /// `distribution`, using a specific Rng `rng`.\n    ///\n    /// ***Panics*** if the number of elements overflows usize.\n    ///\n    /// ```\n    /// use ndarray::Array;\n    /// use ndarray_rand::RandomExt;\n    /// use ndarray_rand::rand::SeedableRng;\n    /// use ndarray_rand::rand_distr::Uniform;\n    /// use rand_isaac::isaac64::Isaac64Rng;\n    ///\n    /// # fn main() {\n    /// // Get a seeded random number generator for reproducibility (Isaac64 algorithm)\n    /// let seed = 42;\n    /// let mut rng = Isaac64Rng::seed_from_u64(seed);\n    ///\n    /// // Generate a random array using `rng`\n    /// let a = Array::random_using((2, 5), Uniform::new(0., 10.), &mut rng);\n    /// println!(\"{:8.4}\", a);\n    /// // Example Output:\n    /// // [[  8.6900,   6.9824,   3.8922,   6.5861,   2.4890],\n    /// //  [  0.0914,   5.5186,   5.8135,   5.2361,   3.1879]]\n    /// # }\n    fn random_using<Sh, IdS, R>(shape: Sh, distribution: IdS, rng: &mut R) -> ArrayBase<S, D>\n    where\n        IdS: Distribution<S::Elem>,\n        R: Rng + ?Sized,\n        Sh: ShapeBuilder<Dim = D>;\n\n    /// Sample `n_samples` lanes slicing along `axis` using the default RNG.\n    ///\n    /// If `strategy==SamplingStrategy::WithoutReplacement`, each lane can only be sampled once.\n    /// If `strategy==SamplingStrategy::WithReplacement`, each lane can be sampled multiple times.\n    ///\n    /// ***Panics*** when:\n    /// - creation of the RNG fails;\n    /// - `n_samples` is greater than the length of `axis` (if sampling without replacement);\n    /// - length of `axis` is 0.\n    ///\n    /// ```\n    /// use ndarray::{array, Axis};\n    /// use ndarray_rand::{RandomExt, SamplingStrategy};\n    ///\n    /// # fn main() {\n    /// let a = array![\n    ///     [1., 2., 3.],\n    ///     [4., 5., 6.],\n    ///     [7., 8., 9.],\n    ///     [10., 11., 12.],\n    /// ];\n    /// // Sample 2 rows, without replacement\n    /// let sample_rows = a.sample_axis(Axis(0), 2, SamplingStrategy::WithoutReplacement);\n    /// println!(\"{:?}\", sample_rows);\n    /// // Example Output: (1st and 3rd rows)\n    /// // [\n    /// //  [1., 2., 3.],\n    /// //  [7., 8., 9.]\n    /// // ]\n    /// // Sample 2 columns, with replacement\n    /// let sample_columns = a.sample_axis(Axis(1), 1, SamplingStrategy::WithReplacement);\n    /// println!(\"{:?}\", sample_columns);\n    /// // Example Output: (2nd column, sampled twice)\n    /// // [\n    /// //  [2., 2.],\n    /// //  [5., 5.],\n    /// //  [8., 8.],\n    /// //  [11., 11.]\n    /// // ]\n    /// # }\n    /// ```\n    fn sample_axis(&self, axis: Axis, n_samples: usize, strategy: SamplingStrategy) -> Array<A, D>\n    where\n        A: Copy,\n        D: RemoveAxis;\n\n    /// Sample `n_samples` lanes slicing along `axis` using the specified RNG `rng`.\n    ///\n    /// If `strategy==SamplingStrategy::WithoutReplacement`, each lane can only be sampled once.\n    /// If `strategy==SamplingStrategy::WithReplacement`, each lane can be sampled multiple times.\n    ///\n    /// ***Panics*** when:\n    /// - creation of the RNG fails;\n    /// - `n_samples` is greater than the length of `axis` (if sampling without replacement);\n    /// - length of `axis` is 0.\n    ///\n    /// ```\n    /// use ndarray::{array, Axis};\n    /// use ndarray_rand::{RandomExt, SamplingStrategy};\n    /// use ndarray_rand::rand::SeedableRng;\n    /// use rand_isaac::isaac64::Isaac64Rng;\n    ///\n    /// # fn main() {\n    /// // Get a seeded random number generator for reproducibility (Isaac64 algorithm)\n    /// let seed = 42;\n    /// let mut rng = Isaac64Rng::seed_from_u64(seed);\n    ///\n    /// let a = array![\n    ///     [1., 2., 3.],\n    ///     [4., 5., 6.],\n    ///     [7., 8., 9.],\n    ///     [10., 11., 12.],\n    /// ];\n    /// // Sample 2 rows, without replacement\n    /// let sample_rows = a.sample_axis_using(Axis(0), 2, SamplingStrategy::WithoutReplacement, &mut rng);\n    /// println!(\"{:?}\", sample_rows);\n    /// // Example Output: (1st and 3rd rows)\n    /// // [\n    /// //  [1., 2., 3.],\n    /// //  [7., 8., 9.]\n    /// // ]\n    ///\n    /// // Sample 2 columns, with replacement\n    /// let sample_columns = a.sample_axis_using(Axis(1), 1, SamplingStrategy::WithReplacement, &mut rng);\n    /// println!(\"{:?}\", sample_columns);\n    /// // Example Output: (2nd column, sampled twice)\n    /// // [\n    /// //  [2., 2.],\n    /// //  [5., 5.],\n    /// //  [8., 8.],\n    /// //  [11., 11.]\n    /// // ]\n    /// # }\n    /// ```\n    fn sample_axis_using<R>(\n        &self,\n        axis: Axis,\n        n_samples: usize,\n        strategy: SamplingStrategy,\n        rng: &mut R,\n    ) -> Array<A, D>\n    where\n        R: Rng + ?Sized,\n        A: Copy,\n        D: RemoveAxis;\n}","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))"],"SamplingStrategy":["/// Used as parameter in [`sample_axis`] and [`sample_axis_using`] to determine\n/// if lanes from the original array should only be sampled once (*without replacement*) or\n/// multiple times (*with replacement*).\n///\n/// [`sample_axis`]: trait.RandomExt.html#tymethod.sample_axis\n/// [`sample_axis_using`]: trait.RandomExt.html#tymethod.sample_axis_using\npub enum SamplingStrategy {\n    WithReplacement,\n    WithoutReplacement,\n}","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))"],"get_rng":["fn get_rng() -> SmallRng{\n    SmallRng::from_rng(thread_rng()).expect(\"create SmallRng from thread_rng failed\")\n}","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))"]},"struct_constructor":{"F32":["clone"],"SamplingStrategy":["clone"],"f32":["sample"],"ndarray::ArrayBase":["random","random_using","sample_axis","sample_axis_using"],"rand::prelude::SmallRng":["get_rng"]},"struct_to_trait":{"F32":["rand_distr::Distribution","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"SamplingStrategy":["std::clone::Clone","std::fmt::Debug"],"ndarray::ArrayBase":["RandomExt"]},"targets":{"<F32<S> as rand_distr::Distribution<f32>>::sample":["sample","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))","rand_distr::Distribution"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::random":["random","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))","RandomExt"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::random_using":["random_using","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))","RandomExt"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::sample_axis":["sample_axis","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))","RandomExt"],"<ndarray::ArrayBase<S, D> as RandomExt<S, A, D>>::sample_axis_using":["sample_axis_using","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))","RandomExt"],"get_rng":["get_rng","Real(LocalPath(\"ndarray-rand/src/lib.rs\"))",""]},"trait_to_struct":{"RandomExt":["ndarray::ArrayBase"],"rand_distr::Distribution":["F32"],"std::clone::Clone":["F32","SamplingStrategy"],"std::fmt::Debug":["F32","SamplingStrategy"],"std::marker::Copy":["F32"]},"type_to_def_path":{"F32<S>":"F32","SamplingStrategy":"SamplingStrategy"}}