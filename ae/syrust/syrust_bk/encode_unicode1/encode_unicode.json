{"dependencies":{"<I as traits::IterExt>::to_bytes":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf8_iterators::Utf8CharSplitter"],"<I as traits::IterExt>::to_units":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf16_iterators::Utf16CharSplitter"],"<I as traits::IterExt>::to_utf16chars":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"<I as traits::IterExt>::to_utf8chars":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char"],"<S as traits::SliceExt>::utf16char_indices":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","utf16_char::Utf16Char"],"<S as traits::SliceExt>::utf8char_indices":["decoding_iterators::Utf8CharDecoder","std::borrow::Borrow","utf16_char::Utf16Char"],"<char as traits::CharExt>::from_u32_detailed":["std::marker::Sized","std::result::Result"],"<char as traits::CharExt>::from_utf16_array":["std::marker::Sized","std::result::Result"],"<char as traits::CharExt>::from_utf16_array_unchecked":[],"<char as traits::CharExt>::from_utf16_slice_start":["std::marker::Sized","std::result::Result"],"<char as traits::CharExt>::from_utf16_tuple":["std::marker::Sized","std::option::Option","std::result::Result"],"<char as traits::CharExt>::from_utf16_tuple_unchecked":["std::marker::Sized","std::option::Option"],"<char as traits::CharExt>::from_utf8_array":["std::marker::Sized","std::result::Result"],"<char as traits::CharExt>::from_utf8_exact_slice_unchecked":[],"<char as traits::CharExt>::from_utf8_slice_start":["std::marker::Sized","std::result::Result"],"<char as traits::CharExt>::iter_utf16_units":["utf16_iterators::Utf16Iterator"],"<char as traits::CharExt>::iter_utf8_bytes":["utf8_iterators::Utf8Iterator"],"<char as traits::CharExt>::to_utf16":["utf16_char::Utf16Char"],"<char as traits::CharExt>::to_utf16_array":[],"<char as traits::CharExt>::to_utf16_tuple":["std::marker::Sized","std::option::Option"],"<char as traits::CharExt>::to_utf8":["utf8_char::Utf8Char"],"<char as traits::CharExt>::to_utf8_array":[],"<decoding_iterators::Utf16CharDecoder<'a> as std::clone::Clone>::clone":["decoding_iterators::Utf16CharDecoder"],"<decoding_iterators::Utf16CharDecoder<'a> as std::convert::From<&'a [u16]>>::from":["decoding_iterators::Utf16CharDecoder"],"<decoding_iterators::Utf16CharDecoder<'a> as std::default::Default>::default":["decoding_iterators::Utf16CharDecoder"],"<decoding_iterators::Utf16CharDecoder<'a> as std::fmt::Debug>::fmt":["decoding_iterators::Utf16CharDecoder","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<decoding_iterators::Utf16CharDecoder<'a> as std::iter::Iterator>::next":["decoding_iterators::Utf16CharDecoder","std::marker::Sized","std::option::Option"],"<decoding_iterators::Utf16CharDecoder<'a> as std::iter::Iterator>::size_hint":["decoding_iterators::Utf16CharDecoder","std::marker::Sized","std::option::Option"],"<decoding_iterators::Utf16CharMerger<B, I> as std::clone::Clone>::clone":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"<decoding_iterators::Utf16CharMerger<B, I> as std::convert::From<T>>::from":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"<decoding_iterators::Utf16CharMerger<B, I> as std::default::Default>::default":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"<decoding_iterators::Utf16CharMerger<B, I> as std::fmt::Debug>::fmt":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","std::borrow::Borrow","std::fmt::Formatter","std::iter::Iterator","std::marker::Sized","std::option::Option","std::result::Result","utf16_char::Utf16Char"],"<decoding_iterators::Utf16CharMerger<B, I> as std::iter::Iterator>::next":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"<decoding_iterators::Utf16CharMerger<B, I> as std::iter::Iterator>::size_hint":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"<decoding_iterators::Utf8CharDecoder<'a> as std::clone::Clone>::clone":["decoding_iterators::Utf8CharDecoder"],"<decoding_iterators::Utf8CharDecoder<'a> as std::convert::From<&'a [u8]>>::from":["decoding_iterators::Utf8CharDecoder"],"<decoding_iterators::Utf8CharDecoder<'a> as std::default::Default>::default":["decoding_iterators::Utf8CharDecoder"],"<decoding_iterators::Utf8CharDecoder<'a> as std::fmt::Debug>::fmt":["decoding_iterators::Utf8CharDecoder","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<decoding_iterators::Utf8CharDecoder<'a> as std::iter::DoubleEndedIterator>::next_back":["decoding_iterators::Utf8CharDecoder","std::marker::Sized","std::option::Option"],"<decoding_iterators::Utf8CharDecoder<'a> as std::iter::Iterator>::next":["decoding_iterators::Utf8CharDecoder","std::marker::Sized","std::option::Option"],"<decoding_iterators::Utf8CharDecoder<'a> as std::iter::Iterator>::size_hint":["decoding_iterators::Utf8CharDecoder","std::marker::Sized","std::option::Option"],"<decoding_iterators::Utf8CharMerger<B, I> as std::clone::Clone>::clone":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char"],"<decoding_iterators::Utf8CharMerger<B, I> as std::convert::From<T>>::from":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char"],"<decoding_iterators::Utf8CharMerger<B, I> as std::default::Default>::default":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char"],"<decoding_iterators::Utf8CharMerger<B, I> as std::fmt::Debug>::fmt":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::fmt::Formatter","std::iter::Iterator","std::marker::Sized","std::result::Result","utf16_char::Utf16Char"],"<decoding_iterators::Utf8CharMerger<B, I> as std::iter::Iterator>::next":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"<decoding_iterators::Utf8CharMerger<B, I> as std::iter::Iterator>::size_hint":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"<errors::EmptyStrError as std::clone::Clone>::clone":["errors::EmptyStrError"],"<errors::EmptyStrError as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::EmptyStrError"],"<errors::EmptyStrError as std::cmp::PartialEq>::eq":["errors::EmptyStrError"],"<errors::EmptyStrError as std::error::Error>::description":["errors::EmptyStrError"],"<errors::EmptyStrError as std::fmt::Debug>::fmt":["errors::EmptyStrError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::EmptyStrError as std::fmt::Display>::fmt":["errors::EmptyStrError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::FromStrError as std::clone::Clone>::clone":["errors::FromStrError"],"<errors::FromStrError as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::FromStrError"],"<errors::FromStrError as std::cmp::PartialEq>::eq":["errors::FromStrError"],"<errors::FromStrError as std::error::Error>::description":["errors::FromStrError"],"<errors::FromStrError as std::fmt::Debug>::fmt":["errors::FromStrError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::FromStrError as std::fmt::Display>::fmt":["errors::FromStrError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidCodepoint as std::clone::Clone>::clone":["errors::InvalidCodepoint"],"<errors::InvalidCodepoint as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::InvalidCodepoint"],"<errors::InvalidCodepoint as std::cmp::PartialEq>::eq":["errors::InvalidCodepoint"],"<errors::InvalidCodepoint as std::error::Error>::description":["errors::InvalidCodepoint"],"<errors::InvalidCodepoint as std::fmt::Debug>::fmt":["errors::InvalidCodepoint","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidCodepoint as std::fmt::Display>::fmt":["errors::InvalidCodepoint","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf16Array as std::clone::Clone>::clone":["errors::InvalidUtf16Array"],"<errors::InvalidUtf16Array as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::InvalidUtf16Array"],"<errors::InvalidUtf16Array as std::cmp::PartialEq>::eq":["errors::InvalidUtf16Array"],"<errors::InvalidUtf16Array as std::error::Error>::description":["errors::InvalidUtf16Array"],"<errors::InvalidUtf16Array as std::fmt::Debug>::fmt":["errors::InvalidUtf16Array","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf16Array as std::fmt::Display>::fmt":["errors::InvalidUtf16Array","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf16FirstUnit as std::clone::Clone>::clone":["errors::InvalidUtf16FirstUnit"],"<errors::InvalidUtf16FirstUnit as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::InvalidUtf16FirstUnit"],"<errors::InvalidUtf16FirstUnit as std::cmp::PartialEq>::eq":["errors::InvalidUtf16FirstUnit"],"<errors::InvalidUtf16FirstUnit as std::error::Error>::description":["errors::InvalidUtf16FirstUnit"],"<errors::InvalidUtf16FirstUnit as std::fmt::Debug>::fmt":["errors::InvalidUtf16FirstUnit","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf16FirstUnit as std::fmt::Display>::fmt":["errors::InvalidUtf16FirstUnit","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf16Slice as std::clone::Clone>::clone":["errors::InvalidUtf16Slice"],"<errors::InvalidUtf16Slice as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::InvalidUtf16Slice"],"<errors::InvalidUtf16Slice as std::cmp::PartialEq>::eq":["errors::InvalidUtf16Slice"],"<errors::InvalidUtf16Slice as std::error::Error>::description":["errors::InvalidUtf16Slice"],"<errors::InvalidUtf16Slice as std::fmt::Debug>::fmt":["errors::InvalidUtf16Slice","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf16Slice as std::fmt::Display>::fmt":["errors::InvalidUtf16Slice","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf16Tuple as std::clone::Clone>::clone":["errors::InvalidUtf16Tuple"],"<errors::InvalidUtf16Tuple as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::InvalidUtf16Tuple"],"<errors::InvalidUtf16Tuple as std::cmp::PartialEq>::eq":["errors::InvalidUtf16Tuple"],"<errors::InvalidUtf16Tuple as std::error::Error>::description":["errors::InvalidUtf16Tuple"],"<errors::InvalidUtf16Tuple as std::fmt::Debug>::fmt":["errors::InvalidUtf16Tuple","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf16Tuple as std::fmt::Display>::fmt":["errors::InvalidUtf16Tuple","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf8 as std::clone::Clone>::clone":["errors::InvalidUtf8","errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8 as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::InvalidUtf8","errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8 as std::cmp::PartialEq>::eq":["errors::InvalidUtf8","errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8 as std::convert::From<errors::InvalidUtf8FirstByte>>::from":["errors::InvalidUtf8","errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8 as std::error::Error>::cause":["errors::InvalidUtf8","errors::InvalidUtf8FirstByte","std::marker::Sized","std::option::Option"],"<errors::InvalidUtf8 as std::error::Error>::description":["errors::InvalidUtf8","errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8 as std::fmt::Debug>::fmt":["errors::InvalidUtf8","errors::InvalidUtf8FirstByte","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf8 as std::fmt::Display>::fmt":["errors::InvalidUtf8","errors::InvalidUtf8FirstByte","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf8Array as std::clone::Clone>::clone":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8Array as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8Array as std::cmp::PartialEq>::eq":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8Array as std::convert::From<errors::InvalidCodepoint>>::from":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8Array as std::convert::From<errors::InvalidUtf8>>::from":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8Array as std::error::Error>::cause":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","std::marker::Sized","std::option::Option"],"<errors::InvalidUtf8Array as std::error::Error>::description":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8Array as std::fmt::Debug>::fmt":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf8Array as std::fmt::Display>::fmt":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf8FirstByte as std::clone::Clone>::clone":["errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8FirstByte as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8FirstByte as std::cmp::PartialEq>::eq":["errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8FirstByte as std::error::Error>::description":["errors::InvalidUtf8FirstByte"],"<errors::InvalidUtf8FirstByte as std::fmt::Debug>::fmt":["errors::InvalidUtf8FirstByte","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf8FirstByte as std::fmt::Display>::fmt":["errors::InvalidUtf8FirstByte","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf8Slice as std::clone::Clone>::clone":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice"],"<errors::InvalidUtf8Slice as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice"],"<errors::InvalidUtf8Slice as std::cmp::PartialEq>::eq":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice"],"<errors::InvalidUtf8Slice as std::convert::From<errors::InvalidCodepoint>>::from":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice"],"<errors::InvalidUtf8Slice as std::convert::From<errors::InvalidUtf8>>::from":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice"],"<errors::InvalidUtf8Slice as std::error::Error>::cause":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","std::marker::Sized","std::option::Option"],"<errors::InvalidUtf8Slice as std::error::Error>::description":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice"],"<errors::InvalidUtf8Slice as std::fmt::Debug>::fmt":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::InvalidUtf8Slice as std::fmt::Display>::fmt":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::NonAsciiError as std::clone::Clone>::clone":["errors::NonAsciiError"],"<errors::NonAsciiError as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::NonAsciiError"],"<errors::NonAsciiError as std::cmp::PartialEq>::eq":["errors::NonAsciiError"],"<errors::NonAsciiError as std::error::Error>::description":["errors::NonAsciiError"],"<errors::NonAsciiError as std::fmt::Debug>::fmt":["errors::NonAsciiError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::NonAsciiError as std::fmt::Display>::fmt":["errors::NonAsciiError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::NonBMPError as std::clone::Clone>::clone":["errors::NonBMPError"],"<errors::NonBMPError as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::NonBMPError"],"<errors::NonBMPError as std::cmp::PartialEq>::eq":["errors::NonBMPError"],"<errors::NonBMPError as std::error::Error>::description":["errors::NonBMPError"],"<errors::NonBMPError as std::fmt::Debug>::fmt":["errors::NonBMPError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::NonBMPError as std::fmt::Display>::fmt":["errors::NonBMPError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::Utf16PairError as std::clone::Clone>::clone":["errors::Utf16PairError"],"<errors::Utf16PairError as std::cmp::Eq>::assert_receiver_is_total_eq":["errors::Utf16PairError"],"<errors::Utf16PairError as std::cmp::PartialEq>::eq":["errors::Utf16PairError"],"<errors::Utf16PairError as std::error::Error>::description":["errors::Utf16PairError"],"<errors::Utf16PairError as std::fmt::Debug>::fmt":["errors::Utf16PairError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<errors::Utf16PairError as std::fmt::Display>::fmt":["errors::Utf16PairError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<str as traits::StrExt>::utf16char_indices":["utf16_iterators::Utf16CharIndices"],"<str as traits::StrExt>::utf16chars":["utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars"],"<str as traits::StrExt>::utf8char_indices":["utf8_iterators::Utf8CharIndices"],"<str as traits::StrExt>::utf8chars":["utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars"],"<u16 as traits::U16UtfExt>::is_utf16_leading_surrogate":[],"<u16 as traits::U16UtfExt>::utf16_needs_extra_unit":["std::marker::Sized","std::result::Result"],"<u8 as traits::U8UtfExt>::extra_utf8_bytes":["std::marker::Sized","std::result::Result"],"<u8 as traits::U8UtfExt>::extra_utf8_bytes_unchecked":[],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::eq_ignore_ascii_case":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::is_ascii":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::make_ascii_lowercase":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::make_ascii_uppercase":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::to_ascii_lowercase":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::to_ascii_uppercase":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::borrow::Borrow<[u16]>>::borrow":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::clone::Clone>::clone":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::cmp::Eq>::assert_receiver_is_total_eq":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::cmp::Ord>::cmp":["std::cmp::Ordering","utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::cmp::PartialEq<char>>::eq":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::cmp::PartialEq<u16>>::eq":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::cmp::PartialEq<u8>>::eq":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::cmp::PartialEq<utf8_char::Utf8Char>>::eq":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"<utf16_char::Utf16Char as std::cmp::PartialEq>::eq":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::cmp::PartialOrd<char>>::partial_cmp":["std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::cmp::PartialOrd<utf8_char::Utf8Char>>::partial_cmp":["std::marker::Sized","std::option::Option","utf16_char::Utf16Char","utf8_char::Utf8Char"],"<utf16_char::Utf16Char as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::convert::AsRef<[u16]>>::as_ref":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::convert::From<char>>::from":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::convert::From<utf8_char::Utf8Char>>::from":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"<utf16_char::Utf16Char as std::default::Default>::default":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::iter::IntoIterator>::into_iter":["utf16_char::Utf16Char","utf16_iterators::Utf16Iterator"],"<utf16_char::Utf16Char as std::ops::Deref>::deref":["utf16_char::Utf16Char"],"<utf16_char::Utf16Char as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<utf16_iterators::Utf16CharIndices<'a> as std::clone::Clone>::clone":["utf16_iterators::Utf16CharIndices"],"<utf16_iterators::Utf16CharIndices<'a> as std::convert::From<&'a str>>::from":["utf16_iterators::Utf16CharIndices"],"<utf16_iterators::Utf16CharIndices<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf16_iterators::Utf16CharIndices"],"<utf16_iterators::Utf16CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["std::marker::Sized","std::option::Option","utf16_iterators::Utf16CharIndices"],"<utf16_iterators::Utf16CharIndices<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","utf16_iterators::Utf16CharIndices"],"<utf16_iterators::Utf16CharIndices<'a> as std::iter::Iterator>::size_hint":["std::marker::Sized","std::option::Option","utf16_iterators::Utf16CharIndices"],"<utf16_iterators::Utf16CharSplitter<U, I> as std::clone::Clone>::clone":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf16_iterators::Utf16CharSplitter"],"<utf16_iterators::Utf16CharSplitter<U, I> as std::iter::Iterator>::next":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char","utf16_iterators::Utf16CharSplitter"],"<utf16_iterators::Utf16CharSplitter<U, I> as std::iter::Iterator>::size_hint":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char","utf16_iterators::Utf16CharSplitter"],"<utf16_iterators::Utf16CharSplitter<utf16_char::Utf16Char, I> as std::convert::From<I>>::from":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf16_iterators::Utf16CharSplitter"],"<utf16_iterators::Utf16Chars<'a> as std::clone::Clone>::clone":["utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars"],"<utf16_iterators::Utf16Chars<'a> as std::convert::From<&'a str>>::from":["utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars"],"<utf16_iterators::Utf16Chars<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars"],"<utf16_iterators::Utf16Chars<'a> as std::iter::DoubleEndedIterator>::next_back":["std::marker::Sized","std::option::Option","utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars"],"<utf16_iterators::Utf16Chars<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars"],"<utf16_iterators::Utf16Chars<'a> as std::iter::Iterator>::size_hint":["std::marker::Sized","std::option::Option","utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars"],"<utf16_iterators::Utf16Iterator as std::clone::Clone>::clone":["utf16_iterators::Utf16Iterator"],"<utf16_iterators::Utf16Iterator as std::convert::From<char>>::from":["utf16_iterators::Utf16Iterator"],"<utf16_iterators::Utf16Iterator as std::convert::From<utf16_char::Utf16Char>>::from":["utf16_char::Utf16Char","utf16_iterators::Utf16Iterator"],"<utf16_iterators::Utf16Iterator as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf16_iterators::Utf16Iterator"],"<utf16_iterators::Utf16Iterator as std::iter::ExactSizeIterator>::len":["utf16_iterators::Utf16Iterator"],"<utf16_iterators::Utf16Iterator as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","utf16_iterators::Utf16Iterator"],"<utf16_iterators::Utf16Iterator as std::iter::Iterator>::size_hint":["std::marker::Sized","std::option::Option","utf16_iterators::Utf16Iterator"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::eq_ignore_ascii_case":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::is_ascii":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::make_ascii_lowercase":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::make_ascii_uppercase":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::to_ascii_lowercase":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::to_ascii_uppercase":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::borrow::Borrow<[u8]>>::borrow":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::borrow::Borrow<str>>::borrow":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::clone::Clone>::clone":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::cmp::Eq>::assert_receiver_is_total_eq":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::cmp::Ord>::cmp":["std::cmp::Ordering","utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::cmp::PartialEq<char>>::eq":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::cmp::PartialEq<u8>>::eq":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::cmp::PartialEq<utf16_char::Utf16Char>>::eq":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::cmp::PartialEq>::eq":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::cmp::PartialOrd<char>>::partial_cmp":["std::marker::Sized","std::option::Option","utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::cmp::PartialOrd<utf16_char::Utf16Char>>::partial_cmp":["std::marker::Sized","std::option::Option","utf16_char::Utf16Char","utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::convert::AsRef<[u8]>>::as_ref":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::convert::AsRef<str>>::as_ref":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::convert::From<char>>::from":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::convert::From<utf16_char::Utf16Char>>::from":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::default::Default>::default":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::iter::IntoIterator>::into_iter":["utf8_char::Utf8Char","utf8_iterators::Utf8Iterator"],"<utf8_char::Utf8Char as std::ops::Deref>::deref":["utf8_char::Utf8Char"],"<utf8_char::Utf8Char as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<utf8_iterators::Utf8CharIndices<'a> as std::clone::Clone>::clone":["utf8_iterators::Utf8CharIndices"],"<utf8_iterators::Utf8CharIndices<'a> as std::convert::From<&'a str>>::from":["utf8_iterators::Utf8CharIndices"],"<utf8_iterators::Utf8CharIndices<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf8_iterators::Utf8CharIndices"],"<utf8_iterators::Utf8CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["std::marker::Sized","std::option::Option","utf8_iterators::Utf8CharIndices"],"<utf8_iterators::Utf8CharIndices<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","utf8_iterators::Utf8CharIndices"],"<utf8_iterators::Utf8CharIndices<'a> as std::iter::Iterator>::size_hint":["std::marker::Sized","std::option::Option","utf8_iterators::Utf8CharIndices"],"<utf8_iterators::Utf8CharSplitter<U, I> as std::clone::Clone>::clone":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf8_iterators::Utf8CharSplitter"],"<utf8_iterators::Utf8CharSplitter<U, I> as std::io::Read>::read":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::result::Result","utf16_char::Utf16Char","utf8_iterators::Utf8CharSplitter"],"<utf8_iterators::Utf8CharSplitter<U, I> as std::iter::Iterator>::next":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char","utf8_iterators::Utf8CharSplitter"],"<utf8_iterators::Utf8CharSplitter<U, I> as std::iter::Iterator>::size_hint":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char","utf8_iterators::Utf8CharSplitter"],"<utf8_iterators::Utf8CharSplitter<utf8_char::Utf8Char, I> as std::convert::From<I>>::from":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf8_iterators::Utf8CharSplitter"],"<utf8_iterators::Utf8Chars<'a> as std::clone::Clone>::clone":["utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars"],"<utf8_iterators::Utf8Chars<'a> as std::convert::From<&'a str>>::from":["utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars"],"<utf8_iterators::Utf8Chars<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars"],"<utf8_iterators::Utf8Chars<'a> as std::iter::DoubleEndedIterator>::next_back":["std::marker::Sized","std::option::Option","utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars"],"<utf8_iterators::Utf8Chars<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars"],"<utf8_iterators::Utf8Chars<'a> as std::iter::Iterator>::size_hint":["std::marker::Sized","std::option::Option","utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars"],"<utf8_iterators::Utf8Iterator as std::clone::Clone>::clone":["utf8_iterators::Utf8Iterator"],"<utf8_iterators::Utf8Iterator as std::convert::From<char>>::from":["utf8_iterators::Utf8Iterator"],"<utf8_iterators::Utf8Iterator as std::convert::From<utf8_char::Utf8Char>>::from":["utf8_char::Utf8Char","utf8_iterators::Utf8Iterator"],"<utf8_iterators::Utf8Iterator as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf8_iterators::Utf8Iterator"],"<utf8_iterators::Utf8Iterator as std::io::Read>::read":["std::marker::Sized","std::result::Result","utf8_iterators::Utf8Iterator"],"<utf8_iterators::Utf8Iterator as std::iter::ExactSizeIterator>::len":["utf8_iterators::Utf8Iterator"],"<utf8_iterators::Utf8Iterator as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","utf8_iterators::Utf8Iterator"],"<utf8_iterators::Utf8Iterator as std::iter::Iterator>::size_hint":["std::marker::Sized","std::option::Option","utf8_iterators::Utf8Iterator"],"decoding_iterators::Utf16CharDecoder":["decoding_iterators::Utf16CharDecoder"],"decoding_iterators::Utf16CharDecoder::<'a>::as_slice":["decoding_iterators::Utf16CharDecoder"],"decoding_iterators::Utf16CharMerger":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"decoding_iterators::Utf16CharMerger::<B, I>::into_inner":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"decoding_iterators::Utf16CharMerger::<B, I>::into_remaining_units":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","std::borrow::Borrow","std::iter::Chain","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"decoding_iterators::Utf8CharDecoder":["decoding_iterators::Utf8CharDecoder"],"decoding_iterators::Utf8CharDecoder::<'a>::as_slice":["decoding_iterators::Utf8CharDecoder"],"decoding_iterators::Utf8CharMerger":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char"],"decoding_iterators::Utf8CharMerger::<B, I>::extra":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::result::Result","utf16_char::Utf16Char"],"decoding_iterators::Utf8CharMerger::<B, I>::into_inner":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char"],"decoding_iterators::Utf8CharMerger::<B, I>::save":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char"],"errors::EmptyStrError":["errors::EmptyStrError"],"errors::FromStrError":["errors::FromStrError"],"errors::InvalidCodepoint":["errors::InvalidCodepoint"],"errors::InvalidCodepoint::error_range":["errors::InvalidCodepoint"],"errors::InvalidUtf16Array":["errors::InvalidUtf16Array"],"errors::InvalidUtf16FirstUnit":["errors::InvalidUtf16FirstUnit"],"errors::InvalidUtf16Slice":["errors::InvalidUtf16Slice"],"errors::InvalidUtf16Tuple":["errors::InvalidUtf16Tuple"],"errors::InvalidUtf8":["errors::InvalidUtf8","errors::InvalidUtf8FirstByte"],"errors::InvalidUtf8Array":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte"],"errors::InvalidUtf8FirstByte":["errors::InvalidUtf8FirstByte"],"errors::InvalidUtf8Slice":["errors::InvalidCodepoint","errors::InvalidUtf8","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice"],"errors::NonAsciiError":["errors::NonAsciiError"],"errors::NonBMPError":["errors::NonBMPError"],"errors::Utf16PairError":["errors::Utf16PairError"],"traits::CharExt::from_u32_detailed":["std::marker::Sized","std::result::Result"],"traits::CharExt::from_utf16_array":["std::marker::Sized","std::result::Result"],"traits::CharExt::from_utf16_array_unchecked":[],"traits::CharExt::from_utf16_slice_start":["std::marker::Sized","std::result::Result"],"traits::CharExt::from_utf16_tuple":["std::marker::Sized","std::option::Option","std::result::Result"],"traits::CharExt::from_utf16_tuple_unchecked":["std::marker::Sized","std::option::Option"],"traits::CharExt::from_utf8_array":["std::marker::Sized","std::result::Result"],"traits::CharExt::from_utf8_exact_slice_unchecked":[],"traits::CharExt::from_utf8_slice_start":["std::marker::Sized","std::result::Result"],"traits::CharExt::iter_utf16_units":["utf16_iterators::Utf16Iterator"],"traits::CharExt::iter_utf8_bytes":["utf8_iterators::Utf8Iterator"],"traits::CharExt::to_utf16":["utf16_char::Utf16Char"],"traits::CharExt::to_utf16_array":[],"traits::CharExt::to_utf16_tuple":["std::marker::Sized","std::option::Option"],"traits::CharExt::to_utf8":["utf8_char::Utf8Char"],"traits::CharExt::to_utf8_array":[],"traits::IterExt::to_bytes":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf8_iterators::Utf8CharSplitter"],"traits::IterExt::to_units":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf16_iterators::Utf16CharSplitter"],"traits::IterExt::to_utf16chars":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"traits::IterExt::to_utf8chars":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf8CharMerger","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char"],"traits::SliceExt::utf16char_indices":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","utf16_char::Utf16Char"],"traits::SliceExt::utf8char_indices":["decoding_iterators::Utf8CharDecoder","std::borrow::Borrow","utf16_char::Utf16Char"],"traits::StrExt::utf16char_indices":["utf16_iterators::Utf16CharIndices"],"traits::StrExt::utf16chars":["utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars"],"traits::StrExt::utf8char_indices":["utf8_iterators::Utf8CharIndices"],"traits::StrExt::utf8chars":["utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars"],"traits::U16UtfExt::is_utf16_leading_surrogate":[],"traits::U16UtfExt::utf16_needs_extra_unit":["std::marker::Sized","std::result::Result"],"traits::U8UtfExt::extra_utf8_bytes":["std::marker::Sized","std::result::Result"],"traits::U8UtfExt::extra_utf8_bytes_unchecked":[],"traits::combine_surrogates":[],"traits::merge_nonascii_unchecked_utf8":[],"traits::overlong":[],"utf16_char::<impl std::cmp::PartialEq<utf16_char::Utf16Char> for char>::eq":["utf16_char::Utf16Char"],"utf16_char::<impl std::cmp::PartialOrd<utf16_char::Utf16Char> for char>::partial_cmp":["std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"utf16_char::<impl std::convert::From<utf16_char::Utf16Char> for char>::from":["utf16_char::Utf16Char"],"utf16_char::<impl std::iter::Extend<&'a utf16_char::Utf16Char> for std::string::String>::extend":["std::iter::IntoIterator","std::marker::Sized","std::string::String","utf16_char::Utf16Char"],"utf16_char::<impl std::iter::Extend<&'a utf16_char::Utf16Char> for std::vec::Vec<u16>>::extend":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","utf16_char::Utf16Char"],"utf16_char::<impl std::iter::Extend<utf16_char::Utf16Char> for std::string::String>::extend":["std::iter::IntoIterator","std::marker::Sized","std::string::String","utf16_char::Utf16Char"],"utf16_char::<impl std::iter::Extend<utf16_char::Utf16Char> for std::vec::Vec<u16>>::extend":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","utf16_char::Utf16Char"],"utf16_char::<impl std::iter::FromIterator<&'a utf16_char::Utf16Char> for std::string::String>::from_iter":["std::iter::IntoIterator","std::marker::Sized","std::string::String","utf16_char::Utf16Char"],"utf16_char::<impl std::iter::FromIterator<&'a utf16_char::Utf16Char> for std::vec::Vec<u16>>::from_iter":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","utf16_char::Utf16Char"],"utf16_char::<impl std::iter::FromIterator<utf16_char::Utf16Char> for std::string::String>::from_iter":["std::iter::IntoIterator","std::marker::Sized","std::string::String","utf16_char::Utf16Char"],"utf16_char::<impl std::iter::FromIterator<utf16_char::Utf16Char> for std::vec::Vec<u16>>::from_iter":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","utf16_char::Utf16Char"],"utf16_char::Utf16Char":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::eq_ignore_ascii_case":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::from_array":["std::marker::Sized","std::result::Result"],"utf16_char::Utf16Char::from_array_unchecked":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::from_bmp":["std::marker::Sized","std::result::Result"],"utf16_char::Utf16Char::from_bmp_unchecked":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::from_slice_start":["std::marker::Sized","std::result::Result"],"utf16_char::Utf16Char::from_slice_start_unchecked":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::from_str_start":["std::marker::Sized","std::result::Result"],"utf16_char::Utf16Char::from_tuple":["std::marker::Sized","std::option::Option","std::result::Result"],"utf16_char::Utf16Char::from_tuple_unchecked":["std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"utf16_char::Utf16Char::is_ascii":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::is_bmp":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::len":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::make_ascii_lowercase":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::make_ascii_uppercase":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::to_array":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::to_ascii_lowercase":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::to_ascii_uppercase":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::to_char":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::to_slice":["utf16_char::Utf16Char"],"utf16_char::Utf16Char::to_tuple":["std::marker::Sized","std::option::Option","utf16_char::Utf16Char"],"utf16_iterators::Utf16CharIndices":["utf16_iterators::Utf16CharIndices"],"utf16_iterators::Utf16CharIndices::<'a>::as_str":["utf16_iterators::Utf16CharIndices"],"utf16_iterators::Utf16CharSplitter":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf16_iterators::Utf16CharSplitter"],"utf16_iterators::Utf16CharSplitter::<U, I>::into_inner":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf16_iterators::Utf16CharSplitter"],"utf16_iterators::Utf16Chars":["utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars"],"utf16_iterators::Utf16Chars::<'a>::as_str":["utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars"],"utf16_iterators::Utf16Iterator":["utf16_iterators::Utf16Iterator"],"utf16_iterators::iter_units":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf16_iterators::Utf16CharSplitter"],"utf8_char::<impl std::cmp::PartialEq<utf8_char::Utf8Char> for char>::eq":["utf8_char::Utf8Char"],"utf8_char::<impl std::cmp::PartialOrd<utf8_char::Utf8Char> for char>::partial_cmp":["std::marker::Sized","std::option::Option","utf8_char::Utf8Char"],"utf8_char::<impl std::convert::From<utf8_char::Utf8Char> for char>::from":["utf8_char::Utf8Char"],"utf8_char::<impl std::iter::Extend<&'a utf8_char::Utf8Char> for std::string::String>::extend":["std::iter::IntoIterator","std::marker::Sized","std::string::String","utf16_char::Utf16Char"],"utf8_char::<impl std::iter::Extend<&'a utf8_char::Utf8Char> for std::vec::Vec<u8>>::extend":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","utf16_char::Utf16Char"],"utf8_char::<impl std::iter::Extend<utf8_char::Utf8Char> for std::string::String>::extend":["std::iter::IntoIterator","std::marker::Sized","std::string::String","utf16_char::Utf16Char"],"utf8_char::<impl std::iter::Extend<utf8_char::Utf8Char> for std::vec::Vec<u8>>::extend":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","utf16_char::Utf16Char"],"utf8_char::<impl std::iter::FromIterator<&'a utf8_char::Utf8Char> for std::string::String>::from_iter":["std::iter::IntoIterator","std::marker::Sized","std::string::String","utf16_char::Utf16Char"],"utf8_char::<impl std::iter::FromIterator<&'a utf8_char::Utf8Char> for std::vec::Vec<u8>>::from_iter":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","utf16_char::Utf16Char"],"utf8_char::<impl std::iter::FromIterator<utf8_char::Utf8Char> for std::string::String>::from_iter":["std::iter::IntoIterator","std::marker::Sized","std::string::String","utf16_char::Utf16Char"],"utf8_char::<impl std::iter::FromIterator<utf8_char::Utf8Char> for std::vec::Vec<u8>>::from_iter":["std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","utf16_char::Utf16Char"],"utf8_char::Utf8Char":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::as_str":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::eq_ignore_ascii_case":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::from_array":["std::marker::Sized","std::result::Result"],"utf8_char::Utf8Char::from_array_unchecked":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::from_ascii":["std::marker::Sized","std::result::Result"],"utf8_char::Utf8Char::from_ascii_unchecked":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::from_slice_start":["std::marker::Sized","std::result::Result"],"utf8_char::Utf8Char::from_slice_start_unchecked":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::from_str_start":["std::marker::Sized","std::result::Result"],"utf8_char::Utf8Char::is_ascii":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::len":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::make_ascii_lowercase":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::make_ascii_uppercase":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::to_array":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::to_ascii_lowercase":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::to_ascii_uppercase":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::to_char":["utf8_char::Utf8Char"],"utf8_char::Utf8Char::to_slice":["utf8_char::Utf8Char"],"utf8_iterators::Utf8CharIndices":["utf8_iterators::Utf8CharIndices"],"utf8_iterators::Utf8CharIndices::<'a>::as_str":["utf8_iterators::Utf8CharIndices"],"utf8_iterators::Utf8CharSplitter":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf8_iterators::Utf8CharSplitter"],"utf8_iterators::Utf8CharSplitter::<U, I>::into_inner":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf8_iterators::Utf8CharSplitter"],"utf8_iterators::Utf8Chars":["utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars"],"utf8_iterators::Utf8Chars::<'a>::as_str":["utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars"],"utf8_iterators::Utf8Iterator":["utf8_iterators::Utf8Iterator"],"utf8_iterators::iter_bytes":["decoding_iterators::Utf16CharDecoder","std::borrow::Borrow","std::iter::IntoIterator","std::iter::Iterator","std::marker::Sized","utf16_char::Utf16Char","utf8_iterators::Utf8CharSplitter"]},"glob_path_import":{},"self_to_fn":{"<I as traits::IterExt>::I":["impl<I:Iterator> IterExt for I {\n    fn to_bytes(self) -> Utf8CharSplitter<Self::Item,Self> where Self::Item: Borrow<Utf8Char> {\n        iter_bytes(self)\n    }\n    fn to_units(self) -> Utf16CharSplitter<Self::Item,Self> where Self::Item: Borrow<Utf16Char> {\n        iter_units(self)\n    }\n    fn to_utf8chars(self) -> Utf8CharMerger<Self::Item,Self> where Self::Item: Borrow<u8> {\n        Utf8CharMerger::from(self)\n    }\n    fn to_utf16chars(self) -> Utf16CharMerger<Self::Item,Self> where Self::Item: Borrow<u16> {\n        Utf16CharMerger::from(self)\n    }\n}"],"<S as traits::SliceExt>::S":["impl<S: ?Sized+Index<RangeFull>> SliceExt for S {\n    fn utf8char_indices(&self) -> Utf8CharDecoder where Self::Output: Borrow<[u8]> {\n        Utf8CharDecoder::from(self[..].borrow())\n    }\n    fn utf16char_indices(&self) -> Utf16CharDecoder where Self::Output: Borrow<[u16]> {\n        Utf16CharDecoder::from(self[..].borrow())\n    }\n}"],"decoding_iterators::Utf16CharDecoder":["Clone","Default","impl<'a> Debug for Utf16CharDecoder<'a> {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        write!(fmtr, \"Utf16CharDecoder {{ units[{}..]: {:?} }}\", self.index, self.as_slice())\n    }\n}","impl<'a> From<&'a[u16]> for Utf16CharDecoder<'a> {\n    fn from(s: &'a[u16]) -> Self {\n        Utf16CharDecoder{ slice: s,  index: 0 }\n    }\n}","impl<'a> Iterator for Utf16CharDecoder<'a> {\n    type Item = (usize,Result<Utf16Char,Utf16PairError>,usize);\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item>  {\n        let start = self.index;\n        match Utf16Char::from_slice_start(self.as_slice()) {\n            Ok((u16c,len)) => {\n                self.index += len;\n                Some((start, Ok(u16c), len))\n            },\n            Err(EmptySlice) => None,\n            Err(FirstLowSurrogate) => {\n                self.index += 1;\n                Some((start, Err(UnexpectedTrailingSurrogate), 1))\n            },\n            Err(SecondNotLowSurrogate) => {\n                self.index += 1;\n                Some((start, Err(UnmatchedLeadingSurrogate), 1))\n            },\n            Err(MissingSecond) => {\n                self.index = self.slice.len();\n                Some((start, Err(Incomplete), 1))\n            }\n        }\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize,Option<usize>) {\n        let units = self.slice.len() - self.index;\n        // Cannot be exact, so KISS and don't bother rounding up.\n        // The slice is unlikely be full of surrogate pairs, so buffers\n        // allocated with the lower bound will have to be grown anyway.\n        (units/2, Some(units))\n    }\n}","impl<'a> Utf16CharDecoder<'a> {\n    /// Extract the remainder of the source slice.\n    ///\n    /// # Examples\n    ///\n    /// Unlike `Utf16CharMerger::into_inner()`, the unit after an error is never swallowed:\n    /// ```\n    /// # use encode_unicode::SliceExt;\n    /// # use encode_unicode::error::Utf16PairError;\n    /// let mut iter = [0xd901, 'F' as u16, 'S' as u16].utf16char_indices();\n    /// assert_eq!(iter.next(), Some((0, Err(Utf16PairError::UnmatchedLeadingSurrogate), 1)));\n    /// assert_eq!(iter.as_slice(), &['F' as u16, 'S' as u16]);\n    /// ```\n    pub fn as_slice(&self) -> &[u16] {\n        &self.slice[self.index..]\n    }\n}"],"decoding_iterators::Utf16CharMerger":["Clone","Default","impl<B:Borrow<u16>, I:Iterator<Item=B>+Debug> Debug for Utf16CharMerger<B,I> {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        fmtr.debug_struct(\"Utf16CharMerger\")\n            .field(\"buffered\", &self.prev.as_ref().map(|b| *b.borrow() ))\n            .field(\"inner\", &self.iter)\n            .finish()\n    }\n}","impl<B:Borrow<u16>, I:Iterator<Item=B>, T:IntoIterator<IntoIter=I,Item=B>>\nFrom<T> for Utf16CharMerger<B,I> {\n    fn from(t: T) -> Self {\n        Utf16CharMerger { iter: t.into_iter(),  prev: None }\n    }\n}","impl<B:Borrow<u16>, I:Iterator<Item=B>> Iterator for Utf16CharMerger<B,I> {\n    type Item = Result<Utf16Char,Utf16PairError>;\n    fn next(&mut self) -> Option<Self::Item> {\n        let first = self.prev.take().or_else(|| self.iter.next() );\n        first.map(|first| unsafe {\n            match first.borrow().utf16_needs_extra_unit() {\n                Ok(false) => Ok(Utf16Char::from_array_unchecked([*first.borrow(), 0])),\n                Ok(true) => match self.iter.next() {\n                    Some(second) => match second.borrow().utf16_needs_extra_unit() {\n                        Err(InvalidUtf16FirstUnit) => Ok(Utf16Char::from_tuple_unchecked((\n                            *first.borrow(),\n                            Some(*second.borrow())\n                        ))),\n                        Ok(_) => {\n                            self.prev = Some(second);\n                            Err(Utf16PairError::UnmatchedLeadingSurrogate)\n                        }\n                    },\n                    None => Err(Utf16PairError::Incomplete)\n                },\n                Err(InvalidUtf16FirstUnit) => Err(Utf16PairError::UnexpectedTrailingSurrogate),\n            }\n        })\n    }\n    fn size_hint(&self) -> (usize,Option<usize>) {\n        let (iter_min, iter_max) = self.iter.size_hint();\n        // cannot be exact, so KISS\n        let min = iter_min / 2; // don't bother rounding up or accounting for self.prev\n        let max = match (iter_max, &self.prev) {\n            (Some(max), &Some(_)) => max.checked_add(1),\n            (max, _) => max,\n        };\n        (min, max)\n    }\n}","impl<B:Borrow<u16>, I:Iterator<Item=B>> Utf16CharMerger<B,I> {\n    /// Extract the inner iterator.\n    ///\n    /// If the last item produced was an `Err`, the first unit might be missing.\n    ///\n    /// # Examples\n    ///\n    /// Unit right after an error missing\n    /// ```\n    /// # use encode_unicode::IterExt;\n    /// # use encode_unicode::error::Utf16PairError;\n    /// let mut merger = [0xd901, 'F' as u16, 'S' as u16].iter().to_utf16chars();\n    /// assert_eq!(merger.next(), Some(Err(Utf16PairError::UnmatchedLeadingSurrogate)));\n    /// let mut inner: std::slice::Iter<u16> = merger.into_inner();\n    /// assert_eq!(inner.next(), Some('S' as u16).as_ref()); // 'F' was consumed by Utf16CharMerger\n    /// ```\n    ///\n    /// Error that doesn't swallow any units\n    /// ```\n    /// # use encode_unicode::IterExt;\n    /// # use encode_unicode::error::Utf16PairError;\n    /// let mut merger = [0xde00, 'F' as u16, 'S' as u16].iter().to_utf16chars();\n    /// assert_eq!(merger.next(), Some(Err(Utf16PairError::UnexpectedTrailingSurrogate)));\n    /// let mut inner: std::slice::Iter<u16> = merger.into_inner();\n    /// assert_eq!(inner.next(), Some('F' as u16).as_ref()); // not consumed\n    /// ```\n    pub fn into_inner(self) -> I {\n        self.iter\n    }\n    /// Returns an iterator over the remaining units.\n    /// Unlike `into_inner()` this will never drop any units.\n    ///\n    /// The exact type of the returned iterator should not be depended on.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use encode_unicode::IterExt;\n    /// # use encode_unicode::error::Utf16PairError;\n    /// let slice = [0xd901, 'F' as u16, 'S' as u16];\n    /// let mut merger = slice.iter().to_utf16chars();\n    /// assert_eq!(merger.next(), Some(Err(Utf16PairError::UnmatchedLeadingSurrogate)));\n    /// let mut remaining = merger.into_remaining_units();\n    /// assert_eq!(remaining.next(), Some('F' as u16).as_ref());\n    /// ```\n    pub fn into_remaining_units(self) -> Chain<option::IntoIter<B>,I> {\n        self.prev.into_iter().chain(self.iter)\n    }\n}"],"decoding_iterators::Utf8CharDecoder":["Clone","Default","impl<'a> Debug for Utf8CharDecoder<'a> {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        write!(fmtr, \"Utf8CharDecoder {{ bytes[{}..]: {:?} }}\", self.index, self.as_slice())\n    }\n}","impl<'a> DoubleEndedIterator for Utf8CharDecoder<'a> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.index < self.slice.len() {\n            let extras = self.slice.iter()\n                .rev()\n                .take_while(|&b| b & 0b1100_0000 == 0b1000_0000 )\n                .count();\n            let starts = self.slice.len() - (extras+1);\n            match Utf8Char::from_slice_start(&self.slice[starts..]) {\n                Ok((u8c,len)) if len == 1+extras => {\n                    self.slice = &self.slice[..starts];\n                    Some((starts, Ok(u8c), len))\n                },\n                // This enures errors for every byte in both directions,\n                // but means overlong and codepoint errors will be turned into\n                // tooshort errors.\n                Err(e) if extras == 0 => {\n                    self.slice = &self.slice[..self.slice.len()-1];\n                    Some((self.slice.len()-1, Err(e), 1))\n                },\n                _ => {\n                    self.slice = &self.slice[..self.slice.len()-1];\n                    Some((self.slice.len()-1, Err(Utf8(FirstByte(ContinuationByte))), 1))\n                },\n            }\n        } else {\n            None\n        }\n    }\n}","impl<'a> From<&'a[u8]> for Utf8CharDecoder<'a> {\n    fn from(s: &[u8]) -> Utf8CharDecoder {\n        Utf8CharDecoder { slice: s, index: 0 }\n    }\n}","impl<'a> Iterator for Utf8CharDecoder<'a> {\n    type Item = (usize, Result<Utf8Char,InvalidUtf8Slice>, usize);\n    fn next(&mut self) -> Option<Self::Item> {\n        let start = self.index;\n        match Utf8Char::from_slice_start(&self.slice[self.index..]) {\n            Ok((u8c, len)) => {\n                self.index += len;\n                Some((start, Ok(u8c), len))\n            },\n            Err(TooShort(1)) => None,\n            Err(e) => {\n                self.index += 1;\n                Some((start, Err(e), 1))\n            }\n        }\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize,Option<usize>) {\n        let bytes = self.slice.len() - self.index;\n        // Cannot be exact, so KISS and don't bother rounding up.\n        // The slice is unlikely be full of 4-byte codepoints, so buffers\n        // allocated with the lower bound will have to be grown anyway.\n        (bytes/4, Some(bytes))\n    }\n}","impl<'a> Utf8CharDecoder<'a> {\n    /// Extract the remainder of the source slice.\n    ///\n    /// # Examples\n    ///\n    /// Unlike `Utf8CharMerger::into_inner()`, bytes directly after an error\n    /// are never swallowed:\n    /// ```\n    /// # use encode_unicode::SliceExt;\n    /// let mut iter = b\"\\xf4\\xa1\\xb2FS\".utf8char_indices();\n    /// assert!(iter.next().unwrap().1.is_err());\n    /// assert_eq!(iter.as_slice(), b\"\\xa1\\xb2FS\");\n    /// ```\n    pub fn as_slice(&self) -> &'a[u8] {\n        &self.slice[self.index..]\n    }\n}"],"decoding_iterators::Utf8CharMerger":["Clone","Default","impl<B:Borrow<u8>, I:Iterator<Item=B>+Debug> Debug for Utf8CharMerger<B,I> {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        let mut in_order = [0u8; 3];\n        for i in 0..self.after_err_leftover as usize {\n            in_order[i] = self.after_err_stack[self.after_err_leftover as usize - i - 1];\n        }\n        fmtr.debug_struct(\"Utf8CharMerger\")\n            .field(\"buffered\", &&in_order[..self.after_err_leftover as usize])\n            .field(\"inner\", &self.iter)\n            .finish()\n    }\n}","impl<B:Borrow<u8>, I:Iterator<Item=B>, T:IntoIterator<IntoIter=I,Item=B>>\nFrom<T> for Utf8CharMerger<B, I> {\n    fn from(t: T) -> Self {\n        Utf8CharMerger {\n            iter: t.into_iter(),\n            after_err_leftover: 0,\n            after_err_stack: [0; 3],\n        }\n    }\n}","impl<B:Borrow<u8>, I:Iterator<Item=B>> Iterator for Utf8CharMerger<B,I> {\n    type Item = Result<Utf8Char,InvalidUtf8Slice>;\n    fn next(&mut self) -> Option<Self::Item> {\n        let first: u8;\n        if self.after_err_leftover != 0 {\n            self.after_err_leftover -= 1;\n            first = self.after_err_stack[self.after_err_leftover as usize];\n        } else if let Some(next) = self.iter.next() {\n            first = *next.borrow();\n        } else {\n            return None;\n        }\n\n        unsafe {\n            let mut bytes = [first, 0, 0, 0];\n            let ok = match first {\n                0b0000_0000...0b0111_1111 => {/*1 and */Ok(())},\n                0b1100_0010...0b1101_1111 => {//2 and not overlong\n                    self.extra(&mut bytes, 2) // no extra validation required\n                },\n                0b1110_0000...0b1110_1111 => {//3\n                    if let Err(e) = self.extra(&mut bytes, 3) {\n                        Err(e)\n                    } else if bytes[0] == 0b1110_0000  &&  bytes[1] <= 0b10_011111 {\n                        self.save(&bytes, 3);\n                        Err(Utf8(OverLong))\n                    } else if bytes[0] == 0b1110_1101  &&  bytes[1] & 0b11_100000 == 0b10_100000 {\n                        self.save(&bytes, 3);\n                        Err(Codepoint(Utf16Reserved))\n                    } else {\n                        Ok(())\n                    }\n                },\n                0b1111_0000...0b1111_0100 => {//4\n                    if let Err(e) = self.extra(&mut bytes, 4) {\n                        Err(e)\n                    } else if bytes[0] == 0b11110_000  &&  bytes[1] <= 0b10_001111 {\n                        self.save(&bytes, 4);\n                        Err(InvalidUtf8Slice::Utf8(OverLong))\n                    } else if bytes[0] == 0b11110_100  &&  bytes[1] > 0b10_001111 {\n                        self.save(&bytes, 4);\n                        Err(InvalidUtf8Slice::Codepoint(TooHigh))\n                    } else {\n                        Ok(())\n                    }\n                },\n                0b1000_0000...0b1011_1111 => {// continuation byte\n                    Err(Utf8(FirstByte(ContinuationByte)))\n                },\n                0b1100_0000...0b1100_0001 => {// 2 and overlong\n                    Err(Utf8(OverLong))\n                },\n                0b1111_0101...0b1111_0111 => {// 4 and too high codepoint\n                    Err(Codepoint(TooHigh))\n                },\n                0b1111_1000...0b1111_1111 => {\n                    Err(Utf8(FirstByte(TooLongSeqence)))\n                },\n                _ => unreachable!(\"all possible byte values should be covered\")\n            };\n            Some(ok.map(|()| Utf8Char::from_array_unchecked(bytes) ))\n        }\n    }\n    fn size_hint(&self) -> (usize,Option<usize>) {\n        let (iter_min, iter_max) = self.iter.size_hint();\n        // cannot be exact, so KISS\n        let min = iter_min / 4; // don't bother rounding up or accounting for after_err\n        // handle edge case of max > usize::MAX-3 just in case.\n        // Using wrapping_add() wouldn't violate any API contract as the trait isn't unsafe.\n        let max = iter_max.and_then(|max| {\n            max.checked_add(self.after_err_leftover as usize)\n        });\n        (min, max)\n    }\n}","impl<B:Borrow<u8>, I:Iterator<Item=B>> Utf8CharMerger<B,I> {\n    /// Extract the inner iterator.\n    ///\n    /// If the last item produced by `.next()` was an `Err`,\n    /// up to three following bytes might be missing.  \n    /// The exact number of missing bytes for each error type should not be relied on.\n    ///\n    /// # Examples\n    ///\n    /// Three bytes swallowed:\n    /// ```\n    /// # use encode_unicode::IterExt;\n    /// let mut merger = b\"\\xf4\\xa1\\xb2FS\".iter().to_utf8chars();\n    /// assert!(merger.next().unwrap().is_err());\n    /// let mut inner: std::slice::Iter<u8> = merger.into_inner();\n    /// assert_eq!(inner.next(), Some(&b'S')); // b'\\xa1', b'\\xb2' and b'F' disappeared\n    /// ```\n    ///\n    /// All bytes present:\n    /// ```\n    /// # use encode_unicode::IterExt;\n    /// let mut merger = b\"\\xb0FS\".iter().to_utf8chars();\n    /// assert!(merger.next().unwrap().is_err());\n    /// assert_eq!(merger.into_inner().next(), Some(&b'F'));\n    /// ```\n    ///\n    /// Two bytes missing:\n    /// ```\n    /// # use encode_unicode::IterExt;\n    /// let mut merger = b\"\\xe0\\x80\\x80FS\".iter().to_utf8chars();\n    /// assert!(merger.next().unwrap().is_err());\n    /// assert_eq!(merger.into_inner().next(), Some(&b'F'));\n    /// ```\n    pub fn into_inner(self) -> I {\n        self.iter\n    }\n\n    fn save(&mut self,  bytes: &[u8;4],  len: usize) {\n        // forget bytes[0] and push the others onto self.after_err_stack (in reverse).\n        for &after_err in bytes[1..len].iter().rev() {\n            self.after_err_stack[self.after_err_leftover as usize] = after_err;\n            self.after_err_leftover += 1;\n        }\n    }\n    /// Reads len-1 bytes into bytes[1..]\n    fn extra(&mut self,  bytes: &mut[u8;4],  len: usize) -> Result<(),InvalidUtf8Slice> {\n        // This is the only function that pushes onto after_err_stack,\n        // and it checks that all bytes are continuation bytes before fetching the next one.\n        // Therefore only the last byte retrieved can be a non-continuation byte.\n        // That last byte is also the last to be retrieved from after_err.\n        //\n        // Before this function is called, there has been retrieved at least one byte.\n        // If that byte was a continuation byte, next() produces an error\n        // and won't call this function.\n        // Therefore, we know that after_err is empty at this point.\n        // This means that we can use self.iter directly, and knows where to start pushing\n        debug_assert_eq!(self.after_err_leftover, 0, \"first: {:#02x}, stack: {:?}\", bytes[0], self.after_err_stack);\n        for i in 1..len {\n            if let Some(extra) = self.iter.next() {\n                let extra = *extra.borrow();\n                bytes[i] = extra;\n                if extra & 0b1100_0000 != 0b1000_0000 {\n                    // not a continuation byte\n                    self.save(bytes, i+1);\n                    return Err(InvalidUtf8Slice::Utf8(NotAContinuationByte(i)))\n                }\n            } else {\n                self.save(bytes, i);\n                return Err(TooShort(len));\n            }\n        }\n        Ok(())\n    }\n}"],"errors::EmptyStrError":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            write!(fmtr, \"{}\", self.description())\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            ($desc)(self)\n        }\n    }"],"errors::FromStrError":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            write!(fmtr, \"{}\", self.description())\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            ($desc)(self)\n        }\n    }"],"errors::InvalidCodepoint":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            write!(fmtr, \"{}\", self.description())\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            ($desc)(self)\n        }\n    }","impl InvalidCodepoint {\n    /// Get the range of values for which this error would be given.\n    pub fn error_range(self) -> (u32,u32) {match self {\n        Utf16Reserved => (0xd8_00, 0xdf_ff),\n        TooHigh => (0x00_10_ff_ff, 0xff_ff_ff_ff),\n    }}\n}"],"errors::InvalidUtf16Array":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            write!(fmtr, \"{}\", self.description())\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            ($desc)(self)\n        }\n    }"],"errors::InvalidUtf16FirstUnit":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            write!(fmtr, \"{}\", self.description())\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            ($desc)(self)\n        }\n    }"],"errors::InvalidUtf16Slice":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            write!(fmtr, \"{}\", self.description())\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            ($desc)(self)\n        }\n    }"],"errors::InvalidUtf16Tuple":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            write!(fmtr, \"{}\", self.description())\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            ($desc)(self)\n        }\n    }"],"errors::InvalidUtf8":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            match (self.cause(), $use_cause) {\n                (Some(d),true) => write!(fmtr, \"{}: {}\", self.description(), d),\n                        _      => write!(fmtr, \"{}\", self.description()),\n            }\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            match *self{ $($desc => $string,)* }\n        }\n        $(#[$causedoc])*\n        fn cause(&self) -> Option<&Error> {\n            match *self{ $($cause => $result,)* }\n        }\n    }","impl From<$sub> for $err {\n          fn from(error: $sub) -> $err {\n              $to(error)\n          }\n      }"],"errors::InvalidUtf8Array":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            match (self.cause(), $use_cause) {\n                (Some(d),true) => write!(fmtr, \"{}: {}\", self.description(), d),\n                        _      => write!(fmtr, \"{}\", self.description()),\n            }\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            match *self{ $($desc => $string,)* }\n        }\n        $(#[$causedoc])*\n        fn cause(&self) -> Option<&Error> {\n            match *self{ $($cause => $result,)* }\n        }\n    }","impl From<$sub> for $err {\n          fn from(error: $sub) -> $err {\n              $to(error)\n          }\n      }"],"errors::InvalidUtf8FirstByte":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            write!(fmtr, \"{}\", self.description())\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            ($desc)(self)\n        }\n    }"],"errors::InvalidUtf8Slice":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            match (self.cause(), $use_cause) {\n                (Some(d),true) => write!(fmtr, \"{}: {}\", self.description(), d),\n                        _      => write!(fmtr, \"{}\", self.description()),\n            }\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            match *self{ $($desc => $string,)* }\n        }\n        $(#[$causedoc])*\n        fn cause(&self) -> Option<&Error> {\n            match *self{ $($cause => $result,)* }\n        }\n    }","impl From<$sub> for $err {\n          fn from(error: $sub) -> $err {\n              $to(error)\n          }\n      }"],"errors::NonAsciiError":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            write!(fmtr, \"{}\", self.description())\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            ($desc)(self)\n        }\n    }"],"errors::NonBMPError":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            write!(fmtr, \"{}\", self.description())\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            ($desc)(self)\n        }\n    }"],"errors::Utf16PairError":["Clone","Copy","Debug","Eq","PartialEq","impl Display for $err {\n        fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result {\n            write!(fmtr, \"{}\", self.description())\n        }\n    }","impl Error for $err {\n        fn description(&self) -> &'static str {\n            ($desc)(self)\n        }\n    }"],"std::string::String":["impl Extend<Utf16Char> for String {\n    fn extend<I:IntoIterator<Item=Utf16Char>>(&mut self,  iter: I) {\n        self.extend(iter.into_iter().map(|u16c| Utf8Char::from(u16c) ));\n    }\n}","impl Extend<Utf8Char> for String {\n    fn extend<I:IntoIterator<Item=Utf8Char>>(&mut self,  iter: I) {\n        unsafe { self.as_mut_vec().extend(iter) }\n    }\n}","impl FromIterator<Utf16Char> for String {\n    fn from_iter<I:IntoIterator<Item=Utf16Char>>(iter: I) -> Self {\n        let mut s = String::new();\n        s.extend(iter);\n        return s;\n    }\n}","impl FromIterator<Utf8Char> for String {\n    fn from_iter<I:IntoIterator<Item=Utf8Char>>(iter: I) -> String {\n        let mut string = String::new();\n        string.extend(iter);\n        return string;\n    }\n}","impl<'a> Extend<&'a Utf16Char> for String {\n    fn extend<I:IntoIterator<Item=&'a Utf16Char>>(&mut self,  iter: I) {\n        self.extend(iter.into_iter().cloned());\n    }\n}","impl<'a> Extend<&'a Utf8Char> for String {\n    fn extend<I:IntoIterator<Item=&'a Utf8Char>>(&mut self,  iter: I) {\n        self.extend(iter.into_iter().cloned())\n    }\n}","impl<'a> FromIterator<&'a Utf16Char> for String {\n    fn from_iter<I:IntoIterator<Item=&'a Utf16Char>>(iter: I) -> Self {\n        Self::from_iter(iter.into_iter().cloned())\n    }\n}","impl<'a> FromIterator<&'a Utf8Char> for String {\n    fn from_iter<I:IntoIterator<Item=&'a Utf8Char>>(iter: I) -> String {\n        iter.into_iter().cloned().collect()\n    }\n}"],"std::vec::Vec":["impl Extend<Utf16Char> for Vec<u16> {\n    fn extend<I:IntoIterator<Item=Utf16Char>>(&mut self,  iter: I) {\n        let iter = iter.into_iter();\n        self.reserve(iter.size_hint().0);\n        for u16c in iter {\n            self.push(u16c.units[0]);\n            if u16c.units[1] != 0 {\n                self.push(u16c.units[1]);\n            }\n        }\n    }\n}","impl Extend<Utf8Char> for Vec<u8> {\n    fn extend<I:IntoIterator<Item=Utf8Char>>(&mut self,  iter: I) {\n        let iter = iter.into_iter();\n        self.reserve(iter.size_hint().0);\n        for u8c in iter {\n            // twice as fast as self.extend_from_slice(u8c.as_bytes());\n            self.push(u8c.bytes[0]);\n            for &extra in &u8c.bytes[1..] {\n                if extra != 0 {\n                    self.push(extra);\n                }\n            }\n        }\n    }\n}","impl FromIterator<Utf16Char> for Vec<u16> {\n    fn from_iter<I:IntoIterator<Item=Utf16Char>>(iter: I) -> Self {\n        let mut vec = Vec::new();\n        vec.extend(iter);\n        return vec;\n    }\n}","impl FromIterator<Utf8Char> for Vec<u8> {\n    fn from_iter<I:IntoIterator<Item=Utf8Char>>(iter: I) -> Self {\n        iter.into_iter().collect::<String>().into_bytes()\n    }\n}","impl<'a> Extend<&'a Utf16Char> for Vec<u16> {\n    fn extend<I:IntoIterator<Item=&'a Utf16Char>>(&mut self,  iter: I) {\n        self.extend(iter.into_iter().cloned())\n    }\n}","impl<'a> Extend<&'a Utf8Char> for Vec<u8> {\n    fn extend<I:IntoIterator<Item=&'a Utf8Char>>(&mut self,  iter: I) {\n        self.extend(iter.into_iter().cloned())\n    }\n}","impl<'a> FromIterator<&'a Utf16Char> for Vec<u16> {\n    fn from_iter<I:IntoIterator<Item=&'a Utf16Char>>(iter: I) -> Self {\n        Self::from_iter(iter.into_iter().cloned())\n    }\n}","impl<'a> FromIterator<&'a Utf8Char> for Vec<u8> {\n    fn from_iter<I:IntoIterator<Item=&'a Utf8Char>>(iter: I) -> Self {\n        iter.into_iter().cloned().collect::<String>().into_bytes()\n    }\n}"],"utf16_char::Utf16Char":["Clone","Copy","Default","Eq","PartialEq","impl AsRef<[u16]> for Utf16Char {\n    #[inline]\n    fn as_ref(&self) -> &[u16] {\n        &self.units[..self.len()]\n    }\n}","impl AsciiExt for Utf16Char {\n    type Owned = Self;\n    fn is_ascii(&self) -> bool {\n        self.units[0] < 128\n    }\n    fn eq_ignore_ascii_case(&self,  other: &Self) -> bool {\n        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n    }\n    fn to_ascii_uppercase(&self) -> Self {\n        let n = self.units[0].wrapping_sub(b'a' as u16);\n        if n < 26 {Utf16Char{ units: [n+b'A' as u16, 0] }}\n        else      {*self}\n    }\n    fn to_ascii_lowercase(&self) -> Self {\n        let n = self.units[0].wrapping_sub(b'A' as u16);\n        if n < 26 {Utf16Char{ units: [n+b'a' as u16, 0] }}\n        else      {*self}\n    }\n    fn make_ascii_uppercase(&mut self) {\n        *self = self.to_ascii_uppercase()\n    }\n    fn make_ascii_lowercase(&mut self) {\n        *self = self.to_ascii_lowercase();\n    }\n}","impl Borrow<[u16]> for Utf16Char {\n    #[inline]\n    fn borrow(&self) -> &[u16] {\n        self.as_ref()\n    }\n}","impl Deref for Utf16Char {\n    type Target = [u16];\n    #[inline]\n    fn deref(&self) -> &[u16] {\n        self.as_ref()\n    }\n}","impl From<Utf8Char> for Utf16Char {\n    fn from(utf8: Utf8Char) -> Utf16Char {\n        let (b, utf8_len) = utf8.to_array();\n        match utf8_len {\n            1 => Utf16Char{ units: [b[0] as u16, 0] },\n            4 => {// need surrogate\n                let mut first = 0xd800 - (0x01_00_00u32 >> 10) as u16;\n                first += (b[0] as u16 & 0x07) << 8;\n                first += (b[1] as u16 & 0x3f) << 2;\n                first += (b[2] as u16 & 0x30) >> 4;\n                let mut second = 0xdc00;\n                second |= (b[2] as u16 & 0x0f) << 6;\n                second |=  b[3] as u16 & 0x3f;\n                Utf16Char{ units: [first, second] }\n            },\n            _ => { // 2 or 3\n                let mut unit = ((b[0] as u16 & 0x1f) << 6) | (b[1] as u16 & 0x3f);\n                if utf8_len == 3 {\n                    unit = (unit << 6) | (b[2] as u16 & 0x3f);\n                }\n                Utf16Char{ units: [unit, 0] }\n            },\n        }\n    }\n}","impl From<char> for Utf16Char {\n    fn from(c: char) -> Self {\n        let (first, second) = c.to_utf16_tuple();\n        Utf16Char{ units: [first, second.unwrap_or(0)] }\n    }\n}","impl FromStr for Utf16Char {\n    type Err = FromStrError;\n    /// Create an `Utf16Char` from a string slice.\n    /// The string must contain exactly one codepoint.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::error::FromStrError::*;\n    /// use encode_unicode::Utf16Char;\n    /// use std::str::FromStr;\n    ///\n    /// assert_eq!(Utf16Char::from_str(\"a\"), Ok(Utf16Char::from('a')));\n    /// assert_eq!(Utf16Char::from_str(\"🂠\"), Ok(Utf16Char::from('🂠')));\n    /// assert_eq!(Utf16Char::from_str(\"\"), Err(Empty));\n    /// assert_eq!(Utf16Char::from_str(\"ab\"), Err(MultipleCodepoints));\n    /// assert_eq!(Utf16Char::from_str(\"é\"), Err(MultipleCodepoints));// 'e'+u301 combining mark\n    /// ```\n    fn from_str(s: &str) -> Result<Self, FromStrError> {\n        match Utf16Char::from_str_start(s) {\n            Ok((u16c,bytes)) if bytes == s.len() => Ok(u16c),\n            Ok((_,_)) => Err(FromStrError::MultipleCodepoints),\n            Err(EmptyStrError) => Err(FromStrError::Empty),\n        }\n    }\n}","impl IntoIterator for Utf16Char {\n    type Item=u16;\n    type IntoIter=Utf16Iterator;\n    /// Iterate over the units.\n    fn into_iter(self) -> Utf16Iterator {\n        Utf16Iterator::from(self)\n    }\n}","impl Ord for Utf16Char {\n    #[inline]\n    fn cmp(&self,  rhs: &Self) -> Ordering {\n        // Shift the first unit by 0xd if surrogate, and 0 otherwise.\n        // This ensures surrogates are always greater than 0xffff, and\n        // that the second unit only affect the result when the first are equal.\n        // Multiplying by a constant factor isn't enough because that factor\n        // would have to be greater than 1023 and smaller than 5.5.\n        // This transformation is less complicated than combine_surrogates().\n        let lhs = (self.units[0] as u32, self.units[1] as u32);\n        let rhs = (rhs.units[0] as u32, rhs.units[1] as u32);\n        let lhs = (lhs.0 << (lhs.1 >> 12)) + lhs.1;\n        let rhs = (rhs.0 << (rhs.1 >> 12)) + rhs.1;\n        lhs.cmp(&rhs)\n    }\n}","impl PartialEq<Utf8Char> for Utf16Char {\n    fn eq(&self,  u8c: &Utf8Char) -> bool {\n        *self == Utf16Char::from(*u8c)\n    }\n}","impl PartialEq<char> for Utf16Char {\n    fn eq(&self,  u32c: &char) -> bool {\n        *self == Utf16Char::from(*u32c)\n    }\n}","impl PartialEq<u16> for Utf16Char {\n    fn eq(&self,  unit: &u16) -> bool {\n        self.units[0] == *unit  &&  self.units[1] == 0\n    }\n}","impl PartialEq<u8> for Utf16Char {\n    fn eq(&self,  byte: &u8) -> bool {\n        self.units[0] == *byte as u16\n    }\n}","impl PartialOrd for Utf16Char {\n    #[inline]\n    fn partial_cmp(&self,  rhs: &Self) -> Option<Ordering> {\n        Some(self.cmp(rhs))\n    }\n}","impl PartialOrd<Utf8Char> for Utf16Char {\n    fn partial_cmp(&self,  u8c: &Utf8Char) -> Option<Ordering> {\n        self.partial_cmp(&Utf16Char::from(*u8c))\n    }\n}","impl PartialOrd<char> for Utf16Char {\n    fn partial_cmp(&self,  u32c: &char) -> Option<Ordering> {\n        self.partial_cmp(&Utf16Char::from(*u32c))\n    }\n}","impl Utf16Char {\n    /// Create an `Utf16Char` from the first codepoint in a string slice,\n    /// converting from UTF-8 to UTF-16.\n    ///\n    /// The returned `usize` is the number of UTF-8 bytes used from the str,\n    /// and not the number of UTF-16 units.\n    ///\n    /// Returns an error if the `str` is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::Utf16Char;\n    ///\n    /// assert_eq!(Utf16Char::from_str_start(\"a\"), Ok((Utf16Char::from('a'),1)));\n    /// assert_eq!(Utf16Char::from_str_start(\"ab\"), Ok((Utf16Char::from('a'),1)));\n    /// assert_eq!(Utf16Char::from_str_start(\"🂠 \"), Ok((Utf16Char::from('🂠'),4)));\n    /// assert_eq!(Utf16Char::from_str_start(\"é\"), Ok((Utf16Char::from('e'),1)));// 'e'+u301 combining mark\n    /// assert!(Utf16Char::from_str_start(\"\").is_err());\n    /// ```\n    pub fn from_str_start(s: &str) -> Result<(Self,usize), EmptyStrError> {\n        if s.is_empty() {\n            return Err(EmptyStrError);\n        }\n        let b = s.as_bytes();\n        // Read the last byte first to reduce the number of unnecesary length checks.\n        match b[0] {\n            0...127 => {// 1 byte => 1 unit\n                let unit = b[0] as u16;// 0b0000_0000_0xxx_xxxx\n                Ok((Utf16Char{ units: [unit, 0] }, 1))\n            },\n            0b1000_0000...0b1101_1111 => {// 2 bytes => 1 unit\n                let unit = (((b[1] & 0x3f) as u16) << 0) // 0b0000_0000_00xx_xxxx\n                         | (((b[0] & 0x1f) as u16) << 6);// 0b0000_0xxx_xx00_0000\n                Ok((Utf16Char{ units: [unit, 0] }, 2))\n            },\n            0b1110_0000...0b1110_1111 => {// 3 bytes => 1 unit\n                let unit = (((b[2] & 0x3f) as u16) <<  0) // 0b0000_0000_00xx_xxxx\n                         | (((b[1] & 0x3f) as u16) <<  6) // 0b0000_xxxx_xx00_0000\n                         | (((b[0] & 0x0f) as u16) << 12);// 0bxxxx_0000_0000_0000\n                Ok((Utf16Char{ units: [unit, 0] }, 3))\n            },\n            _ => {// 4 bytes => 2 units\n                let second = 0xdc00                        // 0b1101_1100_0000_0000\n                           | (((b[3] & 0x3f) as u16) << 0) // 0b0000_0000_00xx_xxxx\n                           | (((b[2] & 0x0f) as u16) << 6);// 0b0000_00xx_xx00_0000\n                let first = 0xd800-(0x01_00_00u32>>10) as u16// 0b1101_0111_1100_0000\n                          + (((b[2] & 0x30) as u16) >> 4)    // 0b0000_0000_0000_00xx\n                          + (((b[1] & 0x3f) as u16) << 2)    // 0b0000_0000_xxxx_xx00\n                          + (((b[0] & 0x07) as u16) << 8);   // 0b0000_0xxx_0000_0000\n                Ok((Utf16Char{ units: [first, second] }, 4))\n            }\n        }\n    }\n    /// Validate and store the first UTF-16 codepoint in the slice.\n    /// Also return how many units were needed.\n    pub fn from_slice_start(src: &[u16]) -> Result<(Self,usize), InvalidUtf16Slice> {\n        char::from_utf16_slice_start(src).map(|(_,len)| {\n            let second = if len==2 {src[1]} else {0};\n            (Utf16Char{ units: [src[0], second] }, len)\n        })\n    }\n    /// Store the first UTF-16 codepoint of the slice.\n    ///\n    /// # Safety\n    ///\n    /// The slice must be non-empty and start with a valid UTF-16 codepoint.  \n    /// The length of the slice is never checked.\n    pub unsafe fn from_slice_start_unchecked(src: &[u16]) -> (Self,usize) {\n        let first = *src.get_unchecked(0);\n        if first.is_utf16_leading_surrogate() {\n            (Utf16Char{ units: [first, *src.get_unchecked(1)] }, 2)\n        } else {\n            (Utf16Char{ units: [first, 0] }, 1)\n        }\n    }\n    /// Validate and store an UTF-16 array as returned from `char.to_utf16_array()`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::Utf16Char;\n    /// use encode_unicode::error::InvalidUtf16Array;\n    ///\n    /// assert_eq!(Utf16Char::from_array(['x' as u16, 'y' as u16]), Ok(Utf16Char::from('x')));\n    /// assert_eq!(Utf16Char::from_array(['睷' as u16, 0]), Ok(Utf16Char::from('睷')));\n    /// assert_eq!(Utf16Char::from_array([0xda6f, 0xdcde]), Ok(Utf16Char::from('\\u{abcde}')));\n    /// assert_eq!(Utf16Char::from_array([0xf111, 0xdbad]), Ok(Utf16Char::from('\\u{f111}')));\n    /// assert_eq!(Utf16Char::from_array([0xdaaf, 0xdaaf]), Err(InvalidUtf16Array::SecondIsNotTrailingSurrogate));\n    /// assert_eq!(Utf16Char::from_array([0xdcac, 0x9000]), Err(InvalidUtf16Array::FirstIsTrailingSurrogate));\n    /// ```\n    pub fn from_array(units: [u16; 2]) -> Result<Self,InvalidUtf16Array> {\n        if (units[0] & 0xf8_00) != 0xd8_00 {\n            Ok(Utf16Char { units: [units[0], 0] })\n        } else if units[0] < 0xdc_00  &&  (units[1] & 0xfc_00) == 0xdc_00 {\n            Ok(Utf16Char { units: units })\n        } else if units[0] < 0xdc_00 {\n            Err(InvalidUtf16Array::SecondIsNotTrailingSurrogate)\n        } else {\n            Err(InvalidUtf16Array::FirstIsTrailingSurrogate)\n        }\n    }\n    /// Create an `Utf16Char` from an array as returned from `char.to_utf16_array()`.\n    ///\n    /// # Safety\n    ///\n    /// The units must form a valid codepoint, and the second unit must be 0\n    /// when a surrogate pair is not required.\n    /// Violating this can easily lead to undefined behavior, although unlike\n    /// `char` bad `Utf16Char`s simply existing is not immediately UB.\n    pub unsafe fn from_array_unchecked(units: [u16; 2]) -> Self {\n        Utf16Char { units: units }\n    }\n    /// Validate and store a UTF-16 pair as returned from `char.to_utf16_tuple()`.\n    pub fn from_tuple(utf16: (u16,Option<u16>)) -> Result<Self,InvalidUtf16Tuple> {\n        unsafe {char::from_utf16_tuple(utf16).map(|_|\n            Self::from_tuple_unchecked(utf16)\n        )}\n    }\n    /// Create an `Utf16Char` from a tuple as returned from `char.to_utf16_tuple()`.\n    ///\n    /// # Safety\n    ///\n    /// The units must form a valid codepoint with the second being 0 when a\n    /// surrogate pair is not required.\n    /// Violating this can easily lead to undefined behavior.\n    pub unsafe fn from_tuple_unchecked(utf16: (u16,Option<u16>)) -> Self {\n        Utf16Char { units: [utf16.0, utf16.1.unwrap_or(0)] }\n    }\n    /// Create an `Utf16Char` from a single unit.\n    ///\n    /// Codepoints < '\\u{1_0000}' (which fit in a `u16`) are part of the basic\n    /// multilingual plane unless they are reserved for surrogate pairs.\n    ///\n    /// # Errors\n    ///\n    /// Returns `NonBMPError` if the unit is in the range `0xd800..0xe000`\n    /// (which means that it's part of a surrogat pair)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use encode_unicode::Utf16Char;\n    /// assert_eq!(Utf16Char::from_bmp(0x40).unwrap(), '@');\n    /// assert_eq!(Utf16Char::from_bmp('ø' as u16).unwrap(), 'ø');\n    /// assert!(Utf16Char::from_bmp(0xdddd).is_err());\n    /// ```\n    pub fn from_bmp(bmp_codepoint: u16) -> Result<Self,NonBMPError> {\n        if bmp_codepoint & 0xf800 != 0xd800 {\n            Ok(Utf16Char{ units: [bmp_codepoint, 0] })\n        } else {\n            Err(NonBMPError)\n        }\n    }\n    /// Create an `Utf16Char` from a single unit without checking that it's a\n    /// valid codepoint on its own.\n    ///\n    /// # Safety\n    ///\n    /// The unit must be less than 0xd800 or greater than 0xdfff.\n    /// In other words, not part of a surrogate pair.  \n    /// Violating this can easily lead to undefined behavior.\n    #[inline]\n    pub unsafe fn from_bmp_unchecked(bmp_codepoint: u16) -> Self {\n        Utf16Char{ units: [bmp_codepoint, 0] }\n    }\n    /// Checks that the codepoint is in the basic multilingual plane.\n    ///\n    /// # Examples\n    /// ```\n    /// # use encode_unicode::Utf16Char;\n    /// assert_eq!(Utf16Char::from('e').is_bmp(), true);\n    /// assert_eq!(Utf16Char::from('€').is_bmp(), true);\n    /// assert_eq!(Utf16Char::from('𝔼').is_bmp(), false);\n    /// ```\n    #[inline]\n    pub fn is_bmp(&self) -> bool {\n        self.units[1] == 0\n    }\n\n    /// The number of units this character is made up of.\n    ///\n    /// Is either 1 or 2 and identical to `.as_char().len_utf16()`\n    /// or `.as_ref().len()`.\n    #[inline]\n    pub fn len(self) -> usize {\n        1 + (self.units[1] as usize >> 15)\n    }\n    // There is no `.is_emty()` because it would always return false.\n\n    /// Checks that the codepoint is an ASCII character.\n    #[inline]\n    pub fn is_ascii(&self) -> bool {\n        self.units[0] <= 127\n    }\n    /// Checks that two characters are an ASCII case-insensitive match.\n    ///\n    /// Is equivalent to `a.to_ascii_lowercase() == b.to_ascii_lowercase()`.\n    #[cfg(feature=\"std\")]\n    pub fn eq_ignore_ascii_case(&self,  other: &Self) -> bool {\n        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n    }\n    /// Converts the character to its ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    #[cfg(feature=\"std\")]\n    pub fn to_ascii_uppercase(&self) -> Self {\n        let n = self.units[0].wrapping_sub(b'a' as u16);\n        if n < 26 {Utf16Char{ units: [n+b'A' as u16, 0] }}\n        else      {*self}\n    }\n    /// Converts the character to its ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    #[cfg(feature=\"std\")]\n    pub fn to_ascii_lowercase(&self) -> Self {\n        let n = self.units[0].wrapping_sub(b'A' as u16);\n        if n < 26 {Utf16Char{ units: [n+b'a' as u16, 0] }}\n        else      {*self}\n    }\n    /// Converts the character to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    #[cfg(feature=\"std\")]\n    pub fn make_ascii_uppercase(&mut self) {\n        *self = self.to_ascii_uppercase()\n    }\n    /// Converts the character to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    #[cfg(feature=\"std\")]\n    pub fn make_ascii_lowercase(&mut self) {\n        *self = self.to_ascii_lowercase();\n    }\n\n    /// Convert from UTF-16 to UTF-32\n    pub fn to_char(self) -> char {\n        self.into()\n    }\n    /// Write the internal representation to a slice,\n    /// and then returns the number of `u16`s written.\n    ///\n    /// # Panics\n    /// Will panic the buffer is too small;\n    /// You can get the required length from `.len()`,\n    /// but a buffer of length two is always large enough.\n    pub fn to_slice(self,  dst: &mut[u16]) -> usize {\n        // Write the last unit first to avoid repeated length checks.\n        let extra = self.units[1] as usize >> 15;\n        match dst.get_mut(extra) {\n            Some(first) => *first = self.units[extra],\n            None => panic!(\"The provided buffer is too small.\")\n        }\n        if extra != 0 {dst[0] = self.units[0];}\n        extra+1\n    }\n    /// Get the character represented as an array of two units.\n    ///\n    /// The second `u16` is zero for codepoints that fit in one unit.\n    #[inline]\n    pub fn to_array(self) -> [u16;2] {\n        self.units\n    }\n    /// The second `u16` is used for surrogate pairs.\n    #[inline]\n    pub fn to_tuple(self) -> (u16,Option<u16>) {\n        (self.units[0],  if self.units[1]==0 {None} else {Some(self.units[1])})\n    }\n}","impl fmt::Debug for Utf16Char {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&self.to_char(), fmtr)\n    }\n}","impl fmt::Display for Utf16Char {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(&Utf8Char::from(*self), fmtr)\n    }\n}","impl hash::Hash for Utf16Char {\n    fn hash<H : hash::Hasher>(&self,  state: &mut H) {\n        self.to_char().hash(state);\n    }\n}"],"utf16_iterators::Utf16CharIndices":["Clone","impl<'a> DoubleEndedIterator for Utf16CharIndices<'a> {\n    fn next_back(&mut self) -> Option<(usize,Utf16Char)> {\n        if self.index < self.str.len() {\n            let rev = self.str.bytes().rev();\n            let len = 1 + rev.take_while(|b| b & 0b1100_0000 == 0b1000_0000 ).count();\n            let starts = self.str.len() - len;\n            let (u16c,_) = Utf16Char::from_str_start(&self.str[starts..]).unwrap();\n            self.str = &self.str[..starts];\n            Some((starts, u16c))\n        } else {\n            None\n        }\n    }\n}","impl<'a> From<&'a str> for Utf16CharIndices<'a> {\n    fn from(s: &str) -> Utf16CharIndices {\n        Utf16CharIndices{str: s, index: 0}\n    }\n}","impl<'a> Iterator for Utf16CharIndices<'a> {\n    type Item = (usize,Utf16Char);\n    fn next(&mut self) -> Option<(usize,Utf16Char)> {\n        match Utf16Char::from_str_start(&self.str[self.index..]) {\n            Ok((u16c, bytes)) => {\n                let item = (self.index, u16c);\n                self.index += bytes;\n                Some(item)\n            },\n            Err(EmptyStrError) => None\n        }\n    }\n    fn size_hint(&self) -> (usize,Option<usize>) {\n        let len = self.str.len() - self.index;\n        // For len+3 to overflow, the slice must fill all but two bytes of\n        // addressable memory, and size_hint() doesn't need to be correct.\n        (len.wrapping_add(3)/4, Some(len))\n    }\n}","impl<'a> Utf16CharIndices<'a> {\n    /// Extract the remainder of the source `str`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::{StrExt, Utf16Char};\n    /// let mut iter = \"abc\".utf16char_indices();\n    /// assert_eq!(iter.next_back(), Some((2, Utf16Char::from('c'))));\n    /// assert_eq!(iter.next(), Some((0, Utf16Char::from('a'))));\n    /// assert_eq!(iter.as_str(), \"b\");\n    /// ```\n    pub fn as_str(&self) -> &'a str {\n        &self.str[self.index..]\n    }\n}","impl<'a> fmt::Debug for Utf16CharIndices<'a> {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        fmtr.debug_tuple(\"Utf16CharIndices\")\n            .field(&self.index)\n            .field(&self.as_str())\n            .finish()\n    }\n}"],"utf16_iterators::Utf16CharSplitter":["Clone","impl<I:Iterator<Item=Utf16Char>> From<I> for Utf16CharSplitter<Utf16Char,I> {\n    /// A less generic constructor than `iter_units()`\n    fn from(iter: I) -> Self {\n        iter_units(iter)\n    }\n}","impl<U:Borrow<Utf16Char>, I:Iterator<Item=U>> Iterator for Utf16CharSplitter<U,I> {\n    type Item = u16;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.prev_second == 0 {\n            self.inner.next().map(|u16c| {\n                let units = u16c.borrow().to_array();\n                self.prev_second = units[1];\n                units[0]\n            })\n        } else {\n            let prev_second = self.prev_second;\n            self.prev_second = 0;\n            Some(prev_second)\n        }\n    }\n    fn size_hint(&self) -> (usize,Option<usize>) {\n        // Doesn't need to handle unlikely overflows correctly because\n        // size_hint() cannot be relied upon anyway. (the trait isn't unsafe)\n        let (min, max) = self.inner.size_hint();\n        let add = if self.prev_second == 0 {0} else {1};\n        (min.wrapping_add(add), max.map(|max| max.wrapping_mul(2).wrapping_add(add) ))\n    }\n}","impl<U:Borrow<Utf16Char>, I:Iterator<Item=U>> Utf16CharSplitter<U,I> {\n    /// Extracts the source iterator.\n    ///\n    /// Note that `iter_units(iter.into_inner())` is not a no-op:  \n    /// If the last returned unit from `next()` was a leading surrogate,\n    /// the trailing surrogate is lost.\n    pub fn into_inner(self) -> I {\n        self.inner\n    }\n}"],"utf16_iterators::Utf16Chars":["Clone","impl<'a> DoubleEndedIterator for Utf16Chars<'a> {\n    fn next_back(&mut self) -> Option<Utf16Char> {\n        self.0.next_back().map(|(_,u16c)| u16c )\n    }\n}","impl<'a> From<&'a str> for Utf16Chars<'a> {\n    fn from(s: &str) -> Utf16Chars {\n        Utf16Chars(Utf16CharIndices::from(s))\n    }\n}","impl<'a> Iterator for Utf16Chars<'a> {\n    type Item = Utf16Char;\n    fn next(&mut self) -> Option<Utf16Char> {\n        self.0.next().map(|(_,u16c)| u16c )\n    }\n    fn size_hint(&self) -> (usize,Option<usize>) {\n        self.0.size_hint()\n    }\n}","impl<'a> Utf16Chars<'a> {\n    /// Extract the remainder of the source `str`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::{StrExt, Utf16Char};\n    /// let mut iter = \"abc\".utf16chars();\n    /// assert_eq!(iter.next(), Some(Utf16Char::from('a')));\n    /// assert_eq!(iter.next_back(), Some(Utf16Char::from('c')));\n    /// assert_eq!(iter.as_str(), \"b\");\n    /// ```\n    pub fn as_str(&self) -> &'a str {\n        self.0.as_str()\n    }\n}","impl<'a> fmt::Debug for Utf16Chars<'a> {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        fmtr.debug_tuple(\"Utf16Chars\")\n            .field(&self.as_str())\n            .finish()\n    }\n}"],"utf16_iterators::Utf16Iterator":["Clone","impl ExactSizeIterator for Utf16Iterator {\n    fn len(&self) -> usize {\n        (if self.first == FIRST_USED {0} else {1}) +\n        (if self.second == SECOND_USED {0} else {1})\n    }\n}","impl From<Utf16Char> for Utf16Iterator {\n    fn from(uc: Utf16Char) -> Self {\n        let (first, second) = uc.to_tuple();\n        Utf16Iterator{ first: first,  second: second.unwrap_or(SECOND_USED) }\n    }\n}","impl From<char> for Utf16Iterator {\n    fn from(c: char) -> Self {\n        let (first, second) = c.to_utf16_tuple();\n        Utf16Iterator{ first: first,  second: second.unwrap_or(SECOND_USED) }\n    }\n}","impl Iterator for Utf16Iterator {\n    type Item=u16;\n    fn next(&mut self) -> Option<u16> {\n        match (self.first, self.second) {\n            (FIRST_USED, SECOND_USED)  =>  {                            None        },\n            (FIRST_USED, second     )  =>  {self.second = SECOND_USED;  Some(second)},\n            (first     ,      _     )  =>  {self.first = FIRST_USED;    Some(first )},\n        }\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.len(), Some(self.len()))\n    }\n}","impl fmt::Debug for Utf16Iterator {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        let mut clone = self.clone();\n        match (clone.next(), clone.next()) {\n            (Some(one), None)  => write!(fmtr, \"[{}]\", one),\n            (Some(a), Some(b)) => write!(fmtr, \"[{}, {}]\", a, b),\n            (None,  _)         => write!(fmtr, \"[]\"),\n        }\n    }\n}"],"utf8_char::Utf8Char":["Clone","Copy","Default","Eq","Ord","PartialEq","PartialOrd","impl AsRef<[u8]> for Utf8Char {\n    fn as_ref(&self) -> &[u8] {\n        &self.bytes[..self.len()]\n    }\n}","impl AsRef<str> for Utf8Char {\n    fn as_ref(&self) -> &str {\n        unsafe{ str::from_utf8_unchecked( self.as_ref() ) }\n    }\n}","impl AsciiExt for Utf8Char {\n    type Owned = Utf8Char;\n    fn is_ascii(&self) -> bool {\n        self.bytes[0].is_ascii()\n    }\n    fn eq_ignore_ascii_case(&self,  other: &Self) -> bool {\n        if self.is_ascii() {self.bytes[0].eq_ignore_ascii_case(&other.bytes[0])}\n        else               {self == other}\n    }\n    fn to_ascii_uppercase(&self) -> Self::Owned {\n        let mut uc = *self;\n        uc.make_ascii_uppercase();\n        uc\n    }\n    fn to_ascii_lowercase(&self) -> Self::Owned {\n        let mut uc = *self;\n        uc.make_ascii_lowercase();\n        uc\n    }\n    fn make_ascii_uppercase(&mut self) {\n        self.bytes[0].make_ascii_uppercase()\n    }\n    fn make_ascii_lowercase(&mut self) {\n        self.bytes[0].make_ascii_lowercase();\n    }\n}","impl Borrow<[u8]> for Utf8Char {\n    fn borrow(&self) -> &[u8] {\n        self.as_ref()\n    }\n}","impl Borrow<str> for Utf8Char {\n    fn borrow(&self) -> &str {\n        self.as_ref()\n    }\n}","impl Deref for Utf8Char {\n    type Target = str;\n    fn deref(&self) -> &Self::Target {\n        self.as_ref()\n    }\n}","impl From<Utf16Char> for Utf8Char {\n    fn from(utf16: Utf16Char) -> Utf8Char {\n        match utf16.to_tuple() {\n            (a @ 0...0x00_7f, _) => {\n                Utf8Char{ bytes: [a as u8, 0, 0, 0] }\n            },\n            (u @ 0...0x07_ff, _) => {\n                let b = 0x80 |  (u & 0x00_3f) as u8;\n                let a = 0xc0 | ((u & 0x07_c0) >> 6) as u8;\n                Utf8Char{ bytes: [a, b, 0, 0] }\n            },\n            (u, None) => {\n                let c = 0x80 |  (u & 0x00_3f) as u8;\n                let b = 0x80 | ((u & 0x0f_c0) >> 6) as u8;\n                let a = 0xe0 | ((u & 0xf0_00) >> 12) as u8;\n                Utf8Char{ bytes: [a, b, c, 0] }\n            },\n            (f, Some(s)) => {\n                let f = f + (0x01_00_00u32 >> 10) as u16;\n                let d = 0x80 |  (s & 0x00_3f) as u8;\n                let c = 0x80 | ((s & 0x03_c0) >> 6) as u8\n                             | ((f & 0x00_03) << 4) as u8;\n                let b = 0x80 | ((f & 0x00_fc) >> 2) as u8;\n                let a = 0xf0 | ((f & 0x07_00) >> 8) as u8;\n                Utf8Char{ bytes: [a, b, c, d] }\n            }\n        }\n    }\n}","impl From<char> for Utf8Char {\n    fn from(c: char) -> Self {\n        Utf8Char{ bytes: c.to_utf8_array().0 }\n    }\n}","impl IntoIterator for Utf8Char {\n    type Item=u8;\n    type IntoIter=Utf8Iterator;\n    /// Iterate over the byte values.\n    fn into_iter(self) -> Utf8Iterator {\n        Utf8Iterator::from(self)\n    }\n}","impl PartialEq<Utf16Char> for Utf8Char {\n    fn eq(&self,  u16c: &Utf16Char) -> bool {\n        *self == Self::from(*u16c)\n    }\n}","impl PartialEq<char> for Utf8Char {\n    fn eq(&self,  u32c: &char) -> bool {\n        *self == Utf8Char::from(*u32c)\n    }\n}","impl PartialEq<u8> for Utf8Char {\n    fn eq(&self,  byte: &u8) -> bool {\n        self.bytes[0] == *byte  &&  self.bytes[1] == 0\n    }\n}","impl PartialOrd<Utf16Char> for Utf8Char {\n    fn partial_cmp(&self,  u16c: &Utf16Char) -> Option<Ordering> {\n        self.partial_cmp(&Self::from(*u16c))\n    }\n}","impl PartialOrd<char> for Utf8Char {\n    fn partial_cmp(&self,  u32c: &char) -> Option<Ordering> {\n        self.partial_cmp(&Self::from(*u32c))\n    }\n}","impl Utf8Char {\n    /// Create an `Utf8Char` from the first codepoint in a `str`.\n    ///\n    /// Returns an error if the `str` is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::Utf8Char;\n    ///\n    /// assert_eq!(Utf8Char::from_str_start(\"a\"), Ok((Utf8Char::from('a'),1)));\n    /// assert_eq!(Utf8Char::from_str_start(\"ab\"), Ok((Utf8Char::from('a'),1)));\n    /// assert_eq!(Utf8Char::from_str_start(\"🂠 \"), Ok((Utf8Char::from('🂠'),4)));\n    /// assert_eq!(Utf8Char::from_str_start(\"é\"), Ok((Utf8Char::from('e'),1)));// 'e'+u301 combining mark\n    /// assert!(Utf8Char::from_str_start(\"\").is_err());\n    /// ```\n    pub fn from_str_start(src: &str) -> Result<(Self,usize),EmptyStrError> {\n        unsafe {\n            if src.is_empty() {\n                Err(EmptyStrError)\n            } else {\n                Ok(Utf8Char::from_slice_start_unchecked(src.as_bytes()))\n            }\n        }\n    }\n    /// Create an `Utf8Char` of the first codepoint in an UTF-8 slice.  \n    /// Also returns the length of the UTF-8 sequence for the codepoint.\n    ///\n    /// If the slice is from a `str`, use `::from_str_start()` to skip UTF-8 validation.\n    ///\n    /// # Errors\n    ///\n    /// Returns an `Err` if the slice is empty, doesn't start with a valid\n    /// UTF-8 sequence or is too short for the sequence.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::Utf8Char;\n    /// use encode_unicode::error::InvalidUtf8Slice::*;\n    /// use encode_unicode::error::InvalidUtf8::*;\n    ///\n    /// assert_eq!(Utf8Char::from_slice_start(&[b'A', b'B', b'C']), Ok((Utf8Char::from('A'),1)));\n    /// assert_eq!(Utf8Char::from_slice_start(&[0xdd, 0xbb]), Ok((Utf8Char::from('\\u{77b}'),2)));\n    ///\n    /// assert_eq!(Utf8Char::from_slice_start(&[]), Err(TooShort(1)));\n    /// assert_eq!(Utf8Char::from_slice_start(&[0xf0, 0x99]), Err(TooShort(4)));\n    /// assert_eq!(Utf8Char::from_slice_start(&[0xee, b'F', 0x80]), Err(Utf8(NotAContinuationByte(1))));\n    /// assert_eq!(Utf8Char::from_slice_start(&[0xee, 0x99, 0x0f]), Err(Utf8(NotAContinuationByte(2))));\n    /// ```\n    pub fn from_slice_start(src: &[u8]) -> Result<(Self,usize),InvalidUtf8Slice> {\n        char::from_utf8_slice_start(src).map(|(_,len)| {\n            let mut bytes = [0; 4];\n            bytes[..len].copy_from_slice(&src[..len]);\n            (Utf8Char{ bytes: bytes }, len)\n        })\n    }\n    /// A `from_slice_start()` that doesn't validate the codepoint.\n    ///\n    /// # Safety\n    ///\n    /// The slice must be non-empty and start with a valid UTF-8 codepoint.  \n    /// Invalid or incomplete values might cause reads of uninitalized memory.\n    pub unsafe fn from_slice_start_unchecked(src: &[u8]) -> (Self,usize) {\n        let len = 1+src.get_unchecked(0).extra_utf8_bytes_unchecked();\n        let mut bytes = [0; 4];\n        ptr::copy_nonoverlapping(src.as_ptr(), &mut bytes[0] as *mut u8, len);\n        (Utf8Char{ bytes: bytes }, len)\n    }\n    /// Create an `Utf8Char` from a byte array after validating it.\n    ///\n    /// The codepoint must start at the first byte.  \n    /// Unused bytes are set to zero by this function and so can be anything.\n    ///\n    /// # Errors\n    ///\n    /// Returns an `Err` if the array doesn't start with a valid UTF-8 sequence.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::Utf8Char;\n    /// use encode_unicode::error::InvalidUtf8Array::*;\n    /// use encode_unicode::error::InvalidUtf8::*;\n    /// use encode_unicode::error::InvalidCodepoint::*;\n    ///\n    /// assert_eq!(Utf8Char::from_array([b'A', 0, 0, 0]), Ok(Utf8Char::from('A')));\n    /// assert_eq!(Utf8Char::from_array([0xf4, 0x8b, 0xbb, 0xbb]), Ok(Utf8Char::from('\\u{10befb}')));\n    /// assert_eq!(Utf8Char::from_array([b'A', b'B', b'C', b'D']), Ok(Utf8Char::from('A')));\n    /// assert_eq!(Utf8Char::from_array([0, 0, 0xcc, 0xbb]), Ok(Utf8Char::from('\\0')));\n    ///\n    /// assert_eq!(Utf8Char::from_array([0xef, b'F', 0x80, 0x80]), Err(Utf8(NotAContinuationByte(1))));\n    /// assert_eq!(Utf8Char::from_array([0xc1, 0x80, 0, 0]), Err(Utf8(OverLong)));\n    /// assert_eq!(Utf8Char::from_array([0xf7, 0xaa, 0x99, 0x88]), Err(Codepoint(TooHigh)));\n    /// ```\n    pub fn from_array(utf8: [u8;4]) -> Result<Self,InvalidUtf8Array> {\n        unsafe {\n            // perform all validation\n            try!(char::from_utf8_array(utf8));\n            let extra = utf8[0].extra_utf8_bytes_unchecked() as u32;\n            // zero unused bytes in one operation by transmuting the arrary to\n            // u32, apply an endian-corrected mask and transmute back\n            let mask = u32::from_le(0xff_ff_ff_ff >> 8*(3-extra));\n            let unused_zeroed = mask  &  transmute::<_,u32>(utf8);\n            Ok(Utf8Char{ bytes: transmute(unused_zeroed) })\n        }\n    }\n    /// Zero-cost constructor.\n    ///\n    /// # Safety\n    ///\n    /// Must contain a valid codepoint starting at the first byte, with the\n    /// unused bytes zeroed.  \n    /// Bad values can easily lead to undefined behavior.\n    #[inline]\n    pub unsafe fn from_array_unchecked(utf8: [u8;4]) -> Self {\n        Utf8Char{ bytes: utf8 }\n    }\n    /// Create an `Utf8Char` from a single byte.\n    ///\n    /// The byte must be an ASCII character.\n    ///\n    /// # Errors\n    ///\n    /// Returns `NonAsciiError` if the byte greater than 127.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use encode_unicode::Utf8Char;\n    /// assert_eq!(Utf8Char::from_ascii(b'a').unwrap(), 'a');\n    /// assert!(Utf8Char::from_ascii(128).is_err());\n    /// ```\n    pub fn from_ascii(ascii: u8) -> Result<Self,NonAsciiError> {\n        if ascii as i8 >= 0 {\n            Ok(Utf8Char{ bytes: [ascii, 0, 0, 0] })\n        } else {\n            Err(NonAsciiError)\n        }\n    }\n    /// Create an `Utf8Char` from a single byte without checking that it's a\n    /// valid codepoint on its own, which is only true for ASCII characters.\n    ///\n    /// # Safety\n    ///\n    /// The byte must be less than 128.\n    #[inline]\n    pub unsafe fn from_ascii_unchecked(ascii: u8) -> Self {\n        Utf8Char{ bytes: [ascii, 0, 0, 0] }\n    }\n\n    /// The number of bytes this character needs.\n    ///\n    /// Is between 1 and 4 (inclusive) and identical to `.as_ref().len()` or\n    /// `.as_char().len_utf8()`.\n    #[inline]\n    pub fn len(self) -> usize {\n        // Invariants of the extra bytes enambles algorithms that\n        // `u8.extra_utf8_bytes_unchecked()` cannot use.\n        // Some of them turned out to require fewer x86 instructions:\n\n        // Exploits that unused bytes are zero and calculates the number of\n        // trailing zero bytes.\n        // Setting a bit in the first byte prevents the function from returning\n        // 0 for '\\0' (which has 32 leading zeros).\n        // trailing and leading is swapped below to optimize for little-endian\n        // architectures.\n        (4 - (u32::to_le(unsafe{transmute(self.bytes)})|1).leading_zeros()/8) as usize\n\n        // Exploits that the extra bytes have their most significant bit set if\n        // in use.\n        // Takes fewer instructions than the one above if popcnt can be used,\n        // (which it cannot by default,\n        //  set RUSTFLAGS='-C target-cpu=native' to enable)\n        //let all: u32 = unsafe{transmute(self.bytes)};\n        //let msb_mask = u32::from_be(0x00808080);\n        //let add_one = u32::from_be(0x80000000);\n        //((all & msb_mask) | add_one).count_ones() as usize\n    }\n    // There is no .is_emty() because this type is never empty.\n\n    /// Checks that the codepoint is an ASCII character.\n    pub fn is_ascii(&self) -> bool {\n        self.bytes[0] <= 127\n    }\n    /// Checks that two characters are an ASCII case-insensitive match.\n    ///\n    /// Is equivalent to `a.to_ascii_lowercase() == b.to_ascii_lowercase()`.\n    #[cfg(feature=\"std\")]\n    pub fn eq_ignore_ascii_case(&self,  other: &Self) -> bool {\n        if self.is_ascii() {self.bytes[0].eq_ignore_ascii_case(&other.bytes[0])}\n        else               {self == other}\n    }\n    /// Converts the character to its ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    #[cfg(feature=\"std\")]\n    pub fn to_ascii_uppercase(&self) -> Self {\n        let mut uc = *self;\n        uc.make_ascii_uppercase();\n        uc\n    }\n    /// Converts the character to its ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    #[cfg(feature=\"std\")]\n    pub fn to_ascii_lowercase(&self) -> Self {\n        let mut uc = *self;\n        uc.make_ascii_lowercase();\n        uc\n    }\n    /// Converts the character to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    #[inline]\n    #[cfg(feature=\"std\")]\n    pub fn make_ascii_uppercase(&mut self) {\n        self.bytes[0].make_ascii_uppercase()\n    }\n    /// Converts the character to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    #[inline]\n    #[cfg(feature=\"std\")]\n    pub fn make_ascii_lowercase(&mut self) {\n        self.bytes[0].make_ascii_lowercase();\n    }\n\n    /// Convert from UTF-8 to UTF-32\n    pub fn to_char(self) -> char {\n        self.into()\n    }\n    /// Write the internal representation to a slice,\n    /// and then returns the number of bytes written.\n    ///\n    /// # Panics\n    ///\n    /// Will panic the buffer is too small;\n    /// You can get the required length from `.len()`,\n    /// but a buffer of length four is always large enough.\n    pub fn to_slice(self,  dst: &mut[u8]) -> usize {\n        if self.len() > dst.len() {\n            panic!(\"The provided buffer is too small.\");\n        }\n        dst[..self.len()].copy_from_slice(&self.bytes[..self.len()]);\n        self.len()\n    }\n    /// Expose the internal array and the number of used bytes.\n    pub fn to_array(self) -> ([u8;4],usize) {\n        (self.bytes, self.len())\n    }\n    /// Return a `str` view of the array the codepoint is stored as.\n    ///\n    /// Is an unambiguous version of `.as_ref()`.\n    pub fn as_str(&self) -> &str {\n        self.deref()\n    }\n}","impl fmt::Debug for Utf8Char {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(&self.to_char(), fmtr)\n    }\n}","impl fmt::Display for Utf8Char {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        fmtr.write_str(self.as_str())\n    }\n}","impl hash::Hash for Utf8Char {\n    fn hash<H : hash::Hasher>(&self,  state: &mut H) {\n        self.to_char().hash(state);\n    }\n}","impl str::FromStr for Utf8Char {\n    type Err = FromStrError;\n    /// Create an `Utf8Char` from a string slice.\n    /// The string must contain exactly one codepoint.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::error::FromStrError::*;\n    /// use encode_unicode::Utf8Char;\n    /// use std::str::FromStr;\n    ///\n    /// assert_eq!(Utf8Char::from_str(\"a\"), Ok(Utf8Char::from('a')));\n    /// assert_eq!(Utf8Char::from_str(\"🂠\"), Ok(Utf8Char::from('🂠')));\n    /// assert_eq!(Utf8Char::from_str(\"\"), Err(Empty));\n    /// assert_eq!(Utf8Char::from_str(\"ab\"), Err(MultipleCodepoints));\n    /// assert_eq!(Utf8Char::from_str(\"é\"), Err(MultipleCodepoints));// 'e'+u301 combining mark\n    /// ```\n    fn from_str(s: &str) -> Result<Self, FromStrError> {\n        if s.is_empty() {\n            Err(FromStrError::Empty)\n        } else if s.len() != 1+s.as_bytes()[0].extra_utf8_bytes_unchecked() {\n            Err(FromStrError::MultipleCodepoints)\n        } else {\n            let mut bytes = [0; 4];\n            bytes[..s.len()].copy_from_slice(s.as_bytes());\n            Ok(Utf8Char{bytes: bytes})\n        }\n    }\n}"],"utf8_iterators::Utf8CharIndices":["Clone","impl<'a> DoubleEndedIterator for Utf8CharIndices<'a> {\n    fn next_back(&mut self) -> Option<(usize,Utf8Char)> {\n        // Cannot refactor out the unwrap without switching to ::from_slice()\n        // since slicing the str panics if not on a boundary.\n        if self.index < self.str.len() {\n            let rev = self.str.bytes().rev();\n            let len = 1 + rev.take_while(|b| b & 0b1100_0000 == 0b1000_0000 ).count();\n            let starts = self.str.len() - len;\n            let (u8c,_) = Utf8Char::from_str_start(&self.str[starts..]).unwrap();\n            self.str = &self.str[..starts];\n            Some((starts, u8c))\n        } else {\n            None\n        }\n    }\n}","impl<'a> From<&'a str> for Utf8CharIndices<'a> {\n    fn from(s: &str) -> Utf8CharIndices {\n        Utf8CharIndices{str: s, index: 0}\n    }\n}","impl<'a> Iterator for Utf8CharIndices<'a> {\n    type Item = (usize,Utf8Char);\n    fn next(&mut self) -> Option<(usize,Utf8Char)> {\n        match Utf8Char::from_str_start(&self.str[self.index..]) {\n            Ok((u8c, len)) => {\n                let item = (self.index, u8c);\n                self.index += len;\n                Some(item)\n            },\n            Err(EmptyStrError) => None\n        }\n    }\n    fn size_hint(&self) -> (usize,Option<usize>) {\n        let len = self.str.len() - self.index;\n        // For len+3 to overflow, the slice must fill all but two bytes of\n        // addressable memory, and size_hint() doesn't need to be correct.\n        (len.wrapping_add(3)/4, Some(len))\n    }\n}","impl<'a> Utf8CharIndices<'a> {\n    /// Extract the remainder of the source `str`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::{StrExt, Utf8Char};\n    /// let mut iter = \"abc\".utf8char_indices();\n    /// assert_eq!(iter.next_back(), Some((2, Utf8Char::from('c'))));\n    /// assert_eq!(iter.next(), Some((0, Utf8Char::from('a'))));\n    /// assert_eq!(iter.as_str(), \"b\");\n    /// ```\n    pub fn as_str(&self) -> &'a str {\n        &self.str[self.index..]\n    }\n}","impl<'a> fmt::Debug for Utf8CharIndices<'a> {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        fmtr.debug_tuple(\"Utf8CharIndices\")\n            .field(&self.index)\n            .field(&self.as_str())\n            .finish()\n    }\n}"],"utf8_iterators::Utf8CharSplitter":["Clone","impl<I:Iterator<Item=Utf8Char>> From<I> for Utf8CharSplitter<Utf8Char,I> {\n    /// A less generic constructor than `iter_bytes()`\n    fn from(iter: I) -> Self {\n        iter_bytes(iter)\n    }\n}","impl<U:Borrow<Utf8Char>, I:Iterator<Item=U>> Iterator for Utf8CharSplitter<U,I> {\n    type Item = u8;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.prev == 0 {\n            self.inner.next().map(|u8c| {\n                let array = u8c.borrow().to_array().0;\n                self.prev = unsafe{ u32::from_le(mem::transmute(array)) } >> 8;\n                array[0]\n            })\n        } else {\n            let next = self.prev as u8;\n            self.prev >>= 8;\n            Some(next)\n        }\n    }\n    fn size_hint(&self) -> (usize,Option<usize>) {\n        // Doesn't need to handle unlikely overflows correctly because\n        // size_hint() cannot be relied upon anyway. (the trait isn't unsafe)\n        let (min, max) = self.inner.size_hint();\n        let add = 4 - (self.prev.leading_zeros() / 8) as usize;\n        (min.wrapping_add(add), max.map(|max| max.wrapping_mul(4).wrapping_add(add) ))\n    }\n}","impl<U:Borrow<Utf8Char>, I:Iterator<Item=U>> Read for Utf8CharSplitter<U,I> {\n    /// Always returns `Ok`\n    fn read(&mut self,  buf: &mut[u8]) -> Result<usize, ioError> {\n        let mut i = 0;\n        // write remaining bytes of previous codepoint\n        while self.prev != 0  &&  i < buf.len() {\n            buf[i] = self.prev as u8;\n            self.prev >>= 8;\n            i += 1;\n        }\n        // write whole characters\n        while i < buf.len() {\n            let bytes = match self.inner.next() {\n                Some(u8c) => u8c.borrow().to_array().0,\n                None => break\n            };\n            buf[i] = bytes[0];\n            i += 1;\n            if bytes[1] != 0 {\n                let len = bytes[0].not().leading_zeros() as usize;\n                let mut written = 1;\n                while written < len {\n                    if i < buf.len() {\n                        buf[i] = bytes[written];\n                        i += 1;\n                        written += 1;\n                    } else {\n                        let bytes_as_u32 = unsafe{ u32::from_le(mem::transmute(bytes)) };\n                        self.prev = bytes_as_u32 >> (8*written);\n                        return Ok(i);\n                    }\n                }\n            }\n        }\n        Ok(i)\n    }\n}","impl<U:Borrow<Utf8Char>, I:Iterator<Item=U>> Utf8CharSplitter<U,I> {\n    /// Extracts the source iterator.\n    ///\n    /// Note that `iter_bytes(iter.into_inner())` is not a no-op:  \n    /// If the last returned byte from `next()` was not an ASCII by,\n    /// the remaining bytes of that codepoint is lost.\n    pub fn into_inner(self) -> I {\n        self.inner\n    }\n}"],"utf8_iterators::Utf8Chars":["Clone","impl<'a> DoubleEndedIterator for Utf8Chars<'a> {\n    fn next_back(&mut self) -> Option<Utf8Char> {\n        self.0.next_back().map(|(_,u8c)| u8c )\n    }\n}","impl<'a> From<&'a str> for Utf8Chars<'a> {\n    fn from(s: &str) -> Utf8Chars {\n        Utf8Chars(Utf8CharIndices::from(s))\n    }\n}","impl<'a> Iterator for Utf8Chars<'a> {\n    type Item = Utf8Char;\n    fn next(&mut self) -> Option<Utf8Char> {\n        self.0.next().map(|(_,u8c)| u8c )\n    }\n    fn size_hint(&self) -> (usize,Option<usize>) {\n        self.0.size_hint()\n    }\n}","impl<'a> Utf8Chars<'a> {\n    /// Extract the remainder of the source `str`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::{StrExt, Utf8Char};\n    /// let mut iter = \"abc\".utf8chars();\n    /// assert_eq!(iter.next(), Some(Utf8Char::from('a')));\n    /// assert_eq!(iter.next_back(), Some(Utf8Char::from('c')));\n    /// assert_eq!(iter.as_str(), \"b\");\n    /// ```\n    pub fn as_str(&self) -> &'a str {\n        self.0.as_str()\n    }\n}","impl<'a> fmt::Debug for Utf8Chars<'a> {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        fmtr.debug_tuple(\"Utf8CharIndices\")\n            .field(&self.as_str())\n            .finish()\n    }\n}"],"utf8_iterators::Utf8Iterator":["Clone","impl ExactSizeIterator for Utf8Iterator {\n    fn len(&self) -> usize {// not straightforward, but possible\n        let unused_bytes = self.0.not().leading_zeros() / 8;\n        4 - unused_bytes as usize\n    }\n}","impl From<Utf8Char> for Utf8Iterator {\n    fn from(uc: Utf8Char) -> Self {\n        let used = u32::from_le(unsafe{ mem::transmute(uc.to_array().0) });\n        // uses u64 because shifting an u32 by 32 bits is a no-op.\n        let unused_set = (u64::MAX  <<  uc.len() as u64*8) as u32;\n        Utf8Iterator(used | unused_set)\n    }\n}","impl From<char> for Utf8Iterator {\n    fn from(c: char) -> Self {\n        Self::from(Utf8Char::from(c))\n    }\n}","impl Iterator for Utf8Iterator {\n    type Item=u8;\n    fn next(&mut self) -> Option<u8> {\n        let next = self.0 as u8;\n        if next == 0xff {\n            None\n        } else {\n            self.0 = (self.0 >> 8)  |  0xff_00_00_00;\n            Some(next)\n        }\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.len(),  Some(self.len()))\n    }\n}","impl Read for Utf8Iterator {\n    /// Always returns Ok\n    fn read(&mut self,  buf: &mut[u8]) -> Result<usize, ioError> {\n        // Cannot call self.next() until I know I can write the result.\n        for (i, dst) in buf.iter_mut().enumerate() {\n            match self.next() {\n                Some(b) => *dst = b,\n                None    => return Ok(i),\n            }\n        }\n        Ok(buf.len())\n    }\n}","impl fmt::Debug for Utf8Iterator {\n    fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result {\n        let mut content = [0; 4];\n        let mut i = 0;\n        for b in self.clone() {\n            content[i] = b;\n            i += 1;\n        }\n        write!(fmtr, \"{:?}\", &content[..i])\n    }\n}"]},"single_path_import":{"decoding_iterators::Utf16CharDecoder":"iterator::Utf16CharDecoder","decoding_iterators::Utf16CharMerger":"iterator::Utf16CharMerger","decoding_iterators::Utf8CharDecoder":"iterator::Utf8CharDecoder","decoding_iterators::Utf8CharMerger":"iterator::Utf8CharMerger","errors::EmptyStrError":"error::EmptyStrError","errors::FromStrError":"error::FromStrError","errors::InvalidCodepoint":"error::InvalidCodepoint","errors::InvalidUtf16Array":"error::InvalidUtf16Array","errors::InvalidUtf16FirstUnit":"error::InvalidUtf16FirstUnit","errors::InvalidUtf16Slice":"error::InvalidUtf16Slice","errors::InvalidUtf16Tuple":"error::InvalidUtf16Tuple","errors::InvalidUtf8":"error::InvalidUtf8","errors::InvalidUtf8Array":"error::InvalidUtf8Array","errors::InvalidUtf8FirstByte":"error::InvalidUtf8FirstByte","errors::InvalidUtf8Slice":"error::InvalidUtf8Slice","errors::Utf16PairError":"error::Utf16PairError","traits::CharExt":"CharExt","traits::IterExt":"IterExt","traits::SliceExt":"SliceExt","traits::StrExt":"StrExt","traits::U16UtfExt":"U16UtfExt","traits::U8UtfExt":"U8UtfExt","utf16_char::Utf16Char":"Utf16Char","utf16_iterators::Utf16CharIndices":"iterator::Utf16CharIndices","utf16_iterators::Utf16CharSplitter":"iterator::Utf16CharSplitter","utf16_iterators::Utf16Chars":"iterator::Utf16Chars","utf16_iterators::Utf16Iterator":"iterator::Utf16Iterator","utf16_iterators::iter_units":"iter_units","utf8_char::Utf8Char":"Utf8Char","utf8_iterators::Utf8CharIndices":"iterator::Utf8CharIndices","utf8_iterators::Utf8CharSplitter":"iterator::Utf8CharSplitter","utf8_iterators::Utf8Chars":"iterator::Utf8Chars","utf8_iterators::Utf8Iterator":"iterator::Utf8Iterator","utf8_iterators::iter_bytes":"iter_bytes"},"srcs":{"<I as traits::IterExt>::to_bytes":["fn to_bytes(self) -> Utf8CharSplitter<Self::Item,Self> where Self::Item: Borrow<Utf8Char>{\n        iter_bytes(self)\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<I as traits::IterExt>::to_units":["fn to_units(self) -> Utf16CharSplitter<Self::Item,Self> where Self::Item: Borrow<Utf16Char>{\n        iter_units(self)\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<I as traits::IterExt>::to_utf16chars":["fn to_utf16chars(self) -> Utf16CharMerger<Self::Item,Self> where Self::Item: Borrow<u16>{\n        Utf16CharMerger::from(self)\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<I as traits::IterExt>::to_utf8chars":["fn to_utf8chars(self) -> Utf8CharMerger<Self::Item,Self> where Self::Item: Borrow<u8>{\n        Utf8CharMerger::from(self)\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<S as traits::SliceExt>::utf16char_indices":["fn utf16char_indices(&self) -> Utf16CharDecoder where Self::Output: Borrow<[u16]>{\n        Utf16CharDecoder::from(self[..].borrow())\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<S as traits::SliceExt>::utf8char_indices":["fn utf8char_indices(&self) -> Utf8CharDecoder where Self::Output: Borrow<[u8]>{\n        Utf8CharDecoder::from(self[..].borrow())\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::from_u32_detailed":["fn from_u32_detailed(c: u32) -> Result<Self,InvalidCodepoint>{\n        match char::from_u32(c) {\n            Some(c) => Ok(c),\n            None if c > 0x10_ff_ff => Err(InvalidCodepoint::TooHigh),\n            None => Err(InvalidCodepoint::Utf16Reserved),\n        }\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::from_utf16_array":["fn from_utf16_array(utf16: [u16;2]) -> Result<Self, InvalidUtf16Array>{\n        use errors::InvalidUtf16Array::*;\n        if let Some(c) = char::from_u32(utf16[0] as u32) {\n            Ok(c) // single\n        } else if utf16[0] < 0xdc_00  &&  utf16[1] & 0xfc_00 == 0xdc_00 {\n            // correct surrogate pair\n            Ok(combine_surrogates(utf16[0], utf16[1]))\n        } else if utf16[0] < 0xdc_00 {\n            Err(SecondIsNotTrailingSurrogate)\n        } else {\n            Err(FirstIsTrailingSurrogate)\n        }\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::from_utf16_array_unchecked":["fn from_utf16_array_unchecked(utf16: [u16;2]) -> Self{\n        // treat any array with a surrogate value in [0] as a surrogate because\n        // combine_surrogates() is safe.\n        // `(utf16[0] & 0xf800) == 0xd80` might not be quite as fast as\n        // `utf16[1] != 0`, but avoiding the potential for UB is worth it\n        // since the conversion isn't zero-cost in either case.\n        char::from_u32(utf16[0] as u32)\n            .unwrap_or_else(|| combine_surrogates(utf16[0], utf16[1]) )\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::from_utf16_slice_start":["fn from_utf16_slice_start(src: &[u16]) -> Result<(Self,usize), InvalidUtf16Slice>{\n        use errors::InvalidUtf16Slice::*;\n        unsafe {match (src.get(0), src.get(1)) {\n            (Some(&u @ 0x00_00...0xd7_ff), _) |\n            (Some(&u @ 0xe0_00...0xff_ff), _)\n                => Ok((char::from_u32_unchecked(u as u32), 1)),\n            (Some(&0xdc_00...0xdf_ff), _) => Err(FirstLowSurrogate),\n            (None, _) => Err(EmptySlice),\n            (Some(&f @ 0xd8_00...0xdb_ff), Some(&s @ 0xdc_00...0xdf_ff))\n                => Ok((char::from_utf16_tuple_unchecked((f, Some(s))), 2)),\n            (Some(&0xd8_00...0xdb_ff), Some(_)) => Err(SecondNotLowSurrogate),\n            (Some(&0xd8_00...0xdb_ff), None) => Err(MissingSecond),\n            (Some(_), _) => unreachable!()\n        }}\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::from_utf16_tuple":["fn from_utf16_tuple(utf16: (u16, Option<u16>)) -> Result<Self, InvalidUtf16Tuple>{\n        use errors::InvalidUtf16Tuple::*;\n        unsafe{ match utf16 {\n            (0x00_00...0xd7_ff, None) | // single\n            (0xe0_00...0xff_ff, None) | // single\n            (0xd8_00...0xdb_ff, Some(0xdc_00...0xdf_ff)) // correct surrogate\n                => Ok(char::from_utf16_tuple_unchecked(utf16)),\n            (0xd8_00...0xdb_ff, Some(_)) => Err(InvalidSecond),\n            (0xd8_00...0xdb_ff, None   ) => Err(MissingSecond),\n            (0xdc_00...0xdf_ff,    _   ) => Err(FirstIsTrailingSurrogate),\n            (        _        , Some(_)) => Err(SuperfluousSecond),\n            (        _        , None   ) => unreachable!()\n        }}\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::from_utf16_tuple_unchecked":["unsafe fn from_utf16_tuple_unchecked(utf16: (u16, Option<u16>)) -> Self{\n        match utf16.1 {\n            Some(second) => combine_surrogates(utf16.0, second),\n            None         => char::from_u32_unchecked(utf16.0 as u32)\n        }\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::from_utf8_array":["fn from_utf8_array(utf8: [u8; 4]) -> Result<Self,InvalidUtf8Array>{\n        use errors::InvalidUtf8::*;\n        use errors::InvalidUtf8Array::*;\n        let src = match utf8[0].extra_utf8_bytes() {\n            Err(error) => return Err(Utf8(FirstByte(error))),\n            Ok(0)      => return Ok(utf8[0] as char),\n            Ok(extra)  => &utf8[..extra+1],\n        };\n        if let Some(i) = src[1..].iter().position(|&b| (b >> 6) != 0b10 ) {\n            Err(Utf8(NotAContinuationByte(i+1)))\n        } else if overlong(utf8[0], utf8[1]) {\n            Err(Utf8(OverLong))\n        } else {\n            char::from_u32_detailed(merge_nonascii_unchecked_utf8(src))\n                 .map_err(|e| Codepoint(e) )\n        }\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::from_utf8_exact_slice_unchecked":["unsafe fn from_utf8_exact_slice_unchecked(src: &[u8]) -> Self{\n        if src.len() == 1 {\n            src[0] as char\n        } else {\n            char::from_u32_unchecked(merge_nonascii_unchecked_utf8(src))\n        }\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::from_utf8_slice_start":["fn from_utf8_slice_start(src: &[u8]) -> Result<(Self,usize),InvalidUtf8Slice>{\n        use errors::InvalidUtf8::*;\n        use errors::InvalidUtf8Slice::*;\n        let first = match src.first() {\n            Some(first) => *first,\n            None => return Err(TooShort(1)),\n        };\n        let bytes = match first.extra_utf8_bytes() {\n            Err(e)    => return Err(Utf8(FirstByte(e))),\n            Ok(0)     => return Ok((first as char, 1)),\n            Ok(extra) if extra >= src.len()\n                      => return Err(TooShort(extra+1)),\n            Ok(extra) => &src[..extra+1],\n        };\n        if let Some(i) = bytes.iter().skip(1).position(|&b| (b >> 6) != 0b10 ) {\n            Err(Utf8(NotAContinuationByte(i+1)))\n        } else if overlong(bytes[0], bytes[1]) {\n            Err(Utf8(OverLong))\n        } else {\n            match char::from_u32_detailed(merge_nonascii_unchecked_utf8(bytes)) {\n                Ok(c) => Ok((c, bytes.len())),\n                Err(e) => Err(Codepoint(e)),\n            }\n        }\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::iter_utf16_units":["fn iter_utf16_units(self) -> Utf16Iterator{\n        self.to_utf16().into_iter()\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::iter_utf8_bytes":["fn iter_utf8_bytes(self) -> Utf8Iterator{\n        self.to_utf8().into_iter()\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::to_utf16":["fn to_utf16(self) -> Utf16Char{\n        Utf16Char::from(self)\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::to_utf16_array":["fn to_utf16_array(self) -> [u16;2]{\n        let (first, second) = self.to_utf16_tuple();\n        [first, second.unwrap_or(0)]\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::to_utf16_tuple":["fn to_utf16_tuple(self) -> (u16, Option<u16>){\n        if self <= '\\u{ffff}' {// single\n            (self as u16, None)\n        } else {// double\n            let c = self as u32 - 0x_01_00_00;\n            let high = 0x_d8_00 + (c >> 10);\n            let low = 0x_dc_00 + (c & 0x_03_ff);\n            (high as u16,  Some(low as u16))\n        }\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::to_utf8":["fn to_utf8(self) -> Utf8Char{\n        self.into()\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<char as traits::CharExt>::to_utf8_array":["fn to_utf8_array(self) -> ([u8; 4], usize){\n        let len = self.len_utf8();\n        let mut c = self as u32;\n        if len == 1 {// ASCII, the common case\n            ([c as u8, 0, 0, 0],  1)\n        } else {\n            let mut parts = 0;// convert to 6-bit bytes\n                        parts |= c & 0x3f;  c>>=6;\n            parts<<=8;  parts |= c & 0x3f;  c>>=6;\n            parts<<=8;  parts |= c & 0x3f;  c>>=6;\n            parts<<=8;  parts |= c & 0x3f;\n            parts |= 0x80_80_80_80;// set the most significant bit\n            parts >>= 8*(4-len);// right-align bytes\n            // Now, unused bytes are zero, (which matters for Utf8Char.eq())\n            // and the rest are 0b10xx_xxxx\n\n            // set header on first byte\n            parts |= (0xff_00u32 >> len)  &  0xff;// store length\n            parts &= Not::not(1u32 << 7-len);// clear the next bit after it\n\n            let bytes: [u8; 4] = unsafe{ mem::transmute(u32::from_le(parts)) };\n            (bytes, len)\n        }\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<decoding_iterators::Utf16CharDecoder<'a> as std::convert::From<&'a [u16]>>::from":["fn from(s: &'a[u16]) -> Self{\n        Utf16CharDecoder{ slice: s,  index: 0 }\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf16CharDecoder<'a> as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        write!(fmtr, \"Utf16CharDecoder {{ units[{}..]: {:?} }}\", self.index, self.as_slice())\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf16CharDecoder<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        let start = self.index;\n        match Utf16Char::from_slice_start(self.as_slice()) {\n            Ok((u16c,len)) => {\n                self.index += len;\n                Some((start, Ok(u16c), len))\n            },\n            Err(EmptySlice) => None,\n            Err(FirstLowSurrogate) => {\n                self.index += 1;\n                Some((start, Err(UnexpectedTrailingSurrogate), 1))\n            },\n            Err(SecondNotLowSurrogate) => {\n                self.index += 1;\n                Some((start, Err(UnmatchedLeadingSurrogate), 1))\n            },\n            Err(MissingSecond) => {\n                self.index = self.slice.len();\n                Some((start, Err(Incomplete), 1))\n            }\n        }\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf16CharDecoder<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize,Option<usize>){\n        let units = self.slice.len() - self.index;\n        // Cannot be exact, so KISS and don't bother rounding up.\n        // The slice is unlikely be full of surrogate pairs, so buffers\n        // allocated with the lower bound will have to be grown anyway.\n        (units/2, Some(units))\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf16CharMerger<B, I> as std::convert::From<T>>::from":["fn from(t: T) -> Self{\n        Utf16CharMerger { iter: t.into_iter(),  prev: None }\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf16CharMerger<B, I> as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        fmtr.debug_struct(\"Utf16CharMerger\")\n            .field(\"buffered\", &self.prev.as_ref().map(|b| *b.borrow() ))\n            .field(\"inner\", &self.iter)\n            .finish()\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf16CharMerger<B, I> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let first = self.prev.take().or_else(|| self.iter.next() );\n        first.map(|first| unsafe {\n            match first.borrow().utf16_needs_extra_unit() {\n                Ok(false) => Ok(Utf16Char::from_array_unchecked([*first.borrow(), 0])),\n                Ok(true) => match self.iter.next() {\n                    Some(second) => match second.borrow().utf16_needs_extra_unit() {\n                        Err(InvalidUtf16FirstUnit) => Ok(Utf16Char::from_tuple_unchecked((\n                            *first.borrow(),\n                            Some(*second.borrow())\n                        ))),\n                        Ok(_) => {\n                            self.prev = Some(second);\n                            Err(Utf16PairError::UnmatchedLeadingSurrogate)\n                        }\n                    },\n                    None => Err(Utf16PairError::Incomplete)\n                },\n                Err(InvalidUtf16FirstUnit) => Err(Utf16PairError::UnexpectedTrailingSurrogate),\n            }\n        })\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf16CharMerger<B, I> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize,Option<usize>){\n        let (iter_min, iter_max) = self.iter.size_hint();\n        // cannot be exact, so KISS\n        let min = iter_min / 2; // don't bother rounding up or accounting for self.prev\n        let max = match (iter_max, &self.prev) {\n            (Some(max), &Some(_)) => max.checked_add(1),\n            (max, _) => max,\n        };\n        (min, max)\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf8CharDecoder<'a> as std::convert::From<&'a [u8]>>::from":["fn from(s: &[u8]) -> Utf8CharDecoder{\n        Utf8CharDecoder { slice: s, index: 0 }\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf8CharDecoder<'a> as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        write!(fmtr, \"Utf8CharDecoder {{ bytes[{}..]: {:?} }}\", self.index, self.as_slice())\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf8CharDecoder<'a> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        if self.index < self.slice.len() {\n            let extras = self.slice.iter()\n                .rev()\n                .take_while(|&b| b & 0b1100_0000 == 0b1000_0000 )\n                .count();\n            let starts = self.slice.len() - (extras+1);\n            match Utf8Char::from_slice_start(&self.slice[starts..]) {\n                Ok((u8c,len)) if len == 1+extras => {\n                    self.slice = &self.slice[..starts];\n                    Some((starts, Ok(u8c), len))\n                },\n                // This enures errors for every byte in both directions,\n                // but means overlong and codepoint errors will be turned into\n                // tooshort errors.\n                Err(e) if extras == 0 => {\n                    self.slice = &self.slice[..self.slice.len()-1];\n                    Some((self.slice.len()-1, Err(e), 1))\n                },\n                _ => {\n                    self.slice = &self.slice[..self.slice.len()-1];\n                    Some((self.slice.len()-1, Err(Utf8(FirstByte(ContinuationByte))), 1))\n                },\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf8CharDecoder<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let start = self.index;\n        match Utf8Char::from_slice_start(&self.slice[self.index..]) {\n            Ok((u8c, len)) => {\n                self.index += len;\n                Some((start, Ok(u8c), len))\n            },\n            Err(TooShort(1)) => None,\n            Err(e) => {\n                self.index += 1;\n                Some((start, Err(e), 1))\n            }\n        }\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf8CharDecoder<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize,Option<usize>){\n        let bytes = self.slice.len() - self.index;\n        // Cannot be exact, so KISS and don't bother rounding up.\n        // The slice is unlikely be full of 4-byte codepoints, so buffers\n        // allocated with the lower bound will have to be grown anyway.\n        (bytes/4, Some(bytes))\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf8CharMerger<B, I> as std::convert::From<T>>::from":["fn from(t: T) -> Self{\n        Utf8CharMerger {\n            iter: t.into_iter(),\n            after_err_leftover: 0,\n            after_err_stack: [0; 3],\n        }\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf8CharMerger<B, I> as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        let mut in_order = [0u8; 3];\n        for i in 0..self.after_err_leftover as usize {\n            in_order[i] = self.after_err_stack[self.after_err_leftover as usize - i - 1];\n        }\n        fmtr.debug_struct(\"Utf8CharMerger\")\n            .field(\"buffered\", &&in_order[..self.after_err_leftover as usize])\n            .field(\"inner\", &self.iter)\n            .finish()\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf8CharMerger<B, I> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let first: u8;\n        if self.after_err_leftover != 0 {\n            self.after_err_leftover -= 1;\n            first = self.after_err_stack[self.after_err_leftover as usize];\n        } else if let Some(next) = self.iter.next() {\n            first = *next.borrow();\n        } else {\n            return None;\n        }\n\n        unsafe {\n            let mut bytes = [first, 0, 0, 0];\n            let ok = match first {\n                0b0000_0000...0b0111_1111 => {/*1 and */Ok(())},\n                0b1100_0010...0b1101_1111 => {//2 and not overlong\n                    self.extra(&mut bytes, 2) // no extra validation required\n                },\n                0b1110_0000...0b1110_1111 => {//3\n                    if let Err(e) = self.extra(&mut bytes, 3) {\n                        Err(e)\n                    } else if bytes[0] == 0b1110_0000  &&  bytes[1] <= 0b10_011111 {\n                        self.save(&bytes, 3);\n                        Err(Utf8(OverLong))\n                    } else if bytes[0] == 0b1110_1101  &&  bytes[1] & 0b11_100000 == 0b10_100000 {\n                        self.save(&bytes, 3);\n                        Err(Codepoint(Utf16Reserved))\n                    } else {\n                        Ok(())\n                    }\n                },\n                0b1111_0000...0b1111_0100 => {//4\n                    if let Err(e) = self.extra(&mut bytes, 4) {\n                        Err(e)\n                    } else if bytes[0] == 0b11110_000  &&  bytes[1] <= 0b10_001111 {\n                        self.save(&bytes, 4);\n                        Err(InvalidUtf8Slice::Utf8(OverLong))\n                    } else if bytes[0] == 0b11110_100  &&  bytes[1] > 0b10_001111 {\n                        self.save(&bytes, 4);\n                        Err(InvalidUtf8Slice::Codepoint(TooHigh))\n                    } else {\n                        Ok(())\n                    }\n                },\n                0b1000_0000...0b1011_1111 => {// continuation byte\n                    Err(Utf8(FirstByte(ContinuationByte)))\n                },\n                0b1100_0000...0b1100_0001 => {// 2 and overlong\n                    Err(Utf8(OverLong))\n                },\n                0b1111_0101...0b1111_0111 => {// 4 and too high codepoint\n                    Err(Codepoint(TooHigh))\n                },\n                0b1111_1000...0b1111_1111 => {\n                    Err(Utf8(FirstByte(TooLongSeqence)))\n                },\n                _ => unreachable!(\"all possible byte values should be covered\")\n            };\n            Some(ok.map(|()| Utf8Char::from_array_unchecked(bytes) ))\n        }\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<decoding_iterators::Utf8CharMerger<B, I> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize,Option<usize>){\n        let (iter_min, iter_max) = self.iter.size_hint();\n        // cannot be exact, so KISS\n        let min = iter_min / 4; // don't bother rounding up or accounting for after_err\n        // handle edge case of max > usize::MAX-3 just in case.\n        // Using wrapping_add() wouldn't violate any API contract as the trait isn't unsafe.\n        let max = iter_max.and_then(|max| {\n            max.checked_add(self.after_err_leftover as usize)\n        });\n        (min, max)\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"<errors::EmptyStrError as std::error::Error>::description":["fn description(&self) -> &'static str{\n            ($desc)(self)\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::EmptyStrError as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            write!(fmtr, \"{}\", self.description())\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::FromStrError as std::error::Error>::description":["fn description(&self) -> &'static str{\n            ($desc)(self)\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::FromStrError as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            write!(fmtr, \"{}\", self.description())\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidCodepoint as std::error::Error>::description":["fn description(&self) -> &'static str{\n            ($desc)(self)\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidCodepoint as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            write!(fmtr, \"{}\", self.description())\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf16Array as std::error::Error>::description":["fn description(&self) -> &'static str{\n            ($desc)(self)\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf16Array as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            write!(fmtr, \"{}\", self.description())\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf16FirstUnit as std::error::Error>::description":["fn description(&self) -> &'static str{\n            ($desc)(self)\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf16FirstUnit as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            write!(fmtr, \"{}\", self.description())\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf16Slice as std::error::Error>::description":["fn description(&self) -> &'static str{\n            ($desc)(self)\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf16Slice as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            write!(fmtr, \"{}\", self.description())\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf16Tuple as std::error::Error>::description":["fn description(&self) -> &'static str{\n            ($desc)(self)\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf16Tuple as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            write!(fmtr, \"{}\", self.description())\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8 as std::convert::From<errors::InvalidUtf8FirstByte>>::from":["fn from(error: $sub) -> $err{\n              $to(error)\n          }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8 as std::error::Error>::cause":["#[$causedoc]\nfn cause(&self) -> Option<&Error>{\n            match *self{ $($cause => $result,)* }\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8 as std::error::Error>::description":["fn description(&self) -> &'static str{\n            match *self{ $($desc => $string,)* }\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8 as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            match (self.cause(), $use_cause) {\n                (Some(d),true) => write!(fmtr, \"{}: {}\", self.description(), d),\n                        _      => write!(fmtr, \"{}\", self.description()),\n            }\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8Array as std::convert::From<errors::InvalidCodepoint>>::from":["fn from(error: $sub) -> $err{\n              $to(error)\n          }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8Array as std::convert::From<errors::InvalidUtf8>>::from":["fn from(error: $sub) -> $err{\n              $to(error)\n          }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8Array as std::error::Error>::cause":["#[$causedoc]\nfn cause(&self) -> Option<&Error>{\n            match *self{ $($cause => $result,)* }\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8Array as std::error::Error>::description":["fn description(&self) -> &'static str{\n            match *self{ $($desc => $string,)* }\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8Array as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            match (self.cause(), $use_cause) {\n                (Some(d),true) => write!(fmtr, \"{}: {}\", self.description(), d),\n                        _      => write!(fmtr, \"{}\", self.description()),\n            }\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8FirstByte as std::error::Error>::description":["fn description(&self) -> &'static str{\n            ($desc)(self)\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8FirstByte as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            write!(fmtr, \"{}\", self.description())\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8Slice as std::convert::From<errors::InvalidCodepoint>>::from":["fn from(error: $sub) -> $err{\n              $to(error)\n          }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8Slice as std::convert::From<errors::InvalidUtf8>>::from":["fn from(error: $sub) -> $err{\n              $to(error)\n          }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8Slice as std::error::Error>::cause":["fn cause(&self) -> Option<&Error>{\n            match *self{ $($cause => $result,)* }\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8Slice as std::error::Error>::description":["fn description(&self) -> &'static str{\n            match *self{ $($desc => $string,)* }\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::InvalidUtf8Slice as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            match (self.cause(), $use_cause) {\n                (Some(d),true) => write!(fmtr, \"{}: {}\", self.description(), d),\n                        _      => write!(fmtr, \"{}\", self.description()),\n            }\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::NonAsciiError as std::error::Error>::description":["fn description(&self) -> &'static str{\n            ($desc)(self)\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::NonAsciiError as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            write!(fmtr, \"{}\", self.description())\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::NonBMPError as std::error::Error>::description":["fn description(&self) -> &'static str{\n            ($desc)(self)\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::NonBMPError as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            write!(fmtr, \"{}\", self.description())\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::Utf16PairError as std::error::Error>::description":["fn description(&self) -> &'static str{\n            ($desc)(self)\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<errors::Utf16PairError as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut Formatter) -> fmt::Result{\n            write!(fmtr, \"{}\", self.description())\n        }","Real(LocalPath(\"src/errors.rs\"))"],"<str as traits::StrExt>::utf16char_indices":["fn utf16char_indices(&self) -> Utf16CharIndices{\n        Utf16CharIndices::from(self)\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<str as traits::StrExt>::utf16chars":["fn utf16chars(&self) -> Utf16Chars{\n        Utf16Chars::from(self)\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<str as traits::StrExt>::utf8char_indices":["fn utf8char_indices(&self) -> Utf8CharIndices{\n        Utf8CharIndices::from(self)\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<str as traits::StrExt>::utf8chars":["fn utf8chars(&self) -> Utf8Chars{\n        Utf8Chars::from(self)\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<u16 as traits::U16UtfExt>::is_utf16_leading_surrogate":["#[inline]\nfn is_utf16_leading_surrogate(self) -> bool{\n        (self & 0xfc00) == 0xd800// Clear the ten content bytes of a surrogate,\n                                 // and see if it's a leading surrogate.\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<u16 as traits::U16UtfExt>::utf16_needs_extra_unit":["#[inline]\nfn utf16_needs_extra_unit(self) -> Result<bool,InvalidUtf16FirstUnit>{\n        match self {\n            // https://en.wikipedia.org/wiki/UTF-16#U.2B10000_to_U.2B10FFFF\n            0x00_00...0xd7_ff | 0xe0_00...0xff_ff => Ok(false),\n            0xd8_00...0xdb_ff => Ok(true),\n                    _         => Err(InvalidUtf16FirstUnit)\n        }\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<u8 as traits::U8UtfExt>::extra_utf8_bytes":["#[inline]\nfn extra_utf8_bytes(self) -> Result<usize,InvalidUtf8FirstByte>{\n        use error::InvalidUtf8FirstByte::{ContinuationByte,TooLongSeqence};\n        // the bit twiddling is explained in extra_utf8_bytes_unchecked()\n        if self < 128 {\n            return Ok(0);\n        }\n        match ((self as u32)<<25).not().leading_zeros() {\n            n @ 1...3 => Ok(n as usize),\n            0 => Err(ContinuationByte),\n            _ => Err(TooLongSeqence),\n        }\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<u8 as traits::U8UtfExt>::extra_utf8_bytes_unchecked":["#[inline]\nfn extra_utf8_bytes_unchecked(self) -> usize{\n        // For fun I've optimized this function (for x86 instruction count):\n        // The most straightforward implementation, that lets the compiler do\n        // the optimizing:\n        //match self {\n        //    0b0000_0000...0b0111_1111 => 0,\n        //    0b1100_0010...0b1101_1111 => 1,\n        //    0b1110_0000...0b1110_1111 => 2,\n        //    0b1111_0000...0b1111_0100 => 3,\n        //                _             => whatever()\n        //}\n        // Using `unsafe{self::core::hint::unreachable_unchecked()}` for the\n        // \"don't care\" case is a terrible idea: while having the function\n        // non-deterministically return whatever happens to be in a register\n        // MIGHT be acceptable, it permits the function to not `ret`urn at all,\n        // but let execution fall through to whatever comes after it in the\n        // binary! (in other words completely UB).\n        // Currently unreachable_unchecked() might trap too,\n        // which is certainly not what we want.\n        // I also think `unsafe{mem::unitialized()}` is much more likely to\n        // explicitly produce whatever happens to be in a register than tell\n        // the compiler it can ignore this branch but needs to produce a value.\n        //\n        // From the bit patterns we see that for non-ASCII values the result is\n        // (number of leading set bits) - 1\n        // The standard library doesn't have a method for counting leading ones,\n        // but it has leading_zeros(), which can be used after inverting.\n        // This function can therefore be reduced to the one-liner\n        //`self.not().leading_zeros().saturating_sub(1) as usize`, which would\n        // be branchless for architectures with instructions for\n        // leading_zeros() and saturating_sub().\n\n        // Shortest version as long as ASCII-ness can be predicted: (especially\n        // if the BSR instruction which leading_zeros() uses is microcoded or\n        // doesn't exist)\n        // u8.leading_zeros() would cast to a bigger type internally, so that's\n        // free. compensating by shifting left by 24 before inverting lets the\n        // compiler know that the value passed to leading_zeros() is not zero,\n        // for which BSR's output is undefined and leading_zeros() normally has\n        // special case with a branch.\n        // Shifting one bit too many left acts as a saturating_sub(1).\n        if self<128 {0} else {((self as u32)<<25).not().leading_zeros() as usize}\n\n        // Branchless but longer version: (9 instructions)\n        // It's tempting to try (self|0x80).not().leading_zeros().wrapping_sub(1),\n        // but that produces high lengths for ASCII values 0b01xx_xxxx.\n        // If we could somehow (branchlessy) clear that bit for ASCII values...\n        // We can by masking with the value shifted right with sign extension!\n        // (any nonzero number of bits in range works)\n        //let extended = self as i8 as i32;\n        //let ascii_cleared = (extended<<25) & (extended>>25);\n        //ascii_cleared.not().leading_zeros() as usize\n\n        // cmov version: (7 instructions)\n        //(((self as u32)<<24).not().leading_zeros() as usize).saturating_sub(1)\n    }","Real(LocalPath(\"src/traits.rs\"))"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::eq_ignore_ascii_case":["fn eq_ignore_ascii_case(&self,  other: &Self) -> bool{\n        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::is_ascii":["fn is_ascii(&self) -> bool{\n        self.units[0] < 128\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::make_ascii_lowercase":["fn make_ascii_lowercase(&mut self){\n        *self = self.to_ascii_lowercase();\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::make_ascii_uppercase":["fn make_ascii_uppercase(&mut self){\n        *self = self.to_ascii_uppercase()\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::to_ascii_lowercase":["fn to_ascii_lowercase(&self) -> Self{\n        let n = self.units[0].wrapping_sub(b'A' as u16);\n        if n < 26 {Utf16Char{ units: [n+b'a' as u16, 0] }}\n        else      {*self}\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::to_ascii_uppercase":["fn to_ascii_uppercase(&self) -> Self{\n        let n = self.units[0].wrapping_sub(b'a' as u16);\n        if n < 26 {Utf16Char{ units: [n+b'A' as u16, 0] }}\n        else      {*self}\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::borrow::Borrow<[u16]>>::borrow":["#[inline]\nfn borrow(&self) -> &[u16]{\n        self.as_ref()\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::cmp::Ord>::cmp":["#[inline]\nfn cmp(&self,  rhs: &Self) -> Ordering{\n        // Shift the first unit by 0xd if surrogate, and 0 otherwise.\n        // This ensures surrogates are always greater than 0xffff, and\n        // that the second unit only affect the result when the first are equal.\n        // Multiplying by a constant factor isn't enough because that factor\n        // would have to be greater than 1023 and smaller than 5.5.\n        // This transformation is less complicated than combine_surrogates().\n        let lhs = (self.units[0] as u32, self.units[1] as u32);\n        let rhs = (rhs.units[0] as u32, rhs.units[1] as u32);\n        let lhs = (lhs.0 << (lhs.1 >> 12)) + lhs.1;\n        let rhs = (rhs.0 << (rhs.1 >> 12)) + rhs.1;\n        lhs.cmp(&rhs)\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::cmp::PartialEq<char>>::eq":["fn eq(&self,  u32c: &char) -> bool{\n        *self == Utf16Char::from(*u32c)\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::cmp::PartialEq<u16>>::eq":["fn eq(&self,  unit: &u16) -> bool{\n        self.units[0] == *unit  &&  self.units[1] == 0\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::cmp::PartialEq<u8>>::eq":["fn eq(&self,  byte: &u8) -> bool{\n        self.units[0] == *byte as u16\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::cmp::PartialEq<utf8_char::Utf8Char>>::eq":["fn eq(&self,  u8c: &Utf8Char) -> bool{\n        *self == Utf16Char::from(*u8c)\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::cmp::PartialOrd<char>>::partial_cmp":["fn partial_cmp(&self,  u32c: &char) -> Option<Ordering>{\n        self.partial_cmp(&Utf16Char::from(*u32c))\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::cmp::PartialOrd<utf8_char::Utf8Char>>::partial_cmp":["fn partial_cmp(&self,  u8c: &Utf8Char) -> Option<Ordering>{\n        self.partial_cmp(&Utf16Char::from(*u8c))\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::cmp::PartialOrd>::partial_cmp":["#[inline]\nfn partial_cmp(&self,  rhs: &Self) -> Option<Ordering>{\n        Some(self.cmp(rhs))\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::convert::AsRef<[u16]>>::as_ref":["#[inline]\nfn as_ref(&self) -> &[u16]{\n        &self.units[..self.len()]\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::convert::From<char>>::from":["fn from(c: char) -> Self{\n        let (first, second) = c.to_utf16_tuple();\n        Utf16Char{ units: [first, second.unwrap_or(0)] }\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::convert::From<utf8_char::Utf8Char>>::from":["fn from(utf8: Utf8Char) -> Utf16Char{\n        let (b, utf8_len) = utf8.to_array();\n        match utf8_len {\n            1 => Utf16Char{ units: [b[0] as u16, 0] },\n            4 => {// need surrogate\n                let mut first = 0xd800 - (0x01_00_00u32 >> 10) as u16;\n                first += (b[0] as u16 & 0x07) << 8;\n                first += (b[1] as u16 & 0x3f) << 2;\n                first += (b[2] as u16 & 0x30) >> 4;\n                let mut second = 0xdc00;\n                second |= (b[2] as u16 & 0x0f) << 6;\n                second |=  b[3] as u16 & 0x3f;\n                Utf16Char{ units: [first, second] }\n            },\n            _ => { // 2 or 3\n                let mut unit = ((b[0] as u16 & 0x1f) << 6) | (b[1] as u16 & 0x3f);\n                if utf8_len == 3 {\n                    unit = (unit << 6) | (b[2] as u16 & 0x3f);\n                }\n                Utf16Char{ units: [unit, 0] }\n            },\n        }\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Debug::fmt(&self.to_char(), fmtr)\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Display::fmt(&Utf8Char::from(*self), fmtr)\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::hash::Hash>::hash":["fn hash<H : hash::Hasher>(&self,  state: &mut H){\n        self.to_char().hash(state);\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::iter::IntoIterator>::into_iter":["/// Iterate over the units.\nfn into_iter(self) -> Utf16Iterator{\n        Utf16Iterator::from(self)\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::ops::Deref>::deref":["#[inline]\nfn deref(&self) -> &[u16]{\n        self.as_ref()\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_char::Utf16Char as std::str::FromStr>::from_str":["/// Create an `Utf16Char` from a string slice.\n/// The string must contain exactly one codepoint.\n///\n/// # Examples\n///\n/// ```\n/// use encode_unicode::error::FromStrError::*;\n/// use encode_unicode::Utf16Char;\n/// use std::str::FromStr;\n///\n/// assert_eq!(Utf16Char::from_str(\"a\"), Ok(Utf16Char::from('a')));\n/// assert_eq!(Utf16Char::from_str(\"🂠\"), Ok(Utf16Char::from('🂠')));\n/// assert_eq!(Utf16Char::from_str(\"\"), Err(Empty));\n/// assert_eq!(Utf16Char::from_str(\"ab\"), Err(MultipleCodepoints));\n/// assert_eq!(Utf16Char::from_str(\"é\"), Err(MultipleCodepoints));// 'e'+u301 combining mark\n/// ```\nfn from_str(s: &str) -> Result<Self, FromStrError>{\n        match Utf16Char::from_str_start(s) {\n            Ok((u16c,bytes)) if bytes == s.len() => Ok(u16c),\n            Ok((_,_)) => Err(FromStrError::MultipleCodepoints),\n            Err(EmptyStrError) => Err(FromStrError::Empty),\n        }\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"<utf16_iterators::Utf16CharIndices<'a> as std::convert::From<&'a str>>::from":["fn from(s: &str) -> Utf16CharIndices{\n        Utf16CharIndices{str: s, index: 0}\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16CharIndices<'a> as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        fmtr.debug_tuple(\"Utf16CharIndices\")\n            .field(&self.index)\n            .field(&self.as_str())\n            .finish()\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<(usize,Utf16Char)>{\n        if self.index < self.str.len() {\n            let rev = self.str.bytes().rev();\n            let len = 1 + rev.take_while(|b| b & 0b1100_0000 == 0b1000_0000 ).count();\n            let starts = self.str.len() - len;\n            let (u16c,_) = Utf16Char::from_str_start(&self.str[starts..]).unwrap();\n            self.str = &self.str[..starts];\n            Some((starts, u16c))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16CharIndices<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<(usize,Utf16Char)>{\n        match Utf16Char::from_str_start(&self.str[self.index..]) {\n            Ok((u16c, bytes)) => {\n                let item = (self.index, u16c);\n                self.index += bytes;\n                Some(item)\n            },\n            Err(EmptyStrError) => None\n        }\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16CharIndices<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize,Option<usize>){\n        let len = self.str.len() - self.index;\n        // For len+3 to overflow, the slice must fill all but two bytes of\n        // addressable memory, and size_hint() doesn't need to be correct.\n        (len.wrapping_add(3)/4, Some(len))\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16CharSplitter<U, I> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        if self.prev_second == 0 {\n            self.inner.next().map(|u16c| {\n                let units = u16c.borrow().to_array();\n                self.prev_second = units[1];\n                units[0]\n            })\n        } else {\n            let prev_second = self.prev_second;\n            self.prev_second = 0;\n            Some(prev_second)\n        }\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16CharSplitter<U, I> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize,Option<usize>){\n        // Doesn't need to handle unlikely overflows correctly because\n        // size_hint() cannot be relied upon anyway. (the trait isn't unsafe)\n        let (min, max) = self.inner.size_hint();\n        let add = if self.prev_second == 0 {0} else {1};\n        (min.wrapping_add(add), max.map(|max| max.wrapping_mul(2).wrapping_add(add) ))\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16CharSplitter<utf16_char::Utf16Char, I> as std::convert::From<I>>::from":["/// A less generic constructor than `iter_units()`\nfn from(iter: I) -> Self{\n        iter_units(iter)\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16Chars<'a> as std::convert::From<&'a str>>::from":["fn from(s: &str) -> Utf16Chars{\n        Utf16Chars(Utf16CharIndices::from(s))\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16Chars<'a> as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        fmtr.debug_tuple(\"Utf16Chars\")\n            .field(&self.as_str())\n            .finish()\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16Chars<'a> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Utf16Char>{\n        self.0.next_back().map(|(_,u16c)| u16c )\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16Chars<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Utf16Char>{\n        self.0.next().map(|(_,u16c)| u16c )\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16Chars<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize,Option<usize>){\n        self.0.size_hint()\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16Iterator as std::convert::From<char>>::from":["fn from(c: char) -> Self{\n        let (first, second) = c.to_utf16_tuple();\n        Utf16Iterator{ first: first,  second: second.unwrap_or(SECOND_USED) }\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16Iterator as std::convert::From<utf16_char::Utf16Char>>::from":["fn from(uc: Utf16Char) -> Self{\n        let (first, second) = uc.to_tuple();\n        Utf16Iterator{ first: first,  second: second.unwrap_or(SECOND_USED) }\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16Iterator as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        let mut clone = self.clone();\n        match (clone.next(), clone.next()) {\n            (Some(one), None)  => write!(fmtr, \"[{}]\", one),\n            (Some(a), Some(b)) => write!(fmtr, \"[{}, {}]\", a, b),\n            (None,  _)         => write!(fmtr, \"[]\"),\n        }\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16Iterator as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        (if self.first == FIRST_USED {0} else {1}) +\n        (if self.second == SECOND_USED {0} else {1})\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16Iterator as std::iter::Iterator>::next":["fn next(&mut self) -> Option<u16>{\n        match (self.first, self.second) {\n            (FIRST_USED, SECOND_USED)  =>  {                            None        },\n            (FIRST_USED, second     )  =>  {self.second = SECOND_USED;  Some(second)},\n            (first     ,      _     )  =>  {self.first = FIRST_USED;    Some(first )},\n        }\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf16_iterators::Utf16Iterator as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (self.len(), Some(self.len()))\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::eq_ignore_ascii_case":["fn eq_ignore_ascii_case(&self,  other: &Self) -> bool{\n        if self.is_ascii() {self.bytes[0].eq_ignore_ascii_case(&other.bytes[0])}\n        else               {self == other}\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::is_ascii":["fn is_ascii(&self) -> bool{\n        self.bytes[0].is_ascii()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::make_ascii_lowercase":["fn make_ascii_lowercase(&mut self){\n        self.bytes[0].make_ascii_lowercase();\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::make_ascii_uppercase":["fn make_ascii_uppercase(&mut self){\n        self.bytes[0].make_ascii_uppercase()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::to_ascii_lowercase":["fn to_ascii_lowercase(&self) -> Self::Owned{\n        let mut uc = *self;\n        uc.make_ascii_lowercase();\n        uc\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::to_ascii_uppercase":["fn to_ascii_uppercase(&self) -> Self::Owned{\n        let mut uc = *self;\n        uc.make_ascii_uppercase();\n        uc\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::borrow::Borrow<[u8]>>::borrow":["fn borrow(&self) -> &[u8]{\n        self.as_ref()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::borrow::Borrow<str>>::borrow":["fn borrow(&self) -> &str{\n        self.as_ref()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::cmp::PartialEq<char>>::eq":["fn eq(&self,  u32c: &char) -> bool{\n        *self == Utf8Char::from(*u32c)\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::cmp::PartialEq<u8>>::eq":["fn eq(&self,  byte: &u8) -> bool{\n        self.bytes[0] == *byte  &&  self.bytes[1] == 0\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::cmp::PartialEq<utf16_char::Utf16Char>>::eq":["fn eq(&self,  u16c: &Utf16Char) -> bool{\n        *self == Self::from(*u16c)\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::cmp::PartialOrd<char>>::partial_cmp":["fn partial_cmp(&self,  u32c: &char) -> Option<Ordering>{\n        self.partial_cmp(&Self::from(*u32c))\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::cmp::PartialOrd<utf16_char::Utf16Char>>::partial_cmp":["fn partial_cmp(&self,  u16c: &Utf16Char) -> Option<Ordering>{\n        self.partial_cmp(&Self::from(*u16c))\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::convert::AsRef<[u8]>>::as_ref":["fn as_ref(&self) -> &[u8]{\n        &self.bytes[..self.len()]\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::convert::AsRef<str>>::as_ref":["fn as_ref(&self) -> &str{\n        unsafe{ str::from_utf8_unchecked( self.as_ref() ) }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::convert::From<char>>::from":["fn from(c: char) -> Self{\n        Utf8Char{ bytes: c.to_utf8_array().0 }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::convert::From<utf16_char::Utf16Char>>::from":["fn from(utf16: Utf16Char) -> Utf8Char{\n        match utf16.to_tuple() {\n            (a @ 0...0x00_7f, _) => {\n                Utf8Char{ bytes: [a as u8, 0, 0, 0] }\n            },\n            (u @ 0...0x07_ff, _) => {\n                let b = 0x80 |  (u & 0x00_3f) as u8;\n                let a = 0xc0 | ((u & 0x07_c0) >> 6) as u8;\n                Utf8Char{ bytes: [a, b, 0, 0] }\n            },\n            (u, None) => {\n                let c = 0x80 |  (u & 0x00_3f) as u8;\n                let b = 0x80 | ((u & 0x0f_c0) >> 6) as u8;\n                let a = 0xe0 | ((u & 0xf0_00) >> 12) as u8;\n                Utf8Char{ bytes: [a, b, c, 0] }\n            },\n            (f, Some(s)) => {\n                let f = f + (0x01_00_00u32 >> 10) as u16;\n                let d = 0x80 |  (s & 0x00_3f) as u8;\n                let c = 0x80 | ((s & 0x03_c0) >> 6) as u8\n                             | ((f & 0x00_03) << 4) as u8;\n                let b = 0x80 | ((f & 0x00_fc) >> 2) as u8;\n                let a = 0xf0 | ((f & 0x07_00) >> 8) as u8;\n                Utf8Char{ bytes: [a, b, c, d] }\n            }\n        }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Debug::fmt(&self.to_char(), fmtr)\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::fmt::Display>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        fmtr.write_str(self.as_str())\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::hash::Hash>::hash":["fn hash<H : hash::Hasher>(&self,  state: &mut H){\n        self.to_char().hash(state);\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::iter::IntoIterator>::into_iter":["/// Iterate over the byte values.\nfn into_iter(self) -> Utf8Iterator{\n        Utf8Iterator::from(self)\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::ops::Deref>::deref":["fn deref(&self) -> &Self::Target{\n        self.as_ref()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_char::Utf8Char as std::str::FromStr>::from_str":["/// Create an `Utf8Char` from a string slice.\n/// The string must contain exactly one codepoint.\n///\n/// # Examples\n///\n/// ```\n/// use encode_unicode::error::FromStrError::*;\n/// use encode_unicode::Utf8Char;\n/// use std::str::FromStr;\n///\n/// assert_eq!(Utf8Char::from_str(\"a\"), Ok(Utf8Char::from('a')));\n/// assert_eq!(Utf8Char::from_str(\"🂠\"), Ok(Utf8Char::from('🂠')));\n/// assert_eq!(Utf8Char::from_str(\"\"), Err(Empty));\n/// assert_eq!(Utf8Char::from_str(\"ab\"), Err(MultipleCodepoints));\n/// assert_eq!(Utf8Char::from_str(\"é\"), Err(MultipleCodepoints));// 'e'+u301 combining mark\n/// ```\nfn from_str(s: &str) -> Result<Self, FromStrError>{\n        if s.is_empty() {\n            Err(FromStrError::Empty)\n        } else if s.len() != 1+s.as_bytes()[0].extra_utf8_bytes_unchecked() {\n            Err(FromStrError::MultipleCodepoints)\n        } else {\n            let mut bytes = [0; 4];\n            bytes[..s.len()].copy_from_slice(s.as_bytes());\n            Ok(Utf8Char{bytes: bytes})\n        }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"<utf8_iterators::Utf8CharIndices<'a> as std::convert::From<&'a str>>::from":["fn from(s: &str) -> Utf8CharIndices{\n        Utf8CharIndices{str: s, index: 0}\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8CharIndices<'a> as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        fmtr.debug_tuple(\"Utf8CharIndices\")\n            .field(&self.index)\n            .field(&self.as_str())\n            .finish()\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<(usize,Utf8Char)>{\n        // Cannot refactor out the unwrap without switching to ::from_slice()\n        // since slicing the str panics if not on a boundary.\n        if self.index < self.str.len() {\n            let rev = self.str.bytes().rev();\n            let len = 1 + rev.take_while(|b| b & 0b1100_0000 == 0b1000_0000 ).count();\n            let starts = self.str.len() - len;\n            let (u8c,_) = Utf8Char::from_str_start(&self.str[starts..]).unwrap();\n            self.str = &self.str[..starts];\n            Some((starts, u8c))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8CharIndices<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<(usize,Utf8Char)>{\n        match Utf8Char::from_str_start(&self.str[self.index..]) {\n            Ok((u8c, len)) => {\n                let item = (self.index, u8c);\n                self.index += len;\n                Some(item)\n            },\n            Err(EmptyStrError) => None\n        }\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8CharIndices<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize,Option<usize>){\n        let len = self.str.len() - self.index;\n        // For len+3 to overflow, the slice must fill all but two bytes of\n        // addressable memory, and size_hint() doesn't need to be correct.\n        (len.wrapping_add(3)/4, Some(len))\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8CharSplitter<U, I> as std::io::Read>::read":["/// Always returns `Ok`\nfn read(&mut self,  buf: &mut[u8]) -> Result<usize, ioError>{\n        let mut i = 0;\n        // write remaining bytes of previous codepoint\n        while self.prev != 0  &&  i < buf.len() {\n            buf[i] = self.prev as u8;\n            self.prev >>= 8;\n            i += 1;\n        }\n        // write whole characters\n        while i < buf.len() {\n            let bytes = match self.inner.next() {\n                Some(u8c) => u8c.borrow().to_array().0,\n                None => break\n            };\n            buf[i] = bytes[0];\n            i += 1;\n            if bytes[1] != 0 {\n                let len = bytes[0].not().leading_zeros() as usize;\n                let mut written = 1;\n                while written < len {\n                    if i < buf.len() {\n                        buf[i] = bytes[written];\n                        i += 1;\n                        written += 1;\n                    } else {\n                        let bytes_as_u32 = unsafe{ u32::from_le(mem::transmute(bytes)) };\n                        self.prev = bytes_as_u32 >> (8*written);\n                        return Ok(i);\n                    }\n                }\n            }\n        }\n        Ok(i)\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8CharSplitter<U, I> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        if self.prev == 0 {\n            self.inner.next().map(|u8c| {\n                let array = u8c.borrow().to_array().0;\n                self.prev = unsafe{ u32::from_le(mem::transmute(array)) } >> 8;\n                array[0]\n            })\n        } else {\n            let next = self.prev as u8;\n            self.prev >>= 8;\n            Some(next)\n        }\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8CharSplitter<U, I> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize,Option<usize>){\n        // Doesn't need to handle unlikely overflows correctly because\n        // size_hint() cannot be relied upon anyway. (the trait isn't unsafe)\n        let (min, max) = self.inner.size_hint();\n        let add = 4 - (self.prev.leading_zeros() / 8) as usize;\n        (min.wrapping_add(add), max.map(|max| max.wrapping_mul(4).wrapping_add(add) ))\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8CharSplitter<utf8_char::Utf8Char, I> as std::convert::From<I>>::from":["/// A less generic constructor than `iter_bytes()`\nfn from(iter: I) -> Self{\n        iter_bytes(iter)\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Chars<'a> as std::convert::From<&'a str>>::from":["fn from(s: &str) -> Utf8Chars{\n        Utf8Chars(Utf8CharIndices::from(s))\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Chars<'a> as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        fmtr.debug_tuple(\"Utf8CharIndices\")\n            .field(&self.as_str())\n            .finish()\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Chars<'a> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Utf8Char>{\n        self.0.next_back().map(|(_,u8c)| u8c )\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Chars<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Utf8Char>{\n        self.0.next().map(|(_,u8c)| u8c )\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Chars<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize,Option<usize>){\n        self.0.size_hint()\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Iterator as std::convert::From<char>>::from":["fn from(c: char) -> Self{\n        Self::from(Utf8Char::from(c))\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Iterator as std::convert::From<utf8_char::Utf8Char>>::from":["fn from(uc: Utf8Char) -> Self{\n        let used = u32::from_le(unsafe{ mem::transmute(uc.to_array().0) });\n        // uses u64 because shifting an u32 by 32 bits is a no-op.\n        let unused_set = (u64::MAX  <<  uc.len() as u64*8) as u32;\n        Utf8Iterator(used | unused_set)\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Iterator as std::fmt::Debug>::fmt":["fn fmt(&self,  fmtr: &mut fmt::Formatter) -> fmt::Result{\n        let mut content = [0; 4];\n        let mut i = 0;\n        for b in self.clone() {\n            content[i] = b;\n            i += 1;\n        }\n        write!(fmtr, \"{:?}\", &content[..i])\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Iterator as std::io::Read>::read":["/// Always returns Ok\nfn read(&mut self,  buf: &mut[u8]) -> Result<usize, ioError>{\n        // Cannot call self.next() until I know I can write the result.\n        for (i, dst) in buf.iter_mut().enumerate() {\n            match self.next() {\n                Some(b) => *dst = b,\n                None    => return Ok(i),\n            }\n        }\n        Ok(buf.len())\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Iterator as std::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{// not straightforward, but possible\n        let unused_bytes = self.0.not().leading_zeros() / 8;\n        4 - unused_bytes as usize\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Iterator as std::iter::Iterator>::next":["fn next(&mut self) -> Option<u8>{\n        let next = self.0 as u8;\n        if next == 0xff {\n            None\n        } else {\n            self.0 = (self.0 >> 8)  |  0xff_00_00_00;\n            Some(next)\n        }\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"<utf8_iterators::Utf8Iterator as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (self.len(),  Some(self.len()))\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"decoding_iterators::Utf16CharDecoder":["/// An [`Utf16CharMerger`](struct.Utf16CharMerger.html) that also produces\n/// offsets and lengths, but can only iterate over slices.\n///\n/// See [`SliceExt::utf16char_indices()`](../trait.SliceExt.html#tymethod.utf16char_indices)\n/// for examples and error handling.\npub struct Utf16CharDecoder<'a> {\n    slice: &'a[u16],\n    index: usize,\n}","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"decoding_iterators::Utf16CharDecoder::<'a>::as_slice":["/// Extract the remainder of the source slice.\n///\n/// # Examples\n///\n/// Unlike `Utf16CharMerger::into_inner()`, the unit after an error is never swallowed:\n/// ```\n/// # use encode_unicode::SliceExt;\n/// # use encode_unicode::error::Utf16PairError;\n/// let mut iter = [0xd901, 'F' as u16, 'S' as u16].utf16char_indices();\n/// assert_eq!(iter.next(), Some((0, Err(Utf16PairError::UnmatchedLeadingSurrogate), 1)));\n/// assert_eq!(iter.as_slice(), &['F' as u16, 'S' as u16]);\n/// ```\npub fn as_slice(&self) -> &[u16]{\n        &self.slice[self.index..]\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"decoding_iterators::Utf16CharMerger":["/// Decodes UTF-16 characters from a `u16` iterator into `Utf16Char`s.\n///\n/// See [`IterExt::to_utf16chars()`](../trait.IterExt.html#tymethod.to_utf16chars)\n/// for examples and error handling.\npub struct Utf16CharMerger<B:Borrow<u16>, I:Iterator<Item=B>> {\n    iter: I,\n    /// Used when a trailing surrogate was expected, the u16 can be any value.\n    prev: Option<B>,\n}","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"decoding_iterators::Utf16CharMerger::<B, I>::into_inner":["/// Extract the inner iterator.\n///\n/// If the last item produced was an `Err`, the first unit might be missing.\n///\n/// # Examples\n///\n/// Unit right after an error missing\n/// ```\n/// # use encode_unicode::IterExt;\n/// # use encode_unicode::error::Utf16PairError;\n/// let mut merger = [0xd901, 'F' as u16, 'S' as u16].iter().to_utf16chars();\n/// assert_eq!(merger.next(), Some(Err(Utf16PairError::UnmatchedLeadingSurrogate)));\n/// let mut inner: std::slice::Iter<u16> = merger.into_inner();\n/// assert_eq!(inner.next(), Some('S' as u16).as_ref()); // 'F' was consumed by Utf16CharMerger\n/// ```\n///\n/// Error that doesn't swallow any units\n/// ```\n/// # use encode_unicode::IterExt;\n/// # use encode_unicode::error::Utf16PairError;\n/// let mut merger = [0xde00, 'F' as u16, 'S' as u16].iter().to_utf16chars();\n/// assert_eq!(merger.next(), Some(Err(Utf16PairError::UnexpectedTrailingSurrogate)));\n/// let mut inner: std::slice::Iter<u16> = merger.into_inner();\n/// assert_eq!(inner.next(), Some('F' as u16).as_ref()); // not consumed\n/// ```\npub fn into_inner(self) -> I{\n        self.iter\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"decoding_iterators::Utf16CharMerger::<B, I>::into_remaining_units":["/// Returns an iterator over the remaining units.\n/// Unlike `into_inner()` this will never drop any units.\n///\n/// The exact type of the returned iterator should not be depended on.\n///\n/// # Examples\n///\n/// ```\n/// # use encode_unicode::IterExt;\n/// # use encode_unicode::error::Utf16PairError;\n/// let slice = [0xd901, 'F' as u16, 'S' as u16];\n/// let mut merger = slice.iter().to_utf16chars();\n/// assert_eq!(merger.next(), Some(Err(Utf16PairError::UnmatchedLeadingSurrogate)));\n/// let mut remaining = merger.into_remaining_units();\n/// assert_eq!(remaining.next(), Some('F' as u16).as_ref());\n/// ```\npub fn into_remaining_units(self) -> Chain<option::IntoIter<B>,I>{\n        self.prev.into_iter().chain(self.iter)\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"decoding_iterators::Utf8CharDecoder":["/// An [`Utf8CharMerger`](struct.Utf8CharMerger.html) that also produces\n/// offsets and lengths, but can only iterate over slices.\n///\n/// See [`SliceExt::utf8char_indices()`](../trait.SliceExt.html#tymethod.utf8char_indices)\n/// for examples and error handling.\npub struct Utf8CharDecoder<'a> {\n    slice: &'a[u8],\n    index: usize,\n}","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"decoding_iterators::Utf8CharDecoder::<'a>::as_slice":["/// Extract the remainder of the source slice.\n///\n/// # Examples\n///\n/// Unlike `Utf8CharMerger::into_inner()`, bytes directly after an error\n/// are never swallowed:\n/// ```\n/// # use encode_unicode::SliceExt;\n/// let mut iter = b\"\\xf4\\xa1\\xb2FS\".utf8char_indices();\n/// assert!(iter.next().unwrap().1.is_err());\n/// assert_eq!(iter.as_slice(), b\"\\xa1\\xb2FS\");\n/// ```\npub fn as_slice(&self) -> &'a[u8]{\n        &self.slice[self.index..]\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"decoding_iterators::Utf8CharMerger":["/// Decodes UTF-8 characters from a byte iterator into `Utf8Char`s.\n///\n/// See [`IterExt::to_utf8chars()`](../trait.IterExt.html#tymethod.to_utf8chars)\n/// for examples and error handling.\npub struct Utf8CharMerger<B:Borrow<u8>, I:Iterator<Item=B>> {\n    iter: I,\n    /// number of bytes that were read before an error was detected\n    after_err_leftover: u8,\n    /// stack because it simplifies popping.\n    after_err_stack: [u8; 3],\n}","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"decoding_iterators::Utf8CharMerger::<B, I>::extra":["/// Reads len-1 bytes into bytes[1..]\nfn extra(&mut self,  bytes: &mut[u8;4],  len: usize) -> Result<(),InvalidUtf8Slice>{\n        // This is the only function that pushes onto after_err_stack,\n        // and it checks that all bytes are continuation bytes before fetching the next one.\n        // Therefore only the last byte retrieved can be a non-continuation byte.\n        // That last byte is also the last to be retrieved from after_err.\n        //\n        // Before this function is called, there has been retrieved at least one byte.\n        // If that byte was a continuation byte, next() produces an error\n        // and won't call this function.\n        // Therefore, we know that after_err is empty at this point.\n        // This means that we can use self.iter directly, and knows where to start pushing\n        debug_assert_eq!(self.after_err_leftover, 0, \"first: {:#02x}, stack: {:?}\", bytes[0], self.after_err_stack);\n        for i in 1..len {\n            if let Some(extra) = self.iter.next() {\n                let extra = *extra.borrow();\n                bytes[i] = extra;\n                if extra & 0b1100_0000 != 0b1000_0000 {\n                    // not a continuation byte\n                    self.save(bytes, i+1);\n                    return Err(InvalidUtf8Slice::Utf8(NotAContinuationByte(i)))\n                }\n            } else {\n                self.save(bytes, i);\n                return Err(TooShort(len));\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"decoding_iterators::Utf8CharMerger::<B, I>::into_inner":["/// Extract the inner iterator.\n///\n/// If the last item produced by `.next()` was an `Err`,\n/// up to three following bytes might be missing.  \n/// The exact number of missing bytes for each error type should not be relied on.\n///\n/// # Examples\n///\n/// Three bytes swallowed:\n/// ```\n/// # use encode_unicode::IterExt;\n/// let mut merger = b\"\\xf4\\xa1\\xb2FS\".iter().to_utf8chars();\n/// assert!(merger.next().unwrap().is_err());\n/// let mut inner: std::slice::Iter<u8> = merger.into_inner();\n/// assert_eq!(inner.next(), Some(&b'S')); // b'\\xa1', b'\\xb2' and b'F' disappeared\n/// ```\n///\n/// All bytes present:\n/// ```\n/// # use encode_unicode::IterExt;\n/// let mut merger = b\"\\xb0FS\".iter().to_utf8chars();\n/// assert!(merger.next().unwrap().is_err());\n/// assert_eq!(merger.into_inner().next(), Some(&b'F'));\n/// ```\n///\n/// Two bytes missing:\n/// ```\n/// # use encode_unicode::IterExt;\n/// let mut merger = b\"\\xe0\\x80\\x80FS\".iter().to_utf8chars();\n/// assert!(merger.next().unwrap().is_err());\n/// assert_eq!(merger.into_inner().next(), Some(&b'F'));\n/// ```\npub fn into_inner(self) -> I{\n        self.iter\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"decoding_iterators::Utf8CharMerger::<B, I>::save":["fn save(&mut self,  bytes: &[u8;4],  len: usize){\n        // forget bytes[0] and push the others onto self.after_err_stack (in reverse).\n        for &after_err in bytes[1..len].iter().rev() {\n            self.after_err_stack[self.after_err_leftover as usize] = after_err;\n            self.after_err_leftover += 1;\n        }\n    }","Real(LocalPath(\"src/decoding_iterators.rs\"))"],"errors::EmptyStrError":["#[$doc1]\n#[$doc2]\npub struct $err;","Real(LocalPath(\"src/errors.rs\"))"],"errors::FromStrError":["#[$tydoc]\npub enum $err {\n        $($(#[$vardoc])* $variant),*\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::InvalidCodepoint":["#[$tydoc]\npub enum $err {\n        $($(#[$vardoc])* $variant),*\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::InvalidCodepoint::error_range":["/// Get the range of values for which this error would be given.\npub fn error_range(self) -> (u32,u32){match self {\n        Utf16Reserved => (0xd8_00, 0xdf_ff),\n        TooHigh => (0x00_10_ff_ff, 0xff_ff_ff_ff),\n    }}","Real(LocalPath(\"src/errors.rs\"))"],"errors::InvalidUtf16Array":["#[$tydoc]\npub enum $err {\n        $($(#[$vardoc])* $variant),*\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::InvalidUtf16FirstUnit":["#[$doc1]\n#[$doc2]\npub struct $err;","Real(LocalPath(\"src/errors.rs\"))"],"errors::InvalidUtf16Slice":["#[$tydoc]\npub enum $err {\n        $($(#[$vardoc])* $variant),*\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::InvalidUtf16Tuple":["#[$tydoc]\npub enum $err {\n        $($(#[$vardoc])* $variant),*\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::InvalidUtf8":["/// Reasons why a byte sequence is not valid UTF-8, excluding invalid codepoint.\n/// In sinking precedence.\npub enum InvalidUtf8 {\n    /// Something is wrong with the first byte.\n    FirstByte(InvalidUtf8FirstByte),\n    /// The byte at index 1...3 should be a continuation byte,\n    /// but dosesn't fit the pattern 0b10xx_xxxx.\n    NotAContinuationByte(usize),\n    /// There are too many leading zeros: it could be a byte shorter.\n    ///\n    /// [Decoding this could allow someone to input otherwise prohibited\n    /// characters and sequences, such as \"../\"](https://tools.ietf.org/html/rfc3629#section-10).\n    OverLong,\n}","Real(LocalPath(\"src/errors.rs\"))"],"errors::InvalidUtf8Array":["/// Reasons why a byte array is not valid UTF-8, in sinking precedence.\npub enum InvalidUtf8Array {\n    /// Not a valid UTF-8 sequence.\n    Utf8(InvalidUtf8),\n    /// Not a valid unicode codepoint.\n    Codepoint(InvalidCodepoint),\n}","Real(LocalPath(\"src/errors.rs\"))"],"errors::InvalidUtf8FirstByte":["#[$tydoc]\npub enum $err {\n        $($(#[$vardoc])* $variant),*\n    }","Real(LocalPath(\"src/errors.rs\"))"],"errors::InvalidUtf8Slice":["/// Reasons why a byte slice is not valid UTF-8, in sinking precedence.\npub enum InvalidUtf8Slice {\n    /// Something is certainly wrong with the first byte.\n    Utf8(InvalidUtf8),\n    /// The encoded codepoint is invalid:\n    Codepoint(InvalidCodepoint),\n    /// The slice is too short; n bytes was required.\n    TooShort(usize),\n}","Real(LocalPath(\"src/errors.rs\"))"],"errors::NonAsciiError":["#[$doc1]\n#[$doc2]\npub struct $err;","Real(LocalPath(\"src/errors.rs\"))"],"errors::NonBMPError":["#[$doc1]\n#[$doc2]\npub struct $err;","Real(LocalPath(\"src/errors.rs\"))"],"errors::Utf16PairError":["#[$tydoc]\npub enum $err {\n        $($(#[$vardoc])* $variant),*\n    }","Real(LocalPath(\"src/errors.rs\"))"],"traits::CharExt":["/// Extension trait for `char` that adds methods for converting to and from UTF-8 or UTF-16.\npub trait CharExt: Sized {\n    /// Get the UTF-8 representation of this codepoint.\n    ///\n    /// `Utf8Char` is to `[u8;4]` what `char` is to `u32`:\n    /// a restricted type that cannot be mutated internally.\n    fn to_utf8(self) -> Utf8Char;\n\n    /// Get the UTF-16 representation of this codepoint.\n    ///\n    /// `Utf16Char` is to `[u16;2]` what `char` is to `u32`:\n    /// a restricted type that cannot be mutated internally.\n    fn to_utf16(self) -> Utf16Char;\n\n    /// Iterate over or [read](https://doc.rust-lang.org/std/io/trait.Read.html)\n    /// the one to four bytes in the UTF-8 representation of this codepoint.\n    ///\n    /// An identical alternative to the unstable `char.encode_utf8()`.\n    /// That method somehow still exist on stable, so I have to use a different name.\n    fn iter_utf8_bytes(self) -> Utf8Iterator;\n\n    /// Iterate over the one or two units in the UTF-16 representation of this codepoint.\n    ///\n    /// An identical alternative to the unstable `char.encode_utf16()`.\n    /// That method somehow still exist on stable, so I have to use a different name.\n    fn iter_utf16_units(self) -> Utf16Iterator;\n\n\n    /// Convert this char to an UTF-8 array, and also return how many bytes of\n    /// the array are used,\n    ///\n    /// The returned array is left-aligned with unused bytes set to zero.\n    fn to_utf8_array(self) -> ([u8; 4], usize);\n\n    /// Convert this `char` to UTF-16.\n    ///\n    /// The second element is non-zero when a surrogate pair is required.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::CharExt;\n    ///\n    /// assert_eq!('@'.to_utf16_array(), ['@' as u16, 0]);\n    /// assert_eq!('睷'.to_utf16_array(), ['睷' as u16, 0]);\n    /// assert_eq!('\\u{abcde}'.to_utf16_array(), [0xda6f, 0xdcde]);\n    /// ```\n    fn to_utf16_array(self) -> [u16; 2];\n\n    /// Convert this `char` to UTF-16.\n    /// The second item is `Some` if a surrogate pair is required.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::CharExt;\n    ///\n    /// assert_eq!('@'.to_utf16_tuple(), ('@' as u16, None));\n    /// assert_eq!('睷'.to_utf16_tuple(), ('睷' as u16, None));\n    /// assert_eq!('\\u{abcde}'.to_utf16_tuple(), (0xda6f, Some(0xdcde)));\n    /// ```\n    fn to_utf16_tuple(self) -> (u16, Option<u16>);\n\n\n\n    /// Create a `char` from the start of an UTF-8 slice,\n    /// and also return how many bytes were used.\n    ///\n    /// # Errors\n    ///\n    /// Returns an `Err` if the slice is empty, doesn't start with a valid\n    /// UTF-8 sequence or is too short for the sequence.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::CharExt;\n    /// use encode_unicode::error::InvalidUtf8Slice::*;\n    /// use encode_unicode::error::InvalidUtf8::*;\n    ///\n    /// assert_eq!(char::from_utf8_slice_start(&[b'A', b'B', b'C']), Ok(('A',1)));\n    /// assert_eq!(char::from_utf8_slice_start(&[0xdd, 0xbb]), Ok(('\\u{77b}',2)));\n    ///\n    /// assert_eq!(char::from_utf8_slice_start(&[]), Err(TooShort(1)));\n    /// assert_eq!(char::from_utf8_slice_start(&[0xf0, 0x99]), Err(TooShort(4)));\n    /// assert_eq!(char::from_utf8_slice_start(&[0xee, b'F', 0x80]), Err(Utf8(NotAContinuationByte(1))));\n    /// assert_eq!(char::from_utf8_slice_start(&[0xee, 0x99, 0x0f]), Err(Utf8(NotAContinuationByte(2))));\n    /// ```\n    fn from_utf8_slice_start(src: &[u8]) -> Result<(Self,usize),InvalidUtf8Slice>;\n\n    /// Create a `char` from the start of an UTF-16 slice,\n    /// and also return how many units were used.\n    ///\n    /// If you want to continue after an error, continue with the next `u16` unit.\n    fn from_utf16_slice_start(src: &[u16]) -> Result<(Self,usize), InvalidUtf16Slice>;\n\n\n    /// Convert an UTF-8 sequence as returned from `.to_utf8_array()` into a `char`\n    ///\n    /// The codepoint must start at the first byte, and leftover bytes are ignored.\n    ///\n    /// # Errors\n    ///\n    /// Returns an `Err` if the array doesn't start with a valid UTF-8 sequence.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::CharExt;\n    /// use encode_unicode::error::InvalidUtf8Array::*;\n    /// use encode_unicode::error::InvalidUtf8::*;\n    /// use encode_unicode::error::InvalidCodepoint::*;\n    ///\n    /// assert_eq!(char::from_utf8_array([b'A', 0, 0, 0]), Ok('A'));\n    /// assert_eq!(char::from_utf8_array([0xf4, 0x8b, 0xbb, 0xbb]), Ok('\\u{10befb}'));\n    /// assert_eq!(char::from_utf8_array([b'A', b'B', b'C', b'D']), Ok('A'));\n    /// assert_eq!(char::from_utf8_array([0, 0, 0xcc, 0xbb]), Ok('\\0'));\n    ///\n    /// assert_eq!(char::from_utf8_array([0xef, b'F', 0x80, 0x80]), Err(Utf8(NotAContinuationByte(1))));\n    /// assert_eq!(char::from_utf8_array([0xc1, 0x80, 0, 0]), Err(Utf8(OverLong)));\n    /// assert_eq!(char::from_utf8_array([0xf7, 0xaa, 0x99, 0x88]), Err(Codepoint(TooHigh)));\n    /// ```\n    fn from_utf8_array(utf8: [u8; 4]) -> Result<Self,InvalidUtf8Array>;\n\n    /// Convert a UTF-16 pair as returned from `.to_utf16_array()` into a `char`.\n    ///\n    /// The second element is ignored when not required.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::CharExt;\n    /// use encode_unicode::error::InvalidUtf16Array;\n    ///\n    /// assert_eq!(char::from_utf16_array(['x' as u16, 'y' as u16]), Ok('x'));\n    /// assert_eq!(char::from_utf16_array(['睷' as u16, 0]), Ok('睷'));\n    /// assert_eq!(char::from_utf16_array([0xda6f, 0xdcde]), Ok('\\u{abcde}'));\n    /// assert_eq!(char::from_utf16_array([0xf111, 0xdbad]), Ok('\\u{f111}'));\n    /// assert_eq!(char::from_utf16_array([0xdaaf, 0xdaaf]), Err(InvalidUtf16Array::SecondIsNotTrailingSurrogate));\n    /// assert_eq!(char::from_utf16_array([0xdcac, 0x9000]), Err(InvalidUtf16Array::FirstIsTrailingSurrogate));\n    /// ```\n    fn from_utf16_array(utf16: [u16; 2]) -> Result<Self, InvalidUtf16Array>;\n\n    /// Convert a UTF-16 pair as returned from `.to_utf16_tuple()` into a `char`.\n    fn from_utf16_tuple(utf16: (u16, Option<u16>)) -> Result<Self, InvalidUtf16Tuple>;\n\n\n    /// Convert an UTF-8 sequence into a char.\n    ///\n    /// The length of the slice is taken as length of the sequence;\n    /// it should be 1,2,3 or 4.\n    ///\n    /// # Safety\n    ///\n    /// The slice must contain exactly one, valid, UTF-8 sequence.\n    ///\n    /// Passing a slice that produces an invalid codepoint is always undefined\n    /// behavior; Later checks that the codepoint is valid can be removed\n    /// by the compiler.\n    ///\n    /// # Panics\n    ///\n    /// If the slice is empty\n    unsafe fn from_utf8_exact_slice_unchecked(src: &[u8]) -> Self;\n\n    /// Convert a UTF-16 array as returned from `.to_utf16_array()` into a\n    /// `char`.\n    ///\n    /// This function is safe because it avoids creating invalid codepoints,\n    /// but the returned value might not be what one expectedd.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::CharExt;\n    ///\n    /// // starts with a trailing surrogate - converted as if it was a valid\n    /// // surrogate pair anyway.\n    /// assert_eq!(char::from_utf16_array_unchecked([0xdbad, 0xf19e]), '\\u{fb59e}');\n    /// // missing trailing surrogate - ditto\n    /// assert_eq!(char::from_utf16_array_unchecked([0xd802, 0]), '\\u{10800}');\n    /// ```\n    fn from_utf16_array_unchecked(utf16: [u16;2]) -> Self;\n\n    /// Convert a UTF-16 tuple as returned from `.to_utf16_tuple()` into a `char`.\n    unsafe fn from_utf16_tuple_unchecked(utf16: (u16, Option<u16>)) -> Self;\n\n\n    /// Produces more detailed errors than `char::from_u32()`\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if\n    ///\n    /// * the value is greater than 0x10ffff\n    /// * the value is between 0xd800 and 0xdfff (inclusive)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use encode_unicode::CharExt;\n    /// use encode_unicode::error::InvalidCodepoint;\n    ///\n    /// assert_eq!(char::from_u32_detailed(0x41), Ok('A'));\n    /// assert_eq!(char::from_u32_detailed(0x40_00_00), Err(InvalidCodepoint::TooHigh));\n    /// assert_eq!(char::from_u32_detailed(0xd951), Err(InvalidCodepoint::Utf16Reserved));\n    /// assert_eq!(char::from_u32_detailed(0xdddd), Err(InvalidCodepoint::Utf16Reserved));\n    /// assert_eq!(char::from_u32_detailed(0xdd), Ok('Ý'));\n    /// assert_eq!(char::from_u32_detailed(0x1f331), Ok('🌱'));\n    /// ```\n    fn from_u32_detailed(c: u32) -> Result<Self,InvalidCodepoint>;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::IterExt":["/// Iterator methods that convert between `u8`s and `Utf8Char` or `u16`s and `Utf16Char`\n///\n/// All the iterator adapters also accept iterators that produce references of\n/// the type they convert from.\npub trait IterExt: Iterator+Sized {\n    /// Converts an iterator of `Utf8Char`s or `&Utf8Char`s to an iterator of\n    /// `u8`s.\n    ///\n    /// Has the same effect as `.flat_map()` or `.flatten()`, but the returned\n    /// iterator is ~40% faster.\n    ///\n    /// The iterator also implements `Read`\n    /// (when the `std` feature isn't disabled).  \n    /// Reading will never produce an error, and calls to `.read()` and `.next()`\n    /// can be mixed.\n    ///\n    /// The exact number of bytes cannot be known in advance, but `size_hint()`\n    /// gives the possible range.\n    /// (min: all remaining characters are ASCII, max: all require four bytes)\n    ///\n    /// # Examples\n    ///\n    /// From iterator of values:\n    ///\n    /// ```\n    /// use encode_unicode::{IterExt, StrExt};\n    ///\n    /// let iterator = \"foo\".utf8chars();\n    /// let mut bytes = [0; 4];\n    /// for (u,dst) in iterator.to_bytes().zip(&mut bytes) {*dst=u;}\n    /// assert_eq!(&bytes, b\"foo\\0\");\n    /// ```\n    ///\n    /// From iterator of references:\n    ///\n    #[cfg_attr(feature=\"std\", doc=\" ```\")]\n    #[cfg_attr(not(feature=\"std\"), doc=\" ```no_compile\")]\n    /// use encode_unicode::{IterExt, StrExt, Utf8Char};\n    ///\n    /// let chars: Vec<Utf8Char> = \"💣 bomb 💣\".utf8chars().collect();\n    /// let bytes: Vec<u8> = chars.iter().to_bytes().collect();\n    /// let flat_map: Vec<u8> = chars.iter().flat_map(|u8c| *u8c ).collect();\n    /// assert_eq!(bytes, flat_map);\n    /// ```\n    ///\n    /// `Read`ing from it:\n    ///\n    #[cfg_attr(feature=\"std\", doc=\" ```\")]\n    #[cfg_attr(not(feature=\"std\"), doc=\" ```no_compile\")]\n    /// use encode_unicode::{IterExt, StrExt};\n    /// use std::io::Read;\n    ///\n    /// let s = \"Ååh‽\";\n    /// assert_eq!(s.len(), 8);\n    /// let mut buf = [b'E'; 9];\n    /// let mut reader = s.utf8chars().to_bytes();\n    /// assert_eq!(reader.read(&mut buf[..]).unwrap(), 8);\n    /// assert_eq!(reader.read(&mut buf[..]).unwrap(), 0);\n    /// assert_eq!(&buf[..8], s.as_bytes());\n    /// assert_eq!(buf[8], b'E');\n    /// ```\n    fn to_bytes(self) -> Utf8CharSplitter<Self::Item,Self> where Self::Item: Borrow<Utf8Char>;\n\n    /// Converts an iterator of `Utf16Char` (or `&Utf16Char`) to an iterator of\n    /// `u16`s.\n    ///\n    /// Has the same effect as `.flat_map()` or `.flatten()`, but the returned\n    /// iterator is about twice as fast.\n    ///\n    /// The exact number of units cannot be known in advance, but `size_hint()`\n    /// gives the possible range.\n    ///\n    /// # Examples\n    ///\n    /// From iterator of values:\n    ///\n    /// ```\n    /// use encode_unicode::{IterExt, StrExt};\n    ///\n    /// let iterator = \"foo\".utf16chars();\n    /// let mut units = [0; 4];\n    /// for (u,dst) in iterator.to_units().zip(&mut units) {*dst=u;}\n    ///\n    /// assert_eq!(units, ['f' as u16, 'o' as u16, 'o' as u16, 0]);\n    /// ```\n    ///\n    /// From iterator of references:\n    ///\n    #[cfg_attr(feature=\"std\", doc=\" ```\")]\n    #[cfg_attr(not(feature=\"std\"), doc=\" ```no_compile\")]\n    /// use encode_unicode::{IterExt, StrExt, Utf16Char};\n    ///\n    /// // (💣 takes two units)\n    /// let chars: Vec<Utf16Char> = \"💣 bomb 💣\".utf16chars().collect();\n    /// let units: Vec<u16> = chars.iter().to_units().collect();\n    /// let flat_map: Vec<u16> = chars.iter().flat_map(|u16c| *u16c ).collect();\n    ///\n    /// assert_eq!(units, flat_map);\n    /// ```\n    fn to_units(self) -> Utf16CharSplitter<Self::Item,Self> where Self::Item: Borrow<Utf16Char>;\n\n    /// Decodes bytes as UTF-8 and groups them into `Utf8Char`s\n    ///\n    /// When errors (invalid values or sequences) are encountered,\n    /// it continues with the byte right after the start of the error sequence.  \n    /// This is neither the most intelligent choiche (sometimes it is guaranteed to\n    ///  produce another error), nor the easiest to implement, but I believe it to\n    /// be the most predictable.\n    /// It also means that ASCII characters are never hidden by errors.\n    ///\n    /// # Examples\n    ///\n    /// Replace all errors with u+FFFD REPLACEMENT_CHARACTER:\n    /// ```\n    /// use encode_unicode::{Utf8Char, IterExt};\n    ///\n    /// let mut buf = [b'\\0'; 255];\n    /// let len = b\"foo\\xCFbar\".iter()\n    ///     .to_utf8chars()\n    ///     .flat_map(|r| r.unwrap_or(Utf8Char::from('\\u{FFFD}')).into_iter() )\n    ///     .zip(&mut buf[..])\n    ///     .map(|(byte, dst)| *dst = byte )\n    ///     .count();\n    ///\n    /// assert_eq!(&buf[..len], \"foo\\u{FFFD}bar\".as_bytes());\n    /// ```\n    ///\n    /// Collect everything up until the first error into a string:\n    #[cfg_attr(feature=\"std\", doc=\" ```\")]\n    #[cfg_attr(not(feature=\"std\"), doc=\" ```no_compile\")]\n    /// use encode_unicode::iterator::Utf8CharMerger;\n    /// let mut good = String::new();\n    /// for r in Utf8CharMerger::from(b\"foo\\xcc\\xbbbar\\xcc\\xddbaz\") {\n    ///     if let Ok(uc) = r {\n    ///         good.push_str(uc.as_str());\n    ///     } else {\n    ///         break;\n    ///     }\n    /// }\n    /// assert_eq!(good, \"foo̻bar\");\n    /// ```\n    ///\n    /// Abort decoding on error:\n    #[cfg_attr(feature=\"std\", doc=\" ```\")]\n    #[cfg_attr(not(feature=\"std\"), doc=\" ```no_compile\")]\n    /// use encode_unicode::{IterExt, Utf8Char};\n    /// use encode_unicode::error::{InvalidUtf8Slice, InvalidUtf8};\n    ///\n    /// let result = b\"ab\\0\\xe0\\xbc\\xa9 \\xf3\\x80\\x77\".iter()\n    ///     .to_utf8chars()\n    ///     .collect::<Result<String,InvalidUtf8Slice>>();\n    ///\n    /// assert_eq!(result, Err(InvalidUtf8Slice::Utf8(InvalidUtf8::NotAContinuationByte(2))));\n    /// ```\n    fn to_utf8chars(self) -> Utf8CharMerger<Self::Item,Self> where Self::Item: Borrow<u8>;\n\n    /// Decodes bytes as UTF-16 and groups them into `Utf16Char`s\n    ///\n    /// When errors (unmatched leading surrogates or unexpected trailing surrogates)\n    /// are encountered, an error is produced for every unit.\n    ///\n    /// # Examples\n    ///\n    /// Replace errors with '�':\n    #[cfg_attr(feature=\"std\", doc=\" ```\")]\n    #[cfg_attr(not(feature=\"std\"), doc=\" ```no_compile\")]\n    /// use encode_unicode::{IterExt, Utf16Char};\n    ///\n    /// let slice = &['a' as u16, 0xdf00, 0xd83c, 0xdca0][..];\n    /// let string = slice.iter()\n    ///     .to_utf16chars()\n    ///     .map(|r| r.unwrap_or(Utf16Char::from('\\u{fffd}')) ) // REPLACEMENT_CHARACTER\n    ///     .collect::<String>();\n    ///\n    /// assert_eq!(string, \"a�🂠\");\n    /// ```\n    ///\n    /// ```\n    /// use encode_unicode::{IterExt, Utf16Char};\n    /// use encode_unicode::error::Utf16PairError::*;\n    ///\n    /// let slice = [0xdcba, 0xdeff, 0xd8be, 0xdeee, 'Y' as u16, 0xdab1, 0xdab1];\n    /// let mut iter = slice.iter().to_utf16chars();\n    /// assert_eq!(iter.size_hint(), (3, Some(7)));\n    /// assert_eq!(iter.next(), Some(Err(UnexpectedTrailingSurrogate)));\n    /// assert_eq!(iter.next(), Some(Err(UnexpectedTrailingSurrogate)));\n    /// assert_eq!(iter.next(), Some(Ok(Utf16Char::from('\\u{3faee}'))));\n    /// assert_eq!(iter.next(), Some(Ok(Utf16Char::from('Y'))));\n    /// assert_eq!(iter.next(), Some(Err(UnmatchedLeadingSurrogate)));\n    /// assert_eq!(iter.next(), Some(Err(Incomplete)));\n    /// assert_eq!(iter.into_remaining_units().next(), None);\n    /// ```\n    ///\n    /// Search for a codepoint and return the codepoint index of the first match:\n    /// ```\n    /// use encode_unicode::{IterExt, Utf16Char};\n    ///\n    /// let position = [0xd875, 0xdd4f, '≈' as u16, '2' as u16].iter()\n    ///     .to_utf16chars()\n    ///     .position(|r| r == Ok(Utf16Char::from('≈')) );\n    ///\n    /// assert_eq!(position, Some(1));\n    /// ```\n    fn to_utf16chars(self) -> Utf16CharMerger<Self::Item,Self> where Self::Item: Borrow<u16>;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::SliceExt":["/// Methods for iterating over `u8` and `u16` slices as UTF-8 or UTF-16 characters.\n///\n/// The iterators are slightly faster than the similar methods in [`IterExt`](trait.IterExt.html)\n/// because they con \"push back\" items for free after errors and don't need a\n/// separate buffer that must be checked on every call to `.next()`.\npub trait SliceExt: Index<RangeFull> {\n    /// Decode `u8` slices as UTF-8 and iterate over the codepoints as `Utf8Char`s,\n    ///\n    /// # Examples\n    ///\n    /// Get the index and error type of the first error:\n    #[cfg_attr(feature=\"std\", doc=\" ```\")]\n    #[cfg_attr(not(feature=\"std\"), doc=\" ```no_compile\")]\n    /// use encode_unicode::{SliceExt, Utf8Char};\n    /// use encode_unicode::error::InvalidUtf8Slice;\n    ///\n    /// let slice = b\"ab\\0\\xe0\\xbc\\xa9 \\xf3\\x80\\x77\";\n    /// let result = slice.utf8char_indices()\n    ///     .map(|(offset,r,length)| r.map_err(|e| (offset,e,length) ) )\n    ///     .collect::<Result<String,(usize,InvalidUtf8Slice,usize)>>();\n    ///\n    /// assert_eq!(result, Err((7, InvalidUtf8Slice::TooShort(4), 1)));\n    /// ```\n    ///\n    /// ```\n    /// use encode_unicode::{SliceExt, Utf8Char};\n    /// use std::error::Error;\n    ///\n    /// let slice = b\"\\xf0\\xbf\\xbf\\xbfXY\\xdd\\xbb\\xe1\\x80\\x99quux123\";\n    /// let mut fixed_size = [Utf8Char::default(); 8];\n    /// for (cp_i, (byte_index, r, _)) in slice.utf8char_indices().enumerate().take(8) {\n    ///     match r {\n    ///         Ok(u8c) => fixed_size[cp_i] = u8c,\n    ///         Err(e) => panic!(\"Invalid codepoint at index {} ({})\", cp_i, e.description()),\n    ///     }\n    /// }\n    /// let chars = ['\\u{3ffff}', 'X', 'Y', '\\u{77b}', '\\u{1019}', 'q', 'u', 'u'];\n    /// assert_eq!(fixed_size, chars);\n    /// ```\n    ///\n    #[cfg_attr(feature=\"std\", doc=\" ```\")]\n    #[cfg_attr(not(feature=\"std\"), doc=\" ```no_compile\")]\n    /// use encode_unicode::{SliceExt, Utf8Char};\n    /// use encode_unicode::error::InvalidUtf8Slice::*;\n    /// use encode_unicode::error::{InvalidUtf8, InvalidUtf8FirstByte, InvalidCodepoint};\n    ///\n    /// let bytes = b\"\\xfa-\\xf4\\x8f\\xee\\xa1\\x8f-\\xed\\xa9\\x87\\xf0\\xcc\\xbb\";\n    /// let mut errors = Vec::new();\n    /// let mut lengths = Vec::new();\n    /// let mut string = String::new();\n    /// for (offset,result,length) in bytes.utf8char_indices() {\n    ///     lengths.push((offset,length));\n    ///     let c = result.unwrap_or_else(|error| {\n    ///         errors.push((offset,error));\n    ///         Utf8Char::from('\\u{fffd}') // replacement character\n    ///     });\n    ///     string.push_str(c.as_str());\n    /// }\n    ///\n    /// assert_eq!(string, \"�-��\\u{e84f}-����\\u{33b}\");\n    /// assert_eq!(lengths, [(0,1), (1,1), (2,1), (3,1), (4,3), (7,1),\n    ///                      (8,1), (9,1), (10,1), (11,1), (12,2)]);\n    /// assert_eq!(errors, [\n    ///     ( 0, Utf8(InvalidUtf8::FirstByte(InvalidUtf8FirstByte::TooLongSeqence))),\n    ///     ( 2, Utf8(InvalidUtf8::NotAContinuationByte(2))),\n    ///     ( 3, Utf8(InvalidUtf8::FirstByte(InvalidUtf8FirstByte::ContinuationByte))),\n    ///     ( 8, Codepoint(InvalidCodepoint::Utf16Reserved)),\n    ///     ( 9, Utf8(InvalidUtf8::FirstByte(InvalidUtf8FirstByte::ContinuationByte))),\n    ///     (10, Utf8(InvalidUtf8::FirstByte(InvalidUtf8FirstByte::ContinuationByte))),\n    ///     (11, TooShort(4)), // (but it was not the last element returned!)\n    /// ]);\n    /// ```\n    fn utf8char_indices(&self) -> Utf8CharDecoder where Self::Output: Borrow<[u8]>;\n\n\n    /// Decode `u16` slices as UTF-16 and iterate over the codepoints as `Utf16Char`s,\n    ///\n    /// The iterator produces `(usize,Result<Utf16Char,Utf16Error>,usize)`,\n    /// and the slice is validated as you go.\n    ///\n    /// The first `usize` contains the offset from the start of the slice and\n    /// the last `usize` contains the length of the codepoint or error.\n    /// The length is either 1 or 2, and always 1 for errors.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(feature=\"std\", doc=\" ```\")]\n    #[cfg_attr(not(feature=\"std\"), doc=\" ```no_compile\")]\n    /// use encode_unicode::{SliceExt, Utf8Char};\n    ///\n    /// let slice = &['a' as u16, 0xdf00, 0xd83c, 0xdca0][..];\n    /// let mut errors = Vec::new();\n    /// let string = slice.utf16char_indices().map(|(offset,r,_)| match r {\n    ///     Ok(u16c) => Utf8Char::from(u16c),\n    ///     Err(_) => {\n    ///         errors.push(offset);\n    ///         Utf8Char::from('\\u{fffd}') // REPLACEMENT_CHARACTER\n    ///     }\n    /// }).collect::<String>();\n    ///\n    /// assert_eq!(string, \"a�🂠\");\n    /// assert_eq!(errors, [1]);\n    /// ```\n    ///\n    /// Search for a codepoint and return its unit and codepoint index.\n    /// ```\n    /// use encode_unicode::{SliceExt, Utf16Char};\n    ///\n    /// let slice = [0xd875,/*'𝕏'*/ 0xdd4f, '≈' as u16, '2' as u16];\n    /// let position = slice.utf16char_indices()\n    ///     .enumerate()\n    ///     .find(|&(_,(_,r,_))| r == Ok(Utf16Char::from('≈')) )\n    ///     .map(|(codepoint, (offset, _, _))| (codepoint, offset) );\n    ///\n    /// assert_eq!(position, Some((1,2)));\n    /// ```\n    ///\n    /// Error types:\n    /// ```\n    /// use encode_unicode::{SliceExt, Utf16Char};\n    /// use encode_unicode::error::Utf16PairError::*;\n    ///\n    /// let slice = [0xdcba, 0xdeff, 0xd8be, 0xdeee, 'λ' as u16, 0xdab1, 0xdab1];\n    /// let mut iter = slice.utf16char_indices();\n    /// assert_eq!(iter.next(), Some((0, Err(UnexpectedTrailingSurrogate), 1)));\n    /// assert_eq!(iter.next(), Some((1, Err(UnexpectedTrailingSurrogate), 1)));\n    /// assert_eq!(iter.next(), Some((2, Ok(Utf16Char::from('\\u{3faee}')), 2)));\n    /// assert_eq!(iter.next(), Some((4, Ok(Utf16Char::from('λ')), 1)));\n    /// assert_eq!(iter.next(), Some((5, Err(UnmatchedLeadingSurrogate), 1)));\n    /// assert_eq!(iter.next(), Some((6, Err(Incomplete), 1)));\n    /// assert_eq!(iter.next(), None);\n    /// assert_eq!(iter.as_slice(), [])\n    /// ```\n    fn utf16char_indices(&self) -> Utf16CharDecoder where Self::Output: Borrow<[u16]>;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::StrExt":["/// Adds `.utf8chars()` and `.utf16chars()` iterator constructors to `&str`.\npub trait StrExt: AsRef<str> {\n    /// Equivalent to `.chars()` but produces `Utf8Char`s.\n    fn utf8chars(&self) -> Utf8Chars;\n    /// Equivalent to `.chars()` but produces `Utf16Char`s.\n    fn utf16chars(&self) -> Utf16Chars;\n    /// Equivalent to `.char_indices()` but produces `Utf8Char`s.\n    fn utf8char_indices(&self) -> Utf8CharIndices;\n    /// Equivalent to `.char_indices()` but produces `Utf16Char`s.\n    fn utf16char_indices(&self) -> Utf16CharIndices;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::U16UtfExt":["/// Methods for working with `u16`s as UTF-16 units.\npub trait U16UtfExt {\n    /// Will you need an extra unit to complete this codepoint?\n    ///\n    /// Returns `Err` for trailing surrogates, `Ok(true)` for leading surrogates,\n    /// and `Ok(false)` for others.\n    fn utf16_needs_extra_unit(self) -> Result<bool,InvalidUtf16FirstUnit>;\n\n    /// Does this `u16` need another `u16` to complete a codepoint?\n    /// Returns `(self & 0xfc00) == 0xd800`\n    ///\n    /// Is basically an unchecked variant of `utf16_needs_extra_unit()`.\n    fn is_utf16_leading_surrogate(self) -> bool;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::U8UtfExt":["/// Methods for working with `u8`s as UTF-8 bytes.\npub trait U8UtfExt {\n    /// How many more bytes will you need to complete this codepoint?\n    ///\n    /// # Errors\n    ///\n    /// An error is returned if the byte is not a valid start of an UTF-8\n    /// codepoint:\n    ///\n    /// * `128..192`: ContinuationByte\n    /// * `248..`: TooLongSequence\n    ///\n    /// Values in 244..248 represent a too high codepoint, but do not cause an\n    /// error.\n    fn extra_utf8_bytes(self) -> Result<usize,InvalidUtf8FirstByte>;\n\n    /// How many more bytes will you need to complete this codepoint?\n    ///\n    /// This function assumes that the byte is a valid UTF-8 start, and might\n    /// return any value otherwise. (but the function is pure and safe to call\n    /// with any value).\n    fn extra_utf8_bytes_unchecked(self) -> usize;\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::combine_surrogates":["/// Create a `char` from a leading and a trailing surrogate.\n///\n/// This function is safe because it ignores the six most significant bits of\n/// each arguments and always produces a codepoint in 0x01_00_00..=0x10_ff_ff.\nfn combine_surrogates(first: u16,  second: u16) -> char{\n    unsafe {\n        let high = (first & 0x_03_ff) as u32;\n        let low = (second & 0x_03_ff) as u32;\n        let c = ((high << 10) | low) + 0x_01_00_00; // no, the constant can't be or'd in\n        char::from_u32_unchecked(c)\n    }\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::merge_nonascii_unchecked_utf8":["/// Decodes the codepoint represented by a multi-byte UTF-8 sequence.\n///\n/// Does not check that the codepoint is valid,\n/// and returns `u32` because casting invalid codepoints to `char` is insta UB.\nfn merge_nonascii_unchecked_utf8(src: &[u8]) -> u32{\n    let mut c = src[0] as u32 & (0x7f >> src.len());\n    for b in &src[1..] {\n        c = (c << 6)  |  (b & 0b0011_1111) as u32;\n    }\n    c\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::overlong":["fn overlong(first: u8, second: u8) -> bool{\n    if first < 0x80 {\n        false\n    } else if (first & 0xe0) == 0xc0 {\n        (first & 0xfe) == 0xc0\n    } else if (first & 0xf0) == 0xe0 {\n        first == 0xe0 && (second & 0xe0) == 0x80\n    } else {\n        first == 0xf0 && (second & 0xf0) == 0x80\n    }\n}","Real(LocalPath(\"src/traits.rs\"))"],"utf16_char::<impl std::cmp::PartialEq<utf16_char::Utf16Char> for char>::eq":["fn eq(&self,  u16c: &Utf16Char) -> bool{\n        Utf16Char::from(*self) == *u16c\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::<impl std::cmp::PartialOrd<utf16_char::Utf16Char> for char>::partial_cmp":["fn partial_cmp(&self,  u16c: &Utf16Char) -> Option<Ordering>{\n        Utf16Char::from(*self).partial_cmp(u16c)\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::<impl std::convert::From<utf16_char::Utf16Char> for char>::from":["fn from(uc: Utf16Char) -> char{\n        char::from_utf16_array_unchecked(uc.to_array())\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::<impl std::iter::Extend<&'a utf16_char::Utf16Char> for std::string::String>::extend":["fn extend<I:IntoIterator<Item=&'a Utf16Char>>(&mut self,  iter: I){\n        self.extend(iter.into_iter().cloned());\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::<impl std::iter::Extend<&'a utf16_char::Utf16Char> for std::vec::Vec<u16>>::extend":["fn extend<I:IntoIterator<Item=&'a Utf16Char>>(&mut self,  iter: I){\n        self.extend(iter.into_iter().cloned())\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::<impl std::iter::Extend<utf16_char::Utf16Char> for std::string::String>::extend":["fn extend<I:IntoIterator<Item=Utf16Char>>(&mut self,  iter: I){\n        self.extend(iter.into_iter().map(|u16c| Utf8Char::from(u16c) ));\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::<impl std::iter::Extend<utf16_char::Utf16Char> for std::vec::Vec<u16>>::extend":["fn extend<I:IntoIterator<Item=Utf16Char>>(&mut self,  iter: I){\n        let iter = iter.into_iter();\n        self.reserve(iter.size_hint().0);\n        for u16c in iter {\n            self.push(u16c.units[0]);\n            if u16c.units[1] != 0 {\n                self.push(u16c.units[1]);\n            }\n        }\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::<impl std::iter::FromIterator<&'a utf16_char::Utf16Char> for std::string::String>::from_iter":["fn from_iter<I:IntoIterator<Item=&'a Utf16Char>>(iter: I) -> Self{\n        Self::from_iter(iter.into_iter().cloned())\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::<impl std::iter::FromIterator<&'a utf16_char::Utf16Char> for std::vec::Vec<u16>>::from_iter":["fn from_iter<I:IntoIterator<Item=&'a Utf16Char>>(iter: I) -> Self{\n        Self::from_iter(iter.into_iter().cloned())\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::<impl std::iter::FromIterator<utf16_char::Utf16Char> for std::string::String>::from_iter":["fn from_iter<I:IntoIterator<Item=Utf16Char>>(iter: I) -> Self{\n        let mut s = String::new();\n        s.extend(iter);\n        return s;\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::<impl std::iter::FromIterator<utf16_char::Utf16Char> for std::vec::Vec<u16>>::from_iter":["fn from_iter<I:IntoIterator<Item=Utf16Char>>(iter: I) -> Self{\n        let mut vec = Vec::new();\n        vec.extend(iter);\n        return vec;\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char":["/// An unicode codepoint stored as UTF-16.\n///\n/// It can be borrowed as an `u16` slice, and has the same size as `char`.\npub struct Utf16Char {\n    units: [u16; 2],\n}","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::eq_ignore_ascii_case":["/// Checks that two characters are an ASCII case-insensitive match.\n///\n/// Is equivalent to `a.to_ascii_lowercase() == b.to_ascii_lowercase()`.\n#[cfg(feature=\"std\")]\npub fn eq_ignore_ascii_case(&self,  other: &Self) -> bool{\n        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::from_array":["/// Validate and store an UTF-16 array as returned from `char.to_utf16_array()`.\n///\n/// # Examples\n///\n/// ```\n/// use encode_unicode::Utf16Char;\n/// use encode_unicode::error::InvalidUtf16Array;\n///\n/// assert_eq!(Utf16Char::from_array(['x' as u16, 'y' as u16]), Ok(Utf16Char::from('x')));\n/// assert_eq!(Utf16Char::from_array(['睷' as u16, 0]), Ok(Utf16Char::from('睷')));\n/// assert_eq!(Utf16Char::from_array([0xda6f, 0xdcde]), Ok(Utf16Char::from('\\u{abcde}')));\n/// assert_eq!(Utf16Char::from_array([0xf111, 0xdbad]), Ok(Utf16Char::from('\\u{f111}')));\n/// assert_eq!(Utf16Char::from_array([0xdaaf, 0xdaaf]), Err(InvalidUtf16Array::SecondIsNotTrailingSurrogate));\n/// assert_eq!(Utf16Char::from_array([0xdcac, 0x9000]), Err(InvalidUtf16Array::FirstIsTrailingSurrogate));\n/// ```\npub fn from_array(units: [u16; 2]) -> Result<Self,InvalidUtf16Array>{\n        if (units[0] & 0xf8_00) != 0xd8_00 {\n            Ok(Utf16Char { units: [units[0], 0] })\n        } else if units[0] < 0xdc_00  &&  (units[1] & 0xfc_00) == 0xdc_00 {\n            Ok(Utf16Char { units: units })\n        } else if units[0] < 0xdc_00 {\n            Err(InvalidUtf16Array::SecondIsNotTrailingSurrogate)\n        } else {\n            Err(InvalidUtf16Array::FirstIsTrailingSurrogate)\n        }\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::from_array_unchecked":["/// Create an `Utf16Char` from an array as returned from `char.to_utf16_array()`.\n///\n/// # Safety\n///\n/// The units must form a valid codepoint, and the second unit must be 0\n/// when a surrogate pair is not required.\n/// Violating this can easily lead to undefined behavior, although unlike\n/// `char` bad `Utf16Char`s simply existing is not immediately UB.\npub unsafe fn from_array_unchecked(units: [u16; 2]) -> Self{\n        Utf16Char { units: units }\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::from_bmp":["/// Create an `Utf16Char` from a single unit.\n///\n/// Codepoints < '\\u{1_0000}' (which fit in a `u16`) are part of the basic\n/// multilingual plane unless they are reserved for surrogate pairs.\n///\n/// # Errors\n///\n/// Returns `NonBMPError` if the unit is in the range `0xd800..0xe000`\n/// (which means that it's part of a surrogat pair)\n///\n/// # Examples\n///\n/// ```\n/// # use encode_unicode::Utf16Char;\n/// assert_eq!(Utf16Char::from_bmp(0x40).unwrap(), '@');\n/// assert_eq!(Utf16Char::from_bmp('ø' as u16).unwrap(), 'ø');\n/// assert!(Utf16Char::from_bmp(0xdddd).is_err());\n/// ```\npub fn from_bmp(bmp_codepoint: u16) -> Result<Self,NonBMPError>{\n        if bmp_codepoint & 0xf800 != 0xd800 {\n            Ok(Utf16Char{ units: [bmp_codepoint, 0] })\n        } else {\n            Err(NonBMPError)\n        }\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::from_bmp_unchecked":["/// Create an `Utf16Char` from a single unit without checking that it's a\n/// valid codepoint on its own.\n///\n/// # Safety\n///\n/// The unit must be less than 0xd800 or greater than 0xdfff.\n/// In other words, not part of a surrogate pair.  \n/// Violating this can easily lead to undefined behavior.\n#[inline]\npub unsafe fn from_bmp_unchecked(bmp_codepoint: u16) -> Self{\n        Utf16Char{ units: [bmp_codepoint, 0] }\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::from_slice_start":["/// Validate and store the first UTF-16 codepoint in the slice.\n/// Also return how many units were needed.\npub fn from_slice_start(src: &[u16]) -> Result<(Self,usize), InvalidUtf16Slice>{\n        char::from_utf16_slice_start(src).map(|(_,len)| {\n            let second = if len==2 {src[1]} else {0};\n            (Utf16Char{ units: [src[0], second] }, len)\n        })\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::from_slice_start_unchecked":["/// Store the first UTF-16 codepoint of the slice.\n///\n/// # Safety\n///\n/// The slice must be non-empty and start with a valid UTF-16 codepoint.  \n/// The length of the slice is never checked.\npub unsafe fn from_slice_start_unchecked(src: &[u16]) -> (Self,usize){\n        let first = *src.get_unchecked(0);\n        if first.is_utf16_leading_surrogate() {\n            (Utf16Char{ units: [first, *src.get_unchecked(1)] }, 2)\n        } else {\n            (Utf16Char{ units: [first, 0] }, 1)\n        }\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::from_str_start":["/// Create an `Utf16Char` from the first codepoint in a string slice,\n/// converting from UTF-8 to UTF-16.\n///\n/// The returned `usize` is the number of UTF-8 bytes used from the str,\n/// and not the number of UTF-16 units.\n///\n/// Returns an error if the `str` is empty.\n///\n/// # Examples\n///\n/// ```\n/// use encode_unicode::Utf16Char;\n///\n/// assert_eq!(Utf16Char::from_str_start(\"a\"), Ok((Utf16Char::from('a'),1)));\n/// assert_eq!(Utf16Char::from_str_start(\"ab\"), Ok((Utf16Char::from('a'),1)));\n/// assert_eq!(Utf16Char::from_str_start(\"🂠 \"), Ok((Utf16Char::from('🂠'),4)));\n/// assert_eq!(Utf16Char::from_str_start(\"é\"), Ok((Utf16Char::from('e'),1)));// 'e'+u301 combining mark\n/// assert!(Utf16Char::from_str_start(\"\").is_err());\n/// ```\npub fn from_str_start(s: &str) -> Result<(Self,usize), EmptyStrError>{\n        if s.is_empty() {\n            return Err(EmptyStrError);\n        }\n        let b = s.as_bytes();\n        // Read the last byte first to reduce the number of unnecesary length checks.\n        match b[0] {\n            0...127 => {// 1 byte => 1 unit\n                let unit = b[0] as u16;// 0b0000_0000_0xxx_xxxx\n                Ok((Utf16Char{ units: [unit, 0] }, 1))\n            },\n            0b1000_0000...0b1101_1111 => {// 2 bytes => 1 unit\n                let unit = (((b[1] & 0x3f) as u16) << 0) // 0b0000_0000_00xx_xxxx\n                         | (((b[0] & 0x1f) as u16) << 6);// 0b0000_0xxx_xx00_0000\n                Ok((Utf16Char{ units: [unit, 0] }, 2))\n            },\n            0b1110_0000...0b1110_1111 => {// 3 bytes => 1 unit\n                let unit = (((b[2] & 0x3f) as u16) <<  0) // 0b0000_0000_00xx_xxxx\n                         | (((b[1] & 0x3f) as u16) <<  6) // 0b0000_xxxx_xx00_0000\n                         | (((b[0] & 0x0f) as u16) << 12);// 0bxxxx_0000_0000_0000\n                Ok((Utf16Char{ units: [unit, 0] }, 3))\n            },\n            _ => {// 4 bytes => 2 units\n                let second = 0xdc00                        // 0b1101_1100_0000_0000\n                           | (((b[3] & 0x3f) as u16) << 0) // 0b0000_0000_00xx_xxxx\n                           | (((b[2] & 0x0f) as u16) << 6);// 0b0000_00xx_xx00_0000\n                let first = 0xd800-(0x01_00_00u32>>10) as u16// 0b1101_0111_1100_0000\n                          + (((b[2] & 0x30) as u16) >> 4)    // 0b0000_0000_0000_00xx\n                          + (((b[1] & 0x3f) as u16) << 2)    // 0b0000_0000_xxxx_xx00\n                          + (((b[0] & 0x07) as u16) << 8);   // 0b0000_0xxx_0000_0000\n                Ok((Utf16Char{ units: [first, second] }, 4))\n            }\n        }\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::from_tuple":["/// Validate and store a UTF-16 pair as returned from `char.to_utf16_tuple()`.\npub fn from_tuple(utf16: (u16,Option<u16>)) -> Result<Self,InvalidUtf16Tuple>{\n        unsafe {char::from_utf16_tuple(utf16).map(|_|\n            Self::from_tuple_unchecked(utf16)\n        )}\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::from_tuple_unchecked":["/// Create an `Utf16Char` from a tuple as returned from `char.to_utf16_tuple()`.\n///\n/// # Safety\n///\n/// The units must form a valid codepoint with the second being 0 when a\n/// surrogate pair is not required.\n/// Violating this can easily lead to undefined behavior.\npub unsafe fn from_tuple_unchecked(utf16: (u16,Option<u16>)) -> Self{\n        Utf16Char { units: [utf16.0, utf16.1.unwrap_or(0)] }\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::is_ascii":["/// Checks that the codepoint is an ASCII character.\n#[inline]\npub fn is_ascii(&self) -> bool{\n        self.units[0] <= 127\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::is_bmp":["/// Checks that the codepoint is in the basic multilingual plane.\n///\n/// # Examples\n/// ```\n/// # use encode_unicode::Utf16Char;\n/// assert_eq!(Utf16Char::from('e').is_bmp(), true);\n/// assert_eq!(Utf16Char::from('€').is_bmp(), true);\n/// assert_eq!(Utf16Char::from('𝔼').is_bmp(), false);\n/// ```\n#[inline]\npub fn is_bmp(&self) -> bool{\n        self.units[1] == 0\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::len":["/// The number of units this character is made up of.\n///\n/// Is either 1 or 2 and identical to `.as_char().len_utf16()`\n/// or `.as_ref().len()`.\n#[inline]\npub fn len(self) -> usize{\n        1 + (self.units[1] as usize >> 15)\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::make_ascii_lowercase":["/// Converts the character to its ASCII lower case equivalent in-place.\n///\n/// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n/// but non-ASCII letters are unchanged.\n#[cfg(feature=\"std\")]\npub fn make_ascii_lowercase(&mut self){\n        *self = self.to_ascii_lowercase();\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::make_ascii_uppercase":["/// Converts the character to its ASCII upper case equivalent in-place.\n///\n/// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n/// but non-ASCII letters are unchanged.\n#[cfg(feature=\"std\")]\npub fn make_ascii_uppercase(&mut self){\n        *self = self.to_ascii_uppercase()\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::to_array":["/// Get the character represented as an array of two units.\n///\n/// The second `u16` is zero for codepoints that fit in one unit.\n#[inline]\npub fn to_array(self) -> [u16;2]{\n        self.units\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::to_ascii_lowercase":["/// Converts the character to its ASCII lower case equivalent.\n///\n/// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n/// but non-ASCII letters are unchanged.\n#[cfg(feature=\"std\")]\npub fn to_ascii_lowercase(&self) -> Self{\n        let n = self.units[0].wrapping_sub(b'A' as u16);\n        if n < 26 {Utf16Char{ units: [n+b'a' as u16, 0] }}\n        else      {*self}\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::to_ascii_uppercase":["/// Converts the character to its ASCII upper case equivalent.\n///\n/// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n/// but non-ASCII letters are unchanged.\n#[cfg(feature=\"std\")]\npub fn to_ascii_uppercase(&self) -> Self{\n        let n = self.units[0].wrapping_sub(b'a' as u16);\n        if n < 26 {Utf16Char{ units: [n+b'A' as u16, 0] }}\n        else      {*self}\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::to_char":["/// Convert from UTF-16 to UTF-32\npub fn to_char(self) -> char{\n        self.into()\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::to_slice":["/// Write the internal representation to a slice,\n/// and then returns the number of `u16`s written.\n///\n/// # Panics\n/// Will panic the buffer is too small;\n/// You can get the required length from `.len()`,\n/// but a buffer of length two is always large enough.\npub fn to_slice(self,  dst: &mut[u16]) -> usize{\n        // Write the last unit first to avoid repeated length checks.\n        let extra = self.units[1] as usize >> 15;\n        match dst.get_mut(extra) {\n            Some(first) => *first = self.units[extra],\n            None => panic!(\"The provided buffer is too small.\")\n        }\n        if extra != 0 {dst[0] = self.units[0];}\n        extra+1\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_char::Utf16Char::to_tuple":["/// The second `u16` is used for surrogate pairs.\n#[inline]\npub fn to_tuple(self) -> (u16,Option<u16>){\n        (self.units[0],  if self.units[1]==0 {None} else {Some(self.units[1])})\n    }","Real(LocalPath(\"src/utf16_char.rs\"))"],"utf16_iterators::Utf16CharIndices":["/// An iterator over the codepoints in a `str` represented as `Utf16Char`.\npub struct Utf16CharIndices<'a>{\n    str: &'a str,\n    index: usize,\n}","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"utf16_iterators::Utf16CharIndices::<'a>::as_str":["/// Extract the remainder of the source `str`.\n///\n/// # Examples\n///\n/// ```\n/// use encode_unicode::{StrExt, Utf16Char};\n/// let mut iter = \"abc\".utf16char_indices();\n/// assert_eq!(iter.next_back(), Some((2, Utf16Char::from('c'))));\n/// assert_eq!(iter.next(), Some((0, Utf16Char::from('a'))));\n/// assert_eq!(iter.as_str(), \"b\");\n/// ```\npub fn as_str(&self) -> &'a str{\n        &self.str[self.index..]\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"utf16_iterators::Utf16CharSplitter":["/// The iterator type returned by `iter_units()`\npub struct Utf16CharSplitter<U:Borrow<Utf16Char>, I:Iterator<Item=U>> {\n    inner: I,\n    prev_second: u16,\n}","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"utf16_iterators::Utf16CharSplitter::<U, I>::into_inner":["/// Extracts the source iterator.\n///\n/// Note that `iter_units(iter.into_inner())` is not a no-op:  \n/// If the last returned unit from `next()` was a leading surrogate,\n/// the trailing surrogate is lost.\npub fn into_inner(self) -> I{\n        self.inner\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"utf16_iterators::Utf16Chars":["/// An iterator over the codepoints in a `str` represented as `Utf16Char`.\npub struct Utf16Chars<'a>(Utf16CharIndices<'a>);","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"utf16_iterators::Utf16Chars::<'a>::as_str":["/// Extract the remainder of the source `str`.\n///\n/// # Examples\n///\n/// ```\n/// use encode_unicode::{StrExt, Utf16Char};\n/// let mut iter = \"abc\".utf16chars();\n/// assert_eq!(iter.next(), Some(Utf16Char::from('a')));\n/// assert_eq!(iter.next_back(), Some(Utf16Char::from('c')));\n/// assert_eq!(iter.as_str(), \"b\");\n/// ```\npub fn as_str(&self) -> &'a str{\n        self.0.as_str()\n    }","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"utf16_iterators::Utf16Iterator":["/// Iterate over the units of the UTF-16 representation of a codepoint.\npub struct Utf16Iterator {\n    first: u16,\n    second: u16,\n}","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"utf16_iterators::iter_units":["/// Converts an iterator of `Utf16Char` (or `&Utf16Char`)\n/// to an iterator of `u16`s.  \n/// Is equivalent to calling `.flat_map()` on the original iterator,\n/// but the returned iterator is about twice as fast.\n///\n/// The exact number of units cannot be known in advance, but `size_hint()`\n/// gives the possible range.\n///\n/// # Examples\n///\n/// From iterator of values:\n///\n/// ```\n/// use encode_unicode::{iter_units, CharExt};\n///\n/// let iterator = \"foo\".chars().map(|c| c.to_utf16() );\n/// let mut units = [0; 4];\n/// for (u,dst) in iter_units(iterator).zip(&mut units) {*dst=u;}\n/// assert_eq!(units, ['f' as u16, 'o' as u16, 'o' as u16, 0]);\n/// ```\n///\n/// From iterator of references:\n///\ndoc=\" ```\"\n/// use encode_unicode::{iter_units, CharExt, Utf16Char};\n///\n/// // (💣 takes two units)\n/// let chars: Vec<Utf16Char> = \"💣 bomb 💣\".chars().map(|c| c.to_utf16() ).collect();\n/// let units: Vec<u16> = iter_units(&chars).collect();\n/// let flat_map: Vec<u16> = chars.iter().flat_map(|u16c| *u16c ).collect();\n/// assert_eq!(units, flat_map);\n/// ```\npub fn iter_units<U:Borrow<Utf16Char>, I:IntoIterator<Item=U>>\n(iterable: I) -> Utf16CharSplitter<U, I::IntoIter>{\n    Utf16CharSplitter{ inner: iterable.into_iter(),  prev_second: 0 }\n}","Real(LocalPath(\"src/utf16_iterators.rs\"))"],"utf8_char::<impl std::cmp::PartialEq<utf8_char::Utf8Char> for char>::eq":["fn eq(&self,  u8c: &Utf8Char) -> bool{\n        Utf8Char::from(*self) == *u8c\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::<impl std::cmp::PartialOrd<utf8_char::Utf8Char> for char>::partial_cmp":["fn partial_cmp(&self,  u8c: &Utf8Char) -> Option<Ordering>{\n        Utf8Char::from(*self).partial_cmp(u8c)\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::<impl std::convert::From<utf8_char::Utf8Char> for char>::from":["fn from(uc: Utf8Char) -> char{\n        unsafe{ char::from_utf8_exact_slice_unchecked(&uc.bytes[..uc.len()]) }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::<impl std::iter::Extend<&'a utf8_char::Utf8Char> for std::string::String>::extend":["fn extend<I:IntoIterator<Item=&'a Utf8Char>>(&mut self,  iter: I){\n        self.extend(iter.into_iter().cloned())\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::<impl std::iter::Extend<&'a utf8_char::Utf8Char> for std::vec::Vec<u8>>::extend":["fn extend<I:IntoIterator<Item=&'a Utf8Char>>(&mut self,  iter: I){\n        self.extend(iter.into_iter().cloned())\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::<impl std::iter::Extend<utf8_char::Utf8Char> for std::string::String>::extend":["fn extend<I:IntoIterator<Item=Utf8Char>>(&mut self,  iter: I){\n        unsafe { self.as_mut_vec().extend(iter) }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::<impl std::iter::Extend<utf8_char::Utf8Char> for std::vec::Vec<u8>>::extend":["fn extend<I:IntoIterator<Item=Utf8Char>>(&mut self,  iter: I){\n        let iter = iter.into_iter();\n        self.reserve(iter.size_hint().0);\n        for u8c in iter {\n            // twice as fast as self.extend_from_slice(u8c.as_bytes());\n            self.push(u8c.bytes[0]);\n            for &extra in &u8c.bytes[1..] {\n                if extra != 0 {\n                    self.push(extra);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::<impl std::iter::FromIterator<&'a utf8_char::Utf8Char> for std::string::String>::from_iter":["fn from_iter<I:IntoIterator<Item=&'a Utf8Char>>(iter: I) -> String{\n        iter.into_iter().cloned().collect()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::<impl std::iter::FromIterator<&'a utf8_char::Utf8Char> for std::vec::Vec<u8>>::from_iter":["fn from_iter<I:IntoIterator<Item=&'a Utf8Char>>(iter: I) -> Self{\n        iter.into_iter().cloned().collect::<String>().into_bytes()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::<impl std::iter::FromIterator<utf8_char::Utf8Char> for std::string::String>::from_iter":["fn from_iter<I:IntoIterator<Item=Utf8Char>>(iter: I) -> String{\n        let mut string = String::new();\n        string.extend(iter);\n        return string;\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::<impl std::iter::FromIterator<utf8_char::Utf8Char> for std::vec::Vec<u8>>::from_iter":["fn from_iter<I:IntoIterator<Item=Utf8Char>>(iter: I) -> Self{\n        iter.into_iter().collect::<String>().into_bytes()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char":["/// An unicode codepoint stored as UTF-8.\n///\n/// It can be borrowed as a `str`, and has the same size as `char`.\npub struct Utf8Char {\n    bytes: [u8; 4],\n}","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::as_str":["/// Return a `str` view of the array the codepoint is stored as.\n///\n/// Is an unambiguous version of `.as_ref()`.\npub fn as_str(&self) -> &str{\n        self.deref()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::eq_ignore_ascii_case":["/// Checks that two characters are an ASCII case-insensitive match.\n///\n/// Is equivalent to `a.to_ascii_lowercase() == b.to_ascii_lowercase()`.\n#[cfg(feature=\"std\")]\npub fn eq_ignore_ascii_case(&self,  other: &Self) -> bool{\n        if self.is_ascii() {self.bytes[0].eq_ignore_ascii_case(&other.bytes[0])}\n        else               {self == other}\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::from_array":["/// Create an `Utf8Char` from a byte array after validating it.\n///\n/// The codepoint must start at the first byte.  \n/// Unused bytes are set to zero by this function and so can be anything.\n///\n/// # Errors\n///\n/// Returns an `Err` if the array doesn't start with a valid UTF-8 sequence.\n///\n/// # Examples\n///\n/// ```\n/// use encode_unicode::Utf8Char;\n/// use encode_unicode::error::InvalidUtf8Array::*;\n/// use encode_unicode::error::InvalidUtf8::*;\n/// use encode_unicode::error::InvalidCodepoint::*;\n///\n/// assert_eq!(Utf8Char::from_array([b'A', 0, 0, 0]), Ok(Utf8Char::from('A')));\n/// assert_eq!(Utf8Char::from_array([0xf4, 0x8b, 0xbb, 0xbb]), Ok(Utf8Char::from('\\u{10befb}')));\n/// assert_eq!(Utf8Char::from_array([b'A', b'B', b'C', b'D']), Ok(Utf8Char::from('A')));\n/// assert_eq!(Utf8Char::from_array([0, 0, 0xcc, 0xbb]), Ok(Utf8Char::from('\\0')));\n///\n/// assert_eq!(Utf8Char::from_array([0xef, b'F', 0x80, 0x80]), Err(Utf8(NotAContinuationByte(1))));\n/// assert_eq!(Utf8Char::from_array([0xc1, 0x80, 0, 0]), Err(Utf8(OverLong)));\n/// assert_eq!(Utf8Char::from_array([0xf7, 0xaa, 0x99, 0x88]), Err(Codepoint(TooHigh)));\n/// ```\npub fn from_array(utf8: [u8;4]) -> Result<Self,InvalidUtf8Array>{\n        unsafe {\n            // perform all validation\n            try!(char::from_utf8_array(utf8));\n            let extra = utf8[0].extra_utf8_bytes_unchecked() as u32;\n            // zero unused bytes in one operation by transmuting the arrary to\n            // u32, apply an endian-corrected mask and transmute back\n            let mask = u32::from_le(0xff_ff_ff_ff >> 8*(3-extra));\n            let unused_zeroed = mask  &  transmute::<_,u32>(utf8);\n            Ok(Utf8Char{ bytes: transmute(unused_zeroed) })\n        }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::from_array_unchecked":["/// Zero-cost constructor.\n///\n/// # Safety\n///\n/// Must contain a valid codepoint starting at the first byte, with the\n/// unused bytes zeroed.  \n/// Bad values can easily lead to undefined behavior.\n#[inline]\npub unsafe fn from_array_unchecked(utf8: [u8;4]) -> Self{\n        Utf8Char{ bytes: utf8 }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::from_ascii":["/// Create an `Utf8Char` from a single byte.\n///\n/// The byte must be an ASCII character.\n///\n/// # Errors\n///\n/// Returns `NonAsciiError` if the byte greater than 127.\n///\n/// # Examples\n///\n/// ```\n/// # use encode_unicode::Utf8Char;\n/// assert_eq!(Utf8Char::from_ascii(b'a').unwrap(), 'a');\n/// assert!(Utf8Char::from_ascii(128).is_err());\n/// ```\npub fn from_ascii(ascii: u8) -> Result<Self,NonAsciiError>{\n        if ascii as i8 >= 0 {\n            Ok(Utf8Char{ bytes: [ascii, 0, 0, 0] })\n        } else {\n            Err(NonAsciiError)\n        }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::from_ascii_unchecked":["/// Create an `Utf8Char` from a single byte without checking that it's a\n/// valid codepoint on its own, which is only true for ASCII characters.\n///\n/// # Safety\n///\n/// The byte must be less than 128.\n#[inline]\npub unsafe fn from_ascii_unchecked(ascii: u8) -> Self{\n        Utf8Char{ bytes: [ascii, 0, 0, 0] }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::from_slice_start":["/// Create an `Utf8Char` of the first codepoint in an UTF-8 slice.  \n/// Also returns the length of the UTF-8 sequence for the codepoint.\n///\n/// If the slice is from a `str`, use `::from_str_start()` to skip UTF-8 validation.\n///\n/// # Errors\n///\n/// Returns an `Err` if the slice is empty, doesn't start with a valid\n/// UTF-8 sequence or is too short for the sequence.\n///\n/// # Examples\n///\n/// ```\n/// use encode_unicode::Utf8Char;\n/// use encode_unicode::error::InvalidUtf8Slice::*;\n/// use encode_unicode::error::InvalidUtf8::*;\n///\n/// assert_eq!(Utf8Char::from_slice_start(&[b'A', b'B', b'C']), Ok((Utf8Char::from('A'),1)));\n/// assert_eq!(Utf8Char::from_slice_start(&[0xdd, 0xbb]), Ok((Utf8Char::from('\\u{77b}'),2)));\n///\n/// assert_eq!(Utf8Char::from_slice_start(&[]), Err(TooShort(1)));\n/// assert_eq!(Utf8Char::from_slice_start(&[0xf0, 0x99]), Err(TooShort(4)));\n/// assert_eq!(Utf8Char::from_slice_start(&[0xee, b'F', 0x80]), Err(Utf8(NotAContinuationByte(1))));\n/// assert_eq!(Utf8Char::from_slice_start(&[0xee, 0x99, 0x0f]), Err(Utf8(NotAContinuationByte(2))));\n/// ```\npub fn from_slice_start(src: &[u8]) -> Result<(Self,usize),InvalidUtf8Slice>{\n        char::from_utf8_slice_start(src).map(|(_,len)| {\n            let mut bytes = [0; 4];\n            bytes[..len].copy_from_slice(&src[..len]);\n            (Utf8Char{ bytes: bytes }, len)\n        })\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::from_slice_start_unchecked":["/// A `from_slice_start()` that doesn't validate the codepoint.\n///\n/// # Safety\n///\n/// The slice must be non-empty and start with a valid UTF-8 codepoint.  \n/// Invalid or incomplete values might cause reads of uninitalized memory.\npub unsafe fn from_slice_start_unchecked(src: &[u8]) -> (Self,usize){\n        let len = 1+src.get_unchecked(0).extra_utf8_bytes_unchecked();\n        let mut bytes = [0; 4];\n        ptr::copy_nonoverlapping(src.as_ptr(), &mut bytes[0] as *mut u8, len);\n        (Utf8Char{ bytes: bytes }, len)\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::from_str_start":["/// Create an `Utf8Char` from the first codepoint in a `str`.\n///\n/// Returns an error if the `str` is empty.\n///\n/// # Examples\n///\n/// ```\n/// use encode_unicode::Utf8Char;\n///\n/// assert_eq!(Utf8Char::from_str_start(\"a\"), Ok((Utf8Char::from('a'),1)));\n/// assert_eq!(Utf8Char::from_str_start(\"ab\"), Ok((Utf8Char::from('a'),1)));\n/// assert_eq!(Utf8Char::from_str_start(\"🂠 \"), Ok((Utf8Char::from('🂠'),4)));\n/// assert_eq!(Utf8Char::from_str_start(\"é\"), Ok((Utf8Char::from('e'),1)));// 'e'+u301 combining mark\n/// assert!(Utf8Char::from_str_start(\"\").is_err());\n/// ```\npub fn from_str_start(src: &str) -> Result<(Self,usize),EmptyStrError>{\n        unsafe {\n            if src.is_empty() {\n                Err(EmptyStrError)\n            } else {\n                Ok(Utf8Char::from_slice_start_unchecked(src.as_bytes()))\n            }\n        }\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::is_ascii":["/// Checks that the codepoint is an ASCII character.\npub fn is_ascii(&self) -> bool{\n        self.bytes[0] <= 127\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::len":["/// The number of bytes this character needs.\n///\n/// Is between 1 and 4 (inclusive) and identical to `.as_ref().len()` or\n/// `.as_char().len_utf8()`.\n#[inline]\npub fn len(self) -> usize{\n        // Invariants of the extra bytes enambles algorithms that\n        // `u8.extra_utf8_bytes_unchecked()` cannot use.\n        // Some of them turned out to require fewer x86 instructions:\n\n        // Exploits that unused bytes are zero and calculates the number of\n        // trailing zero bytes.\n        // Setting a bit in the first byte prevents the function from returning\n        // 0 for '\\0' (which has 32 leading zeros).\n        // trailing and leading is swapped below to optimize for little-endian\n        // architectures.\n        (4 - (u32::to_le(unsafe{transmute(self.bytes)})|1).leading_zeros()/8) as usize\n\n        // Exploits that the extra bytes have their most significant bit set if\n        // in use.\n        // Takes fewer instructions than the one above if popcnt can be used,\n        // (which it cannot by default,\n        //  set RUSTFLAGS='-C target-cpu=native' to enable)\n        //let all: u32 = unsafe{transmute(self.bytes)};\n        //let msb_mask = u32::from_be(0x00808080);\n        //let add_one = u32::from_be(0x80000000);\n        //((all & msb_mask) | add_one).count_ones() as usize\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::make_ascii_lowercase":["/// Converts the character to its ASCII lower case equivalent in-place.\n///\n/// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n/// but non-ASCII letters are unchanged.\n#[inline]\n#[cfg(feature=\"std\")]\npub fn make_ascii_lowercase(&mut self){\n        self.bytes[0].make_ascii_lowercase();\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::make_ascii_uppercase":["/// Converts the character to its ASCII upper case equivalent in-place.\n///\n/// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n/// but non-ASCII letters are unchanged.\n#[inline]\n#[cfg(feature=\"std\")]\npub fn make_ascii_uppercase(&mut self){\n        self.bytes[0].make_ascii_uppercase()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::to_array":["/// Expose the internal array and the number of used bytes.\npub fn to_array(self) -> ([u8;4],usize){\n        (self.bytes, self.len())\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::to_ascii_lowercase":["/// Converts the character to its ASCII lower case equivalent.\n///\n/// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n/// but non-ASCII letters are unchanged.\n#[cfg(feature=\"std\")]\npub fn to_ascii_lowercase(&self) -> Self{\n        let mut uc = *self;\n        uc.make_ascii_lowercase();\n        uc\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::to_ascii_uppercase":["/// Converts the character to its ASCII upper case equivalent.\n///\n/// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n/// but non-ASCII letters are unchanged.\n#[cfg(feature=\"std\")]\npub fn to_ascii_uppercase(&self) -> Self{\n        let mut uc = *self;\n        uc.make_ascii_uppercase();\n        uc\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::to_char":["/// Convert from UTF-8 to UTF-32\npub fn to_char(self) -> char{\n        self.into()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_char::Utf8Char::to_slice":["/// Write the internal representation to a slice,\n/// and then returns the number of bytes written.\n///\n/// # Panics\n///\n/// Will panic the buffer is too small;\n/// You can get the required length from `.len()`,\n/// but a buffer of length four is always large enough.\npub fn to_slice(self,  dst: &mut[u8]) -> usize{\n        if self.len() > dst.len() {\n            panic!(\"The provided buffer is too small.\");\n        }\n        dst[..self.len()].copy_from_slice(&self.bytes[..self.len()]);\n        self.len()\n    }","Real(LocalPath(\"src/utf8_char.rs\"))"],"utf8_iterators::Utf8CharIndices":["/// An iterator over the `Utf8Char` of a string slice, and their positions.\n///\n/// This struct is created by the `utf8char_indices() method from [`StrExt`] trait. See its documentation for more.\npub struct Utf8CharIndices<'a>{\n    str: &'a str,\n    index: usize,\n}","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"utf8_iterators::Utf8CharIndices::<'a>::as_str":["/// Extract the remainder of the source `str`.\n///\n/// # Examples\n///\n/// ```\n/// use encode_unicode::{StrExt, Utf8Char};\n/// let mut iter = \"abc\".utf8char_indices();\n/// assert_eq!(iter.next_back(), Some((2, Utf8Char::from('c'))));\n/// assert_eq!(iter.next(), Some((0, Utf8Char::from('a'))));\n/// assert_eq!(iter.as_str(), \"b\");\n/// ```\npub fn as_str(&self) -> &'a str{\n        &self.str[self.index..]\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"utf8_iterators::Utf8CharSplitter":["/// The iterator type returned by `iter_bytes()`\n///\n/// See its documentation for details.\npub struct Utf8CharSplitter<U:Borrow<Utf8Char>, I:Iterator<Item=U>> {\n    inner: I,\n    prev: u32,\n}","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"utf8_iterators::Utf8CharSplitter::<U, I>::into_inner":["/// Extracts the source iterator.\n///\n/// Note that `iter_bytes(iter.into_inner())` is not a no-op:  \n/// If the last returned byte from `next()` was not an ASCII by,\n/// the remaining bytes of that codepoint is lost.\npub fn into_inner(self) -> I{\n        self.inner\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"utf8_iterators::Utf8Chars":["/// An iterator over the codepoints in a `str` represented as `Utf8Char`.\npub struct Utf8Chars<'a>(Utf8CharIndices<'a>);","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"utf8_iterators::Utf8Chars::<'a>::as_str":["/// Extract the remainder of the source `str`.\n///\n/// # Examples\n///\n/// ```\n/// use encode_unicode::{StrExt, Utf8Char};\n/// let mut iter = \"abc\".utf8chars();\n/// assert_eq!(iter.next(), Some(Utf8Char::from('a')));\n/// assert_eq!(iter.next_back(), Some(Utf8Char::from('c')));\n/// assert_eq!(iter.as_str(), \"b\");\n/// ```\npub fn as_str(&self) -> &'a str{\n        self.0.as_str()\n    }","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"utf8_iterators::Utf8Iterator":["/// Read or iterate over the bytes of the UTF-8 representation of a codepoint.\npub struct Utf8Iterator (u32);","Real(LocalPath(\"src/utf8_iterators.rs\"))"],"utf8_iterators::iter_bytes":["/// Converts an iterator of `Utf8Char` (or `&Utf8Char`)\n/// to an iterator of `u8`s.  \n/// Is equivalent to calling `.flat_map()` on the original iterator,\n/// but the returned iterator is ~40% faster.\n///\n/// The iterator also implements `Read` (if the `std` feature isn't disabled).\n/// Reading will never produce an error, and calls to `.read()` and `.next()`\n/// can be mixed.\n///\n/// The exact number of bytes cannot be known in advance, but `size_hint()`\n/// gives the possible range.\n/// (min: all remaining characters are ASCII, max: all require four bytes)\n///\n/// # Examples\n///\n/// From iterator of values:\n///\n/// ```\n/// use encode_unicode::{iter_bytes, CharExt};\n///\n/// let iterator = \"foo\".chars().map(|c| c.to_utf8() );\n/// let mut bytes = [0; 4];\n/// for (u,dst) in iter_bytes(iterator).zip(&mut bytes) {*dst=u;}\n/// assert_eq!(&bytes, b\"foo\\0\");\n/// ```\n///\n/// From iterator of references:\n///\ndoc=\" ```\"\n/// use encode_unicode::{iter_bytes, CharExt, Utf8Char};\n///\n/// let chars: Vec<Utf8Char> = \"💣 bomb 💣\".chars().map(|c| c.to_utf8() ).collect();\n/// let bytes: Vec<u8> = iter_bytes(&chars).collect();\n/// let flat_map: Vec<u8> = chars.iter().flat_map(|u8c| *u8c ).collect();\n/// assert_eq!(bytes, flat_map);\n/// ```\n///\n/// `Read`ing from it:\n///\ndoc=\" ```\"\n/// use encode_unicode::{iter_bytes, CharExt};\n/// use std::io::Read;\n///\n/// let s = \"Ååh‽\";\n/// assert_eq!(s.len(), 8);\n/// let mut buf = [b'E'; 9];\n/// let mut reader = iter_bytes(s.chars().map(|c| c.to_utf8() ));\n/// assert_eq!(reader.read(&mut buf[..]).unwrap(), 8);\n/// assert_eq!(reader.read(&mut buf[..]).unwrap(), 0);\n/// assert_eq!(&buf[..8], s.as_bytes());\n/// assert_eq!(buf[8], b'E');\n/// ```\npub fn iter_bytes<U:Borrow<Utf8Char>, I:IntoIterator<Item=U>>\n(iterable: I) -> Utf8CharSplitter<U, I::IntoIter>{\n    Utf8CharSplitter{ inner: iterable.into_iter(),  prev: 0 }\n}","Real(LocalPath(\"src/utf8_iterators.rs\"))"]},"struct_constructor":{"&'a [u8]":["as_slice"],"&'a str":["as_str"],"&'static str":["description"],"&<utf8_char::Utf8Char as std::ops::Deref>::Target":["deref"],"&[u16]":["as_ref","as_slice","borrow","deref"],"&[u8]":["as_ref","borrow"],"&dyn std::error::Error":["cause"],"&str":["as_ref","as_str","borrow"],"(Self, usize)":["from_utf16_slice_start","from_utf8_slice_start"],"([u8; 4], usize)":["to_array","to_utf8_array"],"(char, usize)":["from_utf16_slice_start","from_utf8_slice_start"],"(u16, std::option::Option<u16>)":["to_tuple","to_utf16_tuple"],"(u32, u32)":["error_range"],"(usize, std::option::Option<usize>)":["size_hint"],"(usize, utf16_char::Utf16Char)":["next","next_back"],"(usize, utf8_char::Utf8Char)":["next","next_back"],"(utf16_char::Utf16Char, usize)":["from_slice_start","from_slice_start_unchecked","from_str_start"],"(utf8_char::Utf8Char, usize)":["from_slice_start","from_slice_start_unchecked","from_str_start"],"<decoding_iterators::Utf16CharDecoder<'a> as std::iter::Iterator>::Item":["next"],"<decoding_iterators::Utf16CharMerger<B, I> as std::iter::Iterator>::Item":["next"],"<decoding_iterators::Utf8CharDecoder<'a> as std::iter::Iterator>::Item":["next","next_back"],"<decoding_iterators::Utf8CharMerger<B, I> as std::iter::Iterator>::Item":["next"],"<utf16_iterators::Utf16CharSplitter<U, I> as std::iter::Iterator>::Item":["next"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::Owned":["to_ascii_lowercase","to_ascii_uppercase"],"<utf8_iterators::Utf8CharSplitter<U, I> as std::iter::Iterator>::Item":["next"],"[u16; 2]":["to_array","to_utf16_array"],"bool":["eq","eq_ignore_ascii_case","is_ascii","is_bmp","is_utf16_leading_surrogate","overlong","utf16_needs_extra_unit"],"char":["combine_surrogates","from","from_u32_detailed","from_utf16_array","from_utf16_array_unchecked","from_utf16_tuple","from_utf16_tuple_unchecked","from_utf8_array","from_utf8_exact_slice_unchecked","to_char"],"decoding_iterators::Utf16CharDecoder":["clone","default","from","utf16char_indices"],"decoding_iterators::Utf16CharMerger":["clone","default","from","to_utf16chars"],"decoding_iterators::Utf8CharDecoder":["clone","default","from","utf8char_indices"],"decoding_iterators::Utf8CharMerger":["clone","default","from","to_utf8chars"],"errors::EmptyStrError":["clone"],"errors::FromStrError":["clone"],"errors::InvalidCodepoint":["clone"],"errors::InvalidUtf16Array":["clone"],"errors::InvalidUtf16FirstUnit":["clone"],"errors::InvalidUtf16Slice":["clone"],"errors::InvalidUtf16Tuple":["clone"],"errors::InvalidUtf8":["clone","from"],"errors::InvalidUtf8Array":["clone","from"],"errors::InvalidUtf8FirstByte":["clone"],"errors::InvalidUtf8Slice":["clone","from"],"errors::NonAsciiError":["clone"],"errors::NonBMPError":["clone"],"errors::Utf16PairError":["clone"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::iter::Chain":["into_remaining_units"],"std::string::String":["from_iter"],"std::vec::Vec":["from_iter"],"u16":["next"],"u32":["merge_nonascii_unchecked_utf8"],"u8":["next"],"usize":["extra_utf8_bytes","extra_utf8_bytes_unchecked","len","read","to_slice"],"utf16_char::Utf16Char":["clone","default","from","from_array","from_array_unchecked","from_bmp","from_bmp_unchecked","from_str","from_tuple","from_tuple_unchecked","next","next_back","to_ascii_lowercase","to_ascii_uppercase","to_utf16"],"utf16_iterators::Utf16CharIndices":["clone","from","utf16char_indices"],"utf16_iterators::Utf16CharSplitter":["clone","from","iter_units","to_units"],"utf16_iterators::Utf16Chars":["clone","from","utf16chars"],"utf16_iterators::Utf16Iterator":["clone","from","into_iter","iter_utf16_units"],"utf8_char::Utf8Char":["clone","default","from","from_array","from_array_unchecked","from_ascii","from_ascii_unchecked","from_str","next","next_back","to_ascii_lowercase","to_ascii_uppercase","to_utf8"],"utf8_iterators::Utf8CharIndices":["clone","from","utf8char_indices"],"utf8_iterators::Utf8CharSplitter":["clone","from","iter_bytes","to_bytes"],"utf8_iterators::Utf8Chars":["clone","from","utf8chars"],"utf8_iterators::Utf8Iterator":["clone","from","into_iter","iter_utf8_bytes"]},"struct_to_trait":{"<I as traits::IterExt>::I":["traits::IterExt"],"<S as traits::SliceExt>::S":["traits::SliceExt"],"decoding_iterators::Utf16CharDecoder":["std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug","std::iter::Iterator"],"decoding_iterators::Utf16CharMerger":["std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug","std::iter::Iterator"],"decoding_iterators::Utf8CharDecoder":["std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"decoding_iterators::Utf8CharMerger":["std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug","std::iter::Iterator"],"errors::EmptyStrError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::FromStrError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::InvalidCodepoint":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::InvalidUtf16Array":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::InvalidUtf16FirstUnit":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::InvalidUtf16Slice":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::InvalidUtf16Tuple":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::InvalidUtf8":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::InvalidUtf8Array":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::InvalidUtf8FirstByte":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::InvalidUtf8Slice":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::NonAsciiError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::NonBMPError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"errors::Utf16PairError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"std::string::String":["std::iter::Extend","std::iter::FromIterator"],"std::vec::Vec":["std::iter::Extend","std::iter::FromIterator"],"utf16_char::Utf16Char":["std::ascii::AsciiExt","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::iter::IntoIterator","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref","std::str::FromStr"],"utf16_iterators::Utf16CharIndices":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"utf16_iterators::Utf16CharSplitter":["std::clone::Clone","std::convert::From","std::iter::Iterator"],"utf16_iterators::Utf16Chars":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"utf16_iterators::Utf16Iterator":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::iter::ExactSizeIterator","std::iter::Iterator"],"utf8_char::Utf8Char":["std::ascii::AsciiExt","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::iter::IntoIterator","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref","std::str::FromStr"],"utf8_iterators::Utf8CharIndices":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"utf8_iterators::Utf8CharSplitter":["std::clone::Clone","std::convert::From","std::io::Read","std::iter::Iterator"],"utf8_iterators::Utf8Chars":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"utf8_iterators::Utf8Iterator":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::io::Read","std::iter::ExactSizeIterator","std::iter::Iterator"]},"targets":{"<I as traits::IterExt>::to_bytes":["to_bytes","Real(LocalPath(\"src/traits.rs\"))","traits::IterExt"],"<I as traits::IterExt>::to_units":["to_units","Real(LocalPath(\"src/traits.rs\"))","traits::IterExt"],"<I as traits::IterExt>::to_utf16chars":["to_utf16chars","Real(LocalPath(\"src/traits.rs\"))","traits::IterExt"],"<I as traits::IterExt>::to_utf8chars":["to_utf8chars","Real(LocalPath(\"src/traits.rs\"))","traits::IterExt"],"<S as traits::SliceExt>::utf16char_indices":["utf16char_indices","Real(LocalPath(\"src/traits.rs\"))","traits::SliceExt"],"<S as traits::SliceExt>::utf8char_indices":["utf8char_indices","Real(LocalPath(\"src/traits.rs\"))","traits::SliceExt"],"<char as traits::CharExt>::from_u32_detailed":["from_u32_detailed","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::from_utf16_array":["from_utf16_array","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::from_utf16_array_unchecked":["from_utf16_array_unchecked","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::from_utf16_slice_start":["from_utf16_slice_start","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::from_utf16_tuple":["from_utf16_tuple","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::from_utf16_tuple_unchecked":["from_utf16_tuple_unchecked","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::from_utf8_array":["from_utf8_array","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::from_utf8_exact_slice_unchecked":["from_utf8_exact_slice_unchecked","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::from_utf8_slice_start":["from_utf8_slice_start","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::iter_utf16_units":["iter_utf16_units","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::iter_utf8_bytes":["iter_utf8_bytes","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::to_utf16":["to_utf16","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::to_utf16_array":["to_utf16_array","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::to_utf16_tuple":["to_utf16_tuple","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::to_utf8":["to_utf8","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<char as traits::CharExt>::to_utf8_array":["to_utf8_array","Real(LocalPath(\"src/traits.rs\"))","traits::CharExt"],"<decoding_iterators::Utf16CharDecoder<'a> as std::convert::From<&'a [u16]>>::from":["from","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::convert::From"],"<decoding_iterators::Utf16CharDecoder<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::fmt::Debug"],"<decoding_iterators::Utf16CharDecoder<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::iter::Iterator"],"<decoding_iterators::Utf16CharDecoder<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::iter::Iterator"],"<decoding_iterators::Utf16CharMerger<B, I> as std::convert::From<T>>::from":["from","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::convert::From"],"<decoding_iterators::Utf16CharMerger<B, I> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::fmt::Debug"],"<decoding_iterators::Utf16CharMerger<B, I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::iter::Iterator"],"<decoding_iterators::Utf16CharMerger<B, I> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::iter::Iterator"],"<decoding_iterators::Utf8CharDecoder<'a> as std::convert::From<&'a [u8]>>::from":["from","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::convert::From"],"<decoding_iterators::Utf8CharDecoder<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::fmt::Debug"],"<decoding_iterators::Utf8CharDecoder<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::iter::DoubleEndedIterator"],"<decoding_iterators::Utf8CharDecoder<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::iter::Iterator"],"<decoding_iterators::Utf8CharDecoder<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::iter::Iterator"],"<decoding_iterators::Utf8CharMerger<B, I> as std::convert::From<T>>::from":["from","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::convert::From"],"<decoding_iterators::Utf8CharMerger<B, I> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::fmt::Debug"],"<decoding_iterators::Utf8CharMerger<B, I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::iter::Iterator"],"<decoding_iterators::Utf8CharMerger<B, I> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/decoding_iterators.rs\"))","std::iter::Iterator"],"<errors::EmptyStrError as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::EmptyStrError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::FromStrError as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::FromStrError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::InvalidCodepoint as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidCodepoint as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::InvalidUtf16Array as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidUtf16Array as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::InvalidUtf16FirstUnit as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidUtf16FirstUnit as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::InvalidUtf16Slice as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidUtf16Slice as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::InvalidUtf16Tuple as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidUtf16Tuple as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::InvalidUtf8 as std::convert::From<errors::InvalidUtf8FirstByte>>::from":["from","Real(LocalPath(\"src/errors.rs\"))","std::convert::From"],"<errors::InvalidUtf8 as std::error::Error>::cause":["cause","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidUtf8 as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidUtf8 as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::InvalidUtf8Array as std::convert::From<errors::InvalidCodepoint>>::from":["from","Real(LocalPath(\"src/errors.rs\"))","std::convert::From"],"<errors::InvalidUtf8Array as std::convert::From<errors::InvalidUtf8>>::from":["from","Real(LocalPath(\"src/errors.rs\"))","std::convert::From"],"<errors::InvalidUtf8Array as std::error::Error>::cause":["cause","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidUtf8Array as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidUtf8Array as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::InvalidUtf8FirstByte as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidUtf8FirstByte as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::InvalidUtf8Slice as std::convert::From<errors::InvalidCodepoint>>::from":["from","Real(LocalPath(\"src/errors.rs\"))","std::convert::From"],"<errors::InvalidUtf8Slice as std::convert::From<errors::InvalidUtf8>>::from":["from","Real(LocalPath(\"src/errors.rs\"))","std::convert::From"],"<errors::InvalidUtf8Slice as std::error::Error>::cause":["cause","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidUtf8Slice as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::InvalidUtf8Slice as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::NonAsciiError as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::NonAsciiError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::NonBMPError as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::NonBMPError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<errors::Utf16PairError as std::error::Error>::description":["description","Real(LocalPath(\"src/errors.rs\"))","std::error::Error"],"<errors::Utf16PairError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/errors.rs\"))","std::fmt::Display"],"<str as traits::StrExt>::utf16char_indices":["utf16char_indices","Real(LocalPath(\"src/traits.rs\"))","traits::StrExt"],"<str as traits::StrExt>::utf16chars":["utf16chars","Real(LocalPath(\"src/traits.rs\"))","traits::StrExt"],"<str as traits::StrExt>::utf8char_indices":["utf8char_indices","Real(LocalPath(\"src/traits.rs\"))","traits::StrExt"],"<str as traits::StrExt>::utf8chars":["utf8chars","Real(LocalPath(\"src/traits.rs\"))","traits::StrExt"],"<u16 as traits::U16UtfExt>::is_utf16_leading_surrogate":["is_utf16_leading_surrogate","Real(LocalPath(\"src/traits.rs\"))","traits::U16UtfExt"],"<u16 as traits::U16UtfExt>::utf16_needs_extra_unit":["utf16_needs_extra_unit","Real(LocalPath(\"src/traits.rs\"))","traits::U16UtfExt"],"<u8 as traits::U8UtfExt>::extra_utf8_bytes":["extra_utf8_bytes","Real(LocalPath(\"src/traits.rs\"))","traits::U8UtfExt"],"<u8 as traits::U8UtfExt>::extra_utf8_bytes_unchecked":["extra_utf8_bytes_unchecked","Real(LocalPath(\"src/traits.rs\"))","traits::U8UtfExt"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::eq_ignore_ascii_case":["eq_ignore_ascii_case","Real(LocalPath(\"src/utf16_char.rs\"))","std::ascii::AsciiExt"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::is_ascii":["is_ascii","Real(LocalPath(\"src/utf16_char.rs\"))","std::ascii::AsciiExt"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::make_ascii_lowercase":["make_ascii_lowercase","Real(LocalPath(\"src/utf16_char.rs\"))","std::ascii::AsciiExt"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::make_ascii_uppercase":["make_ascii_uppercase","Real(LocalPath(\"src/utf16_char.rs\"))","std::ascii::AsciiExt"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::to_ascii_lowercase":["to_ascii_lowercase","Real(LocalPath(\"src/utf16_char.rs\"))","std::ascii::AsciiExt"],"<utf16_char::Utf16Char as std::ascii::AsciiExt>::to_ascii_uppercase":["to_ascii_uppercase","Real(LocalPath(\"src/utf16_char.rs\"))","std::ascii::AsciiExt"],"<utf16_char::Utf16Char as std::borrow::Borrow<[u16]>>::borrow":["borrow","Real(LocalPath(\"src/utf16_char.rs\"))","std::borrow::Borrow"],"<utf16_char::Utf16Char as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/utf16_char.rs\"))","std::cmp::Ord"],"<utf16_char::Utf16Char as std::cmp::PartialEq<char>>::eq":["eq","Real(LocalPath(\"src/utf16_char.rs\"))","std::cmp::PartialEq"],"<utf16_char::Utf16Char as std::cmp::PartialEq<u16>>::eq":["eq","Real(LocalPath(\"src/utf16_char.rs\"))","std::cmp::PartialEq"],"<utf16_char::Utf16Char as std::cmp::PartialEq<u8>>::eq":["eq","Real(LocalPath(\"src/utf16_char.rs\"))","std::cmp::PartialEq"],"<utf16_char::Utf16Char as std::cmp::PartialEq<utf8_char::Utf8Char>>::eq":["eq","Real(LocalPath(\"src/utf16_char.rs\"))","std::cmp::PartialEq"],"<utf16_char::Utf16Char as std::cmp::PartialOrd<char>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/utf16_char.rs\"))","std::cmp::PartialOrd"],"<utf16_char::Utf16Char as std::cmp::PartialOrd<utf8_char::Utf8Char>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/utf16_char.rs\"))","std::cmp::PartialOrd"],"<utf16_char::Utf16Char as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/utf16_char.rs\"))","std::cmp::PartialOrd"],"<utf16_char::Utf16Char as std::convert::AsRef<[u16]>>::as_ref":["as_ref","Real(LocalPath(\"src/utf16_char.rs\"))","std::convert::AsRef"],"<utf16_char::Utf16Char as std::convert::From<char>>::from":["from","Real(LocalPath(\"src/utf16_char.rs\"))","std::convert::From"],"<utf16_char::Utf16Char as std::convert::From<utf8_char::Utf8Char>>::from":["from","Real(LocalPath(\"src/utf16_char.rs\"))","std::convert::From"],"<utf16_char::Utf16Char as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf16_char.rs\"))","std::fmt::Debug"],"<utf16_char::Utf16Char as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/utf16_char.rs\"))","std::fmt::Display"],"<utf16_char::Utf16Char as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/utf16_char.rs\"))","std::hash::Hash"],"<utf16_char::Utf16Char as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/utf16_char.rs\"))","std::iter::IntoIterator"],"<utf16_char::Utf16Char as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/utf16_char.rs\"))","std::ops::Deref"],"<utf16_char::Utf16Char as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/utf16_char.rs\"))","std::str::FromStr"],"<utf16_iterators::Utf16CharIndices<'a> as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::convert::From"],"<utf16_iterators::Utf16CharIndices<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::fmt::Debug"],"<utf16_iterators::Utf16CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::iter::DoubleEndedIterator"],"<utf16_iterators::Utf16CharIndices<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::iter::Iterator"],"<utf16_iterators::Utf16CharIndices<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::iter::Iterator"],"<utf16_iterators::Utf16CharSplitter<U, I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::iter::Iterator"],"<utf16_iterators::Utf16CharSplitter<U, I> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::iter::Iterator"],"<utf16_iterators::Utf16CharSplitter<utf16_char::Utf16Char, I> as std::convert::From<I>>::from":["from","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::convert::From"],"<utf16_iterators::Utf16Chars<'a> as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::convert::From"],"<utf16_iterators::Utf16Chars<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::fmt::Debug"],"<utf16_iterators::Utf16Chars<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::iter::DoubleEndedIterator"],"<utf16_iterators::Utf16Chars<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::iter::Iterator"],"<utf16_iterators::Utf16Chars<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::iter::Iterator"],"<utf16_iterators::Utf16Iterator as std::convert::From<char>>::from":["from","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::convert::From"],"<utf16_iterators::Utf16Iterator as std::convert::From<utf16_char::Utf16Char>>::from":["from","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::convert::From"],"<utf16_iterators::Utf16Iterator as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::fmt::Debug"],"<utf16_iterators::Utf16Iterator as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::iter::ExactSizeIterator"],"<utf16_iterators::Utf16Iterator as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::iter::Iterator"],"<utf16_iterators::Utf16Iterator as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/utf16_iterators.rs\"))","std::iter::Iterator"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::eq_ignore_ascii_case":["eq_ignore_ascii_case","Real(LocalPath(\"src/utf8_char.rs\"))","std::ascii::AsciiExt"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::is_ascii":["is_ascii","Real(LocalPath(\"src/utf8_char.rs\"))","std::ascii::AsciiExt"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::make_ascii_lowercase":["make_ascii_lowercase","Real(LocalPath(\"src/utf8_char.rs\"))","std::ascii::AsciiExt"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::make_ascii_uppercase":["make_ascii_uppercase","Real(LocalPath(\"src/utf8_char.rs\"))","std::ascii::AsciiExt"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::to_ascii_lowercase":["to_ascii_lowercase","Real(LocalPath(\"src/utf8_char.rs\"))","std::ascii::AsciiExt"],"<utf8_char::Utf8Char as std::ascii::AsciiExt>::to_ascii_uppercase":["to_ascii_uppercase","Real(LocalPath(\"src/utf8_char.rs\"))","std::ascii::AsciiExt"],"<utf8_char::Utf8Char as std::borrow::Borrow<[u8]>>::borrow":["borrow","Real(LocalPath(\"src/utf8_char.rs\"))","std::borrow::Borrow"],"<utf8_char::Utf8Char as std::borrow::Borrow<str>>::borrow":["borrow","Real(LocalPath(\"src/utf8_char.rs\"))","std::borrow::Borrow"],"<utf8_char::Utf8Char as std::cmp::PartialEq<char>>::eq":["eq","Real(LocalPath(\"src/utf8_char.rs\"))","std::cmp::PartialEq"],"<utf8_char::Utf8Char as std::cmp::PartialEq<u8>>::eq":["eq","Real(LocalPath(\"src/utf8_char.rs\"))","std::cmp::PartialEq"],"<utf8_char::Utf8Char as std::cmp::PartialEq<utf16_char::Utf16Char>>::eq":["eq","Real(LocalPath(\"src/utf8_char.rs\"))","std::cmp::PartialEq"],"<utf8_char::Utf8Char as std::cmp::PartialOrd<char>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/utf8_char.rs\"))","std::cmp::PartialOrd"],"<utf8_char::Utf8Char as std::cmp::PartialOrd<utf16_char::Utf16Char>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/utf8_char.rs\"))","std::cmp::PartialOrd"],"<utf8_char::Utf8Char as std::convert::AsRef<[u8]>>::as_ref":["as_ref","Real(LocalPath(\"src/utf8_char.rs\"))","std::convert::AsRef"],"<utf8_char::Utf8Char as std::convert::AsRef<str>>::as_ref":["as_ref","Real(LocalPath(\"src/utf8_char.rs\"))","std::convert::AsRef"],"<utf8_char::Utf8Char as std::convert::From<char>>::from":["from","Real(LocalPath(\"src/utf8_char.rs\"))","std::convert::From"],"<utf8_char::Utf8Char as std::convert::From<utf16_char::Utf16Char>>::from":["from","Real(LocalPath(\"src/utf8_char.rs\"))","std::convert::From"],"<utf8_char::Utf8Char as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf8_char.rs\"))","std::fmt::Debug"],"<utf8_char::Utf8Char as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/utf8_char.rs\"))","std::fmt::Display"],"<utf8_char::Utf8Char as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/utf8_char.rs\"))","std::hash::Hash"],"<utf8_char::Utf8Char as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/utf8_char.rs\"))","std::iter::IntoIterator"],"<utf8_char::Utf8Char as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/utf8_char.rs\"))","std::ops::Deref"],"<utf8_char::Utf8Char as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/utf8_char.rs\"))","std::str::FromStr"],"<utf8_iterators::Utf8CharIndices<'a> as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::convert::From"],"<utf8_iterators::Utf8CharIndices<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::fmt::Debug"],"<utf8_iterators::Utf8CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::iter::DoubleEndedIterator"],"<utf8_iterators::Utf8CharIndices<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::iter::Iterator"],"<utf8_iterators::Utf8CharIndices<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::iter::Iterator"],"<utf8_iterators::Utf8CharSplitter<U, I> as std::io::Read>::read":["read","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::io::Read"],"<utf8_iterators::Utf8CharSplitter<U, I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::iter::Iterator"],"<utf8_iterators::Utf8CharSplitter<U, I> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::iter::Iterator"],"<utf8_iterators::Utf8CharSplitter<utf8_char::Utf8Char, I> as std::convert::From<I>>::from":["from","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::convert::From"],"<utf8_iterators::Utf8Chars<'a> as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::convert::From"],"<utf8_iterators::Utf8Chars<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::fmt::Debug"],"<utf8_iterators::Utf8Chars<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::iter::DoubleEndedIterator"],"<utf8_iterators::Utf8Chars<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::iter::Iterator"],"<utf8_iterators::Utf8Chars<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::iter::Iterator"],"<utf8_iterators::Utf8Iterator as std::convert::From<char>>::from":["from","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::convert::From"],"<utf8_iterators::Utf8Iterator as std::convert::From<utf8_char::Utf8Char>>::from":["from","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::convert::From"],"<utf8_iterators::Utf8Iterator as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::fmt::Debug"],"<utf8_iterators::Utf8Iterator as std::io::Read>::read":["read","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::io::Read"],"<utf8_iterators::Utf8Iterator as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::iter::ExactSizeIterator"],"<utf8_iterators::Utf8Iterator as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::iter::Iterator"],"<utf8_iterators::Utf8Iterator as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/utf8_iterators.rs\"))","std::iter::Iterator"],"decoding_iterators::Utf16CharDecoder::<'a>::as_slice":["as_slice","Real(LocalPath(\"src/decoding_iterators.rs\"))",""],"decoding_iterators::Utf16CharMerger::<B, I>::into_inner":["into_inner","Real(LocalPath(\"src/decoding_iterators.rs\"))",""],"decoding_iterators::Utf16CharMerger::<B, I>::into_remaining_units":["into_remaining_units","Real(LocalPath(\"src/decoding_iterators.rs\"))",""],"decoding_iterators::Utf8CharDecoder::<'a>::as_slice":["as_slice","Real(LocalPath(\"src/decoding_iterators.rs\"))",""],"decoding_iterators::Utf8CharMerger::<B, I>::extra":["extra","Real(LocalPath(\"src/decoding_iterators.rs\"))",""],"decoding_iterators::Utf8CharMerger::<B, I>::into_inner":["into_inner","Real(LocalPath(\"src/decoding_iterators.rs\"))",""],"decoding_iterators::Utf8CharMerger::<B, I>::save":["save","Real(LocalPath(\"src/decoding_iterators.rs\"))",""],"errors::InvalidCodepoint::error_range":["error_range","Real(LocalPath(\"src/errors.rs\"))",""],"traits::combine_surrogates":["combine_surrogates","Real(LocalPath(\"src/traits.rs\"))",""],"traits::merge_nonascii_unchecked_utf8":["merge_nonascii_unchecked_utf8","Real(LocalPath(\"src/traits.rs\"))",""],"traits::overlong":["overlong","Real(LocalPath(\"src/traits.rs\"))",""],"utf16_char::<impl std::cmp::PartialEq<utf16_char::Utf16Char> for char>::eq":["eq","Real(LocalPath(\"src/utf16_char.rs\"))","std::cmp::PartialEq"],"utf16_char::<impl std::cmp::PartialOrd<utf16_char::Utf16Char> for char>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/utf16_char.rs\"))","std::cmp::PartialOrd"],"utf16_char::<impl std::convert::From<utf16_char::Utf16Char> for char>::from":["from","Real(LocalPath(\"src/utf16_char.rs\"))","std::convert::From"],"utf16_char::<impl std::iter::Extend<&'a utf16_char::Utf16Char> for std::string::String>::extend":["extend","Real(LocalPath(\"src/utf16_char.rs\"))","std::iter::Extend"],"utf16_char::<impl std::iter::Extend<&'a utf16_char::Utf16Char> for std::vec::Vec<u16>>::extend":["extend","Real(LocalPath(\"src/utf16_char.rs\"))","std::iter::Extend"],"utf16_char::<impl std::iter::Extend<utf16_char::Utf16Char> for std::string::String>::extend":["extend","Real(LocalPath(\"src/utf16_char.rs\"))","std::iter::Extend"],"utf16_char::<impl std::iter::Extend<utf16_char::Utf16Char> for std::vec::Vec<u16>>::extend":["extend","Real(LocalPath(\"src/utf16_char.rs\"))","std::iter::Extend"],"utf16_char::<impl std::iter::FromIterator<&'a utf16_char::Utf16Char> for std::string::String>::from_iter":["from_iter","Real(LocalPath(\"src/utf16_char.rs\"))","std::iter::FromIterator"],"utf16_char::<impl std::iter::FromIterator<&'a utf16_char::Utf16Char> for std::vec::Vec<u16>>::from_iter":["from_iter","Real(LocalPath(\"src/utf16_char.rs\"))","std::iter::FromIterator"],"utf16_char::<impl std::iter::FromIterator<utf16_char::Utf16Char> for std::string::String>::from_iter":["from_iter","Real(LocalPath(\"src/utf16_char.rs\"))","std::iter::FromIterator"],"utf16_char::<impl std::iter::FromIterator<utf16_char::Utf16Char> for std::vec::Vec<u16>>::from_iter":["from_iter","Real(LocalPath(\"src/utf16_char.rs\"))","std::iter::FromIterator"],"utf16_char::Utf16Char::eq_ignore_ascii_case":["eq_ignore_ascii_case","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::from_array":["from_array","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::from_array_unchecked":["from_array_unchecked","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::from_bmp":["from_bmp","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::from_bmp_unchecked":["from_bmp_unchecked","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::from_slice_start":["from_slice_start","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::from_slice_start_unchecked":["from_slice_start_unchecked","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::from_str_start":["from_str_start","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::from_tuple":["from_tuple","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::from_tuple_unchecked":["from_tuple_unchecked","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::is_ascii":["is_ascii","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::is_bmp":["is_bmp","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::len":["len","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::make_ascii_lowercase":["make_ascii_lowercase","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::make_ascii_uppercase":["make_ascii_uppercase","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::to_array":["to_array","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::to_ascii_lowercase":["to_ascii_lowercase","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::to_ascii_uppercase":["to_ascii_uppercase","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::to_char":["to_char","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::to_slice":["to_slice","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_char::Utf16Char::to_tuple":["to_tuple","Real(LocalPath(\"src/utf16_char.rs\"))",""],"utf16_iterators::Utf16CharIndices::<'a>::as_str":["as_str","Real(LocalPath(\"src/utf16_iterators.rs\"))",""],"utf16_iterators::Utf16CharSplitter::<U, I>::into_inner":["into_inner","Real(LocalPath(\"src/utf16_iterators.rs\"))",""],"utf16_iterators::Utf16Chars::<'a>::as_str":["as_str","Real(LocalPath(\"src/utf16_iterators.rs\"))",""],"utf16_iterators::iter_units":["iter_units","Real(LocalPath(\"src/utf16_iterators.rs\"))",""],"utf8_char::<impl std::cmp::PartialEq<utf8_char::Utf8Char> for char>::eq":["eq","Real(LocalPath(\"src/utf8_char.rs\"))","std::cmp::PartialEq"],"utf8_char::<impl std::cmp::PartialOrd<utf8_char::Utf8Char> for char>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/utf8_char.rs\"))","std::cmp::PartialOrd"],"utf8_char::<impl std::convert::From<utf8_char::Utf8Char> for char>::from":["from","Real(LocalPath(\"src/utf8_char.rs\"))","std::convert::From"],"utf8_char::<impl std::iter::Extend<&'a utf8_char::Utf8Char> for std::string::String>::extend":["extend","Real(LocalPath(\"src/utf8_char.rs\"))","std::iter::Extend"],"utf8_char::<impl std::iter::Extend<&'a utf8_char::Utf8Char> for std::vec::Vec<u8>>::extend":["extend","Real(LocalPath(\"src/utf8_char.rs\"))","std::iter::Extend"],"utf8_char::<impl std::iter::Extend<utf8_char::Utf8Char> for std::string::String>::extend":["extend","Real(LocalPath(\"src/utf8_char.rs\"))","std::iter::Extend"],"utf8_char::<impl std::iter::Extend<utf8_char::Utf8Char> for std::vec::Vec<u8>>::extend":["extend","Real(LocalPath(\"src/utf8_char.rs\"))","std::iter::Extend"],"utf8_char::<impl std::iter::FromIterator<&'a utf8_char::Utf8Char> for std::string::String>::from_iter":["from_iter","Real(LocalPath(\"src/utf8_char.rs\"))","std::iter::FromIterator"],"utf8_char::<impl std::iter::FromIterator<&'a utf8_char::Utf8Char> for std::vec::Vec<u8>>::from_iter":["from_iter","Real(LocalPath(\"src/utf8_char.rs\"))","std::iter::FromIterator"],"utf8_char::<impl std::iter::FromIterator<utf8_char::Utf8Char> for std::string::String>::from_iter":["from_iter","Real(LocalPath(\"src/utf8_char.rs\"))","std::iter::FromIterator"],"utf8_char::<impl std::iter::FromIterator<utf8_char::Utf8Char> for std::vec::Vec<u8>>::from_iter":["from_iter","Real(LocalPath(\"src/utf8_char.rs\"))","std::iter::FromIterator"],"utf8_char::Utf8Char::as_str":["as_str","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::eq_ignore_ascii_case":["eq_ignore_ascii_case","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::from_array":["from_array","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::from_array_unchecked":["from_array_unchecked","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::from_ascii":["from_ascii","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::from_ascii_unchecked":["from_ascii_unchecked","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::from_slice_start":["from_slice_start","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::from_slice_start_unchecked":["from_slice_start_unchecked","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::from_str_start":["from_str_start","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::is_ascii":["is_ascii","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::len":["len","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::make_ascii_lowercase":["make_ascii_lowercase","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::make_ascii_uppercase":["make_ascii_uppercase","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::to_array":["to_array","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::to_ascii_lowercase":["to_ascii_lowercase","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::to_ascii_uppercase":["to_ascii_uppercase","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::to_char":["to_char","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_char::Utf8Char::to_slice":["to_slice","Real(LocalPath(\"src/utf8_char.rs\"))",""],"utf8_iterators::Utf8CharIndices::<'a>::as_str":["as_str","Real(LocalPath(\"src/utf8_iterators.rs\"))",""],"utf8_iterators::Utf8CharSplitter::<U, I>::into_inner":["into_inner","Real(LocalPath(\"src/utf8_iterators.rs\"))",""],"utf8_iterators::Utf8Chars::<'a>::as_str":["as_str","Real(LocalPath(\"src/utf8_iterators.rs\"))",""],"utf8_iterators::iter_bytes":["iter_bytes","Real(LocalPath(\"src/utf8_iterators.rs\"))",""]},"trait_to_struct":{"std::ascii::AsciiExt":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::borrow::Borrow":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::clone::Clone":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","decoding_iterators::Utf8CharDecoder","decoding_iterators::Utf8CharMerger","errors::EmptyStrError","errors::FromStrError","errors::InvalidCodepoint","errors::InvalidUtf16Array","errors::InvalidUtf16FirstUnit","errors::InvalidUtf16Slice","errors::InvalidUtf16Tuple","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","errors::NonAsciiError","errors::NonBMPError","errors::Utf16PairError","utf16_char::Utf16Char","utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16CharSplitter","utf16_iterators::Utf16Chars","utf16_iterators::Utf16Iterator","utf8_char::Utf8Char","utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8CharSplitter","utf8_iterators::Utf8Chars","utf8_iterators::Utf8Iterator"],"std::cmp::Eq":["errors::EmptyStrError","errors::FromStrError","errors::InvalidCodepoint","errors::InvalidUtf16Array","errors::InvalidUtf16FirstUnit","errors::InvalidUtf16Slice","errors::InvalidUtf16Tuple","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","errors::NonAsciiError","errors::NonBMPError","errors::Utf16PairError","utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::cmp::Ord":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::cmp::PartialEq":["errors::EmptyStrError","errors::FromStrError","errors::InvalidCodepoint","errors::InvalidUtf16Array","errors::InvalidUtf16FirstUnit","errors::InvalidUtf16Slice","errors::InvalidUtf16Tuple","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","errors::NonAsciiError","errors::NonBMPError","errors::Utf16PairError","utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::cmp::PartialOrd":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::convert::AsRef":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::convert::From":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","decoding_iterators::Utf8CharDecoder","decoding_iterators::Utf8CharMerger","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8Slice","utf16_char::Utf16Char","utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16CharSplitter","utf16_iterators::Utf16Chars","utf16_iterators::Utf16Iterator","utf8_char::Utf8Char","utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8CharSplitter","utf8_iterators::Utf8Chars","utf8_iterators::Utf8Iterator"],"std::default::Default":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","decoding_iterators::Utf8CharDecoder","decoding_iterators::Utf8CharMerger","utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::error::Error":["errors::EmptyStrError","errors::FromStrError","errors::InvalidCodepoint","errors::InvalidUtf16Array","errors::InvalidUtf16FirstUnit","errors::InvalidUtf16Slice","errors::InvalidUtf16Tuple","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","errors::NonAsciiError","errors::NonBMPError","errors::Utf16PairError"],"std::fmt::Debug":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","decoding_iterators::Utf8CharDecoder","decoding_iterators::Utf8CharMerger","errors::EmptyStrError","errors::FromStrError","errors::InvalidCodepoint","errors::InvalidUtf16Array","errors::InvalidUtf16FirstUnit","errors::InvalidUtf16Slice","errors::InvalidUtf16Tuple","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","errors::NonAsciiError","errors::NonBMPError","errors::Utf16PairError","utf16_char::Utf16Char","utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars","utf16_iterators::Utf16Iterator","utf8_char::Utf8Char","utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars","utf8_iterators::Utf8Iterator"],"std::fmt::Display":["errors::EmptyStrError","errors::FromStrError","errors::InvalidCodepoint","errors::InvalidUtf16Array","errors::InvalidUtf16FirstUnit","errors::InvalidUtf16Slice","errors::InvalidUtf16Tuple","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","errors::NonAsciiError","errors::NonBMPError","errors::Utf16PairError","utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::hash::Hash":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::io::Read":["utf8_iterators::Utf8CharSplitter","utf8_iterators::Utf8Iterator"],"std::iter::DoubleEndedIterator":["decoding_iterators::Utf8CharDecoder","utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16Chars","utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8Chars"],"std::iter::ExactSizeIterator":["utf16_iterators::Utf16Iterator","utf8_iterators::Utf8Iterator"],"std::iter::Extend":["std::string::String","std::vec::Vec"],"std::iter::FromIterator":["std::string::String","std::vec::Vec"],"std::iter::IntoIterator":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::iter::Iterator":["decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger","decoding_iterators::Utf8CharDecoder","decoding_iterators::Utf8CharMerger","utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16CharSplitter","utf16_iterators::Utf16Chars","utf16_iterators::Utf16Iterator","utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8CharSplitter","utf8_iterators::Utf8Chars","utf8_iterators::Utf8Iterator"],"std::marker::Copy":["errors::EmptyStrError","errors::FromStrError","errors::InvalidCodepoint","errors::InvalidUtf16Array","errors::InvalidUtf16FirstUnit","errors::InvalidUtf16Slice","errors::InvalidUtf16Tuple","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","errors::NonAsciiError","errors::NonBMPError","errors::Utf16PairError","utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::marker::StructuralEq":["errors::EmptyStrError","errors::FromStrError","errors::InvalidCodepoint","errors::InvalidUtf16Array","errors::InvalidUtf16FirstUnit","errors::InvalidUtf16Slice","errors::InvalidUtf16Tuple","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","errors::NonAsciiError","errors::NonBMPError","errors::Utf16PairError","utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::marker::StructuralPartialEq":["errors::EmptyStrError","errors::FromStrError","errors::InvalidCodepoint","errors::InvalidUtf16Array","errors::InvalidUtf16FirstUnit","errors::InvalidUtf16Slice","errors::InvalidUtf16Tuple","errors::InvalidUtf8","errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice","errors::NonAsciiError","errors::NonBMPError","errors::Utf16PairError","utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::ops::Deref":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"std::str::FromStr":["utf16_char::Utf16Char","utf8_char::Utf8Char"],"traits::IterExt":["<I as traits::IterExt>::I"],"traits::SliceExt":["<S as traits::SliceExt>::S"]},"type_to_def_path":{"decoding_iterators::Utf16CharDecoder<'a>":"decoding_iterators::Utf16CharDecoder","decoding_iterators::Utf16CharMerger<B, I>":"decoding_iterators::Utf16CharMerger","decoding_iterators::Utf8CharDecoder<'a>":"decoding_iterators::Utf8CharDecoder","decoding_iterators::Utf8CharMerger<B, I>":"decoding_iterators::Utf8CharMerger","errors::EmptyStrError":"errors::EmptyStrError","errors::FromStrError":"errors::FromStrError","errors::InvalidCodepoint":"errors::InvalidCodepoint","errors::InvalidUtf16Array":"errors::InvalidUtf16Array","errors::InvalidUtf16FirstUnit":"errors::InvalidUtf16FirstUnit","errors::InvalidUtf16Slice":"errors::InvalidUtf16Slice","errors::InvalidUtf16Tuple":"errors::InvalidUtf16Tuple","errors::InvalidUtf8":"errors::InvalidUtf8","errors::InvalidUtf8Array":"errors::InvalidUtf8Array","errors::InvalidUtf8FirstByte":"errors::InvalidUtf8FirstByte","errors::InvalidUtf8Slice":"errors::InvalidUtf8Slice","errors::NonAsciiError":"errors::NonAsciiError","errors::NonBMPError":"errors::NonBMPError","errors::Utf16PairError":"errors::Utf16PairError","utf16_char::Utf16Char":"utf16_char::Utf16Char","utf16_iterators::Utf16CharIndices<'a>":"utf16_iterators::Utf16CharIndices","utf16_iterators::Utf16CharSplitter<U, I>":"utf16_iterators::Utf16CharSplitter","utf16_iterators::Utf16Chars<'a>":"utf16_iterators::Utf16Chars","utf16_iterators::Utf16Iterator":"utf16_iterators::Utf16Iterator","utf8_char::Utf8Char":"utf8_char::Utf8Char","utf8_iterators::Utf8CharIndices<'a>":"utf8_iterators::Utf8CharIndices","utf8_iterators::Utf8CharSplitter<U, I>":"utf8_iterators::Utf8CharSplitter","utf8_iterators::Utf8Chars<'a>":"utf8_iterators::Utf8Chars","utf8_iterators::Utf8Iterator":"utf8_iterators::Utf8Iterator"}}