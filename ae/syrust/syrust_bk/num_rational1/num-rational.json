{"dependencies":{"<&'a Ratio<T> as core::ops::Add<&'b Ratio<T>>>::add":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Add<&'b T>>::add":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Add<Ratio<T>>>::add":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Add<T>>::add":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Div<&'b Ratio<T>>>::div":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Div<&'b T>>::div":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Div<Ratio<T>>>::div":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Div<T>>::div":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Mul<&'b Ratio<T>>>::mul":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Mul<&'b T>>::mul":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Mul<Ratio<T>>>::mul":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Mul<T>>::mul":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Neg>::neg":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Rem<&'b Ratio<T>>>::rem":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Rem<&'b T>>::rem":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Rem<Ratio<T>>>::rem":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Rem<T>>::rem":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Sub<&'b Ratio<T>>>::sub":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Sub<&'b T>>::sub":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Sub<Ratio<T>>>::sub":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as core::ops::Sub<T>>::sub":["Ratio","core::marker::Sized"],"<&'a Ratio<T> as num_traits::Inv>::inv":["Ratio","core::marker::Sized"],"<ParseRatioError as core::clone::Clone>::clone":["ParseRatioError","RatioErrorKind"],"<ParseRatioError as core::cmp::PartialEq>::eq":["ParseRatioError","RatioErrorKind"],"<ParseRatioError as core::error::Error>::description":["ParseRatioError","RatioErrorKind"],"<ParseRatioError as core::fmt::Debug>::fmt":["ParseRatioError","RatioErrorKind","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<ParseRatioError as core::fmt::Display>::fmt":["ParseRatioError","RatioErrorKind","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Ratio<T> as core::clone::Clone>::clone":["Ratio","core::marker::Sized"],"<Ratio<T> as core::cmp::Ord>::cmp":["Ratio","core::cmp::Ordering","core::marker::Sized"],"<Ratio<T> as core::cmp::PartialEq>::eq":["Ratio","core::marker::Sized"],"<Ratio<T> as core::cmp::PartialOrd>::partial_cmp":["Ratio","core::marker::Sized","core::option::Option"],"<Ratio<T> as core::convert::From<(T, T)>>::from":["Ratio","core::marker::Sized"],"<Ratio<T> as core::convert::From<T>>::from":["Ratio","core::marker::Sized"],"<Ratio<T> as core::convert::Into<(T, T)>>::into":["Ratio","core::marker::Sized"],"<Ratio<T> as core::fmt::Binary>::fmt":["Ratio","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Ratio<T> as core::fmt::Debug>::fmt":["Ratio","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Ratio<T> as core::fmt::Display>::fmt":["Ratio","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Ratio<T> as core::fmt::LowerExp>::fmt":["Ratio","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Ratio<T> as core::fmt::LowerHex>::fmt":["Ratio","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Ratio<T> as core::fmt::Octal>::fmt":["Ratio","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Ratio<T> as core::fmt::UpperExp>::fmt":["Ratio","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Ratio<T> as core::fmt::UpperHex>::fmt":["Ratio","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Ratio<T> as core::hash::Hash>::hash":["Ratio","core::hash::Hasher","core::marker::Sized"],"<Ratio<T> as core::hash::Hash>::hash::recurse":["Ratio","core::hash::Hash","core::hash::Hasher","core::marker::Sized","num_integer::Integer"],"<Ratio<T> as core::ops::Add<&'a Ratio<T>>>::add":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Add<&'a T>>::add":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Add<T>>::add":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Add>::add":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Div<&'a Ratio<T>>>::div":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Div<&'a T>>::div":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Div<T>>::div":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Div>::div":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Mul<&'a Ratio<T>>>::mul":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Mul<&'a T>>::mul":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Mul<T>>::mul":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Mul>::mul":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Neg>::neg":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Rem<&'a Ratio<T>>>::rem":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Rem<&'a T>>::rem":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Rem<T>>::rem":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Rem>::rem":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Sub<&'a Ratio<T>>>::sub":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Sub<&'a T>>::sub":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Sub<T>>::sub":["Ratio","core::marker::Sized"],"<Ratio<T> as core::ops::Sub>::sub":["Ratio","core::marker::Sized"],"<Ratio<T> as core::str::FromStr>::from_str":["core::marker::Sized","core::result::Result"],"<Ratio<T> as num_traits::CheckedAdd>::checked_add":["Ratio","core::marker::Sized","core::option::Option"],"<Ratio<T> as num_traits::CheckedDiv>::checked_div":["Ratio","core::marker::Sized","core::option::Option"],"<Ratio<T> as num_traits::CheckedMul>::checked_mul":["Ratio","core::marker::Sized","core::option::Option"],"<Ratio<T> as num_traits::CheckedSub>::checked_sub":["Ratio","core::marker::Sized","core::option::Option"],"<Ratio<T> as num_traits::Inv>::inv":["Ratio","core::marker::Sized"],"<Ratio<T> as num_traits::Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<Ratio<T> as num_traits::One>::is_one":["Ratio","core::marker::Sized"],"<Ratio<T> as num_traits::One>::one":["Ratio","core::marker::Sized"],"<Ratio<T> as num_traits::One>::set_one":["Ratio","core::marker::Sized"],"<Ratio<T> as num_traits::Signed>::abs":["Ratio","core::marker::Sized"],"<Ratio<T> as num_traits::Signed>::abs_sub":["Ratio","core::marker::Sized"],"<Ratio<T> as num_traits::Signed>::is_negative":["Ratio","core::marker::Sized"],"<Ratio<T> as num_traits::Signed>::is_positive":["Ratio","core::marker::Sized"],"<Ratio<T> as num_traits::Signed>::signum":["Ratio","core::marker::Sized"],"<Ratio<T> as num_traits::ToPrimitive>::to_f64":["Ratio","core::marker::Sized","core::option::Option"],"<Ratio<T> as num_traits::ToPrimitive>::to_i128":["Ratio","core::marker::Sized","core::option::Option"],"<Ratio<T> as num_traits::ToPrimitive>::to_i64":["Ratio","core::marker::Sized","core::option::Option"],"<Ratio<T> as num_traits::ToPrimitive>::to_u128":["Ratio","core::marker::Sized","core::option::Option"],"<Ratio<T> as num_traits::ToPrimitive>::to_u64":["Ratio","core::marker::Sized","core::option::Option"],"<Ratio<T> as num_traits::Zero>::is_zero":["Ratio","core::marker::Sized"],"<Ratio<T> as num_traits::Zero>::set_zero":["Ratio","core::marker::Sized"],"<Ratio<T> as num_traits::Zero>::zero":["Ratio","core::marker::Sized"],"<Ratio<i128> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<i128> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<i128> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<i128> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<i128> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<i128> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<i16> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<i16> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<i16> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<i16> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<i16> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<i16> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<i32> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<i32> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<i32> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<i32> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<i32> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<i32> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<i64> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<i64> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<i64> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<i64> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<i64> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<i64> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<i8> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<i8> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<i8> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<i8> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<i8> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<i8> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<isize> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<isize> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<isize> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<isize> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<isize> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<isize> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<u128> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<u128> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<u128> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<u128> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<u128> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<u128> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<u16> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<u16> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<u16> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<u16> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<u16> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<u16> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<u32> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<u32> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<u32> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<u32> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<u32> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<u32> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<u64> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<u64> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<u64> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<u64> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<u64> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<u64> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<u8> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<u8> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<u8> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<u8> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<u8> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<u8> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<Ratio<usize> as num_traits::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<Ratio<usize> as num_traits::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<Ratio<usize> as num_traits::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<Ratio<usize> as num_traits::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<Ratio<usize> as num_traits::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<Ratio<usize> as num_traits::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<RatioErrorKind as core::clone::Clone>::clone":["RatioErrorKind"],"<RatioErrorKind as core::cmp::PartialEq>::eq":["RatioErrorKind"],"<RatioErrorKind as core::fmt::Debug>::fmt":["RatioErrorKind","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<i128 as Bits>::bits":[],"<num_bigint::BigInt as Bits>::bits":["num_bigint::BigInt"],"Bits::bits":[],"ParseRatioError":["ParseRatioError","RatioErrorKind"],"Ratio":["Ratio","core::marker::Sized"],"Ratio::<T>::approximate_float":["core::marker::Sized","core::option::Option","num_traits::NumCast","num_traits::float::FloatCore"],"Ratio::<T>::ceil":["Ratio","core::marker::Sized"],"Ratio::<T>::denom":["Ratio","core::marker::Sized"],"Ratio::<T>::floor":["Ratio","core::marker::Sized"],"Ratio::<T>::fract":["Ratio","core::marker::Sized"],"Ratio::<T>::from_integer":["Ratio","core::marker::Sized"],"Ratio::<T>::into_recip":["Ratio","core::marker::Sized"],"Ratio::<T>::is_integer":["Ratio","core::marker::Sized"],"Ratio::<T>::new":["Ratio","core::marker::Sized"],"Ratio::<T>::new_raw":["Ratio","core::marker::Sized"],"Ratio::<T>::numer":["Ratio","core::marker::Sized"],"Ratio::<T>::pow":["Ratio","core::marker::Sized","num_traits::Pow"],"Ratio::<T>::recip":["Ratio","core::marker::Sized"],"Ratio::<T>::reduce":["Ratio","core::marker::Sized"],"Ratio::<T>::reduced":["Ratio","core::marker::Sized"],"Ratio::<T>::round":["Ratio","core::marker::Sized"],"Ratio::<T>::to_integer":["Ratio","core::marker::Sized"],"Ratio::<T>::trunc":["Ratio","core::marker::Sized"],"Ratio::<num_bigint::BigInt>::from_float":["core::marker::Sized","core::option::Option","num_traits::float::FloatCore"],"RatioErrorKind":["RatioErrorKind"],"RatioErrorKind::description":["RatioErrorKind"],"approximate_float":["ParseRatioError","Ratio","RatioErrorKind","core::clone::Clone","core::marker::Sized","core::option::Option","num_integer::Integer","num_traits::Bounded","num_traits::NumCast","num_traits::Signed","num_traits::float::FloatCore"],"approximate_float_unsigned":["ParseRatioError","RatioErrorKind","core::clone::Clone","core::marker::Sized","core::option::Option","num_integer::Integer","num_traits::Bounded","num_traits::NumCast","num_traits::float::FloatCore"],"iter_sum_product::<impl core::iter::Product for Ratio<T>>::product":["Ratio","core::iter::Iterator","core::marker::Sized"],"iter_sum_product::<impl core::iter::Product<&'a Ratio<T>> for Ratio<T>>::product":["Ratio","core::iter::Iterator","core::marker::Sized"],"iter_sum_product::<impl core::iter::Sum for Ratio<T>>::sum":["Ratio","core::iter::Iterator","core::marker::Sized"],"iter_sum_product::<impl core::iter::Sum<&'a Ratio<T>> for Ratio<T>>::sum":["Ratio","core::iter::Iterator","core::marker::Sized"],"opassign::<impl core::ops::AddAssign for Ratio<T>>::add_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::AddAssign<&'a Ratio<T>> for Ratio<T>>::add_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::AddAssign<&'a T> for Ratio<T>>::add_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::AddAssign<T> for Ratio<T>>::add_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::DivAssign for Ratio<T>>::div_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::DivAssign<&'a Ratio<T>> for Ratio<T>>::div_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::DivAssign<&'a T> for Ratio<T>>::div_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::DivAssign<T> for Ratio<T>>::div_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::MulAssign for Ratio<T>>::mul_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::MulAssign<&'a Ratio<T>> for Ratio<T>>::mul_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::MulAssign<&'a T> for Ratio<T>>::mul_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::MulAssign<T> for Ratio<T>>::mul_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::RemAssign for Ratio<T>>::rem_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::RemAssign<&'a Ratio<T>> for Ratio<T>>::rem_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::RemAssign<&'a T> for Ratio<T>>::rem_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::RemAssign<T> for Ratio<T>>::rem_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::SubAssign for Ratio<T>>::sub_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::SubAssign<&'a Ratio<T>> for Ratio<T>>::sub_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::SubAssign<&'a T> for Ratio<T>>::sub_assign":["Ratio","core::marker::Sized"],"opassign::<impl core::ops::SubAssign<T> for Ratio<T>>::sub_assign":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b i128> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b i128> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b i16> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b i16> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b i32> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b i32> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b i64> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b i64> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b i8> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b i8> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b isize> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b isize> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b u128> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b u128> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b u16> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b u16> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b u32> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b u32> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b u64> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b u64> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b u8> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b u8> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b usize> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<&'b usize> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<i128> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<i128> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<i16> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<i16> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<i32> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<i32> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<i64> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<i64> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<i8> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<i8> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<isize> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<isize> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<u128> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<u128> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<u16> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<u16> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<u32> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<u32> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<u64> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<u64> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<u8> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<u8> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<usize> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::<impl num_traits::Pow<usize> for Ratio<T>>::pow":["Ratio","core::marker::Sized"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigInt> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized","num_bigint::BigInt"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigInt> for Ratio<T>>::pow":["Ratio","core::marker::Sized","num_bigint::BigInt"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigUint> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized","num_bigint::BigUint"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigUint> for Ratio<T>>::pow":["Ratio","core::marker::Sized","num_bigint::BigUint"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigInt> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized","num_bigint::BigInt"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigInt> for Ratio<T>>::pow":["Ratio","core::marker::Sized","num_bigint::BigInt"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigUint> for &'a Ratio<T>>::pow":["Ratio","core::marker::Sized","num_bigint::BigUint"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigUint> for Ratio<T>>::pow":["Ratio","core::marker::Sized","num_bigint::BigUint"],"ratio_to_f64":["Bits","ParseRatioError","Ratio","RatioErrorKind","core::clone::Clone","core::marker::Sized","core::ops::ShlAssign","num_bigint::BigInt","num_integer::Integer","num_traits::Signed","num_traits::ToPrimitive"]},"glob_path_import":{},"self_to_fn":{"ParseRatioError":["Clone","Copy","Debug","PartialEq","impl Error for ParseRatioError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        self.kind.description()\n    }\n}","impl fmt::Display for ParseRatioError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.kind.description().fmt(f)\n    }\n}"],"Ratio":["Clone","Copy","Debug","impl FromPrimitive for Ratio<$typ> {\n            fn from_i64(n: i64) -> Option<Self> {\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }\n\n            fn from_i128(n: i128) -> Option<Self> {\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }\n\n            fn from_u64(n: u64) -> Option<Self> {\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }\n\n            fn from_u128(n: u128) -> Option<Self> {\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }\n\n            fn from_f32(n: f32) -> Option<Self> {\n                $approx(n, 10e-20, 30)\n            }\n\n            fn from_f64(n: f64) -> Option<Self> {\n                $approx(n, 10e-20, 30)\n            }\n        }","impl FromPrimitive for Ratio<BigInt> {\n    fn from_i64(n: i64) -> Option<Self> {\n        Some(Ratio::from_integer(n.into()))\n    }\n\n    fn from_i128(n: i128) -> Option<Self> {\n        Some(Ratio::from_integer(n.into()))\n    }\n\n    fn from_u64(n: u64) -> Option<Self> {\n        Some(Ratio::from_integer(n.into()))\n    }\n\n    fn from_u128(n: u128) -> Option<Self> {\n        Some(Ratio::from_integer(n.into()))\n    }\n\n    fn from_f32(n: f32) -> Option<Self> {\n        Ratio::from_float(n)\n    }\n\n    fn from_f64(n: f64) -> Option<Self> {\n        Ratio::from_float(n)\n    }\n}","impl Ratio<BigInt> {\n    /// Converts a float into a rational number.\n    pub fn from_float<T: FloatCore>(f: T) -> Option<BigRational> {\n        if !f.is_finite() {\n            return None;\n        }\n        let (mantissa, exponent, sign) = f.integer_decode();\n        let bigint_sign = if sign == 1 { Sign::Plus } else { Sign::Minus };\n        if exponent < 0 {\n            let one: BigInt = One::one();\n            let denom: BigInt = one << ((-exponent) as usize);\n            let numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();\n            Some(Ratio::new(BigInt::from_biguint(bigint_sign, numer), denom))\n        } else {\n            let mut numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();\n            numer <<= exponent as usize;\n            Some(Ratio::from_integer(BigInt::from_biguint(\n                bigint_sign,\n                numer,\n            )))\n        }\n    }\n}","impl<'a, T: Clone + Integer + NumAssign> $imp<&'a Ratio<T>> for Ratio<T> {\n                #[inline]\n                fn $method(&mut self, other: &Ratio<T>) {\n                    self.$method(other.clone())\n                }\n            }","impl<'a, T: Clone + Integer + NumAssign> $imp<&'a T> for Ratio<T> {\n                #[inline]\n                fn $method(&mut self, other: &T) {\n                    self.$method(other.clone())\n                }\n            }","impl<'a, T: Integer + Clone> Product<&'a Ratio<T>> for Ratio<T> {\n        fn product<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = &'a Ratio<T>>,\n        {\n            iter.fold(Self::one(), |prod, num| prod * num)\n        }\n    }","impl<'a, T: Integer + Clone> Sum<&'a Ratio<T>> for Ratio<T> {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = &'a Ratio<T>>,\n        {\n            iter.fold(Self::zero(), |sum, num| sum + num)\n        }\n    }","impl<'a, T> $imp<&'a Ratio<T>> for Ratio<T>\n        where\n            T: Clone + Integer,\n        {\n            type Output = Ratio<T>;\n\n            #[inline]\n            fn $method(self, other: &Ratio<T>) -> Ratio<T> {\n                self.$method(other.clone())\n            }\n        }","impl<'a, T> $imp<&'a T> for Ratio<T>\n        where\n            T: Clone + Integer,\n        {\n            type Output = Ratio<T>;\n\n            #[inline]\n            fn $method(self, other: &T) -> Ratio<T> {\n                self.$method(other.clone())\n            }\n        }","impl<'b, T: Clone + Integer + Pow<$exp, Output = T>> Pow<&'b $exp> for Ratio<T> {\n            type Output = Ratio<T>;\n            #[inline]\n            fn pow(self, expon: &'b $exp) -> Ratio<T> {\n                Pow::pow(self, *expon)\n            }\n        }","impl<'b, T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<&'b $exp> for Ratio<T> {\n            type Output = Ratio<T>;\n            #[inline]\n            fn pow(self, expon: &'b $exp) -> Ratio<T> {\n                Pow::pow(self, *expon)\n            }\n        }","impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigInt> for Ratio<T> {\n        pow_signed_impl!(@ &'b BigInt, BigUint);\n    }","impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigUint> for Ratio<T> {\n        pow_unsigned_impl!(@ &'b BigUint);\n    }","impl<T: $fmt_trait + Clone + Integer> $fmt_trait for Ratio<T> {\n            #[cfg(feature = \"std\")]\n            fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n                let pre_pad = if self.denom.is_one() {\n                    format!($fmt_str, self.numer)\n                } else {\n                    if f.alternate() {\n                        format!(concat!($fmt_str, \"/\", $fmt_alt), self.numer, self.denom)\n                    } else {\n                        format!(concat!($fmt_str, \"/\", $fmt_str), self.numer, self.denom)\n                    }\n                };\n                // TODO: replace with strip_prefix, when stabalized\n                let (pre_pad, non_negative) = {\n                    if pre_pad.starts_with(\"-\") {\n                        (&pre_pad[1..], false)\n                    } else {\n                        (&pre_pad[..], true)\n                    }\n                };\n                f.pad_integral(non_negative, $prefix, pre_pad)\n            }\n            #[cfg(not(feature = \"std\"))]\n            fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n                let plus = if f.sign_plus() && self.numer >= T::zero() {\n                    \"+\"\n                } else {\n                    \"\"\n                };\n                if self.denom.is_one() {\n                    if f.alternate() {\n                        write!(f, concat!(\"{}\", $fmt_alt), plus, self.numer)\n                    } else {\n                        write!(f, concat!(\"{}\", $fmt_str), plus, self.numer)\n                    }\n                } else {\n                    if f.alternate() {\n                        write!(\n                            f,\n                            concat!(\"{}\", $fmt_alt, \"/\", $fmt_alt),\n                            plus, self.numer, self.denom\n                        )\n                    } else {\n                        write!(\n                            f,\n                            concat!(\"{}\", $fmt_str, \"/\", $fmt_str),\n                            plus, self.numer, self.denom\n                        )\n                    }\n                }\n            }\n        }","impl<T: Clone + Integer + CheckedMul + $imp> $imp for Ratio<T> {\n            #[inline]\n            fn $method(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {\n                let gcd = self.denom.clone().gcd(&rhs.denom);\n                let lcm = (self.denom.clone() / gcd.clone()).checked_mul(&rhs.denom)?;\n                let lhs_numer = (lcm.clone() / self.denom.clone()).checked_mul(&self.numer)?;\n                let rhs_numer = (lcm.clone() / rhs.denom.clone()).checked_mul(&rhs.numer)?;\n                Some(Ratio::new(lhs_numer.$method(&rhs_numer)?, lcm))\n            }\n        }","impl<T: Clone + Integer + Hash> Hash for Ratio<T> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        recurse(&self.numer, &self.denom, state);\n\n        fn recurse<T: Integer + Hash, H: Hasher>(numer: &T, denom: &T, state: &mut H) {\n            if !denom.is_zero() {\n                let (int, rem) = numer.div_mod_floor(denom);\n                int.hash(state);\n                recurse(denom, &rem, state);\n            } else {\n                denom.hash(state);\n            }\n        }\n    }\n}","impl<T: Clone + Integer + NumAssign> AddAssign for Ratio<T> {\n        fn add_assign(&mut self, other: Ratio<T>) {\n            if self.denom == other.denom {\n                self.numer += other.numer\n            } else {\n                let lcm = self.denom.lcm(&other.denom);\n                let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());\n                let rhs_numer = other.numer * (lcm.clone() / other.denom);\n                self.numer = lhs_numer + rhs_numer;\n                self.denom = lcm;\n            }\n            self.reduce();\n        }\n    }","impl<T: Clone + Integer + NumAssign> AddAssign<T> for Ratio<T> {\n        fn add_assign(&mut self, other: T) {\n            self.numer += self.denom.clone() * other;\n            self.reduce();\n        }\n    }","impl<T: Clone + Integer + NumAssign> DivAssign for Ratio<T> {\n        fn div_assign(&mut self, other: Ratio<T>) {\n            let gcd_ac = self.numer.gcd(&other.numer);\n            let gcd_bd = self.denom.gcd(&other.denom);\n            self.numer /= gcd_ac.clone();\n            self.numer *= other.denom / gcd_bd.clone();\n            self.denom /= gcd_bd;\n            self.denom *= other.numer / gcd_ac;\n            self.reduce(); // TODO: remove this line. see #8.\n        }\n    }","impl<T: Clone + Integer + NumAssign> DivAssign<T> for Ratio<T> {\n        fn div_assign(&mut self, other: T) {\n            let gcd = self.numer.gcd(&other);\n            self.numer /= gcd.clone();\n            self.denom *= other / gcd;\n            self.reduce(); // TODO: remove this line. see #8.\n        }\n    }","impl<T: Clone + Integer + NumAssign> MulAssign for Ratio<T> {\n        fn mul_assign(&mut self, other: Ratio<T>) {\n            let gcd_ad = self.numer.gcd(&other.denom);\n            let gcd_bc = self.denom.gcd(&other.numer);\n            self.numer /= gcd_ad.clone();\n            self.numer *= other.numer / gcd_bc.clone();\n            self.denom /= gcd_bc;\n            self.denom *= other.denom / gcd_ad;\n            self.reduce(); // TODO: remove this line. see #8.\n        }\n    }","impl<T: Clone + Integer + NumAssign> MulAssign<T> for Ratio<T> {\n        fn mul_assign(&mut self, other: T) {\n            let gcd = self.denom.gcd(&other);\n            self.denom /= gcd.clone();\n            self.numer *= other / gcd;\n            self.reduce(); // TODO: remove this line. see #8.\n        }\n    }","impl<T: Clone + Integer + NumAssign> RemAssign for Ratio<T> {\n        fn rem_assign(&mut self, other: Ratio<T>) {\n            if self.denom == other.denom {\n                self.numer %= other.numer\n            } else {\n                let lcm = self.denom.lcm(&other.denom);\n                let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());\n                let rhs_numer = other.numer * (lcm.clone() / other.denom);\n                self.numer = lhs_numer % rhs_numer;\n                self.denom = lcm;\n            }\n            self.reduce();\n        }\n    }","impl<T: Clone + Integer + NumAssign> RemAssign<T> for Ratio<T> {\n        fn rem_assign(&mut self, other: T) {\n            self.numer %= self.denom.clone() * other;\n            self.reduce();\n        }\n    }","impl<T: Clone + Integer + NumAssign> SubAssign for Ratio<T> {\n        fn sub_assign(&mut self, other: Ratio<T>) {\n            if self.denom == other.denom {\n                self.numer -= other.numer\n            } else {\n                let lcm = self.denom.lcm(&other.denom);\n                let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());\n                let rhs_numer = other.numer * (lcm.clone() / other.denom);\n                self.numer = lhs_numer - rhs_numer;\n                self.denom = lcm;\n            }\n            self.reduce();\n        }\n    }","impl<T: Clone + Integer + NumAssign> SubAssign<T> for Ratio<T> {\n        fn sub_assign(&mut self, other: T) {\n            self.numer -= self.denom.clone() * other;\n            self.reduce();\n        }\n    }","impl<T: Clone + Integer + Pow<$exp, Output = T>> Pow<$exp> for Ratio<T> {\n            pow_unsigned_impl!(@ $exp);\n        }","impl<T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<$exp> for Ratio<T> {\n            pow_signed_impl!(@ $exp, $unsigned);\n        }","impl<T: Clone + Integer + Signed> Signed for Ratio<T> {\n    #[inline]\n    fn abs(&self) -> Ratio<T> {\n        if self.is_negative() {\n            -self.clone()\n        } else {\n            self.clone()\n        }\n    }\n\n    #[inline]\n    fn abs_sub(&self, other: &Ratio<T>) -> Ratio<T> {\n        if *self <= *other {\n            Zero::zero()\n        } else {\n            self - other\n        }\n    }\n\n    #[inline]\n    fn signum(&self) -> Ratio<T> {\n        if self.is_positive() {\n            Self::one()\n        } else if self.is_zero() {\n            Self::zero()\n        } else {\n            -Self::one()\n        }\n    }\n\n    #[inline]\n    fn is_positive(&self) -> bool {\n        (self.numer.is_positive() && self.denom.is_positive())\n            || (self.numer.is_negative() && self.denom.is_negative())\n    }\n\n    #[inline]\n    fn is_negative(&self) -> bool {\n        (self.numer.is_negative() && self.denom.is_positive())\n            || (self.numer.is_positive() && self.denom.is_negative())\n    }\n}","impl<T: Clone + Integer + ToPrimitive + ToBigInt> ToPrimitive for Ratio<T> {\n    fn to_i64(&self) -> Option<i64> {\n        self.to_integer().to_i64()\n    }\n\n    fn to_i128(&self) -> Option<i128> {\n        self.to_integer().to_i128()\n    }\n\n    fn to_u64(&self) -> Option<u64> {\n        self.to_integer().to_u64()\n    }\n\n    fn to_u128(&self) -> Option<u128> {\n        self.to_integer().to_u128()\n    }\n\n    fn to_f64(&self) -> Option<f64> {\n        let float = match (self.numer.to_i64(), self.denom.to_i64()) {\n            (Some(numer), Some(denom)) => ratio_to_f64(\n                <i128 as From<_>>::from(numer),\n                <i128 as From<_>>::from(denom),\n            ),\n            _ => {\n                let numer: BigInt = self.numer.to_bigint()?;\n                let denom: BigInt = self.denom.to_bigint()?;\n                ratio_to_f64(numer, denom)\n            }\n        };\n        if float.is_nan() {\n            None\n        } else {\n            Some(float)\n        }\n    }\n}","impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigInt> for Ratio<T> {\n        type Output = Ratio<T>;\n        #[inline]\n        fn pow(self, expon: BigInt) -> Ratio<T> {\n            Pow::pow(self, &expon)\n        }\n    }","impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigUint> for Ratio<T> {\n        type Output = Ratio<T>;\n        #[inline]\n        fn pow(self, expon: BigUint) -> Ratio<T> {\n            Pow::pow(self, &expon)\n        }\n    }","impl<T: Clone + Integer> $imp<Ratio<T>> for Ratio<T> {\n            type Output = Ratio<T>;\n            #[inline]\n            fn $method(self, rhs: Ratio<T>) -> Ratio<T> {\n                if self.denom == rhs.denom {\n                    return Ratio::new(self.numer.$method(rhs.numer), rhs.denom);\n                }\n                let lcm = self.denom.lcm(&rhs.denom);\n                let lhs_numer = self.numer * (lcm.clone() / self.denom);\n                let rhs_numer = rhs.numer * (lcm.clone() / rhs.denom);\n                Ratio::new(lhs_numer.$method(rhs_numer), lcm)\n            }\n        }","impl<T: Clone + Integer> $imp<T> for Ratio<T> {\n            type Output = Ratio<T>;\n            #[inline]\n            fn $method(self, rhs: T) -> Ratio<T> {\n                Ratio::new(self.numer.$method(self.denom.clone() * rhs), self.denom)\n            }\n        }","impl<T: Clone + Integer> Eq for Ratio<T> {}","impl<T: Clone + Integer> Num for Ratio<T> {\n    type FromStrRadixErr = ParseRatioError;\n\n    /// Parses `numer/denom` where the numbers are in base `radix`.\n    fn from_str_radix(s: &str, radix: u32) -> Result<Ratio<T>, ParseRatioError> {\n        if s.splitn(2, '/').count() == 2 {\n            let mut parts = s.splitn(2, '/').map(|ss| {\n                T::from_str_radix(ss, radix).map_err(|_| ParseRatioError {\n                    kind: RatioErrorKind::ParseError,\n                })\n            });\n            let numer: T = parts.next().unwrap()?;\n            let denom: T = parts.next().unwrap()?;\n            if denom.is_zero() {\n                Err(ParseRatioError {\n                    kind: RatioErrorKind::ZeroDenominator,\n                })\n            } else {\n                Ok(Ratio::new(numer, denom))\n            }\n        } else {\n            Err(ParseRatioError {\n                kind: RatioErrorKind::ParseError,\n            })\n        }\n    }\n}","impl<T: Clone + Integer> One for Ratio<T> {\n    #[inline]\n    fn one() -> Ratio<T> {\n        Ratio::new_raw(One::one(), One::one())\n    }\n\n    #[inline]\n    fn is_one(&self) -> bool {\n        self.numer == self.denom\n    }\n\n    #[inline]\n    fn set_one(&mut self) {\n        self.numer.set_one();\n        self.denom.set_one();\n    }\n}","impl<T: Clone + Integer> Ord for Ratio<T> {\n    #[inline]\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n        // With equal denominators, the numerators can be directly compared\n        if self.denom == other.denom {\n            let ord = self.numer.cmp(&other.numer);\n            return if self.denom < T::zero() {\n                ord.reverse()\n            } else {\n                ord\n            };\n        }\n\n        // With equal numerators, the denominators can be inversely compared\n        if self.numer == other.numer {\n            if self.numer.is_zero() {\n                return cmp::Ordering::Equal;\n            }\n            let ord = self.denom.cmp(&other.denom);\n            return if self.numer < T::zero() {\n                ord\n            } else {\n                ord.reverse()\n            };\n        }\n\n        // Unfortunately, we don't have CheckedMul to try.  That could sometimes avoid all the\n        // division below, or even always avoid it for BigInt and BigUint.\n        // FIXME- future breaking change to add Checked* to Integer?\n\n        // Compare as floored integers and remainders\n        let (self_int, self_rem) = self.numer.div_mod_floor(&self.denom);\n        let (other_int, other_rem) = other.numer.div_mod_floor(&other.denom);\n        match self_int.cmp(&other_int) {\n            cmp::Ordering::Greater => cmp::Ordering::Greater,\n            cmp::Ordering::Less => cmp::Ordering::Less,\n            cmp::Ordering::Equal => {\n                match (self_rem.is_zero(), other_rem.is_zero()) {\n                    (true, true) => cmp::Ordering::Equal,\n                    (true, false) => cmp::Ordering::Less,\n                    (false, true) => cmp::Ordering::Greater,\n                    (false, false) => {\n                        // Compare the reciprocals of the remaining fractions in reverse\n                        let self_recip = Ratio::new_raw(self.denom.clone(), self_rem);\n                        let other_recip = Ratio::new_raw(other.denom.clone(), other_rem);\n                        self_recip.cmp(&other_recip).reverse()\n                    }\n                }\n            }\n        }\n    }\n}","impl<T: Clone + Integer> PartialEq for Ratio<T> {\n    #[inline]\n    fn eq(&self, other: &Self) -> bool {\n        self.cmp(other) == cmp::Ordering::Equal\n    }\n}","impl<T: Clone + Integer> PartialOrd for Ratio<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}","impl<T: Clone + Integer> Ratio<T> {\n    /// Creates a new `Ratio`.\n    ///\n    /// **Panics if `denom` is zero.**\n    #[inline]\n    pub fn new(numer: T, denom: T) -> Ratio<T> {\n        let mut ret = Ratio::new_raw(numer, denom);\n        ret.reduce();\n        ret\n    }\n\n    /// Creates a `Ratio` representing the integer `t`.\n    #[inline]\n    pub fn from_integer(t: T) -> Ratio<T> {\n        Ratio::new_raw(t, One::one())\n    }\n\n    /// Converts to an integer, rounding towards zero.\n    #[inline]\n    pub fn to_integer(&self) -> T {\n        self.trunc().numer\n    }\n\n    /// Returns true if the rational number is an integer (denominator is 1).\n    #[inline]\n    pub fn is_integer(&self) -> bool {\n        self.denom.is_one()\n    }\n\n    /// Puts self into lowest terms, with `denom` > 0.\n    ///\n    /// **Panics if `denom` is zero.**\n    fn reduce(&mut self) {\n        if self.denom.is_zero() {\n            panic!(\"denominator == 0\");\n        }\n        if self.numer.is_zero() {\n            self.denom.set_one();\n            return;\n        }\n        if self.numer == self.denom {\n            self.set_one();\n            return;\n        }\n        let g: T = self.numer.gcd(&self.denom);\n\n        // FIXME(#5992): assignment operator overloads\n        // self.numer /= g;\n        // T: Clone + Integer != T: Clone + NumAssign\n        self.numer = self.numer.clone() / g.clone();\n        // FIXME(#5992): assignment operator overloads\n        // self.denom /= g;\n        // T: Clone + Integer != T: Clone + NumAssign\n        self.denom = self.denom.clone() / g;\n\n        // keep denom positive!\n        if self.denom < T::zero() {\n            self.numer = T::zero() - self.numer.clone();\n            self.denom = T::zero() - self.denom.clone();\n        }\n    }\n\n    /// Returns a reduced copy of self.\n    ///\n    /// In general, it is not necessary to use this method, as the only\n    /// method of procuring a non-reduced fraction is through `new_raw`.\n    ///\n    /// **Panics if `denom` is zero.**\n    pub fn reduced(&self) -> Ratio<T> {\n        let mut ret = self.clone();\n        ret.reduce();\n        ret\n    }\n\n    /// Returns the reciprocal.\n    ///\n    /// **Panics if the `Ratio` is zero.**\n    #[inline]\n    pub fn recip(&self) -> Ratio<T> {\n        self.clone().into_recip()\n    }\n\n    #[inline]\n    fn into_recip(self) -> Ratio<T> {\n        match self.numer.cmp(&T::zero()) {\n            cmp::Ordering::Equal => panic!(\"division by zero\"),\n            cmp::Ordering::Greater => Ratio::new_raw(self.denom, self.numer),\n            cmp::Ordering::Less => Ratio::new_raw(T::zero() - self.denom, T::zero() - self.numer),\n        }\n    }\n\n    /// Rounds towards minus infinity.\n    #[inline]\n    pub fn floor(&self) -> Ratio<T> {\n        if *self < Zero::zero() {\n            let one: T = One::one();\n            Ratio::from_integer(\n                (self.numer.clone() - self.denom.clone() + one) / self.denom.clone(),\n            )\n        } else {\n            Ratio::from_integer(self.numer.clone() / self.denom.clone())\n        }\n    }\n\n    /// Rounds towards plus infinity.\n    #[inline]\n    pub fn ceil(&self) -> Ratio<T> {\n        if *self < Zero::zero() {\n            Ratio::from_integer(self.numer.clone() / self.denom.clone())\n        } else {\n            let one: T = One::one();\n            Ratio::from_integer(\n                (self.numer.clone() + self.denom.clone() - one) / self.denom.clone(),\n            )\n        }\n    }\n\n    /// Rounds to the nearest integer. Rounds half-way cases away from zero.\n    #[inline]\n    pub fn round(&self) -> Ratio<T> {\n        let zero: Ratio<T> = Zero::zero();\n        let one: T = One::one();\n        let two: T = one.clone() + one.clone();\n\n        // Find unsigned fractional part of rational number\n        let mut fractional = self.fract();\n        if fractional < zero {\n            fractional = zero - fractional\n        };\n\n        // The algorithm compares the unsigned fractional part with 1/2, that\n        // is, a/b >= 1/2, or a >= b/2. For odd denominators, we use\n        // a >= (b/2)+1. This avoids overflow issues.\n        let half_or_larger = if fractional.denom.is_even() {\n            fractional.numer >= fractional.denom / two\n        } else {\n            fractional.numer >= (fractional.denom / two) + one\n        };\n\n        if half_or_larger {\n            let one: Ratio<T> = One::one();\n            if *self >= Zero::zero() {\n                self.trunc() + one\n            } else {\n                self.trunc() - one\n            }\n        } else {\n            self.trunc()\n        }\n    }\n\n    /// Rounds towards zero.\n    #[inline]\n    pub fn trunc(&self) -> Ratio<T> {\n        Ratio::from_integer(self.numer.clone() / self.denom.clone())\n    }\n\n    /// Returns the fractional part of a number, with division rounded towards zero.\n    ///\n    /// Satisfies `self == self.trunc() + self.fract()`.\n    #[inline]\n    pub fn fract(&self) -> Ratio<T> {\n        Ratio::new_raw(self.numer.clone() % self.denom.clone(), self.denom.clone())\n    }\n\n    /// Raises the `Ratio` to the power of an exponent.\n    #[inline]\n    pub fn pow(&self, expon: i32) -> Ratio<T>\n    where\n        for<'a> &'a T: Pow<u32, Output = T>,\n    {\n        Pow::pow(self, expon)\n    }\n}","impl<T: Clone + Integer> Zero for Ratio<T> {\n    #[inline]\n    fn zero() -> Ratio<T> {\n        Ratio::new_raw(Zero::zero(), One::one())\n    }\n\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self.numer.is_zero()\n    }\n\n    #[inline]\n    fn set_zero(&mut self) {\n        self.numer.set_zero();\n        self.denom.set_one();\n    }\n}","impl<T: FromStr + Clone + Integer> FromStr for Ratio<T> {\n    type Err = ParseRatioError;\n\n    /// Parses `numer/denom` or just `numer`.\n    fn from_str(s: &str) -> Result<Ratio<T>, ParseRatioError> {\n        let mut split = s.splitn(2, '/');\n\n        let n = split.next().ok_or(ParseRatioError {\n            kind: RatioErrorKind::ParseError,\n        })?;\n        let num = FromStr::from_str(n).map_err(|_| ParseRatioError {\n            kind: RatioErrorKind::ParseError,\n        })?;\n\n        let d = split.next().unwrap_or(\"1\");\n        let den = FromStr::from_str(d).map_err(|_| ParseRatioError {\n            kind: RatioErrorKind::ParseError,\n        })?;\n\n        if Zero::is_zero(&den) {\n            Err(ParseRatioError {\n                kind: RatioErrorKind::ZeroDenominator,\n            })\n        } else {\n            Ok(Ratio::new(num, den))\n        }\n    }\n}","impl<T: Integer + Clone> Product for Ratio<T> {\n        fn product<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = Ratio<T>>,\n        {\n            iter.fold(Self::one(), |prod, num| prod * num)\n        }\n    }","impl<T: Integer + Clone> Sum for Ratio<T> {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = Ratio<T>>,\n        {\n            iter.fold(Self::zero(), |sum, num| sum + num)\n        }\n    }","impl<T: Integer + Signed + Bounded + NumCast + Clone> Ratio<T> {\n    pub fn approximate_float<F: FloatCore + NumCast>(f: F) -> Option<Ratio<T>> {\n        // 1/10e-20 < 1/2**32 which seems like a good default, and 30 seems\n        // to work well. Might want to choose something based on the types in the future, e.g.\n        // T::max().recip() and T::bits() or something similar.\n        let epsilon = <F as NumCast>::from(10e-20).expect(\"Can't convert 10e-20\");\n        approximate_float(f, epsilon, 30)\n    }\n}","impl<T> CheckedDiv for Ratio<T>\nwhere\n    T: Clone + Integer + CheckedMul,\n{\n    #[inline]\n    fn checked_div(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {\n        if rhs.is_zero() {\n            return None;\n        }\n        let (numer, denom) = if self.denom == rhs.denom {\n            (self.numer.clone(), rhs.numer.clone())\n        } else if self.numer == rhs.numer {\n            (rhs.denom.clone(), self.denom.clone())\n        } else {\n            let gcd_ac = self.numer.gcd(&rhs.numer);\n            let gcd_bd = self.denom.gcd(&rhs.denom);\n            (\n                (self.numer.clone() / gcd_ac.clone())\n                    .checked_mul(&(rhs.denom.clone() / gcd_bd.clone()))?,\n                (self.denom.clone() / gcd_bd).checked_mul(&(rhs.numer.clone() / gcd_ac))?,\n            )\n        };\n        // Manual `reduce()`, avoiding sharp edges\n        if denom.is_zero() {\n            None\n        } else if numer.is_zero() {\n            Some(Self::zero())\n        } else if numer == denom {\n            Some(Self::one())\n        } else {\n            let g = numer.gcd(&denom);\n            let numer = numer / g.clone();\n            let denom = denom / g;\n            let raw = if denom < T::zero() {\n                // We need to keep denom positive, but 2's-complement MIN may\n                // overflow negation -- instead we can check multiplying -1.\n                let n1 = T::zero() - T::one();\n                Ratio::new_raw(numer.checked_mul(&n1)?, denom.checked_mul(&n1)?)\n            } else {\n                Ratio::new_raw(numer, denom)\n            };\n            Some(raw)\n        }\n    }\n}","impl<T> CheckedMul for Ratio<T>\nwhere\n    T: Clone + Integer + CheckedMul,\n{\n    #[inline]\n    fn checked_mul(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {\n        let gcd_ad = self.numer.gcd(&rhs.denom);\n        let gcd_bc = self.denom.gcd(&rhs.numer);\n        Some(Ratio::new(\n            (self.numer.clone() / gcd_ad.clone())\n                .checked_mul(&(rhs.numer.clone() / gcd_bc.clone()))?,\n            (self.denom.clone() / gcd_bc).checked_mul(&(rhs.denom.clone() / gcd_ad))?,\n        ))\n    }\n}","impl<T> Div<Ratio<T>> for Ratio<T>\nwhere\n    T: Clone + Integer,\n{\n    type Output = Ratio<T>;\n\n    #[inline]\n    fn div(self, rhs: Ratio<T>) -> Ratio<T> {\n        let gcd_ac = self.numer.gcd(&rhs.numer);\n        let gcd_bd = self.denom.gcd(&rhs.denom);\n        Ratio::new(\n            self.numer / gcd_ac.clone() * (rhs.denom / gcd_bd.clone()),\n            self.denom / gcd_bd * (rhs.numer / gcd_ac),\n        )\n    }\n}","impl<T> Div<T> for Ratio<T>\nwhere\n    T: Clone + Integer,\n{\n    type Output = Ratio<T>;\n\n    #[inline]\n    fn div(self, rhs: T) -> Ratio<T> {\n        let gcd = self.numer.gcd(&rhs);\n        Ratio::new(self.numer / gcd.clone(), self.denom * (rhs / gcd))\n    }\n}","impl<T> From<(T, T)> for Ratio<T>\nwhere\n    T: Clone + Integer,\n{\n    fn from(pair: (T, T)) -> Ratio<T> {\n        Ratio::new(pair.0, pair.1)\n    }\n}","impl<T> From<T> for Ratio<T>\nwhere\n    T: Clone + Integer,\n{\n    fn from(x: T) -> Ratio<T> {\n        Ratio::from_integer(x)\n    }\n}","impl<T> Into<(T, T)> for Ratio<T> {\n    fn into(self) -> (T, T) {\n        (self.numer, self.denom)\n    }\n}","impl<T> Inv for Ratio<T>\nwhere\n    T: Clone + Integer,\n{\n    type Output = Ratio<T>;\n\n    #[inline]\n    fn inv(self) -> Ratio<T> {\n        self.recip()\n    }\n}","impl<T> Mul<Ratio<T>> for Ratio<T>\nwhere\n    T: Clone + Integer,\n{\n    type Output = Ratio<T>;\n    #[inline]\n    fn mul(self, rhs: Ratio<T>) -> Ratio<T> {\n        let gcd_ad = self.numer.gcd(&rhs.denom);\n        let gcd_bc = self.denom.gcd(&rhs.numer);\n        Ratio::new(\n            self.numer / gcd_ad.clone() * (rhs.numer / gcd_bc.clone()),\n            self.denom / gcd_bc * (rhs.denom / gcd_ad),\n        )\n    }\n}","impl<T> Mul<T> for Ratio<T>\nwhere\n    T: Clone + Integer,\n{\n    type Output = Ratio<T>;\n    #[inline]\n    fn mul(self, rhs: T) -> Ratio<T> {\n        let gcd = self.denom.gcd(&rhs);\n        Ratio::new(self.numer * (rhs / gcd.clone()), self.denom / gcd)\n    }\n}","impl<T> Neg for Ratio<T>\nwhere\n    T: Clone + Integer + Neg<Output = T>,\n{\n    type Output = Ratio<T>;\n\n    #[inline]\n    fn neg(self) -> Ratio<T> {\n        Ratio::new_raw(-self.numer, self.denom)\n    }\n}","impl<T> Ratio<T> {\n    /// Creates a `Ratio` without checking for `denom == 0` or reducing.\n    ///\n    /// **There are several methods that will panic if used on a `Ratio` with\n    /// `denom == 0`.**\n    #[inline]\n    pub const fn new_raw(numer: T, denom: T) -> Ratio<T> {\n        Ratio { numer, denom }\n    }\n\n    /// Gets an immutable reference to the numerator.\n    #[inline]\n    pub const fn numer(&self) -> &T {\n        &self.numer\n    }\n\n    /// Gets an immutable reference to the denominator.\n    #[inline]\n    pub const fn denom(&self) -> &T {\n        &self.denom\n    }\n}"],"RatioErrorKind":["Clone","Copy","Debug","PartialEq","impl RatioErrorKind {\n    fn description(&self) -> &'static str {\n        match *self {\n            RatioErrorKind::ParseError => \"failed to parse integer\",\n            RatioErrorKind::ZeroDenominator => \"zero value denominator\",\n        }\n    }\n}"],"num_bigint::BigInt":["impl Bits for BigInt {\n    fn bits(&self) -> u64 {\n        self.bits()\n    }\n}"]},"single_path_import":{},"srcs":{"<&'a Ratio<T> as core::ops::Add<&'b Ratio<T>>>::add":["#[inline]\nfn $method(self, other: &'b Ratio<T>) -> Ratio<T>{\n                self.clone().$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Add<&'b T>>::add":["#[inline]\nfn $method(self, other: &'b T) -> Ratio<T>{\n                self.clone().$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Add<Ratio<T>>>::add":["#[inline]\nfn $method(self, other: Ratio<T>) -> Ratio<T>{\n                self.clone().$method(other)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Add<T>>::add":["#[inline]\nfn $method(self, other: T) -> Ratio<T>{\n                self.clone().$method(other)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Div<&'b Ratio<T>>>::div":["#[inline]\nfn $method(self, other: &'b Ratio<T>) -> Ratio<T>{\n                self.clone().$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Div<&'b T>>::div":["#[inline]\nfn $method(self, other: &'b T) -> Ratio<T>{\n                self.clone().$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Div<Ratio<T>>>::div":["#[inline]\nfn $method(self, other: Ratio<T>) -> Ratio<T>{\n                self.clone().$method(other)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Div<T>>::div":["#[inline]\nfn $method(self, other: T) -> Ratio<T>{\n                self.clone().$method(other)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Mul<&'b Ratio<T>>>::mul":["#[inline]\nfn $method(self, other: &'b Ratio<T>) -> Ratio<T>{\n                self.clone().$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Mul<&'b T>>::mul":["#[inline]\nfn $method(self, other: &'b T) -> Ratio<T>{\n                self.clone().$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Mul<Ratio<T>>>::mul":["#[inline]\nfn $method(self, other: Ratio<T>) -> Ratio<T>{\n                self.clone().$method(other)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Mul<T>>::mul":["#[inline]\nfn $method(self, other: T) -> Ratio<T>{\n                self.clone().$method(other)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Neg>::neg":["#[inline]\nfn neg(self) -> Ratio<T>{\n        -self.clone()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Rem<&'b Ratio<T>>>::rem":["#[inline]\nfn $method(self, other: &'b Ratio<T>) -> Ratio<T>{\n                self.clone().$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Rem<&'b T>>::rem":["#[inline]\nfn $method(self, other: &'b T) -> Ratio<T>{\n                self.clone().$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Rem<Ratio<T>>>::rem":["#[inline]\nfn $method(self, other: Ratio<T>) -> Ratio<T>{\n                self.clone().$method(other)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Rem<T>>::rem":["#[inline]\nfn $method(self, other: T) -> Ratio<T>{\n                self.clone().$method(other)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Sub<&'b Ratio<T>>>::sub":["#[inline]\nfn $method(self, other: &'b Ratio<T>) -> Ratio<T>{\n                self.clone().$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Sub<&'b T>>::sub":["#[inline]\nfn $method(self, other: &'b T) -> Ratio<T>{\n                self.clone().$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Sub<Ratio<T>>>::sub":["#[inline]\nfn $method(self, other: Ratio<T>) -> Ratio<T>{\n                self.clone().$method(other)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as core::ops::Sub<T>>::sub":["#[inline]\nfn $method(self, other: T) -> Ratio<T>{\n                self.clone().$method(other)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a Ratio<T> as num_traits::Inv>::inv":["#[inline]\nfn inv(self) -> Ratio<T>{\n        self.recip()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<ParseRatioError as core::error::Error>::description":["#[allow(deprecated)]\nfn description(&self) -> &str{\n        self.kind.description()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<ParseRatioError as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        self.kind.description().fmt(f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::cmp::Ord>::cmp":["#[inline]\nfn cmp(&self, other: &Self) -> cmp::Ordering{\n        // With equal denominators, the numerators can be directly compared\n        if self.denom == other.denom {\n            let ord = self.numer.cmp(&other.numer);\n            return if self.denom < T::zero() {\n                ord.reverse()\n            } else {\n                ord\n            };\n        }\n\n        // With equal numerators, the denominators can be inversely compared\n        if self.numer == other.numer {\n            if self.numer.is_zero() {\n                return cmp::Ordering::Equal;\n            }\n            let ord = self.denom.cmp(&other.denom);\n            return if self.numer < T::zero() {\n                ord\n            } else {\n                ord.reverse()\n            };\n        }\n\n        // Unfortunately, we don't have CheckedMul to try.  That could sometimes avoid all the\n        // division below, or even always avoid it for BigInt and BigUint.\n        // FIXME- future breaking change to add Checked* to Integer?\n\n        // Compare as floored integers and remainders\n        let (self_int, self_rem) = self.numer.div_mod_floor(&self.denom);\n        let (other_int, other_rem) = other.numer.div_mod_floor(&other.denom);\n        match self_int.cmp(&other_int) {\n            cmp::Ordering::Greater => cmp::Ordering::Greater,\n            cmp::Ordering::Less => cmp::Ordering::Less,\n            cmp::Ordering::Equal => {\n                match (self_rem.is_zero(), other_rem.is_zero()) {\n                    (true, true) => cmp::Ordering::Equal,\n                    (true, false) => cmp::Ordering::Less,\n                    (false, true) => cmp::Ordering::Greater,\n                    (false, false) => {\n                        // Compare the reciprocals of the remaining fractions in reverse\n                        let self_recip = Ratio::new_raw(self.denom.clone(), self_rem);\n                        let other_recip = Ratio::new_raw(other.denom.clone(), other_rem);\n                        self_recip.cmp(&other_recip).reverse()\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::cmp::PartialEq>::eq":["#[inline]\nfn eq(&self, other: &Self) -> bool{\n        self.cmp(other) == cmp::Ordering::Equal\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::cmp::PartialOrd>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::convert::From<(T, T)>>::from":["fn from(pair: (T, T)) -> Ratio<T>{\n        Ratio::new(pair.0, pair.1)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::convert::From<T>>::from":["fn from(x: T) -> Ratio<T>{\n        Ratio::from_integer(x)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::convert::Into<(T, T)>>::into":["fn into(self) -> (T, T){\n        (self.numer, self.denom)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::fmt::Binary>::fmt":["#[cfg(feature = \"std\")]\nfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n                let pre_pad = if self.denom.is_one() {\n                    format!($fmt_str, self.numer)\n                } else {\n                    if f.alternate() {\n                        format!(concat!($fmt_str, \"/\", $fmt_alt), self.numer, self.denom)\n                    } else {\n                        format!(concat!($fmt_str, \"/\", $fmt_str), self.numer, self.denom)\n                    }\n                };\n                // TODO: replace with strip_prefix, when stabalized\n                let (pre_pad, non_negative) = {\n                    if pre_pad.starts_with(\"-\") {\n                        (&pre_pad[1..], false)\n                    } else {\n                        (&pre_pad[..], true)\n                    }\n                };\n                f.pad_integral(non_negative, $prefix, pre_pad)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::fmt::Display>::fmt":["#[cfg(feature = \"std\")]\nfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n                let pre_pad = if self.denom.is_one() {\n                    format!($fmt_str, self.numer)\n                } else {\n                    if f.alternate() {\n                        format!(concat!($fmt_str, \"/\", $fmt_alt), self.numer, self.denom)\n                    } else {\n                        format!(concat!($fmt_str, \"/\", $fmt_str), self.numer, self.denom)\n                    }\n                };\n                // TODO: replace with strip_prefix, when stabalized\n                let (pre_pad, non_negative) = {\n                    if pre_pad.starts_with(\"-\") {\n                        (&pre_pad[1..], false)\n                    } else {\n                        (&pre_pad[..], true)\n                    }\n                };\n                f.pad_integral(non_negative, $prefix, pre_pad)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::fmt::LowerExp>::fmt":["#[cfg(feature = \"std\")]\nfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n                let pre_pad = if self.denom.is_one() {\n                    format!($fmt_str, self.numer)\n                } else {\n                    if f.alternate() {\n                        format!(concat!($fmt_str, \"/\", $fmt_alt), self.numer, self.denom)\n                    } else {\n                        format!(concat!($fmt_str, \"/\", $fmt_str), self.numer, self.denom)\n                    }\n                };\n                // TODO: replace with strip_prefix, when stabalized\n                let (pre_pad, non_negative) = {\n                    if pre_pad.starts_with(\"-\") {\n                        (&pre_pad[1..], false)\n                    } else {\n                        (&pre_pad[..], true)\n                    }\n                };\n                f.pad_integral(non_negative, $prefix, pre_pad)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::fmt::LowerHex>::fmt":["#[cfg(feature = \"std\")]\nfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n                let pre_pad = if self.denom.is_one() {\n                    format!($fmt_str, self.numer)\n                } else {\n                    if f.alternate() {\n                        format!(concat!($fmt_str, \"/\", $fmt_alt), self.numer, self.denom)\n                    } else {\n                        format!(concat!($fmt_str, \"/\", $fmt_str), self.numer, self.denom)\n                    }\n                };\n                // TODO: replace with strip_prefix, when stabalized\n                let (pre_pad, non_negative) = {\n                    if pre_pad.starts_with(\"-\") {\n                        (&pre_pad[1..], false)\n                    } else {\n                        (&pre_pad[..], true)\n                    }\n                };\n                f.pad_integral(non_negative, $prefix, pre_pad)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::fmt::Octal>::fmt":["#[cfg(feature = \"std\")]\nfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n                let pre_pad = if self.denom.is_one() {\n                    format!($fmt_str, self.numer)\n                } else {\n                    if f.alternate() {\n                        format!(concat!($fmt_str, \"/\", $fmt_alt), self.numer, self.denom)\n                    } else {\n                        format!(concat!($fmt_str, \"/\", $fmt_str), self.numer, self.denom)\n                    }\n                };\n                // TODO: replace with strip_prefix, when stabalized\n                let (pre_pad, non_negative) = {\n                    if pre_pad.starts_with(\"-\") {\n                        (&pre_pad[1..], false)\n                    } else {\n                        (&pre_pad[..], true)\n                    }\n                };\n                f.pad_integral(non_negative, $prefix, pre_pad)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::fmt::UpperExp>::fmt":["#[cfg(feature = \"std\")]\nfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n                let pre_pad = if self.denom.is_one() {\n                    format!($fmt_str, self.numer)\n                } else {\n                    if f.alternate() {\n                        format!(concat!($fmt_str, \"/\", $fmt_alt), self.numer, self.denom)\n                    } else {\n                        format!(concat!($fmt_str, \"/\", $fmt_str), self.numer, self.denom)\n                    }\n                };\n                // TODO: replace with strip_prefix, when stabalized\n                let (pre_pad, non_negative) = {\n                    if pre_pad.starts_with(\"-\") {\n                        (&pre_pad[1..], false)\n                    } else {\n                        (&pre_pad[..], true)\n                    }\n                };\n                f.pad_integral(non_negative, $prefix, pre_pad)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::fmt::UpperHex>::fmt":["#[cfg(feature = \"std\")]\nfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result{\n                let pre_pad = if self.denom.is_one() {\n                    format!($fmt_str, self.numer)\n                } else {\n                    if f.alternate() {\n                        format!(concat!($fmt_str, \"/\", $fmt_alt), self.numer, self.denom)\n                    } else {\n                        format!(concat!($fmt_str, \"/\", $fmt_str), self.numer, self.denom)\n                    }\n                };\n                // TODO: replace with strip_prefix, when stabalized\n                let (pre_pad, non_negative) = {\n                    if pre_pad.starts_with(\"-\") {\n                        (&pre_pad[1..], false)\n                    } else {\n                        (&pre_pad[..], true)\n                    }\n                };\n                f.pad_integral(non_negative, $prefix, pre_pad)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::hash::Hash>::hash":["fn hash<H: Hasher>(&self, state: &mut H){\n        recurse(&self.numer, &self.denom, state);\n\n        fn recurse<T: Integer + Hash, H: Hasher>(numer: &T, denom: &T, state: &mut H) {\n            if !denom.is_zero() {\n                let (int, rem) = numer.div_mod_floor(denom);\n                int.hash(state);\n                recurse(denom, &rem, state);\n            } else {\n                denom.hash(state);\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::hash::Hash>::hash::recurse":["fn recurse<T: Integer + Hash, H: Hasher>(numer: &T, denom: &T, state: &mut H){\n            if !denom.is_zero() {\n                let (int, rem) = numer.div_mod_floor(denom);\n                int.hash(state);\n                recurse(denom, &rem, state);\n            } else {\n                denom.hash(state);\n            }\n        }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Add<&'a Ratio<T>>>::add":["#[inline]\nfn $method(self, other: &Ratio<T>) -> Ratio<T>{\n                self.$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Add<&'a T>>::add":["#[inline]\nfn $method(self, other: &T) -> Ratio<T>{\n                self.$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Add<T>>::add":["#[inline]\nfn $method(self, rhs: T) -> Ratio<T>{\n                Ratio::new(self.numer.$method(self.denom.clone() * rhs), self.denom)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Add>::add":["#[inline]\nfn $method(self, rhs: Ratio<T>) -> Ratio<T>{\n                if self.denom == rhs.denom {\n                    return Ratio::new(self.numer.$method(rhs.numer), rhs.denom);\n                }\n                let lcm = self.denom.lcm(&rhs.denom);\n                let lhs_numer = self.numer * (lcm.clone() / self.denom);\n                let rhs_numer = rhs.numer * (lcm.clone() / rhs.denom);\n                Ratio::new(lhs_numer.$method(rhs_numer), lcm)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Div<&'a Ratio<T>>>::div":["#[inline]\nfn $method(self, other: &Ratio<T>) -> Ratio<T>{\n                self.$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Div<&'a T>>::div":["#[inline]\nfn $method(self, other: &T) -> Ratio<T>{\n                self.$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Div<T>>::div":["#[inline]\nfn div(self, rhs: T) -> Ratio<T>{\n        let gcd = self.numer.gcd(&rhs);\n        Ratio::new(self.numer / gcd.clone(), self.denom * (rhs / gcd))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Div>::div":["#[inline]\nfn div(self, rhs: Ratio<T>) -> Ratio<T>{\n        let gcd_ac = self.numer.gcd(&rhs.numer);\n        let gcd_bd = self.denom.gcd(&rhs.denom);\n        Ratio::new(\n            self.numer / gcd_ac.clone() * (rhs.denom / gcd_bd.clone()),\n            self.denom / gcd_bd * (rhs.numer / gcd_ac),\n        )\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Mul<&'a Ratio<T>>>::mul":["#[inline]\nfn $method(self, other: &Ratio<T>) -> Ratio<T>{\n                self.$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Mul<&'a T>>::mul":["#[inline]\nfn $method(self, other: &T) -> Ratio<T>{\n                self.$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Mul<T>>::mul":["#[inline]\nfn mul(self, rhs: T) -> Ratio<T>{\n        let gcd = self.denom.gcd(&rhs);\n        Ratio::new(self.numer * (rhs / gcd.clone()), self.denom / gcd)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Mul>::mul":["#[inline]\nfn mul(self, rhs: Ratio<T>) -> Ratio<T>{\n        let gcd_ad = self.numer.gcd(&rhs.denom);\n        let gcd_bc = self.denom.gcd(&rhs.numer);\n        Ratio::new(\n            self.numer / gcd_ad.clone() * (rhs.numer / gcd_bc.clone()),\n            self.denom / gcd_bc * (rhs.denom / gcd_ad),\n        )\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Neg>::neg":["#[inline]\nfn neg(self) -> Ratio<T>{\n        Ratio::new_raw(-self.numer, self.denom)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Rem<&'a Ratio<T>>>::rem":["#[inline]\nfn $method(self, other: &Ratio<T>) -> Ratio<T>{\n                self.$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Rem<&'a T>>::rem":["#[inline]\nfn $method(self, other: &T) -> Ratio<T>{\n                self.$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Rem<T>>::rem":["#[inline]\nfn $method(self, rhs: T) -> Ratio<T>{\n                Ratio::new(self.numer.$method(self.denom.clone() * rhs), self.denom)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Rem>::rem":["#[inline]\nfn $method(self, rhs: Ratio<T>) -> Ratio<T>{\n                if self.denom == rhs.denom {\n                    return Ratio::new(self.numer.$method(rhs.numer), rhs.denom);\n                }\n                let lcm = self.denom.lcm(&rhs.denom);\n                let lhs_numer = self.numer * (lcm.clone() / self.denom);\n                let rhs_numer = rhs.numer * (lcm.clone() / rhs.denom);\n                Ratio::new(lhs_numer.$method(rhs_numer), lcm)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Sub<&'a Ratio<T>>>::sub":["#[inline]\nfn $method(self, other: &Ratio<T>) -> Ratio<T>{\n                self.$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Sub<&'a T>>::sub":["#[inline]\nfn $method(self, other: &T) -> Ratio<T>{\n                self.$method(other.clone())\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Sub<T>>::sub":["#[inline]\nfn $method(self, rhs: T) -> Ratio<T>{\n                Ratio::new(self.numer.$method(self.denom.clone() * rhs), self.denom)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::ops::Sub>::sub":["#[inline]\nfn $method(self, rhs: Ratio<T>) -> Ratio<T>{\n                if self.denom == rhs.denom {\n                    return Ratio::new(self.numer.$method(rhs.numer), rhs.denom);\n                }\n                let lcm = self.denom.lcm(&rhs.denom);\n                let lhs_numer = self.numer * (lcm.clone() / self.denom);\n                let rhs_numer = rhs.numer * (lcm.clone() / rhs.denom);\n                Ratio::new(lhs_numer.$method(rhs_numer), lcm)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as core::str::FromStr>::from_str":["/// Parses `numer/denom` or just `numer`.\nfn from_str(s: &str) -> Result<Ratio<T>, ParseRatioError>{\n        let mut split = s.splitn(2, '/');\n\n        let n = split.next().ok_or(ParseRatioError {\n            kind: RatioErrorKind::ParseError,\n        })?;\n        let num = FromStr::from_str(n).map_err(|_| ParseRatioError {\n            kind: RatioErrorKind::ParseError,\n        })?;\n\n        let d = split.next().unwrap_or(\"1\");\n        let den = FromStr::from_str(d).map_err(|_| ParseRatioError {\n            kind: RatioErrorKind::ParseError,\n        })?;\n\n        if Zero::is_zero(&den) {\n            Err(ParseRatioError {\n                kind: RatioErrorKind::ZeroDenominator,\n            })\n        } else {\n            Ok(Ratio::new(num, den))\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, rhs: &Ratio<T>) -> Option<Ratio<T>>{\n                let gcd = self.denom.clone().gcd(&rhs.denom);\n                let lcm = (self.denom.clone() / gcd.clone()).checked_mul(&rhs.denom)?;\n                let lhs_numer = (lcm.clone() / self.denom.clone()).checked_mul(&self.numer)?;\n                let rhs_numer = (lcm.clone() / rhs.denom.clone()).checked_mul(&rhs.numer)?;\n                Some(Ratio::new(lhs_numer.$method(&rhs_numer)?, lcm))\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::CheckedDiv>::checked_div":["#[inline]\nfn checked_div(&self, rhs: &Ratio<T>) -> Option<Ratio<T>>{\n        if rhs.is_zero() {\n            return None;\n        }\n        let (numer, denom) = if self.denom == rhs.denom {\n            (self.numer.clone(), rhs.numer.clone())\n        } else if self.numer == rhs.numer {\n            (rhs.denom.clone(), self.denom.clone())\n        } else {\n            let gcd_ac = self.numer.gcd(&rhs.numer);\n            let gcd_bd = self.denom.gcd(&rhs.denom);\n            (\n                (self.numer.clone() / gcd_ac.clone())\n                    .checked_mul(&(rhs.denom.clone() / gcd_bd.clone()))?,\n                (self.denom.clone() / gcd_bd).checked_mul(&(rhs.numer.clone() / gcd_ac))?,\n            )\n        };\n        // Manual `reduce()`, avoiding sharp edges\n        if denom.is_zero() {\n            None\n        } else if numer.is_zero() {\n            Some(Self::zero())\n        } else if numer == denom {\n            Some(Self::one())\n        } else {\n            let g = numer.gcd(&denom);\n            let numer = numer / g.clone();\n            let denom = denom / g;\n            let raw = if denom < T::zero() {\n                // We need to keep denom positive, but 2's-complement MIN may\n                // overflow negation -- instead we can check multiplying -1.\n                let n1 = T::zero() - T::one();\n                Ratio::new_raw(numer.checked_mul(&n1)?, denom.checked_mul(&n1)?)\n            } else {\n                Ratio::new_raw(numer, denom)\n            };\n            Some(raw)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::CheckedMul>::checked_mul":["#[inline]\nfn checked_mul(&self, rhs: &Ratio<T>) -> Option<Ratio<T>>{\n        let gcd_ad = self.numer.gcd(&rhs.denom);\n        let gcd_bc = self.denom.gcd(&rhs.numer);\n        Some(Ratio::new(\n            (self.numer.clone() / gcd_ad.clone())\n                .checked_mul(&(rhs.numer.clone() / gcd_bc.clone()))?,\n            (self.denom.clone() / gcd_bc).checked_mul(&(rhs.denom.clone() / gcd_ad))?,\n        ))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, rhs: &Ratio<T>) -> Option<Ratio<T>>{\n                let gcd = self.denom.clone().gcd(&rhs.denom);\n                let lcm = (self.denom.clone() / gcd.clone()).checked_mul(&rhs.denom)?;\n                let lhs_numer = (lcm.clone() / self.denom.clone()).checked_mul(&self.numer)?;\n                let rhs_numer = (lcm.clone() / rhs.denom.clone()).checked_mul(&rhs.numer)?;\n                Some(Ratio::new(lhs_numer.$method(&rhs_numer)?, lcm))\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::Inv>::inv":["#[inline]\nfn inv(self) -> Ratio<T>{\n        self.recip()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::Num>::from_str_radix":["/// Parses `numer/denom` where the numbers are in base `radix`.\nfn from_str_radix(s: &str, radix: u32) -> Result<Ratio<T>, ParseRatioError>{\n        if s.splitn(2, '/').count() == 2 {\n            let mut parts = s.splitn(2, '/').map(|ss| {\n                T::from_str_radix(ss, radix).map_err(|_| ParseRatioError {\n                    kind: RatioErrorKind::ParseError,\n                })\n            });\n            let numer: T = parts.next().unwrap()?;\n            let denom: T = parts.next().unwrap()?;\n            if denom.is_zero() {\n                Err(ParseRatioError {\n                    kind: RatioErrorKind::ZeroDenominator,\n                })\n            } else {\n                Ok(Ratio::new(numer, denom))\n            }\n        } else {\n            Err(ParseRatioError {\n                kind: RatioErrorKind::ParseError,\n            })\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n        self.numer == self.denom\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::One>::one":["#[inline]\nfn one() -> Ratio<T>{\n        Ratio::new_raw(One::one(), One::one())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::One>::set_one":["#[inline]\nfn set_one(&mut self){\n        self.numer.set_one();\n        self.denom.set_one();\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::Signed>::abs":["#[inline]\nfn abs(&self) -> Ratio<T>{\n        if self.is_negative() {\n            -self.clone()\n        } else {\n            self.clone()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::Signed>::abs_sub":["#[inline]\nfn abs_sub(&self, other: &Ratio<T>) -> Ratio<T>{\n        if *self <= *other {\n            Zero::zero()\n        } else {\n            self - other\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::Signed>::is_negative":["#[inline]\nfn is_negative(&self) -> bool{\n        (self.numer.is_negative() && self.denom.is_positive())\n            || (self.numer.is_positive() && self.denom.is_negative())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::Signed>::is_positive":["#[inline]\nfn is_positive(&self) -> bool{\n        (self.numer.is_positive() && self.denom.is_positive())\n            || (self.numer.is_negative() && self.denom.is_negative())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::Signed>::signum":["#[inline]\nfn signum(&self) -> Ratio<T>{\n        if self.is_positive() {\n            Self::one()\n        } else if self.is_zero() {\n            Self::zero()\n        } else {\n            -Self::one()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::ToPrimitive>::to_f64":["fn to_f64(&self) -> Option<f64>{\n        let float = match (self.numer.to_i64(), self.denom.to_i64()) {\n            (Some(numer), Some(denom)) => ratio_to_f64(\n                <i128 as From<_>>::from(numer),\n                <i128 as From<_>>::from(denom),\n            ),\n            _ => {\n                let numer: BigInt = self.numer.to_bigint()?;\n                let denom: BigInt = self.denom.to_bigint()?;\n                ratio_to_f64(numer, denom)\n            }\n        };\n        if float.is_nan() {\n            None\n        } else {\n            Some(float)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::ToPrimitive>::to_i128":["fn to_i128(&self) -> Option<i128>{\n        self.to_integer().to_i128()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::ToPrimitive>::to_i64":["fn to_i64(&self) -> Option<i64>{\n        self.to_integer().to_i64()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::ToPrimitive>::to_u128":["fn to_u128(&self) -> Option<u128>{\n        self.to_integer().to_u128()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::ToPrimitive>::to_u64":["fn to_u64(&self) -> Option<u64>{\n        self.to_integer().to_u64()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n        self.numer.is_zero()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::Zero>::set_zero":["#[inline]\nfn set_zero(&mut self){\n        self.numer.set_zero();\n        self.denom.set_one();\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<T> as num_traits::Zero>::zero":["#[inline]\nfn zero() -> Ratio<T>{\n        Ratio::new_raw(Zero::zero(), One::one())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i128> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i128> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i128> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i128> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i128> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i128> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i16> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i16> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i16> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i16> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i16> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i16> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i32> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i32> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i32> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i32> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i32> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i32> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i64> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i64> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i64> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i64> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i64> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i64> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i8> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i8> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i8> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i8> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i8> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<i8> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<isize> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<isize> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<isize> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<isize> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<isize> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<isize> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n        Ratio::from_float(n)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n        Ratio::from_float(n)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n        Some(Ratio::from_integer(n.into()))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n        Some(Ratio::from_integer(n.into()))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n        Some(Ratio::from_integer(n.into()))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n        Some(Ratio::from_integer(n.into()))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u128> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u128> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u128> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u128> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u128> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u128> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u16> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u16> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u16> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u16> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u16> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u16> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u32> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u32> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u32> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u32> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u32> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u32> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u64> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u64> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u64> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u64> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u64> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u64> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u8> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u8> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u8> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u8> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u8> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<u8> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<usize> as num_traits::FromPrimitive>::from_f32":["fn from_f32(n: f32) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<usize> as num_traits::FromPrimitive>::from_f64":["fn from_f64(n: f64) -> Option<Self>{\n                $approx(n, 10e-20, 30)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<usize> as num_traits::FromPrimitive>::from_i128":["fn from_i128(n: i128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<usize> as num_traits::FromPrimitive>::from_i64":["fn from_i64(n: i64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<usize> as num_traits::FromPrimitive>::from_u128":["fn from_u128(n: u128) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Ratio<usize> as num_traits::FromPrimitive>::from_u64":["fn from_u64(n: u64) -> Option<Self>{\n                <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<i128 as Bits>::bits":["fn bits(&self) -> u64{\n        (128 - self.wrapping_abs().leading_zeros()).into()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<num_bigint::BigInt as Bits>::bits":["fn bits(&self) -> u64{\n        self.bits()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Bits":["trait Bits {\n    fn bits(&self) -> u64;\n}","Real(LocalPath(\"src/lib.rs\"))"],"ParseRatioError":["pub struct ParseRatioError {\n    kind: RatioErrorKind,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Ratio":["/// Represents the ratio between two numbers.\n#[allow(missing_docs)]\npub struct Ratio<T> {\n    /// Numerator.\n    numer: T,\n    /// Denominator.\n    denom: T,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::approximate_float":["pub fn approximate_float<F: FloatCore + NumCast>(f: F) -> Option<Ratio<T>>{\n        // 1/10e-20 < 1/2**32 which seems like a good default, and 30 seems\n        // to work well. Might want to choose something based on the types in the future, e.g.\n        // T::max().recip() and T::bits() or something similar.\n        let epsilon = <F as NumCast>::from(10e-20).expect(\"Can't convert 10e-20\");\n        approximate_float(f, epsilon, 30)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::ceil":["/// Rounds towards plus infinity.\n#[inline]\npub fn ceil(&self) -> Ratio<T>{\n        if *self < Zero::zero() {\n            Ratio::from_integer(self.numer.clone() / self.denom.clone())\n        } else {\n            let one: T = One::one();\n            Ratio::from_integer(\n                (self.numer.clone() + self.denom.clone() - one) / self.denom.clone(),\n            )\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::denom":["/// Gets an immutable reference to the denominator.\n#[inline]\npub const fn denom(&self) -> &T{\n        &self.denom\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::floor":["/// Rounds towards minus infinity.\n#[inline]\npub fn floor(&self) -> Ratio<T>{\n        if *self < Zero::zero() {\n            let one: T = One::one();\n            Ratio::from_integer(\n                (self.numer.clone() - self.denom.clone() + one) / self.denom.clone(),\n            )\n        } else {\n            Ratio::from_integer(self.numer.clone() / self.denom.clone())\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::fract":["/// Returns the fractional part of a number, with division rounded towards zero.\n///\n/// Satisfies `self == self.trunc() + self.fract()`.\n#[inline]\npub fn fract(&self) -> Ratio<T>{\n        Ratio::new_raw(self.numer.clone() % self.denom.clone(), self.denom.clone())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::from_integer":["/// Creates a `Ratio` representing the integer `t`.\n#[inline]\npub fn from_integer(t: T) -> Ratio<T>{\n        Ratio::new_raw(t, One::one())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::into_recip":["#[inline]\nfn into_recip(self) -> Ratio<T>{\n        match self.numer.cmp(&T::zero()) {\n            cmp::Ordering::Equal => panic!(\"division by zero\"),\n            cmp::Ordering::Greater => Ratio::new_raw(self.denom, self.numer),\n            cmp::Ordering::Less => Ratio::new_raw(T::zero() - self.denom, T::zero() - self.numer),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::is_integer":["/// Returns true if the rational number is an integer (denominator is 1).\n#[inline]\npub fn is_integer(&self) -> bool{\n        self.denom.is_one()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::new":["/// Creates a new `Ratio`.\n///\n/// **Panics if `denom` is zero.**\n#[inline]\npub fn new(numer: T, denom: T) -> Ratio<T>{\n        let mut ret = Ratio::new_raw(numer, denom);\n        ret.reduce();\n        ret\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::new_raw":["/// Creates a `Ratio` without checking for `denom == 0` or reducing.\n///\n/// **There are several methods that will panic if used on a `Ratio` with\n/// `denom == 0`.**\n#[inline]\npub const fn new_raw(numer: T, denom: T) -> Ratio<T>{\n        Ratio { numer, denom }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::numer":["/// Gets an immutable reference to the numerator.\n#[inline]\npub const fn numer(&self) -> &T{\n        &self.numer\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::pow":["/// Raises the `Ratio` to the power of an exponent.\n#[inline]\npub fn pow(&self, expon: i32) -> Ratio<T>\n    where\n        for<'a> &'a T: Pow<u32, Output = T>,{\n        Pow::pow(self, expon)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::recip":["/// Returns the reciprocal.\n///\n/// **Panics if the `Ratio` is zero.**\n#[inline]\npub fn recip(&self) -> Ratio<T>{\n        self.clone().into_recip()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::reduce":["/// Puts self into lowest terms, with `denom` > 0.\n///\n/// **Panics if `denom` is zero.**\nfn reduce(&mut self){\n        if self.denom.is_zero() {\n            panic!(\"denominator == 0\");\n        }\n        if self.numer.is_zero() {\n            self.denom.set_one();\n            return;\n        }\n        if self.numer == self.denom {\n            self.set_one();\n            return;\n        }\n        let g: T = self.numer.gcd(&self.denom);\n\n        // FIXME(#5992): assignment operator overloads\n        // self.numer /= g;\n        // T: Clone + Integer != T: Clone + NumAssign\n        self.numer = self.numer.clone() / g.clone();\n        // FIXME(#5992): assignment operator overloads\n        // self.denom /= g;\n        // T: Clone + Integer != T: Clone + NumAssign\n        self.denom = self.denom.clone() / g;\n\n        // keep denom positive!\n        if self.denom < T::zero() {\n            self.numer = T::zero() - self.numer.clone();\n            self.denom = T::zero() - self.denom.clone();\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::reduced":["/// Returns a reduced copy of self.\n///\n/// In general, it is not necessary to use this method, as the only\n/// method of procuring a non-reduced fraction is through `new_raw`.\n///\n/// **Panics if `denom` is zero.**\npub fn reduced(&self) -> Ratio<T>{\n        let mut ret = self.clone();\n        ret.reduce();\n        ret\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::round":["/// Rounds to the nearest integer. Rounds half-way cases away from zero.\n#[inline]\npub fn round(&self) -> Ratio<T>{\n        let zero: Ratio<T> = Zero::zero();\n        let one: T = One::one();\n        let two: T = one.clone() + one.clone();\n\n        // Find unsigned fractional part of rational number\n        let mut fractional = self.fract();\n        if fractional < zero {\n            fractional = zero - fractional\n        };\n\n        // The algorithm compares the unsigned fractional part with 1/2, that\n        // is, a/b >= 1/2, or a >= b/2. For odd denominators, we use\n        // a >= (b/2)+1. This avoids overflow issues.\n        let half_or_larger = if fractional.denom.is_even() {\n            fractional.numer >= fractional.denom / two\n        } else {\n            fractional.numer >= (fractional.denom / two) + one\n        };\n\n        if half_or_larger {\n            let one: Ratio<T> = One::one();\n            if *self >= Zero::zero() {\n                self.trunc() + one\n            } else {\n                self.trunc() - one\n            }\n        } else {\n            self.trunc()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::to_integer":["/// Converts to an integer, rounding towards zero.\n#[inline]\npub fn to_integer(&self) -> T{\n        self.trunc().numer\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<T>::trunc":["/// Rounds towards zero.\n#[inline]\npub fn trunc(&self) -> Ratio<T>{\n        Ratio::from_integer(self.numer.clone() / self.denom.clone())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Ratio::<num_bigint::BigInt>::from_float":["/// Converts a float into a rational number.\npub fn from_float<T: FloatCore>(f: T) -> Option<BigRational>{\n        if !f.is_finite() {\n            return None;\n        }\n        let (mantissa, exponent, sign) = f.integer_decode();\n        let bigint_sign = if sign == 1 { Sign::Plus } else { Sign::Minus };\n        if exponent < 0 {\n            let one: BigInt = One::one();\n            let denom: BigInt = one << ((-exponent) as usize);\n            let numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();\n            Some(Ratio::new(BigInt::from_biguint(bigint_sign, numer), denom))\n        } else {\n            let mut numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();\n            numer <<= exponent as usize;\n            Some(Ratio::from_integer(BigInt::from_biguint(\n                bigint_sign,\n                numer,\n            )))\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"RatioErrorKind":["enum RatioErrorKind {\n    ParseError,\n    ZeroDenominator,\n}","Real(LocalPath(\"src/lib.rs\"))"],"RatioErrorKind::description":["fn description(&self) -> &'static str{\n        match *self {\n            RatioErrorKind::ParseError => \"failed to parse integer\",\n            RatioErrorKind::ZeroDenominator => \"zero value denominator\",\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"approximate_float":["fn approximate_float<T, F>(val: F, max_error: F, max_iterations: usize) -> Option<Ratio<T>>\nwhere\n    T: Integer + Signed + Bounded + NumCast + Clone,\n    F: FloatCore + NumCast,{\n    let negative = val.is_sign_negative();\n    let abs_val = val.abs();\n\n    let r = approximate_float_unsigned(abs_val, max_error, max_iterations)?;\n\n    // Make negative again if needed\n    Some(if negative { r.neg() } else { r })\n}","Real(LocalPath(\"src/lib.rs\"))"],"approximate_float_unsigned":["fn approximate_float_unsigned<T, F>(val: F, max_error: F, max_iterations: usize) -> Option<Ratio<T>>\nwhere\n    T: Integer + Bounded + NumCast + Clone,\n    F: FloatCore + NumCast,{\n    // Continued fractions algorithm\n    // http://mathforum.org/dr.math/faq/faq.fractions.html#decfrac\n\n    if val < F::zero() || val.is_nan() {\n        return None;\n    }\n\n    let mut q = val;\n    let mut n0 = T::zero();\n    let mut d0 = T::one();\n    let mut n1 = T::one();\n    let mut d1 = T::zero();\n\n    let t_max = T::max_value();\n    let t_max_f = <F as NumCast>::from(t_max.clone())?;\n\n    // 1/epsilon > T::MAX\n    let epsilon = t_max_f.recip();\n\n    // Overflow\n    if q > t_max_f {\n        return None;\n    }\n\n    for _ in 0..max_iterations {\n        let a = match <T as NumCast>::from(q) {\n            None => break,\n            Some(a) => a,\n        };\n\n        let a_f = match <F as NumCast>::from(a.clone()) {\n            None => break,\n            Some(a_f) => a_f,\n        };\n        let f = q - a_f;\n\n        // Prevent overflow\n        if !a.is_zero()\n            && (n1 > t_max.clone() / a.clone()\n                || d1 > t_max.clone() / a.clone()\n                || a.clone() * n1.clone() > t_max.clone() - n0.clone()\n                || a.clone() * d1.clone() > t_max.clone() - d0.clone())\n        {\n            break;\n        }\n\n        let n = a.clone() * n1.clone() + n0.clone();\n        let d = a.clone() * d1.clone() + d0.clone();\n\n        n0 = n1;\n        d0 = d1;\n        n1 = n.clone();\n        d1 = d.clone();\n\n        // Simplify fraction. Doing so here instead of at the end\n        // allows us to get closer to the target value without overflows\n        let g = Integer::gcd(&n1, &d1);\n        if !g.is_zero() {\n            n1 = n1 / g.clone();\n            d1 = d1 / g.clone();\n        }\n\n        // Close enough?\n        let (n_f, d_f) = match (<F as NumCast>::from(n), <F as NumCast>::from(d)) {\n            (Some(n_f), Some(d_f)) => (n_f, d_f),\n            _ => break,\n        };\n        if (n_f / d_f - val).abs() < max_error {\n            break;\n        }\n\n        // Prevent division by ~0\n        if f < epsilon {\n            break;\n        }\n        q = f.recip();\n    }\n\n    // Overflow\n    if d1.is_zero() {\n        return None;\n    }\n\n    Some(Ratio::new(n1, d1))\n}","Real(LocalPath(\"src/lib.rs\"))"],"iter_sum_product::<impl core::iter::Product for Ratio<T>>::product":["fn product<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = Ratio<T>>,{\n            iter.fold(Self::one(), |prod, num| prod * num)\n        }","Real(LocalPath(\"src/lib.rs\"))"],"iter_sum_product::<impl core::iter::Product<&'a Ratio<T>> for Ratio<T>>::product":["fn product<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = &'a Ratio<T>>,{\n            iter.fold(Self::one(), |prod, num| prod * num)\n        }","Real(LocalPath(\"src/lib.rs\"))"],"iter_sum_product::<impl core::iter::Sum for Ratio<T>>::sum":["fn sum<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = Ratio<T>>,{\n            iter.fold(Self::zero(), |sum, num| sum + num)\n        }","Real(LocalPath(\"src/lib.rs\"))"],"iter_sum_product::<impl core::iter::Sum<&'a Ratio<T>> for Ratio<T>>::sum":["fn sum<I>(iter: I) -> Self\n        where\n            I: Iterator<Item = &'a Ratio<T>>,{\n            iter.fold(Self::zero(), |sum, num| sum + num)\n        }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::AddAssign for Ratio<T>>::add_assign":["fn add_assign(&mut self, other: Ratio<T>){\n            if self.denom == other.denom {\n                self.numer += other.numer\n            } else {\n                let lcm = self.denom.lcm(&other.denom);\n                let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());\n                let rhs_numer = other.numer * (lcm.clone() / other.denom);\n                self.numer = lhs_numer + rhs_numer;\n                self.denom = lcm;\n            }\n            self.reduce();\n        }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::AddAssign<&'a Ratio<T>> for Ratio<T>>::add_assign":["#[inline]\nfn $method(&mut self, other: &Ratio<T>){\n                    self.$method(other.clone())\n                }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::AddAssign<&'a T> for Ratio<T>>::add_assign":["#[inline]\nfn $method(&mut self, other: &T){\n                    self.$method(other.clone())\n                }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::AddAssign<T> for Ratio<T>>::add_assign":["fn add_assign(&mut self, other: T){\n            self.numer += self.denom.clone() * other;\n            self.reduce();\n        }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::DivAssign for Ratio<T>>::div_assign":["fn div_assign(&mut self, other: Ratio<T>){\n            let gcd_ac = self.numer.gcd(&other.numer);\n            let gcd_bd = self.denom.gcd(&other.denom);\n            self.numer /= gcd_ac.clone();\n            self.numer *= other.denom / gcd_bd.clone();\n            self.denom /= gcd_bd;\n            self.denom *= other.numer / gcd_ac;\n            self.reduce(); // TODO: remove this line. see #8.\n        }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::DivAssign<&'a Ratio<T>> for Ratio<T>>::div_assign":["#[inline]\nfn $method(&mut self, other: &Ratio<T>){\n                    self.$method(other.clone())\n                }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::DivAssign<&'a T> for Ratio<T>>::div_assign":["#[inline]\nfn $method(&mut self, other: &T){\n                    self.$method(other.clone())\n                }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::DivAssign<T> for Ratio<T>>::div_assign":["fn div_assign(&mut self, other: T){\n            let gcd = self.numer.gcd(&other);\n            self.numer /= gcd.clone();\n            self.denom *= other / gcd;\n            self.reduce(); // TODO: remove this line. see #8.\n        }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::MulAssign for Ratio<T>>::mul_assign":["fn mul_assign(&mut self, other: Ratio<T>){\n            let gcd_ad = self.numer.gcd(&other.denom);\n            let gcd_bc = self.denom.gcd(&other.numer);\n            self.numer /= gcd_ad.clone();\n            self.numer *= other.numer / gcd_bc.clone();\n            self.denom /= gcd_bc;\n            self.denom *= other.denom / gcd_ad;\n            self.reduce(); // TODO: remove this line. see #8.\n        }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::MulAssign<&'a Ratio<T>> for Ratio<T>>::mul_assign":["#[inline]\nfn $method(&mut self, other: &Ratio<T>){\n                    self.$method(other.clone())\n                }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::MulAssign<&'a T> for Ratio<T>>::mul_assign":["#[inline]\nfn $method(&mut self, other: &T){\n                    self.$method(other.clone())\n                }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::MulAssign<T> for Ratio<T>>::mul_assign":["fn mul_assign(&mut self, other: T){\n            let gcd = self.denom.gcd(&other);\n            self.denom /= gcd.clone();\n            self.numer *= other / gcd;\n            self.reduce(); // TODO: remove this line. see #8.\n        }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::RemAssign for Ratio<T>>::rem_assign":["fn rem_assign(&mut self, other: Ratio<T>){\n            if self.denom == other.denom {\n                self.numer %= other.numer\n            } else {\n                let lcm = self.denom.lcm(&other.denom);\n                let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());\n                let rhs_numer = other.numer * (lcm.clone() / other.denom);\n                self.numer = lhs_numer % rhs_numer;\n                self.denom = lcm;\n            }\n            self.reduce();\n        }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::RemAssign<&'a Ratio<T>> for Ratio<T>>::rem_assign":["#[inline]\nfn $method(&mut self, other: &Ratio<T>){\n                    self.$method(other.clone())\n                }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::RemAssign<&'a T> for Ratio<T>>::rem_assign":["#[inline]\nfn $method(&mut self, other: &T){\n                    self.$method(other.clone())\n                }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::RemAssign<T> for Ratio<T>>::rem_assign":["fn rem_assign(&mut self, other: T){\n            self.numer %= self.denom.clone() * other;\n            self.reduce();\n        }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::SubAssign for Ratio<T>>::sub_assign":["fn sub_assign(&mut self, other: Ratio<T>){\n            if self.denom == other.denom {\n                self.numer -= other.numer\n            } else {\n                let lcm = self.denom.lcm(&other.denom);\n                let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());\n                let rhs_numer = other.numer * (lcm.clone() / other.denom);\n                self.numer = lhs_numer - rhs_numer;\n                self.denom = lcm;\n            }\n            self.reduce();\n        }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::SubAssign<&'a Ratio<T>> for Ratio<T>>::sub_assign":["#[inline]\nfn $method(&mut self, other: &Ratio<T>){\n                    self.$method(other.clone())\n                }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::SubAssign<&'a T> for Ratio<T>>::sub_assign":["#[inline]\nfn $method(&mut self, other: &T){\n                    self.$method(other.clone())\n                }","Real(LocalPath(\"src/lib.rs\"))"],"opassign::<impl core::ops::SubAssign<T> for Ratio<T>>::sub_assign":["fn sub_assign(&mut self, other: T){\n            self.numer -= self.denom.clone() * other;\n            self.reduce();\n        }","Real(LocalPath(\"src/lib.rs\"))"],"pow::<impl num_traits::Pow<&'b i128> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b i128> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b i16> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b i16> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b i32> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b i32> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b i64> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b i64> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b i8> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b i8> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b isize> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b isize> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b u128> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b u128> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b u16> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b u16> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b u32> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b u32> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b u64> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b u64> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b u8> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b u8> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b usize> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<&'b usize> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b $exp) -> Ratio<T>{\n                Pow::pow(self, *expon)\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<i128> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<i128> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<i16> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<i16> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<i32> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<i32> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<i64> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<i64> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<i8> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<i8> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<isize> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<isize> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            match expon.cmp(&0) {\n                cmp::Ordering::Equal => One::one(),\n                cmp::Ordering::Less => {\n                    let expon = expon.wrapping_abs() as $unsigned;\n                    Pow::pow(self, expon).into_recip()\n                }\n                cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<u128> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<u128> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<u16> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<u16> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<u32> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<u32> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<u64> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<u64> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<u8> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<u8> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<usize> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::<impl num_traits::Pow<usize> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigInt> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b BigInt) -> Ratio<T>{\n            match expon.sign() {\n                Sign::NoSign => One::one(),\n                Sign::Minus => {\n                    Pow::pow(self, expon.magnitude()).into_recip()\n                }\n                Sign::Plus => Pow::pow(self, expon.magnitude()),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigInt> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: &'b BigInt) -> Ratio<T>{\n            match expon.sign() {\n                Sign::NoSign => One::one(),\n                Sign::Minus => {\n                    Pow::pow(self, expon.magnitude()).into_recip()\n                }\n                Sign::Plus => Pow::pow(self, expon.magnitude()),\n            }\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigUint> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigUint> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: $exp) -> Ratio<T>{\n            Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigInt> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: BigInt) -> Ratio<T>{\n            Pow::pow(self, &expon)\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigInt> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: BigInt) -> Ratio<T>{\n            Pow::pow(self, &expon)\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigUint> for &'a Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: BigUint) -> Ratio<T>{\n            Pow::pow(self, &expon)\n        }","Real(LocalPath(\"src/pow.rs\"))"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigUint> for Ratio<T>>::pow":["#[inline]\nfn pow(self, expon: BigUint) -> Ratio<T>{\n            Pow::pow(self, &expon)\n        }","Real(LocalPath(\"src/pow.rs\"))"],"ratio_to_f64":["/// Converts a ratio of `T` to an f64.\n///\n/// In addition to stated trait bounds, `T` must be able to hold numbers 56 bits larger than\n/// the largest of `numer` and `denom`. This is automatically true if `T` is `BigInt`.\nfn ratio_to_f64<T: Bits + Clone + Integer + Signed + ShlAssign<usize> + ToPrimitive>(\n    numer: T,\n    denom: T,\n) -> f64{\n    assert_eq!(\n        core::f64::RADIX,\n        2,\n        \"only floating point implementations with radix 2 are supported\"\n    );\n\n    // Inclusive upper and lower bounds to the range of exactly-representable ints in an f64.\n    const MAX_EXACT_INT: i64 = 1i64 << core::f64::MANTISSA_DIGITS;\n    const MIN_EXACT_INT: i64 = -MAX_EXACT_INT;\n\n    let flo_sign = numer.signum().to_f64().unwrap() / denom.signum().to_f64().unwrap();\n    if !flo_sign.is_normal() {\n        return flo_sign;\n    }\n\n    // Fast track: both sides can losslessly be converted to f64s. In this case, letting the\n    // FPU do the job is faster and easier. In any other case, converting to f64s may lead\n    // to an inexact result: https://stackoverflow.com/questions/56641441/.\n    if let (Some(n), Some(d)) = (numer.to_i64(), denom.to_i64()) {\n        if MIN_EXACT_INT <= n && n <= MAX_EXACT_INT && MIN_EXACT_INT <= d && d <= MAX_EXACT_INT {\n            return n.to_f64().unwrap() / d.to_f64().unwrap();\n        }\n    }\n\n    // Otherwise, the goal is to obtain a quotient with at least 55 bits. 53 of these bits will\n    // be used as the mantissa of the resulting float, and the remaining two are for rounding.\n    // There's an error of up to 1 on the number of resulting bits, so we may get either 55 or\n    // 56 bits.\n    let mut numer = numer.abs();\n    let mut denom = denom.abs();\n    let (is_diff_positive, absolute_diff) = match numer.bits().checked_sub(denom.bits()) {\n        Some(diff) => (true, diff),\n        None => (false, denom.bits() - numer.bits()),\n    };\n\n    // Filter out overflows and underflows. After this step, the signed difference fits in an\n    // isize.\n    if is_diff_positive && absolute_diff > core::f64::MAX_EXP as u64 {\n        return core::f64::INFINITY * flo_sign;\n    }\n    if !is_diff_positive\n        && absolute_diff > -core::f64::MIN_EXP as u64 + core::f64::MANTISSA_DIGITS as u64 + 1\n    {\n        return 0.0 * flo_sign;\n    }\n    let diff = if is_diff_positive {\n        absolute_diff.to_isize().unwrap()\n    } else {\n        -absolute_diff.to_isize().unwrap()\n    };\n\n    // Shift is chosen so that the quotient will have 55 or 56 bits. The exception is if the\n    // quotient is going to be subnormal, in which case it may have fewer bits.\n    let shift: isize =\n        diff.max(core::f64::MIN_EXP as isize) - core::f64::MANTISSA_DIGITS as isize - 2;\n    if shift >= 0 {\n        denom <<= shift as usize\n    } else {\n        numer <<= -shift as usize\n    };\n\n    let (quotient, remainder) = numer.div_rem(&denom);\n\n    // This is guaranteed to fit since we've set up quotient to be at most 56 bits.\n    let mut quotient = quotient.to_u64().unwrap();\n    let n_rounding_bits = {\n        let quotient_bits = 64 - quotient.leading_zeros() as isize;\n        let subnormal_bits = core::f64::MIN_EXP as isize - shift;\n        quotient_bits.max(subnormal_bits) - core::f64::MANTISSA_DIGITS as isize\n    } as usize;\n    debug_assert!(n_rounding_bits == 2 || n_rounding_bits == 3);\n    let rounding_bit_mask = (1u64 << n_rounding_bits) - 1;\n\n    // Round to 53 bits with round-to-even. For rounding, we need to take into account both\n    // our rounding bits and the division's remainder.\n    let ls_bit = quotient & (1u64 << n_rounding_bits) != 0;\n    let ms_rounding_bit = quotient & (1u64 << (n_rounding_bits - 1)) != 0;\n    let ls_rounding_bits = quotient & (rounding_bit_mask >> 1) != 0;\n    if ms_rounding_bit && (ls_bit || ls_rounding_bits || !remainder.is_zero()) {\n        quotient += 1u64 << n_rounding_bits;\n    }\n    quotient &= !rounding_bit_mask;\n\n    // The quotient is guaranteed to be exactly representable as it's now 53 bits + 2 or 3\n    // trailing zeros, so there is no risk of a rounding error here.\n    let q_float = quotient as f64;\n    q_float * 2f64.powi(shift as i32) * flo_sign\n}","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"&'static str":["description"],"&str":["description"],"(T, T)":["into"],"ParseRatioError":["clone"],"Ratio":["abs","abs_sub","add","ceil","clone","div","floor","fract","from","from_integer","inv","mul","neg","new","new_raw","one","pow","product","recip","reduced","rem","round","signum","sub","sum","trunc","zero"],"RatioErrorKind":["clone"],"bool":["eq","is_integer","is_negative","is_one","is_positive","is_zero"],"core::cmp::Ordering":["cmp"],"core::option::Option":["approximate_float","approximate_float_unsigned","checked_add","checked_div","checked_mul","checked_sub","from_f32","from_f64","from_float","from_i128","from_i64","from_u128","from_u64","partial_cmp","to_f64","to_i128","to_i64","to_u128","to_u64"],"core::result::Result":["fmt","from_str","from_str_radix"],"f64":["ratio_to_f64"],"u64":["bits"]},"struct_to_trait":{"ParseRatioError":["core::clone::Clone","core::cmp::PartialEq","core::error::Error","core::fmt::Debug","core::fmt::Display","core::marker::Copy","core::marker::StructuralPartialEq"],"Ratio":["core::clone::Clone","core::cmp::Eq","core::cmp::Ord","core::cmp::PartialEq","core::cmp::PartialOrd","core::convert::From","core::convert::Into","core::fmt::Binary","core::fmt::Debug","core::fmt::Display","core::fmt::LowerExp","core::fmt::LowerHex","core::fmt::Octal","core::fmt::UpperExp","core::fmt::UpperHex","core::hash::Hash","core::iter::Product","core::iter::Sum","core::marker::Copy","core::ops::Add","core::ops::AddAssign","core::ops::Div","core::ops::DivAssign","core::ops::Mul","core::ops::MulAssign","core::ops::Neg","core::ops::Rem","core::ops::RemAssign","core::ops::Sub","core::ops::SubAssign","core::str::FromStr","num_traits::CheckedAdd","num_traits::CheckedDiv","num_traits::CheckedMul","num_traits::CheckedSub","num_traits::FromPrimitive","num_traits::Inv","num_traits::Num","num_traits::One","num_traits::Pow","num_traits::Signed","num_traits::ToPrimitive","num_traits::Zero"],"RatioErrorKind":["core::clone::Clone","core::cmp::PartialEq","core::fmt::Debug","core::marker::Copy","core::marker::StructuralPartialEq"],"num_bigint::BigInt":["Bits"]},"targets":{"<&'a Ratio<T> as core::ops::Add<&'b Ratio<T>>>::add":["add","Real(LocalPath(\"src/lib.rs\"))","core::ops::Add"],"<&'a Ratio<T> as core::ops::Add<&'b T>>::add":["add","Real(LocalPath(\"src/lib.rs\"))","core::ops::Add"],"<&'a Ratio<T> as core::ops::Add<Ratio<T>>>::add":["add","Real(LocalPath(\"src/lib.rs\"))","core::ops::Add"],"<&'a Ratio<T> as core::ops::Add<T>>::add":["add","Real(LocalPath(\"src/lib.rs\"))","core::ops::Add"],"<&'a Ratio<T> as core::ops::Div<&'b Ratio<T>>>::div":["div","Real(LocalPath(\"src/lib.rs\"))","core::ops::Div"],"<&'a Ratio<T> as core::ops::Div<&'b T>>::div":["div","Real(LocalPath(\"src/lib.rs\"))","core::ops::Div"],"<&'a Ratio<T> as core::ops::Div<Ratio<T>>>::div":["div","Real(LocalPath(\"src/lib.rs\"))","core::ops::Div"],"<&'a Ratio<T> as core::ops::Div<T>>::div":["div","Real(LocalPath(\"src/lib.rs\"))","core::ops::Div"],"<&'a Ratio<T> as core::ops::Mul<&'b Ratio<T>>>::mul":["mul","Real(LocalPath(\"src/lib.rs\"))","core::ops::Mul"],"<&'a Ratio<T> as core::ops::Mul<&'b T>>::mul":["mul","Real(LocalPath(\"src/lib.rs\"))","core::ops::Mul"],"<&'a Ratio<T> as core::ops::Mul<Ratio<T>>>::mul":["mul","Real(LocalPath(\"src/lib.rs\"))","core::ops::Mul"],"<&'a Ratio<T> as core::ops::Mul<T>>::mul":["mul","Real(LocalPath(\"src/lib.rs\"))","core::ops::Mul"],"<&'a Ratio<T> as core::ops::Neg>::neg":["neg","Real(LocalPath(\"src/lib.rs\"))","core::ops::Neg"],"<&'a Ratio<T> as core::ops::Rem<&'b Ratio<T>>>::rem":["rem","Real(LocalPath(\"src/lib.rs\"))","core::ops::Rem"],"<&'a Ratio<T> as core::ops::Rem<&'b T>>::rem":["rem","Real(LocalPath(\"src/lib.rs\"))","core::ops::Rem"],"<&'a Ratio<T> as core::ops::Rem<Ratio<T>>>::rem":["rem","Real(LocalPath(\"src/lib.rs\"))","core::ops::Rem"],"<&'a Ratio<T> as core::ops::Rem<T>>::rem":["rem","Real(LocalPath(\"src/lib.rs\"))","core::ops::Rem"],"<&'a Ratio<T> as core::ops::Sub<&'b Ratio<T>>>::sub":["sub","Real(LocalPath(\"src/lib.rs\"))","core::ops::Sub"],"<&'a Ratio<T> as core::ops::Sub<&'b T>>::sub":["sub","Real(LocalPath(\"src/lib.rs\"))","core::ops::Sub"],"<&'a Ratio<T> as core::ops::Sub<Ratio<T>>>::sub":["sub","Real(LocalPath(\"src/lib.rs\"))","core::ops::Sub"],"<&'a Ratio<T> as core::ops::Sub<T>>::sub":["sub","Real(LocalPath(\"src/lib.rs\"))","core::ops::Sub"],"<&'a Ratio<T> as num_traits::Inv>::inv":["inv","Real(LocalPath(\"src/lib.rs\"))","num_traits::Inv"],"<ParseRatioError as core::error::Error>::description":["description","Real(LocalPath(\"src/lib.rs\"))","core::error::Error"],"<ParseRatioError as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Display"],"<Ratio<T> as core::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/lib.rs\"))","core::cmp::Ord"],"<Ratio<T> as core::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","core::cmp::PartialEq"],"<Ratio<T> as core::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/lib.rs\"))","core::cmp::PartialOrd"],"<Ratio<T> as core::convert::From<(T, T)>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","core::convert::From"],"<Ratio<T> as core::convert::From<T>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","core::convert::From"],"<Ratio<T> as core::convert::Into<(T, T)>>::into":["into","Real(LocalPath(\"src/lib.rs\"))","core::convert::Into"],"<Ratio<T> as core::fmt::Binary>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Binary"],"<Ratio<T> as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Display"],"<Ratio<T> as core::fmt::LowerExp>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::LowerExp"],"<Ratio<T> as core::fmt::LowerHex>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::LowerHex"],"<Ratio<T> as core::fmt::Octal>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Octal"],"<Ratio<T> as core::fmt::UpperExp>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::UpperExp"],"<Ratio<T> as core::fmt::UpperHex>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::UpperHex"],"<Ratio<T> as core::hash::Hash>::hash":["hash","Real(LocalPath(\"src/lib.rs\"))","core::hash::Hash"],"<Ratio<T> as core::hash::Hash>::hash::recurse":["recurse","Real(LocalPath(\"src/lib.rs\"))",""],"<Ratio<T> as core::ops::Add<&'a Ratio<T>>>::add":["add","Real(LocalPath(\"src/lib.rs\"))","core::ops::Add"],"<Ratio<T> as core::ops::Add<&'a T>>::add":["add","Real(LocalPath(\"src/lib.rs\"))","core::ops::Add"],"<Ratio<T> as core::ops::Add<T>>::add":["add","Real(LocalPath(\"src/lib.rs\"))","core::ops::Add"],"<Ratio<T> as core::ops::Add>::add":["add","Real(LocalPath(\"src/lib.rs\"))","core::ops::Add"],"<Ratio<T> as core::ops::Div<&'a Ratio<T>>>::div":["div","Real(LocalPath(\"src/lib.rs\"))","core::ops::Div"],"<Ratio<T> as core::ops::Div<&'a T>>::div":["div","Real(LocalPath(\"src/lib.rs\"))","core::ops::Div"],"<Ratio<T> as core::ops::Div<T>>::div":["div","Real(LocalPath(\"src/lib.rs\"))","core::ops::Div"],"<Ratio<T> as core::ops::Div>::div":["div","Real(LocalPath(\"src/lib.rs\"))","core::ops::Div"],"<Ratio<T> as core::ops::Mul<&'a Ratio<T>>>::mul":["mul","Real(LocalPath(\"src/lib.rs\"))","core::ops::Mul"],"<Ratio<T> as core::ops::Mul<&'a T>>::mul":["mul","Real(LocalPath(\"src/lib.rs\"))","core::ops::Mul"],"<Ratio<T> as core::ops::Mul<T>>::mul":["mul","Real(LocalPath(\"src/lib.rs\"))","core::ops::Mul"],"<Ratio<T> as core::ops::Mul>::mul":["mul","Real(LocalPath(\"src/lib.rs\"))","core::ops::Mul"],"<Ratio<T> as core::ops::Neg>::neg":["neg","Real(LocalPath(\"src/lib.rs\"))","core::ops::Neg"],"<Ratio<T> as core::ops::Rem<&'a Ratio<T>>>::rem":["rem","Real(LocalPath(\"src/lib.rs\"))","core::ops::Rem"],"<Ratio<T> as core::ops::Rem<&'a T>>::rem":["rem","Real(LocalPath(\"src/lib.rs\"))","core::ops::Rem"],"<Ratio<T> as core::ops::Rem<T>>::rem":["rem","Real(LocalPath(\"src/lib.rs\"))","core::ops::Rem"],"<Ratio<T> as core::ops::Rem>::rem":["rem","Real(LocalPath(\"src/lib.rs\"))","core::ops::Rem"],"<Ratio<T> as core::ops::Sub<&'a Ratio<T>>>::sub":["sub","Real(LocalPath(\"src/lib.rs\"))","core::ops::Sub"],"<Ratio<T> as core::ops::Sub<&'a T>>::sub":["sub","Real(LocalPath(\"src/lib.rs\"))","core::ops::Sub"],"<Ratio<T> as core::ops::Sub<T>>::sub":["sub","Real(LocalPath(\"src/lib.rs\"))","core::ops::Sub"],"<Ratio<T> as core::ops::Sub>::sub":["sub","Real(LocalPath(\"src/lib.rs\"))","core::ops::Sub"],"<Ratio<T> as core::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/lib.rs\"))","core::str::FromStr"],"<Ratio<T> as num_traits::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/lib.rs\"))","num_traits::CheckedAdd"],"<Ratio<T> as num_traits::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/lib.rs\"))","num_traits::CheckedDiv"],"<Ratio<T> as num_traits::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/lib.rs\"))","num_traits::CheckedMul"],"<Ratio<T> as num_traits::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/lib.rs\"))","num_traits::CheckedSub"],"<Ratio<T> as num_traits::Inv>::inv":["inv","Real(LocalPath(\"src/lib.rs\"))","num_traits::Inv"],"<Ratio<T> as num_traits::Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","num_traits::Num"],"<Ratio<T> as num_traits::One>::is_one":["is_one","Real(LocalPath(\"src/lib.rs\"))","num_traits::One"],"<Ratio<T> as num_traits::One>::one":["one","Real(LocalPath(\"src/lib.rs\"))","num_traits::One"],"<Ratio<T> as num_traits::One>::set_one":["set_one","Real(LocalPath(\"src/lib.rs\"))","num_traits::One"],"<Ratio<T> as num_traits::Signed>::abs":["abs","Real(LocalPath(\"src/lib.rs\"))","num_traits::Signed"],"<Ratio<T> as num_traits::Signed>::abs_sub":["abs_sub","Real(LocalPath(\"src/lib.rs\"))","num_traits::Signed"],"<Ratio<T> as num_traits::Signed>::is_negative":["is_negative","Real(LocalPath(\"src/lib.rs\"))","num_traits::Signed"],"<Ratio<T> as num_traits::Signed>::is_positive":["is_positive","Real(LocalPath(\"src/lib.rs\"))","num_traits::Signed"],"<Ratio<T> as num_traits::Signed>::signum":["signum","Real(LocalPath(\"src/lib.rs\"))","num_traits::Signed"],"<Ratio<T> as num_traits::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::ToPrimitive"],"<Ratio<T> as num_traits::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::ToPrimitive"],"<Ratio<T> as num_traits::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::ToPrimitive"],"<Ratio<T> as num_traits::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::ToPrimitive"],"<Ratio<T> as num_traits::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::ToPrimitive"],"<Ratio<T> as num_traits::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/lib.rs\"))","num_traits::Zero"],"<Ratio<T> as num_traits::Zero>::set_zero":["set_zero","Real(LocalPath(\"src/lib.rs\"))","num_traits::Zero"],"<Ratio<T> as num_traits::Zero>::zero":["zero","Real(LocalPath(\"src/lib.rs\"))","num_traits::Zero"],"<Ratio<i128> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i128> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i128> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i128> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i128> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i128> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i16> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i16> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i16> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i16> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i16> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i16> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i32> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i32> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i32> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i32> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i32> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i32> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i64> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i64> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i64> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i64> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i64> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i64> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i8> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i8> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i8> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i8> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i8> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<i8> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<isize> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<isize> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<isize> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<isize> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<isize> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<isize> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<num_bigint::BigInt> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u128> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u128> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u128> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u128> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u128> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u128> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u16> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u16> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u16> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u16> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u16> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u16> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u32> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u32> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u32> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u32> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u32> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u32> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u64> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u64> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u64> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u64> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u64> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u64> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u8> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u8> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u8> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u8> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u8> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<u8> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<usize> as num_traits::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<usize> as num_traits::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<usize> as num_traits::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<usize> as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<usize> as num_traits::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<Ratio<usize> as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/lib.rs\"))","num_traits::FromPrimitive"],"<i128 as Bits>::bits":["bits","Real(LocalPath(\"src/lib.rs\"))","Bits"],"<num_bigint::BigInt as Bits>::bits":["bits","Real(LocalPath(\"src/lib.rs\"))","Bits"],"Ratio::<T>::approximate_float":["approximate_float","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::ceil":["ceil","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::denom":["denom","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::floor":["floor","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::fract":["fract","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::from_integer":["from_integer","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::into_recip":["into_recip","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::is_integer":["is_integer","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::new_raw":["new_raw","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::numer":["numer","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::pow":["pow","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::recip":["recip","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::reduce":["reduce","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::reduced":["reduced","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::round":["round","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::to_integer":["to_integer","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<T>::trunc":["trunc","Real(LocalPath(\"src/lib.rs\"))",""],"Ratio::<num_bigint::BigInt>::from_float":["from_float","Real(LocalPath(\"src/lib.rs\"))",""],"RatioErrorKind::description":["description","Real(LocalPath(\"src/lib.rs\"))",""],"approximate_float":["approximate_float","Real(LocalPath(\"src/lib.rs\"))",""],"approximate_float_unsigned":["approximate_float_unsigned","Real(LocalPath(\"src/lib.rs\"))",""],"iter_sum_product::<impl core::iter::Product for Ratio<T>>::product":["product","Real(LocalPath(\"src/lib.rs\"))","core::iter::Product"],"iter_sum_product::<impl core::iter::Product<&'a Ratio<T>> for Ratio<T>>::product":["product","Real(LocalPath(\"src/lib.rs\"))","core::iter::Product"],"iter_sum_product::<impl core::iter::Sum for Ratio<T>>::sum":["sum","Real(LocalPath(\"src/lib.rs\"))","core::iter::Sum"],"iter_sum_product::<impl core::iter::Sum<&'a Ratio<T>> for Ratio<T>>::sum":["sum","Real(LocalPath(\"src/lib.rs\"))","core::iter::Sum"],"opassign::<impl core::ops::AddAssign for Ratio<T>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::AddAssign"],"opassign::<impl core::ops::AddAssign<&'a Ratio<T>> for Ratio<T>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::AddAssign"],"opassign::<impl core::ops::AddAssign<&'a T> for Ratio<T>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::AddAssign"],"opassign::<impl core::ops::AddAssign<T> for Ratio<T>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::AddAssign"],"opassign::<impl core::ops::DivAssign for Ratio<T>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::DivAssign"],"opassign::<impl core::ops::DivAssign<&'a Ratio<T>> for Ratio<T>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::DivAssign"],"opassign::<impl core::ops::DivAssign<&'a T> for Ratio<T>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::DivAssign"],"opassign::<impl core::ops::DivAssign<T> for Ratio<T>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::DivAssign"],"opassign::<impl core::ops::MulAssign for Ratio<T>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::MulAssign"],"opassign::<impl core::ops::MulAssign<&'a Ratio<T>> for Ratio<T>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::MulAssign"],"opassign::<impl core::ops::MulAssign<&'a T> for Ratio<T>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::MulAssign"],"opassign::<impl core::ops::MulAssign<T> for Ratio<T>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::MulAssign"],"opassign::<impl core::ops::RemAssign for Ratio<T>>::rem_assign":["rem_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::RemAssign"],"opassign::<impl core::ops::RemAssign<&'a Ratio<T>> for Ratio<T>>::rem_assign":["rem_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::RemAssign"],"opassign::<impl core::ops::RemAssign<&'a T> for Ratio<T>>::rem_assign":["rem_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::RemAssign"],"opassign::<impl core::ops::RemAssign<T> for Ratio<T>>::rem_assign":["rem_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::RemAssign"],"opassign::<impl core::ops::SubAssign for Ratio<T>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::SubAssign"],"opassign::<impl core::ops::SubAssign<&'a Ratio<T>> for Ratio<T>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::SubAssign"],"opassign::<impl core::ops::SubAssign<&'a T> for Ratio<T>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::SubAssign"],"opassign::<impl core::ops::SubAssign<T> for Ratio<T>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","core::ops::SubAssign"],"pow::<impl num_traits::Pow<&'b i128> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b i128> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b i16> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b i16> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b i32> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b i32> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b i64> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b i64> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b i8> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b i8> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b isize> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b isize> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b u128> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b u128> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b u16> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b u16> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b u32> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b u32> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b u64> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b u64> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b u8> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b u8> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b usize> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<&'b usize> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<i128> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<i128> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<i16> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<i16> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<i32> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<i32> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<i64> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<i64> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<i8> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<i8> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<isize> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<isize> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<u128> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<u128> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<u16> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<u16> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<u32> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<u32> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<u64> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<u64> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<u8> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<u8> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<usize> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::<impl num_traits::Pow<usize> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigInt> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigInt> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigUint> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::bigint::<impl num_traits::Pow<&'b num_bigint::BigUint> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigInt> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigInt> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigUint> for &'a Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"pow::bigint::<impl num_traits::Pow<num_bigint::BigUint> for Ratio<T>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","num_traits::Pow"],"ratio_to_f64":["ratio_to_f64","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"Bits":["num_bigint::BigInt"],"core::clone::Clone":["ParseRatioError","Ratio","RatioErrorKind"],"core::cmp::Eq":["Ratio"],"core::cmp::Ord":["Ratio"],"core::cmp::PartialEq":["ParseRatioError","Ratio","RatioErrorKind"],"core::cmp::PartialOrd":["Ratio"],"core::convert::From":["Ratio"],"core::convert::Into":["Ratio"],"core::error::Error":["ParseRatioError"],"core::fmt::Binary":["Ratio"],"core::fmt::Debug":["ParseRatioError","Ratio","RatioErrorKind"],"core::fmt::Display":["ParseRatioError","Ratio"],"core::fmt::LowerExp":["Ratio"],"core::fmt::LowerHex":["Ratio"],"core::fmt::Octal":["Ratio"],"core::fmt::UpperExp":["Ratio"],"core::fmt::UpperHex":["Ratio"],"core::hash::Hash":["Ratio"],"core::iter::Product":["Ratio"],"core::iter::Sum":["Ratio"],"core::marker::Copy":["ParseRatioError","Ratio","RatioErrorKind"],"core::marker::StructuralPartialEq":["ParseRatioError","RatioErrorKind"],"core::ops::Add":["Ratio"],"core::ops::AddAssign":["Ratio"],"core::ops::Div":["Ratio"],"core::ops::DivAssign":["Ratio"],"core::ops::Mul":["Ratio"],"core::ops::MulAssign":["Ratio"],"core::ops::Neg":["Ratio"],"core::ops::Rem":["Ratio"],"core::ops::RemAssign":["Ratio"],"core::ops::Sub":["Ratio"],"core::ops::SubAssign":["Ratio"],"core::str::FromStr":["Ratio"],"num_traits::CheckedAdd":["Ratio"],"num_traits::CheckedDiv":["Ratio"],"num_traits::CheckedMul":["Ratio"],"num_traits::CheckedSub":["Ratio"],"num_traits::FromPrimitive":["Ratio"],"num_traits::Inv":["Ratio"],"num_traits::Num":["Ratio"],"num_traits::One":["Ratio"],"num_traits::Pow":["Ratio"],"num_traits::Signed":["Ratio"],"num_traits::ToPrimitive":["Ratio"],"num_traits::Zero":["Ratio"]},"type_to_def_path":{"ParseRatioError":"ParseRatioError","Ratio<T>":"Ratio","RatioErrorKind":"RatioErrorKind"}}