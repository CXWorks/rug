{"dependencies":{"<&'a channel::Receiver<T> as std::iter::IntoIterator>::into_iter":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<&T as select::SelectHandle>::accept":["context::Context","flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option","std::sync::Arc"],"<&T as select::SelectHandle>::deadline":["std::marker::Sized","std::option::Option"],"<&T as select::SelectHandle>::is_ready":[],"<&T as select::SelectHandle>::register":["context::Context","select::Operation","std::sync::Arc"],"<&T as select::SelectHandle>::try_select":["flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option"],"<&T as select::SelectHandle>::unregister":["select::Operation"],"<&T as select::SelectHandle>::unwatch":["select::Operation"],"<&T as select::SelectHandle>::watch":["context::Context","select::Operation","std::sync::Arc"],"<channel::IntoIter<T> as std::fmt::Debug>::fmt":["channel::IntoIter","channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::IntoIter<T> as std::iter::Iterator>::next":["channel::IntoIter","channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Iter<'_, T> as std::fmt::Debug>::fmt":["channel::Iter","channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Iter<'_, T> as std::iter::Iterator>::next":["channel::Iter","channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as select::SelectHandle>::accept":["channel::Receiver","channel::ReceiverFlavor","context::Context","counter::Counter","counter::Receiver","flavors::array::ArrayToken","flavors::list::ListToken","flavors::never::Channel","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as select::SelectHandle>::deadline":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as select::SelectHandle>::is_ready":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as select::SelectHandle>::register":["channel::Receiver","channel::ReceiverFlavor","context::Context","counter::Counter","counter::Receiver","flavors::never::Channel","select::Operation","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as select::SelectHandle>::try_select":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::array::ArrayToken","flavors::list::ListToken","flavors::never::Channel","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as select::SelectHandle>::unregister":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","select::Operation","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as select::SelectHandle>::unwatch":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","select::Operation","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as select::SelectHandle>::watch":["channel::Receiver","channel::ReceiverFlavor","context::Context","counter::Counter","counter::Receiver","flavors::never::Channel","select::Operation","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as std::clone::Clone>::clone":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as std::fmt::Debug>::fmt":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as std::iter::IntoIterator>::into_iter":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Receiver<T> as std::ops::Drop>::drop":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Sender<T> as select::SelectHandle>::accept":["channel::Sender","channel::SenderFlavor","context::Context","counter::Counter","counter::Sender","flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Sender<T> as select::SelectHandle>::deadline":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Sender<T> as select::SelectHandle>::is_ready":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Sender<T> as select::SelectHandle>::register":["channel::Sender","channel::SenderFlavor","context::Context","counter::Counter","counter::Sender","select::Operation","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Sender<T> as select::SelectHandle>::try_select":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Sender<T> as select::SelectHandle>::unregister":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","select::Operation","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Sender<T> as select::SelectHandle>::unwatch":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","select::Operation","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Sender<T> as select::SelectHandle>::watch":["channel::Sender","channel::SenderFlavor","context::Context","counter::Counter","counter::Sender","select::Operation","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Sender<T> as std::clone::Clone>::clone":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Sender<T> as std::fmt::Debug>::fmt":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::Sender<T> as std::ops::Drop>::drop":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::TryIter<'_, T> as std::fmt::Debug>::fmt":["channel::Receiver","channel::ReceiverFlavor","channel::TryIter","counter::Counter","counter::Receiver","flavors::never::Channel","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<channel::TryIter<'_, T> as std::iter::Iterator>::next":["channel::Receiver","channel::ReceiverFlavor","channel::TryIter","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<context::Context as std::clone::Clone>::clone":["context::Context","std::sync::Arc"],"<context::Context as std::fmt::Debug>::fmt":["context::Context","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<context::Inner as std::fmt::Debug>::fmt":["context::Inner","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicUsize","std::thread::Thread","std::thread::ThreadId"],"<counter::Receiver<C> as std::cmp::PartialEq>::eq":["counter::Counter","counter::Receiver","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<counter::Receiver<C> as std::ops::Deref>::deref":["counter::Counter","counter::Receiver","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<counter::Sender<C> as std::cmp::PartialEq>::eq":["counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<counter::Sender<C> as std::ops::Deref>::deref":["counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"<err::ReadyTimeoutError as std::clone::Clone>::clone":["err::ReadyTimeoutError"],"<err::ReadyTimeoutError as std::cmp::Eq>::assert_receiver_is_total_eq":["err::ReadyTimeoutError"],"<err::ReadyTimeoutError as std::cmp::PartialEq>::eq":["err::ReadyTimeoutError"],"<err::ReadyTimeoutError as std::fmt::Debug>::fmt":["err::ReadyTimeoutError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::RecvError as std::clone::Clone>::clone":["err::RecvError"],"<err::RecvError as std::cmp::Eq>::assert_receiver_is_total_eq":["err::RecvError"],"<err::RecvError as std::cmp::PartialEq>::eq":["err::RecvError"],"<err::RecvError as std::fmt::Debug>::fmt":["err::RecvError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::RecvError as std::fmt::Display>::fmt":["err::RecvError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::RecvTimeoutError as std::clone::Clone>::clone":["err::RecvTimeoutError"],"<err::RecvTimeoutError as std::cmp::Eq>::assert_receiver_is_total_eq":["err::RecvTimeoutError"],"<err::RecvTimeoutError as std::cmp::PartialEq>::eq":["err::RecvTimeoutError"],"<err::RecvTimeoutError as std::convert::From<err::RecvError>>::from":["err::RecvError","err::RecvTimeoutError"],"<err::RecvTimeoutError as std::fmt::Debug>::fmt":["err::RecvTimeoutError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::RecvTimeoutError as std::fmt::Display>::fmt":["err::RecvTimeoutError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::SelectTimeoutError as std::clone::Clone>::clone":["err::SelectTimeoutError"],"<err::SelectTimeoutError as std::cmp::Eq>::assert_receiver_is_total_eq":["err::SelectTimeoutError"],"<err::SelectTimeoutError as std::cmp::PartialEq>::eq":["err::SelectTimeoutError"],"<err::SelectTimeoutError as std::fmt::Debug>::fmt":["err::SelectTimeoutError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::SelectTimeoutError as std::fmt::Display>::fmt":["err::SelectTimeoutError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::SendError<T> as std::clone::Clone>::clone":["err::SendError","std::marker::Sized"],"<err::SendError<T> as std::cmp::Eq>::assert_receiver_is_total_eq":["err::SendError","std::marker::Sized"],"<err::SendError<T> as std::cmp::PartialEq>::eq":["err::SendError","std::marker::Sized"],"<err::SendError<T> as std::fmt::Debug>::fmt":["err::SendError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::SendError<T> as std::fmt::Display>::fmt":["err::SendError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::SendTimeoutError<T> as std::clone::Clone>::clone":["err::SendTimeoutError","std::marker::Sized"],"<err::SendTimeoutError<T> as std::cmp::Eq>::assert_receiver_is_total_eq":["err::SendTimeoutError","std::marker::Sized"],"<err::SendTimeoutError<T> as std::cmp::PartialEq>::eq":["err::SendTimeoutError","std::marker::Sized"],"<err::SendTimeoutError<T> as std::convert::From<err::SendError<T>>>::from":["err::SendError","err::SendTimeoutError","std::marker::Sized"],"<err::SendTimeoutError<T> as std::fmt::Debug>::fmt":["err::SendTimeoutError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::SendTimeoutError<T> as std::fmt::Display>::fmt":["err::SendTimeoutError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::TryReadyError as std::clone::Clone>::clone":["err::TryReadyError"],"<err::TryReadyError as std::cmp::Eq>::assert_receiver_is_total_eq":["err::TryReadyError"],"<err::TryReadyError as std::cmp::PartialEq>::eq":["err::TryReadyError"],"<err::TryReadyError as std::fmt::Debug>::fmt":["err::TryReadyError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::TryRecvError as std::clone::Clone>::clone":["err::TryRecvError"],"<err::TryRecvError as std::cmp::Eq>::assert_receiver_is_total_eq":["err::TryRecvError"],"<err::TryRecvError as std::cmp::PartialEq>::eq":["err::TryRecvError"],"<err::TryRecvError as std::convert::From<err::RecvError>>::from":["err::RecvError","err::TryRecvError"],"<err::TryRecvError as std::fmt::Debug>::fmt":["err::TryRecvError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::TryRecvError as std::fmt::Display>::fmt":["err::TryRecvError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::TrySelectError as std::clone::Clone>::clone":["err::TrySelectError"],"<err::TrySelectError as std::cmp::Eq>::assert_receiver_is_total_eq":["err::TrySelectError"],"<err::TrySelectError as std::cmp::PartialEq>::eq":["err::TrySelectError"],"<err::TrySelectError as std::fmt::Debug>::fmt":["err::TrySelectError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::TrySelectError as std::fmt::Display>::fmt":["err::TrySelectError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::TrySendError<T> as std::clone::Clone>::clone":["err::TrySendError","std::marker::Sized"],"<err::TrySendError<T> as std::cmp::Eq>::assert_receiver_is_total_eq":["err::TrySendError","std::marker::Sized"],"<err::TrySendError<T> as std::cmp::PartialEq>::eq":["err::TrySendError","std::marker::Sized"],"<err::TrySendError<T> as std::convert::From<err::SendError<T>>>::from":["err::SendError","err::TrySendError","std::marker::Sized"],"<err::TrySendError<T> as std::fmt::Debug>::fmt":["err::TrySendError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<err::TrySendError<T> as std::fmt::Display>::fmt":["err::TrySendError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<flavors::after::Channel as select::SelectHandle>::accept":["context::Context","flavors::after::Channel","flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","std::time::Instant"],"<flavors::after::Channel as select::SelectHandle>::deadline":["flavors::after::Channel","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::time::Instant"],"<flavors::after::Channel as select::SelectHandle>::is_ready":["flavors::after::Channel","std::sync::atomic::AtomicBool","std::time::Instant"],"<flavors::after::Channel as select::SelectHandle>::register":["context::Context","flavors::after::Channel","select::Operation","std::sync::Arc","std::sync::atomic::AtomicBool","std::time::Instant"],"<flavors::after::Channel as select::SelectHandle>::try_select":["flavors::after::Channel","flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::time::Instant"],"<flavors::after::Channel as select::SelectHandle>::unregister":["flavors::after::Channel","select::Operation","std::sync::atomic::AtomicBool","std::time::Instant"],"<flavors::after::Channel as select::SelectHandle>::unwatch":["flavors::after::Channel","select::Operation","std::sync::atomic::AtomicBool","std::time::Instant"],"<flavors::after::Channel as select::SelectHandle>::watch":["context::Context","flavors::after::Channel","select::Operation","std::sync::Arc","std::sync::atomic::AtomicBool","std::time::Instant"],"<flavors::array::ArrayToken as std::default::Default>::default":["flavors::array::ArrayToken"],"<flavors::array::ArrayToken as std::fmt::Debug>::fmt":["flavors::array::ArrayToken","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<flavors::array::Channel<T> as std::ops::Drop>::drop":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::accept":["context::Context","crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::array::Channel","flavors::array::Receiver","flavors::array::Slot","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::deadline":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Receiver","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::is_ready":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Receiver","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::register":["context::Context","crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Receiver","flavors::array::Slot","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::try_select":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::array::Channel","flavors::array::Receiver","flavors::array::Slot","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::unregister":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Receiver","flavors::array::Slot","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::unwatch":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Receiver","flavors::array::Slot","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::watch":["context::Context","crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Receiver","flavors::array::Slot","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::accept":["context::Context","crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::array::Channel","flavors::array::Sender","flavors::array::Slot","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::deadline":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Sender","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::is_ready":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Sender","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::register":["context::Context","crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Sender","flavors::array::Slot","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::try_select":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::array::Channel","flavors::array::Sender","flavors::array::Slot","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::unregister":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Sender","flavors::array::Slot","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::unwatch":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Sender","flavors::array::Slot","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::watch":["context::Context","crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Sender","flavors::array::Slot","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Channel<T> as std::ops::Drop>::drop":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::ListToken as std::default::Default>::default":["flavors::list::ListToken"],"<flavors::list::ListToken as std::fmt::Debug>::fmt":["flavors::list::ListToken","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<flavors::list::Position<T> as std::fmt::Debug>::fmt":["flavors::list::Position","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicPtr","std::sync::atomic::AtomicUsize"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::accept":["context::Context","crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::list::Channel","flavors::list::ListToken","flavors::list::Receiver","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::deadline":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Receiver","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::is_ready":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Receiver","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::register":["context::Context","crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Receiver","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::try_select":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::list::Channel","flavors::list::ListToken","flavors::list::Receiver","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::unregister":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Receiver","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::unwatch":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Receiver","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::watch":["context::Context","crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Receiver","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::accept":["context::Context","crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::list::Channel","flavors::list::ListToken","flavors::list::Sender","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::deadline":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Sender","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::is_ready":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Sender","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::register":["context::Context","crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Sender","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::try_select":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::list::Channel","flavors::list::ListToken","flavors::list::Sender","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::unregister":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Sender","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::unwatch":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Sender","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::watch":["context::Context","crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Sender","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<flavors::never::Channel<T> as select::SelectHandle>::accept":["context::Context","flavors::array::ArrayToken","flavors::list::ListToken","flavors::never::Channel","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"<flavors::never::Channel<T> as select::SelectHandle>::deadline":["flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<flavors::never::Channel<T> as select::SelectHandle>::is_ready":["flavors::never::Channel","std::marker::PhantomData","std::marker::Sized"],"<flavors::never::Channel<T> as select::SelectHandle>::register":["context::Context","flavors::never::Channel","select::Operation","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<flavors::never::Channel<T> as select::SelectHandle>::try_select":["flavors::array::ArrayToken","flavors::list::ListToken","flavors::never::Channel","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<flavors::never::Channel<T> as select::SelectHandle>::unregister":["flavors::never::Channel","select::Operation","std::marker::PhantomData","std::marker::Sized"],"<flavors::never::Channel<T> as select::SelectHandle>::unwatch":["flavors::never::Channel","select::Operation","std::marker::PhantomData","std::marker::Sized"],"<flavors::never::Channel<T> as select::SelectHandle>::watch":["context::Context","flavors::never::Channel","select::Operation","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<flavors::tick::Channel as select::SelectHandle>::accept":["context::Context","crossbeam_utils::atomic::AtomicCell","flavors::array::ArrayToken","flavors::list::ListToken","flavors::tick::Channel","select::Token","std::marker::Sized","std::option::Option","std::sync::Arc","std::time::Duration"],"<flavors::tick::Channel as select::SelectHandle>::deadline":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","std::marker::Sized","std::option::Option","std::time::Duration"],"<flavors::tick::Channel as select::SelectHandle>::is_ready":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","std::time::Duration"],"<flavors::tick::Channel as select::SelectHandle>::register":["context::Context","crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","select::Operation","std::sync::Arc","std::time::Duration"],"<flavors::tick::Channel as select::SelectHandle>::try_select":["crossbeam_utils::atomic::AtomicCell","flavors::array::ArrayToken","flavors::list::ListToken","flavors::tick::Channel","select::Token","std::marker::Sized","std::option::Option","std::time::Duration"],"<flavors::tick::Channel as select::SelectHandle>::unregister":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","select::Operation","std::time::Duration"],"<flavors::tick::Channel as select::SelectHandle>::unwatch":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","select::Operation","std::time::Duration"],"<flavors::tick::Channel as select::SelectHandle>::watch":["context::Context","crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","select::Operation","std::sync::Arc","std::time::Duration"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::accept":["context::Context","flavors::array::ArrayToken","flavors::list::ListToken","flavors::zero::Channel","flavors::zero::Receiver","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::deadline":["flavors::zero::Channel","flavors::zero::Receiver","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::is_ready":["flavors::zero::Channel","flavors::zero::Receiver","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::register":["context::Context","flavors::zero::Channel","flavors::zero::Receiver","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::try_select":["flavors::array::ArrayToken","flavors::list::ListToken","flavors::zero::Channel","flavors::zero::Receiver","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::unregister":["flavors::zero::Channel","flavors::zero::Receiver","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::unwatch":["flavors::zero::Channel","flavors::zero::Receiver","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::watch":["context::Context","flavors::zero::Channel","flavors::zero::Receiver","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::accept":["context::Context","flavors::array::ArrayToken","flavors::list::ListToken","flavors::zero::Channel","flavors::zero::Sender","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::deadline":["flavors::zero::Channel","flavors::zero::Sender","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::is_ready":["flavors::zero::Channel","flavors::zero::Sender","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::register":["context::Context","flavors::zero::Channel","flavors::zero::Sender","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::try_select":["flavors::array::ArrayToken","flavors::list::ListToken","flavors::zero::Channel","flavors::zero::Sender","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::unregister":["flavors::zero::Channel","flavors::zero::Sender","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::unwatch":["flavors::zero::Channel","flavors::zero::Sender","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::watch":["context::Context","flavors::zero::Channel","flavors::zero::Sender","select::Operation","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock"],"<select::Operation as std::clone::Clone>::clone":["select::Operation"],"<select::Operation as std::cmp::Eq>::assert_receiver_is_total_eq":["select::Operation"],"<select::Operation as std::cmp::PartialEq>::eq":["select::Operation"],"<select::Operation as std::fmt::Debug>::fmt":["select::Operation","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<select::Select<'_> as std::fmt::Debug>::fmt":["select::Select","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<select::Select<'a> as std::clone::Clone>::clone":["select::Select","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<select::Select<'a> as std::default::Default>::default":["select::Select","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<select::Selected as std::clone::Clone>::clone":["select::Operation","select::Selected"],"<select::Selected as std::cmp::Eq>::assert_receiver_is_total_eq":["select::Operation","select::Selected"],"<select::Selected as std::cmp::PartialEq>::eq":["select::Operation","select::Selected"],"<select::Selected as std::convert::From<usize>>::from":["select::Operation","select::Selected"],"<select::Selected as std::convert::Into<usize>>::into":["select::Operation","select::Selected"],"<select::Selected as std::fmt::Debug>::fmt":["select::Operation","select::Selected","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<select::SelectedOperation<'_> as std::fmt::Debug>::fmt":["flavors::array::ArrayToken","flavors::list::ListToken","select::SelectedOperation","select::Token","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"<select::SelectedOperation<'_> as std::ops::Drop>::drop":["flavors::array::ArrayToken","flavors::list::ListToken","select::SelectedOperation","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<select::Timeout as std::clone::Clone>::clone":["select::Timeout","std::time::Instant"],"<select::Timeout as std::cmp::Eq>::assert_receiver_is_total_eq":["select::Timeout","std::time::Instant"],"<select::Timeout as std::cmp::PartialEq>::eq":["select::Timeout","std::time::Instant"],"<select::Token as std::default::Default>::default":["flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option"],"<select::Token as std::fmt::Debug>::fmt":["flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<utils::SpinlockGuard<'_, T> as std::ops::Deref>::deref":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","utils::SpinlockGuard"],"<utils::SpinlockGuard<'_, T> as std::ops::DerefMut>::deref_mut":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","utils::SpinlockGuard"],"<utils::SpinlockGuard<'_, T> as std::ops::Drop>::drop":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","utils::SpinlockGuard"],"<waker::SyncWaker as std::ops::Drop>::drop":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"<waker::Waker as std::ops::Drop>::drop":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","waker::Waker"],"channel::IntoIter":["channel::IntoIter","channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Iter":["channel::Iter","channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Receiver":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Receiver::<T>::capacity":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Receiver::<T>::is_empty":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Receiver::<T>::is_full":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Receiver::<T>::iter":["channel::Iter","channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Receiver::<T>::len":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Receiver::<T>::recv":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Receiver::<T>::recv_timeout":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","std::time::Duration"],"channel::Receiver::<T>::same_channel":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Receiver::<T>::try_iter":["channel::Receiver","channel::ReceiverFlavor","channel::TryIter","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Receiver::<T>::try_recv":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::ReceiverFlavor":["channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Sender":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Sender::<T>::capacity":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Sender::<T>::is_empty":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Sender::<T>::is_full":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Sender::<T>::len":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Sender::<T>::same_channel":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Sender::<T>::send":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::Sender::<T>::send_timeout":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","std::time::Duration"],"channel::Sender::<T>::try_send":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::SenderFlavor":["channel::SenderFlavor","counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::TryIter":["channel::Receiver","channel::ReceiverFlavor","channel::TryIter","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::after":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","std::time::Duration"],"channel::bounded":["channel::Receiver","channel::ReceiverFlavor","channel::Sender","channel::SenderFlavor","counter::Counter","counter::Receiver","counter::Sender","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::never":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::read":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::array::ArrayToken","flavors::list::ListToken","flavors::never::Channel","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::tick":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","std::time::Duration"],"channel::unbounded":["channel::Receiver","channel::ReceiverFlavor","channel::Sender","channel::SenderFlavor","counter::Counter","counter::Receiver","counter::Sender","flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"channel::write":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"context::Context":["context::Context","std::sync::Arc"],"context::Context::new":["context::Context","std::sync::Arc"],"context::Context::reset":["context::Context","std::sync::Arc"],"context::Context::selected":["context::Context","select::Operation","select::Selected","std::sync::Arc"],"context::Context::store_packet":["context::Context","std::sync::Arc"],"context::Context::thread_id":["context::Context","std::sync::Arc","std::thread::ThreadId"],"context::Context::try_select":["context::Context","select::Operation","select::Selected","std::marker::Sized","std::result::Result","std::sync::Arc"],"context::Context::unpark":["context::Context","std::sync::Arc"],"context::Context::wait_packet":["context::Context","std::sync::Arc"],"context::Context::wait_until":["context::Context","select::Operation","select::Selected","std::marker::Sized","std::option::Option","std::sync::Arc"],"context::Context::with":["std::marker::Sized","std::ops::FnOnce"],"context::Context::with::CONTEXT::__getit":["std::marker::Sized","std::option::Option"],"context::Context::with::CONTEXT::__init":["std::cell::Cell"],"context::Inner":["context::Inner","std::sync::atomic::AtomicUsize","std::thread::Thread","std::thread::ThreadId"],"counter::Counter":["counter::Counter","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"counter::Receiver":["counter::Counter","counter::Receiver","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"counter::Receiver::<C>::acquire":["counter::Counter","counter::Receiver","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"counter::Receiver::<C>::counter":["counter::Counter","counter::Receiver","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"counter::Receiver::<C>::release":["counter::Counter","counter::Receiver","std::marker::Sized","std::ops::FnOnce","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"counter::Sender":["counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"counter::Sender::<C>::acquire":["counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"counter::Sender::<C>::counter":["counter::Counter","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"counter::Sender::<C>::release":["counter::Counter","counter::Sender","std::marker::Sized","std::ops::FnOnce","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"counter::new":["counter::Counter","counter::Receiver","counter::Sender","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"err::ReadyTimeoutError":["err::ReadyTimeoutError"],"err::RecvError":["err::RecvError"],"err::RecvTimeoutError":["err::RecvTimeoutError"],"err::RecvTimeoutError::is_disconnected":["err::RecvTimeoutError"],"err::RecvTimeoutError::is_timeout":["err::RecvTimeoutError"],"err::SelectTimeoutError":["err::SelectTimeoutError"],"err::SendError":["err::SendError","std::marker::Sized"],"err::SendError::<T>::into_inner":["err::SendError","std::marker::Sized"],"err::SendTimeoutError":["err::SendTimeoutError","std::marker::Sized"],"err::SendTimeoutError::<T>::into_inner":["err::SendTimeoutError","std::marker::Sized"],"err::SendTimeoutError::<T>::is_disconnected":["err::SendTimeoutError","std::marker::Sized"],"err::SendTimeoutError::<T>::is_timeout":["err::SendTimeoutError","std::marker::Sized"],"err::TryReadyError":["err::TryReadyError"],"err::TryRecvError":["err::TryRecvError"],"err::TryRecvError::is_disconnected":["err::TryRecvError"],"err::TryRecvError::is_empty":["err::TryRecvError"],"err::TrySelectError":["err::TrySelectError"],"err::TrySendError":["err::TrySendError","std::marker::Sized"],"err::TrySendError::<T>::into_inner":["err::TrySendError","std::marker::Sized"],"err::TrySendError::<T>::is_disconnected":["err::TrySendError","std::marker::Sized"],"err::TrySendError::<T>::is_full":["err::TrySendError","std::marker::Sized"],"flavors::after::Channel":["flavors::after::Channel","std::sync::atomic::AtomicBool","std::time::Instant"],"flavors::after::Channel::capacity":["flavors::after::Channel","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::time::Instant"],"flavors::after::Channel::is_empty":["flavors::after::Channel","std::sync::atomic::AtomicBool","std::time::Instant"],"flavors::after::Channel::is_full":["flavors::after::Channel","std::sync::atomic::AtomicBool","std::time::Instant"],"flavors::after::Channel::len":["flavors::after::Channel","std::sync::atomic::AtomicBool","std::time::Instant"],"flavors::after::Channel::new":["flavors::after::Channel","std::sync::atomic::AtomicBool","std::time::Duration","std::time::Instant"],"flavors::after::Channel::read":["flavors::after::Channel","flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","std::time::Instant"],"flavors::after::Channel::recv":["flavors::after::Channel","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","std::time::Instant"],"flavors::after::Channel::try_recv":["flavors::after::Channel","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicBool","std::time::Instant"],"flavors::array::ArrayToken":["flavors::array::ArrayToken"],"flavors::array::Channel":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::capacity":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::disconnect":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::is_disconnected":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::is_empty":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::is_full":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::len":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::read":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::array::Channel","flavors::array::Slot","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::receiver":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Receiver","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::recv":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::send":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::sender":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Sender","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::start_recv":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::array::Channel","flavors::array::Slot","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::start_send":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::array::Channel","flavors::array::Slot","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::try_recv":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::try_send":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::with_capacity":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Channel::<T>::write":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::array::Channel","flavors::array::Slot","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Receiver":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Receiver","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Sender":["crossbeam_utils::CachePadded","flavors::array::Channel","flavors::array::Sender","flavors::array::Slot","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","utils::Spinlock","waker::SyncWaker"],"flavors::array::Slot":["flavors::array::Slot","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicUsize"],"flavors::list::Block":["flavors::list::Block","flavors::list::Slot","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicPtr","std::sync::atomic::AtomicUsize"],"flavors::list::Block::<T>::destroy":["flavors::list::Block","flavors::list::Slot","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicPtr","std::sync::atomic::AtomicUsize"],"flavors::list::Block::<T>::new":["flavors::list::Block","flavors::list::Slot","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicPtr","std::sync::atomic::AtomicUsize"],"flavors::list::Block::<T>::wait_next":["flavors::list::Block","flavors::list::Slot","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicPtr","std::sync::atomic::AtomicUsize"],"flavors::list::Channel":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::capacity":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::disconnect":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::is_disconnected":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::is_empty":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::is_full":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::len":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::new":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::read":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::list::Channel","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::receiver":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Receiver","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::recv":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::send":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::sender":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Sender","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::start_recv":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::list::Channel","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::start_send":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::list::Channel","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::try_recv":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::try_send":["crossbeam_utils::CachePadded","flavors::list::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Channel::<T>::write":["crossbeam_utils::CachePadded","flavors::array::ArrayToken","flavors::list::Channel","flavors::list::ListToken","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::ListToken":["flavors::list::ListToken"],"flavors::list::Position":["flavors::list::Position","std::marker::Sized","std::sync::atomic::AtomicPtr","std::sync::atomic::AtomicUsize"],"flavors::list::Receiver":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Receiver","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Sender":["crossbeam_utils::CachePadded","flavors::list::Channel","flavors::list::Sender","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"flavors::list::Slot":["flavors::list::Slot","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicUsize"],"flavors::list::Slot::<T>::wait_write":["flavors::list::Slot","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicUsize"],"flavors::never::Channel":["flavors::never::Channel","std::marker::PhantomData","std::marker::Sized"],"flavors::never::Channel::<T>::capacity":["flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"flavors::never::Channel::<T>::is_empty":["flavors::never::Channel","std::marker::PhantomData","std::marker::Sized"],"flavors::never::Channel::<T>::is_full":["flavors::never::Channel","std::marker::PhantomData","std::marker::Sized"],"flavors::never::Channel::<T>::len":["flavors::never::Channel","std::marker::PhantomData","std::marker::Sized"],"flavors::never::Channel::<T>::new":["flavors::never::Channel","std::marker::PhantomData","std::marker::Sized"],"flavors::never::Channel::<T>::read":["flavors::array::ArrayToken","flavors::list::ListToken","flavors::never::Channel","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"flavors::never::Channel::<T>::recv":["flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result"],"flavors::never::Channel::<T>::try_recv":["flavors::never::Channel","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"flavors::tick::Channel":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","std::time::Duration"],"flavors::tick::Channel::capacity":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","std::marker::Sized","std::option::Option","std::time::Duration"],"flavors::tick::Channel::is_empty":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","std::time::Duration"],"flavors::tick::Channel::is_full":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","std::time::Duration"],"flavors::tick::Channel::len":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","std::time::Duration"],"flavors::tick::Channel::new":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","std::time::Duration"],"flavors::tick::Channel::read":["crossbeam_utils::atomic::AtomicCell","flavors::array::ArrayToken","flavors::list::ListToken","flavors::tick::Channel","select::Token","std::marker::Sized","std::option::Option","std::result::Result","std::time::Duration"],"flavors::tick::Channel::recv":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","std::marker::Sized","std::option::Option","std::result::Result","std::time::Duration"],"flavors::tick::Channel::try_recv":["crossbeam_utils::atomic::AtomicCell","flavors::tick::Channel","std::marker::Sized","std::result::Result","std::time::Duration"],"flavors::zero::Channel":["flavors::zero::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::capacity":["flavors::zero::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::disconnect":["flavors::zero::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::is_empty":["flavors::zero::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::is_full":["flavors::zero::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::len":["flavors::zero::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::new":["flavors::zero::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::read":["flavors::array::ArrayToken","flavors::list::ListToken","flavors::zero::Channel","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::receiver":["flavors::zero::Channel","flavors::zero::Receiver","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::recv":["flavors::zero::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::send":["flavors::zero::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::sender":["flavors::zero::Channel","flavors::zero::Sender","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::start_recv":["flavors::array::ArrayToken","flavors::list::ListToken","flavors::zero::Channel","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::start_send":["flavors::array::ArrayToken","flavors::list::ListToken","flavors::zero::Channel","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::try_recv":["flavors::zero::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::try_send":["flavors::zero::Channel","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Channel::<T>::write":["flavors::array::ArrayToken","flavors::list::ListToken","flavors::zero::Channel","select::Token","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Inner":["flavors::zero::Inner","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","waker::Waker"],"flavors::zero::Packet":["flavors::zero::Packet","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool"],"flavors::zero::Packet::<T>::empty_on_heap":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"flavors::zero::Packet::<T>::empty_on_stack":["flavors::zero::Packet","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool"],"flavors::zero::Packet::<T>::message_on_stack":["flavors::zero::Packet","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool"],"flavors::zero::Packet::<T>::wait_ready":["flavors::zero::Packet","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool"],"flavors::zero::Receiver":["flavors::zero::Channel","flavors::zero::Receiver","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"flavors::zero::Sender":["flavors::zero::Channel","flavors::zero::Sender","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"select::Operation":["select::Operation"],"select::Operation::hook":["select::Operation","std::marker::Sized"],"select::Select":["select::Select","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"select::Select::<'a>::new":["select::Select","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"select::Select::<'a>::ready":["select::Select","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"select::Select::<'a>::ready_timeout":["select::Select","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::time::Duration","std::vec::Vec"],"select::Select::<'a>::recv":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::never::Channel","select::Select","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","std::vec::Vec"],"select::Select::<'a>::remove":["select::Select","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"select::Select::<'a>::select":["flavors::array::ArrayToken","flavors::list::ListToken","select::Select","select::SelectedOperation","select::Token","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"select::Select::<'a>::select_timeout":["select::Select","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::time::Duration","std::vec::Vec"],"select::Select::<'a>::send":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","select::Select","std::alloc::Allocator","std::marker::Sized","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","std::vec::Vec"],"select::Select::<'a>::try_ready":["select::Select","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"select::Select::<'a>::try_select":["select::Select","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"select::SelectHandle::accept":["context::Context","flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option","std::sync::Arc"],"select::SelectHandle::deadline":["std::marker::Sized","std::option::Option"],"select::SelectHandle::is_ready":[],"select::SelectHandle::register":["context::Context","select::Operation","std::sync::Arc"],"select::SelectHandle::try_select":["flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option"],"select::SelectHandle::unregister":["select::Operation"],"select::SelectHandle::unwatch":["select::Operation"],"select::SelectHandle::watch":["context::Context","select::Operation","std::sync::Arc"],"select::Selected":["select::Operation","select::Selected"],"select::SelectedOperation":["flavors::array::ArrayToken","flavors::list::ListToken","select::SelectedOperation","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"select::SelectedOperation::<'_>::index":["flavors::array::ArrayToken","flavors::list::ListToken","select::SelectedOperation","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"select::SelectedOperation::<'_>::recv":["channel::Receiver","channel::ReceiverFlavor","counter::Counter","counter::Receiver","flavors::array::ArrayToken","flavors::list::ListToken","flavors::never::Channel","select::SelectedOperation","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"select::SelectedOperation::<'_>::send":["channel::Sender","channel::SenderFlavor","counter::Counter","counter::Sender","flavors::array::ArrayToken","flavors::list::ListToken","select::SelectedOperation","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize"],"select::Timeout":["select::Timeout","std::time::Instant"],"select::Token":["flavors::array::ArrayToken","flavors::list::ListToken","select::Token","std::marker::Sized","std::option::Option"],"select::run_ready":["select::Timeout","std::marker::Sized","std::option::Option","std::time::Instant"],"select::run_select":["select::Timeout","std::marker::Sized","std::option::Option","std::time::Instant"],"select::select":["flavors::array::ArrayToken","flavors::list::ListToken","select::SelectedOperation","select::Token","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"select::select_timeout":["std::marker::Sized","std::result::Result","std::time::Duration"],"select::try_select":["std::marker::Sized","std::result::Result"],"utils::Spinlock":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"utils::Spinlock::<T>::lock":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","utils::SpinlockGuard"],"utils::Spinlock::<T>::new":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock"],"utils::SpinlockGuard":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","utils::SpinlockGuard"],"utils::shuffle":["std::marker::Sized"],"utils::shuffle::RNG::__getit":["std::marker::Sized","std::option::Option"],"utils::shuffle::RNG::__init":["std::cell::Cell"],"utils::sleep_until":["std::marker::Sized","std::option::Option"],"waker::Entry":["context::Context","select::Operation","std::sync::Arc","waker::Entry"],"waker::SyncWaker":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"waker::SyncWaker::disconnect":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"waker::SyncWaker::new":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"waker::SyncWaker::notify":["std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"waker::SyncWaker::register":["context::Context","select::Operation","std::cell::UnsafeCell","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"waker::SyncWaker::unregister":["select::Operation","std::cell::UnsafeCell","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"waker::SyncWaker::unwatch":["select::Operation","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"waker::SyncWaker::watch":["context::Context","select::Operation","std::cell::UnsafeCell","std::marker::Sized","std::sync::Arc","std::sync::atomic::AtomicBool","utils::Spinlock","waker::SyncWaker"],"waker::Waker":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","waker::Waker"],"waker::Waker::can_select":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","waker::Waker"],"waker::Waker::disconnect":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","waker::Waker"],"waker::Waker::new":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","waker::Waker"],"waker::Waker::notify":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","waker::Waker"],"waker::Waker::register":["context::Context","select::Operation","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec","waker::Waker"],"waker::Waker::register_with_packet":["context::Context","select::Operation","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec","waker::Waker"],"waker::Waker::try_select":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","waker::Waker"],"waker::Waker::unregister":["select::Operation","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","waker::Waker"],"waker::Waker::unwatch":["select::Operation","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","waker::Waker"],"waker::Waker::watch":["context::Context","select::Operation","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec","waker::Waker"],"waker::current_thread_id":["std::thread::ThreadId"],"waker::current_thread_id::THREAD_ID::__getit":["std::marker::Sized","std::option::Option"],"waker::current_thread_id::THREAD_ID::__init":["std::thread::ThreadId"]},"glob_path_import":{},"self_to_fn":{"channel::IntoIter":["impl<T> FusedIterator for IntoIter<T> {}","impl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.receiver.recv().ok()\n    }\n}","impl<T> fmt::Debug for IntoIter<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"IntoIter { .. }\")\n    }\n}"],"channel::Iter":["impl<T> FusedIterator for Iter<'_, T> {}","impl<T> Iterator for Iter<'_, T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.receiver.recv().ok()\n    }\n}","impl<T> fmt::Debug for Iter<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"Iter { .. }\")\n    }\n}"],"channel::Receiver":["impl<T> Clone for Receiver<T> {\n    fn clone(&self) -> Self {\n        let flavor = match &self.flavor {\n            ReceiverFlavor::Array(chan) => ReceiverFlavor::Array(chan.acquire()),\n            ReceiverFlavor::List(chan) => ReceiverFlavor::List(chan.acquire()),\n            ReceiverFlavor::Zero(chan) => ReceiverFlavor::Zero(chan.acquire()),\n            ReceiverFlavor::After(chan) => ReceiverFlavor::After(chan.clone()),\n            ReceiverFlavor::Tick(chan) => ReceiverFlavor::Tick(chan.clone()),\n            ReceiverFlavor::Never(_) => ReceiverFlavor::Never(flavors::never::Channel::new()),\n        };\n\n        Receiver { flavor }\n    }\n}","impl<T> Drop for Receiver<T> {\n    fn drop(&mut self) {\n        unsafe {\n            match &self.flavor {\n                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n                ReceiverFlavor::List(chan) => chan.release(|c| c.disconnect()),\n                ReceiverFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n                ReceiverFlavor::After(_) => {}\n                ReceiverFlavor::Tick(_) => {}\n                ReceiverFlavor::Never(_) => {}\n            }\n        }\n    }\n}","impl<T> IntoIterator for Receiver<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter { receiver: self }\n    }\n}","impl<T> Receiver<T> {\n    /// Attempts to receive a message from the channel without blocking.\n    ///\n    /// This method will either receive a message from the channel immediately or return an error\n    /// if the channel is empty.\n    ///\n    /// If called on a zero-capacity channel, this method will receive a message only if there\n    /// happens to be a send operation on the other side of the channel at the same time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{unbounded, TryRecvError};\n    ///\n    /// let (s, r) = unbounded();\n    /// assert_eq!(r.try_recv(), Err(TryRecvError::Empty));\n    ///\n    /// s.send(5).unwrap();\n    /// drop(s);\n    ///\n    /// assert_eq!(r.try_recv(), Ok(5));\n    /// assert_eq!(r.try_recv(), Err(TryRecvError::Disconnected));\n    /// ```\n    pub fn try_recv(&self) -> Result<T, TryRecvError> {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.try_recv(),\n            ReceiverFlavor::List(chan) => chan.try_recv(),\n            ReceiverFlavor::Zero(chan) => chan.try_recv(),\n            ReceiverFlavor::After(chan) => {\n                let msg = chan.try_recv();\n                unsafe {\n                    mem::transmute_copy::<Result<Instant, TryRecvError>, Result<T, TryRecvError>>(\n                        &msg,\n                    )\n                }\n            }\n            ReceiverFlavor::Tick(chan) => {\n                let msg = chan.try_recv();\n                unsafe {\n                    mem::transmute_copy::<Result<Instant, TryRecvError>, Result<T, TryRecvError>>(\n                        &msg,\n                    )\n                }\n            }\n            ReceiverFlavor::Never(chan) => chan.try_recv(),\n        }\n    }\n\n    /// Blocks the current thread until a message is received or the channel is empty and\n    /// disconnected.\n    ///\n    /// If the channel is empty and not disconnected, this call will block until the receive\n    /// operation can proceed. If the channel is empty and becomes disconnected, this call will\n    /// wake up and return an error.\n    ///\n    /// If called on a zero-capacity channel, this method will wait for a send operation to appear\n    /// on the other side of the channel.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    /// use crossbeam_channel::{unbounded, RecvError};\n    ///\n    /// let (s, r) = unbounded();\n    ///\n    /// thread::spawn(move || {\n    ///     thread::sleep(Duration::from_secs(1));\n    ///     s.send(5).unwrap();\n    ///     drop(s);\n    /// });\n    ///\n    /// assert_eq!(r.recv(), Ok(5));\n    /// assert_eq!(r.recv(), Err(RecvError));\n    /// ```\n    pub fn recv(&self) -> Result<T, RecvError> {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.recv(None),\n            ReceiverFlavor::List(chan) => chan.recv(None),\n            ReceiverFlavor::Zero(chan) => chan.recv(None),\n            ReceiverFlavor::After(chan) => {\n                let msg = chan.recv(None);\n                unsafe {\n                    mem::transmute_copy::<\n                        Result<Instant, RecvTimeoutError>,\n                        Result<T, RecvTimeoutError>,\n                    >(&msg)\n                }\n            }\n            ReceiverFlavor::Tick(chan) => {\n                let msg = chan.recv(None);\n                unsafe {\n                    mem::transmute_copy::<\n                        Result<Instant, RecvTimeoutError>,\n                        Result<T, RecvTimeoutError>,\n                    >(&msg)\n                }\n            }\n            ReceiverFlavor::Never(chan) => chan.recv(None),\n        }\n        .map_err(|_| RecvError)\n    }\n\n    /// Waits for a message to be received from the channel, but only for a limited time.\n    ///\n    /// If the channel is empty and not disconnected, this call will block until the receive\n    /// operation can proceed or the operation times out. If the channel is empty and becomes\n    /// disconnected, this call will wake up and return an error.\n    ///\n    /// If called on a zero-capacity channel, this method will wait for a send operation to appear\n    /// on the other side of the channel.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    /// use crossbeam_channel::{unbounded, RecvTimeoutError};\n    ///\n    /// let (s, r) = unbounded();\n    ///\n    /// thread::spawn(move || {\n    ///     thread::sleep(Duration::from_secs(1));\n    ///     s.send(5).unwrap();\n    ///     drop(s);\n    /// });\n    ///\n    /// assert_eq!(\n    ///     r.recv_timeout(Duration::from_millis(500)),\n    ///     Err(RecvTimeoutError::Timeout),\n    /// );\n    /// assert_eq!(\n    ///     r.recv_timeout(Duration::from_secs(1)),\n    ///     Ok(5),\n    /// );\n    /// assert_eq!(\n    ///     r.recv_timeout(Duration::from_secs(1)),\n    ///     Err(RecvTimeoutError::Disconnected),\n    /// );\n    /// ```\n    pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> {\n        let deadline = Instant::now() + timeout;\n\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.recv(Some(deadline)),\n            ReceiverFlavor::List(chan) => chan.recv(Some(deadline)),\n            ReceiverFlavor::Zero(chan) => chan.recv(Some(deadline)),\n            ReceiverFlavor::After(chan) => {\n                let msg = chan.recv(Some(deadline));\n                unsafe {\n                    mem::transmute_copy::<\n                        Result<Instant, RecvTimeoutError>,\n                        Result<T, RecvTimeoutError>,\n                    >(&msg)\n                }\n            }\n            ReceiverFlavor::Tick(chan) => {\n                let msg = chan.recv(Some(deadline));\n                unsafe {\n                    mem::transmute_copy::<\n                        Result<Instant, RecvTimeoutError>,\n                        Result<T, RecvTimeoutError>,\n                    >(&msg)\n                }\n            }\n            ReceiverFlavor::Never(chan) => chan.recv(Some(deadline)),\n        }\n    }\n\n    /// Returns `true` if the channel is empty.\n    ///\n    /// Note: Zero-capacity channels are always empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::unbounded;\n    ///\n    /// let (s, r) = unbounded();\n    ///\n    /// assert!(r.is_empty());\n    /// s.send(0).unwrap();\n    /// assert!(!r.is_empty());\n    /// ```\n    pub fn is_empty(&self) -> bool {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.is_empty(),\n            ReceiverFlavor::List(chan) => chan.is_empty(),\n            ReceiverFlavor::Zero(chan) => chan.is_empty(),\n            ReceiverFlavor::After(chan) => chan.is_empty(),\n            ReceiverFlavor::Tick(chan) => chan.is_empty(),\n            ReceiverFlavor::Never(chan) => chan.is_empty(),\n        }\n    }\n\n    /// Returns `true` if the channel is full.\n    ///\n    /// Note: Zero-capacity channels are always full.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::bounded;\n    ///\n    /// let (s, r) = bounded(1);\n    ///\n    /// assert!(!r.is_full());\n    /// s.send(0).unwrap();\n    /// assert!(r.is_full());\n    /// ```\n    pub fn is_full(&self) -> bool {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.is_full(),\n            ReceiverFlavor::List(chan) => chan.is_full(),\n            ReceiverFlavor::Zero(chan) => chan.is_full(),\n            ReceiverFlavor::After(chan) => chan.is_full(),\n            ReceiverFlavor::Tick(chan) => chan.is_full(),\n            ReceiverFlavor::Never(chan) => chan.is_full(),\n        }\n    }\n\n    /// Returns the number of messages in the channel.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::unbounded;\n    ///\n    /// let (s, r) = unbounded();\n    /// assert_eq!(r.len(), 0);\n    ///\n    /// s.send(1).unwrap();\n    /// s.send(2).unwrap();\n    /// assert_eq!(r.len(), 2);\n    /// ```\n    pub fn len(&self) -> usize {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.len(),\n            ReceiverFlavor::List(chan) => chan.len(),\n            ReceiverFlavor::Zero(chan) => chan.len(),\n            ReceiverFlavor::After(chan) => chan.len(),\n            ReceiverFlavor::Tick(chan) => chan.len(),\n            ReceiverFlavor::Never(chan) => chan.len(),\n        }\n    }\n\n    /// If the channel is bounded, returns its capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{bounded, unbounded};\n    ///\n    /// let (_, r) = unbounded::<i32>();\n    /// assert_eq!(r.capacity(), None);\n    ///\n    /// let (_, r) = bounded::<i32>(5);\n    /// assert_eq!(r.capacity(), Some(5));\n    ///\n    /// let (_, r) = bounded::<i32>(0);\n    /// assert_eq!(r.capacity(), Some(0));\n    /// ```\n    pub fn capacity(&self) -> Option<usize> {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.capacity(),\n            ReceiverFlavor::List(chan) => chan.capacity(),\n            ReceiverFlavor::Zero(chan) => chan.capacity(),\n            ReceiverFlavor::After(chan) => chan.capacity(),\n            ReceiverFlavor::Tick(chan) => chan.capacity(),\n            ReceiverFlavor::Never(chan) => chan.capacity(),\n        }\n    }\n\n    /// A blocking iterator over messages in the channel.\n    ///\n    /// Each call to [`next`] blocks waiting for the next message and then returns it. However, if\n    /// the channel becomes empty and disconnected, it returns [`None`] without blocking.\n    ///\n    /// [`next`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n    /// [`None`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use crossbeam_channel::unbounded;\n    ///\n    /// let (s, r) = unbounded();\n    ///\n    /// thread::spawn(move || {\n    ///     s.send(1).unwrap();\n    ///     s.send(2).unwrap();\n    ///     s.send(3).unwrap();\n    ///     drop(s); // Disconnect the channel.\n    /// });\n    ///\n    /// // Collect all messages from the channel.\n    /// // Note that the call to `collect` blocks until the sender is dropped.\n    /// let v: Vec<_> = r.iter().collect();\n    ///\n    /// assert_eq!(v, [1, 2, 3]);\n    /// ```\n    pub fn iter(&self) -> Iter<'_, T> {\n        Iter { receiver: self }\n    }\n\n    /// A non-blocking iterator over messages in the channel.\n    ///\n    /// Each call to [`next`] returns a message if there is one ready to be received. The iterator\n    /// never blocks waiting for the next message.\n    ///\n    /// [`next`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    /// use crossbeam_channel::unbounded;\n    ///\n    /// let (s, r) = unbounded::<i32>();\n    ///\n    /// thread::spawn(move || {\n    ///     s.send(1).unwrap();\n    ///     thread::sleep(Duration::from_secs(1));\n    ///     s.send(2).unwrap();\n    ///     thread::sleep(Duration::from_secs(2));\n    ///     s.send(3).unwrap();\n    /// });\n    ///\n    /// thread::sleep(Duration::from_secs(2));\n    ///\n    /// // Collect all messages from the channel without blocking.\n    /// // The third message hasn't been sent yet so we'll collect only the first two.\n    /// let v: Vec<_> = r.try_iter().collect();\n    ///\n    /// assert_eq!(v, [1, 2]);\n    /// ```\n    pub fn try_iter(&self) -> TryIter<'_, T> {\n        TryIter { receiver: self }\n    }\n\n    /// Returns `true` if receivers belong to the same channel.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use crossbeam_channel::unbounded;\n    ///\n    /// let (_, r) = unbounded::<usize>();\n    ///\n    /// let r2 = r.clone();\n    /// assert!(r.same_channel(&r2));\n    ///\n    /// let (_, r3) = unbounded();\n    /// assert!(!r.same_channel(&r3));\n    /// ```\n    pub fn same_channel(&self, other: &Receiver<T>) -> bool {\n        match (&self.flavor, &other.flavor) {\n            (ReceiverFlavor::Array(a), ReceiverFlavor::Array(b)) => a == b,\n            (ReceiverFlavor::List(a), ReceiverFlavor::List(b)) => a == b,\n            (ReceiverFlavor::Zero(a), ReceiverFlavor::Zero(b)) => a == b,\n            (ReceiverFlavor::After(a), ReceiverFlavor::After(b)) => Arc::ptr_eq(a, b),\n            (ReceiverFlavor::Tick(a), ReceiverFlavor::Tick(b)) => Arc::ptr_eq(a, b),\n            (ReceiverFlavor::Never(_), ReceiverFlavor::Never(_)) => true,\n            _ => false,\n        }\n    }\n}","impl<T> RefUnwindSafe for Receiver<T> {}","impl<T> SelectHandle for Receiver<T> {\n    fn try_select(&self, token: &mut Token) -> bool {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().try_select(token),\n            ReceiverFlavor::List(chan) => chan.receiver().try_select(token),\n            ReceiverFlavor::Zero(chan) => chan.receiver().try_select(token),\n            ReceiverFlavor::After(chan) => chan.try_select(token),\n            ReceiverFlavor::Tick(chan) => chan.try_select(token),\n            ReceiverFlavor::Never(chan) => chan.try_select(token),\n        }\n    }\n\n    fn deadline(&self) -> Option<Instant> {\n        match &self.flavor {\n            ReceiverFlavor::Array(_) => None,\n            ReceiverFlavor::List(_) => None,\n            ReceiverFlavor::Zero(_) => None,\n            ReceiverFlavor::After(chan) => chan.deadline(),\n            ReceiverFlavor::Tick(chan) => chan.deadline(),\n            ReceiverFlavor::Never(chan) => chan.deadline(),\n        }\n    }\n\n    fn register(&self, oper: Operation, cx: &Context) -> bool {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().register(oper, cx),\n            ReceiverFlavor::List(chan) => chan.receiver().register(oper, cx),\n            ReceiverFlavor::Zero(chan) => chan.receiver().register(oper, cx),\n            ReceiverFlavor::After(chan) => chan.register(oper, cx),\n            ReceiverFlavor::Tick(chan) => chan.register(oper, cx),\n            ReceiverFlavor::Never(chan) => chan.register(oper, cx),\n        }\n    }\n\n    fn unregister(&self, oper: Operation) {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().unregister(oper),\n            ReceiverFlavor::List(chan) => chan.receiver().unregister(oper),\n            ReceiverFlavor::Zero(chan) => chan.receiver().unregister(oper),\n            ReceiverFlavor::After(chan) => chan.unregister(oper),\n            ReceiverFlavor::Tick(chan) => chan.unregister(oper),\n            ReceiverFlavor::Never(chan) => chan.unregister(oper),\n        }\n    }\n\n    fn accept(&self, token: &mut Token, cx: &Context) -> bool {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().accept(token, cx),\n            ReceiverFlavor::List(chan) => chan.receiver().accept(token, cx),\n            ReceiverFlavor::Zero(chan) => chan.receiver().accept(token, cx),\n            ReceiverFlavor::After(chan) => chan.accept(token, cx),\n            ReceiverFlavor::Tick(chan) => chan.accept(token, cx),\n            ReceiverFlavor::Never(chan) => chan.accept(token, cx),\n        }\n    }\n\n    fn is_ready(&self) -> bool {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().is_ready(),\n            ReceiverFlavor::List(chan) => chan.receiver().is_ready(),\n            ReceiverFlavor::Zero(chan) => chan.receiver().is_ready(),\n            ReceiverFlavor::After(chan) => chan.is_ready(),\n            ReceiverFlavor::Tick(chan) => chan.is_ready(),\n            ReceiverFlavor::Never(chan) => chan.is_ready(),\n        }\n    }\n\n    fn watch(&self, oper: Operation, cx: &Context) -> bool {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().watch(oper, cx),\n            ReceiverFlavor::List(chan) => chan.receiver().watch(oper, cx),\n            ReceiverFlavor::Zero(chan) => chan.receiver().watch(oper, cx),\n            ReceiverFlavor::After(chan) => chan.watch(oper, cx),\n            ReceiverFlavor::Tick(chan) => chan.watch(oper, cx),\n            ReceiverFlavor::Never(chan) => chan.watch(oper, cx),\n        }\n    }\n\n    fn unwatch(&self, oper: Operation) {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().unwatch(oper),\n            ReceiverFlavor::List(chan) => chan.receiver().unwatch(oper),\n            ReceiverFlavor::Zero(chan) => chan.receiver().unwatch(oper),\n            ReceiverFlavor::After(chan) => chan.unwatch(oper),\n            ReceiverFlavor::Tick(chan) => chan.unwatch(oper),\n            ReceiverFlavor::Never(chan) => chan.unwatch(oper),\n        }\n    }\n}","impl<T> UnwindSafe for Receiver<T> {}","impl<T> fmt::Debug for Receiver<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"Receiver { .. }\")\n    }\n}","unsafe impl<T: Send> Send for Receiver<T> {}","unsafe impl<T: Send> Sync for Receiver<T> {}"],"channel::Sender":["impl<T> Clone for Sender<T> {\n    fn clone(&self) -> Self {\n        let flavor = match &self.flavor {\n            SenderFlavor::Array(chan) => SenderFlavor::Array(chan.acquire()),\n            SenderFlavor::List(chan) => SenderFlavor::List(chan.acquire()),\n            SenderFlavor::Zero(chan) => SenderFlavor::Zero(chan.acquire()),\n        };\n\n        Sender { flavor }\n    }\n}","impl<T> Drop for Sender<T> {\n    fn drop(&mut self) {\n        unsafe {\n            match &self.flavor {\n                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n                SenderFlavor::List(chan) => chan.release(|c| c.disconnect()),\n                SenderFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n            }\n        }\n    }\n}","impl<T> RefUnwindSafe for Sender<T> {}","impl<T> SelectHandle for Sender<T> {\n    fn try_select(&self, token: &mut Token) -> bool {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().try_select(token),\n            SenderFlavor::List(chan) => chan.sender().try_select(token),\n            SenderFlavor::Zero(chan) => chan.sender().try_select(token),\n        }\n    }\n\n    fn deadline(&self) -> Option<Instant> {\n        None\n    }\n\n    fn register(&self, oper: Operation, cx: &Context) -> bool {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().register(oper, cx),\n            SenderFlavor::List(chan) => chan.sender().register(oper, cx),\n            SenderFlavor::Zero(chan) => chan.sender().register(oper, cx),\n        }\n    }\n\n    fn unregister(&self, oper: Operation) {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().unregister(oper),\n            SenderFlavor::List(chan) => chan.sender().unregister(oper),\n            SenderFlavor::Zero(chan) => chan.sender().unregister(oper),\n        }\n    }\n\n    fn accept(&self, token: &mut Token, cx: &Context) -> bool {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().accept(token, cx),\n            SenderFlavor::List(chan) => chan.sender().accept(token, cx),\n            SenderFlavor::Zero(chan) => chan.sender().accept(token, cx),\n        }\n    }\n\n    fn is_ready(&self) -> bool {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().is_ready(),\n            SenderFlavor::List(chan) => chan.sender().is_ready(),\n            SenderFlavor::Zero(chan) => chan.sender().is_ready(),\n        }\n    }\n\n    fn watch(&self, oper: Operation, cx: &Context) -> bool {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().watch(oper, cx),\n            SenderFlavor::List(chan) => chan.sender().watch(oper, cx),\n            SenderFlavor::Zero(chan) => chan.sender().watch(oper, cx),\n        }\n    }\n\n    fn unwatch(&self, oper: Operation) {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().unwatch(oper),\n            SenderFlavor::List(chan) => chan.sender().unwatch(oper),\n            SenderFlavor::Zero(chan) => chan.sender().unwatch(oper),\n        }\n    }\n}","impl<T> Sender<T> {\n    /// Attempts to send a message into the channel without blocking.\n    ///\n    /// This method will either send a message into the channel immediately or return an error if\n    /// the channel is full or disconnected. The returned error contains the original message.\n    ///\n    /// If called on a zero-capacity channel, this method will send the message only if there\n    /// happens to be a receive operation on the other side of the channel at the same time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{bounded, TrySendError};\n    ///\n    /// let (s, r) = bounded(1);\n    ///\n    /// assert_eq!(s.try_send(1), Ok(()));\n    /// assert_eq!(s.try_send(2), Err(TrySendError::Full(2)));\n    ///\n    /// drop(r);\n    /// assert_eq!(s.try_send(3), Err(TrySendError::Disconnected(3)));\n    /// ```\n    pub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.try_send(msg),\n            SenderFlavor::List(chan) => chan.try_send(msg),\n            SenderFlavor::Zero(chan) => chan.try_send(msg),\n        }\n    }\n\n    /// Blocks the current thread until a message is sent or the channel is disconnected.\n    ///\n    /// If the channel is full and not disconnected, this call will block until the send operation\n    /// can proceed. If the channel becomes disconnected, this call will wake up and return an\n    /// error. The returned error contains the original message.\n    ///\n    /// If called on a zero-capacity channel, this method will wait for a receive operation to\n    /// appear on the other side of the channel.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    /// use crossbeam_channel::{bounded, SendError};\n    ///\n    /// let (s, r) = bounded(1);\n    /// assert_eq!(s.send(1), Ok(()));\n    ///\n    /// thread::spawn(move || {\n    ///     assert_eq!(r.recv(), Ok(1));\n    ///     thread::sleep(Duration::from_secs(1));\n    ///     drop(r);\n    /// });\n    ///\n    /// assert_eq!(s.send(2), Ok(()));\n    /// assert_eq!(s.send(3), Err(SendError(3)));\n    /// ```\n    pub fn send(&self, msg: T) -> Result<(), SendError<T>> {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.send(msg, None),\n            SenderFlavor::List(chan) => chan.send(msg, None),\n            SenderFlavor::Zero(chan) => chan.send(msg, None),\n        }\n        .map_err(|err| match err {\n            SendTimeoutError::Disconnected(msg) => SendError(msg),\n            SendTimeoutError::Timeout(_) => unreachable!(),\n        })\n    }\n\n    /// Waits for a message to be sent into the channel, but only for a limited time.\n    ///\n    /// If the channel is full and not disconnected, this call will block until the send operation\n    /// can proceed or the operation times out. If the channel becomes disconnected, this call will\n    /// wake up and return an error. The returned error contains the original message.\n    ///\n    /// If called on a zero-capacity channel, this method will wait for a receive operation to\n    /// appear on the other side of the channel.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    /// use crossbeam_channel::{bounded, SendTimeoutError};\n    ///\n    /// let (s, r) = bounded(0);\n    ///\n    /// thread::spawn(move || {\n    ///     thread::sleep(Duration::from_secs(1));\n    ///     assert_eq!(r.recv(), Ok(2));\n    ///     drop(r);\n    /// });\n    ///\n    /// assert_eq!(\n    ///     s.send_timeout(1, Duration::from_millis(500)),\n    ///     Err(SendTimeoutError::Timeout(1)),\n    /// );\n    /// assert_eq!(\n    ///     s.send_timeout(2, Duration::from_secs(1)),\n    ///     Ok(()),\n    /// );\n    /// assert_eq!(\n    ///     s.send_timeout(3, Duration::from_millis(500)),\n    ///     Err(SendTimeoutError::Disconnected(3)),\n    /// );\n    /// ```\n    pub fn send_timeout(&self, msg: T, timeout: Duration) -> Result<(), SendTimeoutError<T>> {\n        let deadline = Instant::now() + timeout;\n\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.send(msg, Some(deadline)),\n            SenderFlavor::List(chan) => chan.send(msg, Some(deadline)),\n            SenderFlavor::Zero(chan) => chan.send(msg, Some(deadline)),\n        }\n    }\n\n    /// Returns `true` if the channel is empty.\n    ///\n    /// Note: Zero-capacity channels are always empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::unbounded;\n    ///\n    /// let (s, r) = unbounded();\n    /// assert!(s.is_empty());\n    ///\n    /// s.send(0).unwrap();\n    /// assert!(!s.is_empty());\n    /// ```\n    pub fn is_empty(&self) -> bool {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.is_empty(),\n            SenderFlavor::List(chan) => chan.is_empty(),\n            SenderFlavor::Zero(chan) => chan.is_empty(),\n        }\n    }\n\n    /// Returns `true` if the channel is full.\n    ///\n    /// Note: Zero-capacity channels are always full.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::bounded;\n    ///\n    /// let (s, r) = bounded(1);\n    ///\n    /// assert!(!s.is_full());\n    /// s.send(0).unwrap();\n    /// assert!(s.is_full());\n    /// ```\n    pub fn is_full(&self) -> bool {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.is_full(),\n            SenderFlavor::List(chan) => chan.is_full(),\n            SenderFlavor::Zero(chan) => chan.is_full(),\n        }\n    }\n\n    /// Returns the number of messages in the channel.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::unbounded;\n    ///\n    /// let (s, r) = unbounded();\n    /// assert_eq!(s.len(), 0);\n    ///\n    /// s.send(1).unwrap();\n    /// s.send(2).unwrap();\n    /// assert_eq!(s.len(), 2);\n    /// ```\n    pub fn len(&self) -> usize {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.len(),\n            SenderFlavor::List(chan) => chan.len(),\n            SenderFlavor::Zero(chan) => chan.len(),\n        }\n    }\n\n    /// If the channel is bounded, returns its capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{bounded, unbounded};\n    ///\n    /// let (s, _) = unbounded::<i32>();\n    /// assert_eq!(s.capacity(), None);\n    ///\n    /// let (s, _) = bounded::<i32>(5);\n    /// assert_eq!(s.capacity(), Some(5));\n    ///\n    /// let (s, _) = bounded::<i32>(0);\n    /// assert_eq!(s.capacity(), Some(0));\n    /// ```\n    pub fn capacity(&self) -> Option<usize> {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.capacity(),\n            SenderFlavor::List(chan) => chan.capacity(),\n            SenderFlavor::Zero(chan) => chan.capacity(),\n        }\n    }\n\n    /// Returns `true` if senders belong to the same channel.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use crossbeam_channel::unbounded;\n    ///\n    /// let (s, _) = unbounded::<usize>();\n    ///\n    /// let s2 = s.clone();\n    /// assert!(s.same_channel(&s2));\n    ///\n    /// let (s3, _) = unbounded();\n    /// assert!(!s.same_channel(&s3));\n    /// ```\n    pub fn same_channel(&self, other: &Sender<T>) -> bool {\n        match (&self.flavor, &other.flavor) {\n            (SenderFlavor::Array(ref a), SenderFlavor::Array(ref b)) => a == b,\n            (SenderFlavor::List(ref a), SenderFlavor::List(ref b)) => a == b,\n            (SenderFlavor::Zero(ref a), SenderFlavor::Zero(ref b)) => a == b,\n            _ => false,\n        }\n    }\n}","impl<T> UnwindSafe for Sender<T> {}","impl<T> fmt::Debug for Sender<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"Sender { .. }\")\n    }\n}","unsafe impl<T: Send> Send for Sender<T> {}","unsafe impl<T: Send> Sync for Sender<T> {}"],"channel::TryIter":["impl<T> Iterator for TryIter<'_, T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.receiver.try_recv().ok()\n    }\n}","impl<T> fmt::Debug for TryIter<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"TryIter { .. }\")\n    }\n}"],"context::Context":["Clone","Debug","impl Context {\n    /// Creates a new context for the duration of the closure.\n    #[inline]\n    pub fn with<F, R>(f: F) -> R\n    where\n        F: FnOnce(&Context) -> R,\n    {\n        thread_local! {\n            /// Cached thread-local context.\n            static CONTEXT: Cell<Option<Context>> = Cell::new(Some(Context::new()));\n        }\n\n        let mut f = Some(f);\n        let mut f = move |cx: &Context| -> R {\n            let f = f.take().unwrap();\n            f(cx)\n        };\n\n        CONTEXT\n            .try_with(|cell| match cell.take() {\n                None => f(&Context::new()),\n                Some(cx) => {\n                    cx.reset();\n                    let res = f(&cx);\n                    cell.set(Some(cx));\n                    res\n                }\n            })\n            .unwrap_or_else(|_| f(&Context::new()))\n    }\n\n    /// Creates a new `Context`.\n    #[cold]\n    fn new() -> Context {\n        Context {\n            inner: Arc::new(Inner {\n                select: AtomicUsize::new(Selected::Waiting.into()),\n                packet: AtomicUsize::new(0),\n                thread: thread::current(),\n                thread_id: thread::current().id(),\n            }),\n        }\n    }\n\n    /// Resets `select` and `packet`.\n    #[inline]\n    fn reset(&self) {\n        self.inner\n            .select\n            .store(Selected::Waiting.into(), Ordering::Release);\n        self.inner.packet.store(0, Ordering::Release);\n    }\n\n    /// Attempts to select an operation.\n    ///\n    /// On failure, the previously selected operation is returned.\n    #[inline]\n    pub fn try_select(&self, select: Selected) -> Result<(), Selected> {\n        self.inner\n            .select\n            .compare_exchange(\n                Selected::Waiting.into(),\n                select.into(),\n                Ordering::AcqRel,\n                Ordering::Acquire,\n            )\n            .map(|_| ())\n            .map_err(|e| e.into())\n    }\n\n    /// Returns the selected operation.\n    #[inline]\n    pub fn selected(&self) -> Selected {\n        Selected::from(self.inner.select.load(Ordering::Acquire))\n    }\n\n    /// Stores a packet.\n    ///\n    /// This method must be called after `try_select` succeeds and there is a packet to provide.\n    #[inline]\n    pub fn store_packet(&self, packet: usize) {\n        if packet != 0 {\n            self.inner.packet.store(packet, Ordering::Release);\n        }\n    }\n\n    /// Waits until a packet is provided and returns it.\n    #[inline]\n    pub fn wait_packet(&self) -> usize {\n        let backoff = Backoff::new();\n        loop {\n            let packet = self.inner.packet.load(Ordering::Acquire);\n            if packet != 0 {\n                return packet;\n            }\n            backoff.snooze();\n        }\n    }\n\n    /// Waits until an operation is selected and returns it.\n    ///\n    /// If the deadline is reached, `Selected::Aborted` will be selected.\n    #[inline]\n    pub fn wait_until(&self, deadline: Option<Instant>) -> Selected {\n        // Spin for a short time, waiting until an operation is selected.\n        let backoff = Backoff::new();\n        loop {\n            let sel = Selected::from(self.inner.select.load(Ordering::Acquire));\n            if sel != Selected::Waiting {\n                return sel;\n            }\n\n            if backoff.is_completed() {\n                break;\n            } else {\n                backoff.snooze();\n            }\n        }\n\n        loop {\n            // Check whether an operation has been selected.\n            let sel = Selected::from(self.inner.select.load(Ordering::Acquire));\n            if sel != Selected::Waiting {\n                return sel;\n            }\n\n            // If there's a deadline, park the current thread until the deadline is reached.\n            if let Some(end) = deadline {\n                let now = Instant::now();\n\n                if now < end {\n                    thread::park_timeout(end - now);\n                } else {\n                    // The deadline has been reached. Try aborting select.\n                    return match self.try_select(Selected::Aborted) {\n                        Ok(()) => Selected::Aborted,\n                        Err(s) => s,\n                    };\n                }\n            } else {\n                thread::park();\n            }\n        }\n    }\n\n    /// Unparks the thread this context belongs to.\n    #[inline]\n    pub fn unpark(&self) {\n        self.inner.thread.unpark();\n    }\n\n    /// Returns the id of the thread this context belongs to.\n    #[inline]\n    pub fn thread_id(&self) -> ThreadId {\n        self.inner.thread_id\n    }\n}"],"context::Inner":["Debug"],"counter::Receiver":["impl<C> PartialEq for Receiver<C> {\n    fn eq(&self, other: &Receiver<C>) -> bool {\n        self.counter == other.counter\n    }\n}","impl<C> Receiver<C> {\n    /// Returns the internal `Counter`.\n    fn counter(&self) -> &Counter<C> {\n        unsafe { &*self.counter }\n    }\n\n    /// Acquires another receiver reference.\n    pub fn acquire(&self) -> Receiver<C> {\n        let count = self.counter().receivers.fetch_add(1, Ordering::Relaxed);\n\n        // Cloning receivers and calling `mem::forget` on the clones could potentially overflow the\n        // counter. It's very difficult to recover sensibly from such degenerate scenarios so we\n        // just abort when the count becomes very large.\n        if count > isize::MAX as usize {\n            process::abort();\n        }\n\n        Receiver {\n            counter: self.counter,\n        }\n    }\n\n    /// Releases the receiver reference.\n    ///\n    /// Function `disconnect` will be called if this is the last receiver reference.\n    pub unsafe fn release<F: FnOnce(&C) -> bool>(&self, disconnect: F) {\n        if self.counter().receivers.fetch_sub(1, Ordering::AcqRel) == 1 {\n            disconnect(&self.counter().chan);\n\n            if self.counter().destroy.swap(true, Ordering::AcqRel) {\n                drop(Box::from_raw(self.counter));\n            }\n        }\n    }\n}","impl<C> ops::Deref for Receiver<C> {\n    type Target = C;\n\n    fn deref(&self) -> &C {\n        &self.counter().chan\n    }\n}"],"counter::Sender":["impl<C> PartialEq for Sender<C> {\n    fn eq(&self, other: &Sender<C>) -> bool {\n        self.counter == other.counter\n    }\n}","impl<C> Sender<C> {\n    /// Returns the internal `Counter`.\n    fn counter(&self) -> &Counter<C> {\n        unsafe { &*self.counter }\n    }\n\n    /// Acquires another sender reference.\n    pub fn acquire(&self) -> Sender<C> {\n        let count = self.counter().senders.fetch_add(1, Ordering::Relaxed);\n\n        // Cloning senders and calling `mem::forget` on the clones could potentially overflow the\n        // counter. It's very difficult to recover sensibly from such degenerate scenarios so we\n        // just abort when the count becomes very large.\n        if count > isize::MAX as usize {\n            process::abort();\n        }\n\n        Sender {\n            counter: self.counter,\n        }\n    }\n\n    /// Releases the sender reference.\n    ///\n    /// Function `disconnect` will be called if this is the last sender reference.\n    pub unsafe fn release<F: FnOnce(&C) -> bool>(&self, disconnect: F) {\n        if self.counter().senders.fetch_sub(1, Ordering::AcqRel) == 1 {\n            disconnect(&self.counter().chan);\n\n            if self.counter().destroy.swap(true, Ordering::AcqRel) {\n                drop(Box::from_raw(self.counter));\n            }\n        }\n    }\n}","impl<C> ops::Deref for Sender<C> {\n    type Target = C;\n\n    fn deref(&self) -> &C {\n        &self.counter().chan\n    }\n}"],"err::ReadyTimeoutError":["Clone","Copy","Debug","Eq","PartialEq"],"err::RecvError":["Clone","Copy","Debug","Eq","PartialEq","impl error::Error for RecvError {}","impl fmt::Display for RecvError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"receiving on an empty and disconnected channel\".fmt(f)\n    }\n}"],"err::RecvTimeoutError":["Clone","Copy","Debug","Eq","PartialEq","impl From<RecvError> for RecvTimeoutError {\n    fn from(err: RecvError) -> RecvTimeoutError {\n        match err {\n            RecvError => RecvTimeoutError::Disconnected,\n        }\n    }\n}","impl RecvTimeoutError {\n    /// Returns `true` if the receive operation timed out.\n    #[allow(clippy::trivially_copy_pass_by_ref)]\n    pub fn is_timeout(&self) -> bool {\n        match self {\n            RecvTimeoutError::Timeout => true,\n            _ => false,\n        }\n    }\n\n    /// Returns `true` if the receive operation failed because the channel is disconnected.\n    #[allow(clippy::trivially_copy_pass_by_ref)]\n    pub fn is_disconnected(&self) -> bool {\n        match self {\n            RecvTimeoutError::Disconnected => true,\n            _ => false,\n        }\n    }\n}","impl error::Error for RecvTimeoutError {}","impl fmt::Display for RecvTimeoutError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            RecvTimeoutError::Timeout => \"timed out waiting on receive operation\".fmt(f),\n            RecvTimeoutError::Disconnected => \"channel is empty and disconnected\".fmt(f),\n        }\n    }\n}"],"err::SelectTimeoutError":["Clone","Copy","Debug","Eq","PartialEq","impl error::Error for SelectTimeoutError {}","impl fmt::Display for SelectTimeoutError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"timed out waiting on select\".fmt(f)\n    }\n}"],"err::SendError":["Clone","Copy","Eq","PartialEq","impl<T: Send> error::Error for SendError<T> {}","impl<T> SendError<T> {\n    /// Unwraps the message.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::unbounded;\n    ///\n    /// let (s, r) = unbounded();\n    /// drop(r);\n    ///\n    /// if let Err(err) = s.send(\"foo\") {\n    ///     assert_eq!(err.into_inner(), \"foo\");\n    /// }\n    /// ```\n    pub fn into_inner(self) -> T {\n        self.0\n    }\n}","impl<T> fmt::Debug for SendError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"SendError(..)\".fmt(f)\n    }\n}","impl<T> fmt::Display for SendError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"sending on a disconnected channel\".fmt(f)\n    }\n}"],"err::SendTimeoutError":["Clone","Copy","Eq","PartialEq","impl<T: Send> error::Error for SendTimeoutError<T> {}","impl<T> From<SendError<T>> for SendTimeoutError<T> {\n    fn from(err: SendError<T>) -> SendTimeoutError<T> {\n        match err {\n            SendError(e) => SendTimeoutError::Disconnected(e),\n        }\n    }\n}","impl<T> SendTimeoutError<T> {\n    /// Unwraps the message.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    /// use crossbeam_channel::unbounded;\n    ///\n    /// let (s, r) = unbounded();\n    ///\n    /// if let Err(err) = s.send_timeout(\"foo\", Duration::from_secs(1)) {\n    ///     assert_eq!(err.into_inner(), \"foo\");\n    /// }\n    /// ```\n    pub fn into_inner(self) -> T {\n        match self {\n            SendTimeoutError::Timeout(v) => v,\n            SendTimeoutError::Disconnected(v) => v,\n        }\n    }\n\n    /// Returns `true` if the send operation timed out.\n    pub fn is_timeout(&self) -> bool {\n        match self {\n            SendTimeoutError::Timeout(_) => true,\n            _ => false,\n        }\n    }\n\n    /// Returns `true` if the send operation failed because the channel is disconnected.\n    pub fn is_disconnected(&self) -> bool {\n        match self {\n            SendTimeoutError::Disconnected(_) => true,\n            _ => false,\n        }\n    }\n}","impl<T> fmt::Debug for SendTimeoutError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"SendTimeoutError(..)\".fmt(f)\n    }\n}","impl<T> fmt::Display for SendTimeoutError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            SendTimeoutError::Timeout(..) => \"timed out waiting on send operation\".fmt(f),\n            SendTimeoutError::Disconnected(..) => \"sending on a disconnected channel\".fmt(f),\n        }\n    }\n}"],"err::TryReadyError":["Clone","Copy","Debug","Eq","PartialEq"],"err::TryRecvError":["Clone","Copy","Debug","Eq","PartialEq","impl From<RecvError> for TryRecvError {\n    fn from(err: RecvError) -> TryRecvError {\n        match err {\n            RecvError => TryRecvError::Disconnected,\n        }\n    }\n}","impl TryRecvError {\n    /// Returns `true` if the receive operation failed because the channel is empty.\n    #[allow(clippy::trivially_copy_pass_by_ref)]\n    pub fn is_empty(&self) -> bool {\n        match self {\n            TryRecvError::Empty => true,\n            _ => false,\n        }\n    }\n\n    /// Returns `true` if the receive operation failed because the channel is disconnected.\n    #[allow(clippy::trivially_copy_pass_by_ref)]\n    pub fn is_disconnected(&self) -> bool {\n        match self {\n            TryRecvError::Disconnected => true,\n            _ => false,\n        }\n    }\n}","impl error::Error for TryRecvError {}","impl fmt::Display for TryRecvError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            TryRecvError::Empty => \"receiving on an empty channel\".fmt(f),\n            TryRecvError::Disconnected => \"receiving on an empty and disconnected channel\".fmt(f),\n        }\n    }\n}"],"err::TrySelectError":["Clone","Copy","Debug","Eq","PartialEq","impl error::Error for TrySelectError {}","impl fmt::Display for TrySelectError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"all operations in select would block\".fmt(f)\n    }\n}"],"err::TrySendError":["Clone","Copy","Eq","PartialEq","impl<T: Send> error::Error for TrySendError<T> {}","impl<T> From<SendError<T>> for TrySendError<T> {\n    fn from(err: SendError<T>) -> TrySendError<T> {\n        match err {\n            SendError(t) => TrySendError::Disconnected(t),\n        }\n    }\n}","impl<T> TrySendError<T> {\n    /// Unwraps the message.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::bounded;\n    ///\n    /// let (s, r) = bounded(0);\n    ///\n    /// if let Err(err) = s.try_send(\"foo\") {\n    ///     assert_eq!(err.into_inner(), \"foo\");\n    /// }\n    /// ```\n    pub fn into_inner(self) -> T {\n        match self {\n            TrySendError::Full(v) => v,\n            TrySendError::Disconnected(v) => v,\n        }\n    }\n\n    /// Returns `true` if the send operation failed because the channel is full.\n    pub fn is_full(&self) -> bool {\n        match self {\n            TrySendError::Full(_) => true,\n            _ => false,\n        }\n    }\n\n    /// Returns `true` if the send operation failed because the channel is disconnected.\n    pub fn is_disconnected(&self) -> bool {\n        match self {\n            TrySendError::Disconnected(_) => true,\n            _ => false,\n        }\n    }\n}","impl<T> fmt::Debug for TrySendError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            TrySendError::Full(..) => \"Full(..)\".fmt(f),\n            TrySendError::Disconnected(..) => \"Disconnected(..)\".fmt(f),\n        }\n    }\n}","impl<T> fmt::Display for TrySendError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            TrySendError::Full(..) => \"sending on a full channel\".fmt(f),\n            TrySendError::Disconnected(..) => \"sending on a disconnected channel\".fmt(f),\n        }\n    }\n}"],"flavors::after::Channel":["impl Channel {\n    /// Creates a channel that delivers a message after a certain duration of time.\n    #[inline]\n    pub fn new(dur: Duration) -> Self {\n        Channel {\n            delivery_time: Instant::now() + dur,\n            received: AtomicBool::new(false),\n        }\n    }\n\n    /// Attempts to receive a message without blocking.\n    #[inline]\n    pub fn try_recv(&self) -> Result<Instant, TryRecvError> {\n        // We use relaxed ordering because this is just an optional optimistic check.\n        if self.received.load(Ordering::Relaxed) {\n            // The message has already been received.\n            return Err(TryRecvError::Empty);\n        }\n\n        if Instant::now() < self.delivery_time {\n            // The message was not delivered yet.\n            return Err(TryRecvError::Empty);\n        }\n\n        // Try receiving the message if it is still available.\n        if !self.received.swap(true, Ordering::SeqCst) {\n            // Success! Return delivery time as the message.\n            Ok(self.delivery_time)\n        } else {\n            // The message was already received.\n            Err(TryRecvError::Empty)\n        }\n    }\n\n    /// Receives a message from the channel.\n    #[inline]\n    pub fn recv(&self, deadline: Option<Instant>) -> Result<Instant, RecvTimeoutError> {\n        // We use relaxed ordering because this is just an optional optimistic check.\n        if self.received.load(Ordering::Relaxed) {\n            // The message has already been received.\n            utils::sleep_until(deadline);\n            return Err(RecvTimeoutError::Timeout);\n        }\n\n        // Wait until the message is received or the deadline is reached.\n        loop {\n            let now = Instant::now();\n\n            // Check if we can receive the next message.\n            if now >= self.delivery_time {\n                break;\n            }\n\n            // Check if the deadline has been reached.\n            if let Some(d) = deadline {\n                if now >= d {\n                    return Err(RecvTimeoutError::Timeout);\n                }\n\n                thread::sleep(self.delivery_time.min(d) - now);\n            } else {\n                thread::sleep(self.delivery_time - now);\n            }\n        }\n\n        // Try receiving the message if it is still available.\n        if !self.received.swap(true, Ordering::SeqCst) {\n            // Success! Return the message, which is the instant at which it was delivered.\n            Ok(self.delivery_time)\n        } else {\n            // The message was already received. Block forever.\n            utils::sleep_until(None);\n            unreachable!()\n        }\n    }\n\n    /// Reads a message from the channel.\n    #[inline]\n    pub unsafe fn read(&self, token: &mut Token) -> Result<Instant, ()> {\n        token.after.ok_or(())\n    }\n\n    /// Returns `true` if the channel is empty.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        // We use relaxed ordering because this is just an optional optimistic check.\n        if self.received.load(Ordering::Relaxed) {\n            return true;\n        }\n\n        // If the delivery time hasn't been reached yet, the channel is empty.\n        if Instant::now() < self.delivery_time {\n            return true;\n        }\n\n        // The delivery time has been reached. The channel is empty only if the message has already\n        // been received.\n        self.received.load(Ordering::SeqCst)\n    }\n\n    /// Returns `true` if the channel is full.\n    #[inline]\n    pub fn is_full(&self) -> bool {\n        !self.is_empty()\n    }\n\n    /// Returns the number of messages in the channel.\n    #[inline]\n    pub fn len(&self) -> usize {\n        if self.is_empty() {\n            0\n        } else {\n            1\n        }\n    }\n\n    /// Returns the capacity of the channel.\n    #[inline]\n    pub fn capacity(&self) -> Option<usize> {\n        Some(1)\n    }\n}","impl SelectHandle for Channel {\n    #[inline]\n    fn try_select(&self, token: &mut Token) -> bool {\n        match self.try_recv() {\n            Ok(msg) => {\n                token.after = Some(msg);\n                true\n            }\n            Err(TryRecvError::Disconnected) => {\n                token.after = None;\n                true\n            }\n            Err(TryRecvError::Empty) => false,\n        }\n    }\n\n    #[inline]\n    fn deadline(&self) -> Option<Instant> {\n        // We use relaxed ordering because this is just an optional optimistic check.\n        if self.received.load(Ordering::Relaxed) {\n            None\n        } else {\n            Some(self.delivery_time)\n        }\n    }\n\n    #[inline]\n    fn register(&self, _oper: Operation, _cx: &Context) -> bool {\n        self.is_ready()\n    }\n\n    #[inline]\n    fn unregister(&self, _oper: Operation) {}\n\n    #[inline]\n    fn accept(&self, token: &mut Token, _cx: &Context) -> bool {\n        self.try_select(token)\n    }\n\n    #[inline]\n    fn is_ready(&self) -> bool {\n        !self.is_empty()\n    }\n\n    #[inline]\n    fn watch(&self, _oper: Operation, _cx: &Context) -> bool {\n        self.is_ready()\n    }\n\n    #[inline]\n    fn unwatch(&self, _oper: Operation) {}\n}"],"flavors::array::ArrayToken":["Debug","impl Default for ArrayToken {\n    #[inline]\n    fn default() -> Self {\n        ArrayToken {\n            slot: ptr::null(),\n            stamp: 0,\n        }\n    }\n}"],"flavors::array::Channel":["impl<T> Channel<T> {\n    /// Creates a bounded channel of capacity `cap`.\n    pub fn with_capacity(cap: usize) -> Self {\n        assert!(cap > 0, \"capacity must be positive\");\n\n        // Compute constants `mark_bit` and `one_lap`.\n        let mark_bit = (cap + 1).next_power_of_two();\n        let one_lap = mark_bit * 2;\n\n        // Head is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n        let head = 0;\n        // Tail is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n        let tail = 0;\n\n        // Allocate a buffer of `cap` slots initialized\n        // with stamps.\n        let buffer = {\n            let mut v: Vec<Slot<T>> = (0..cap)\n                .map(|i| {\n                    // Set the stamp to `{ lap: 0, mark: 0, index: i }`.\n                    Slot {\n                        stamp: AtomicUsize::new(i),\n                        msg: UnsafeCell::new(MaybeUninit::uninit()),\n                    }\n                })\n                .collect();\n            let ptr = v.as_mut_ptr();\n            mem::forget(v);\n            ptr\n        };\n\n        Channel {\n            buffer,\n            cap,\n            one_lap,\n            mark_bit,\n            head: CachePadded::new(AtomicUsize::new(head)),\n            tail: CachePadded::new(AtomicUsize::new(tail)),\n            senders: SyncWaker::new(),\n            receivers: SyncWaker::new(),\n            _marker: PhantomData,\n        }\n    }\n\n    /// Returns a receiver handle to the channel.\n    pub fn receiver(&self) -> Receiver<'_, T> {\n        Receiver(self)\n    }\n\n    /// Returns a sender handle to the channel.\n    pub fn sender(&self) -> Sender<'_, T> {\n        Sender(self)\n    }\n\n    /// Attempts to reserve a slot for sending a message.\n    fn start_send(&self, token: &mut Token) -> bool {\n        let backoff = Backoff::new();\n        let mut tail = self.tail.load(Ordering::Relaxed);\n\n        loop {\n            // Check if the channel is disconnected.\n            if tail & self.mark_bit != 0 {\n                token.array.slot = ptr::null();\n                token.array.stamp = 0;\n                return true;\n            }\n\n            // Deconstruct the tail.\n            let index = tail & (self.mark_bit - 1);\n            let lap = tail & !(self.one_lap - 1);\n\n            // Inspect the corresponding slot.\n            let slot = unsafe { &*self.buffer.add(index) };\n            let stamp = slot.stamp.load(Ordering::Acquire);\n\n            // If the tail and the stamp match, we may attempt to push.\n            if tail == stamp {\n                let new_tail = if index + 1 < self.cap {\n                    // Same lap, incremented index.\n                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n                    tail + 1\n                } else {\n                    // One lap forward, index wraps around to zero.\n                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n                    lap.wrapping_add(self.one_lap)\n                };\n\n                // Try moving the tail.\n                match self.tail.compare_exchange_weak(\n                    tail,\n                    new_tail,\n                    Ordering::SeqCst,\n                    Ordering::Relaxed,\n                ) {\n                    Ok(_) => {\n                        // Prepare the token for the follow-up call to `write`.\n                        token.array.slot = slot as *const Slot<T> as *const u8;\n                        token.array.stamp = tail + 1;\n                        return true;\n                    }\n                    Err(t) => {\n                        tail = t;\n                        backoff.spin();\n                    }\n                }\n            } else if stamp.wrapping_add(self.one_lap) == tail + 1 {\n                atomic::fence(Ordering::SeqCst);\n                let head = self.head.load(Ordering::Relaxed);\n\n                // If the head lags one lap behind the tail as well...\n                if head.wrapping_add(self.one_lap) == tail {\n                    // ...then the channel is full.\n                    return false;\n                }\n\n                backoff.spin();\n                tail = self.tail.load(Ordering::Relaxed);\n            } else {\n                // Snooze because we need to wait for the stamp to get updated.\n                backoff.snooze();\n                tail = self.tail.load(Ordering::Relaxed);\n            }\n        }\n    }\n\n    /// Writes a message into the channel.\n    pub unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n        // If there is no slot, the channel is disconnected.\n        if token.array.slot.is_null() {\n            return Err(msg);\n        }\n\n        let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n\n        // Write the message into the slot and update the stamp.\n        slot.msg.get().write(MaybeUninit::new(msg));\n        slot.stamp.store(token.array.stamp, Ordering::Release);\n\n        // Wake a sleeping receiver.\n        self.receivers.notify();\n        Ok(())\n    }\n\n    /// Attempts to reserve a slot for receiving a message.\n    fn start_recv(&self, token: &mut Token) -> bool {\n        let backoff = Backoff::new();\n        let mut head = self.head.load(Ordering::Relaxed);\n\n        loop {\n            // Deconstruct the head.\n            let index = head & (self.mark_bit - 1);\n            let lap = head & !(self.one_lap - 1);\n\n            // Inspect the corresponding slot.\n            let slot = unsafe { &*self.buffer.add(index) };\n            let stamp = slot.stamp.load(Ordering::Acquire);\n\n            // If the the stamp is ahead of the head by 1, we may attempt to pop.\n            if head + 1 == stamp {\n                let new = if index + 1 < self.cap {\n                    // Same lap, incremented index.\n                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n                    head + 1\n                } else {\n                    // One lap forward, index wraps around to zero.\n                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n                    lap.wrapping_add(self.one_lap)\n                };\n\n                // Try moving the head.\n                match self.head.compare_exchange_weak(\n                    head,\n                    new,\n                    Ordering::SeqCst,\n                    Ordering::Relaxed,\n                ) {\n                    Ok(_) => {\n                        // Prepare the token for the follow-up call to `read`.\n                        token.array.slot = slot as *const Slot<T> as *const u8;\n                        token.array.stamp = head.wrapping_add(self.one_lap);\n                        return true;\n                    }\n                    Err(h) => {\n                        head = h;\n                        backoff.spin();\n                    }\n                }\n            } else if stamp == head {\n                atomic::fence(Ordering::SeqCst);\n                let tail = self.tail.load(Ordering::Relaxed);\n\n                // If the tail equals the head, that means the channel is empty.\n                if (tail & !self.mark_bit) == head {\n                    // If the channel is disconnected...\n                    if tail & self.mark_bit != 0 {\n                        // ...then receive an error.\n                        token.array.slot = ptr::null();\n                        token.array.stamp = 0;\n                        return true;\n                    } else {\n                        // Otherwise, the receive operation is not ready.\n                        return false;\n                    }\n                }\n\n                backoff.spin();\n                head = self.head.load(Ordering::Relaxed);\n            } else {\n                // Snooze because we need to wait for the stamp to get updated.\n                backoff.snooze();\n                head = self.head.load(Ordering::Relaxed);\n            }\n        }\n    }\n\n    /// Reads a message from the channel.\n    pub unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n        if token.array.slot.is_null() {\n            // The channel is disconnected.\n            return Err(());\n        }\n\n        let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n\n        // Read the message from the slot and update the stamp.\n        let msg = slot.msg.get().read().assume_init();\n        slot.stamp.store(token.array.stamp, Ordering::Release);\n\n        // Wake a sleeping sender.\n        self.senders.notify();\n        Ok(msg)\n    }\n\n    /// Attempts to send a message into the channel.\n    pub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n        let token = &mut Token::default();\n        if self.start_send(token) {\n            unsafe { self.write(token, msg).map_err(TrySendError::Disconnected) }\n        } else {\n            Err(TrySendError::Full(msg))\n        }\n    }\n\n    /// Sends a message into the channel.\n    pub fn send(&self, msg: T, deadline: Option<Instant>) -> Result<(), SendTimeoutError<T>> {\n        let token = &mut Token::default();\n        loop {\n            // Try sending a message several times.\n            let backoff = Backoff::new();\n            loop {\n                if self.start_send(token) {\n                    let res = unsafe { self.write(token, msg) };\n                    return res.map_err(SendTimeoutError::Disconnected);\n                }\n\n                if backoff.is_completed() {\n                    break;\n                } else {\n                    backoff.snooze();\n                }\n            }\n\n            if let Some(d) = deadline {\n                if Instant::now() >= d {\n                    return Err(SendTimeoutError::Timeout(msg));\n                }\n            }\n\n            Context::with(|cx| {\n                // Prepare for blocking until a receiver wakes us up.\n                let oper = Operation::hook(token);\n                self.senders.register(oper, cx);\n\n                // Has the channel become ready just now?\n                if !self.is_full() || self.is_disconnected() {\n                    let _ = cx.try_select(Selected::Aborted);\n                }\n\n                // Block the current thread.\n                let sel = cx.wait_until(deadline);\n\n                match sel {\n                    Selected::Waiting => unreachable!(),\n                    Selected::Aborted | Selected::Disconnected => {\n                        self.senders.unregister(oper).unwrap();\n                    }\n                    Selected::Operation(_) => {}\n                }\n            });\n        }\n    }\n\n    /// Attempts to receive a message without blocking.\n    pub fn try_recv(&self) -> Result<T, TryRecvError> {\n        let token = &mut Token::default();\n\n        if self.start_recv(token) {\n            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n        } else {\n            Err(TryRecvError::Empty)\n        }\n    }\n\n    /// Receives a message from the channel.\n    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n        let token = &mut Token::default();\n        loop {\n            // Try receiving a message several times.\n            let backoff = Backoff::new();\n            loop {\n                if self.start_recv(token) {\n                    let res = unsafe { self.read(token) };\n                    return res.map_err(|_| RecvTimeoutError::Disconnected);\n                }\n\n                if backoff.is_completed() {\n                    break;\n                } else {\n                    backoff.snooze();\n                }\n            }\n\n            if let Some(d) = deadline {\n                if Instant::now() >= d {\n                    return Err(RecvTimeoutError::Timeout);\n                }\n            }\n\n            Context::with(|cx| {\n                // Prepare for blocking until a sender wakes us up.\n                let oper = Operation::hook(token);\n                self.receivers.register(oper, cx);\n\n                // Has the channel become ready just now?\n                if !self.is_empty() || self.is_disconnected() {\n                    let _ = cx.try_select(Selected::Aborted);\n                }\n\n                // Block the current thread.\n                let sel = cx.wait_until(deadline);\n\n                match sel {\n                    Selected::Waiting => unreachable!(),\n                    Selected::Aborted | Selected::Disconnected => {\n                        self.receivers.unregister(oper).unwrap();\n                        // If the channel was disconnected, we still have to check for remaining\n                        // messages.\n                    }\n                    Selected::Operation(_) => {}\n                }\n            });\n        }\n    }\n\n    /// Returns the current number of messages inside the channel.\n    pub fn len(&self) -> usize {\n        loop {\n            // Load the tail, then load the head.\n            let tail = self.tail.load(Ordering::SeqCst);\n            let head = self.head.load(Ordering::SeqCst);\n\n            // If the tail didn't change, we've got consistent values to work with.\n            if self.tail.load(Ordering::SeqCst) == tail {\n                let hix = head & (self.mark_bit - 1);\n                let tix = tail & (self.mark_bit - 1);\n\n                return if hix < tix {\n                    tix - hix\n                } else if hix > tix {\n                    self.cap - hix + tix\n                } else if (tail & !self.mark_bit) == head {\n                    0\n                } else {\n                    self.cap\n                };\n            }\n        }\n    }\n\n    /// Returns the capacity of the channel.\n    pub fn capacity(&self) -> Option<usize> {\n        Some(self.cap)\n    }\n\n    /// Disconnects the channel and wakes up all blocked senders and receivers.\n    ///\n    /// Returns `true` if this call disconnected the channel.\n    pub fn disconnect(&self) -> bool {\n        let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n\n        if tail & self.mark_bit == 0 {\n            self.senders.disconnect();\n            self.receivers.disconnect();\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Returns `true` if the channel is disconnected.\n    pub fn is_disconnected(&self) -> bool {\n        self.tail.load(Ordering::SeqCst) & self.mark_bit != 0\n    }\n\n    /// Returns `true` if the channel is empty.\n    pub fn is_empty(&self) -> bool {\n        let head = self.head.load(Ordering::SeqCst);\n        let tail = self.tail.load(Ordering::SeqCst);\n\n        // Is the tail equal to the head?\n        //\n        // Note: If the head changes just before we load the tail, that means there was a moment\n        // when the channel was not empty, so it is safe to just return `false`.\n        (tail & !self.mark_bit) == head\n    }\n\n    /// Returns `true` if the channel is full.\n    pub fn is_full(&self) -> bool {\n        let tail = self.tail.load(Ordering::SeqCst);\n        let head = self.head.load(Ordering::SeqCst);\n\n        // Is the head lagging one lap behind tail?\n        //\n        // Note: If the tail changes just before we load the head, that means there was a moment\n        // when the channel was not full, so it is safe to just return `false`.\n        head.wrapping_add(self.one_lap) == tail & !self.mark_bit\n    }\n}","impl<T> Drop for Channel<T> {\n    fn drop(&mut self) {\n        // Get the index of the head.\n        let hix = self.head.load(Ordering::Relaxed) & (self.mark_bit - 1);\n\n        // Loop over all slots that hold a message and drop them.\n        for i in 0..self.len() {\n            // Compute the index of the next slot holding a message.\n            let index = if hix + i < self.cap {\n                hix + i\n            } else {\n                hix + i - self.cap\n            };\n\n            unsafe {\n                let p = {\n                    let slot = &mut *self.buffer.add(index);\n                    let msg = &mut *slot.msg.get();\n                    msg.as_mut_ptr()\n                };\n                p.drop_in_place();\n            }\n        }\n\n        // Finally, deallocate the buffer, but don't run any destructors.\n        unsafe {\n            Vec::from_raw_parts(self.buffer, 0, self.cap);\n        }\n    }\n}"],"flavors::array::Receiver":["impl<T> SelectHandle for Receiver<'_, T> {\n    fn try_select(&self, token: &mut Token) -> bool {\n        self.0.start_recv(token)\n    }\n\n    fn deadline(&self) -> Option<Instant> {\n        None\n    }\n\n    fn register(&self, oper: Operation, cx: &Context) -> bool {\n        self.0.receivers.register(oper, cx);\n        self.is_ready()\n    }\n\n    fn unregister(&self, oper: Operation) {\n        self.0.receivers.unregister(oper);\n    }\n\n    fn accept(&self, token: &mut Token, _cx: &Context) -> bool {\n        self.try_select(token)\n    }\n\n    fn is_ready(&self) -> bool {\n        !self.0.is_empty() || self.0.is_disconnected()\n    }\n\n    fn watch(&self, oper: Operation, cx: &Context) -> bool {\n        self.0.receivers.watch(oper, cx);\n        self.is_ready()\n    }\n\n    fn unwatch(&self, oper: Operation) {\n        self.0.receivers.unwatch(oper);\n    }\n}"],"flavors::array::Sender":["impl<T> SelectHandle for Sender<'_, T> {\n    fn try_select(&self, token: &mut Token) -> bool {\n        self.0.start_send(token)\n    }\n\n    fn deadline(&self) -> Option<Instant> {\n        None\n    }\n\n    fn register(&self, oper: Operation, cx: &Context) -> bool {\n        self.0.senders.register(oper, cx);\n        self.is_ready()\n    }\n\n    fn unregister(&self, oper: Operation) {\n        self.0.senders.unregister(oper);\n    }\n\n    fn accept(&self, token: &mut Token, _cx: &Context) -> bool {\n        self.try_select(token)\n    }\n\n    fn is_ready(&self) -> bool {\n        !self.0.is_full() || self.0.is_disconnected()\n    }\n\n    fn watch(&self, oper: Operation, cx: &Context) -> bool {\n        self.0.senders.watch(oper, cx);\n        self.is_ready()\n    }\n\n    fn unwatch(&self, oper: Operation) {\n        self.0.senders.unwatch(oper);\n    }\n}"],"flavors::list::Block":["impl<T> Block<T> {\n    /// Creates an empty block.\n    fn new() -> Block<T> {\n        // SAFETY: This is safe because:\n        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n        //  [3] `Slot::msg` (UnsafeCell) may be safely zero initialized because it\n        //       holds a MaybeUninit.\n        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n        unsafe { MaybeUninit::zeroed().assume_init() }\n    }\n\n    /// Waits until the next pointer is set.\n    fn wait_next(&self) -> *mut Block<T> {\n        let backoff = Backoff::new();\n        loop {\n            let next = self.next.load(Ordering::Acquire);\n            if !next.is_null() {\n                return next;\n            }\n            backoff.snooze();\n        }\n    }\n\n    /// Sets the `DESTROY` bit in slots starting from `start` and destroys the block.\n    unsafe fn destroy(this: *mut Block<T>, start: usize) {\n        // It is not necessary to set the `DESTROY` bit in the last slot because that slot has\n        // begun destruction of the block.\n        for i in start..BLOCK_CAP - 1 {\n            let slot = (*this).slots.get_unchecked(i);\n\n            // Mark the `DESTROY` bit if a thread is still using the slot.\n            if slot.state.load(Ordering::Acquire) & READ == 0\n                && slot.state.fetch_or(DESTROY, Ordering::AcqRel) & READ == 0\n            {\n                // If a thread is still using the slot, it will continue destruction of the block.\n                return;\n            }\n        }\n\n        // No thread is using the block, now it is safe to destroy it.\n        drop(Box::from_raw(this));\n    }\n}"],"flavors::list::Channel":["impl<T> Channel<T> {\n    /// Creates a new unbounded channel.\n    pub fn new() -> Self {\n        Channel {\n            head: CachePadded::new(Position {\n                block: AtomicPtr::new(ptr::null_mut()),\n                index: AtomicUsize::new(0),\n            }),\n            tail: CachePadded::new(Position {\n                block: AtomicPtr::new(ptr::null_mut()),\n                index: AtomicUsize::new(0),\n            }),\n            receivers: SyncWaker::new(),\n            _marker: PhantomData,\n        }\n    }\n\n    /// Returns a receiver handle to the channel.\n    pub fn receiver(&self) -> Receiver<'_, T> {\n        Receiver(self)\n    }\n\n    /// Returns a sender handle to the channel.\n    pub fn sender(&self) -> Sender<'_, T> {\n        Sender(self)\n    }\n\n    /// Attempts to reserve a slot for sending a message.\n    fn start_send(&self, token: &mut Token) -> bool {\n        let backoff = Backoff::new();\n        let mut tail = self.tail.index.load(Ordering::Acquire);\n        let mut block = self.tail.block.load(Ordering::Acquire);\n        let mut next_block = None;\n\n        loop {\n            // Check if the channel is disconnected.\n            if tail & MARK_BIT != 0 {\n                token.list.block = ptr::null();\n                return true;\n            }\n\n            // Calculate the offset of the index into the block.\n            let offset = (tail >> SHIFT) % LAP;\n\n            // If we reached the end of the block, wait until the next one is installed.\n            if offset == BLOCK_CAP {\n                backoff.snooze();\n                tail = self.tail.index.load(Ordering::Acquire);\n                block = self.tail.block.load(Ordering::Acquire);\n                continue;\n            }\n\n            // If we're going to have to install the next block, allocate it in advance in order to\n            // make the wait for other threads as short as possible.\n            if offset + 1 == BLOCK_CAP && next_block.is_none() {\n                next_block = Some(Box::new(Block::<T>::new()));\n            }\n\n            // If this is the first message to be sent into the channel, we need to allocate the\n            // first block and install it.\n            if block.is_null() {\n                let new = Box::into_raw(Box::new(Block::<T>::new()));\n\n                if self\n                    .tail\n                    .block\n                    .compare_and_swap(block, new, Ordering::Release)\n                    == block\n                {\n                    self.head.block.store(new, Ordering::Release);\n                    block = new;\n                } else {\n                    next_block = unsafe { Some(Box::from_raw(new)) };\n                    tail = self.tail.index.load(Ordering::Acquire);\n                    block = self.tail.block.load(Ordering::Acquire);\n                    continue;\n                }\n            }\n\n            let new_tail = tail + (1 << SHIFT);\n\n            // Try advancing the tail forward.\n            match self.tail.index.compare_exchange_weak(\n                tail,\n                new_tail,\n                Ordering::SeqCst,\n                Ordering::Acquire,\n            ) {\n                Ok(_) => unsafe {\n                    // If we've reached the end of the block, install the next one.\n                    if offset + 1 == BLOCK_CAP {\n                        let next_block = Box::into_raw(next_block.unwrap());\n                        self.tail.block.store(next_block, Ordering::Release);\n                        self.tail.index.fetch_add(1 << SHIFT, Ordering::Release);\n                        (*block).next.store(next_block, Ordering::Release);\n                    }\n\n                    token.list.block = block as *const u8;\n                    token.list.offset = offset;\n                    return true;\n                },\n                Err(t) => {\n                    tail = t;\n                    block = self.tail.block.load(Ordering::Acquire);\n                    backoff.spin();\n                }\n            }\n        }\n    }\n\n    /// Writes a message into the channel.\n    pub unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n        // If there is no slot, the channel is disconnected.\n        if token.list.block.is_null() {\n            return Err(msg);\n        }\n\n        // Write the message into the slot.\n        let block = token.list.block as *mut Block<T>;\n        let offset = token.list.offset;\n        let slot = (*block).slots.get_unchecked(offset);\n        slot.msg.get().write(MaybeUninit::new(msg));\n        slot.state.fetch_or(WRITE, Ordering::Release);\n\n        // Wake a sleeping receiver.\n        self.receivers.notify();\n        Ok(())\n    }\n\n    /// Attempts to reserve a slot for receiving a message.\n    fn start_recv(&self, token: &mut Token) -> bool {\n        let backoff = Backoff::new();\n        let mut head = self.head.index.load(Ordering::Acquire);\n        let mut block = self.head.block.load(Ordering::Acquire);\n\n        loop {\n            // Calculate the offset of the index into the block.\n            let offset = (head >> SHIFT) % LAP;\n\n            // If we reached the end of the block, wait until the next one is installed.\n            if offset == BLOCK_CAP {\n                backoff.snooze();\n                head = self.head.index.load(Ordering::Acquire);\n                block = self.head.block.load(Ordering::Acquire);\n                continue;\n            }\n\n            let mut new_head = head + (1 << SHIFT);\n\n            if new_head & MARK_BIT == 0 {\n                atomic::fence(Ordering::SeqCst);\n                let tail = self.tail.index.load(Ordering::Relaxed);\n\n                // If the tail equals the head, that means the channel is empty.\n                if head >> SHIFT == tail >> SHIFT {\n                    // If the channel is disconnected...\n                    if tail & MARK_BIT != 0 {\n                        // ...then receive an error.\n                        token.list.block = ptr::null();\n                        return true;\n                    } else {\n                        // Otherwise, the receive operation is not ready.\n                        return false;\n                    }\n                }\n\n                // If head and tail are not in the same block, set `MARK_BIT` in head.\n                if (head >> SHIFT) / LAP != (tail >> SHIFT) / LAP {\n                    new_head |= MARK_BIT;\n                }\n            }\n\n            // The block can be null here only if the first message is being sent into the channel.\n            // In that case, just wait until it gets initialized.\n            if block.is_null() {\n                backoff.snooze();\n                head = self.head.index.load(Ordering::Acquire);\n                block = self.head.block.load(Ordering::Acquire);\n                continue;\n            }\n\n            // Try moving the head index forward.\n            match self.head.index.compare_exchange_weak(\n                head,\n                new_head,\n                Ordering::SeqCst,\n                Ordering::Acquire,\n            ) {\n                Ok(_) => unsafe {\n                    // If we've reached the end of the block, move to the next one.\n                    if offset + 1 == BLOCK_CAP {\n                        let next = (*block).wait_next();\n                        let mut next_index = (new_head & !MARK_BIT).wrapping_add(1 << SHIFT);\n                        if !(*next).next.load(Ordering::Relaxed).is_null() {\n                            next_index |= MARK_BIT;\n                        }\n\n                        self.head.block.store(next, Ordering::Release);\n                        self.head.index.store(next_index, Ordering::Release);\n                    }\n\n                    token.list.block = block as *const u8;\n                    token.list.offset = offset;\n                    return true;\n                },\n                Err(h) => {\n                    head = h;\n                    block = self.head.block.load(Ordering::Acquire);\n                    backoff.spin();\n                }\n            }\n        }\n    }\n\n    /// Reads a message from the channel.\n    pub unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n        if token.list.block.is_null() {\n            // The channel is disconnected.\n            return Err(());\n        }\n\n        // Read the message.\n        let block = token.list.block as *mut Block<T>;\n        let offset = token.list.offset;\n        let slot = (*block).slots.get_unchecked(offset);\n        slot.wait_write();\n        let msg = slot.msg.get().read().assume_init();\n\n        // Destroy the block if we've reached the end, or if another thread wanted to destroy but\n        // couldn't because we were busy reading from the slot.\n        if offset + 1 == BLOCK_CAP {\n            Block::destroy(block, 0);\n        } else if slot.state.fetch_or(READ, Ordering::AcqRel) & DESTROY != 0 {\n            Block::destroy(block, offset + 1);\n        }\n\n        Ok(msg)\n    }\n\n    /// Attempts to send a message into the channel.\n    pub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n        self.send(msg, None).map_err(|err| match err {\n            SendTimeoutError::Disconnected(msg) => TrySendError::Disconnected(msg),\n            SendTimeoutError::Timeout(_) => unreachable!(),\n        })\n    }\n\n    /// Sends a message into the channel.\n    pub fn send(&self, msg: T, _deadline: Option<Instant>) -> Result<(), SendTimeoutError<T>> {\n        let token = &mut Token::default();\n        assert!(self.start_send(token));\n        unsafe {\n            self.write(token, msg)\n                .map_err(SendTimeoutError::Disconnected)\n        }\n    }\n\n    /// Attempts to receive a message without blocking.\n    pub fn try_recv(&self) -> Result<T, TryRecvError> {\n        let token = &mut Token::default();\n\n        if self.start_recv(token) {\n            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n        } else {\n            Err(TryRecvError::Empty)\n        }\n    }\n\n    /// Receives a message from the channel.\n    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n        let token = &mut Token::default();\n        loop {\n            // Try receiving a message several times.\n            let backoff = Backoff::new();\n            loop {\n                if self.start_recv(token) {\n                    unsafe {\n                        return self.read(token).map_err(|_| RecvTimeoutError::Disconnected);\n                    }\n                }\n\n                if backoff.is_completed() {\n                    break;\n                } else {\n                    backoff.snooze();\n                }\n            }\n\n            if let Some(d) = deadline {\n                if Instant::now() >= d {\n                    return Err(RecvTimeoutError::Timeout);\n                }\n            }\n\n            // Prepare for blocking until a sender wakes us up.\n            Context::with(|cx| {\n                let oper = Operation::hook(token);\n                self.receivers.register(oper, cx);\n\n                // Has the channel become ready just now?\n                if !self.is_empty() || self.is_disconnected() {\n                    let _ = cx.try_select(Selected::Aborted);\n                }\n\n                // Block the current thread.\n                let sel = cx.wait_until(deadline);\n\n                match sel {\n                    Selected::Waiting => unreachable!(),\n                    Selected::Aborted | Selected::Disconnected => {\n                        self.receivers.unregister(oper).unwrap();\n                        // If the channel was disconnected, we still have to check for remaining\n                        // messages.\n                    }\n                    Selected::Operation(_) => {}\n                }\n            });\n        }\n    }\n\n    /// Returns the current number of messages inside the channel.\n    pub fn len(&self) -> usize {\n        loop {\n            // Load the tail index, then load the head index.\n            let mut tail = self.tail.index.load(Ordering::SeqCst);\n            let mut head = self.head.index.load(Ordering::SeqCst);\n\n            // If the tail index didn't change, we've got consistent indices to work with.\n            if self.tail.index.load(Ordering::SeqCst) == tail {\n                // Erase the lower bits.\n                tail &= !((1 << SHIFT) - 1);\n                head &= !((1 << SHIFT) - 1);\n\n                // Fix up indices if they fall onto block ends.\n                if (tail >> SHIFT) & (LAP - 1) == LAP - 1 {\n                    tail = tail.wrapping_add(1 << SHIFT);\n                }\n                if (head >> SHIFT) & (LAP - 1) == LAP - 1 {\n                    head = head.wrapping_add(1 << SHIFT);\n                }\n\n                // Rotate indices so that head falls into the first block.\n                let lap = (head >> SHIFT) / LAP;\n                tail = tail.wrapping_sub((lap * LAP) << SHIFT);\n                head = head.wrapping_sub((lap * LAP) << SHIFT);\n\n                // Remove the lower bits.\n                tail >>= SHIFT;\n                head >>= SHIFT;\n\n                // Return the difference minus the number of blocks between tail and head.\n                return tail - head - tail / LAP;\n            }\n        }\n    }\n\n    /// Returns the capacity of the channel.\n    pub fn capacity(&self) -> Option<usize> {\n        None\n    }\n\n    /// Disconnects the channel and wakes up all blocked receivers.\n    ///\n    /// Returns `true` if this call disconnected the channel.\n    pub fn disconnect(&self) -> bool {\n        let tail = self.tail.index.fetch_or(MARK_BIT, Ordering::SeqCst);\n\n        if tail & MARK_BIT == 0 {\n            self.receivers.disconnect();\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Returns `true` if the channel is disconnected.\n    pub fn is_disconnected(&self) -> bool {\n        self.tail.index.load(Ordering::SeqCst) & MARK_BIT != 0\n    }\n\n    /// Returns `true` if the channel is empty.\n    pub fn is_empty(&self) -> bool {\n        let head = self.head.index.load(Ordering::SeqCst);\n        let tail = self.tail.index.load(Ordering::SeqCst);\n        head >> SHIFT == tail >> SHIFT\n    }\n\n    /// Returns `true` if the channel is full.\n    pub fn is_full(&self) -> bool {\n        false\n    }\n}","impl<T> Drop for Channel<T> {\n    fn drop(&mut self) {\n        let mut head = self.head.index.load(Ordering::Relaxed);\n        let mut tail = self.tail.index.load(Ordering::Relaxed);\n        let mut block = self.head.block.load(Ordering::Relaxed);\n\n        // Erase the lower bits.\n        head &= !((1 << SHIFT) - 1);\n        tail &= !((1 << SHIFT) - 1);\n\n        unsafe {\n            // Drop all messages between head and tail and deallocate the heap-allocated blocks.\n            while head != tail {\n                let offset = (head >> SHIFT) % LAP;\n\n                if offset < BLOCK_CAP {\n                    // Drop the message in the slot.\n                    let slot = (*block).slots.get_unchecked(offset);\n                    let p = &mut *slot.msg.get();\n                    p.as_mut_ptr().drop_in_place();\n                } else {\n                    // Deallocate the block and move to the next one.\n                    let next = (*block).next.load(Ordering::Relaxed);\n                    drop(Box::from_raw(block));\n                    block = next;\n                }\n\n                head = head.wrapping_add(1 << SHIFT);\n            }\n\n            // Deallocate the last remaining block.\n            if !block.is_null() {\n                drop(Box::from_raw(block));\n            }\n        }\n    }\n}"],"flavors::list::ListToken":["Debug","impl Default for ListToken {\n    #[inline]\n    fn default() -> Self {\n        ListToken {\n            block: ptr::null(),\n            offset: 0,\n        }\n    }\n}"],"flavors::list::Position":["Debug"],"flavors::list::Receiver":["impl<T> SelectHandle for Receiver<'_, T> {\n    fn try_select(&self, token: &mut Token) -> bool {\n        self.0.start_recv(token)\n    }\n\n    fn deadline(&self) -> Option<Instant> {\n        None\n    }\n\n    fn register(&self, oper: Operation, cx: &Context) -> bool {\n        self.0.receivers.register(oper, cx);\n        self.is_ready()\n    }\n\n    fn unregister(&self, oper: Operation) {\n        self.0.receivers.unregister(oper);\n    }\n\n    fn accept(&self, token: &mut Token, _cx: &Context) -> bool {\n        self.try_select(token)\n    }\n\n    fn is_ready(&self) -> bool {\n        !self.0.is_empty() || self.0.is_disconnected()\n    }\n\n    fn watch(&self, oper: Operation, cx: &Context) -> bool {\n        self.0.receivers.watch(oper, cx);\n        self.is_ready()\n    }\n\n    fn unwatch(&self, oper: Operation) {\n        self.0.receivers.unwatch(oper);\n    }\n}"],"flavors::list::Sender":["impl<T> SelectHandle for Sender<'_, T> {\n    fn try_select(&self, token: &mut Token) -> bool {\n        self.0.start_send(token)\n    }\n\n    fn deadline(&self) -> Option<Instant> {\n        None\n    }\n\n    fn register(&self, _oper: Operation, _cx: &Context) -> bool {\n        self.is_ready()\n    }\n\n    fn unregister(&self, _oper: Operation) {}\n\n    fn accept(&self, token: &mut Token, _cx: &Context) -> bool {\n        self.try_select(token)\n    }\n\n    fn is_ready(&self) -> bool {\n        true\n    }\n\n    fn watch(&self, _oper: Operation, _cx: &Context) -> bool {\n        self.is_ready()\n    }\n\n    fn unwatch(&self, _oper: Operation) {}\n}"],"flavors::list::Slot":["impl<T> Slot<T> {\n    /// Waits until a message is written into the slot.\n    fn wait_write(&self) {\n        let backoff = Backoff::new();\n        while self.state.load(Ordering::Acquire) & WRITE == 0 {\n            backoff.snooze();\n        }\n    }\n}"],"flavors::never::Channel":["impl<T> Channel<T> {\n    /// Creates a channel that never delivers messages.\n    #[inline]\n    pub fn new() -> Self {\n        Channel {\n            _marker: PhantomData,\n        }\n    }\n\n    /// Attempts to receive a message without blocking.\n    #[inline]\n    pub fn try_recv(&self) -> Result<T, TryRecvError> {\n        Err(TryRecvError::Empty)\n    }\n\n    /// Receives a message from the channel.\n    #[inline]\n    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n        utils::sleep_until(deadline);\n        Err(RecvTimeoutError::Timeout)\n    }\n\n    /// Reads a message from the channel.\n    #[inline]\n    pub unsafe fn read(&self, _token: &mut Token) -> Result<T, ()> {\n        Err(())\n    }\n\n    /// Returns `true` if the channel is empty.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        true\n    }\n\n    /// Returns `true` if the channel is full.\n    #[inline]\n    pub fn is_full(&self) -> bool {\n        true\n    }\n\n    /// Returns the number of messages in the channel.\n    #[inline]\n    pub fn len(&self) -> usize {\n        0\n    }\n\n    /// Returns the capacity of the channel.\n    #[inline]\n    pub fn capacity(&self) -> Option<usize> {\n        Some(0)\n    }\n}","impl<T> SelectHandle for Channel<T> {\n    #[inline]\n    fn try_select(&self, _token: &mut Token) -> bool {\n        false\n    }\n\n    #[inline]\n    fn deadline(&self) -> Option<Instant> {\n        None\n    }\n\n    #[inline]\n    fn register(&self, _oper: Operation, _cx: &Context) -> bool {\n        self.is_ready()\n    }\n\n    #[inline]\n    fn unregister(&self, _oper: Operation) {}\n\n    #[inline]\n    fn accept(&self, token: &mut Token, _cx: &Context) -> bool {\n        self.try_select(token)\n    }\n\n    #[inline]\n    fn is_ready(&self) -> bool {\n        false\n    }\n\n    #[inline]\n    fn watch(&self, _oper: Operation, _cx: &Context) -> bool {\n        self.is_ready()\n    }\n\n    #[inline]\n    fn unwatch(&self, _oper: Operation) {}\n}"],"flavors::tick::Channel":["impl Channel {\n    /// Creates a channel that delivers messages periodically.\n    #[inline]\n    pub fn new(dur: Duration) -> Self {\n        Channel {\n            delivery_time: AtomicCell::new(Instant::now() + dur),\n            duration: dur,\n        }\n    }\n\n    /// Attempts to receive a message without blocking.\n    #[inline]\n    pub fn try_recv(&self) -> Result<Instant, TryRecvError> {\n        loop {\n            let now = Instant::now();\n            let delivery_time = self.delivery_time.load();\n\n            if now < delivery_time {\n                return Err(TryRecvError::Empty);\n            }\n\n            if self\n                .delivery_time\n                .compare_exchange(delivery_time, now + self.duration)\n                .is_ok()\n            {\n                return Ok(delivery_time);\n            }\n        }\n    }\n\n    /// Receives a message from the channel.\n    #[inline]\n    pub fn recv(&self, deadline: Option<Instant>) -> Result<Instant, RecvTimeoutError> {\n        loop {\n            let delivery_time = self.delivery_time.load();\n            let now = Instant::now();\n\n            if let Some(d) = deadline {\n                if d < delivery_time {\n                    if now < d {\n                        thread::sleep(d - now);\n                    }\n                    return Err(RecvTimeoutError::Timeout);\n                }\n            }\n\n            if self\n                .delivery_time\n                .compare_exchange(delivery_time, delivery_time.max(now) + self.duration)\n                .is_ok()\n            {\n                if now < delivery_time {\n                    thread::sleep(delivery_time - now);\n                }\n                return Ok(delivery_time);\n            }\n        }\n    }\n\n    /// Reads a message from the channel.\n    #[inline]\n    pub unsafe fn read(&self, token: &mut Token) -> Result<Instant, ()> {\n        token.tick.ok_or(())\n    }\n\n    /// Returns `true` if the channel is empty.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        Instant::now() < self.delivery_time.load()\n    }\n\n    /// Returns `true` if the channel is full.\n    #[inline]\n    pub fn is_full(&self) -> bool {\n        !self.is_empty()\n    }\n\n    /// Returns the number of messages in the channel.\n    #[inline]\n    pub fn len(&self) -> usize {\n        if self.is_empty() {\n            0\n        } else {\n            1\n        }\n    }\n\n    /// Returns the capacity of the channel.\n    #[inline]\n    pub fn capacity(&self) -> Option<usize> {\n        Some(1)\n    }\n}","impl SelectHandle for Channel {\n    #[inline]\n    fn try_select(&self, token: &mut Token) -> bool {\n        match self.try_recv() {\n            Ok(msg) => {\n                token.tick = Some(msg);\n                true\n            }\n            Err(TryRecvError::Disconnected) => {\n                token.tick = None;\n                true\n            }\n            Err(TryRecvError::Empty) => false,\n        }\n    }\n\n    #[inline]\n    fn deadline(&self) -> Option<Instant> {\n        Some(self.delivery_time.load())\n    }\n\n    #[inline]\n    fn register(&self, _oper: Operation, _cx: &Context) -> bool {\n        self.is_ready()\n    }\n\n    #[inline]\n    fn unregister(&self, _oper: Operation) {}\n\n    #[inline]\n    fn accept(&self, token: &mut Token, _cx: &Context) -> bool {\n        self.try_select(token)\n    }\n\n    #[inline]\n    fn is_ready(&self) -> bool {\n        !self.is_empty()\n    }\n\n    #[inline]\n    fn watch(&self, _oper: Operation, _cx: &Context) -> bool {\n        self.is_ready()\n    }\n\n    #[inline]\n    fn unwatch(&self, _oper: Operation) {}\n}"],"flavors::zero::Channel":["impl<T> Channel<T> {\n    /// Constructs a new zero-capacity channel.\n    pub fn new() -> Self {\n        Channel {\n            inner: Spinlock::new(Inner {\n                senders: Waker::new(),\n                receivers: Waker::new(),\n                is_disconnected: false,\n            }),\n            _marker: PhantomData,\n        }\n    }\n\n    /// Returns a receiver handle to the channel.\n    pub fn receiver(&self) -> Receiver<'_, T> {\n        Receiver(self)\n    }\n\n    /// Returns a sender handle to the channel.\n    pub fn sender(&self) -> Sender<'_, T> {\n        Sender(self)\n    }\n\n    /// Attempts to reserve a slot for sending a message.\n    fn start_send(&self, token: &mut Token) -> bool {\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting receiver, pair up with it.\n        if let Some(operation) = inner.receivers.try_select() {\n            token.zero = operation.packet;\n            true\n        } else if inner.is_disconnected {\n            token.zero = 0;\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Writes a message into the packet.\n    pub unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n        // If there is no packet, the channel is disconnected.\n        if token.zero == 0 {\n            return Err(msg);\n        }\n\n        let packet = &*(token.zero as *const Packet<T>);\n        packet.msg.get().write(Some(msg));\n        packet.ready.store(true, Ordering::Release);\n        Ok(())\n    }\n\n    /// Attempts to pair up with a sender.\n    fn start_recv(&self, token: &mut Token) -> bool {\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting sender, pair up with it.\n        if let Some(operation) = inner.senders.try_select() {\n            token.zero = operation.packet;\n            true\n        } else if inner.is_disconnected {\n            token.zero = 0;\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Reads a message from the packet.\n    pub unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n        // If there is no packet, the channel is disconnected.\n        if token.zero == 0 {\n            return Err(());\n        }\n\n        let packet = &*(token.zero as *const Packet<T>);\n\n        if packet.on_stack {\n            // The message has been in the packet from the beginning, so there is no need to wait\n            // for it. However, after reading the message, we need to set `ready` to `true` in\n            // order to signal that the packet can be destroyed.\n            let msg = packet.msg.get().replace(None).unwrap();\n            packet.ready.store(true, Ordering::Release);\n            Ok(msg)\n        } else {\n            // Wait until the message becomes available, then read it and destroy the\n            // heap-allocated packet.\n            packet.wait_ready();\n            let msg = packet.msg.get().replace(None).unwrap();\n            drop(Box::from_raw(packet as *const Packet<T> as *mut Packet<T>));\n            Ok(msg)\n        }\n    }\n\n    /// Attempts to send a message into the channel.\n    pub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n        let token = &mut Token::default();\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting receiver, pair up with it.\n        if let Some(operation) = inner.receivers.try_select() {\n            token.zero = operation.packet;\n            drop(inner);\n            unsafe {\n                self.write(token, msg).ok().unwrap();\n            }\n            Ok(())\n        } else if inner.is_disconnected {\n            Err(TrySendError::Disconnected(msg))\n        } else {\n            Err(TrySendError::Full(msg))\n        }\n    }\n\n    /// Sends a message into the channel.\n    pub fn send(&self, msg: T, deadline: Option<Instant>) -> Result<(), SendTimeoutError<T>> {\n        let token = &mut Token::default();\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting receiver, pair up with it.\n        if let Some(operation) = inner.receivers.try_select() {\n            token.zero = operation.packet;\n            drop(inner);\n            unsafe {\n                self.write(token, msg).ok().unwrap();\n            }\n            return Ok(());\n        }\n\n        if inner.is_disconnected {\n            return Err(SendTimeoutError::Disconnected(msg));\n        }\n\n        Context::with(|cx| {\n            // Prepare for blocking until a receiver wakes us up.\n            let oper = Operation::hook(token);\n            let packet = Packet::<T>::message_on_stack(msg);\n            inner\n                .senders\n                .register_with_packet(oper, &packet as *const Packet<T> as usize, cx);\n            inner.receivers.notify();\n            drop(inner);\n\n            // Block the current thread.\n            let sel = cx.wait_until(deadline);\n\n            match sel {\n                Selected::Waiting => unreachable!(),\n                Selected::Aborted => {\n                    self.inner.lock().senders.unregister(oper).unwrap();\n                    let msg = unsafe { packet.msg.get().replace(None).unwrap() };\n                    Err(SendTimeoutError::Timeout(msg))\n                }\n                Selected::Disconnected => {\n                    self.inner.lock().senders.unregister(oper).unwrap();\n                    let msg = unsafe { packet.msg.get().replace(None).unwrap() };\n                    Err(SendTimeoutError::Disconnected(msg))\n                }\n                Selected::Operation(_) => {\n                    // Wait until the message is read, then drop the packet.\n                    packet.wait_ready();\n                    Ok(())\n                }\n            }\n        })\n    }\n\n    /// Attempts to receive a message without blocking.\n    pub fn try_recv(&self) -> Result<T, TryRecvError> {\n        let token = &mut Token::default();\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting sender, pair up with it.\n        if let Some(operation) = inner.senders.try_select() {\n            token.zero = operation.packet;\n            drop(inner);\n            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n        } else if inner.is_disconnected {\n            Err(TryRecvError::Disconnected)\n        } else {\n            Err(TryRecvError::Empty)\n        }\n    }\n\n    /// Receives a message from the channel.\n    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n        let token = &mut Token::default();\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting sender, pair up with it.\n        if let Some(operation) = inner.senders.try_select() {\n            token.zero = operation.packet;\n            drop(inner);\n            unsafe {\n                return self.read(token).map_err(|_| RecvTimeoutError::Disconnected);\n            }\n        }\n\n        if inner.is_disconnected {\n            return Err(RecvTimeoutError::Disconnected);\n        }\n\n        Context::with(|cx| {\n            // Prepare for blocking until a sender wakes us up.\n            let oper = Operation::hook(token);\n            let packet = Packet::<T>::empty_on_stack();\n            inner\n                .receivers\n                .register_with_packet(oper, &packet as *const Packet<T> as usize, cx);\n            inner.senders.notify();\n            drop(inner);\n\n            // Block the current thread.\n            let sel = cx.wait_until(deadline);\n\n            match sel {\n                Selected::Waiting => unreachable!(),\n                Selected::Aborted => {\n                    self.inner.lock().receivers.unregister(oper).unwrap();\n                    Err(RecvTimeoutError::Timeout)\n                }\n                Selected::Disconnected => {\n                    self.inner.lock().receivers.unregister(oper).unwrap();\n                    Err(RecvTimeoutError::Disconnected)\n                }\n                Selected::Operation(_) => {\n                    // Wait until the message is provided, then read it.\n                    packet.wait_ready();\n                    unsafe { Ok(packet.msg.get().replace(None).unwrap()) }\n                }\n            }\n        })\n    }\n\n    /// Disconnects the channel and wakes up all blocked senders and receivers.\n    ///\n    /// Returns `true` if this call disconnected the channel.\n    pub fn disconnect(&self) -> bool {\n        let mut inner = self.inner.lock();\n\n        if !inner.is_disconnected {\n            inner.is_disconnected = true;\n            inner.senders.disconnect();\n            inner.receivers.disconnect();\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Returns the current number of messages inside the channel.\n    pub fn len(&self) -> usize {\n        0\n    }\n\n    /// Returns the capacity of the channel.\n    pub fn capacity(&self) -> Option<usize> {\n        Some(0)\n    }\n\n    /// Returns `true` if the channel is empty.\n    pub fn is_empty(&self) -> bool {\n        true\n    }\n\n    /// Returns `true` if the channel is full.\n    pub fn is_full(&self) -> bool {\n        true\n    }\n}"],"flavors::zero::Packet":["impl<T> Packet<T> {\n    /// Creates an empty packet on the stack.\n    fn empty_on_stack() -> Packet<T> {\n        Packet {\n            on_stack: true,\n            ready: AtomicBool::new(false),\n            msg: UnsafeCell::new(None),\n        }\n    }\n\n    /// Creates an empty packet on the heap.\n    fn empty_on_heap() -> Box<Packet<T>> {\n        Box::new(Packet {\n            on_stack: false,\n            ready: AtomicBool::new(false),\n            msg: UnsafeCell::new(None),\n        })\n    }\n\n    /// Creates a packet on the stack, containing a message.\n    fn message_on_stack(msg: T) -> Packet<T> {\n        Packet {\n            on_stack: true,\n            ready: AtomicBool::new(false),\n            msg: UnsafeCell::new(Some(msg)),\n        }\n    }\n\n    /// Waits until the packet becomes ready for reading or writing.\n    fn wait_ready(&self) {\n        let backoff = Backoff::new();\n        while !self.ready.load(Ordering::Acquire) {\n            backoff.snooze();\n        }\n    }\n}"],"flavors::zero::Receiver":["impl<T> SelectHandle for Receiver<'_, T> {\n    fn try_select(&self, token: &mut Token) -> bool {\n        self.0.start_recv(token)\n    }\n\n    fn deadline(&self) -> Option<Instant> {\n        None\n    }\n\n    fn register(&self, oper: Operation, cx: &Context) -> bool {\n        let packet = Box::into_raw(Packet::<T>::empty_on_heap());\n\n        let mut inner = self.0.inner.lock();\n        inner\n            .receivers\n            .register_with_packet(oper, packet as usize, cx);\n        inner.senders.notify();\n        inner.senders.can_select() || inner.is_disconnected\n    }\n\n    fn unregister(&self, oper: Operation) {\n        if let Some(operation) = self.0.inner.lock().receivers.unregister(oper) {\n            unsafe {\n                drop(Box::from_raw(operation.packet as *mut Packet<T>));\n            }\n        }\n    }\n\n    fn accept(&self, token: &mut Token, cx: &Context) -> bool {\n        token.zero = cx.wait_packet();\n        true\n    }\n\n    fn is_ready(&self) -> bool {\n        let inner = self.0.inner.lock();\n        inner.senders.can_select() || inner.is_disconnected\n    }\n\n    fn watch(&self, oper: Operation, cx: &Context) -> bool {\n        let mut inner = self.0.inner.lock();\n        inner.receivers.watch(oper, cx);\n        inner.senders.can_select() || inner.is_disconnected\n    }\n\n    fn unwatch(&self, oper: Operation) {\n        let mut inner = self.0.inner.lock();\n        inner.receivers.unwatch(oper);\n    }\n}"],"flavors::zero::Sender":["impl<T> SelectHandle for Sender<'_, T> {\n    fn try_select(&self, token: &mut Token) -> bool {\n        self.0.start_send(token)\n    }\n\n    fn deadline(&self) -> Option<Instant> {\n        None\n    }\n\n    fn register(&self, oper: Operation, cx: &Context) -> bool {\n        let packet = Box::into_raw(Packet::<T>::empty_on_heap());\n\n        let mut inner = self.0.inner.lock();\n        inner\n            .senders\n            .register_with_packet(oper, packet as usize, cx);\n        inner.receivers.notify();\n        inner.receivers.can_select() || inner.is_disconnected\n    }\n\n    fn unregister(&self, oper: Operation) {\n        if let Some(operation) = self.0.inner.lock().senders.unregister(oper) {\n            unsafe {\n                drop(Box::from_raw(operation.packet as *mut Packet<T>));\n            }\n        }\n    }\n\n    fn accept(&self, token: &mut Token, cx: &Context) -> bool {\n        token.zero = cx.wait_packet();\n        true\n    }\n\n    fn is_ready(&self) -> bool {\n        let inner = self.0.inner.lock();\n        inner.receivers.can_select() || inner.is_disconnected\n    }\n\n    fn watch(&self, oper: Operation, cx: &Context) -> bool {\n        let mut inner = self.0.inner.lock();\n        inner.senders.watch(oper, cx);\n        inner.receivers.can_select() || inner.is_disconnected\n    }\n\n    fn unwatch(&self, oper: Operation) {\n        let mut inner = self.0.inner.lock();\n        inner.senders.unwatch(oper);\n    }\n}"],"select::Operation":["Clone","Copy","Debug","Eq","PartialEq","impl Operation {\n    /// Creates an operation identifier from a mutable reference.\n    ///\n    /// This function essentially just turns the address of the reference into a number. The\n    /// reference should point to a variable that is specific to the thread and the operation,\n    /// and is alive for the entire duration of select or blocking operation.\n    #[inline]\n    pub fn hook<T>(r: &mut T) -> Operation {\n        let val = r as *mut T as usize;\n        // Make sure that the pointer address doesn't equal the numerical representation of\n        // `Selected::{Waiting, Aborted, Disconnected}`.\n        assert!(val > 2);\n        Operation(val)\n    }\n}"],"select::Select":["impl fmt::Debug for Select<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"Select { .. }\")\n    }\n}","impl<'a> Clone for Select<'a> {\n    fn clone(&self) -> Select<'a> {\n        Select {\n            handles: self.handles.clone(),\n            next_index: self.next_index,\n        }\n    }\n}","impl<'a> Default for Select<'a> {\n    fn default() -> Select<'a> {\n        Select::new()\n    }\n}","impl<'a> Select<'a> {\n    /// Creates an empty list of channel operations for selection.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::Select;\n    ///\n    /// let mut sel = Select::new();\n    ///\n    /// // The list of operations is empty, which means no operation can be selected.\n    /// assert!(sel.try_select().is_err());\n    /// ```\n    pub fn new() -> Select<'a> {\n        Select {\n            handles: Vec::with_capacity(4),\n            next_index: 0,\n        }\n    }\n\n    /// Adds a send operation.\n    ///\n    /// Returns the index of the added operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{unbounded, Select};\n    ///\n    /// let (s, r) = unbounded::<i32>();\n    ///\n    /// let mut sel = Select::new();\n    /// let index = sel.send(&s);\n    /// ```\n    pub fn send<T>(&mut self, s: &'a Sender<T>) -> usize {\n        let i = self.next_index;\n        let ptr = s as *const Sender<_> as *const u8;\n        self.handles.push((s, i, ptr));\n        self.next_index += 1;\n        i\n    }\n\n    /// Adds a receive operation.\n    ///\n    /// Returns the index of the added operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{unbounded, Select};\n    ///\n    /// let (s, r) = unbounded::<i32>();\n    ///\n    /// let mut sel = Select::new();\n    /// let index = sel.recv(&r);\n    /// ```\n    pub fn recv<T>(&mut self, r: &'a Receiver<T>) -> usize {\n        let i = self.next_index;\n        let ptr = r as *const Receiver<_> as *const u8;\n        self.handles.push((r, i, ptr));\n        self.next_index += 1;\n        i\n    }\n\n    /// Removes a previously added operation.\n    ///\n    /// This is useful when an operation is selected because the channel got disconnected and we\n    /// want to try again to select a different operation instead.\n    ///\n    /// If new operations are added after removing some, the indices of removed operations will not\n    /// be reused.\n    ///\n    /// # Panics\n    ///\n    /// An attempt to remove a non-existing or already removed operation will panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{unbounded, Select};\n    ///\n    /// let (s1, r1) = unbounded::<i32>();\n    /// let (_, r2) = unbounded::<i32>();\n    ///\n    /// let mut sel = Select::new();\n    /// let oper1 = sel.recv(&r1);\n    /// let oper2 = sel.recv(&r2);\n    ///\n    /// // Both operations are initially ready, so a random one will be executed.\n    /// let oper = sel.select();\n    /// assert_eq!(oper.index(), oper2);\n    /// assert!(oper.recv(&r2).is_err());\n    /// sel.remove(oper2);\n    ///\n    /// s1.send(10).unwrap();\n    ///\n    /// let oper = sel.select();\n    /// assert_eq!(oper.index(), oper1);\n    /// assert_eq!(oper.recv(&r1), Ok(10));\n    /// ```\n    pub fn remove(&mut self, index: usize) {\n        assert!(\n            index < self.next_index,\n            \"index out of bounds; {} >= {}\",\n            index,\n            self.next_index,\n        );\n\n        let i = self\n            .handles\n            .iter()\n            .enumerate()\n            .find(|(_, (_, i, _))| *i == index)\n            .expect(\"no operation with this index\")\n            .0;\n\n        self.handles.swap_remove(i);\n    }\n\n    /// Attempts to select one of the operations without blocking.\n    ///\n    /// If an operation is ready, it is selected and returned. If multiple operations are ready at\n    /// the same time, a random one among them is selected. If none of the operations are ready, an\n    /// error is returned.\n    ///\n    /// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n    /// even when it will simply return an error because the channel is disconnected.\n    ///\n    /// The selected operation must be completed with [`SelectedOperation::send`]\n    /// or [`SelectedOperation::recv`].\n    ///\n    /// [`SelectedOperation::send`]: struct.SelectedOperation.html#method.send\n    /// [`SelectedOperation::recv`]: struct.SelectedOperation.html#method.recv\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{unbounded, Select};\n    ///\n    /// let (s1, r1) = unbounded();\n    /// let (s2, r2) = unbounded();\n    ///\n    /// s1.send(10).unwrap();\n    /// s2.send(20).unwrap();\n    ///\n    /// let mut sel = Select::new();\n    /// let oper1 = sel.recv(&r1);\n    /// let oper2 = sel.recv(&r2);\n    ///\n    /// // Both operations are initially ready, so a random one will be executed.\n    /// let oper = sel.try_select();\n    /// match oper {\n    ///     Err(_) => panic!(\"both operations should be ready\"),\n    ///     Ok(oper) => match oper.index() {\n    ///         i if i == oper1 => assert_eq!(oper.recv(&r1), Ok(10)),\n    ///         i if i == oper2 => assert_eq!(oper.recv(&r2), Ok(20)),\n    ///         _ => unreachable!(),\n    ///     }\n    /// }\n    /// ```\n    pub fn try_select(&mut self) -> Result<SelectedOperation<'a>, TrySelectError> {\n        try_select(&mut self.handles)\n    }\n\n    /// Blocks until one of the operations becomes ready and selects it.\n    ///\n    /// Once an operation becomes ready, it is selected and returned. If multiple operations are\n    /// ready at the same time, a random one among them is selected.\n    ///\n    /// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n    /// even when it will simply return an error because the channel is disconnected.\n    ///\n    /// The selected operation must be completed with [`SelectedOperation::send`]\n    /// or [`SelectedOperation::recv`].\n    ///\n    /// [`SelectedOperation::send`]: struct.SelectedOperation.html#method.send\n    /// [`SelectedOperation::recv`]: struct.SelectedOperation.html#method.recv\n    ///\n    /// # Panics\n    ///\n    /// Panics if no operations have been added to `Select`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    /// use crossbeam_channel::{unbounded, Select};\n    ///\n    /// let (s1, r1) = unbounded();\n    /// let (s2, r2) = unbounded();\n    ///\n    /// thread::spawn(move || {\n    ///     thread::sleep(Duration::from_secs(1));\n    ///     s1.send(10).unwrap();\n    /// });\n    /// thread::spawn(move || s2.send(20).unwrap());\n    ///\n    /// let mut sel = Select::new();\n    /// let oper1 = sel.recv(&r1);\n    /// let oper2 = sel.recv(&r2);\n    ///\n    /// // The second operation will be selected because it becomes ready first.\n    /// let oper = sel.select();\n    /// match oper.index() {\n    ///     i if i == oper1 => assert_eq!(oper.recv(&r1), Ok(10)),\n    ///     i if i == oper2 => assert_eq!(oper.recv(&r2), Ok(20)),\n    ///     _ => unreachable!(),\n    /// }\n    /// ```\n    pub fn select(&mut self) -> SelectedOperation<'a> {\n        select(&mut self.handles)\n    }\n\n    /// Blocks for a limited time until one of the operations becomes ready and selects it.\n    ///\n    /// If an operation becomes ready, it is selected and returned. If multiple operations are\n    /// ready at the same time, a random one among them is selected. If none of the operations\n    /// become ready for the specified duration, an error is returned.\n    ///\n    /// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n    /// even when it will simply return an error because the channel is disconnected.\n    ///\n    /// The selected operation must be completed with [`SelectedOperation::send`]\n    /// or [`SelectedOperation::recv`].\n    ///\n    /// [`SelectedOperation::send`]: struct.SelectedOperation.html#method.send\n    /// [`SelectedOperation::recv`]: struct.SelectedOperation.html#method.recv\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    /// use crossbeam_channel::{unbounded, Select};\n    ///\n    /// let (s1, r1) = unbounded();\n    /// let (s2, r2) = unbounded();\n    ///\n    /// thread::spawn(move || {\n    ///     thread::sleep(Duration::from_secs(1));\n    ///     s1.send(10).unwrap();\n    /// });\n    /// thread::spawn(move || s2.send(20).unwrap());\n    ///\n    /// let mut sel = Select::new();\n    /// let oper1 = sel.recv(&r1);\n    /// let oper2 = sel.recv(&r2);\n    ///\n    /// // The second operation will be selected because it becomes ready first.\n    /// let oper = sel.select_timeout(Duration::from_millis(500));\n    /// match oper {\n    ///     Err(_) => panic!(\"should not have timed out\"),\n    ///     Ok(oper) => match oper.index() {\n    ///         i if i == oper1 => assert_eq!(oper.recv(&r1), Ok(10)),\n    ///         i if i == oper2 => assert_eq!(oper.recv(&r2), Ok(20)),\n    ///         _ => unreachable!(),\n    ///     }\n    /// }\n    /// ```\n    pub fn select_timeout(\n        &mut self,\n        timeout: Duration,\n    ) -> Result<SelectedOperation<'a>, SelectTimeoutError> {\n        select_timeout(&mut self.handles, timeout)\n    }\n\n    /// Attempts to find a ready operation without blocking.\n    ///\n    /// If an operation is ready, its index is returned. If multiple operations are ready at the\n    /// same time, a random one among them is chosen. If none of the operations are ready, an error\n    /// is returned.\n    ///\n    /// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n    /// even when it will simply return an error because the channel is disconnected.\n    ///\n    /// Note that this method might return with success spuriously, so it's a good idea to always\n    /// double check if the operation is really ready.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{unbounded, Select};\n    ///\n    /// let (s1, r1) = unbounded();\n    /// let (s2, r2) = unbounded();\n    ///\n    /// s1.send(10).unwrap();\n    /// s2.send(20).unwrap();\n    ///\n    /// let mut sel = Select::new();\n    /// let oper1 = sel.recv(&r1);\n    /// let oper2 = sel.recv(&r2);\n    ///\n    /// // Both operations are initially ready, so a random one will be chosen.\n    /// match sel.try_ready() {\n    ///     Err(_) => panic!(\"both operations should be ready\"),\n    ///     Ok(i) if i == oper1 => assert_eq!(r1.try_recv(), Ok(10)),\n    ///     Ok(i) if i == oper2 => assert_eq!(r2.try_recv(), Ok(20)),\n    ///     Ok(_) => unreachable!(),\n    /// }\n    /// ```\n    pub fn try_ready(&mut self) -> Result<usize, TryReadyError> {\n        match run_ready(&mut self.handles, Timeout::Now) {\n            None => Err(TryReadyError),\n            Some(index) => Ok(index),\n        }\n    }\n\n    /// Blocks until one of the operations becomes ready.\n    ///\n    /// Once an operation becomes ready, its index is returned. If multiple operations are ready at\n    /// the same time, a random one among them is chosen.\n    ///\n    /// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n    /// even when it will simply return an error because the channel is disconnected.\n    ///\n    /// Note that this method might return with success spuriously, so it's a good idea to always\n    /// double check if the operation is really ready.\n    ///\n    /// # Panics\n    ///\n    /// Panics if no operations have been added to `Select`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    /// use crossbeam_channel::{unbounded, Select};\n    ///\n    /// let (s1, r1) = unbounded();\n    /// let (s2, r2) = unbounded();\n    ///\n    /// thread::spawn(move || {\n    ///     thread::sleep(Duration::from_secs(1));\n    ///     s1.send(10).unwrap();\n    /// });\n    /// thread::spawn(move || s2.send(20).unwrap());\n    ///\n    /// let mut sel = Select::new();\n    /// let oper1 = sel.recv(&r1);\n    /// let oper2 = sel.recv(&r2);\n    ///\n    /// // The second operation will be selected because it becomes ready first.\n    /// match sel.ready() {\n    ///     i if i == oper1 => assert_eq!(r1.try_recv(), Ok(10)),\n    ///     i if i == oper2 => assert_eq!(r2.try_recv(), Ok(20)),\n    ///     _ => unreachable!(),\n    /// }\n    /// ```\n    pub fn ready(&mut self) -> usize {\n        if self.handles.is_empty() {\n            panic!(\"no operations have been added to `Select`\");\n        }\n\n        run_ready(&mut self.handles, Timeout::Never).unwrap()\n    }\n\n    /// Blocks for a limited time until one of the operations becomes ready.\n    ///\n    /// If an operation becomes ready, its index is returned. If multiple operations are ready at\n    /// the same time, a random one among them is chosen. If none of the operations become ready\n    /// for the specified duration, an error is returned.\n    ///\n    /// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n    /// even when it will simply return an error because the channel is disconnected.\n    ///\n    /// Note that this method might return with success spuriously, so it's a good idea to double\n    /// check if the operation is really ready.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    /// use crossbeam_channel::{unbounded, Select};\n    ///\n    /// let (s1, r1) = unbounded();\n    /// let (s2, r2) = unbounded();\n    ///\n    /// thread::spawn(move || {\n    ///     thread::sleep(Duration::from_secs(1));\n    ///     s1.send(10).unwrap();\n    /// });\n    /// thread::spawn(move || s2.send(20).unwrap());\n    ///\n    /// let mut sel = Select::new();\n    /// let oper1 = sel.recv(&r1);\n    /// let oper2 = sel.recv(&r2);\n    ///\n    /// // The second operation will be selected because it becomes ready first.\n    /// match sel.ready_timeout(Duration::from_millis(500)) {\n    ///     Err(_) => panic!(\"should not have timed out\"),\n    ///     Ok(i) if i == oper1 => assert_eq!(r1.try_recv(), Ok(10)),\n    ///     Ok(i) if i == oper2 => assert_eq!(r2.try_recv(), Ok(20)),\n    ///     Ok(_) => unreachable!(),\n    /// }\n    /// ```\n    pub fn ready_timeout(&mut self, timeout: Duration) -> Result<usize, ReadyTimeoutError> {\n        let timeout = Timeout::At(Instant::now() + timeout);\n\n        match run_ready(&mut self.handles, timeout) {\n            None => Err(ReadyTimeoutError),\n            Some(index) => Ok(index),\n        }\n    }\n}","unsafe impl Send for Select<'_> {}","unsafe impl Sync for Select<'_> {}"],"select::Selected":["Clone","Copy","Debug","Eq","PartialEq","impl From<usize> for Selected {\n    #[inline]\n    fn from(val: usize) -> Selected {\n        match val {\n            0 => Selected::Waiting,\n            1 => Selected::Aborted,\n            2 => Selected::Disconnected,\n            oper => Selected::Operation(Operation(oper)),\n        }\n    }\n}","impl Into<usize> for Selected {\n    #[inline]\n    fn into(self) -> usize {\n        match self {\n            Selected::Waiting => 0,\n            Selected::Aborted => 1,\n            Selected::Disconnected => 2,\n            Selected::Operation(Operation(val)) => val,\n        }\n    }\n}"],"select::SelectedOperation":["impl Drop for SelectedOperation<'_> {\n    fn drop(&mut self) {\n        panic!(\"dropped `SelectedOperation` without completing the operation\");\n    }\n}","impl SelectedOperation<'_> {\n    /// Returns the index of the selected operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{bounded, Select};\n    ///\n    /// let (s1, r1) = bounded::<()>(0);\n    /// let (s2, r2) = bounded::<()>(0);\n    /// let (s3, r3) = bounded::<()>(1);\n    ///\n    /// let mut sel = Select::new();\n    /// let oper1 = sel.send(&s1);\n    /// let oper2 = sel.recv(&r2);\n    /// let oper3 = sel.send(&s3);\n    ///\n    /// // Only the last operation is ready.\n    /// let oper = sel.select();\n    /// assert_eq!(oper.index(), 2);\n    /// assert_eq!(oper.index(), oper3);\n    ///\n    /// // Complete the operation.\n    /// oper.send(&s3, ()).unwrap();\n    /// ```\n    pub fn index(&self) -> usize {\n        self.index\n    }\n\n    /// Completes the send operation.\n    ///\n    /// The passed [`Sender`] reference must be the same one that was used in [`Select::send`]\n    /// when the operation was added.\n    ///\n    /// # Panics\n    ///\n    /// Panics if an incorrect [`Sender`] reference is passed.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{bounded, Select, SendError};\n    ///\n    /// let (s, r) = bounded::<i32>(0);\n    /// drop(r);\n    ///\n    /// let mut sel = Select::new();\n    /// let oper1 = sel.send(&s);\n    ///\n    /// let oper = sel.select();\n    /// assert_eq!(oper.index(), oper1);\n    /// assert_eq!(oper.send(&s, 10), Err(SendError(10)));\n    /// ```\n    ///\n    /// [`Sender`]: struct.Sender.html\n    /// [`Select::send`]: struct.Select.html#method.send\n    pub fn send<T>(mut self, s: &Sender<T>, msg: T) -> Result<(), SendError<T>> {\n        assert!(\n            s as *const Sender<T> as *const u8 == self.ptr,\n            \"passed a sender that wasn't selected\",\n        );\n        let res = unsafe { channel::write(s, &mut self.token, msg) };\n        mem::forget(self);\n        res.map_err(SendError)\n    }\n\n    /// Completes the receive operation.\n    ///\n    /// The passed [`Receiver`] reference must be the same one that was used in [`Select::recv`]\n    /// when the operation was added.\n    ///\n    /// # Panics\n    ///\n    /// Panics if an incorrect [`Receiver`] reference is passed.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use crossbeam_channel::{bounded, Select, RecvError};\n    ///\n    /// let (s, r) = bounded::<i32>(0);\n    /// drop(s);\n    ///\n    /// let mut sel = Select::new();\n    /// let oper1 = sel.recv(&r);\n    ///\n    /// let oper = sel.select();\n    /// assert_eq!(oper.index(), oper1);\n    /// assert_eq!(oper.recv(&r), Err(RecvError));\n    /// ```\n    ///\n    /// [`Receiver`]: struct.Receiver.html\n    /// [`Select::recv`]: struct.Select.html#method.recv\n    pub fn recv<T>(mut self, r: &Receiver<T>) -> Result<T, RecvError> {\n        assert!(\n            r as *const Receiver<T> as *const u8 == self.ptr,\n            \"passed a receiver that wasn't selected\",\n        );\n        let res = unsafe { channel::read(r, &mut self.token) };\n        mem::forget(self);\n        res.map_err(|_| RecvError)\n    }\n}","impl fmt::Debug for SelectedOperation<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"SelectedOperation { .. }\")\n    }\n}"],"select::Timeout":["Clone","Copy","Eq","PartialEq"],"select::Token":["Debug","Default"],"utils::Spinlock":["impl<T> Spinlock<T> {\n    /// Returns a new spinlock initialized with `value`.\n    pub fn new(value: T) -> Spinlock<T> {\n        Spinlock {\n            flag: AtomicBool::new(false),\n            value: UnsafeCell::new(value),\n        }\n    }\n\n    /// Locks the spinlock.\n    pub fn lock(&self) -> SpinlockGuard<'_, T> {\n        let backoff = Backoff::new();\n        while self.flag.swap(true, Ordering::Acquire) {\n            backoff.snooze();\n        }\n        SpinlockGuard { parent: self }\n    }\n}"],"utils::SpinlockGuard":["impl<T> Deref for SpinlockGuard<'_, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        unsafe { &*self.parent.value.get() }\n    }\n}","impl<T> DerefMut for SpinlockGuard<'_, T> {\n    fn deref_mut(&mut self) -> &mut T {\n        unsafe { &mut *self.parent.value.get() }\n    }\n}","impl<T> Drop for SpinlockGuard<'_, T> {\n    fn drop(&mut self) {\n        self.parent.flag.store(false, Ordering::Release);\n    }\n}"],"waker::SyncWaker":["impl Drop for SyncWaker {\n    #[inline]\n    fn drop(&mut self) {\n        debug_assert_eq!(self.is_empty.load(Ordering::SeqCst), true);\n    }\n}","impl SyncWaker {\n    /// Creates a new `SyncWaker`.\n    #[inline]\n    pub fn new() -> Self {\n        SyncWaker {\n            inner: Spinlock::new(Waker::new()),\n            is_empty: AtomicBool::new(true),\n        }\n    }\n\n    /// Registers the current thread with an operation.\n    #[inline]\n    pub fn register(&self, oper: Operation, cx: &Context) {\n        let mut inner = self.inner.lock();\n        inner.register(oper, cx);\n        self.is_empty.store(\n            inner.selectors.is_empty() && inner.observers.is_empty(),\n            Ordering::SeqCst,\n        );\n    }\n\n    /// Unregisters an operation previously registered by the current thread.\n    #[inline]\n    pub fn unregister(&self, oper: Operation) -> Option<Entry> {\n        let mut inner = self.inner.lock();\n        let entry = inner.unregister(oper);\n        self.is_empty.store(\n            inner.selectors.is_empty() && inner.observers.is_empty(),\n            Ordering::SeqCst,\n        );\n        entry\n    }\n\n    /// Attempts to find one thread (not the current one), select its operation, and wake it up.\n    #[inline]\n    pub fn notify(&self) {\n        if !self.is_empty.load(Ordering::SeqCst) {\n            let mut inner = self.inner.lock();\n            if !self.is_empty.load(Ordering::SeqCst) {\n                inner.try_select();\n                inner.notify();\n                self.is_empty.store(\n                    inner.selectors.is_empty() && inner.observers.is_empty(),\n                    Ordering::SeqCst,\n                );\n            }\n        }\n    }\n\n    /// Registers an operation waiting to be ready.\n    #[inline]\n    pub fn watch(&self, oper: Operation, cx: &Context) {\n        let mut inner = self.inner.lock();\n        inner.watch(oper, cx);\n        self.is_empty.store(\n            inner.selectors.is_empty() && inner.observers.is_empty(),\n            Ordering::SeqCst,\n        );\n    }\n\n    /// Unregisters an operation waiting to be ready.\n    #[inline]\n    pub fn unwatch(&self, oper: Operation) {\n        let mut inner = self.inner.lock();\n        inner.unwatch(oper);\n        self.is_empty.store(\n            inner.selectors.is_empty() && inner.observers.is_empty(),\n            Ordering::SeqCst,\n        );\n    }\n\n    /// Notifies all threads that the channel is disconnected.\n    #[inline]\n    pub fn disconnect(&self) {\n        let mut inner = self.inner.lock();\n        inner.disconnect();\n        self.is_empty.store(\n            inner.selectors.is_empty() && inner.observers.is_empty(),\n            Ordering::SeqCst,\n        );\n    }\n}"],"waker::Waker":["impl Drop for Waker {\n    #[inline]\n    fn drop(&mut self) {\n        debug_assert_eq!(self.selectors.len(), 0);\n        debug_assert_eq!(self.observers.len(), 0);\n    }\n}","impl Waker {\n    /// Creates a new `Waker`.\n    #[inline]\n    pub fn new() -> Self {\n        Waker {\n            selectors: Vec::new(),\n            observers: Vec::new(),\n        }\n    }\n\n    /// Registers a select operation.\n    #[inline]\n    pub fn register(&mut self, oper: Operation, cx: &Context) {\n        self.register_with_packet(oper, 0, cx);\n    }\n\n    /// Registers a select operation and a packet.\n    #[inline]\n    pub fn register_with_packet(&mut self, oper: Operation, packet: usize, cx: &Context) {\n        self.selectors.push(Entry {\n            oper,\n            packet,\n            cx: cx.clone(),\n        });\n    }\n\n    /// Unregisters a select operation.\n    #[inline]\n    pub fn unregister(&mut self, oper: Operation) -> Option<Entry> {\n        if let Some((i, _)) = self\n            .selectors\n            .iter()\n            .enumerate()\n            .find(|&(_, entry)| entry.oper == oper)\n        {\n            let entry = self.selectors.remove(i);\n            Some(entry)\n        } else {\n            None\n        }\n    }\n\n    /// Attempts to find another thread's entry, select the operation, and wake it up.\n    #[inline]\n    pub fn try_select(&mut self) -> Option<Entry> {\n        let mut entry = None;\n\n        if !self.selectors.is_empty() {\n            let thread_id = current_thread_id();\n\n            for i in 0..self.selectors.len() {\n                // Does the entry belong to a different thread?\n                if self.selectors[i].cx.thread_id() != thread_id {\n                    // Try selecting this operation.\n                    let sel = Selected::Operation(self.selectors[i].oper);\n                    let res = self.selectors[i].cx.try_select(sel);\n\n                    if res.is_ok() {\n                        // Provide the packet.\n                        self.selectors[i].cx.store_packet(self.selectors[i].packet);\n                        // Wake the thread up.\n                        self.selectors[i].cx.unpark();\n\n                        // Remove the entry from the queue to keep it clean and improve\n                        // performance.\n                        entry = Some(self.selectors.remove(i));\n                        break;\n                    }\n                }\n            }\n        }\n\n        entry\n    }\n\n    /// Returns `true` if there is an entry which can be selected by the current thread.\n    #[inline]\n    pub fn can_select(&self) -> bool {\n        if self.selectors.is_empty() {\n            false\n        } else {\n            let thread_id = current_thread_id();\n\n            self.selectors.iter().any(|entry| {\n                entry.cx.thread_id() != thread_id && entry.cx.selected() == Selected::Waiting\n            })\n        }\n    }\n\n    /// Registers an operation waiting to be ready.\n    #[inline]\n    pub fn watch(&mut self, oper: Operation, cx: &Context) {\n        self.observers.push(Entry {\n            oper,\n            packet: 0,\n            cx: cx.clone(),\n        });\n    }\n\n    /// Unregisters an operation waiting to be ready.\n    #[inline]\n    pub fn unwatch(&mut self, oper: Operation) {\n        self.observers.retain(|e| e.oper != oper);\n    }\n\n    /// Notifies all operations waiting to be ready.\n    #[inline]\n    pub fn notify(&mut self) {\n        for entry in self.observers.drain(..) {\n            if entry.cx.try_select(Selected::Operation(entry.oper)).is_ok() {\n                entry.cx.unpark();\n            }\n        }\n    }\n\n    /// Notifies all registered operations that the channel is disconnected.\n    #[inline]\n    pub fn disconnect(&mut self) {\n        for entry in self.selectors.iter() {\n            if entry.cx.try_select(Selected::Disconnected).is_ok() {\n                // Wake the thread up.\n                //\n                // Here we don't remove the entry from the queue. Registered threads must\n                // unregister from the waker by themselves. They might also want to recover the\n                // packet value and destroy it, if necessary.\n                entry.cx.unpark();\n            }\n        }\n\n        self.notify();\n    }\n}"]},"single_path_import":{"channel::IntoIter":"IntoIter","channel::Iter":"Iter","channel::Receiver":"Receiver","channel::Sender":"Sender","channel::TryIter":"TryIter","channel::after":"after","channel::bounded":"bounded","channel::never":"never","channel::tick":"tick","channel::unbounded":"unbounded","err::ReadyTimeoutError":"ReadyTimeoutError","err::RecvError":"RecvError","err::RecvTimeoutError":"RecvTimeoutError","err::SelectTimeoutError":"SelectTimeoutError","err::SendError":"SendError","err::SendTimeoutError":"SendTimeoutError","err::TryReadyError":"TryReadyError","err::TryRecvError":"TryRecvError","err::TrySelectError":"TrySelectError","err::TrySendError":"TrySendError","select::Select":"Select","select::SelectHandle":"internal::SelectHandle","select::SelectedOperation":"SelectedOperation","select::select":"internal::select","select::select_timeout":"internal::select_timeout","select::try_select":"internal::try_select"},"srcs":{"<&'a channel::Receiver<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<&T as select::SelectHandle>::accept":["fn accept(&self, token: &mut Token, cx: &Context) -> bool{\n        (**self).accept(token, cx)\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<&T as select::SelectHandle>::deadline":["fn deadline(&self) -> Option<Instant>{\n        (**self).deadline()\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<&T as select::SelectHandle>::is_ready":["fn is_ready(&self) -> bool{\n        (**self).is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<&T as select::SelectHandle>::register":["fn register(&self, oper: Operation, cx: &Context) -> bool{\n        (**self).register(oper, cx)\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<&T as select::SelectHandle>::try_select":["fn try_select(&self, token: &mut Token) -> bool{\n        (**self).try_select(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<&T as select::SelectHandle>::unregister":["fn unregister(&self, oper: Operation){\n        (**self).unregister(oper);\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<&T as select::SelectHandle>::unwatch":["fn unwatch(&self, oper: Operation){\n        (**self).unwatch(oper)\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<&T as select::SelectHandle>::watch":["fn watch(&self, oper: Operation, cx: &Context) -> bool{\n        (**self).watch(oper, cx)\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<channel::IntoIter<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"IntoIter { .. }\")\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::IntoIter<T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.receiver.recv().ok()\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Iter<'_, T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"Iter { .. }\")\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Iter<'_, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.receiver.recv().ok()\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as select::SelectHandle>::accept":["fn accept(&self, token: &mut Token, cx: &Context) -> bool{\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().accept(token, cx),\n            ReceiverFlavor::List(chan) => chan.receiver().accept(token, cx),\n            ReceiverFlavor::Zero(chan) => chan.receiver().accept(token, cx),\n            ReceiverFlavor::After(chan) => chan.accept(token, cx),\n            ReceiverFlavor::Tick(chan) => chan.accept(token, cx),\n            ReceiverFlavor::Never(chan) => chan.accept(token, cx),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as select::SelectHandle>::deadline":["fn deadline(&self) -> Option<Instant>{\n        match &self.flavor {\n            ReceiverFlavor::Array(_) => None,\n            ReceiverFlavor::List(_) => None,\n            ReceiverFlavor::Zero(_) => None,\n            ReceiverFlavor::After(chan) => chan.deadline(),\n            ReceiverFlavor::Tick(chan) => chan.deadline(),\n            ReceiverFlavor::Never(chan) => chan.deadline(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as select::SelectHandle>::is_ready":["fn is_ready(&self) -> bool{\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().is_ready(),\n            ReceiverFlavor::List(chan) => chan.receiver().is_ready(),\n            ReceiverFlavor::Zero(chan) => chan.receiver().is_ready(),\n            ReceiverFlavor::After(chan) => chan.is_ready(),\n            ReceiverFlavor::Tick(chan) => chan.is_ready(),\n            ReceiverFlavor::Never(chan) => chan.is_ready(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as select::SelectHandle>::register":["fn register(&self, oper: Operation, cx: &Context) -> bool{\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().register(oper, cx),\n            ReceiverFlavor::List(chan) => chan.receiver().register(oper, cx),\n            ReceiverFlavor::Zero(chan) => chan.receiver().register(oper, cx),\n            ReceiverFlavor::After(chan) => chan.register(oper, cx),\n            ReceiverFlavor::Tick(chan) => chan.register(oper, cx),\n            ReceiverFlavor::Never(chan) => chan.register(oper, cx),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as select::SelectHandle>::try_select":["fn try_select(&self, token: &mut Token) -> bool{\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().try_select(token),\n            ReceiverFlavor::List(chan) => chan.receiver().try_select(token),\n            ReceiverFlavor::Zero(chan) => chan.receiver().try_select(token),\n            ReceiverFlavor::After(chan) => chan.try_select(token),\n            ReceiverFlavor::Tick(chan) => chan.try_select(token),\n            ReceiverFlavor::Never(chan) => chan.try_select(token),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as select::SelectHandle>::unregister":["fn unregister(&self, oper: Operation){\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().unregister(oper),\n            ReceiverFlavor::List(chan) => chan.receiver().unregister(oper),\n            ReceiverFlavor::Zero(chan) => chan.receiver().unregister(oper),\n            ReceiverFlavor::After(chan) => chan.unregister(oper),\n            ReceiverFlavor::Tick(chan) => chan.unregister(oper),\n            ReceiverFlavor::Never(chan) => chan.unregister(oper),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as select::SelectHandle>::unwatch":["fn unwatch(&self, oper: Operation){\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().unwatch(oper),\n            ReceiverFlavor::List(chan) => chan.receiver().unwatch(oper),\n            ReceiverFlavor::Zero(chan) => chan.receiver().unwatch(oper),\n            ReceiverFlavor::After(chan) => chan.unwatch(oper),\n            ReceiverFlavor::Tick(chan) => chan.unwatch(oper),\n            ReceiverFlavor::Never(chan) => chan.unwatch(oper),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as select::SelectHandle>::watch":["fn watch(&self, oper: Operation, cx: &Context) -> bool{\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.receiver().watch(oper, cx),\n            ReceiverFlavor::List(chan) => chan.receiver().watch(oper, cx),\n            ReceiverFlavor::Zero(chan) => chan.receiver().watch(oper, cx),\n            ReceiverFlavor::After(chan) => chan.watch(oper, cx),\n            ReceiverFlavor::Tick(chan) => chan.watch(oper, cx),\n            ReceiverFlavor::Never(chan) => chan.watch(oper, cx),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        let flavor = match &self.flavor {\n            ReceiverFlavor::Array(chan) => ReceiverFlavor::Array(chan.acquire()),\n            ReceiverFlavor::List(chan) => ReceiverFlavor::List(chan.acquire()),\n            ReceiverFlavor::Zero(chan) => ReceiverFlavor::Zero(chan.acquire()),\n            ReceiverFlavor::After(chan) => ReceiverFlavor::After(chan.clone()),\n            ReceiverFlavor::Tick(chan) => ReceiverFlavor::Tick(chan.clone()),\n            ReceiverFlavor::Never(_) => ReceiverFlavor::Never(flavors::never::Channel::new()),\n        };\n\n        Receiver { flavor }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"Receiver { .. }\")\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        IntoIter { receiver: self }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Receiver<T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        unsafe {\n            match &self.flavor {\n                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n                ReceiverFlavor::List(chan) => chan.release(|c| c.disconnect()),\n                ReceiverFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n                ReceiverFlavor::After(_) => {}\n                ReceiverFlavor::Tick(_) => {}\n                ReceiverFlavor::Never(_) => {}\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Sender<T> as select::SelectHandle>::accept":["fn accept(&self, token: &mut Token, cx: &Context) -> bool{\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().accept(token, cx),\n            SenderFlavor::List(chan) => chan.sender().accept(token, cx),\n            SenderFlavor::Zero(chan) => chan.sender().accept(token, cx),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Sender<T> as select::SelectHandle>::deadline":["fn deadline(&self) -> Option<Instant>{\n        None\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Sender<T> as select::SelectHandle>::is_ready":["fn is_ready(&self) -> bool{\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().is_ready(),\n            SenderFlavor::List(chan) => chan.sender().is_ready(),\n            SenderFlavor::Zero(chan) => chan.sender().is_ready(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Sender<T> as select::SelectHandle>::register":["fn register(&self, oper: Operation, cx: &Context) -> bool{\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().register(oper, cx),\n            SenderFlavor::List(chan) => chan.sender().register(oper, cx),\n            SenderFlavor::Zero(chan) => chan.sender().register(oper, cx),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Sender<T> as select::SelectHandle>::try_select":["fn try_select(&self, token: &mut Token) -> bool{\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().try_select(token),\n            SenderFlavor::List(chan) => chan.sender().try_select(token),\n            SenderFlavor::Zero(chan) => chan.sender().try_select(token),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Sender<T> as select::SelectHandle>::unregister":["fn unregister(&self, oper: Operation){\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().unregister(oper),\n            SenderFlavor::List(chan) => chan.sender().unregister(oper),\n            SenderFlavor::Zero(chan) => chan.sender().unregister(oper),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Sender<T> as select::SelectHandle>::unwatch":["fn unwatch(&self, oper: Operation){\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().unwatch(oper),\n            SenderFlavor::List(chan) => chan.sender().unwatch(oper),\n            SenderFlavor::Zero(chan) => chan.sender().unwatch(oper),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Sender<T> as select::SelectHandle>::watch":["fn watch(&self, oper: Operation, cx: &Context) -> bool{\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.sender().watch(oper, cx),\n            SenderFlavor::List(chan) => chan.sender().watch(oper, cx),\n            SenderFlavor::Zero(chan) => chan.sender().watch(oper, cx),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Sender<T> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        let flavor = match &self.flavor {\n            SenderFlavor::Array(chan) => SenderFlavor::Array(chan.acquire()),\n            SenderFlavor::List(chan) => SenderFlavor::List(chan.acquire()),\n            SenderFlavor::Zero(chan) => SenderFlavor::Zero(chan.acquire()),\n        };\n\n        Sender { flavor }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Sender<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"Sender { .. }\")\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::Sender<T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        unsafe {\n            match &self.flavor {\n                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n                SenderFlavor::List(chan) => chan.release(|c| c.disconnect()),\n                SenderFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::TryIter<'_, T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"TryIter { .. }\")\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<channel::TryIter<'_, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.receiver.try_recv().ok()\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"<counter::Receiver<C> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Receiver<C>) -> bool{\n        self.counter == other.counter\n    }","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"<counter::Receiver<C> as std::ops::Deref>::deref":["fn deref(&self) -> &C{\n        &self.counter().chan\n    }","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"<counter::Sender<C> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Sender<C>) -> bool{\n        self.counter == other.counter\n    }","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"<counter::Sender<C> as std::ops::Deref>::deref":["fn deref(&self) -> &C{\n        &self.counter().chan\n    }","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"<err::RecvError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        \"receiving on an empty and disconnected channel\".fmt(f)\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::RecvTimeoutError as std::convert::From<err::RecvError>>::from":["fn from(err: RecvError) -> RecvTimeoutError{\n        match err {\n            RecvError => RecvTimeoutError::Disconnected,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::RecvTimeoutError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match *self {\n            RecvTimeoutError::Timeout => \"timed out waiting on receive operation\".fmt(f),\n            RecvTimeoutError::Disconnected => \"channel is empty and disconnected\".fmt(f),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::SelectTimeoutError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        \"timed out waiting on select\".fmt(f)\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::SendError<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        \"SendError(..)\".fmt(f)\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::SendError<T> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        \"sending on a disconnected channel\".fmt(f)\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::SendTimeoutError<T> as std::convert::From<err::SendError<T>>>::from":["fn from(err: SendError<T>) -> SendTimeoutError<T>{\n        match err {\n            SendError(e) => SendTimeoutError::Disconnected(e),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::SendTimeoutError<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        \"SendTimeoutError(..)\".fmt(f)\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::SendTimeoutError<T> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match *self {\n            SendTimeoutError::Timeout(..) => \"timed out waiting on send operation\".fmt(f),\n            SendTimeoutError::Disconnected(..) => \"sending on a disconnected channel\".fmt(f),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::TryRecvError as std::convert::From<err::RecvError>>::from":["fn from(err: RecvError) -> TryRecvError{\n        match err {\n            RecvError => TryRecvError::Disconnected,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::TryRecvError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match *self {\n            TryRecvError::Empty => \"receiving on an empty channel\".fmt(f),\n            TryRecvError::Disconnected => \"receiving on an empty and disconnected channel\".fmt(f),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::TrySelectError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        \"all operations in select would block\".fmt(f)\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::TrySendError<T> as std::convert::From<err::SendError<T>>>::from":["fn from(err: SendError<T>) -> TrySendError<T>{\n        match err {\n            SendError(t) => TrySendError::Disconnected(t),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::TrySendError<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match *self {\n            TrySendError::Full(..) => \"Full(..)\".fmt(f),\n            TrySendError::Disconnected(..) => \"Disconnected(..)\".fmt(f),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<err::TrySendError<T> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match *self {\n            TrySendError::Full(..) => \"sending on a full channel\".fmt(f),\n            TrySendError::Disconnected(..) => \"sending on a disconnected channel\".fmt(f),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"<flavors::after::Channel as select::SelectHandle>::accept":["#[inline]\nfn accept(&self, token: &mut Token, _cx: &Context) -> bool{\n        self.try_select(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"<flavors::after::Channel as select::SelectHandle>::deadline":["#[inline]\nfn deadline(&self) -> Option<Instant>{\n        // We use relaxed ordering because this is just an optional optimistic check.\n        if self.received.load(Ordering::Relaxed) {\n            None\n        } else {\n            Some(self.delivery_time)\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"<flavors::after::Channel as select::SelectHandle>::is_ready":["#[inline]\nfn is_ready(&self) -> bool{\n        !self.is_empty()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"<flavors::after::Channel as select::SelectHandle>::register":["#[inline]\nfn register(&self, _oper: Operation, _cx: &Context) -> bool{\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"<flavors::after::Channel as select::SelectHandle>::try_select":["#[inline]\nfn try_select(&self, token: &mut Token) -> bool{\n        match self.try_recv() {\n            Ok(msg) => {\n                token.after = Some(msg);\n                true\n            }\n            Err(TryRecvError::Disconnected) => {\n                token.after = None;\n                true\n            }\n            Err(TryRecvError::Empty) => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"<flavors::after::Channel as select::SelectHandle>::unregister":["#[inline]\nfn unregister(&self, _oper: Operation){}","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"<flavors::after::Channel as select::SelectHandle>::unwatch":["#[inline]\nfn unwatch(&self, _oper: Operation){}","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"<flavors::after::Channel as select::SelectHandle>::watch":["#[inline]\nfn watch(&self, _oper: Operation, _cx: &Context) -> bool{\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"<flavors::array::ArrayToken as std::default::Default>::default":["#[inline]\nfn default() -> Self{\n        ArrayToken {\n            slot: ptr::null(),\n            stamp: 0,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Channel<T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        // Get the index of the head.\n        let hix = self.head.load(Ordering::Relaxed) & (self.mark_bit - 1);\n\n        // Loop over all slots that hold a message and drop them.\n        for i in 0..self.len() {\n            // Compute the index of the next slot holding a message.\n            let index = if hix + i < self.cap {\n                hix + i\n            } else {\n                hix + i - self.cap\n            };\n\n            unsafe {\n                let p = {\n                    let slot = &mut *self.buffer.add(index);\n                    let msg = &mut *slot.msg.get();\n                    msg.as_mut_ptr()\n                };\n                p.drop_in_place();\n            }\n        }\n\n        // Finally, deallocate the buffer, but don't run any destructors.\n        unsafe {\n            Vec::from_raw_parts(self.buffer, 0, self.cap);\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::accept":["fn accept(&self, token: &mut Token, _cx: &Context) -> bool{\n        self.try_select(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::deadline":["fn deadline(&self) -> Option<Instant>{\n        None\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::is_ready":["fn is_ready(&self) -> bool{\n        !self.0.is_empty() || self.0.is_disconnected()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::register":["fn register(&self, oper: Operation, cx: &Context) -> bool{\n        self.0.receivers.register(oper, cx);\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::try_select":["fn try_select(&self, token: &mut Token) -> bool{\n        self.0.start_recv(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::unregister":["fn unregister(&self, oper: Operation){\n        self.0.receivers.unregister(oper);\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::unwatch":["fn unwatch(&self, oper: Operation){\n        self.0.receivers.unwatch(oper);\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::watch":["fn watch(&self, oper: Operation, cx: &Context) -> bool{\n        self.0.receivers.watch(oper, cx);\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::accept":["fn accept(&self, token: &mut Token, _cx: &Context) -> bool{\n        self.try_select(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::deadline":["fn deadline(&self) -> Option<Instant>{\n        None\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::is_ready":["fn is_ready(&self) -> bool{\n        !self.0.is_full() || self.0.is_disconnected()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::register":["fn register(&self, oper: Operation, cx: &Context) -> bool{\n        self.0.senders.register(oper, cx);\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::try_select":["fn try_select(&self, token: &mut Token) -> bool{\n        self.0.start_send(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::unregister":["fn unregister(&self, oper: Operation){\n        self.0.senders.unregister(oper);\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::unwatch":["fn unwatch(&self, oper: Operation){\n        self.0.senders.unwatch(oper);\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::watch":["fn watch(&self, oper: Operation, cx: &Context) -> bool{\n        self.0.senders.watch(oper, cx);\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"<flavors::list::Channel<T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        let mut head = self.head.index.load(Ordering::Relaxed);\n        let mut tail = self.tail.index.load(Ordering::Relaxed);\n        let mut block = self.head.block.load(Ordering::Relaxed);\n\n        // Erase the lower bits.\n        head &= !((1 << SHIFT) - 1);\n        tail &= !((1 << SHIFT) - 1);\n\n        unsafe {\n            // Drop all messages between head and tail and deallocate the heap-allocated blocks.\n            while head != tail {\n                let offset = (head >> SHIFT) % LAP;\n\n                if offset < BLOCK_CAP {\n                    // Drop the message in the slot.\n                    let slot = (*block).slots.get_unchecked(offset);\n                    let p = &mut *slot.msg.get();\n                    p.as_mut_ptr().drop_in_place();\n                } else {\n                    // Deallocate the block and move to the next one.\n                    let next = (*block).next.load(Ordering::Relaxed);\n                    drop(Box::from_raw(block));\n                    block = next;\n                }\n\n                head = head.wrapping_add(1 << SHIFT);\n            }\n\n            // Deallocate the last remaining block.\n            if !block.is_null() {\n                drop(Box::from_raw(block));\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::ListToken as std::default::Default>::default":["#[inline]\nfn default() -> Self{\n        ListToken {\n            block: ptr::null(),\n            offset: 0,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::accept":["fn accept(&self, token: &mut Token, _cx: &Context) -> bool{\n        self.try_select(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::deadline":["fn deadline(&self) -> Option<Instant>{\n        None\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::is_ready":["fn is_ready(&self) -> bool{\n        !self.0.is_empty() || self.0.is_disconnected()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::register":["fn register(&self, oper: Operation, cx: &Context) -> bool{\n        self.0.receivers.register(oper, cx);\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::try_select":["fn try_select(&self, token: &mut Token) -> bool{\n        self.0.start_recv(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::unregister":["fn unregister(&self, oper: Operation){\n        self.0.receivers.unregister(oper);\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::unwatch":["fn unwatch(&self, oper: Operation){\n        self.0.receivers.unwatch(oper);\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::watch":["fn watch(&self, oper: Operation, cx: &Context) -> bool{\n        self.0.receivers.watch(oper, cx);\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::accept":["fn accept(&self, token: &mut Token, _cx: &Context) -> bool{\n        self.try_select(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::deadline":["fn deadline(&self) -> Option<Instant>{\n        None\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::is_ready":["fn is_ready(&self) -> bool{\n        true\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::register":["fn register(&self, _oper: Operation, _cx: &Context) -> bool{\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::try_select":["fn try_select(&self, token: &mut Token) -> bool{\n        self.0.start_send(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::unregister":["fn unregister(&self, _oper: Operation){}","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::unwatch":["fn unwatch(&self, _oper: Operation){}","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::watch":["fn watch(&self, _oper: Operation, _cx: &Context) -> bool{\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"<flavors::never::Channel<T> as select::SelectHandle>::accept":["#[inline]\nfn accept(&self, token: &mut Token, _cx: &Context) -> bool{\n        self.try_select(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"<flavors::never::Channel<T> as select::SelectHandle>::deadline":["#[inline]\nfn deadline(&self) -> Option<Instant>{\n        None\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"<flavors::never::Channel<T> as select::SelectHandle>::is_ready":["#[inline]\nfn is_ready(&self) -> bool{\n        false\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"<flavors::never::Channel<T> as select::SelectHandle>::register":["#[inline]\nfn register(&self, _oper: Operation, _cx: &Context) -> bool{\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"<flavors::never::Channel<T> as select::SelectHandle>::try_select":["#[inline]\nfn try_select(&self, _token: &mut Token) -> bool{\n        false\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"<flavors::never::Channel<T> as select::SelectHandle>::unregister":["#[inline]\nfn unregister(&self, _oper: Operation){}","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"<flavors::never::Channel<T> as select::SelectHandle>::unwatch":["#[inline]\nfn unwatch(&self, _oper: Operation){}","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"<flavors::never::Channel<T> as select::SelectHandle>::watch":["#[inline]\nfn watch(&self, _oper: Operation, _cx: &Context) -> bool{\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"<flavors::tick::Channel as select::SelectHandle>::accept":["#[inline]\nfn accept(&self, token: &mut Token, _cx: &Context) -> bool{\n        self.try_select(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"<flavors::tick::Channel as select::SelectHandle>::deadline":["#[inline]\nfn deadline(&self) -> Option<Instant>{\n        Some(self.delivery_time.load())\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"<flavors::tick::Channel as select::SelectHandle>::is_ready":["#[inline]\nfn is_ready(&self) -> bool{\n        !self.is_empty()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"<flavors::tick::Channel as select::SelectHandle>::register":["#[inline]\nfn register(&self, _oper: Operation, _cx: &Context) -> bool{\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"<flavors::tick::Channel as select::SelectHandle>::try_select":["#[inline]\nfn try_select(&self, token: &mut Token) -> bool{\n        match self.try_recv() {\n            Ok(msg) => {\n                token.tick = Some(msg);\n                true\n            }\n            Err(TryRecvError::Disconnected) => {\n                token.tick = None;\n                true\n            }\n            Err(TryRecvError::Empty) => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"<flavors::tick::Channel as select::SelectHandle>::unregister":["#[inline]\nfn unregister(&self, _oper: Operation){}","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"<flavors::tick::Channel as select::SelectHandle>::unwatch":["#[inline]\nfn unwatch(&self, _oper: Operation){}","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"<flavors::tick::Channel as select::SelectHandle>::watch":["#[inline]\nfn watch(&self, _oper: Operation, _cx: &Context) -> bool{\n        self.is_ready()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::accept":["fn accept(&self, token: &mut Token, cx: &Context) -> bool{\n        token.zero = cx.wait_packet();\n        true\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::deadline":["fn deadline(&self) -> Option<Instant>{\n        None\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::is_ready":["fn is_ready(&self) -> bool{\n        let inner = self.0.inner.lock();\n        inner.senders.can_select() || inner.is_disconnected\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::register":["fn register(&self, oper: Operation, cx: &Context) -> bool{\n        let packet = Box::into_raw(Packet::<T>::empty_on_heap());\n\n        let mut inner = self.0.inner.lock();\n        inner\n            .receivers\n            .register_with_packet(oper, packet as usize, cx);\n        inner.senders.notify();\n        inner.senders.can_select() || inner.is_disconnected\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::try_select":["fn try_select(&self, token: &mut Token) -> bool{\n        self.0.start_recv(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::unregister":["fn unregister(&self, oper: Operation){\n        if let Some(operation) = self.0.inner.lock().receivers.unregister(oper) {\n            unsafe {\n                drop(Box::from_raw(operation.packet as *mut Packet<T>));\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::unwatch":["fn unwatch(&self, oper: Operation){\n        let mut inner = self.0.inner.lock();\n        inner.receivers.unwatch(oper);\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::watch":["fn watch(&self, oper: Operation, cx: &Context) -> bool{\n        let mut inner = self.0.inner.lock();\n        inner.receivers.watch(oper, cx);\n        inner.senders.can_select() || inner.is_disconnected\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::accept":["fn accept(&self, token: &mut Token, cx: &Context) -> bool{\n        token.zero = cx.wait_packet();\n        true\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::deadline":["fn deadline(&self) -> Option<Instant>{\n        None\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::is_ready":["fn is_ready(&self) -> bool{\n        let inner = self.0.inner.lock();\n        inner.receivers.can_select() || inner.is_disconnected\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::register":["fn register(&self, oper: Operation, cx: &Context) -> bool{\n        let packet = Box::into_raw(Packet::<T>::empty_on_heap());\n\n        let mut inner = self.0.inner.lock();\n        inner\n            .senders\n            .register_with_packet(oper, packet as usize, cx);\n        inner.receivers.notify();\n        inner.receivers.can_select() || inner.is_disconnected\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::try_select":["fn try_select(&self, token: &mut Token) -> bool{\n        self.0.start_send(token)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::unregister":["fn unregister(&self, oper: Operation){\n        if let Some(operation) = self.0.inner.lock().senders.unregister(oper) {\n            unsafe {\n                drop(Box::from_raw(operation.packet as *mut Packet<T>));\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::unwatch":["fn unwatch(&self, oper: Operation){\n        let mut inner = self.0.inner.lock();\n        inner.senders.unwatch(oper);\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::watch":["fn watch(&self, oper: Operation, cx: &Context) -> bool{\n        let mut inner = self.0.inner.lock();\n        inner.senders.watch(oper, cx);\n        inner.receivers.can_select() || inner.is_disconnected\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"<select::Select<'_> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"Select { .. }\")\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<select::Select<'a> as std::clone::Clone>::clone":["fn clone(&self) -> Select<'a>{\n        Select {\n            handles: self.handles.clone(),\n            next_index: self.next_index,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<select::Select<'a> as std::default::Default>::default":["fn default() -> Select<'a>{\n        Select::new()\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<select::Selected as std::convert::From<usize>>::from":["#[inline]\nfn from(val: usize) -> Selected{\n        match val {\n            0 => Selected::Waiting,\n            1 => Selected::Aborted,\n            2 => Selected::Disconnected,\n            oper => Selected::Operation(Operation(oper)),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<select::Selected as std::convert::Into<usize>>::into":["#[inline]\nfn into(self) -> usize{\n        match self {\n            Selected::Waiting => 0,\n            Selected::Aborted => 1,\n            Selected::Disconnected => 2,\n            Selected::Operation(Operation(val)) => val,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<select::SelectedOperation<'_> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"SelectedOperation { .. }\")\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<select::SelectedOperation<'_> as std::ops::Drop>::drop":["fn drop(&mut self){\n        panic!(\"dropped `SelectedOperation` without completing the operation\");\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"<utils::SpinlockGuard<'_, T> as std::ops::Deref>::deref":["fn deref(&self) -> &T{\n        unsafe { &*self.parent.value.get() }\n    }","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))"],"<utils::SpinlockGuard<'_, T> as std::ops::DerefMut>::deref_mut":["fn deref_mut(&mut self) -> &mut T{\n        unsafe { &mut *self.parent.value.get() }\n    }","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))"],"<utils::SpinlockGuard<'_, T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        self.parent.flag.store(false, Ordering::Release);\n    }","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))"],"<waker::SyncWaker as std::ops::Drop>::drop":["#[inline]\nfn drop(&mut self){\n        debug_assert_eq!(self.is_empty.load(Ordering::SeqCst), true);\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"<waker::Waker as std::ops::Drop>::drop":["#[inline]\nfn drop(&mut self){\n        debug_assert_eq!(self.selectors.len(), 0);\n        debug_assert_eq!(self.observers.len(), 0);\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"channel::IntoIter":["/// A blocking iterator over messages in a channel.\n///\n/// Each call to [`next`] blocks waiting for the next message and then returns it. However, if the\n/// channel becomes empty and disconnected, it returns [`None`] without blocking.\n///\n/// [`next`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n/// [`None`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded();\n///\n/// thread::spawn(move || {\n///     s.send(1).unwrap();\n///     s.send(2).unwrap();\n///     s.send(3).unwrap();\n///     drop(s); // Disconnect the channel.\n/// });\n///\n/// // Collect all messages from the channel.\n/// // Note that the call to `collect` blocks until the sender is dropped.\n/// let v: Vec<_> = r.into_iter().collect();\n///\n/// assert_eq!(v, [1, 2, 3]);\n/// ```\npub struct IntoIter<T> {\n    receiver: Receiver<T>,\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Iter":["/// A blocking iterator over messages in a channel.\n///\n/// Each call to [`next`] blocks waiting for the next message and then returns it. However, if the\n/// channel becomes empty and disconnected, it returns [`None`] without blocking.\n///\n/// [`next`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n/// [`None`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded();\n///\n/// thread::spawn(move || {\n///     s.send(1).unwrap();\n///     s.send(2).unwrap();\n///     s.send(3).unwrap();\n///     drop(s); // Disconnect the channel.\n/// });\n///\n/// // Collect all messages from the channel.\n/// // Note that the call to `collect` blocks until the sender is dropped.\n/// let v: Vec<_> = r.iter().collect();\n///\n/// assert_eq!(v, [1, 2, 3]);\n/// ```\npub struct Iter<'a, T> {\n    receiver: &'a Receiver<T>,\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Receiver":["/// The receiving side of a channel.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded();\n///\n/// thread::spawn(move || {\n///     let _ = s.send(1);\n///     thread::sleep(Duration::from_secs(1));\n///     let _ = s.send(2);\n/// });\n///\n/// assert_eq!(r.recv(), Ok(1)); // Received immediately.\n/// assert_eq!(r.recv(), Ok(2)); // Received after 1 second.\n/// ```\npub struct Receiver<T> {\n    flavor: ReceiverFlavor<T>,\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Receiver::<T>::capacity":["/// If the channel is bounded, returns its capacity.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{bounded, unbounded};\n///\n/// let (_, r) = unbounded::<i32>();\n/// assert_eq!(r.capacity(), None);\n///\n/// let (_, r) = bounded::<i32>(5);\n/// assert_eq!(r.capacity(), Some(5));\n///\n/// let (_, r) = bounded::<i32>(0);\n/// assert_eq!(r.capacity(), Some(0));\n/// ```\npub fn capacity(&self) -> Option<usize>{\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.capacity(),\n            ReceiverFlavor::List(chan) => chan.capacity(),\n            ReceiverFlavor::Zero(chan) => chan.capacity(),\n            ReceiverFlavor::After(chan) => chan.capacity(),\n            ReceiverFlavor::Tick(chan) => chan.capacity(),\n            ReceiverFlavor::Never(chan) => chan.capacity(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Receiver::<T>::is_empty":["/// Returns `true` if the channel is empty.\n///\n/// Note: Zero-capacity channels are always empty.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded();\n///\n/// assert!(r.is_empty());\n/// s.send(0).unwrap();\n/// assert!(!r.is_empty());\n/// ```\npub fn is_empty(&self) -> bool{\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.is_empty(),\n            ReceiverFlavor::List(chan) => chan.is_empty(),\n            ReceiverFlavor::Zero(chan) => chan.is_empty(),\n            ReceiverFlavor::After(chan) => chan.is_empty(),\n            ReceiverFlavor::Tick(chan) => chan.is_empty(),\n            ReceiverFlavor::Never(chan) => chan.is_empty(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Receiver::<T>::is_full":["/// Returns `true` if the channel is full.\n///\n/// Note: Zero-capacity channels are always full.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::bounded;\n///\n/// let (s, r) = bounded(1);\n///\n/// assert!(!r.is_full());\n/// s.send(0).unwrap();\n/// assert!(r.is_full());\n/// ```\npub fn is_full(&self) -> bool{\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.is_full(),\n            ReceiverFlavor::List(chan) => chan.is_full(),\n            ReceiverFlavor::Zero(chan) => chan.is_full(),\n            ReceiverFlavor::After(chan) => chan.is_full(),\n            ReceiverFlavor::Tick(chan) => chan.is_full(),\n            ReceiverFlavor::Never(chan) => chan.is_full(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Receiver::<T>::iter":["/// A blocking iterator over messages in the channel.\n///\n/// Each call to [`next`] blocks waiting for the next message and then returns it. However, if\n/// the channel becomes empty and disconnected, it returns [`None`] without blocking.\n///\n/// [`next`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n/// [`None`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded();\n///\n/// thread::spawn(move || {\n///     s.send(1).unwrap();\n///     s.send(2).unwrap();\n///     s.send(3).unwrap();\n///     drop(s); // Disconnect the channel.\n/// });\n///\n/// // Collect all messages from the channel.\n/// // Note that the call to `collect` blocks until the sender is dropped.\n/// let v: Vec<_> = r.iter().collect();\n///\n/// assert_eq!(v, [1, 2, 3]);\n/// ```\npub fn iter(&self) -> Iter<'_, T>{\n        Iter { receiver: self }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Receiver::<T>::len":["/// Returns the number of messages in the channel.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded();\n/// assert_eq!(r.len(), 0);\n///\n/// s.send(1).unwrap();\n/// s.send(2).unwrap();\n/// assert_eq!(r.len(), 2);\n/// ```\npub fn len(&self) -> usize{\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.len(),\n            ReceiverFlavor::List(chan) => chan.len(),\n            ReceiverFlavor::Zero(chan) => chan.len(),\n            ReceiverFlavor::After(chan) => chan.len(),\n            ReceiverFlavor::Tick(chan) => chan.len(),\n            ReceiverFlavor::Never(chan) => chan.len(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Receiver::<T>::recv":["/// Blocks the current thread until a message is received or the channel is empty and\n/// disconnected.\n///\n/// If the channel is empty and not disconnected, this call will block until the receive\n/// operation can proceed. If the channel is empty and becomes disconnected, this call will\n/// wake up and return an error.\n///\n/// If called on a zero-capacity channel, this method will wait for a send operation to appear\n/// on the other side of the channel.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::{unbounded, RecvError};\n///\n/// let (s, r) = unbounded();\n///\n/// thread::spawn(move || {\n///     thread::sleep(Duration::from_secs(1));\n///     s.send(5).unwrap();\n///     drop(s);\n/// });\n///\n/// assert_eq!(r.recv(), Ok(5));\n/// assert_eq!(r.recv(), Err(RecvError));\n/// ```\npub fn recv(&self) -> Result<T, RecvError>{\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.recv(None),\n            ReceiverFlavor::List(chan) => chan.recv(None),\n            ReceiverFlavor::Zero(chan) => chan.recv(None),\n            ReceiverFlavor::After(chan) => {\n                let msg = chan.recv(None);\n                unsafe {\n                    mem::transmute_copy::<\n                        Result<Instant, RecvTimeoutError>,\n                        Result<T, RecvTimeoutError>,\n                    >(&msg)\n                }\n            }\n            ReceiverFlavor::Tick(chan) => {\n                let msg = chan.recv(None);\n                unsafe {\n                    mem::transmute_copy::<\n                        Result<Instant, RecvTimeoutError>,\n                        Result<T, RecvTimeoutError>,\n                    >(&msg)\n                }\n            }\n            ReceiverFlavor::Never(chan) => chan.recv(None),\n        }\n        .map_err(|_| RecvError)\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Receiver::<T>::recv_timeout":["/// Waits for a message to be received from the channel, but only for a limited time.\n///\n/// If the channel is empty and not disconnected, this call will block until the receive\n/// operation can proceed or the operation times out. If the channel is empty and becomes\n/// disconnected, this call will wake up and return an error.\n///\n/// If called on a zero-capacity channel, this method will wait for a send operation to appear\n/// on the other side of the channel.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::{unbounded, RecvTimeoutError};\n///\n/// let (s, r) = unbounded();\n///\n/// thread::spawn(move || {\n///     thread::sleep(Duration::from_secs(1));\n///     s.send(5).unwrap();\n///     drop(s);\n/// });\n///\n/// assert_eq!(\n///     r.recv_timeout(Duration::from_millis(500)),\n///     Err(RecvTimeoutError::Timeout),\n/// );\n/// assert_eq!(\n///     r.recv_timeout(Duration::from_secs(1)),\n///     Ok(5),\n/// );\n/// assert_eq!(\n///     r.recv_timeout(Duration::from_secs(1)),\n///     Err(RecvTimeoutError::Disconnected),\n/// );\n/// ```\npub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError>{\n        let deadline = Instant::now() + timeout;\n\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.recv(Some(deadline)),\n            ReceiverFlavor::List(chan) => chan.recv(Some(deadline)),\n            ReceiverFlavor::Zero(chan) => chan.recv(Some(deadline)),\n            ReceiverFlavor::After(chan) => {\n                let msg = chan.recv(Some(deadline));\n                unsafe {\n                    mem::transmute_copy::<\n                        Result<Instant, RecvTimeoutError>,\n                        Result<T, RecvTimeoutError>,\n                    >(&msg)\n                }\n            }\n            ReceiverFlavor::Tick(chan) => {\n                let msg = chan.recv(Some(deadline));\n                unsafe {\n                    mem::transmute_copy::<\n                        Result<Instant, RecvTimeoutError>,\n                        Result<T, RecvTimeoutError>,\n                    >(&msg)\n                }\n            }\n            ReceiverFlavor::Never(chan) => chan.recv(Some(deadline)),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Receiver::<T>::same_channel":["/// Returns `true` if receivers belong to the same channel.\n///\n/// # Examples\n///\n/// ```rust\n/// use crossbeam_channel::unbounded;\n///\n/// let (_, r) = unbounded::<usize>();\n///\n/// let r2 = r.clone();\n/// assert!(r.same_channel(&r2));\n///\n/// let (_, r3) = unbounded();\n/// assert!(!r.same_channel(&r3));\n/// ```\npub fn same_channel(&self, other: &Receiver<T>) -> bool{\n        match (&self.flavor, &other.flavor) {\n            (ReceiverFlavor::Array(a), ReceiverFlavor::Array(b)) => a == b,\n            (ReceiverFlavor::List(a), ReceiverFlavor::List(b)) => a == b,\n            (ReceiverFlavor::Zero(a), ReceiverFlavor::Zero(b)) => a == b,\n            (ReceiverFlavor::After(a), ReceiverFlavor::After(b)) => Arc::ptr_eq(a, b),\n            (ReceiverFlavor::Tick(a), ReceiverFlavor::Tick(b)) => Arc::ptr_eq(a, b),\n            (ReceiverFlavor::Never(_), ReceiverFlavor::Never(_)) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Receiver::<T>::try_iter":["/// A non-blocking iterator over messages in the channel.\n///\n/// Each call to [`next`] returns a message if there is one ready to be received. The iterator\n/// never blocks waiting for the next message.\n///\n/// [`next`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded::<i32>();\n///\n/// thread::spawn(move || {\n///     s.send(1).unwrap();\n///     thread::sleep(Duration::from_secs(1));\n///     s.send(2).unwrap();\n///     thread::sleep(Duration::from_secs(2));\n///     s.send(3).unwrap();\n/// });\n///\n/// thread::sleep(Duration::from_secs(2));\n///\n/// // Collect all messages from the channel without blocking.\n/// // The third message hasn't been sent yet so we'll collect only the first two.\n/// let v: Vec<_> = r.try_iter().collect();\n///\n/// assert_eq!(v, [1, 2]);\n/// ```\npub fn try_iter(&self) -> TryIter<'_, T>{\n        TryIter { receiver: self }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Receiver::<T>::try_recv":["/// Attempts to receive a message from the channel without blocking.\n///\n/// This method will either receive a message from the channel immediately or return an error\n/// if the channel is empty.\n///\n/// If called on a zero-capacity channel, this method will receive a message only if there\n/// happens to be a send operation on the other side of the channel at the same time.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{unbounded, TryRecvError};\n///\n/// let (s, r) = unbounded();\n/// assert_eq!(r.try_recv(), Err(TryRecvError::Empty));\n///\n/// s.send(5).unwrap();\n/// drop(s);\n///\n/// assert_eq!(r.try_recv(), Ok(5));\n/// assert_eq!(r.try_recv(), Err(TryRecvError::Disconnected));\n/// ```\npub fn try_recv(&self) -> Result<T, TryRecvError>{\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.try_recv(),\n            ReceiverFlavor::List(chan) => chan.try_recv(),\n            ReceiverFlavor::Zero(chan) => chan.try_recv(),\n            ReceiverFlavor::After(chan) => {\n                let msg = chan.try_recv();\n                unsafe {\n                    mem::transmute_copy::<Result<Instant, TryRecvError>, Result<T, TryRecvError>>(\n                        &msg,\n                    )\n                }\n            }\n            ReceiverFlavor::Tick(chan) => {\n                let msg = chan.try_recv();\n                unsafe {\n                    mem::transmute_copy::<Result<Instant, TryRecvError>, Result<T, TryRecvError>>(\n                        &msg,\n                    )\n                }\n            }\n            ReceiverFlavor::Never(chan) => chan.try_recv(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::ReceiverFlavor":["/// Receiver flavors.\nenum ReceiverFlavor<T> {\n    /// Bounded channel based on a preallocated array.\n    Array(counter::Receiver<flavors::array::Channel<T>>),\n\n    /// Unbounded channel implemented as a linked list.\n    List(counter::Receiver<flavors::list::Channel<T>>),\n\n    /// Zero-capacity channel.\n    Zero(counter::Receiver<flavors::zero::Channel<T>>),\n\n    /// The after flavor.\n    After(Arc<flavors::after::Channel>),\n\n    /// The tick flavor.\n    Tick(Arc<flavors::tick::Channel>),\n\n    /// The never flavor.\n    Never(flavors::never::Channel<T>),\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Sender":["/// The sending side of a channel.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use crossbeam_channel::unbounded;\n///\n/// let (s1, r) = unbounded();\n/// let s2 = s1.clone();\n///\n/// thread::spawn(move || s1.send(1).unwrap());\n/// thread::spawn(move || s2.send(2).unwrap());\n///\n/// let msg1 = r.recv().unwrap();\n/// let msg2 = r.recv().unwrap();\n///\n/// assert_eq!(msg1 + msg2, 3);\n/// ```\npub struct Sender<T> {\n    flavor: SenderFlavor<T>,\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Sender::<T>::capacity":["/// If the channel is bounded, returns its capacity.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{bounded, unbounded};\n///\n/// let (s, _) = unbounded::<i32>();\n/// assert_eq!(s.capacity(), None);\n///\n/// let (s, _) = bounded::<i32>(5);\n/// assert_eq!(s.capacity(), Some(5));\n///\n/// let (s, _) = bounded::<i32>(0);\n/// assert_eq!(s.capacity(), Some(0));\n/// ```\npub fn capacity(&self) -> Option<usize>{\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.capacity(),\n            SenderFlavor::List(chan) => chan.capacity(),\n            SenderFlavor::Zero(chan) => chan.capacity(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Sender::<T>::is_empty":["/// Returns `true` if the channel is empty.\n///\n/// Note: Zero-capacity channels are always empty.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded();\n/// assert!(s.is_empty());\n///\n/// s.send(0).unwrap();\n/// assert!(!s.is_empty());\n/// ```\npub fn is_empty(&self) -> bool{\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.is_empty(),\n            SenderFlavor::List(chan) => chan.is_empty(),\n            SenderFlavor::Zero(chan) => chan.is_empty(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Sender::<T>::is_full":["/// Returns `true` if the channel is full.\n///\n/// Note: Zero-capacity channels are always full.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::bounded;\n///\n/// let (s, r) = bounded(1);\n///\n/// assert!(!s.is_full());\n/// s.send(0).unwrap();\n/// assert!(s.is_full());\n/// ```\npub fn is_full(&self) -> bool{\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.is_full(),\n            SenderFlavor::List(chan) => chan.is_full(),\n            SenderFlavor::Zero(chan) => chan.is_full(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Sender::<T>::len":["/// Returns the number of messages in the channel.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded();\n/// assert_eq!(s.len(), 0);\n///\n/// s.send(1).unwrap();\n/// s.send(2).unwrap();\n/// assert_eq!(s.len(), 2);\n/// ```\npub fn len(&self) -> usize{\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.len(),\n            SenderFlavor::List(chan) => chan.len(),\n            SenderFlavor::Zero(chan) => chan.len(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Sender::<T>::same_channel":["/// Returns `true` if senders belong to the same channel.\n///\n/// # Examples\n///\n/// ```rust\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, _) = unbounded::<usize>();\n///\n/// let s2 = s.clone();\n/// assert!(s.same_channel(&s2));\n///\n/// let (s3, _) = unbounded();\n/// assert!(!s.same_channel(&s3));\n/// ```\npub fn same_channel(&self, other: &Sender<T>) -> bool{\n        match (&self.flavor, &other.flavor) {\n            (SenderFlavor::Array(ref a), SenderFlavor::Array(ref b)) => a == b,\n            (SenderFlavor::List(ref a), SenderFlavor::List(ref b)) => a == b,\n            (SenderFlavor::Zero(ref a), SenderFlavor::Zero(ref b)) => a == b,\n            _ => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Sender::<T>::send":["/// Blocks the current thread until a message is sent or the channel is disconnected.\n///\n/// If the channel is full and not disconnected, this call will block until the send operation\n/// can proceed. If the channel becomes disconnected, this call will wake up and return an\n/// error. The returned error contains the original message.\n///\n/// If called on a zero-capacity channel, this method will wait for a receive operation to\n/// appear on the other side of the channel.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::{bounded, SendError};\n///\n/// let (s, r) = bounded(1);\n/// assert_eq!(s.send(1), Ok(()));\n///\n/// thread::spawn(move || {\n///     assert_eq!(r.recv(), Ok(1));\n///     thread::sleep(Duration::from_secs(1));\n///     drop(r);\n/// });\n///\n/// assert_eq!(s.send(2), Ok(()));\n/// assert_eq!(s.send(3), Err(SendError(3)));\n/// ```\npub fn send(&self, msg: T) -> Result<(), SendError<T>>{\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.send(msg, None),\n            SenderFlavor::List(chan) => chan.send(msg, None),\n            SenderFlavor::Zero(chan) => chan.send(msg, None),\n        }\n        .map_err(|err| match err {\n            SendTimeoutError::Disconnected(msg) => SendError(msg),\n            SendTimeoutError::Timeout(_) => unreachable!(),\n        })\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Sender::<T>::send_timeout":["/// Waits for a message to be sent into the channel, but only for a limited time.\n///\n/// If the channel is full and not disconnected, this call will block until the send operation\n/// can proceed or the operation times out. If the channel becomes disconnected, this call will\n/// wake up and return an error. The returned error contains the original message.\n///\n/// If called on a zero-capacity channel, this method will wait for a receive operation to\n/// appear on the other side of the channel.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::{bounded, SendTimeoutError};\n///\n/// let (s, r) = bounded(0);\n///\n/// thread::spawn(move || {\n///     thread::sleep(Duration::from_secs(1));\n///     assert_eq!(r.recv(), Ok(2));\n///     drop(r);\n/// });\n///\n/// assert_eq!(\n///     s.send_timeout(1, Duration::from_millis(500)),\n///     Err(SendTimeoutError::Timeout(1)),\n/// );\n/// assert_eq!(\n///     s.send_timeout(2, Duration::from_secs(1)),\n///     Ok(()),\n/// );\n/// assert_eq!(\n///     s.send_timeout(3, Duration::from_millis(500)),\n///     Err(SendTimeoutError::Disconnected(3)),\n/// );\n/// ```\npub fn send_timeout(&self, msg: T, timeout: Duration) -> Result<(), SendTimeoutError<T>>{\n        let deadline = Instant::now() + timeout;\n\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.send(msg, Some(deadline)),\n            SenderFlavor::List(chan) => chan.send(msg, Some(deadline)),\n            SenderFlavor::Zero(chan) => chan.send(msg, Some(deadline)),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::Sender::<T>::try_send":["/// Attempts to send a message into the channel without blocking.\n///\n/// This method will either send a message into the channel immediately or return an error if\n/// the channel is full or disconnected. The returned error contains the original message.\n///\n/// If called on a zero-capacity channel, this method will send the message only if there\n/// happens to be a receive operation on the other side of the channel at the same time.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{bounded, TrySendError};\n///\n/// let (s, r) = bounded(1);\n///\n/// assert_eq!(s.try_send(1), Ok(()));\n/// assert_eq!(s.try_send(2), Err(TrySendError::Full(2)));\n///\n/// drop(r);\n/// assert_eq!(s.try_send(3), Err(TrySendError::Disconnected(3)));\n/// ```\npub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>>{\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.try_send(msg),\n            SenderFlavor::List(chan) => chan.try_send(msg),\n            SenderFlavor::Zero(chan) => chan.try_send(msg),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::SenderFlavor":["/// Sender flavors.\nenum SenderFlavor<T> {\n    /// Bounded channel based on a preallocated array.\n    Array(counter::Sender<flavors::array::Channel<T>>),\n\n    /// Unbounded channel implemented as a linked list.\n    List(counter::Sender<flavors::list::Channel<T>>),\n\n    /// Zero-capacity channel.\n    Zero(counter::Sender<flavors::zero::Channel<T>>),\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::TryIter":["/// A non-blocking iterator over messages in a channel.\n///\n/// Each call to [`next`] returns a message if there is one ready to be received. The iterator\n/// never blocks waiting for the next message.\n///\n/// [`next`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded::<i32>();\n///\n/// thread::spawn(move || {\n///     s.send(1).unwrap();\n///     thread::sleep(Duration::from_secs(1));\n///     s.send(2).unwrap();\n///     thread::sleep(Duration::from_secs(2));\n///     s.send(3).unwrap();\n/// });\n///\n/// thread::sleep(Duration::from_secs(2));\n///\n/// // Collect all messages from the channel without blocking.\n/// // The third message hasn't been sent yet so we'll collect only the first two.\n/// let v: Vec<_> = r.try_iter().collect();\n///\n/// assert_eq!(v, [1, 2]);\n/// ```\npub struct TryIter<'a, T> {\n    receiver: &'a Receiver<T>,\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::after":["/// Creates a receiver that delivers a message after a certain duration of time.\n///\n/// The channel is bounded with capacity of 1 and never gets disconnected. Exactly one message will\n/// be sent into the channel after `duration` elapses. The message is the instant at which it is\n/// sent.\n///\n/// # Examples\n///\n/// Using an `after` channel for timeouts:\n///\n/// ```\n/// use std::time::Duration;\n/// use crossbeam_channel::{after, select, unbounded};\n///\n/// let (s, r) = unbounded::<i32>();\n/// let timeout = Duration::from_millis(100);\n///\n/// select! {\n///     recv(r) -> msg => println!(\"received {:?}\", msg),\n///     recv(after(timeout)) -> _ => println!(\"timed out\"),\n/// }\n/// ```\n///\n/// When the message gets sent:\n///\n/// ```\n/// use std::thread;\n/// use std::time::{Duration, Instant};\n/// use crossbeam_channel::after;\n///\n/// // Converts a number of milliseconds into a `Duration`.\n/// let ms = |ms| Duration::from_millis(ms);\n///\n/// // Returns `true` if `a` and `b` are very close `Instant`s.\n/// let eq = |a, b| a + ms(50) > b && b + ms(50) > a;\n///\n/// let start = Instant::now();\n/// let r = after(ms(100));\n///\n/// thread::sleep(ms(500));\n///\n/// // This message was sent 100 ms from the start and received 500 ms from the start.\n/// assert!(eq(r.recv().unwrap(), start + ms(100)));\n/// assert!(eq(Instant::now(), start + ms(500)));\n/// ```\npub fn after(duration: Duration) -> Receiver<Instant>{\n    Receiver {\n        flavor: ReceiverFlavor::After(Arc::new(flavors::after::Channel::new(duration))),\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::bounded":["/// Creates a channel of bounded capacity.\n///\n/// This channel has a buffer that can hold at most `cap` messages at a time.\n///\n/// A special case is zero-capacity channel, which cannot hold any messages. Instead, send and\n/// receive operations must appear at the same time in order to pair up and pass the message over.\n///\n/// # Examples\n///\n/// A channel of capacity 1:\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::bounded;\n///\n/// let (s, r) = bounded(1);\n///\n/// // This call returns immediately because there is enough space in the channel.\n/// s.send(1).unwrap();\n///\n/// thread::spawn(move || {\n///     // This call blocks the current thread because the channel is full.\n///     // It will be able to complete only after the first message is received.\n///     s.send(2).unwrap();\n/// });\n///\n/// thread::sleep(Duration::from_secs(1));\n/// assert_eq!(r.recv(), Ok(1));\n/// assert_eq!(r.recv(), Ok(2));\n/// ```\n///\n/// A zero-capacity channel:\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::bounded;\n///\n/// let (s, r) = bounded(0);\n///\n/// thread::spawn(move || {\n///     // This call blocks the current thread until a receive operation appears\n///     // on the other side of the channel.\n///     s.send(1).unwrap();\n/// });\n///\n/// thread::sleep(Duration::from_secs(1));\n/// assert_eq!(r.recv(), Ok(1));\n/// ```\npub fn bounded<T>(cap: usize) -> (Sender<T>, Receiver<T>){\n    if cap == 0 {\n        let (s, r) = counter::new(flavors::zero::Channel::new());\n        let s = Sender {\n            flavor: SenderFlavor::Zero(s),\n        };\n        let r = Receiver {\n            flavor: ReceiverFlavor::Zero(r),\n        };\n        (s, r)\n    } else {\n        let (s, r) = counter::new(flavors::array::Channel::with_capacity(cap));\n        let s = Sender {\n            flavor: SenderFlavor::Array(s),\n        };\n        let r = Receiver {\n            flavor: ReceiverFlavor::Array(r),\n        };\n        (s, r)\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::never":["/// Creates a receiver that never delivers messages.\n///\n/// The channel is bounded with capacity of 0 and never gets disconnected.\n///\n/// # Examples\n///\n/// Using a `never` channel to optionally add a timeout to [`select!`]:\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::{after, select, never, unbounded};\n///\n/// let (s, r) = unbounded();\n///\n/// thread::spawn(move || {\n///     thread::sleep(Duration::from_secs(1));\n///     s.send(1).unwrap();\n/// });\n///\n/// // Suppose this duration can be a `Some` or a `None`.\n/// let duration = Some(Duration::from_millis(100));\n///\n/// // Create a channel that times out after the specified duration.\n/// let timeout = duration\n///     .map(|d| after(d))\n///     .unwrap_or(never());\n///\n/// select! {\n///     recv(r) -> msg => assert_eq!(msg, Ok(1)),\n///     recv(timeout) -> _ => println!(\"timed out\"),\n/// }\n/// ```\n///\n/// [`select!`]: macro.select.html\npub fn never<T>() -> Receiver<T>{\n    Receiver {\n        flavor: ReceiverFlavor::Never(flavors::never::Channel::new()),\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::read":["/// Reads a message from the channel.\npub unsafe fn read<T>(r: &Receiver<T>, token: &mut Token) -> Result<T, ()>{\n    match &r.flavor {\n        ReceiverFlavor::Array(chan) => chan.read(token),\n        ReceiverFlavor::List(chan) => chan.read(token),\n        ReceiverFlavor::Zero(chan) => chan.read(token),\n        ReceiverFlavor::After(chan) => {\n            mem::transmute_copy::<Result<Instant, ()>, Result<T, ()>>(&chan.read(token))\n        }\n        ReceiverFlavor::Tick(chan) => {\n            mem::transmute_copy::<Result<Instant, ()>, Result<T, ()>>(&chan.read(token))\n        }\n        ReceiverFlavor::Never(chan) => chan.read(token),\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::tick":["/// Creates a receiver that delivers messages periodically.\n///\n/// The channel is bounded with capacity of 1 and never gets disconnected. Messages will be\n/// sent into the channel in intervals of `duration`. Each message is the instant at which it is\n/// sent.\n///\n/// # Examples\n///\n/// Using a `tick` channel to periodically print elapsed time:\n///\n/// ```\n/// use std::time::{Duration, Instant};\n/// use crossbeam_channel::tick;\n///\n/// let start = Instant::now();\n/// let ticker = tick(Duration::from_millis(100));\n///\n/// for _ in 0..5 {\n///     ticker.recv().unwrap();\n///     println!(\"elapsed: {:?}\", start.elapsed());\n/// }\n/// ```\n///\n/// When messages get sent:\n///\n/// ```\n/// use std::thread;\n/// use std::time::{Duration, Instant};\n/// use crossbeam_channel::tick;\n///\n/// // Converts a number of milliseconds into a `Duration`.\n/// let ms = |ms| Duration::from_millis(ms);\n///\n/// // Returns `true` if `a` and `b` are very close `Instant`s.\n/// let eq = |a, b| a + ms(50) > b && b + ms(50) > a;\n///\n/// let start = Instant::now();\n/// let r = tick(ms(100));\n///\n/// // This message was sent 100 ms from the start and received 100 ms from the start.\n/// assert!(eq(r.recv().unwrap(), start + ms(100)));\n/// assert!(eq(Instant::now(), start + ms(100)));\n///\n/// thread::sleep(ms(500));\n///\n/// // This message was sent 200 ms from the start and received 600 ms from the start.\n/// assert!(eq(r.recv().unwrap(), start + ms(200)));\n/// assert!(eq(Instant::now(), start + ms(600)));\n///\n/// // This message was sent 700 ms from the start and received 700 ms from the start.\n/// assert!(eq(r.recv().unwrap(), start + ms(700)));\n/// assert!(eq(Instant::now(), start + ms(700)));\n/// ```\npub fn tick(duration: Duration) -> Receiver<Instant>{\n    Receiver {\n        flavor: ReceiverFlavor::Tick(Arc::new(flavors::tick::Channel::new(duration))),\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::unbounded":["/// Creates a channel of unbounded capacity.\n///\n/// This channel has a growable buffer that can hold any number of messages at a time.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded();\n///\n/// // Computes the n-th Fibonacci number.\n/// fn fib(n: i32) -> i32 {\n///     if n <= 1 {\n///         n\n///     } else {\n///         fib(n - 1) + fib(n - 2)\n///     }\n/// }\n///\n/// // Spawn an asynchronous computation.\n/// thread::spawn(move || s.send(fib(20)).unwrap());\n///\n/// // Print the result of the computation.\n/// println!(\"{}\", r.recv().unwrap());\n/// ```\npub fn unbounded<T>() -> (Sender<T>, Receiver<T>){\n    let (s, r) = counter::new(flavors::list::Channel::new());\n    let s = Sender {\n        flavor: SenderFlavor::List(s),\n    };\n    let r = Receiver {\n        flavor: ReceiverFlavor::List(r),\n    };\n    (s, r)\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"channel::write":["/// Writes a message into the channel.\npub unsafe fn write<T>(s: &Sender<T>, token: &mut Token, msg: T) -> Result<(), T>{\n    match &s.flavor {\n        SenderFlavor::Array(chan) => chan.write(token, msg),\n        SenderFlavor::List(chan) => chan.write(token, msg),\n        SenderFlavor::Zero(chan) => chan.write(token, msg),\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))"],"context::Context":["/// Thread-local context used in select.\npub struct Context {\n    inner: Arc<Inner>,\n}","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"context::Context::new":["/// Creates a new `Context`.\n#[cold]\nfn new() -> Context{\n        Context {\n            inner: Arc::new(Inner {\n                select: AtomicUsize::new(Selected::Waiting.into()),\n                packet: AtomicUsize::new(0),\n                thread: thread::current(),\n                thread_id: thread::current().id(),\n            }),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"context::Context::reset":["/// Resets `select` and `packet`.\n#[inline]\nfn reset(&self){\n        self.inner\n            .select\n            .store(Selected::Waiting.into(), Ordering::Release);\n        self.inner.packet.store(0, Ordering::Release);\n    }","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"context::Context::selected":["/// Returns the selected operation.\n#[inline]\npub fn selected(&self) -> Selected{\n        Selected::from(self.inner.select.load(Ordering::Acquire))\n    }","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"context::Context::store_packet":["/// Stores a packet.\n///\n/// This method must be called after `try_select` succeeds and there is a packet to provide.\n#[inline]\npub fn store_packet(&self, packet: usize){\n        if packet != 0 {\n            self.inner.packet.store(packet, Ordering::Release);\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"context::Context::thread_id":["/// Returns the id of the thread this context belongs to.\n#[inline]\npub fn thread_id(&self) -> ThreadId{\n        self.inner.thread_id\n    }","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"context::Context::try_select":["/// Attempts to select an operation.\n///\n/// On failure, the previously selected operation is returned.\n#[inline]\npub fn try_select(&self, select: Selected) -> Result<(), Selected>{\n        self.inner\n            .select\n            .compare_exchange(\n                Selected::Waiting.into(),\n                select.into(),\n                Ordering::AcqRel,\n                Ordering::Acquire,\n            )\n            .map(|_| ())\n            .map_err(|e| e.into())\n    }","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"context::Context::unpark":["/// Unparks the thread this context belongs to.\n#[inline]\npub fn unpark(&self){\n        self.inner.thread.unpark();\n    }","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"context::Context::wait_packet":["/// Waits until a packet is provided and returns it.\n#[inline]\npub fn wait_packet(&self) -> usize{\n        let backoff = Backoff::new();\n        loop {\n            let packet = self.inner.packet.load(Ordering::Acquire);\n            if packet != 0 {\n                return packet;\n            }\n            backoff.snooze();\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"context::Context::wait_until":["/// Waits until an operation is selected and returns it.\n///\n/// If the deadline is reached, `Selected::Aborted` will be selected.\n#[inline]\npub fn wait_until(&self, deadline: Option<Instant>) -> Selected{\n        // Spin for a short time, waiting until an operation is selected.\n        let backoff = Backoff::new();\n        loop {\n            let sel = Selected::from(self.inner.select.load(Ordering::Acquire));\n            if sel != Selected::Waiting {\n                return sel;\n            }\n\n            if backoff.is_completed() {\n                break;\n            } else {\n                backoff.snooze();\n            }\n        }\n\n        loop {\n            // Check whether an operation has been selected.\n            let sel = Selected::from(self.inner.select.load(Ordering::Acquire));\n            if sel != Selected::Waiting {\n                return sel;\n            }\n\n            // If there's a deadline, park the current thread until the deadline is reached.\n            if let Some(end) = deadline {\n                let now = Instant::now();\n\n                if now < end {\n                    thread::park_timeout(end - now);\n                } else {\n                    // The deadline has been reached. Try aborting select.\n                    return match self.try_select(Selected::Aborted) {\n                        Ok(()) => Selected::Aborted,\n                        Err(s) => s,\n                    };\n                }\n            } else {\n                thread::park();\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"context::Context::with":["/// Creates a new context for the duration of the closure.\n#[inline]\npub fn with<F, R>(f: F) -> R\n    where\n        F: FnOnce(&Context) -> R,{\n        thread_local! {\n            /// Cached thread-local context.\n            static CONTEXT: Cell<Option<Context>> = Cell::new(Some(Context::new()));\n        }\n\n        let mut f = Some(f);\n        let mut f = move |cx: &Context| -> R {\n            let f = f.take().unwrap();\n            f(cx)\n        };\n\n        CONTEXT\n            .try_with(|cell| match cell.take() {\n                None => f(&Context::new()),\n                Some(cx) => {\n                    cx.reset();\n                    let res = f(&cx);\n                    cell.set(Some(cx));\n                    res\n                }\n            })\n            .unwrap_or_else(|_| f(&Context::new()))\n    }","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"context::Context::with::CONTEXT::__getit":["inline\nunsafe fn __getit(\n                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n            ) -> $crate::option::Option<&'static $t>{\n                #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                    $crate::thread::__StaticLocalKeyInner::new();\n\n                #[thread_local]\n                #[cfg(all(\n                    target_thread_local,\n                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n                    $crate::thread::__FastLocalKeyInner::new();\n\n                #[cfg(all(\n                    not(target_thread_local),\n                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                    $crate::thread::__OsLocalKeyInner::new();\n\n                // FIXME: remove the #[allow(...)] marker when macros don't\n                // raise warning for missing/extraneous unsafe blocks anymore.\n                // See https://github.com/rust-lang/rust/issues/74838.\n                #[allow(unused_unsafe)]\n                unsafe {\n                    __KEY.get(move || {\n                        if let $crate::option::Option::Some(init) = init {\n                            if let $crate::option::Option::Some(value) = init.take() {\n                                return value;\n                            } else if $crate::cfg!(debug_assertions) {\n                                $crate::unreachable!(\"missing default value\");\n                            }\n                        }\n                        __init()\n                    })\n                }\n            }","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })"],"context::Context::with::CONTEXT::__init":["#[inline]\nfn __init() -> $t{ $init }","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })"],"context::Inner":["/// Inner representation of `Context`.\nstruct Inner {\n    /// Selected operation.\n    select: AtomicUsize,\n\n    /// A slot into which another thread may store a pointer to its `Packet`.\n    packet: AtomicUsize,\n\n    /// Thread handle.\n    thread: Thread,\n\n    /// Thread id.\n    thread_id: ThreadId,\n}","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))"],"counter::Counter":["/// Reference counter internals.\nstruct Counter<C> {\n    /// The number of senders associated with the channel.\n    senders: AtomicUsize,\n\n    /// The number of receivers associated with the channel.\n    receivers: AtomicUsize,\n\n    /// Set to `true` if the last sender or the last receiver reference deallocates the channel.\n    destroy: AtomicBool,\n\n    /// The internal channel.\n    chan: C,\n}","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"counter::Receiver":["/// The receiving side.\npub struct Receiver<C> {\n    counter: *mut Counter<C>,\n}","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"counter::Receiver::<C>::acquire":["/// Acquires another receiver reference.\npub fn acquire(&self) -> Receiver<C>{\n        let count = self.counter().receivers.fetch_add(1, Ordering::Relaxed);\n\n        // Cloning receivers and calling `mem::forget` on the clones could potentially overflow the\n        // counter. It's very difficult to recover sensibly from such degenerate scenarios so we\n        // just abort when the count becomes very large.\n        if count > isize::MAX as usize {\n            process::abort();\n        }\n\n        Receiver {\n            counter: self.counter,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"counter::Receiver::<C>::counter":["/// Returns the internal `Counter`.\nfn counter(&self) -> &Counter<C>{\n        unsafe { &*self.counter }\n    }","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"counter::Receiver::<C>::release":["/// Releases the receiver reference.\n///\n/// Function `disconnect` will be called if this is the last receiver reference.\npub unsafe fn release<F: FnOnce(&C) -> bool>(&self, disconnect: F){\n        if self.counter().receivers.fetch_sub(1, Ordering::AcqRel) == 1 {\n            disconnect(&self.counter().chan);\n\n            if self.counter().destroy.swap(true, Ordering::AcqRel) {\n                drop(Box::from_raw(self.counter));\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"counter::Sender":["/// The sending side.\npub struct Sender<C> {\n    counter: *mut Counter<C>,\n}","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"counter::Sender::<C>::acquire":["/// Acquires another sender reference.\npub fn acquire(&self) -> Sender<C>{\n        let count = self.counter().senders.fetch_add(1, Ordering::Relaxed);\n\n        // Cloning senders and calling `mem::forget` on the clones could potentially overflow the\n        // counter. It's very difficult to recover sensibly from such degenerate scenarios so we\n        // just abort when the count becomes very large.\n        if count > isize::MAX as usize {\n            process::abort();\n        }\n\n        Sender {\n            counter: self.counter,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"counter::Sender::<C>::counter":["/// Returns the internal `Counter`.\nfn counter(&self) -> &Counter<C>{\n        unsafe { &*self.counter }\n    }","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"counter::Sender::<C>::release":["/// Releases the sender reference.\n///\n/// Function `disconnect` will be called if this is the last sender reference.\npub unsafe fn release<F: FnOnce(&C) -> bool>(&self, disconnect: F){\n        if self.counter().senders.fetch_sub(1, Ordering::AcqRel) == 1 {\n            disconnect(&self.counter().chan);\n\n            if self.counter().destroy.swap(true, Ordering::AcqRel) {\n                drop(Box::from_raw(self.counter));\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"counter::new":["/// Wraps a channel into the reference counter.\npub fn new<C>(chan: C) -> (Sender<C>, Receiver<C>){\n    let counter = Box::into_raw(Box::new(Counter {\n        senders: AtomicUsize::new(1),\n        receivers: AtomicUsize::new(1),\n        destroy: AtomicBool::new(false),\n        chan,\n    }));\n    let s = Sender { counter };\n    let r = Receiver { counter };\n    (s, r)\n}","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))"],"err::ReadyTimeoutError":["/// An error returned from the [`ready_timeout`] method.\n///\n/// Failed because none of the channel operations became ready before the timeout.\n///\n/// [`ready_timeout`]: struct.Select.html#method.ready_timeout\npub struct ReadyTimeoutError;","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::RecvError":["/// An error returned from the [`recv`] method.\n///\n/// A message could not be received because the channel is empty and disconnected.\n///\n/// [`recv`]: struct.Receiver.html#method.recv\npub struct RecvError;","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::RecvTimeoutError":["/// An error returned from the [`recv_timeout`] method.\n///\n/// [`recv_timeout`]: struct.Receiver.html#method.recv_timeout\npub enum RecvTimeoutError {\n    /// A message could not be received because the channel is empty and the operation timed out.\n    ///\n    /// If this is a zero-capacity channel, then the error indicates that there was no sender\n    /// available to send a message and the operation timed out.\n    Timeout,\n\n    /// The message could not be received because the channel is empty and disconnected.\n    Disconnected,\n}","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::RecvTimeoutError::is_disconnected":["/// Returns `true` if the receive operation failed because the channel is disconnected.\n#[allow(clippy::trivially_copy_pass_by_ref)]\npub fn is_disconnected(&self) -> bool{\n        match self {\n            RecvTimeoutError::Disconnected => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::RecvTimeoutError::is_timeout":["/// Returns `true` if the receive operation timed out.\n#[allow(clippy::trivially_copy_pass_by_ref)]\npub fn is_timeout(&self) -> bool{\n        match self {\n            RecvTimeoutError::Timeout => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::SelectTimeoutError":["/// An error returned from the [`select_timeout`] method.\n///\n/// Failed because none of the channel operations became ready before the timeout.\n///\n/// [`select_timeout`]: struct.Select.html#method.select_timeout\npub struct SelectTimeoutError;","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::SendError":["/// An error returned from the [`send`] method.\n///\n/// The message could not be sent because the channel is disconnected.\n///\n/// The error contains the message so it can be recovered.\n///\n/// [`send`]: struct.Sender.html#method.send\npub struct SendError<T>(pub T);","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::SendError::<T>::into_inner":["/// Unwraps the message.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded();\n/// drop(r);\n///\n/// if let Err(err) = s.send(\"foo\") {\n///     assert_eq!(err.into_inner(), \"foo\");\n/// }\n/// ```\npub fn into_inner(self) -> T{\n        self.0\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::SendTimeoutError":["/// An error returned from the [`send_timeout`] method.\n///\n/// The error contains the message being sent so it can be recovered.\n///\n/// [`send_timeout`]: struct.Sender.html#method.send_timeout\npub enum SendTimeoutError<T> {\n    /// The message could not be sent because the channel is full and the operation timed out.\n    ///\n    /// If this is a zero-capacity channel, then the error indicates that there was no receiver\n    /// available to receive the message and the operation timed out.\n    Timeout(T),\n\n    /// The message could not be sent because the channel is disconnected.\n    Disconnected(T),\n}","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::SendTimeoutError::<T>::into_inner":["/// Unwraps the message.\n///\n/// # Examples\n///\n/// ```\n/// use std::time::Duration;\n/// use crossbeam_channel::unbounded;\n///\n/// let (s, r) = unbounded();\n///\n/// if let Err(err) = s.send_timeout(\"foo\", Duration::from_secs(1)) {\n///     assert_eq!(err.into_inner(), \"foo\");\n/// }\n/// ```\npub fn into_inner(self) -> T{\n        match self {\n            SendTimeoutError::Timeout(v) => v,\n            SendTimeoutError::Disconnected(v) => v,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::SendTimeoutError::<T>::is_disconnected":["/// Returns `true` if the send operation failed because the channel is disconnected.\npub fn is_disconnected(&self) -> bool{\n        match self {\n            SendTimeoutError::Disconnected(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::SendTimeoutError::<T>::is_timeout":["/// Returns `true` if the send operation timed out.\npub fn is_timeout(&self) -> bool{\n        match self {\n            SendTimeoutError::Timeout(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::TryReadyError":["/// An error returned from the [`try_ready`] method.\n///\n/// Failed because none of the channel operations were ready.\n///\n/// [`try_ready`]: struct.Select.html#method.try_ready\npub struct TryReadyError;","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::TryRecvError":["/// An error returned from the [`try_recv`] method.\n///\n/// [`try_recv`]: struct.Receiver.html#method.recv\npub enum TryRecvError {\n    /// A message could not be received because the channel is empty.\n    ///\n    /// If this is a zero-capacity channel, then the error indicates that there was no sender\n    /// available to send a message at the time.\n    Empty,\n\n    /// The message could not be received because the channel is empty and disconnected.\n    Disconnected,\n}","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::TryRecvError::is_disconnected":["/// Returns `true` if the receive operation failed because the channel is disconnected.\n#[allow(clippy::trivially_copy_pass_by_ref)]\npub fn is_disconnected(&self) -> bool{\n        match self {\n            TryRecvError::Disconnected => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::TryRecvError::is_empty":["/// Returns `true` if the receive operation failed because the channel is empty.\n#[allow(clippy::trivially_copy_pass_by_ref)]\npub fn is_empty(&self) -> bool{\n        match self {\n            TryRecvError::Empty => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::TrySelectError":["/// An error returned from the [`try_select`] method.\n///\n/// Failed because none of the channel operations were ready.\n///\n/// [`try_select`]: struct.Select.html#method.try_select\npub struct TrySelectError;","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::TrySendError":["/// An error returned from the [`try_send`] method.\n///\n/// The error contains the message being sent so it can be recovered.\n///\n/// [`try_send`]: struct.Sender.html#method.try_send\npub enum TrySendError<T> {\n    /// The message could not be sent because the channel is full.\n    ///\n    /// If this is a zero-capacity channel, then the error indicates that there was no receiver\n    /// available to receive the message at the time.\n    Full(T),\n\n    /// The message could not be sent because the channel is disconnected.\n    Disconnected(T),\n}","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::TrySendError::<T>::into_inner":["/// Unwraps the message.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::bounded;\n///\n/// let (s, r) = bounded(0);\n///\n/// if let Err(err) = s.try_send(\"foo\") {\n///     assert_eq!(err.into_inner(), \"foo\");\n/// }\n/// ```\npub fn into_inner(self) -> T{\n        match self {\n            TrySendError::Full(v) => v,\n            TrySendError::Disconnected(v) => v,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::TrySendError::<T>::is_disconnected":["/// Returns `true` if the send operation failed because the channel is disconnected.\npub fn is_disconnected(&self) -> bool{\n        match self {\n            TrySendError::Disconnected(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"err::TrySendError::<T>::is_full":["/// Returns `true` if the send operation failed because the channel is full.\npub fn is_full(&self) -> bool{\n        match self {\n            TrySendError::Full(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))"],"flavors::after::Channel":["/// Channel that delivers a message after a certain amount of time.\npub struct Channel {\n    /// The instant at which the message will be delivered.\n    delivery_time: Instant,\n\n    /// `true` if the message has been received.\n    received: AtomicBool,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"flavors::after::Channel::capacity":["/// Returns the capacity of the channel.\n#[inline]\npub fn capacity(&self) -> Option<usize>{\n        Some(1)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"flavors::after::Channel::is_empty":["/// Returns `true` if the channel is empty.\n#[inline]\npub fn is_empty(&self) -> bool{\n        // We use relaxed ordering because this is just an optional optimistic check.\n        if self.received.load(Ordering::Relaxed) {\n            return true;\n        }\n\n        // If the delivery time hasn't been reached yet, the channel is empty.\n        if Instant::now() < self.delivery_time {\n            return true;\n        }\n\n        // The delivery time has been reached. The channel is empty only if the message has already\n        // been received.\n        self.received.load(Ordering::SeqCst)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"flavors::after::Channel::is_full":["/// Returns `true` if the channel is full.\n#[inline]\npub fn is_full(&self) -> bool{\n        !self.is_empty()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"flavors::after::Channel::len":["/// Returns the number of messages in the channel.\n#[inline]\npub fn len(&self) -> usize{\n        if self.is_empty() {\n            0\n        } else {\n            1\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"flavors::after::Channel::new":["/// Creates a channel that delivers a message after a certain duration of time.\n#[inline]\npub fn new(dur: Duration) -> Self{\n        Channel {\n            delivery_time: Instant::now() + dur,\n            received: AtomicBool::new(false),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"flavors::after::Channel::read":["/// Reads a message from the channel.\n#[inline]\npub unsafe fn read(&self, token: &mut Token) -> Result<Instant, ()>{\n        token.after.ok_or(())\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"flavors::after::Channel::recv":["/// Receives a message from the channel.\n#[inline]\npub fn recv(&self, deadline: Option<Instant>) -> Result<Instant, RecvTimeoutError>{\n        // We use relaxed ordering because this is just an optional optimistic check.\n        if self.received.load(Ordering::Relaxed) {\n            // The message has already been received.\n            utils::sleep_until(deadline);\n            return Err(RecvTimeoutError::Timeout);\n        }\n\n        // Wait until the message is received or the deadline is reached.\n        loop {\n            let now = Instant::now();\n\n            // Check if we can receive the next message.\n            if now >= self.delivery_time {\n                break;\n            }\n\n            // Check if the deadline has been reached.\n            if let Some(d) = deadline {\n                if now >= d {\n                    return Err(RecvTimeoutError::Timeout);\n                }\n\n                thread::sleep(self.delivery_time.min(d) - now);\n            } else {\n                thread::sleep(self.delivery_time - now);\n            }\n        }\n\n        // Try receiving the message if it is still available.\n        if !self.received.swap(true, Ordering::SeqCst) {\n            // Success! Return the message, which is the instant at which it was delivered.\n            Ok(self.delivery_time)\n        } else {\n            // The message was already received. Block forever.\n            utils::sleep_until(None);\n            unreachable!()\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"flavors::after::Channel::try_recv":["/// Attempts to receive a message without blocking.\n#[inline]\npub fn try_recv(&self) -> Result<Instant, TryRecvError>{\n        // We use relaxed ordering because this is just an optional optimistic check.\n        if self.received.load(Ordering::Relaxed) {\n            // The message has already been received.\n            return Err(TryRecvError::Empty);\n        }\n\n        if Instant::now() < self.delivery_time {\n            // The message was not delivered yet.\n            return Err(TryRecvError::Empty);\n        }\n\n        // Try receiving the message if it is still available.\n        if !self.received.swap(true, Ordering::SeqCst) {\n            // Success! Return delivery time as the message.\n            Ok(self.delivery_time)\n        } else {\n            // The message was already received.\n            Err(TryRecvError::Empty)\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))"],"flavors::array::ArrayToken":["/// The token type for the array flavor.\npub struct ArrayToken {\n    /// Slot to read from or write to.\n    slot: *const u8,\n\n    /// Stamp to store into the slot after reading or writing.\n    stamp: usize,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel":["/// Bounded channel based on a preallocated array.\npub struct Channel<T> {\n    /// The head of the channel.\n    ///\n    /// This value is a \"stamp\" consisting of an index into the buffer, a mark bit, and a lap, but\n    /// packed into a single `usize`. The lower bits represent the index, while the upper bits\n    /// represent the lap. The mark bit in the head is always zero.\n    ///\n    /// Messages are popped from the head of the channel.\n    head: CachePadded<AtomicUsize>,\n\n    /// The tail of the channel.\n    ///\n    /// This value is a \"stamp\" consisting of an index into the buffer, a mark bit, and a lap, but\n    /// packed into a single `usize`. The lower bits represent the index, while the upper bits\n    /// represent the lap. The mark bit indicates that the channel is disconnected.\n    ///\n    /// Messages are pushed into the tail of the channel.\n    tail: CachePadded<AtomicUsize>,\n\n    /// The buffer holding slots.\n    buffer: *mut Slot<T>,\n\n    /// The channel capacity.\n    cap: usize,\n\n    /// A stamp with the value of `{ lap: 1, mark: 0, index: 0 }`.\n    one_lap: usize,\n\n    /// If this bit is set in the tail, that means the channel is disconnected.\n    mark_bit: usize,\n\n    /// Senders waiting while the channel is full.\n    senders: SyncWaker,\n\n    /// Receivers waiting while the channel is empty and not disconnected.\n    receivers: SyncWaker,\n\n    /// Indicates that dropping a `Channel<T>` may drop values of type `T`.\n    _marker: PhantomData<T>,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::capacity":["/// Returns the capacity of the channel.\npub fn capacity(&self) -> Option<usize>{\n        Some(self.cap)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::disconnect":["/// Disconnects the channel and wakes up all blocked senders and receivers.\n///\n/// Returns `true` if this call disconnected the channel.\npub fn disconnect(&self) -> bool{\n        let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n\n        if tail & self.mark_bit == 0 {\n            self.senders.disconnect();\n            self.receivers.disconnect();\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::is_disconnected":["/// Returns `true` if the channel is disconnected.\npub fn is_disconnected(&self) -> bool{\n        self.tail.load(Ordering::SeqCst) & self.mark_bit != 0\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::is_empty":["/// Returns `true` if the channel is empty.\npub fn is_empty(&self) -> bool{\n        let head = self.head.load(Ordering::SeqCst);\n        let tail = self.tail.load(Ordering::SeqCst);\n\n        // Is the tail equal to the head?\n        //\n        // Note: If the head changes just before we load the tail, that means there was a moment\n        // when the channel was not empty, so it is safe to just return `false`.\n        (tail & !self.mark_bit) == head\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::is_full":["/// Returns `true` if the channel is full.\npub fn is_full(&self) -> bool{\n        let tail = self.tail.load(Ordering::SeqCst);\n        let head = self.head.load(Ordering::SeqCst);\n\n        // Is the head lagging one lap behind tail?\n        //\n        // Note: If the tail changes just before we load the head, that means there was a moment\n        // when the channel was not full, so it is safe to just return `false`.\n        head.wrapping_add(self.one_lap) == tail & !self.mark_bit\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::len":["/// Returns the current number of messages inside the channel.\npub fn len(&self) -> usize{\n        loop {\n            // Load the tail, then load the head.\n            let tail = self.tail.load(Ordering::SeqCst);\n            let head = self.head.load(Ordering::SeqCst);\n\n            // If the tail didn't change, we've got consistent values to work with.\n            if self.tail.load(Ordering::SeqCst) == tail {\n                let hix = head & (self.mark_bit - 1);\n                let tix = tail & (self.mark_bit - 1);\n\n                return if hix < tix {\n                    tix - hix\n                } else if hix > tix {\n                    self.cap - hix + tix\n                } else if (tail & !self.mark_bit) == head {\n                    0\n                } else {\n                    self.cap\n                };\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::read":["/// Reads a message from the channel.\npub unsafe fn read(&self, token: &mut Token) -> Result<T, ()>{\n        if token.array.slot.is_null() {\n            // The channel is disconnected.\n            return Err(());\n        }\n\n        let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n\n        // Read the message from the slot and update the stamp.\n        let msg = slot.msg.get().read().assume_init();\n        slot.stamp.store(token.array.stamp, Ordering::Release);\n\n        // Wake a sleeping sender.\n        self.senders.notify();\n        Ok(msg)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::receiver":["/// Returns a receiver handle to the channel.\npub fn receiver(&self) -> Receiver<'_, T>{\n        Receiver(self)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::recv":["/// Receives a message from the channel.\npub fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError>{\n        let token = &mut Token::default();\n        loop {\n            // Try receiving a message several times.\n            let backoff = Backoff::new();\n            loop {\n                if self.start_recv(token) {\n                    let res = unsafe { self.read(token) };\n                    return res.map_err(|_| RecvTimeoutError::Disconnected);\n                }\n\n                if backoff.is_completed() {\n                    break;\n                } else {\n                    backoff.snooze();\n                }\n            }\n\n            if let Some(d) = deadline {\n                if Instant::now() >= d {\n                    return Err(RecvTimeoutError::Timeout);\n                }\n            }\n\n            Context::with(|cx| {\n                // Prepare for blocking until a sender wakes us up.\n                let oper = Operation::hook(token);\n                self.receivers.register(oper, cx);\n\n                // Has the channel become ready just now?\n                if !self.is_empty() || self.is_disconnected() {\n                    let _ = cx.try_select(Selected::Aborted);\n                }\n\n                // Block the current thread.\n                let sel = cx.wait_until(deadline);\n\n                match sel {\n                    Selected::Waiting => unreachable!(),\n                    Selected::Aborted | Selected::Disconnected => {\n                        self.receivers.unregister(oper).unwrap();\n                        // If the channel was disconnected, we still have to check for remaining\n                        // messages.\n                    }\n                    Selected::Operation(_) => {}\n                }\n            });\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::send":["/// Sends a message into the channel.\npub fn send(&self, msg: T, deadline: Option<Instant>) -> Result<(), SendTimeoutError<T>>{\n        let token = &mut Token::default();\n        loop {\n            // Try sending a message several times.\n            let backoff = Backoff::new();\n            loop {\n                if self.start_send(token) {\n                    let res = unsafe { self.write(token, msg) };\n                    return res.map_err(SendTimeoutError::Disconnected);\n                }\n\n                if backoff.is_completed() {\n                    break;\n                } else {\n                    backoff.snooze();\n                }\n            }\n\n            if let Some(d) = deadline {\n                if Instant::now() >= d {\n                    return Err(SendTimeoutError::Timeout(msg));\n                }\n            }\n\n            Context::with(|cx| {\n                // Prepare for blocking until a receiver wakes us up.\n                let oper = Operation::hook(token);\n                self.senders.register(oper, cx);\n\n                // Has the channel become ready just now?\n                if !self.is_full() || self.is_disconnected() {\n                    let _ = cx.try_select(Selected::Aborted);\n                }\n\n                // Block the current thread.\n                let sel = cx.wait_until(deadline);\n\n                match sel {\n                    Selected::Waiting => unreachable!(),\n                    Selected::Aborted | Selected::Disconnected => {\n                        self.senders.unregister(oper).unwrap();\n                    }\n                    Selected::Operation(_) => {}\n                }\n            });\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::sender":["/// Returns a sender handle to the channel.\npub fn sender(&self) -> Sender<'_, T>{\n        Sender(self)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::start_recv":["/// Attempts to reserve a slot for receiving a message.\nfn start_recv(&self, token: &mut Token) -> bool{\n        let backoff = Backoff::new();\n        let mut head = self.head.load(Ordering::Relaxed);\n\n        loop {\n            // Deconstruct the head.\n            let index = head & (self.mark_bit - 1);\n            let lap = head & !(self.one_lap - 1);\n\n            // Inspect the corresponding slot.\n            let slot = unsafe { &*self.buffer.add(index) };\n            let stamp = slot.stamp.load(Ordering::Acquire);\n\n            // If the the stamp is ahead of the head by 1, we may attempt to pop.\n            if head + 1 == stamp {\n                let new = if index + 1 < self.cap {\n                    // Same lap, incremented index.\n                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n                    head + 1\n                } else {\n                    // One lap forward, index wraps around to zero.\n                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n                    lap.wrapping_add(self.one_lap)\n                };\n\n                // Try moving the head.\n                match self.head.compare_exchange_weak(\n                    head,\n                    new,\n                    Ordering::SeqCst,\n                    Ordering::Relaxed,\n                ) {\n                    Ok(_) => {\n                        // Prepare the token for the follow-up call to `read`.\n                        token.array.slot = slot as *const Slot<T> as *const u8;\n                        token.array.stamp = head.wrapping_add(self.one_lap);\n                        return true;\n                    }\n                    Err(h) => {\n                        head = h;\n                        backoff.spin();\n                    }\n                }\n            } else if stamp == head {\n                atomic::fence(Ordering::SeqCst);\n                let tail = self.tail.load(Ordering::Relaxed);\n\n                // If the tail equals the head, that means the channel is empty.\n                if (tail & !self.mark_bit) == head {\n                    // If the channel is disconnected...\n                    if tail & self.mark_bit != 0 {\n                        // ...then receive an error.\n                        token.array.slot = ptr::null();\n                        token.array.stamp = 0;\n                        return true;\n                    } else {\n                        // Otherwise, the receive operation is not ready.\n                        return false;\n                    }\n                }\n\n                backoff.spin();\n                head = self.head.load(Ordering::Relaxed);\n            } else {\n                // Snooze because we need to wait for the stamp to get updated.\n                backoff.snooze();\n                head = self.head.load(Ordering::Relaxed);\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::start_send":["/// Attempts to reserve a slot for sending a message.\nfn start_send(&self, token: &mut Token) -> bool{\n        let backoff = Backoff::new();\n        let mut tail = self.tail.load(Ordering::Relaxed);\n\n        loop {\n            // Check if the channel is disconnected.\n            if tail & self.mark_bit != 0 {\n                token.array.slot = ptr::null();\n                token.array.stamp = 0;\n                return true;\n            }\n\n            // Deconstruct the tail.\n            let index = tail & (self.mark_bit - 1);\n            let lap = tail & !(self.one_lap - 1);\n\n            // Inspect the corresponding slot.\n            let slot = unsafe { &*self.buffer.add(index) };\n            let stamp = slot.stamp.load(Ordering::Acquire);\n\n            // If the tail and the stamp match, we may attempt to push.\n            if tail == stamp {\n                let new_tail = if index + 1 < self.cap {\n                    // Same lap, incremented index.\n                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n                    tail + 1\n                } else {\n                    // One lap forward, index wraps around to zero.\n                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n                    lap.wrapping_add(self.one_lap)\n                };\n\n                // Try moving the tail.\n                match self.tail.compare_exchange_weak(\n                    tail,\n                    new_tail,\n                    Ordering::SeqCst,\n                    Ordering::Relaxed,\n                ) {\n                    Ok(_) => {\n                        // Prepare the token for the follow-up call to `write`.\n                        token.array.slot = slot as *const Slot<T> as *const u8;\n                        token.array.stamp = tail + 1;\n                        return true;\n                    }\n                    Err(t) => {\n                        tail = t;\n                        backoff.spin();\n                    }\n                }\n            } else if stamp.wrapping_add(self.one_lap) == tail + 1 {\n                atomic::fence(Ordering::SeqCst);\n                let head = self.head.load(Ordering::Relaxed);\n\n                // If the head lags one lap behind the tail as well...\n                if head.wrapping_add(self.one_lap) == tail {\n                    // ...then the channel is full.\n                    return false;\n                }\n\n                backoff.spin();\n                tail = self.tail.load(Ordering::Relaxed);\n            } else {\n                // Snooze because we need to wait for the stamp to get updated.\n                backoff.snooze();\n                tail = self.tail.load(Ordering::Relaxed);\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::try_recv":["/// Attempts to receive a message without blocking.\npub fn try_recv(&self) -> Result<T, TryRecvError>{\n        let token = &mut Token::default();\n\n        if self.start_recv(token) {\n            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n        } else {\n            Err(TryRecvError::Empty)\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::try_send":["/// Attempts to send a message into the channel.\npub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>>{\n        let token = &mut Token::default();\n        if self.start_send(token) {\n            unsafe { self.write(token, msg).map_err(TrySendError::Disconnected) }\n        } else {\n            Err(TrySendError::Full(msg))\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::with_capacity":["/// Creates a bounded channel of capacity `cap`.\npub fn with_capacity(cap: usize) -> Self{\n        assert!(cap > 0, \"capacity must be positive\");\n\n        // Compute constants `mark_bit` and `one_lap`.\n        let mark_bit = (cap + 1).next_power_of_two();\n        let one_lap = mark_bit * 2;\n\n        // Head is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n        let head = 0;\n        // Tail is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n        let tail = 0;\n\n        // Allocate a buffer of `cap` slots initialized\n        // with stamps.\n        let buffer = {\n            let mut v: Vec<Slot<T>> = (0..cap)\n                .map(|i| {\n                    // Set the stamp to `{ lap: 0, mark: 0, index: i }`.\n                    Slot {\n                        stamp: AtomicUsize::new(i),\n                        msg: UnsafeCell::new(MaybeUninit::uninit()),\n                    }\n                })\n                .collect();\n            let ptr = v.as_mut_ptr();\n            mem::forget(v);\n            ptr\n        };\n\n        Channel {\n            buffer,\n            cap,\n            one_lap,\n            mark_bit,\n            head: CachePadded::new(AtomicUsize::new(head)),\n            tail: CachePadded::new(AtomicUsize::new(tail)),\n            senders: SyncWaker::new(),\n            receivers: SyncWaker::new(),\n            _marker: PhantomData,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Channel::<T>::write":["/// Writes a message into the channel.\npub unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T>{\n        // If there is no slot, the channel is disconnected.\n        if token.array.slot.is_null() {\n            return Err(msg);\n        }\n\n        let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n\n        // Write the message into the slot and update the stamp.\n        slot.msg.get().write(MaybeUninit::new(msg));\n        slot.stamp.store(token.array.stamp, Ordering::Release);\n\n        // Wake a sleeping receiver.\n        self.receivers.notify();\n        Ok(())\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Receiver":["/// Receiver handle to a channel.\npub struct Receiver<'a, T>(&'a Channel<T>);","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Sender":["/// Sender handle to a channel.\npub struct Sender<'a, T>(&'a Channel<T>);","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::array::Slot":["/// A slot in a channel.\nstruct Slot<T> {\n    /// The current stamp.\n    stamp: AtomicUsize,\n\n    /// The message in this slot.\n    msg: UnsafeCell<MaybeUninit<T>>,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))"],"flavors::list::Block":["/// A block in a linked list.\n///\n/// Each block in the list can hold up to `BLOCK_CAP` messages.\nstruct Block<T> {\n    /// The next block in the linked list.\n    next: AtomicPtr<Block<T>>,\n\n    /// Slots for messages.\n    slots: [Slot<T>; BLOCK_CAP],\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Block::<T>::destroy":["/// Sets the `DESTROY` bit in slots starting from `start` and destroys the block.\nunsafe fn destroy(this: *mut Block<T>, start: usize){\n        // It is not necessary to set the `DESTROY` bit in the last slot because that slot has\n        // begun destruction of the block.\n        for i in start..BLOCK_CAP - 1 {\n            let slot = (*this).slots.get_unchecked(i);\n\n            // Mark the `DESTROY` bit if a thread is still using the slot.\n            if slot.state.load(Ordering::Acquire) & READ == 0\n                && slot.state.fetch_or(DESTROY, Ordering::AcqRel) & READ == 0\n            {\n                // If a thread is still using the slot, it will continue destruction of the block.\n                return;\n            }\n        }\n\n        // No thread is using the block, now it is safe to destroy it.\n        drop(Box::from_raw(this));\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Block::<T>::new":["/// Creates an empty block.\nfn new() -> Block<T>{\n        // SAFETY: This is safe because:\n        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n        //  [3] `Slot::msg` (UnsafeCell) may be safely zero initialized because it\n        //       holds a MaybeUninit.\n        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n        unsafe { MaybeUninit::zeroed().assume_init() }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Block::<T>::wait_next":["/// Waits until the next pointer is set.\nfn wait_next(&self) -> *mut Block<T>{\n        let backoff = Backoff::new();\n        loop {\n            let next = self.next.load(Ordering::Acquire);\n            if !next.is_null() {\n                return next;\n            }\n            backoff.snooze();\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel":["/// Unbounded channel implemented as a linked list.\n///\n/// Each message sent into the channel is assigned a sequence number, i.e. an index. Indices are\n/// represented as numbers of type `usize` and wrap on overflow.\n///\n/// Consecutive messages are grouped into blocks in order to put less pressure on the allocator and\n/// improve cache efficiency.\npub struct Channel<T> {\n    /// The head of the channel.\n    head: CachePadded<Position<T>>,\n\n    /// The tail of the channel.\n    tail: CachePadded<Position<T>>,\n\n    /// Receivers waiting while the channel is empty and not disconnected.\n    receivers: SyncWaker,\n\n    /// Indicates that dropping a `Channel<T>` may drop messages of type `T`.\n    _marker: PhantomData<T>,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::capacity":["/// Returns the capacity of the channel.\npub fn capacity(&self) -> Option<usize>{\n        None\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::disconnect":["/// Disconnects the channel and wakes up all blocked receivers.\n///\n/// Returns `true` if this call disconnected the channel.\npub fn disconnect(&self) -> bool{\n        let tail = self.tail.index.fetch_or(MARK_BIT, Ordering::SeqCst);\n\n        if tail & MARK_BIT == 0 {\n            self.receivers.disconnect();\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::is_disconnected":["/// Returns `true` if the channel is disconnected.\npub fn is_disconnected(&self) -> bool{\n        self.tail.index.load(Ordering::SeqCst) & MARK_BIT != 0\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::is_empty":["/// Returns `true` if the channel is empty.\npub fn is_empty(&self) -> bool{\n        let head = self.head.index.load(Ordering::SeqCst);\n        let tail = self.tail.index.load(Ordering::SeqCst);\n        head >> SHIFT == tail >> SHIFT\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::is_full":["/// Returns `true` if the channel is full.\npub fn is_full(&self) -> bool{\n        false\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::len":["/// Returns the current number of messages inside the channel.\npub fn len(&self) -> usize{\n        loop {\n            // Load the tail index, then load the head index.\n            let mut tail = self.tail.index.load(Ordering::SeqCst);\n            let mut head = self.head.index.load(Ordering::SeqCst);\n\n            // If the tail index didn't change, we've got consistent indices to work with.\n            if self.tail.index.load(Ordering::SeqCst) == tail {\n                // Erase the lower bits.\n                tail &= !((1 << SHIFT) - 1);\n                head &= !((1 << SHIFT) - 1);\n\n                // Fix up indices if they fall onto block ends.\n                if (tail >> SHIFT) & (LAP - 1) == LAP - 1 {\n                    tail = tail.wrapping_add(1 << SHIFT);\n                }\n                if (head >> SHIFT) & (LAP - 1) == LAP - 1 {\n                    head = head.wrapping_add(1 << SHIFT);\n                }\n\n                // Rotate indices so that head falls into the first block.\n                let lap = (head >> SHIFT) / LAP;\n                tail = tail.wrapping_sub((lap * LAP) << SHIFT);\n                head = head.wrapping_sub((lap * LAP) << SHIFT);\n\n                // Remove the lower bits.\n                tail >>= SHIFT;\n                head >>= SHIFT;\n\n                // Return the difference minus the number of blocks between tail and head.\n                return tail - head - tail / LAP;\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::new":["/// Creates a new unbounded channel.\npub fn new() -> Self{\n        Channel {\n            head: CachePadded::new(Position {\n                block: AtomicPtr::new(ptr::null_mut()),\n                index: AtomicUsize::new(0),\n            }),\n            tail: CachePadded::new(Position {\n                block: AtomicPtr::new(ptr::null_mut()),\n                index: AtomicUsize::new(0),\n            }),\n            receivers: SyncWaker::new(),\n            _marker: PhantomData,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::read":["/// Reads a message from the channel.\npub unsafe fn read(&self, token: &mut Token) -> Result<T, ()>{\n        if token.list.block.is_null() {\n            // The channel is disconnected.\n            return Err(());\n        }\n\n        // Read the message.\n        let block = token.list.block as *mut Block<T>;\n        let offset = token.list.offset;\n        let slot = (*block).slots.get_unchecked(offset);\n        slot.wait_write();\n        let msg = slot.msg.get().read().assume_init();\n\n        // Destroy the block if we've reached the end, or if another thread wanted to destroy but\n        // couldn't because we were busy reading from the slot.\n        if offset + 1 == BLOCK_CAP {\n            Block::destroy(block, 0);\n        } else if slot.state.fetch_or(READ, Ordering::AcqRel) & DESTROY != 0 {\n            Block::destroy(block, offset + 1);\n        }\n\n        Ok(msg)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::receiver":["/// Returns a receiver handle to the channel.\npub fn receiver(&self) -> Receiver<'_, T>{\n        Receiver(self)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::recv":["/// Receives a message from the channel.\npub fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError>{\n        let token = &mut Token::default();\n        loop {\n            // Try receiving a message several times.\n            let backoff = Backoff::new();\n            loop {\n                if self.start_recv(token) {\n                    unsafe {\n                        return self.read(token).map_err(|_| RecvTimeoutError::Disconnected);\n                    }\n                }\n\n                if backoff.is_completed() {\n                    break;\n                } else {\n                    backoff.snooze();\n                }\n            }\n\n            if let Some(d) = deadline {\n                if Instant::now() >= d {\n                    return Err(RecvTimeoutError::Timeout);\n                }\n            }\n\n            // Prepare for blocking until a sender wakes us up.\n            Context::with(|cx| {\n                let oper = Operation::hook(token);\n                self.receivers.register(oper, cx);\n\n                // Has the channel become ready just now?\n                if !self.is_empty() || self.is_disconnected() {\n                    let _ = cx.try_select(Selected::Aborted);\n                }\n\n                // Block the current thread.\n                let sel = cx.wait_until(deadline);\n\n                match sel {\n                    Selected::Waiting => unreachable!(),\n                    Selected::Aborted | Selected::Disconnected => {\n                        self.receivers.unregister(oper).unwrap();\n                        // If the channel was disconnected, we still have to check for remaining\n                        // messages.\n                    }\n                    Selected::Operation(_) => {}\n                }\n            });\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::send":["/// Sends a message into the channel.\npub fn send(&self, msg: T, _deadline: Option<Instant>) -> Result<(), SendTimeoutError<T>>{\n        let token = &mut Token::default();\n        assert!(self.start_send(token));\n        unsafe {\n            self.write(token, msg)\n                .map_err(SendTimeoutError::Disconnected)\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::sender":["/// Returns a sender handle to the channel.\npub fn sender(&self) -> Sender<'_, T>{\n        Sender(self)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::start_recv":["/// Attempts to reserve a slot for receiving a message.\nfn start_recv(&self, token: &mut Token) -> bool{\n        let backoff = Backoff::new();\n        let mut head = self.head.index.load(Ordering::Acquire);\n        let mut block = self.head.block.load(Ordering::Acquire);\n\n        loop {\n            // Calculate the offset of the index into the block.\n            let offset = (head >> SHIFT) % LAP;\n\n            // If we reached the end of the block, wait until the next one is installed.\n            if offset == BLOCK_CAP {\n                backoff.snooze();\n                head = self.head.index.load(Ordering::Acquire);\n                block = self.head.block.load(Ordering::Acquire);\n                continue;\n            }\n\n            let mut new_head = head + (1 << SHIFT);\n\n            if new_head & MARK_BIT == 0 {\n                atomic::fence(Ordering::SeqCst);\n                let tail = self.tail.index.load(Ordering::Relaxed);\n\n                // If the tail equals the head, that means the channel is empty.\n                if head >> SHIFT == tail >> SHIFT {\n                    // If the channel is disconnected...\n                    if tail & MARK_BIT != 0 {\n                        // ...then receive an error.\n                        token.list.block = ptr::null();\n                        return true;\n                    } else {\n                        // Otherwise, the receive operation is not ready.\n                        return false;\n                    }\n                }\n\n                // If head and tail are not in the same block, set `MARK_BIT` in head.\n                if (head >> SHIFT) / LAP != (tail >> SHIFT) / LAP {\n                    new_head |= MARK_BIT;\n                }\n            }\n\n            // The block can be null here only if the first message is being sent into the channel.\n            // In that case, just wait until it gets initialized.\n            if block.is_null() {\n                backoff.snooze();\n                head = self.head.index.load(Ordering::Acquire);\n                block = self.head.block.load(Ordering::Acquire);\n                continue;\n            }\n\n            // Try moving the head index forward.\n            match self.head.index.compare_exchange_weak(\n                head,\n                new_head,\n                Ordering::SeqCst,\n                Ordering::Acquire,\n            ) {\n                Ok(_) => unsafe {\n                    // If we've reached the end of the block, move to the next one.\n                    if offset + 1 == BLOCK_CAP {\n                        let next = (*block).wait_next();\n                        let mut next_index = (new_head & !MARK_BIT).wrapping_add(1 << SHIFT);\n                        if !(*next).next.load(Ordering::Relaxed).is_null() {\n                            next_index |= MARK_BIT;\n                        }\n\n                        self.head.block.store(next, Ordering::Release);\n                        self.head.index.store(next_index, Ordering::Release);\n                    }\n\n                    token.list.block = block as *const u8;\n                    token.list.offset = offset;\n                    return true;\n                },\n                Err(h) => {\n                    head = h;\n                    block = self.head.block.load(Ordering::Acquire);\n                    backoff.spin();\n                }\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::start_send":["/// Attempts to reserve a slot for sending a message.\nfn start_send(&self, token: &mut Token) -> bool{\n        let backoff = Backoff::new();\n        let mut tail = self.tail.index.load(Ordering::Acquire);\n        let mut block = self.tail.block.load(Ordering::Acquire);\n        let mut next_block = None;\n\n        loop {\n            // Check if the channel is disconnected.\n            if tail & MARK_BIT != 0 {\n                token.list.block = ptr::null();\n                return true;\n            }\n\n            // Calculate the offset of the index into the block.\n            let offset = (tail >> SHIFT) % LAP;\n\n            // If we reached the end of the block, wait until the next one is installed.\n            if offset == BLOCK_CAP {\n                backoff.snooze();\n                tail = self.tail.index.load(Ordering::Acquire);\n                block = self.tail.block.load(Ordering::Acquire);\n                continue;\n            }\n\n            // If we're going to have to install the next block, allocate it in advance in order to\n            // make the wait for other threads as short as possible.\n            if offset + 1 == BLOCK_CAP && next_block.is_none() {\n                next_block = Some(Box::new(Block::<T>::new()));\n            }\n\n            // If this is the first message to be sent into the channel, we need to allocate the\n            // first block and install it.\n            if block.is_null() {\n                let new = Box::into_raw(Box::new(Block::<T>::new()));\n\n                if self\n                    .tail\n                    .block\n                    .compare_and_swap(block, new, Ordering::Release)\n                    == block\n                {\n                    self.head.block.store(new, Ordering::Release);\n                    block = new;\n                } else {\n                    next_block = unsafe { Some(Box::from_raw(new)) };\n                    tail = self.tail.index.load(Ordering::Acquire);\n                    block = self.tail.block.load(Ordering::Acquire);\n                    continue;\n                }\n            }\n\n            let new_tail = tail + (1 << SHIFT);\n\n            // Try advancing the tail forward.\n            match self.tail.index.compare_exchange_weak(\n                tail,\n                new_tail,\n                Ordering::SeqCst,\n                Ordering::Acquire,\n            ) {\n                Ok(_) => unsafe {\n                    // If we've reached the end of the block, install the next one.\n                    if offset + 1 == BLOCK_CAP {\n                        let next_block = Box::into_raw(next_block.unwrap());\n                        self.tail.block.store(next_block, Ordering::Release);\n                        self.tail.index.fetch_add(1 << SHIFT, Ordering::Release);\n                        (*block).next.store(next_block, Ordering::Release);\n                    }\n\n                    token.list.block = block as *const u8;\n                    token.list.offset = offset;\n                    return true;\n                },\n                Err(t) => {\n                    tail = t;\n                    block = self.tail.block.load(Ordering::Acquire);\n                    backoff.spin();\n                }\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::try_recv":["/// Attempts to receive a message without blocking.\npub fn try_recv(&self) -> Result<T, TryRecvError>{\n        let token = &mut Token::default();\n\n        if self.start_recv(token) {\n            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n        } else {\n            Err(TryRecvError::Empty)\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::try_send":["/// Attempts to send a message into the channel.\npub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>>{\n        self.send(msg, None).map_err(|err| match err {\n            SendTimeoutError::Disconnected(msg) => TrySendError::Disconnected(msg),\n            SendTimeoutError::Timeout(_) => unreachable!(),\n        })\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Channel::<T>::write":["/// Writes a message into the channel.\npub unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T>{\n        // If there is no slot, the channel is disconnected.\n        if token.list.block.is_null() {\n            return Err(msg);\n        }\n\n        // Write the message into the slot.\n        let block = token.list.block as *mut Block<T>;\n        let offset = token.list.offset;\n        let slot = (*block).slots.get_unchecked(offset);\n        slot.msg.get().write(MaybeUninit::new(msg));\n        slot.state.fetch_or(WRITE, Ordering::Release);\n\n        // Wake a sleeping receiver.\n        self.receivers.notify();\n        Ok(())\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::ListToken":["/// The token type for the list flavor.\npub struct ListToken {\n    /// The block of slots.\n    block: *const u8,\n\n    /// The offset into the block.\n    offset: usize,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Position":["/// A position in a channel.\nstruct Position<T> {\n    /// The index in the channel.\n    index: AtomicUsize,\n\n    /// The block in the linked list.\n    block: AtomicPtr<Block<T>>,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Receiver":["/// Receiver handle to a channel.\npub struct Receiver<'a, T>(&'a Channel<T>);","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Sender":["/// Sender handle to a channel.\npub struct Sender<'a, T>(&'a Channel<T>);","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Slot":["/// A slot in a block.\nstruct Slot<T> {\n    /// The message.\n    msg: UnsafeCell<MaybeUninit<T>>,\n\n    /// The state of the slot.\n    state: AtomicUsize,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::list::Slot::<T>::wait_write":["/// Waits until a message is written into the slot.\nfn wait_write(&self){\n        let backoff = Backoff::new();\n        while self.state.load(Ordering::Acquire) & WRITE == 0 {\n            backoff.snooze();\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))"],"flavors::never::Channel":["/// Channel that never delivers messages.\npub struct Channel<T> {\n    _marker: PhantomData<T>,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"flavors::never::Channel::<T>::capacity":["/// Returns the capacity of the channel.\n#[inline]\npub fn capacity(&self) -> Option<usize>{\n        Some(0)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"flavors::never::Channel::<T>::is_empty":["/// Returns `true` if the channel is empty.\n#[inline]\npub fn is_empty(&self) -> bool{\n        true\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"flavors::never::Channel::<T>::is_full":["/// Returns `true` if the channel is full.\n#[inline]\npub fn is_full(&self) -> bool{\n        true\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"flavors::never::Channel::<T>::len":["/// Returns the number of messages in the channel.\n#[inline]\npub fn len(&self) -> usize{\n        0\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"flavors::never::Channel::<T>::new":["/// Creates a channel that never delivers messages.\n#[inline]\npub fn new() -> Self{\n        Channel {\n            _marker: PhantomData,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"flavors::never::Channel::<T>::read":["/// Reads a message from the channel.\n#[inline]\npub unsafe fn read(&self, _token: &mut Token) -> Result<T, ()>{\n        Err(())\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"flavors::never::Channel::<T>::recv":["/// Receives a message from the channel.\n#[inline]\npub fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError>{\n        utils::sleep_until(deadline);\n        Err(RecvTimeoutError::Timeout)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"flavors::never::Channel::<T>::try_recv":["/// Attempts to receive a message without blocking.\n#[inline]\npub fn try_recv(&self) -> Result<T, TryRecvError>{\n        Err(TryRecvError::Empty)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))"],"flavors::tick::Channel":["/// Channel that delivers messages periodically.\npub struct Channel {\n    /// The instant at which the next message will be delivered.\n    delivery_time: AtomicCell<Instant>,\n\n    /// The time interval in which messages get delivered.\n    duration: Duration,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"flavors::tick::Channel::capacity":["/// Returns the capacity of the channel.\n#[inline]\npub fn capacity(&self) -> Option<usize>{\n        Some(1)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"flavors::tick::Channel::is_empty":["/// Returns `true` if the channel is empty.\n#[inline]\npub fn is_empty(&self) -> bool{\n        Instant::now() < self.delivery_time.load()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"flavors::tick::Channel::is_full":["/// Returns `true` if the channel is full.\n#[inline]\npub fn is_full(&self) -> bool{\n        !self.is_empty()\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"flavors::tick::Channel::len":["/// Returns the number of messages in the channel.\n#[inline]\npub fn len(&self) -> usize{\n        if self.is_empty() {\n            0\n        } else {\n            1\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"flavors::tick::Channel::new":["/// Creates a channel that delivers messages periodically.\n#[inline]\npub fn new(dur: Duration) -> Self{\n        Channel {\n            delivery_time: AtomicCell::new(Instant::now() + dur),\n            duration: dur,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"flavors::tick::Channel::read":["/// Reads a message from the channel.\n#[inline]\npub unsafe fn read(&self, token: &mut Token) -> Result<Instant, ()>{\n        token.tick.ok_or(())\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"flavors::tick::Channel::recv":["/// Receives a message from the channel.\n#[inline]\npub fn recv(&self, deadline: Option<Instant>) -> Result<Instant, RecvTimeoutError>{\n        loop {\n            let delivery_time = self.delivery_time.load();\n            let now = Instant::now();\n\n            if let Some(d) = deadline {\n                if d < delivery_time {\n                    if now < d {\n                        thread::sleep(d - now);\n                    }\n                    return Err(RecvTimeoutError::Timeout);\n                }\n            }\n\n            if self\n                .delivery_time\n                .compare_exchange(delivery_time, delivery_time.max(now) + self.duration)\n                .is_ok()\n            {\n                if now < delivery_time {\n                    thread::sleep(delivery_time - now);\n                }\n                return Ok(delivery_time);\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"flavors::tick::Channel::try_recv":["/// Attempts to receive a message without blocking.\n#[inline]\npub fn try_recv(&self) -> Result<Instant, TryRecvError>{\n        loop {\n            let now = Instant::now();\n            let delivery_time = self.delivery_time.load();\n\n            if now < delivery_time {\n                return Err(TryRecvError::Empty);\n            }\n\n            if self\n                .delivery_time\n                .compare_exchange(delivery_time, now + self.duration)\n                .is_ok()\n            {\n                return Ok(delivery_time);\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))"],"flavors::zero::Channel":["/// Zero-capacity channel.\npub struct Channel<T> {\n    /// Inner representation of the channel.\n    inner: Spinlock<Inner>,\n\n    /// Indicates that dropping a `Channel<T>` may drop values of type `T`.\n    _marker: PhantomData<T>,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::capacity":["/// Returns the capacity of the channel.\npub fn capacity(&self) -> Option<usize>{\n        Some(0)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::disconnect":["/// Disconnects the channel and wakes up all blocked senders and receivers.\n///\n/// Returns `true` if this call disconnected the channel.\npub fn disconnect(&self) -> bool{\n        let mut inner = self.inner.lock();\n\n        if !inner.is_disconnected {\n            inner.is_disconnected = true;\n            inner.senders.disconnect();\n            inner.receivers.disconnect();\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::is_empty":["/// Returns `true` if the channel is empty.\npub fn is_empty(&self) -> bool{\n        true\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::is_full":["/// Returns `true` if the channel is full.\npub fn is_full(&self) -> bool{\n        true\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::len":["/// Returns the current number of messages inside the channel.\npub fn len(&self) -> usize{\n        0\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::new":["/// Constructs a new zero-capacity channel.\npub fn new() -> Self{\n        Channel {\n            inner: Spinlock::new(Inner {\n                senders: Waker::new(),\n                receivers: Waker::new(),\n                is_disconnected: false,\n            }),\n            _marker: PhantomData,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::read":["/// Reads a message from the packet.\npub unsafe fn read(&self, token: &mut Token) -> Result<T, ()>{\n        // If there is no packet, the channel is disconnected.\n        if token.zero == 0 {\n            return Err(());\n        }\n\n        let packet = &*(token.zero as *const Packet<T>);\n\n        if packet.on_stack {\n            // The message has been in the packet from the beginning, so there is no need to wait\n            // for it. However, after reading the message, we need to set `ready` to `true` in\n            // order to signal that the packet can be destroyed.\n            let msg = packet.msg.get().replace(None).unwrap();\n            packet.ready.store(true, Ordering::Release);\n            Ok(msg)\n        } else {\n            // Wait until the message becomes available, then read it and destroy the\n            // heap-allocated packet.\n            packet.wait_ready();\n            let msg = packet.msg.get().replace(None).unwrap();\n            drop(Box::from_raw(packet as *const Packet<T> as *mut Packet<T>));\n            Ok(msg)\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::receiver":["/// Returns a receiver handle to the channel.\npub fn receiver(&self) -> Receiver<'_, T>{\n        Receiver(self)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::recv":["/// Receives a message from the channel.\npub fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError>{\n        let token = &mut Token::default();\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting sender, pair up with it.\n        if let Some(operation) = inner.senders.try_select() {\n            token.zero = operation.packet;\n            drop(inner);\n            unsafe {\n                return self.read(token).map_err(|_| RecvTimeoutError::Disconnected);\n            }\n        }\n\n        if inner.is_disconnected {\n            return Err(RecvTimeoutError::Disconnected);\n        }\n\n        Context::with(|cx| {\n            // Prepare for blocking until a sender wakes us up.\n            let oper = Operation::hook(token);\n            let packet = Packet::<T>::empty_on_stack();\n            inner\n                .receivers\n                .register_with_packet(oper, &packet as *const Packet<T> as usize, cx);\n            inner.senders.notify();\n            drop(inner);\n\n            // Block the current thread.\n            let sel = cx.wait_until(deadline);\n\n            match sel {\n                Selected::Waiting => unreachable!(),\n                Selected::Aborted => {\n                    self.inner.lock().receivers.unregister(oper).unwrap();\n                    Err(RecvTimeoutError::Timeout)\n                }\n                Selected::Disconnected => {\n                    self.inner.lock().receivers.unregister(oper).unwrap();\n                    Err(RecvTimeoutError::Disconnected)\n                }\n                Selected::Operation(_) => {\n                    // Wait until the message is provided, then read it.\n                    packet.wait_ready();\n                    unsafe { Ok(packet.msg.get().replace(None).unwrap()) }\n                }\n            }\n        })\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::send":["/// Sends a message into the channel.\npub fn send(&self, msg: T, deadline: Option<Instant>) -> Result<(), SendTimeoutError<T>>{\n        let token = &mut Token::default();\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting receiver, pair up with it.\n        if let Some(operation) = inner.receivers.try_select() {\n            token.zero = operation.packet;\n            drop(inner);\n            unsafe {\n                self.write(token, msg).ok().unwrap();\n            }\n            return Ok(());\n        }\n\n        if inner.is_disconnected {\n            return Err(SendTimeoutError::Disconnected(msg));\n        }\n\n        Context::with(|cx| {\n            // Prepare for blocking until a receiver wakes us up.\n            let oper = Operation::hook(token);\n            let packet = Packet::<T>::message_on_stack(msg);\n            inner\n                .senders\n                .register_with_packet(oper, &packet as *const Packet<T> as usize, cx);\n            inner.receivers.notify();\n            drop(inner);\n\n            // Block the current thread.\n            let sel = cx.wait_until(deadline);\n\n            match sel {\n                Selected::Waiting => unreachable!(),\n                Selected::Aborted => {\n                    self.inner.lock().senders.unregister(oper).unwrap();\n                    let msg = unsafe { packet.msg.get().replace(None).unwrap() };\n                    Err(SendTimeoutError::Timeout(msg))\n                }\n                Selected::Disconnected => {\n                    self.inner.lock().senders.unregister(oper).unwrap();\n                    let msg = unsafe { packet.msg.get().replace(None).unwrap() };\n                    Err(SendTimeoutError::Disconnected(msg))\n                }\n                Selected::Operation(_) => {\n                    // Wait until the message is read, then drop the packet.\n                    packet.wait_ready();\n                    Ok(())\n                }\n            }\n        })\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::sender":["/// Returns a sender handle to the channel.\npub fn sender(&self) -> Sender<'_, T>{\n        Sender(self)\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::start_recv":["/// Attempts to pair up with a sender.\nfn start_recv(&self, token: &mut Token) -> bool{\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting sender, pair up with it.\n        if let Some(operation) = inner.senders.try_select() {\n            token.zero = operation.packet;\n            true\n        } else if inner.is_disconnected {\n            token.zero = 0;\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::start_send":["/// Attempts to reserve a slot for sending a message.\nfn start_send(&self, token: &mut Token) -> bool{\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting receiver, pair up with it.\n        if let Some(operation) = inner.receivers.try_select() {\n            token.zero = operation.packet;\n            true\n        } else if inner.is_disconnected {\n            token.zero = 0;\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::try_recv":["/// Attempts to receive a message without blocking.\npub fn try_recv(&self) -> Result<T, TryRecvError>{\n        let token = &mut Token::default();\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting sender, pair up with it.\n        if let Some(operation) = inner.senders.try_select() {\n            token.zero = operation.packet;\n            drop(inner);\n            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n        } else if inner.is_disconnected {\n            Err(TryRecvError::Disconnected)\n        } else {\n            Err(TryRecvError::Empty)\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::try_send":["/// Attempts to send a message into the channel.\npub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>>{\n        let token = &mut Token::default();\n        let mut inner = self.inner.lock();\n\n        // If there's a waiting receiver, pair up with it.\n        if let Some(operation) = inner.receivers.try_select() {\n            token.zero = operation.packet;\n            drop(inner);\n            unsafe {\n                self.write(token, msg).ok().unwrap();\n            }\n            Ok(())\n        } else if inner.is_disconnected {\n            Err(TrySendError::Disconnected(msg))\n        } else {\n            Err(TrySendError::Full(msg))\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Channel::<T>::write":["/// Writes a message into the packet.\npub unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T>{\n        // If there is no packet, the channel is disconnected.\n        if token.zero == 0 {\n            return Err(msg);\n        }\n\n        let packet = &*(token.zero as *const Packet<T>);\n        packet.msg.get().write(Some(msg));\n        packet.ready.store(true, Ordering::Release);\n        Ok(())\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Inner":["/// Inner representation of a zero-capacity channel.\nstruct Inner {\n    /// Senders waiting to pair up with a receive operation.\n    senders: Waker,\n\n    /// Receivers waiting to pair up with a send operation.\n    receivers: Waker,\n\n    /// Equals `true` when the channel is disconnected.\n    is_disconnected: bool,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Packet":["/// A slot for passing one message from a sender to a receiver.\nstruct Packet<T> {\n    /// Equals `true` if the packet is allocated on the stack.\n    on_stack: bool,\n\n    /// Equals `true` once the packet is ready for reading or writing.\n    ready: AtomicBool,\n\n    /// The message.\n    msg: UnsafeCell<Option<T>>,\n}","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Packet::<T>::empty_on_heap":["/// Creates an empty packet on the heap.\nfn empty_on_heap() -> Box<Packet<T>>{\n        Box::new(Packet {\n            on_stack: false,\n            ready: AtomicBool::new(false),\n            msg: UnsafeCell::new(None),\n        })\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Packet::<T>::empty_on_stack":["/// Creates an empty packet on the stack.\nfn empty_on_stack() -> Packet<T>{\n        Packet {\n            on_stack: true,\n            ready: AtomicBool::new(false),\n            msg: UnsafeCell::new(None),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Packet::<T>::message_on_stack":["/// Creates a packet on the stack, containing a message.\nfn message_on_stack(msg: T) -> Packet<T>{\n        Packet {\n            on_stack: true,\n            ready: AtomicBool::new(false),\n            msg: UnsafeCell::new(Some(msg)),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Packet::<T>::wait_ready":["/// Waits until the packet becomes ready for reading or writing.\nfn wait_ready(&self){\n        let backoff = Backoff::new();\n        while !self.ready.load(Ordering::Acquire) {\n            backoff.snooze();\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Receiver":["/// Receiver handle to a channel.\npub struct Receiver<'a, T>(&'a Channel<T>);","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"flavors::zero::Sender":["/// Sender handle to a channel.\npub struct Sender<'a, T>(&'a Channel<T>);","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))"],"select::Operation":["/// Identifier associated with an operation by a specific thread on a specific channel.\npub struct Operation(usize);","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Operation::hook":["/// Creates an operation identifier from a mutable reference.\n///\n/// This function essentially just turns the address of the reference into a number. The\n/// reference should point to a variable that is specific to the thread and the operation,\n/// and is alive for the entire duration of select or blocking operation.\n#[inline]\npub fn hook<T>(r: &mut T) -> Operation{\n        let val = r as *mut T as usize;\n        // Make sure that the pointer address doesn't equal the numerical representation of\n        // `Selected::{Waiting, Aborted, Disconnected}`.\n        assert!(val > 2);\n        Operation(val)\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Select":["/// Selects from a set of channel operations.\n///\n/// `Select` allows you to define a set of channel operations, wait until any one of them becomes\n/// ready, and finally execute it. If multiple operations are ready at the same time, a random one\n/// among them is selected.\n///\n/// An operation is considered to be ready if it doesn't have to block. Note that it is ready even\n/// when it will simply return an error because the channel is disconnected.\n///\n/// The [`select!`] macro is a convenience wrapper around `Select`. However, it cannot select over a\n/// dynamically created list of channel operations.\n///\n/// Once a list of operations has been built with `Select`, there are two different ways of\n/// proceeding:\n///\n/// * Select an operation with [`try_select`], [`select`], or [`select_timeout`]. If successful,\n///   the returned selected operation has already begun and **must** be completed. If we don't\n///   complete it, a panic will occur.\n///\n/// * Wait for an operation to become ready with [`try_ready`], [`ready`], or [`ready_timeout`]. If\n///   successful, we may attempt to execute the operation, but are not obliged to. In fact, it's\n///   possible for another thread to make the operation not ready just before we try executing it,\n///   so it's wise to use a retry loop. However, note that these methods might return with success\n///   spuriously, so it's a good idea to always double check if the operation is really ready.\n///\n/// # Examples\n///\n/// Use [`select`] to receive a message from a list of receivers:\n///\n/// ```\n/// use crossbeam_channel::{Receiver, RecvError, Select};\n///\n/// fn recv_multiple<T>(rs: &[Receiver<T>]) -> Result<T, RecvError> {\n///     // Build a list of operations.\n///     let mut sel = Select::new();\n///     for r in rs {\n///         sel.recv(r);\n///     }\n///\n///     // Complete the selected operation.\n///     let oper = sel.select();\n///     let index = oper.index();\n///     oper.recv(&rs[index])\n/// }\n/// ```\n///\n/// Use [`ready`] to receive a message from a list of receivers:\n///\n/// ```\n/// use crossbeam_channel::{Receiver, RecvError, Select};\n///\n/// fn recv_multiple<T>(rs: &[Receiver<T>]) -> Result<T, RecvError> {\n///     // Build a list of operations.\n///     let mut sel = Select::new();\n///     for r in rs {\n///         sel.recv(r);\n///     }\n///\n///     loop {\n///         // Wait until a receive operation becomes ready and try executing it.\n///         let index = sel.ready();\n///         let res = rs[index].try_recv();\n///\n///         // If the operation turns out not to be ready, retry.\n///         if let Err(e) = res {\n///             if e.is_empty() {\n///                 continue;\n///             }\n///         }\n///\n///         // Success!\n///         return res.map_err(|_| RecvError);\n///     }\n/// }\n/// ```\n///\n/// [`select!`]: macro.select.html\n/// [`try_select`]: struct.Select.html#method.try_select\n/// [`select`]: struct.Select.html#method.select\n/// [`select_timeout`]: struct.Select.html#method.select_timeout\n/// [`try_ready`]: struct.Select.html#method.try_ready\n/// [`ready`]: struct.Select.html#method.ready\n/// [`ready_timeout`]: struct.Select.html#method.ready_timeout\npub struct Select<'a> {\n    /// A list of senders and receivers participating in selection.\n    handles: Vec<(&'a dyn SelectHandle, usize, *const u8)>,\n\n    /// The next index to assign to an operation.\n    next_index: usize,\n}","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Select::<'a>::new":["/// Creates an empty list of channel operations for selection.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::Select;\n///\n/// let mut sel = Select::new();\n///\n/// // The list of operations is empty, which means no operation can be selected.\n/// assert!(sel.try_select().is_err());\n/// ```\npub fn new() -> Select<'a>{\n        Select {\n            handles: Vec::with_capacity(4),\n            next_index: 0,\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Select::<'a>::ready":["/// Blocks until one of the operations becomes ready.\n///\n/// Once an operation becomes ready, its index is returned. If multiple operations are ready at\n/// the same time, a random one among them is chosen.\n///\n/// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n/// even when it will simply return an error because the channel is disconnected.\n///\n/// Note that this method might return with success spuriously, so it's a good idea to always\n/// double check if the operation is really ready.\n///\n/// # Panics\n///\n/// Panics if no operations have been added to `Select`.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::{unbounded, Select};\n///\n/// let (s1, r1) = unbounded();\n/// let (s2, r2) = unbounded();\n///\n/// thread::spawn(move || {\n///     thread::sleep(Duration::from_secs(1));\n///     s1.send(10).unwrap();\n/// });\n/// thread::spawn(move || s2.send(20).unwrap());\n///\n/// let mut sel = Select::new();\n/// let oper1 = sel.recv(&r1);\n/// let oper2 = sel.recv(&r2);\n///\n/// // The second operation will be selected because it becomes ready first.\n/// match sel.ready() {\n///     i if i == oper1 => assert_eq!(r1.try_recv(), Ok(10)),\n///     i if i == oper2 => assert_eq!(r2.try_recv(), Ok(20)),\n///     _ => unreachable!(),\n/// }\n/// ```\npub fn ready(&mut self) -> usize{\n        if self.handles.is_empty() {\n            panic!(\"no operations have been added to `Select`\");\n        }\n\n        run_ready(&mut self.handles, Timeout::Never).unwrap()\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Select::<'a>::ready_timeout":["/// Blocks for a limited time until one of the operations becomes ready.\n///\n/// If an operation becomes ready, its index is returned. If multiple operations are ready at\n/// the same time, a random one among them is chosen. If none of the operations become ready\n/// for the specified duration, an error is returned.\n///\n/// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n/// even when it will simply return an error because the channel is disconnected.\n///\n/// Note that this method might return with success spuriously, so it's a good idea to double\n/// check if the operation is really ready.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::{unbounded, Select};\n///\n/// let (s1, r1) = unbounded();\n/// let (s2, r2) = unbounded();\n///\n/// thread::spawn(move || {\n///     thread::sleep(Duration::from_secs(1));\n///     s1.send(10).unwrap();\n/// });\n/// thread::spawn(move || s2.send(20).unwrap());\n///\n/// let mut sel = Select::new();\n/// let oper1 = sel.recv(&r1);\n/// let oper2 = sel.recv(&r2);\n///\n/// // The second operation will be selected because it becomes ready first.\n/// match sel.ready_timeout(Duration::from_millis(500)) {\n///     Err(_) => panic!(\"should not have timed out\"),\n///     Ok(i) if i == oper1 => assert_eq!(r1.try_recv(), Ok(10)),\n///     Ok(i) if i == oper2 => assert_eq!(r2.try_recv(), Ok(20)),\n///     Ok(_) => unreachable!(),\n/// }\n/// ```\npub fn ready_timeout(&mut self, timeout: Duration) -> Result<usize, ReadyTimeoutError>{\n        let timeout = Timeout::At(Instant::now() + timeout);\n\n        match run_ready(&mut self.handles, timeout) {\n            None => Err(ReadyTimeoutError),\n            Some(index) => Ok(index),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Select::<'a>::recv":["/// Adds a receive operation.\n///\n/// Returns the index of the added operation.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{unbounded, Select};\n///\n/// let (s, r) = unbounded::<i32>();\n///\n/// let mut sel = Select::new();\n/// let index = sel.recv(&r);\n/// ```\npub fn recv<T>(&mut self, r: &'a Receiver<T>) -> usize{\n        let i = self.next_index;\n        let ptr = r as *const Receiver<_> as *const u8;\n        self.handles.push((r, i, ptr));\n        self.next_index += 1;\n        i\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Select::<'a>::remove":["/// Removes a previously added operation.\n///\n/// This is useful when an operation is selected because the channel got disconnected and we\n/// want to try again to select a different operation instead.\n///\n/// If new operations are added after removing some, the indices of removed operations will not\n/// be reused.\n///\n/// # Panics\n///\n/// An attempt to remove a non-existing or already removed operation will panic.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{unbounded, Select};\n///\n/// let (s1, r1) = unbounded::<i32>();\n/// let (_, r2) = unbounded::<i32>();\n///\n/// let mut sel = Select::new();\n/// let oper1 = sel.recv(&r1);\n/// let oper2 = sel.recv(&r2);\n///\n/// // Both operations are initially ready, so a random one will be executed.\n/// let oper = sel.select();\n/// assert_eq!(oper.index(), oper2);\n/// assert!(oper.recv(&r2).is_err());\n/// sel.remove(oper2);\n///\n/// s1.send(10).unwrap();\n///\n/// let oper = sel.select();\n/// assert_eq!(oper.index(), oper1);\n/// assert_eq!(oper.recv(&r1), Ok(10));\n/// ```\npub fn remove(&mut self, index: usize){\n        assert!(\n            index < self.next_index,\n            \"index out of bounds; {} >= {}\",\n            index,\n            self.next_index,\n        );\n\n        let i = self\n            .handles\n            .iter()\n            .enumerate()\n            .find(|(_, (_, i, _))| *i == index)\n            .expect(\"no operation with this index\")\n            .0;\n\n        self.handles.swap_remove(i);\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Select::<'a>::select":["/// Blocks until one of the operations becomes ready and selects it.\n///\n/// Once an operation becomes ready, it is selected and returned. If multiple operations are\n/// ready at the same time, a random one among them is selected.\n///\n/// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n/// even when it will simply return an error because the channel is disconnected.\n///\n/// The selected operation must be completed with [`SelectedOperation::send`]\n/// or [`SelectedOperation::recv`].\n///\n/// [`SelectedOperation::send`]: struct.SelectedOperation.html#method.send\n/// [`SelectedOperation::recv`]: struct.SelectedOperation.html#method.recv\n///\n/// # Panics\n///\n/// Panics if no operations have been added to `Select`.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::{unbounded, Select};\n///\n/// let (s1, r1) = unbounded();\n/// let (s2, r2) = unbounded();\n///\n/// thread::spawn(move || {\n///     thread::sleep(Duration::from_secs(1));\n///     s1.send(10).unwrap();\n/// });\n/// thread::spawn(move || s2.send(20).unwrap());\n///\n/// let mut sel = Select::new();\n/// let oper1 = sel.recv(&r1);\n/// let oper2 = sel.recv(&r2);\n///\n/// // The second operation will be selected because it becomes ready first.\n/// let oper = sel.select();\n/// match oper.index() {\n///     i if i == oper1 => assert_eq!(oper.recv(&r1), Ok(10)),\n///     i if i == oper2 => assert_eq!(oper.recv(&r2), Ok(20)),\n///     _ => unreachable!(),\n/// }\n/// ```\npub fn select(&mut self) -> SelectedOperation<'a>{\n        select(&mut self.handles)\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Select::<'a>::select_timeout":["/// Blocks for a limited time until one of the operations becomes ready and selects it.\n///\n/// If an operation becomes ready, it is selected and returned. If multiple operations are\n/// ready at the same time, a random one among them is selected. If none of the operations\n/// become ready for the specified duration, an error is returned.\n///\n/// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n/// even when it will simply return an error because the channel is disconnected.\n///\n/// The selected operation must be completed with [`SelectedOperation::send`]\n/// or [`SelectedOperation::recv`].\n///\n/// [`SelectedOperation::send`]: struct.SelectedOperation.html#method.send\n/// [`SelectedOperation::recv`]: struct.SelectedOperation.html#method.recv\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::time::Duration;\n/// use crossbeam_channel::{unbounded, Select};\n///\n/// let (s1, r1) = unbounded();\n/// let (s2, r2) = unbounded();\n///\n/// thread::spawn(move || {\n///     thread::sleep(Duration::from_secs(1));\n///     s1.send(10).unwrap();\n/// });\n/// thread::spawn(move || s2.send(20).unwrap());\n///\n/// let mut sel = Select::new();\n/// let oper1 = sel.recv(&r1);\n/// let oper2 = sel.recv(&r2);\n///\n/// // The second operation will be selected because it becomes ready first.\n/// let oper = sel.select_timeout(Duration::from_millis(500));\n/// match oper {\n///     Err(_) => panic!(\"should not have timed out\"),\n///     Ok(oper) => match oper.index() {\n///         i if i == oper1 => assert_eq!(oper.recv(&r1), Ok(10)),\n///         i if i == oper2 => assert_eq!(oper.recv(&r2), Ok(20)),\n///         _ => unreachable!(),\n///     }\n/// }\n/// ```\npub fn select_timeout(\n        &mut self,\n        timeout: Duration,\n    ) -> Result<SelectedOperation<'a>, SelectTimeoutError>{\n        select_timeout(&mut self.handles, timeout)\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Select::<'a>::send":["/// Adds a send operation.\n///\n/// Returns the index of the added operation.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{unbounded, Select};\n///\n/// let (s, r) = unbounded::<i32>();\n///\n/// let mut sel = Select::new();\n/// let index = sel.send(&s);\n/// ```\npub fn send<T>(&mut self, s: &'a Sender<T>) -> usize{\n        let i = self.next_index;\n        let ptr = s as *const Sender<_> as *const u8;\n        self.handles.push((s, i, ptr));\n        self.next_index += 1;\n        i\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Select::<'a>::try_ready":["/// Attempts to find a ready operation without blocking.\n///\n/// If an operation is ready, its index is returned. If multiple operations are ready at the\n/// same time, a random one among them is chosen. If none of the operations are ready, an error\n/// is returned.\n///\n/// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n/// even when it will simply return an error because the channel is disconnected.\n///\n/// Note that this method might return with success spuriously, so it's a good idea to always\n/// double check if the operation is really ready.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{unbounded, Select};\n///\n/// let (s1, r1) = unbounded();\n/// let (s2, r2) = unbounded();\n///\n/// s1.send(10).unwrap();\n/// s2.send(20).unwrap();\n///\n/// let mut sel = Select::new();\n/// let oper1 = sel.recv(&r1);\n/// let oper2 = sel.recv(&r2);\n///\n/// // Both operations are initially ready, so a random one will be chosen.\n/// match sel.try_ready() {\n///     Err(_) => panic!(\"both operations should be ready\"),\n///     Ok(i) if i == oper1 => assert_eq!(r1.try_recv(), Ok(10)),\n///     Ok(i) if i == oper2 => assert_eq!(r2.try_recv(), Ok(20)),\n///     Ok(_) => unreachable!(),\n/// }\n/// ```\npub fn try_ready(&mut self) -> Result<usize, TryReadyError>{\n        match run_ready(&mut self.handles, Timeout::Now) {\n            None => Err(TryReadyError),\n            Some(index) => Ok(index),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Select::<'a>::try_select":["/// Attempts to select one of the operations without blocking.\n///\n/// If an operation is ready, it is selected and returned. If multiple operations are ready at\n/// the same time, a random one among them is selected. If none of the operations are ready, an\n/// error is returned.\n///\n/// An operation is considered to be ready if it doesn't have to block. Note that it is ready\n/// even when it will simply return an error because the channel is disconnected.\n///\n/// The selected operation must be completed with [`SelectedOperation::send`]\n/// or [`SelectedOperation::recv`].\n///\n/// [`SelectedOperation::send`]: struct.SelectedOperation.html#method.send\n/// [`SelectedOperation::recv`]: struct.SelectedOperation.html#method.recv\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{unbounded, Select};\n///\n/// let (s1, r1) = unbounded();\n/// let (s2, r2) = unbounded();\n///\n/// s1.send(10).unwrap();\n/// s2.send(20).unwrap();\n///\n/// let mut sel = Select::new();\n/// let oper1 = sel.recv(&r1);\n/// let oper2 = sel.recv(&r2);\n///\n/// // Both operations are initially ready, so a random one will be executed.\n/// let oper = sel.try_select();\n/// match oper {\n///     Err(_) => panic!(\"both operations should be ready\"),\n///     Ok(oper) => match oper.index() {\n///         i if i == oper1 => assert_eq!(oper.recv(&r1), Ok(10)),\n///         i if i == oper2 => assert_eq!(oper.recv(&r2), Ok(20)),\n///         _ => unreachable!(),\n///     }\n/// }\n/// ```\npub fn try_select(&mut self) -> Result<SelectedOperation<'a>, TrySelectError>{\n        try_select(&mut self.handles)\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::SelectHandle":["/// A receiver or a sender that can participate in select.\n///\n/// This is a handle that assists select in executing an operation, registration, deciding on the\n/// appropriate deadline for blocking, etc.\npub trait SelectHandle {\n    /// Attempts to select an operation and returns `true` on success.\n    fn try_select(&self, token: &mut Token) -> bool;\n\n    /// Returns a deadline for an operation, if there is one.\n    fn deadline(&self) -> Option<Instant>;\n\n    /// Registers an operation for execution and returns `true` if it is now ready.\n    fn register(&self, oper: Operation, cx: &Context) -> bool;\n\n    /// Unregisters an operation for execution.\n    fn unregister(&self, oper: Operation);\n\n    /// Attempts to select an operation the thread got woken up for and returns `true` on success.\n    fn accept(&self, token: &mut Token, cx: &Context) -> bool;\n\n    /// Returns `true` if an operation can be executed without blocking.\n    fn is_ready(&self) -> bool;\n\n    /// Registers an operation for readiness notification and returns `true` if it is now ready.\n    fn watch(&self, oper: Operation, cx: &Context) -> bool;\n\n    /// Unregisters an operation for readiness notification.\n    fn unwatch(&self, oper: Operation);\n}","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Selected":["/// Current state of a select or a blocking operation.\npub enum Selected {\n    /// Still waiting for an operation.\n    Waiting,\n\n    /// The attempt to block the current thread has been aborted.\n    Aborted,\n\n    /// An operation became ready because a channel is disconnected.\n    Disconnected,\n\n    /// An operation became ready because a message can be sent or received.\n    Operation(Operation),\n}","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::SelectedOperation":["/// A selected operation that needs to be completed.\n///\n/// To complete the operation, call [`send`] or [`recv`].\n///\n/// # Panics\n///\n/// Forgetting to complete the operation is an error and might lead to deadlocks. If a\n/// `SelectedOperation` is dropped without completion, a panic occurs.\n///\n/// [`send`]: struct.SelectedOperation.html#method.send\n/// [`recv`]: struct.SelectedOperation.html#method.recv\n#[must_use]\npub struct SelectedOperation<'a> {\n    /// Token needed to complete the operation.\n    token: Token,\n\n    /// The index of the selected operation.\n    index: usize,\n\n    /// The address of the selected `Sender` or `Receiver`.\n    ptr: *const u8,\n\n    /// Indicates that `Sender`s and `Receiver`s are borrowed.\n    _marker: PhantomData<&'a ()>,\n}","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::SelectedOperation::<'_>::index":["/// Returns the index of the selected operation.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{bounded, Select};\n///\n/// let (s1, r1) = bounded::<()>(0);\n/// let (s2, r2) = bounded::<()>(0);\n/// let (s3, r3) = bounded::<()>(1);\n///\n/// let mut sel = Select::new();\n/// let oper1 = sel.send(&s1);\n/// let oper2 = sel.recv(&r2);\n/// let oper3 = sel.send(&s3);\n///\n/// // Only the last operation is ready.\n/// let oper = sel.select();\n/// assert_eq!(oper.index(), 2);\n/// assert_eq!(oper.index(), oper3);\n///\n/// // Complete the operation.\n/// oper.send(&s3, ()).unwrap();\n/// ```\npub fn index(&self) -> usize{\n        self.index\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::SelectedOperation::<'_>::recv":["/// Completes the receive operation.\n///\n/// The passed [`Receiver`] reference must be the same one that was used in [`Select::recv`]\n/// when the operation was added.\n///\n/// # Panics\n///\n/// Panics if an incorrect [`Receiver`] reference is passed.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{bounded, Select, RecvError};\n///\n/// let (s, r) = bounded::<i32>(0);\n/// drop(s);\n///\n/// let mut sel = Select::new();\n/// let oper1 = sel.recv(&r);\n///\n/// let oper = sel.select();\n/// assert_eq!(oper.index(), oper1);\n/// assert_eq!(oper.recv(&r), Err(RecvError));\n/// ```\n///\n/// [`Receiver`]: struct.Receiver.html\n/// [`Select::recv`]: struct.Select.html#method.recv\npub fn recv<T>(mut self, r: &Receiver<T>) -> Result<T, RecvError>{\n        assert!(\n            r as *const Receiver<T> as *const u8 == self.ptr,\n            \"passed a receiver that wasn't selected\",\n        );\n        let res = unsafe { channel::read(r, &mut self.token) };\n        mem::forget(self);\n        res.map_err(|_| RecvError)\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::SelectedOperation::<'_>::send":["/// Completes the send operation.\n///\n/// The passed [`Sender`] reference must be the same one that was used in [`Select::send`]\n/// when the operation was added.\n///\n/// # Panics\n///\n/// Panics if an incorrect [`Sender`] reference is passed.\n///\n/// # Examples\n///\n/// ```\n/// use crossbeam_channel::{bounded, Select, SendError};\n///\n/// let (s, r) = bounded::<i32>(0);\n/// drop(r);\n///\n/// let mut sel = Select::new();\n/// let oper1 = sel.send(&s);\n///\n/// let oper = sel.select();\n/// assert_eq!(oper.index(), oper1);\n/// assert_eq!(oper.send(&s, 10), Err(SendError(10)));\n/// ```\n///\n/// [`Sender`]: struct.Sender.html\n/// [`Select::send`]: struct.Select.html#method.send\npub fn send<T>(mut self, s: &Sender<T>, msg: T) -> Result<(), SendError<T>>{\n        assert!(\n            s as *const Sender<T> as *const u8 == self.ptr,\n            \"passed a sender that wasn't selected\",\n        );\n        let res = unsafe { channel::write(s, &mut self.token, msg) };\n        mem::forget(self);\n        res.map_err(SendError)\n    }","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Timeout":["/// Determines when a select operation should time out.\nenum Timeout {\n    /// No blocking.\n    Now,\n\n    /// Block forever.\n    Never,\n\n    /// Time out after the time instant.\n    At(Instant),\n}","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::Token":["/// Temporary data that gets initialized during select or a blocking operation, and is consumed by\n/// `read` or `write`.\n///\n/// Each field contains data associated with a specific channel flavor.\npub struct Token {\n    pub after: flavors::after::AfterToken,\n    pub array: flavors::array::ArrayToken,\n    pub list: flavors::list::ListToken,\n    pub never: flavors::never::NeverToken,\n    pub tick: flavors::tick::TickToken,\n    pub zero: flavors::zero::ZeroToken,\n}","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::run_ready":["/// Runs until one of the operations becomes ready, potentially blocking the current thread.\nfn run_ready(\n    handles: &mut [(&dyn SelectHandle, usize, *const u8)],\n    timeout: Timeout,\n) -> Option<usize>{\n    if handles.is_empty() {\n        // Wait until the timeout and return.\n        match timeout {\n            Timeout::Now => return None,\n            Timeout::Never => {\n                utils::sleep_until(None);\n                unreachable!();\n            }\n            Timeout::At(when) => {\n                utils::sleep_until(Some(when));\n                return None;\n            }\n        }\n    }\n\n    // Shuffle the operations for fairness.\n    utils::shuffle(handles);\n\n    loop {\n        let backoff = Backoff::new();\n        loop {\n            // Check operations for readiness.\n            for &(handle, i, _) in handles.iter() {\n                if handle.is_ready() {\n                    return Some(i);\n                }\n            }\n\n            if backoff.is_completed() {\n                break;\n            } else {\n                backoff.snooze();\n            }\n        }\n\n        // Check for timeout.\n        match timeout {\n            Timeout::Now => return None,\n            Timeout::Never => {}\n            Timeout::At(when) => {\n                if Instant::now() >= when {\n                    return None;\n                }\n            }\n        }\n\n        // Prepare for blocking.\n        let res = Context::with(|cx| {\n            let mut sel = Selected::Waiting;\n            let mut registered_count = 0;\n\n            // Begin watching all operations.\n            for (handle, _, _) in handles.iter_mut() {\n                registered_count += 1;\n                let oper = Operation::hook::<&dyn SelectHandle>(handle);\n\n                // If registration returns `false`, that means the operation has just become ready.\n                if handle.watch(oper, cx) {\n                    sel = match cx.try_select(Selected::Operation(oper)) {\n                        Ok(()) => Selected::Operation(oper),\n                        Err(s) => s,\n                    };\n                    break;\n                }\n\n                // If another thread has already chosen one of the operations, stop registration.\n                sel = cx.selected();\n                if sel != Selected::Waiting {\n                    break;\n                }\n            }\n\n            if sel == Selected::Waiting {\n                // Check with each operation for how long we're allowed to block, and compute the\n                // earliest deadline.\n                let mut deadline: Option<Instant> = match timeout {\n                    Timeout::Now => unreachable!(),\n                    Timeout::Never => None,\n                    Timeout::At(when) => Some(when),\n                };\n                for &(handle, _, _) in handles.iter() {\n                    if let Some(x) = handle.deadline() {\n                        deadline = deadline.map(|y| x.min(y)).or(Some(x));\n                    }\n                }\n\n                // Block the current thread.\n                sel = cx.wait_until(deadline);\n            }\n\n            // Unwatch all operations.\n            for (handle, _, _) in handles.iter_mut().take(registered_count) {\n                handle.unwatch(Operation::hook::<&dyn SelectHandle>(handle));\n            }\n\n            match sel {\n                Selected::Waiting => unreachable!(),\n                Selected::Aborted => {}\n                Selected::Disconnected => {}\n                Selected::Operation(_) => {\n                    for (handle, i, _) in handles.iter_mut() {\n                        let oper = Operation::hook::<&dyn SelectHandle>(handle);\n                        if sel == Selected::Operation(oper) {\n                            return Some(*i);\n                        }\n                    }\n                }\n            }\n\n            None\n        });\n\n        // Return if an operation became ready.\n        if res.is_some() {\n            return res;\n        }\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::run_select":["/// Runs until one of the operations is selected, potentially blocking the current thread.\n///\n/// Successful receive operations will have to be followed up by `channel::read()` and successful\n/// send operations by `channel::write()`.\nfn run_select(\n    handles: &mut [(&dyn SelectHandle, usize, *const u8)],\n    timeout: Timeout,\n) -> Option<(Token, usize, *const u8)>{\n    if handles.is_empty() {\n        // Wait until the timeout and return.\n        match timeout {\n            Timeout::Now => return None,\n            Timeout::Never => {\n                utils::sleep_until(None);\n                unreachable!();\n            }\n            Timeout::At(when) => {\n                utils::sleep_until(Some(when));\n                return None;\n            }\n        }\n    }\n\n    // Shuffle the operations for fairness.\n    utils::shuffle(handles);\n\n    // Create a token, which serves as a temporary variable that gets initialized in this function\n    // and is later used by a call to `channel::read()` or `channel::write()` that completes the\n    // selected operation.\n    let mut token = Token::default();\n\n    // Try selecting one of the operations without blocking.\n    for &(handle, i, ptr) in handles.iter() {\n        if handle.try_select(&mut token) {\n            return Some((token, i, ptr));\n        }\n    }\n\n    loop {\n        // Prepare for blocking.\n        let res = Context::with(|cx| {\n            let mut sel = Selected::Waiting;\n            let mut registered_count = 0;\n            let mut index_ready = None;\n\n            if let Timeout::Now = timeout {\n                cx.try_select(Selected::Aborted).unwrap();\n            }\n\n            // Register all operations.\n            for (handle, i, _) in handles.iter_mut() {\n                registered_count += 1;\n\n                // If registration returns `false`, that means the operation has just become ready.\n                if handle.register(Operation::hook::<&dyn SelectHandle>(handle), cx) {\n                    // Try aborting select.\n                    sel = match cx.try_select(Selected::Aborted) {\n                        Ok(()) => {\n                            index_ready = Some(*i);\n                            Selected::Aborted\n                        }\n                        Err(s) => s,\n                    };\n                    break;\n                }\n\n                // If another thread has already selected one of the operations, stop registration.\n                sel = cx.selected();\n                if sel != Selected::Waiting {\n                    break;\n                }\n            }\n\n            if sel == Selected::Waiting {\n                // Check with each operation for how long we're allowed to block, and compute the\n                // earliest deadline.\n                let mut deadline: Option<Instant> = match timeout {\n                    Timeout::Now => return None,\n                    Timeout::Never => None,\n                    Timeout::At(when) => Some(when),\n                };\n                for &(handle, _, _) in handles.iter() {\n                    if let Some(x) = handle.deadline() {\n                        deadline = deadline.map(|y| x.min(y)).or(Some(x));\n                    }\n                }\n\n                // Block the current thread.\n                sel = cx.wait_until(deadline);\n            }\n\n            // Unregister all registered operations.\n            for (handle, _, _) in handles.iter_mut().take(registered_count) {\n                handle.unregister(Operation::hook::<&dyn SelectHandle>(handle));\n            }\n\n            match sel {\n                Selected::Waiting => unreachable!(),\n                Selected::Aborted => {\n                    // If an operation became ready during registration, try selecting it.\n                    if let Some(index_ready) = index_ready {\n                        for &(handle, i, ptr) in handles.iter() {\n                            if i == index_ready && handle.try_select(&mut token) {\n                                return Some((i, ptr));\n                            }\n                        }\n                    }\n                }\n                Selected::Disconnected => {}\n                Selected::Operation(_) => {\n                    // Find the selected operation.\n                    for (handle, i, ptr) in handles.iter_mut() {\n                        // Is this the selected operation?\n                        if sel == Selected::Operation(Operation::hook::<&dyn SelectHandle>(handle))\n                        {\n                            // Try selecting this operation.\n                            if handle.accept(&mut token, cx) {\n                                return Some((*i, *ptr));\n                            }\n                        }\n                    }\n                }\n            }\n\n            None\n        });\n\n        // Return if an operation was selected.\n        if let Some((i, ptr)) = res {\n            return Some((token, i, ptr));\n        }\n\n        // Try selecting one of the operations without blocking.\n        for &(handle, i, ptr) in handles.iter() {\n            if handle.try_select(&mut token) {\n                return Some((token, i, ptr));\n            }\n        }\n\n        match timeout {\n            Timeout::Now => return None,\n            Timeout::Never => {}\n            Timeout::At(when) => {\n                if Instant::now() >= when {\n                    return None;\n                }\n            }\n        }\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::select":["/// Blocks until one of the operations becomes ready and selects it.\n#[inline]\npub fn select<'a>(\n    handles: &mut [(&'a dyn SelectHandle, usize, *const u8)],\n) -> SelectedOperation<'a>{\n    if handles.is_empty() {\n        panic!(\"no operations have been added to `Select`\");\n    }\n\n    let (token, index, ptr) = run_select(handles, Timeout::Never).unwrap();\n    SelectedOperation {\n        token,\n        index,\n        ptr,\n        _marker: PhantomData,\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::select_timeout":["/// Blocks for a limited time until one of the operations becomes ready and selects it.\n#[inline]\npub fn select_timeout<'a>(\n    handles: &mut [(&'a dyn SelectHandle, usize, *const u8)],\n    timeout: Duration,\n) -> Result<SelectedOperation<'a>, SelectTimeoutError>{\n    let timeout = Timeout::At(Instant::now() + timeout);\n\n    match run_select(handles, timeout) {\n        None => Err(SelectTimeoutError),\n        Some((token, index, ptr)) => Ok(SelectedOperation {\n            token,\n            index,\n            ptr,\n            _marker: PhantomData,\n        }),\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"select::try_select":["/// Attempts to select one of the operations without blocking.\n#[inline]\npub fn try_select<'a>(\n    handles: &mut [(&'a dyn SelectHandle, usize, *const u8)],\n) -> Result<SelectedOperation<'a>, TrySelectError>{\n    match run_select(handles, Timeout::Now) {\n        None => Err(TrySelectError),\n        Some((token, index, ptr)) => Ok(SelectedOperation {\n            token,\n            index,\n            ptr,\n            _marker: PhantomData,\n        }),\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))"],"utils::Spinlock":["/// A simple spinlock.\npub struct Spinlock<T> {\n    flag: AtomicBool,\n    value: UnsafeCell<T>,\n}","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))"],"utils::Spinlock::<T>::lock":["/// Locks the spinlock.\npub fn lock(&self) -> SpinlockGuard<'_, T>{\n        let backoff = Backoff::new();\n        while self.flag.swap(true, Ordering::Acquire) {\n            backoff.snooze();\n        }\n        SpinlockGuard { parent: self }\n    }","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))"],"utils::Spinlock::<T>::new":["/// Returns a new spinlock initialized with `value`.\npub fn new(value: T) -> Spinlock<T>{\n        Spinlock {\n            flag: AtomicBool::new(false),\n            value: UnsafeCell::new(value),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))"],"utils::SpinlockGuard":["/// A guard holding a spinlock locked.\npub struct SpinlockGuard<'a, T> {\n    parent: &'a Spinlock<T>,\n}","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))"],"utils::shuffle":["/// Randomly shuffles a slice.\npub fn shuffle<T>(v: &mut [T]){\n    let len = v.len();\n    if len <= 1 {\n        return;\n    }\n\n    thread_local! {\n        static RNG: Cell<Wrapping<u32>> = Cell::new(Wrapping(1_406_868_647));\n    }\n\n    let _ = RNG.try_with(|rng| {\n        for i in 1..len {\n            // This is the 32-bit variant of Xorshift.\n            //\n            // Source: https://en.wikipedia.org/wiki/Xorshift\n            let mut x = rng.get();\n            x ^= x << 13;\n            x ^= x >> 17;\n            x ^= x << 5;\n            rng.set(x);\n\n            let x = x.0;\n            let n = i + 1;\n\n            // This is a fast alternative to `let j = x % n`.\n            //\n            // Author: Daniel Lemire\n            // Source: https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/\n            let j = ((x as u64).wrapping_mul(n as u64) >> 32) as u32 as usize;\n\n            v.swap(i, j);\n        }\n    });\n}","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))"],"utils::shuffle::RNG::__getit":["inline\nunsafe fn __getit(\n                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n            ) -> $crate::option::Option<&'static $t>{\n                #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                    $crate::thread::__StaticLocalKeyInner::new();\n\n                #[thread_local]\n                #[cfg(all(\n                    target_thread_local,\n                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n                    $crate::thread::__FastLocalKeyInner::new();\n\n                #[cfg(all(\n                    not(target_thread_local),\n                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                    $crate::thread::__OsLocalKeyInner::new();\n\n                // FIXME: remove the #[allow(...)] marker when macros don't\n                // raise warning for missing/extraneous unsafe blocks anymore.\n                // See https://github.com/rust-lang/rust/issues/74838.\n                #[allow(unused_unsafe)]\n                unsafe {\n                    __KEY.get(move || {\n                        if let $crate::option::Option::Some(init) = init {\n                            if let $crate::option::Option::Some(value) = init.take() {\n                                return value;\n                            } else if $crate::cfg!(debug_assertions) {\n                                $crate::unreachable!(\"missing default value\");\n                            }\n                        }\n                        __init()\n                    })\n                }\n            }","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })"],"utils::shuffle::RNG::__init":["#[inline]\nfn __init() -> $t{ $init }","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })"],"utils::sleep_until":["/// Sleeps until the deadline, or forever if the deadline isn't specified.\npub fn sleep_until(deadline: Option<Instant>){\n    loop {\n        match deadline {\n            None => thread::sleep(Duration::from_secs(1000)),\n            Some(d) => {\n                let now = Instant::now();\n                if now >= d {\n                    break;\n                }\n                thread::sleep(d - now);\n            }\n        }\n    }\n}","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))"],"waker::Entry":["/// Represents a thread blocked on a specific channel operation.\npub struct Entry {\n    /// The operation.\n    pub oper: Operation,\n\n    /// Optional packet.\n    pub packet: usize,\n\n    /// Context associated with the thread owning this operation.\n    pub cx: Context,\n}","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::SyncWaker":["/// A waker that can be shared among threads without locking.\n///\n/// This is a simple wrapper around `Waker` that internally uses a mutex for synchronization.\npub struct SyncWaker {\n    /// The inner `Waker`.\n    inner: Spinlock<Waker>,\n\n    /// `true` if the waker is empty.\n    is_empty: AtomicBool,\n}","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::SyncWaker::disconnect":["/// Notifies all threads that the channel is disconnected.\n#[inline]\npub fn disconnect(&self){\n        let mut inner = self.inner.lock();\n        inner.disconnect();\n        self.is_empty.store(\n            inner.selectors.is_empty() && inner.observers.is_empty(),\n            Ordering::SeqCst,\n        );\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::SyncWaker::new":["/// Creates a new `SyncWaker`.\n#[inline]\npub fn new() -> Self{\n        SyncWaker {\n            inner: Spinlock::new(Waker::new()),\n            is_empty: AtomicBool::new(true),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::SyncWaker::notify":["/// Attempts to find one thread (not the current one), select its operation, and wake it up.\n#[inline]\npub fn notify(&self){\n        if !self.is_empty.load(Ordering::SeqCst) {\n            let mut inner = self.inner.lock();\n            if !self.is_empty.load(Ordering::SeqCst) {\n                inner.try_select();\n                inner.notify();\n                self.is_empty.store(\n                    inner.selectors.is_empty() && inner.observers.is_empty(),\n                    Ordering::SeqCst,\n                );\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::SyncWaker::register":["/// Registers the current thread with an operation.\n#[inline]\npub fn register(&self, oper: Operation, cx: &Context){\n        let mut inner = self.inner.lock();\n        inner.register(oper, cx);\n        self.is_empty.store(\n            inner.selectors.is_empty() && inner.observers.is_empty(),\n            Ordering::SeqCst,\n        );\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::SyncWaker::unregister":["/// Unregisters an operation previously registered by the current thread.\n#[inline]\npub fn unregister(&self, oper: Operation) -> Option<Entry>{\n        let mut inner = self.inner.lock();\n        let entry = inner.unregister(oper);\n        self.is_empty.store(\n            inner.selectors.is_empty() && inner.observers.is_empty(),\n            Ordering::SeqCst,\n        );\n        entry\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::SyncWaker::unwatch":["/// Unregisters an operation waiting to be ready.\n#[inline]\npub fn unwatch(&self, oper: Operation){\n        let mut inner = self.inner.lock();\n        inner.unwatch(oper);\n        self.is_empty.store(\n            inner.selectors.is_empty() && inner.observers.is_empty(),\n            Ordering::SeqCst,\n        );\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::SyncWaker::watch":["/// Registers an operation waiting to be ready.\n#[inline]\npub fn watch(&self, oper: Operation, cx: &Context){\n        let mut inner = self.inner.lock();\n        inner.watch(oper, cx);\n        self.is_empty.store(\n            inner.selectors.is_empty() && inner.observers.is_empty(),\n            Ordering::SeqCst,\n        );\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::Waker":["/// A queue of threads blocked on channel operations.\n///\n/// This data structure is used by threads to register blocking operations and get woken up once\n/// an operation becomes ready.\npub struct Waker {\n    /// A list of select operations.\n    selectors: Vec<Entry>,\n\n    /// A list of operations waiting to be ready.\n    observers: Vec<Entry>,\n}","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::Waker::can_select":["/// Returns `true` if there is an entry which can be selected by the current thread.\n#[inline]\npub fn can_select(&self) -> bool{\n        if self.selectors.is_empty() {\n            false\n        } else {\n            let thread_id = current_thread_id();\n\n            self.selectors.iter().any(|entry| {\n                entry.cx.thread_id() != thread_id && entry.cx.selected() == Selected::Waiting\n            })\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::Waker::disconnect":["/// Notifies all registered operations that the channel is disconnected.\n#[inline]\npub fn disconnect(&mut self){\n        for entry in self.selectors.iter() {\n            if entry.cx.try_select(Selected::Disconnected).is_ok() {\n                // Wake the thread up.\n                //\n                // Here we don't remove the entry from the queue. Registered threads must\n                // unregister from the waker by themselves. They might also want to recover the\n                // packet value and destroy it, if necessary.\n                entry.cx.unpark();\n            }\n        }\n\n        self.notify();\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::Waker::new":["/// Creates a new `Waker`.\n#[inline]\npub fn new() -> Self{\n        Waker {\n            selectors: Vec::new(),\n            observers: Vec::new(),\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::Waker::notify":["/// Notifies all operations waiting to be ready.\n#[inline]\npub fn notify(&mut self){\n        for entry in self.observers.drain(..) {\n            if entry.cx.try_select(Selected::Operation(entry.oper)).is_ok() {\n                entry.cx.unpark();\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::Waker::register":["/// Registers a select operation.\n#[inline]\npub fn register(&mut self, oper: Operation, cx: &Context){\n        self.register_with_packet(oper, 0, cx);\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::Waker::register_with_packet":["/// Registers a select operation and a packet.\n#[inline]\npub fn register_with_packet(&mut self, oper: Operation, packet: usize, cx: &Context){\n        self.selectors.push(Entry {\n            oper,\n            packet,\n            cx: cx.clone(),\n        });\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::Waker::try_select":["/// Attempts to find another thread's entry, select the operation, and wake it up.\n#[inline]\npub fn try_select(&mut self) -> Option<Entry>{\n        let mut entry = None;\n\n        if !self.selectors.is_empty() {\n            let thread_id = current_thread_id();\n\n            for i in 0..self.selectors.len() {\n                // Does the entry belong to a different thread?\n                if self.selectors[i].cx.thread_id() != thread_id {\n                    // Try selecting this operation.\n                    let sel = Selected::Operation(self.selectors[i].oper);\n                    let res = self.selectors[i].cx.try_select(sel);\n\n                    if res.is_ok() {\n                        // Provide the packet.\n                        self.selectors[i].cx.store_packet(self.selectors[i].packet);\n                        // Wake the thread up.\n                        self.selectors[i].cx.unpark();\n\n                        // Remove the entry from the queue to keep it clean and improve\n                        // performance.\n                        entry = Some(self.selectors.remove(i));\n                        break;\n                    }\n                }\n            }\n        }\n\n        entry\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::Waker::unregister":["/// Unregisters a select operation.\n#[inline]\npub fn unregister(&mut self, oper: Operation) -> Option<Entry>{\n        if let Some((i, _)) = self\n            .selectors\n            .iter()\n            .enumerate()\n            .find(|&(_, entry)| entry.oper == oper)\n        {\n            let entry = self.selectors.remove(i);\n            Some(entry)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::Waker::unwatch":["/// Unregisters an operation waiting to be ready.\n#[inline]\npub fn unwatch(&mut self, oper: Operation){\n        self.observers.retain(|e| e.oper != oper);\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::Waker::watch":["/// Registers an operation waiting to be ready.\n#[inline]\npub fn watch(&mut self, oper: Operation, cx: &Context){\n        self.observers.push(Entry {\n            oper,\n            packet: 0,\n            cx: cx.clone(),\n        });\n    }","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::current_thread_id":["/// Returns the id of the current thread.\n#[inline]\nfn current_thread_id() -> ThreadId{\n    thread_local! {\n        /// Cached thread-local id.\n        static THREAD_ID: ThreadId = thread::current().id();\n    }\n\n    THREAD_ID\n        .try_with(|id| *id)\n        .unwrap_or_else(|_| thread::current().id())\n}","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))"],"waker::current_thread_id::THREAD_ID::__getit":["inline\nunsafe fn __getit(\n                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n            ) -> $crate::option::Option<&'static $t>{\n                #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                    $crate::thread::__StaticLocalKeyInner::new();\n\n                #[thread_local]\n                #[cfg(all(\n                    target_thread_local,\n                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n                    $crate::thread::__FastLocalKeyInner::new();\n\n                #[cfg(all(\n                    not(target_thread_local),\n                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                    $crate::thread::__OsLocalKeyInner::new();\n\n                // FIXME: remove the #[allow(...)] marker when macros don't\n                // raise warning for missing/extraneous unsafe blocks anymore.\n                // See https://github.com/rust-lang/rust/issues/74838.\n                #[allow(unused_unsafe)]\n                unsafe {\n                    __KEY.get(move || {\n                        if let $crate::option::Option::Some(init) = init {\n                            if let $crate::option::Option::Some(value) = init.take() {\n                                return value;\n                            } else if $crate::cfg!(debug_assertions) {\n                                $crate::unreachable!(\"missing default value\");\n                            }\n                        }\n                        __init()\n                    })\n                }\n            }","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })"],"waker::current_thread_id::THREAD_ID::__init":["#[inline]\nfn __init() -> $t{ $init }","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })"]},"struct_constructor":{"&'static std::thread::ThreadId":["__getit"],"(channel::Sender<T>, channel::Receiver<T>)":["bounded","unbounded"],"(counter::Sender<C>, counter::Receiver<C>)":["new"],"(select::Token, usize, *const u8)":["run_select"],"<&'a channel::Receiver<T> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<channel::IntoIter<T> as std::iter::Iterator>::Item":["next"],"<channel::Iter<'_, T> as std::iter::Iterator>::Item":["next"],"<channel::Receiver<T> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<channel::TryIter<'_, T> as std::iter::Iterator>::Item":["next"],"bool":["accept","can_select","disconnect","eq","is_disconnected","is_empty","is_full","is_ready","is_timeout","register","same_channel","start_recv","start_send","try_select","watch"],"channel::Iter":["iter"],"channel::Receiver":["after","clone","never","tick"],"channel::Sender":["clone"],"channel::TryIter":["try_iter"],"context::Context":["clone","new"],"counter::Receiver":["acquire"],"counter::Sender":["acquire"],"err::ReadyTimeoutError":["clone"],"err::RecvError":["clone"],"err::RecvTimeoutError":["clone","from"],"err::SelectTimeoutError":["clone"],"err::SendError":["clone"],"err::SendTimeoutError":["clone","from"],"err::TryReadyError":["clone"],"err::TryRecvError":["clone","from"],"err::TrySelectError":["clone"],"err::TrySendError":["clone","from"],"flavors::after::Channel":["new"],"flavors::array::ArrayToken":["default"],"flavors::array::Channel":["with_capacity"],"flavors::array::Receiver":["receiver"],"flavors::array::Sender":["sender"],"flavors::list::Block":["new"],"flavors::list::Channel":["new"],"flavors::list::ListToken":["default"],"flavors::list::Receiver":["receiver"],"flavors::list::Sender":["sender"],"flavors::never::Channel":["new"],"flavors::tick::Channel":["new"],"flavors::zero::Channel":["new"],"flavors::zero::Packet":["empty_on_stack","message_on_stack"],"flavors::zero::Receiver":["receiver"],"flavors::zero::Sender":["sender"],"select::Operation":["clone","hook"],"select::Select":["clone","default","new"],"select::Selected":["clone","from","selected","wait_until"],"select::SelectedOperation":["select","select_timeout","try_select"],"select::Timeout":["clone"],"select::Token":["default"],"std::boxed::Box":["empty_on_heap"],"std::cell::Cell":["__init"],"std::thread::ThreadId":["__init","current_thread_id","thread_id"],"std::time::Instant":["deadline","read","try_recv"],"usize":["capacity","index","into","len","ready","ready_timeout","recv","run_ready","send","try_ready","wait_packet"],"utils::Spinlock":["new"],"utils::SpinlockGuard":["lock"],"waker::Entry":["try_select","unregister"],"waker::SyncWaker":["new"],"waker::Waker":["new"]},"struct_to_trait":{"channel::IntoIter":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"channel::Iter":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"channel::Receiver":["select::SelectHandle","std::clone::Clone","std::fmt::Debug","std::iter::IntoIterator","std::marker::Send","std::marker::Sync","std::ops::Drop","std::panic::RefUnwindSafe","std::panic::UnwindSafe"],"channel::Sender":["select::SelectHandle","std::clone::Clone","std::fmt::Debug","std::marker::Send","std::marker::Sync","std::ops::Drop","std::panic::RefUnwindSafe","std::panic::UnwindSafe"],"channel::TryIter":["std::fmt::Debug","std::iter::Iterator"],"context::Context":["std::clone::Clone","std::fmt::Debug"],"context::Inner":["std::fmt::Debug"],"counter::Receiver":["std::cmp::PartialEq","std::ops::Deref"],"counter::Sender":["std::cmp::PartialEq","std::ops::Deref"],"err::ReadyTimeoutError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"err::RecvError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"err::RecvTimeoutError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"err::SelectTimeoutError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"err::SendError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"err::SendTimeoutError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"err::TryReadyError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"err::TryRecvError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"err::TrySelectError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"err::TrySendError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"flavors::after::Channel":["select::SelectHandle"],"flavors::array::ArrayToken":["std::default::Default","std::fmt::Debug"],"flavors::array::Channel":["std::ops::Drop"],"flavors::array::Receiver":["select::SelectHandle"],"flavors::array::Sender":["select::SelectHandle"],"flavors::list::Channel":["std::ops::Drop"],"flavors::list::ListToken":["std::default::Default","std::fmt::Debug"],"flavors::list::Position":["std::fmt::Debug"],"flavors::list::Receiver":["select::SelectHandle"],"flavors::list::Sender":["select::SelectHandle"],"flavors::never::Channel":["select::SelectHandle"],"flavors::tick::Channel":["select::SelectHandle"],"flavors::zero::Receiver":["select::SelectHandle"],"flavors::zero::Sender":["select::SelectHandle"],"select::Operation":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"select::Select":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::marker::Send","std::marker::Sync"],"select::Selected":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::convert::Into","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"select::SelectedOperation":["std::fmt::Debug","std::ops::Drop"],"select::Timeout":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"select::Token":["std::default::Default","std::fmt::Debug"],"utils::SpinlockGuard":["std::ops::Deref","std::ops::DerefMut","std::ops::Drop"],"waker::SyncWaker":["std::ops::Drop"],"waker::Waker":["std::ops::Drop"]},"targets":{"<&'a channel::Receiver<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::iter::IntoIterator"],"<&T as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","select::SelectHandle"],"<&T as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","select::SelectHandle"],"<&T as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","select::SelectHandle"],"<&T as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","select::SelectHandle"],"<&T as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","select::SelectHandle"],"<&T as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","select::SelectHandle"],"<&T as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","select::SelectHandle"],"<&T as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","select::SelectHandle"],"<channel::IntoIter<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::fmt::Debug"],"<channel::IntoIter<T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::iter::Iterator"],"<channel::Iter<'_, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::fmt::Debug"],"<channel::Iter<'_, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::iter::Iterator"],"<channel::Receiver<T> as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Receiver<T> as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Receiver<T> as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Receiver<T> as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Receiver<T> as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Receiver<T> as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Receiver<T> as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Receiver<T> as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Receiver<T> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::clone::Clone"],"<channel::Receiver<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::fmt::Debug"],"<channel::Receiver<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::iter::IntoIterator"],"<channel::Receiver<T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::ops::Drop"],"<channel::Sender<T> as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Sender<T> as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Sender<T> as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Sender<T> as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Sender<T> as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Sender<T> as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Sender<T> as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Sender<T> as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","select::SelectHandle"],"<channel::Sender<T> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::clone::Clone"],"<channel::Sender<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::fmt::Debug"],"<channel::Sender<T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::ops::Drop"],"<channel::TryIter<'_, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::fmt::Debug"],"<channel::TryIter<'_, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))","std::iter::Iterator"],"<counter::Receiver<C> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))","std::cmp::PartialEq"],"<counter::Receiver<C> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))","std::ops::Deref"],"<counter::Sender<C> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))","std::cmp::PartialEq"],"<counter::Sender<C> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))","std::ops::Deref"],"<err::RecvError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::fmt::Display"],"<err::RecvTimeoutError as std::convert::From<err::RecvError>>::from":["from","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::convert::From"],"<err::RecvTimeoutError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::fmt::Display"],"<err::SelectTimeoutError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::fmt::Display"],"<err::SendError<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::fmt::Debug"],"<err::SendError<T> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::fmt::Display"],"<err::SendTimeoutError<T> as std::convert::From<err::SendError<T>>>::from":["from","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::convert::From"],"<err::SendTimeoutError<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::fmt::Debug"],"<err::SendTimeoutError<T> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::fmt::Display"],"<err::TryRecvError as std::convert::From<err::RecvError>>::from":["from","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::convert::From"],"<err::TryRecvError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::fmt::Display"],"<err::TrySelectError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::fmt::Display"],"<err::TrySendError<T> as std::convert::From<err::SendError<T>>>::from":["from","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::convert::From"],"<err::TrySendError<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::fmt::Debug"],"<err::TrySendError<T> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))","std::fmt::Display"],"<flavors::after::Channel as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))","select::SelectHandle"],"<flavors::after::Channel as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))","select::SelectHandle"],"<flavors::after::Channel as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))","select::SelectHandle"],"<flavors::after::Channel as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))","select::SelectHandle"],"<flavors::after::Channel as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))","select::SelectHandle"],"<flavors::after::Channel as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))","select::SelectHandle"],"<flavors::after::Channel as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))","select::SelectHandle"],"<flavors::after::Channel as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))","select::SelectHandle"],"<flavors::array::ArrayToken as std::default::Default>::default":["default","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","std::default::Default"],"<flavors::array::Channel<T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","std::ops::Drop"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Receiver<'_, T> as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::array::Sender<'_, T> as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))","select::SelectHandle"],"<flavors::list::Channel<T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","std::ops::Drop"],"<flavors::list::ListToken as std::default::Default>::default":["default","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","std::default::Default"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Receiver<'_, T> as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::list::Sender<'_, T> as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))","select::SelectHandle"],"<flavors::never::Channel<T> as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))","select::SelectHandle"],"<flavors::never::Channel<T> as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))","select::SelectHandle"],"<flavors::never::Channel<T> as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))","select::SelectHandle"],"<flavors::never::Channel<T> as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))","select::SelectHandle"],"<flavors::never::Channel<T> as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))","select::SelectHandle"],"<flavors::never::Channel<T> as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))","select::SelectHandle"],"<flavors::never::Channel<T> as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))","select::SelectHandle"],"<flavors::never::Channel<T> as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))","select::SelectHandle"],"<flavors::tick::Channel as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))","select::SelectHandle"],"<flavors::tick::Channel as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))","select::SelectHandle"],"<flavors::tick::Channel as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))","select::SelectHandle"],"<flavors::tick::Channel as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))","select::SelectHandle"],"<flavors::tick::Channel as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))","select::SelectHandle"],"<flavors::tick::Channel as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))","select::SelectHandle"],"<flavors::tick::Channel as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))","select::SelectHandle"],"<flavors::tick::Channel as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))","select::SelectHandle"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Receiver<'_, T> as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::accept":["accept","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::deadline":["deadline","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::is_ready":["is_ready","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::register":["register","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<flavors::zero::Sender<'_, T> as select::SelectHandle>::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))","select::SelectHandle"],"<select::Select<'_> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","std::fmt::Debug"],"<select::Select<'a> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","std::clone::Clone"],"<select::Select<'a> as std::default::Default>::default":["default","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","std::default::Default"],"<select::Selected as std::convert::From<usize>>::from":["from","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","std::convert::From"],"<select::Selected as std::convert::Into<usize>>::into":["into","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","std::convert::Into"],"<select::SelectedOperation<'_> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","std::fmt::Debug"],"<select::SelectedOperation<'_> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))","std::ops::Drop"],"<utils::SpinlockGuard<'_, T> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))","std::ops::Deref"],"<utils::SpinlockGuard<'_, T> as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))","std::ops::DerefMut"],"<utils::SpinlockGuard<'_, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))","std::ops::Drop"],"<waker::SyncWaker as std::ops::Drop>::drop":["drop","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))","std::ops::Drop"],"<waker::Waker as std::ops::Drop>::drop":["drop","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))","std::ops::Drop"],"channel::Receiver::<T>::capacity":["capacity","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Receiver::<T>::is_empty":["is_empty","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Receiver::<T>::is_full":["is_full","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Receiver::<T>::iter":["iter","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Receiver::<T>::len":["len","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Receiver::<T>::recv":["recv","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Receiver::<T>::recv_timeout":["recv_timeout","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Receiver::<T>::same_channel":["same_channel","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Receiver::<T>::try_iter":["try_iter","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Receiver::<T>::try_recv":["try_recv","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Sender::<T>::capacity":["capacity","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Sender::<T>::is_empty":["is_empty","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Sender::<T>::is_full":["is_full","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Sender::<T>::len":["len","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Sender::<T>::same_channel":["same_channel","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Sender::<T>::send":["send","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Sender::<T>::send_timeout":["send_timeout","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::Sender::<T>::try_send":["try_send","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::after":["after","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::bounded":["bounded","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::never":["never","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::read":["read","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::tick":["tick","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::unbounded":["unbounded","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"channel::write":["write","Real(LocalPath(\"crossbeam-channel/src/channel.rs\"))",""],"context::Context::new":["new","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))",""],"context::Context::reset":["reset","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))",""],"context::Context::selected":["selected","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))",""],"context::Context::store_packet":["store_packet","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))",""],"context::Context::thread_id":["thread_id","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))",""],"context::Context::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))",""],"context::Context::unpark":["unpark","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))",""],"context::Context::wait_packet":["wait_packet","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))",""],"context::Context::wait_until":["wait_until","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))",""],"context::Context::with":["with","Real(LocalPath(\"crossbeam-channel/src/context.rs\"))",""],"context::Context::with::CONTEXT::__getit":["__getit","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })",""],"context::Context::with::CONTEXT::__init":["__init","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })",""],"counter::Receiver::<C>::acquire":["acquire","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))",""],"counter::Receiver::<C>::counter":["counter","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))",""],"counter::Receiver::<C>::release":["release","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))",""],"counter::Sender::<C>::acquire":["acquire","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))",""],"counter::Sender::<C>::counter":["counter","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))",""],"counter::Sender::<C>::release":["release","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))",""],"counter::new":["new","Real(LocalPath(\"crossbeam-channel/src/counter.rs\"))",""],"err::RecvTimeoutError::is_disconnected":["is_disconnected","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))",""],"err::RecvTimeoutError::is_timeout":["is_timeout","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))",""],"err::SendError::<T>::into_inner":["into_inner","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))",""],"err::SendTimeoutError::<T>::into_inner":["into_inner","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))",""],"err::SendTimeoutError::<T>::is_disconnected":["is_disconnected","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))",""],"err::SendTimeoutError::<T>::is_timeout":["is_timeout","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))",""],"err::TryRecvError::is_disconnected":["is_disconnected","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))",""],"err::TryRecvError::is_empty":["is_empty","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))",""],"err::TrySendError::<T>::into_inner":["into_inner","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))",""],"err::TrySendError::<T>::is_disconnected":["is_disconnected","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))",""],"err::TrySendError::<T>::is_full":["is_full","Real(LocalPath(\"crossbeam-channel/src/err.rs\"))",""],"flavors::after::Channel::capacity":["capacity","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))",""],"flavors::after::Channel::is_empty":["is_empty","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))",""],"flavors::after::Channel::is_full":["is_full","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))",""],"flavors::after::Channel::len":["len","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))",""],"flavors::after::Channel::new":["new","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))",""],"flavors::after::Channel::read":["read","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))",""],"flavors::after::Channel::recv":["recv","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))",""],"flavors::after::Channel::try_recv":["try_recv","Real(LocalPath(\"crossbeam-channel/src/flavors/after.rs\"))",""],"flavors::array::Channel::<T>::capacity":["capacity","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::disconnect":["disconnect","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::is_disconnected":["is_disconnected","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::is_empty":["is_empty","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::is_full":["is_full","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::len":["len","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::read":["read","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::receiver":["receiver","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::recv":["recv","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::send":["send","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::sender":["sender","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::start_recv":["start_recv","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::start_send":["start_send","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::try_recv":["try_recv","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::try_send":["try_send","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::with_capacity":["with_capacity","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::array::Channel::<T>::write":["write","Real(LocalPath(\"crossbeam-channel/src/flavors/array.rs\"))",""],"flavors::list::Block::<T>::destroy":["destroy","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Block::<T>::new":["new","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Block::<T>::wait_next":["wait_next","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::capacity":["capacity","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::disconnect":["disconnect","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::is_disconnected":["is_disconnected","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::is_empty":["is_empty","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::is_full":["is_full","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::len":["len","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::new":["new","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::read":["read","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::receiver":["receiver","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::recv":["recv","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::send":["send","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::sender":["sender","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::start_recv":["start_recv","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::start_send":["start_send","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::try_recv":["try_recv","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::try_send":["try_send","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Channel::<T>::write":["write","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::list::Slot::<T>::wait_write":["wait_write","Real(LocalPath(\"crossbeam-channel/src/flavors/list.rs\"))",""],"flavors::never::Channel::<T>::capacity":["capacity","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))",""],"flavors::never::Channel::<T>::is_empty":["is_empty","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))",""],"flavors::never::Channel::<T>::is_full":["is_full","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))",""],"flavors::never::Channel::<T>::len":["len","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))",""],"flavors::never::Channel::<T>::new":["new","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))",""],"flavors::never::Channel::<T>::read":["read","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))",""],"flavors::never::Channel::<T>::recv":["recv","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))",""],"flavors::never::Channel::<T>::try_recv":["try_recv","Real(LocalPath(\"crossbeam-channel/src/flavors/never.rs\"))",""],"flavors::tick::Channel::capacity":["capacity","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))",""],"flavors::tick::Channel::is_empty":["is_empty","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))",""],"flavors::tick::Channel::is_full":["is_full","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))",""],"flavors::tick::Channel::len":["len","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))",""],"flavors::tick::Channel::new":["new","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))",""],"flavors::tick::Channel::read":["read","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))",""],"flavors::tick::Channel::recv":["recv","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))",""],"flavors::tick::Channel::try_recv":["try_recv","Real(LocalPath(\"crossbeam-channel/src/flavors/tick.rs\"))",""],"flavors::zero::Channel::<T>::capacity":["capacity","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::disconnect":["disconnect","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::is_empty":["is_empty","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::is_full":["is_full","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::len":["len","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::new":["new","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::read":["read","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::receiver":["receiver","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::recv":["recv","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::send":["send","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::sender":["sender","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::start_recv":["start_recv","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::start_send":["start_send","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::try_recv":["try_recv","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::try_send":["try_send","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Channel::<T>::write":["write","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Packet::<T>::empty_on_heap":["empty_on_heap","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Packet::<T>::empty_on_stack":["empty_on_stack","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Packet::<T>::message_on_stack":["message_on_stack","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"flavors::zero::Packet::<T>::wait_ready":["wait_ready","Real(LocalPath(\"crossbeam-channel/src/flavors/zero.rs\"))",""],"select::Operation::hook":["hook","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::Select::<'a>::new":["new","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::Select::<'a>::ready":["ready","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::Select::<'a>::ready_timeout":["ready_timeout","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::Select::<'a>::recv":["recv","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::Select::<'a>::remove":["remove","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::Select::<'a>::select":["select","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::Select::<'a>::select_timeout":["select_timeout","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::Select::<'a>::send":["send","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::Select::<'a>::try_ready":["try_ready","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::Select::<'a>::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::SelectedOperation::<'_>::index":["index","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::SelectedOperation::<'_>::recv":["recv","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::SelectedOperation::<'_>::send":["send","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::run_ready":["run_ready","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::run_select":["run_select","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::select":["select","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::select_timeout":["select_timeout","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"select::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/select.rs\"))",""],"utils::Spinlock::<T>::lock":["lock","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))",""],"utils::Spinlock::<T>::new":["new","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))",""],"utils::shuffle":["shuffle","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))",""],"utils::shuffle::RNG::__getit":["__getit","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })",""],"utils::shuffle::RNG::__init":["__init","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })",""],"utils::sleep_until":["sleep_until","Real(LocalPath(\"crossbeam-channel/src/utils.rs\"))",""],"waker::SyncWaker::disconnect":["disconnect","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::SyncWaker::new":["new","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::SyncWaker::notify":["notify","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::SyncWaker::register":["register","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::SyncWaker::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::SyncWaker::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::SyncWaker::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::Waker::can_select":["can_select","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::Waker::disconnect":["disconnect","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::Waker::new":["new","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::Waker::notify":["notify","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::Waker::register":["register","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::Waker::register_with_packet":["register_with_packet","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::Waker::try_select":["try_select","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::Waker::unregister":["unregister","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::Waker::unwatch":["unwatch","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::Waker::watch":["watch","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::current_thread_id":["current_thread_id","Real(LocalPath(\"crossbeam-channel/src/waker.rs\"))",""],"waker::current_thread_id::THREAD_ID::__getit":["__getit","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })",""],"waker::current_thread_id::THREAD_ID::__init":["__init","Real(Remapped { local_path: Some(\"/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })",""]},"trait_to_struct":{"select::SelectHandle":["channel::Receiver","channel::Sender","flavors::after::Channel","flavors::array::Receiver","flavors::array::Sender","flavors::list::Receiver","flavors::list::Sender","flavors::never::Channel","flavors::tick::Channel","flavors::zero::Receiver","flavors::zero::Sender"],"std::clone::Clone":["channel::Receiver","channel::Sender","context::Context","err::ReadyTimeoutError","err::RecvError","err::RecvTimeoutError","err::SelectTimeoutError","err::SendError","err::SendTimeoutError","err::TryReadyError","err::TryRecvError","err::TrySelectError","err::TrySendError","select::Operation","select::Select","select::Selected","select::Timeout"],"std::cmp::Eq":["err::ReadyTimeoutError","err::RecvError","err::RecvTimeoutError","err::SelectTimeoutError","err::SendError","err::SendTimeoutError","err::TryReadyError","err::TryRecvError","err::TrySelectError","err::TrySendError","select::Operation","select::Selected","select::Timeout"],"std::cmp::PartialEq":["counter::Receiver","counter::Sender","err::ReadyTimeoutError","err::RecvError","err::RecvTimeoutError","err::SelectTimeoutError","err::SendError","err::SendTimeoutError","err::TryReadyError","err::TryRecvError","err::TrySelectError","err::TrySendError","select::Operation","select::Selected","select::Timeout"],"std::convert::From":["err::RecvTimeoutError","err::SendTimeoutError","err::TryRecvError","err::TrySendError","select::Selected"],"std::convert::Into":["select::Selected"],"std::default::Default":["flavors::array::ArrayToken","flavors::list::ListToken","select::Select","select::Token"],"std::error::Error":["err::RecvError","err::RecvTimeoutError","err::SelectTimeoutError","err::SendError","err::SendTimeoutError","err::TryRecvError","err::TrySelectError","err::TrySendError"],"std::fmt::Debug":["channel::IntoIter","channel::Iter","channel::Receiver","channel::Sender","channel::TryIter","context::Context","context::Inner","err::ReadyTimeoutError","err::RecvError","err::RecvTimeoutError","err::SelectTimeoutError","err::SendError","err::SendTimeoutError","err::TryReadyError","err::TryRecvError","err::TrySelectError","err::TrySendError","flavors::array::ArrayToken","flavors::list::ListToken","flavors::list::Position","select::Operation","select::Select","select::Selected","select::SelectedOperation","select::Token"],"std::fmt::Display":["err::RecvError","err::RecvTimeoutError","err::SelectTimeoutError","err::SendError","err::SendTimeoutError","err::TryRecvError","err::TrySelectError","err::TrySendError"],"std::iter::FusedIterator":["channel::IntoIter","channel::Iter"],"std::iter::IntoIterator":["channel::Receiver"],"std::iter::Iterator":["channel::IntoIter","channel::Iter","channel::TryIter"],"std::marker::Copy":["err::ReadyTimeoutError","err::RecvError","err::RecvTimeoutError","err::SelectTimeoutError","err::SendError","err::SendTimeoutError","err::TryReadyError","err::TryRecvError","err::TrySelectError","err::TrySendError","select::Operation","select::Selected","select::Timeout"],"std::marker::Send":["channel::Receiver","channel::Sender","select::Select"],"std::marker::StructuralEq":["err::ReadyTimeoutError","err::RecvError","err::RecvTimeoutError","err::SelectTimeoutError","err::SendError","err::SendTimeoutError","err::TryReadyError","err::TryRecvError","err::TrySelectError","err::TrySendError","select::Operation","select::Selected","select::Timeout"],"std::marker::StructuralPartialEq":["err::ReadyTimeoutError","err::RecvError","err::RecvTimeoutError","err::SelectTimeoutError","err::SendError","err::SendTimeoutError","err::TryReadyError","err::TryRecvError","err::TrySelectError","err::TrySendError","select::Operation","select::Selected","select::Timeout"],"std::marker::Sync":["channel::Receiver","channel::Sender","select::Select"],"std::ops::Deref":["counter::Receiver","counter::Sender","utils::SpinlockGuard"],"std::ops::DerefMut":["utils::SpinlockGuard"],"std::ops::Drop":["channel::Receiver","channel::Sender","flavors::array::Channel","flavors::list::Channel","select::SelectedOperation","utils::SpinlockGuard","waker::SyncWaker","waker::Waker"],"std::panic::RefUnwindSafe":["channel::Receiver","channel::Sender"],"std::panic::UnwindSafe":["channel::Receiver","channel::Sender"]},"type_to_def_path":{"channel::IntoIter<T>":"channel::IntoIter","channel::Iter<'a, T>":"channel::Iter","channel::Receiver<T>":"channel::Receiver","channel::ReceiverFlavor<T>":"channel::ReceiverFlavor","channel::Sender<T>":"channel::Sender","channel::SenderFlavor<T>":"channel::SenderFlavor","channel::TryIter<'a, T>":"channel::TryIter","context::Context":"context::Context","context::Inner":"context::Inner","counter::Counter<C>":"counter::Counter","counter::Receiver<C>":"counter::Receiver","counter::Sender<C>":"counter::Sender","err::ReadyTimeoutError":"err::ReadyTimeoutError","err::RecvError":"err::RecvError","err::RecvTimeoutError":"err::RecvTimeoutError","err::SelectTimeoutError":"err::SelectTimeoutError","err::SendError<T>":"err::SendError","err::SendTimeoutError<T>":"err::SendTimeoutError","err::TryReadyError":"err::TryReadyError","err::TryRecvError":"err::TryRecvError","err::TrySelectError":"err::TrySelectError","err::TrySendError<T>":"err::TrySendError","flavors::after::Channel":"flavors::after::Channel","flavors::array::ArrayToken":"flavors::array::ArrayToken","flavors::array::Channel<T>":"flavors::array::Channel","flavors::array::Receiver<'a, T>":"flavors::array::Receiver","flavors::array::Sender<'a, T>":"flavors::array::Sender","flavors::array::Slot<T>":"flavors::array::Slot","flavors::list::Block<T>":"flavors::list::Block","flavors::list::Channel<T>":"flavors::list::Channel","flavors::list::ListToken":"flavors::list::ListToken","flavors::list::Position<T>":"flavors::list::Position","flavors::list::Receiver<'a, T>":"flavors::list::Receiver","flavors::list::Sender<'a, T>":"flavors::list::Sender","flavors::list::Slot<T>":"flavors::list::Slot","flavors::never::Channel<T>":"flavors::never::Channel","flavors::tick::Channel":"flavors::tick::Channel","flavors::zero::Channel<T>":"flavors::zero::Channel","flavors::zero::Inner":"flavors::zero::Inner","flavors::zero::Packet<T>":"flavors::zero::Packet","flavors::zero::Receiver<'a, T>":"flavors::zero::Receiver","flavors::zero::Sender<'a, T>":"flavors::zero::Sender","select::Operation":"select::Operation","select::Select<'a>":"select::Select","select::Selected":"select::Selected","select::SelectedOperation<'a>":"select::SelectedOperation","select::Timeout":"select::Timeout","select::Token":"select::Token","utils::Spinlock<T>":"utils::Spinlock","utils::SpinlockGuard<'a, T>":"utils::SpinlockGuard","waker::Entry":"waker::Entry","waker::SyncWaker":"waker::SyncWaker","waker::Waker":"waker::Waker"}}