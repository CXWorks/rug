{"dependencies":{"simple::RandomAccessSimple":["simple::RandomAccessSimple","std::marker::Sized"],"simple::RandomAccessSimple::<R>::get":["simple::RandomAccessSimple","std::marker::Sized","std::result::Result"],"simple::RandomAccessSimple::<R>::is_empty":["simple::RandomAccessSimple","std::marker::Sized"],"simple::RandomAccessSimple::<R>::len":["simple::RandomAccessSimple","std::marker::Sized"],"simple::RandomAccessSimple::<R>::open":["std::marker::Sized","std::result::Result"],"simple::RandomAccessSimple::<W>::create":["csv::Reader","std::io::Read","std::marker::Sized","std::result::Result"]},"glob_path_import":{},"self_to_fn":{"simple::RandomAccessSimple":["impl<R: io::Read + io::Seek> RandomAccessSimple<R> {\n    /// Open an existing simple CSV index.\n    ///\n    /// The reader given must be seekable and should contain an index written\n    /// by `RandomAccessSimple::create`.\n    ///\n    /// # Example\n    ///\n    /// This example shows how to create a simple random access index, open it\n    /// and query the number of records in the index.\n    ///\n    /// ```\n    /// use std::io;\n    /// use csv_index::RandomAccessSimple;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> csv::Result<()> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \";\n    ///     let mut rdr = csv::Reader::from_reader(data.as_bytes());\n    ///     let mut wtr = io::Cursor::new(vec![]);\n    ///     RandomAccessSimple::create(&mut rdr, &mut wtr)?;\n    ///\n    ///     let idx = RandomAccessSimple::open(wtr)?;\n    ///     assert_eq!(idx.len(), 3);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn open(mut rdr: R) -> csv::Result<RandomAccessSimple<R>> {\n        rdr.seek(io::SeekFrom::End(-8))?;\n        let len = rdr.read_u64::<BigEndian>()?;\n        Ok(RandomAccessSimple { rdr: rdr, len: len })\n    }\n\n    /// Get the position of the record at index `i`.\n    ///\n    /// The first record has index `0`.\n    ///\n    /// If the position returned is used to seek the CSV reader that was used\n    /// to create this index, then the next record read by the CSV reader will\n    /// be the `i`th record.\n    ///\n    /// Note that since this index does not store the line number of each\n    /// record, the position returned will always have a line number equivalent\n    /// to `1`. This in turn will cause the CSV reader to report all subsequent\n    /// line numbers incorrectly.\n    ///\n    /// # Example\n    ///\n    /// This example shows how to create a simple random access index, open it\n    /// and use it to seek a CSV reader to read an arbitrary record.\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::io;\n    /// use csv_index::RandomAccessSimple;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \";\n    ///     // Note that we wrap our CSV data in an io::Cursor, which makes it\n    ///     // seekable. If you're opening CSV data from a file, then this is\n    ///     // not needed since a `File` is already seekable.\n    ///     let mut rdr = csv::Reader::from_reader(io::Cursor::new(data));\n    ///     let mut wtr = io::Cursor::new(vec![]);\n    ///     RandomAccessSimple::create(&mut rdr, &mut wtr)?;\n    ///\n    ///     // Open the index we just created, get the position of the last\n    ///     // record and seek the CSV reader.\n    ///     let mut idx = RandomAccessSimple::open(wtr)?;\n    ///     let pos = idx.get(2)?;\n    ///     rdr.seek(pos)?;\n    ///\n    ///     // Read the next record.\n    ///     if let Some(result) = rdr.records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Concord\", \"United States\", \"42695\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn get(&mut self, i: u64) -> csv::Result<csv::Position> {\n        if i >= self.len {\n            let msg = format!(\n                \"invalid record index {} (there are {} records)\",\n                i, self.len\n            );\n            let err = io::Error::new(io::ErrorKind::Other, msg);\n            return Err(csv::Error::from(err));\n        }\n        self.rdr.seek(io::SeekFrom::Start(i * 8))?;\n        let offset = self.rdr.read_u64::<BigEndian>()?;\n        let mut pos = csv::Position::new();\n        pos.set_byte(offset).set_record(i);\n        Ok(pos)\n    }\n\n    /// Return the number of records (including the header record) in this\n    /// index.\n    pub fn len(&self) -> u64 {\n        self.len\n    }\n\n    /// Return true if and only if this index has zero records.\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n}","impl<W: io::Write> RandomAccessSimple<W> {\n    /// Write a simple index to the given writer for the given CSV reader.\n    ///\n    /// If there was a problem reading CSV records or writing to the given\n    /// writer, then an error is returned.\n    ///\n    /// That the given CSV reader is read as given until EOF. The index\n    /// produced includes all records, including the first record even if the\n    /// CSV reader is configured to interpret the first record as a header\n    /// record.\n    ///\n    /// # Example: in memory index\n    ///\n    /// This example shows how to create a simple random access index, open it\n    /// and query the number of records in the index.\n    ///\n    /// ```\n    /// use std::io;\n    /// use csv_index::RandomAccessSimple;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> csv::Result<()> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \";\n    ///     let mut rdr = csv::Reader::from_reader(data.as_bytes());\n    ///     let mut wtr = io::Cursor::new(vec![]);\n    ///     RandomAccessSimple::create(&mut rdr, &mut wtr)?;\n    ///\n    ///     let idx = RandomAccessSimple::open(wtr)?;\n    ///     assert_eq!(idx.len(), 3);\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Example: file backed index\n    ///\n    /// This is like the previous example, but instead of creating the index\n    /// in memory with `std::io::Cursor`, we write the index to a file.\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io;\n    /// use csv_index::RandomAccessSimple;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> csv::Result<()> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \";\n    ///     let mut rdr = csv::Reader::from_reader(data.as_bytes());\n    ///     let mut wtr = File::create(\"data.csv.idx\")?;\n    ///     RandomAccessSimple::create(&mut rdr, &mut wtr)?;\n    ///\n    ///     let fileidx = File::open(\"data.csv.idx\")?;\n    ///     let idx = RandomAccessSimple::open(fileidx)?;\n    ///     assert_eq!(idx.len(), 3);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn create<R: io::Read>(\n        rdr: &mut csv::Reader<R>,\n        mut wtr: W,\n    ) -> csv::Result<()> {\n        // If the reader is configured to read a header, then read that\n        // first. (The CSV reader otherwise won't yield the header record\n        // when calling `read_byte_record`.)\n        let mut len = 0;\n        if rdr.has_headers() {\n            let header = rdr.byte_headers()?;\n            if !header.is_empty() {\n                let pos = header.position().expect(\"position on header row\");\n                wtr.write_u64::<BigEndian>(pos.byte())?;\n                len += 1;\n            }\n        }\n        let mut record = csv::ByteRecord::new();\n        while rdr.read_byte_record(&mut record)? {\n            let pos = record.position().expect(\"position on row\");\n            wtr.write_u64::<BigEndian>(pos.byte())?;\n            len += 1;\n        }\n        wtr.write_u64::<BigEndian>(len)?;\n        Ok(())\n    }\n}"]},"single_path_import":{"simple::RandomAccessSimple":"RandomAccessSimple"},"srcs":{"simple::RandomAccessSimple":["/// A simple index for random access to CSV records.\n///\n/// This index permits seeking to the start of any CSV record with a constant\n/// number of operations.\n///\n/// The format of the index is simplistic and amenable to serializing to disk.\n/// It consists of exactly `N+1` 64 bit big-endian integers, where `N` is the\n/// number of records in the CSV data that is indexed. Each `i`th integer\n/// corresponds to the approximate byte offset where the `i`th record in the\n/// CSV data begins. One additional integer is written to the end of the index\n/// which indicates the total number of records in the CSV data.\n///\n/// This indexing format does not store the line numbers of CSV records, so\n/// using the positions returned by this index to seek a CSV reader will likely\n/// cause any future line numbers reported by that reader to be incorrect.\n///\n/// This format will never change.\n///\n/// N.B. The format of this indexing scheme matches the format of the old the\n/// `csv::Indexed` type in pre-1.0 versions of the `csv` crate.\npub struct RandomAccessSimple<R> {\n    rdr: R,\n    len: u64,\n}","Real(LocalPath(\"csv-index/src/simple.rs\"))"],"simple::RandomAccessSimple::<R>::get":["/// Get the position of the record at index `i`.\n///\n/// The first record has index `0`.\n///\n/// If the position returned is used to seek the CSV reader that was used\n/// to create this index, then the next record read by the CSV reader will\n/// be the `i`th record.\n///\n/// Note that since this index does not store the line number of each\n/// record, the position returned will always have a line number equivalent\n/// to `1`. This in turn will cause the CSV reader to report all subsequent\n/// line numbers incorrectly.\n///\n/// # Example\n///\n/// This example shows how to create a simple random access index, open it\n/// and use it to seek a CSV reader to read an arbitrary record.\n///\n/// ```\n/// use std::error::Error;\n/// use std::io;\n/// use csv_index::RandomAccessSimple;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \";\n///     // Note that we wrap our CSV data in an io::Cursor, which makes it\n///     // seekable. If you're opening CSV data from a file, then this is\n///     // not needed since a `File` is already seekable.\n///     let mut rdr = csv::Reader::from_reader(io::Cursor::new(data));\n///     let mut wtr = io::Cursor::new(vec![]);\n///     RandomAccessSimple::create(&mut rdr, &mut wtr)?;\n///\n///     // Open the index we just created, get the position of the last\n///     // record and seek the CSV reader.\n///     let mut idx = RandomAccessSimple::open(wtr)?;\n///     let pos = idx.get(2)?;\n///     rdr.seek(pos)?;\n///\n///     // Read the next record.\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Concord\", \"United States\", \"42695\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn get(&mut self, i: u64) -> csv::Result<csv::Position>{\n        if i >= self.len {\n            let msg = format!(\n                \"invalid record index {} (there are {} records)\",\n                i, self.len\n            );\n            let err = io::Error::new(io::ErrorKind::Other, msg);\n            return Err(csv::Error::from(err));\n        }\n        self.rdr.seek(io::SeekFrom::Start(i * 8))?;\n        let offset = self.rdr.read_u64::<BigEndian>()?;\n        let mut pos = csv::Position::new();\n        pos.set_byte(offset).set_record(i);\n        Ok(pos)\n    }","Real(LocalPath(\"csv-index/src/simple.rs\"))"],"simple::RandomAccessSimple::<R>::is_empty":["/// Return true if and only if this index has zero records.\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"csv-index/src/simple.rs\"))"],"simple::RandomAccessSimple::<R>::len":["/// Return the number of records (including the header record) in this\n/// index.\npub fn len(&self) -> u64{\n        self.len\n    }","Real(LocalPath(\"csv-index/src/simple.rs\"))"],"simple::RandomAccessSimple::<R>::open":["/// Open an existing simple CSV index.\n///\n/// The reader given must be seekable and should contain an index written\n/// by `RandomAccessSimple::create`.\n///\n/// # Example\n///\n/// This example shows how to create a simple random access index, open it\n/// and query the number of records in the index.\n///\n/// ```\n/// use std::io;\n/// use csv_index::RandomAccessSimple;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> csv::Result<()> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \";\n///     let mut rdr = csv::Reader::from_reader(data.as_bytes());\n///     let mut wtr = io::Cursor::new(vec![]);\n///     RandomAccessSimple::create(&mut rdr, &mut wtr)?;\n///\n///     let idx = RandomAccessSimple::open(wtr)?;\n///     assert_eq!(idx.len(), 3);\n///     Ok(())\n/// }\n/// ```\npub fn open(mut rdr: R) -> csv::Result<RandomAccessSimple<R>>{\n        rdr.seek(io::SeekFrom::End(-8))?;\n        let len = rdr.read_u64::<BigEndian>()?;\n        Ok(RandomAccessSimple { rdr: rdr, len: len })\n    }","Real(LocalPath(\"csv-index/src/simple.rs\"))"],"simple::RandomAccessSimple::<W>::create":["/// Write a simple index to the given writer for the given CSV reader.\n///\n/// If there was a problem reading CSV records or writing to the given\n/// writer, then an error is returned.\n///\n/// That the given CSV reader is read as given until EOF. The index\n/// produced includes all records, including the first record even if the\n/// CSV reader is configured to interpret the first record as a header\n/// record.\n///\n/// # Example: in memory index\n///\n/// This example shows how to create a simple random access index, open it\n/// and query the number of records in the index.\n///\n/// ```\n/// use std::io;\n/// use csv_index::RandomAccessSimple;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> csv::Result<()> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \";\n///     let mut rdr = csv::Reader::from_reader(data.as_bytes());\n///     let mut wtr = io::Cursor::new(vec![]);\n///     RandomAccessSimple::create(&mut rdr, &mut wtr)?;\n///\n///     let idx = RandomAccessSimple::open(wtr)?;\n///     assert_eq!(idx.len(), 3);\n///     Ok(())\n/// }\n/// ```\n///\n/// # Example: file backed index\n///\n/// This is like the previous example, but instead of creating the index\n/// in memory with `std::io::Cursor`, we write the index to a file.\n///\n/// ```no_run\n/// use std::fs::File;\n/// use std::io;\n/// use csv_index::RandomAccessSimple;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> csv::Result<()> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \";\n///     let mut rdr = csv::Reader::from_reader(data.as_bytes());\n///     let mut wtr = File::create(\"data.csv.idx\")?;\n///     RandomAccessSimple::create(&mut rdr, &mut wtr)?;\n///\n///     let fileidx = File::open(\"data.csv.idx\")?;\n///     let idx = RandomAccessSimple::open(fileidx)?;\n///     assert_eq!(idx.len(), 3);\n///     Ok(())\n/// }\n/// ```\npub fn create<R: io::Read>(\n        rdr: &mut csv::Reader<R>,\n        mut wtr: W,\n    ) -> csv::Result<()>{\n        // If the reader is configured to read a header, then read that\n        // first. (The CSV reader otherwise won't yield the header record\n        // when calling `read_byte_record`.)\n        let mut len = 0;\n        if rdr.has_headers() {\n            let header = rdr.byte_headers()?;\n            if !header.is_empty() {\n                let pos = header.position().expect(\"position on header row\");\n                wtr.write_u64::<BigEndian>(pos.byte())?;\n                len += 1;\n            }\n        }\n        let mut record = csv::ByteRecord::new();\n        while rdr.read_byte_record(&mut record)? {\n            let pos = record.position().expect(\"position on row\");\n            wtr.write_u64::<BigEndian>(pos.byte())?;\n            len += 1;\n        }\n        wtr.write_u64::<BigEndian>(len)?;\n        Ok(())\n    }","Real(LocalPath(\"csv-index/src/simple.rs\"))"]},"struct_constructor":{"bool":["is_empty"],"csv::Position":["get"],"simple::RandomAccessSimple":["open"],"u64":["len"]},"struct_to_trait":{},"targets":{"simple::RandomAccessSimple::<R>::get":["get","Real(LocalPath(\"csv-index/src/simple.rs\"))",""],"simple::RandomAccessSimple::<R>::is_empty":["is_empty","Real(LocalPath(\"csv-index/src/simple.rs\"))",""],"simple::RandomAccessSimple::<R>::len":["len","Real(LocalPath(\"csv-index/src/simple.rs\"))",""],"simple::RandomAccessSimple::<R>::open":["open","Real(LocalPath(\"csv-index/src/simple.rs\"))",""],"simple::RandomAccessSimple::<W>::create":["create","Real(LocalPath(\"csv-index/src/simple.rs\"))",""]},"trait_to_struct":{},"type_to_def_path":{"simple::RandomAccessSimple<R>":"simple::RandomAccessSimple"}}