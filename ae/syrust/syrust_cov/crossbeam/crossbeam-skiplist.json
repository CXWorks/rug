{"dependencies":{"<&'a map::SkipMap<K, V> as std::iter::IntoIterator>::into_iter":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","map::SkipMap","std::marker::Sized","std::option::Option"],"<&'a set::SkipSet<T> as std::iter::IntoIterator>::into_iter":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","map::SkipMap","set::Iter","set::SkipSet","std::marker::Sized","std::option::Option"],"<base::Entry<'_, '_, K, V> as std::fmt::Debug>::fmt":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicUsize"],"<base::Entry<'a, 'g, K, V> as std::clone::Clone>::clone":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"<base::Head<K, V> as std::ops::Deref>::deref":["base::Head","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized"],"<base::IntoIter<K, V> as std::fmt::Debug>::fmt":["base::IntoIter","base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicUsize"],"<base::IntoIter<K, V> as std::iter::Iterator>::next":["base::IntoIter","base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"<base::IntoIter<K, V> as std::ops::Drop>::drop":["base::IntoIter","base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized","std::sync::atomic::AtomicUsize"],"<base::Iter<'_, '_, K, V> as std::fmt::Debug>::fmt":["base::Head","base::Iter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<base::Iter<'a, 'g, K, V> as std::iter::DoubleEndedIterator>::next_back":["base::Head","base::Iter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"<base::Iter<'a, 'g, K, V> as std::iter::Iterator>::next":["base::Head","base::Iter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"<base::Node<K, V> as std::fmt::Debug>::fmt":["base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicUsize"],"<base::Range<'_, '_, Q, R, K, V> as std::fmt::Debug>::fmt":["base::Head","base::Range","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option","std::result::Result"],"<base::Range<'a, 'g, Q, R, K, V> as std::iter::DoubleEndedIterator>::next_back":["base::Head","base::Range","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"<base::Range<'a, 'g, Q, R, K, V> as std::iter::Iterator>::next":["base::Head","base::Range","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"<base::RefEntry<'_, K, V> as std::fmt::Debug>::fmt":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicUsize"],"<base::RefEntry<'a, K, V> as std::clone::Clone>::clone":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"<base::RefIter<'_, K, V> as std::fmt::Debug>::fmt":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<base::RefRange<'_, Q, R, K, V> as std::fmt::Debug>::fmt":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option","std::result::Result"],"<base::SkipList<K, V> as std::fmt::Debug>::fmt":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<base::SkipList<K, V> as std::iter::IntoIterator>::into_iter":["base::Head","base::IntoIter","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"<base::SkipList<K, V> as std::ops::Drop>::drop":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized"],"<base::Tower<K, V> as std::ops::Index<usize>>::index":["base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized"],"<map::Entry<'_, K, V> as std::fmt::Debug>::fmt":["map::Entry","std::fmt::Formatter","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"<map::Entry<'_, K, V> as std::ops::Drop>::drop":["map::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"<map::Entry<'a, K, V> as std::clone::Clone>::clone":["map::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"<map::IntoIter<K, V> as std::fmt::Debug>::fmt":["base::IntoIter","base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","map::IntoIter","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicUsize"],"<map::IntoIter<K, V> as std::iter::Iterator>::next":["base::IntoIter","base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","map::IntoIter","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"<map::Iter<'_, K, V> as std::fmt::Debug>::fmt":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<map::Iter<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","std::marker::Sized","std::option::Option"],"<map::Iter<'a, K, V> as std::iter::Iterator>::next":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","std::marker::Sized","std::option::Option"],"<map::Range<'_, Q, R, K, V> as std::fmt::Debug>::fmt":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Range","std::borrow::Borrow","std::cmp::Ord","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option","std::result::Result"],"<map::Range<'a, Q, R, K, V> as std::iter::DoubleEndedIterator>::next_back":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Range","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"<map::Range<'a, Q, R, K, V> as std::iter::Iterator>::next":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Range","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"<map::SkipMap<K, V> as std::default::Default>::default":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::marker::Sized"],"<map::SkipMap<K, V> as std::fmt::Debug>::fmt":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<map::SkipMap<K, V> as std::iter::FromIterator<(K, V)>>::from_iter":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::iter::IntoIterator","std::marker::Sized"],"<map::SkipMap<K, V> as std::iter::IntoIterator>::into_iter":["base::Head","base::IntoIter","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::IntoIter","map::SkipMap","std::marker::Sized","std::sync::atomic::AtomicUsize"],"<set::Entry<'_, T> as std::fmt::Debug>::fmt":["map::Entry","set::Entry","std::fmt::Formatter","std::marker::Sized","std::mem::ManuallyDrop","std::result::Result"],"<set::Entry<'a, T> as std::clone::Clone>::clone":["map::Entry","set::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"<set::IntoIter<T> as std::fmt::Debug>::fmt":["base::IntoIter","base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","map::IntoIter","set::IntoIter","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicUsize"],"<set::IntoIter<T> as std::iter::Iterator>::next":["base::IntoIter","base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","map::IntoIter","set::IntoIter","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"<set::Iter<'_, T> as std::fmt::Debug>::fmt":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","set::Iter","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<set::Iter<'a, T> as std::iter::DoubleEndedIterator>::next_back":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","set::Iter","std::marker::Sized","std::option::Option"],"<set::Iter<'a, T> as std::iter::Iterator>::next":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","set::Iter","std::marker::Sized","std::option::Option"],"<set::Range<'_, Q, R, T> as std::fmt::Debug>::fmt":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Range","set::Range","std::borrow::Borrow","std::cmp::Ord","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option","std::result::Result"],"<set::Range<'a, Q, R, T> as std::iter::DoubleEndedIterator>::next_back":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Range","set::Range","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"<set::Range<'a, Q, R, T> as std::iter::Iterator>::next":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Range","set::Range","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"<set::SkipSet<T> as std::default::Default>::default":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::marker::Sized"],"<set::SkipSet<T> as std::fmt::Debug>::fmt":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<set::SkipSet<T> as std::iter::FromIterator<T>>::from_iter":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::iter::IntoIterator","std::marker::Sized"],"<set::SkipSet<T> as std::iter::IntoIterator>::into_iter":["base::Head","base::IntoIter","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::IntoIter","map::SkipMap","set::IntoIter","set::SkipSet","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Entry":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Entry::<'a, 'g, K, V>::is_removed":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Entry::<'a, 'g, K, V>::key":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Entry::<'a, 'g, K, V>::move_next":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Entry::<'a, 'g, K, V>::move_prev":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Entry::<'a, 'g, K, V>::next":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"base::Entry::<'a, 'g, K, V>::pin":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"base::Entry::<'a, 'g, K, V>::prev":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"base::Entry::<'a, 'g, K, V>::remove":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Entry::<'a, 'g, K, V>::skiplist":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Entry::<'a, 'g, K, V>::value":["base::Entry","base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Head":["base::Head","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized"],"base::Head::<K, V>::new":["base::Head","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized"],"base::HotData":["base::HotData","std::sync::atomic::AtomicUsize"],"base::IntoIter":["base::IntoIter","base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Iter":["base::Head","base::Iter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"base::Node":["base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Node::<K, V>::alloc":["base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Node::<K, V>::dealloc":["base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Node::<K, V>::decrement":["base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Node::<K, V>::decrement_with_pin":["base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::ops::FnOnce","std::sync::atomic::AtomicUsize"],"base::Node::<K, V>::finalize":["base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Node::<K, V>::get_layout":["std::alloc::Layout"],"base::Node::<K, V>::height":["base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Node::<K, V>::is_removed":["base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Node::<K, V>::mark_tower":["base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Node::<K, V>::try_increment":["base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::Position":["base::Position","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","crossbeam_epoch::Shared","std::marker::Sized","std::option::Option"],"base::Range":["base::Head","base::Range","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"base::RefEntry":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'_, K, V>::remove":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'a, K, V>::is_removed":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'a, K, V>::key":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'a, K, V>::move_next":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'a, K, V>::move_prev":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'a, K, V>::next":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'a, K, V>::prev":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'a, K, V>::release":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'a, K, V>::release_with_pin":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::ops::FnOnce","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'a, K, V>::skiplist":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'a, K, V>::try_acquire":["base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"base::RefEntry::<'a, K, V>::value":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::RefIter":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"base::RefIter::<'a, K, V>::next":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"base::RefIter::<'a, K, V>::next_back":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"base::RefRange":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"base::RefRange::<'a, Q, R, K, V>::next":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"base::RefRange::<'a, Q, R, K, V>::next_back":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"base::SkipList":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized"],"base::SkipList::<K, V>::back":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::check_guard":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized"],"base::SkipList::<K, V>::clear":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized"],"base::SkipList::<K, V>::contains_key":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::Sized"],"base::SkipList::<K, V>::front":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::get":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::get_or_insert":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::SkipList::<K, V>::help_unlink":["base::Head","base::Node","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_epoch::Shared","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"base::SkipList::<K, V>::insert":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::SkipList::<K, V>::insert_internal":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::sync::atomic::AtomicUsize"],"base::SkipList::<K, V>::is_empty":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized"],"base::SkipList::<K, V>::iter":["base::Head","base::Iter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::len":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized"],"base::SkipList::<K, V>::lower_bound":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::collections::Bound","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::new":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized"],"base::SkipList::<K, V>::next_node":["base::Head","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::collections::Bound","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::pop_back":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::pop_front":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::random_height":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized"],"base::SkipList::<K, V>::range":["base::Head","base::Range","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"base::SkipList::<K, V>::ref_iter":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::ref_range":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"base::SkipList::<K, V>::remove":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::search_bound":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::collections::Bound","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::search_position":["base::Head","base::Position","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_epoch::Shared","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::marker::Sized","std::option::Option"],"base::SkipList::<K, V>::upper_bound":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Guard","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","std::borrow::Borrow","std::cmp::Ord","std::collections::Bound","std::marker::Sized","std::option::Option"],"base::Tower":["base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","std::marker::Sized"],"base::above_lower_bound":["std::cmp::Ord","std::collections::Bound","std::marker::Sized"],"base::below_upper_bound":["std::cmp::Ord","std::collections::Bound","std::marker::Sized"],"base::try_pin_loop":["std::marker::Sized","std::ops::FnMut","std::option::Option"],"map::Entry":["map::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"map::Entry::<'_, K, V>::remove":["map::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"map::Entry::<'a, K, V>::is_removed":["map::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"map::Entry::<'a, K, V>::key":["map::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"map::Entry::<'a, K, V>::move_next":["map::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"map::Entry::<'a, K, V>::move_prev":["map::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"map::Entry::<'a, K, V>::new":["base::Head","base::Node","base::RefEntry","base::SkipList","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Entry","std::marker::Sized","std::mem::ManuallyDrop","std::sync::atomic::AtomicUsize"],"map::Entry::<'a, K, V>::next":["map::Entry","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"map::Entry::<'a, K, V>::prev":["map::Entry","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"map::Entry::<'a, K, V>::value":["map::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"map::IntoIter":["base::IntoIter","base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","map::IntoIter","std::marker::Sized","std::sync::atomic::AtomicUsize"],"map::Iter":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","std::marker::Sized","std::option::Option"],"map::Range":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Range","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"map::SkipMap":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::marker::Sized"],"map::SkipMap::<K, V>::back":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::marker::Sized","std::option::Option"],"map::SkipMap::<K, V>::clear":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::marker::Sized"],"map::SkipMap::<K, V>::contains_key":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::borrow::Borrow","std::cmp::Ord","std::marker::Sized"],"map::SkipMap::<K, V>::front":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::marker::Sized","std::option::Option"],"map::SkipMap::<K, V>::get":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::borrow::Borrow","std::cmp::Ord","std::marker::Sized","std::option::Option"],"map::SkipMap::<K, V>::get_or_insert":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Entry","map::SkipMap","std::marker::Sized","std::mem::ManuallyDrop"],"map::SkipMap::<K, V>::insert":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Entry","map::SkipMap","std::marker::Sized","std::mem::ManuallyDrop"],"map::SkipMap::<K, V>::is_empty":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::marker::Sized"],"map::SkipMap::<K, V>::iter":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","map::SkipMap","std::marker::Sized","std::option::Option"],"map::SkipMap::<K, V>::len":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::marker::Sized"],"map::SkipMap::<K, V>::lower_bound":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::borrow::Borrow","std::cmp::Ord","std::collections::Bound","std::marker::Sized","std::option::Option"],"map::SkipMap::<K, V>::new":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::marker::Sized"],"map::SkipMap::<K, V>::pop_back":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::marker::Sized","std::option::Option"],"map::SkipMap::<K, V>::pop_front":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::marker::Sized","std::option::Option"],"map::SkipMap::<K, V>::range":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Range","map::SkipMap","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"map::SkipMap::<K, V>::remove":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::borrow::Borrow","std::cmp::Ord","std::marker::Sized","std::option::Option"],"map::SkipMap::<K, V>::upper_bound":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","std::borrow::Borrow","std::cmp::Ord","std::collections::Bound","std::marker::Sized","std::option::Option"],"set::Entry":["map::Entry","set::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"set::Entry::<'_, T>::remove":["map::Entry","set::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"set::Entry::<'a, T>::is_removed":["map::Entry","set::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"set::Entry::<'a, T>::move_next":["map::Entry","set::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"set::Entry::<'a, T>::move_prev":["map::Entry","set::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"set::Entry::<'a, T>::new":["map::Entry","set::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"set::Entry::<'a, T>::next":["map::Entry","set::Entry","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"set::Entry::<'a, T>::prev":["map::Entry","set::Entry","std::marker::Sized","std::mem::ManuallyDrop","std::option::Option"],"set::Entry::<'a, T>::value":["map::Entry","set::Entry","std::marker::Sized","std::mem::ManuallyDrop"],"set::IntoIter":["base::IntoIter","base::Node","base::Tower","crossbeam_epoch::Atomic","crossbeam_epoch::Pointable","map::IntoIter","set::IntoIter","std::marker::Sized","std::sync::atomic::AtomicUsize"],"set::Iter":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","set::Iter","std::marker::Sized","std::option::Option"],"set::Range":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Range","set::Range","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"set::SkipSet":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::marker::Sized"],"set::SkipSet::<T>::back":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::marker::Sized","std::option::Option"],"set::SkipSet::<T>::clear":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::marker::Sized"],"set::SkipSet::<T>::contains":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::borrow::Borrow","std::cmp::Ord","std::marker::Sized"],"set::SkipSet::<T>::front":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::marker::Sized","std::option::Option"],"set::SkipSet::<T>::get":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::borrow::Borrow","std::cmp::Ord","std::marker::Sized","std::option::Option"],"set::SkipSet::<T>::get_or_insert":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Entry","map::SkipMap","set::Entry","set::SkipSet","std::marker::Sized","std::mem::ManuallyDrop"],"set::SkipSet::<T>::insert":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Entry","map::SkipMap","set::Entry","set::SkipSet","std::marker::Sized","std::mem::ManuallyDrop"],"set::SkipSet::<T>::is_empty":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::marker::Sized"],"set::SkipSet::<T>::iter":["base::Head","base::RefIter","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Iter","map::SkipMap","set::Iter","set::SkipSet","std::marker::Sized","std::option::Option"],"set::SkipSet::<T>::len":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::marker::Sized"],"set::SkipSet::<T>::lower_bound":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::borrow::Borrow","std::cmp::Ord","std::collections::Bound","std::marker::Sized","std::option::Option"],"set::SkipSet::<T>::new":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::marker::Sized"],"set::SkipSet::<T>::pop_back":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::marker::Sized","std::option::Option"],"set::SkipSet::<T>::pop_front":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::marker::Sized","std::option::Option"],"set::SkipSet::<T>::range":["base::Head","base::RefRange","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::Range","map::SkipMap","set::Range","set::SkipSet","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::option::Option"],"set::SkipSet::<T>::remove":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::borrow::Borrow","std::cmp::Ord","std::marker::Sized","std::option::Option"],"set::SkipSet::<T>::upper_bound":["base::Head","base::SkipList","crossbeam_epoch::Atomic","crossbeam_epoch::Collector","crossbeam_epoch::Pointable","crossbeam_utils::CachePadded","map::SkipMap","set::SkipSet","std::borrow::Borrow","std::cmp::Ord","std::collections::Bound","std::marker::Sized","std::option::Option"]},"glob_path_import":{},"self_to_fn":{"base::Entry":["impl<'a: 'g, 'g, K, V> Clone for Entry<'a, 'g, K, V> {\n    fn clone(&self) -> Entry<'a, 'g, K, V> {\n        Entry {\n            parent: self.parent,\n            node: self.node,\n            guard: self.guard,\n        }\n    }\n}","impl<'a: 'g, 'g, K, V> Entry<'a, 'g, K, V>\nwhere\n    K: Ord + Send + 'static,\n    V: Send + 'static,\n{\n    /// Removes the entry from the skip list.\n    ///\n    /// Returns `true` if this call removed the entry and `false` if it was already removed.\n    pub fn remove(&self) -> bool {\n        // Try marking the tower.\n        if self.node.mark_tower() {\n            // Success - the entry is removed. Now decrement `len`.\n            self.parent.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n\n            // Search for the key to unlink the node from the skip list.\n            self.parent\n                .search_bound(Bound::Included(&self.node.key), false, self.guard);\n\n            true\n        } else {\n            false\n        }\n    }\n}","impl<'a: 'g, 'g, K, V> Entry<'a, 'g, K, V>\nwhere\n    K: Ord,\n{\n    /// Moves to the next entry in the skip list.\n    pub fn move_next(&mut self) -> bool {\n        match self.next() {\n            None => false,\n            Some(n) => {\n                *self = n;\n                true\n            }\n        }\n    }\n\n    /// Returns the next entry in the skip list.\n    pub fn next(&self) -> Option<Entry<'a, 'g, K, V>> {\n        let n = self.parent.next_node(\n            &self.node.tower,\n            Bound::Excluded(&self.node.key),\n            self.guard,\n        )?;\n        Some(Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }\n\n    /// Moves to the previous entry in the skip list.\n    pub fn move_prev(&mut self) -> bool {\n        match self.prev() {\n            None => false,\n            Some(n) => {\n                *self = n;\n                true\n            }\n        }\n    }\n\n    /// Returns the previous entry in the skip list.\n    pub fn prev(&self) -> Option<Entry<'a, 'g, K, V>> {\n        let n = self\n            .parent\n            .search_bound(Bound::Excluded(&self.node.key), true, self.guard)?;\n        Some(Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }\n}","impl<'a: 'g, 'g, K: 'a, V: 'a> Entry<'a, 'g, K, V> {\n    /// Returns `true` if the entry is removed from the skip list.\n    pub fn is_removed(&self) -> bool {\n        self.node.is_removed()\n    }\n\n    /// Returns a reference to the key.\n    pub fn key(&self) -> &'g K {\n        &self.node.key\n    }\n\n    /// Returns a reference to the value.\n    pub fn value(&self) -> &'g V {\n        &self.node.value\n    }\n\n    /// Returns a reference to the parent `SkipList`\n    pub fn skiplist(&self) -> &'a SkipList<K, V> {\n        self.parent\n    }\n\n    /// Attempts to pin the entry with a reference count, ensuring that it\n    /// remains accessible even after the `Guard` is dropped.\n    ///\n    /// This method may return `None` if the reference count is already 0 and\n    /// the node has been queued for deletion.\n    pub fn pin(&self) -> Option<RefEntry<'a, K, V>> {\n        unsafe { RefEntry::try_acquire(self.parent, self.node) }\n    }\n}","impl<K, V> fmt::Debug for Entry<'_, '_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"Entry\")\n            .field(self.key())\n            .field(self.value())\n            .finish()\n    }\n}"],"base::Head":["impl<K, V> Deref for Head<K, V> {\n    type Target = Tower<K, V>;\n    fn deref(&self) -> &Tower<K, V> {\n        unsafe { &*(self as *const _ as *const Tower<K, V>) }\n    }\n}","impl<K, V> Head<K, V> {\n    /// Initializes a `Head`.\n    #[inline]\n    fn new() -> Head<K, V> {\n        // Initializing arrays in rust is a pain...\n        Head {\n            pointers: Default::default(),\n        }\n    }\n}"],"base::IntoIter":["impl<K, V> Drop for IntoIter<K, V> {\n    fn drop(&mut self) {\n        // Iterate through the whole chain and destroy every node.\n        while !self.node.is_null() {\n            unsafe {\n                // Unprotected loads are okay because this function is the only one currently using\n                // the skip list.\n                let next = (*self.node).tower[0].load(Ordering::Relaxed, epoch::unprotected());\n\n                // We can safely do this without defering because references to\n                // keys & values that we give out never outlive the SkipList.\n                Node::finalize(self.node);\n\n                self.node = next.as_raw() as *mut Node<K, V>;\n            }\n        }\n    }\n}","impl<K, V> Iterator for IntoIter<K, V> {\n    type Item = (K, V);\n\n    fn next(&mut self) -> Option<(K, V)> {\n        loop {\n            // Have we reached the end of the skip list?\n            if self.node.is_null() {\n                return None;\n            }\n\n            unsafe {\n                // Take the key and value out of the node.\n                let key = ptr::read(&(*self.node).key);\n                let value = ptr::read(&(*self.node).value);\n\n                // Get the next node in the skip list.\n                //\n                // Unprotected loads are okay because this function is the only one currently using\n                // the skip list.\n                let next = (*self.node).tower[0].load(Ordering::Relaxed, epoch::unprotected());\n\n                // Deallocate the current node and move to the next one.\n                Node::dealloc(self.node);\n                self.node = next.as_raw() as *mut Node<K, V>;\n\n                // The current node may be marked. If it is, it's been removed from the skip list\n                // and we should just skip it.\n                if next.tag() == 0 {\n                    return Some((key, value));\n                }\n            }\n        }\n    }\n}","impl<K, V> fmt::Debug for IntoIter<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"IntoIter { .. }\")\n    }\n}"],"base::Iter":["impl<'a: 'g, 'g, K: 'a, V: 'a> DoubleEndedIterator for Iter<'a, 'g, K, V>\nwhere\n    K: Ord,\n{\n    fn next_back(&mut self) -> Option<Entry<'a, 'g, K, V>> {\n        self.tail = match self.tail {\n            Some(n) => self\n                .parent\n                .search_bound(Bound::Excluded(&n.key), true, self.guard),\n            None => self.parent.search_bound(Bound::Unbounded, true, self.guard),\n        };\n        if let (Some(h), Some(t)) = (self.head, self.tail) {\n            if h.key >= t.key {\n                self.head = None;\n                self.tail = None;\n            }\n        }\n        self.tail.map(|n| Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }\n}","impl<'a: 'g, 'g, K: 'a, V: 'a> Iterator for Iter<'a, 'g, K, V>\nwhere\n    K: Ord,\n{\n    type Item = Entry<'a, 'g, K, V>;\n\n    fn next(&mut self) -> Option<Entry<'a, 'g, K, V>> {\n        self.head = match self.head {\n            Some(n) => self\n                .parent\n                .next_node(&n.tower, Bound::Excluded(&n.key), self.guard),\n            None => self\n                .parent\n                .next_node(&self.parent.head, Bound::Unbounded, self.guard),\n        };\n        if let (Some(h), Some(t)) = (self.head, self.tail) {\n            if h.key >= t.key {\n                self.head = None;\n                self.tail = None;\n            }\n        }\n        self.head.map(|n| Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }\n}","impl<K, V> fmt::Debug for Iter<'_, '_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Iter\")\n            .field(\"head\", &self.head.map(|n| (&n.key, &n.value)))\n            .field(\"tail\", &self.tail.map(|n| (&n.key, &n.value)))\n            .finish()\n    }\n}"],"base::Node":["impl<K, V> Node<K, V> {\n    /// Allocates a node.\n    ///\n    /// The returned node will start with reference count of `ref_count` and the tower will be initialized\n    /// with null pointers. However, the key and the value will be left uninitialized, and that is\n    /// why this function is unsafe.\n    unsafe fn alloc(height: usize, ref_count: usize) -> *mut Self {\n        let layout = Self::get_layout(height);\n        let ptr = alloc(layout) as *mut Self;\n        if ptr.is_null() {\n            handle_alloc_error(layout);\n        }\n\n        ptr::write(\n            &mut (*ptr).refs_and_height,\n            AtomicUsize::new((height - 1) | ref_count << HEIGHT_BITS),\n        );\n        ptr::write_bytes((*ptr).tower.pointers.as_mut_ptr(), 0, height);\n        ptr\n    }\n\n    /// Deallocates a node.\n    ///\n    /// This function will not run any destructors.\n    unsafe fn dealloc(ptr: *mut Self) {\n        let height = (*ptr).height();\n        let layout = Self::get_layout(height);\n        dealloc(ptr as *mut u8, layout);\n    }\n\n    /// Returns the layout of a node with the given `height`.\n    unsafe fn get_layout(height: usize) -> Layout {\n        assert!(1 <= height && height <= MAX_HEIGHT);\n\n        let size_self = mem::size_of::<Self>();\n        let align_self = mem::align_of::<Self>();\n        let size_pointer = mem::size_of::<Atomic<Self>>();\n\n        Layout::from_size_align_unchecked(size_self + size_pointer * height, align_self)\n    }\n\n    /// Returns the height of this node's tower.\n    #[inline]\n    fn height(&self) -> usize {\n        (self.refs_and_height.load(Ordering::Relaxed) & HEIGHT_MASK) + 1\n    }\n\n    /// Marks all pointers in the tower and returns `true` if the level 0 was not marked.\n    fn mark_tower(&self) -> bool {\n        let height = self.height();\n\n        for level in (0..height).rev() {\n            let tag = unsafe {\n                // We're loading the pointer only for the tag, so it's okay to use\n                // `epoch::unprotected()` in this situation.\n                // TODO(Amanieu): can we use release ordering here?\n                self.tower[level]\n                    .fetch_or(1, Ordering::SeqCst, epoch::unprotected())\n                    .tag()\n            };\n\n            // If the level 0 pointer was already marked, somebody else removed the node.\n            if level == 0 && tag == 1 {\n                return false;\n            }\n        }\n\n        // We marked the level 0 pointer, therefore we removed the node.\n        true\n    }\n\n    /// Returns `true` if the node is removed.\n    #[inline]\n    fn is_removed(&self) -> bool {\n        let tag = unsafe {\n            // We're loading the pointer only for the tag, so it's okay to use\n            // `epoch::unprotected()` in this situation.\n            self.tower[0]\n                .load(Ordering::Relaxed, epoch::unprotected())\n                .tag()\n        };\n        tag == 1\n    }\n\n    /// Attempts to increment the reference count of a node and returns `true` on success.\n    ///\n    /// The reference count can be incremented only if it is non-zero.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the reference count overflows.\n    #[inline]\n    unsafe fn try_increment(&self) -> bool {\n        let mut refs_and_height = self.refs_and_height.load(Ordering::Relaxed);\n\n        loop {\n            // If the reference count is zero, then the node has already been\n            // queued for deletion. Incrementing it again could lead to a\n            // double-free.\n            if refs_and_height & !HEIGHT_MASK == 0 {\n                return false;\n            }\n\n            // If all bits in the reference count are ones, we're about to overflow it.\n            let new_refs_and_height = refs_and_height\n                .checked_add(1 << HEIGHT_BITS)\n                .expect(\"SkipList reference count overflow\");\n\n            // Try incrementing the count.\n            match self.refs_and_height.compare_exchange_weak(\n                refs_and_height,\n                new_refs_and_height,\n                Ordering::Relaxed,\n                Ordering::Relaxed,\n            ) {\n                Ok(_) => return true,\n                Err(current) => refs_and_height = current,\n            }\n        }\n    }\n\n    /// Decrements the reference count of a node, destroying it if the count becomes zero.\n    #[inline]\n    unsafe fn decrement(&self, guard: &Guard) {\n        if self\n            .refs_and_height\n            .fetch_sub(1 << HEIGHT_BITS, Ordering::Release)\n            >> HEIGHT_BITS\n            == 1\n        {\n            fence(Ordering::Acquire);\n            guard.defer_unchecked(move || Self::finalize(self));\n        }\n    }\n\n    /// Decrements the reference count of a node, pinning the thread and destoying the node\n    /// if the count become zero.\n    #[inline]\n    unsafe fn decrement_with_pin<F>(&self, parent: &SkipList<K, V>, pin: F)\n    where\n        F: FnOnce() -> Guard,\n    {\n        if self\n            .refs_and_height\n            .fetch_sub(1 << HEIGHT_BITS, Ordering::Release)\n            >> HEIGHT_BITS\n            == 1\n        {\n            fence(Ordering::Acquire);\n            let guard = &pin();\n            parent.check_guard(guard);\n            guard.defer_unchecked(move || Self::finalize(self));\n        }\n    }\n\n    /// Drops the key and value of a node, then deallocates it.\n    #[cold]\n    unsafe fn finalize(ptr: *const Self) {\n        let ptr = ptr as *mut Self;\n\n        // Call destructors: drop the key and the value.\n        ptr::drop_in_place(&mut (*ptr).key);\n        ptr::drop_in_place(&mut (*ptr).value);\n\n        // Finally, deallocate the memory occupied by the node.\n        Node::dealloc(ptr);\n    }\n}","impl<K, V> fmt::Debug for Node<K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"Node\")\n            .field(&self.key)\n            .field(&self.value)\n            .finish()\n    }\n}"],"base::Range":["impl<'a: 'g, 'g, Q, R, K: 'a, V: 'a> DoubleEndedIterator for Range<'a, 'g, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n    fn next_back(&mut self) -> Option<Entry<'a, 'g, K, V>> {\n        self.tail = match self.tail {\n            Some(n) => self\n                .parent\n                .search_bound(Bound::Excluded(&n.key.borrow()), true, self.guard),\n            None => self\n                .parent\n                .search_bound(self.range.end_bound(), true, self.guard),\n        };\n        if let Some(t) = self.tail {\n            let bound = match self.head {\n                Some(h) => Bound::Excluded(h.key.borrow()),\n                None => self.range.start_bound(),\n            };\n            if !above_lower_bound(&bound, t.key.borrow()) {\n                self.head = None;\n                self.tail = None;\n            }\n        }\n        self.tail.map(|n| Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }\n}","impl<'a: 'g, 'g, Q, R, K: 'a, V: 'a> Iterator for Range<'a, 'g, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n    type Item = Entry<'a, 'g, K, V>;\n\n    fn next(&mut self) -> Option<Entry<'a, 'g, K, V>> {\n        self.head = match self.head {\n            Some(n) => self\n                .parent\n                .next_node(&n.tower, Bound::Excluded(&n.key), self.guard),\n            None => self\n                .parent\n                .search_bound(self.range.start_bound(), false, self.guard),\n        };\n        if let Some(h) = self.head {\n            let bound = match self.tail {\n                Some(t) => Bound::Excluded(t.key.borrow()),\n                None => self.range.end_bound(),\n            };\n            if !below_upper_bound(&bound, h.key.borrow()) {\n                self.head = None;\n                self.tail = None;\n            }\n        }\n        self.head.map(|n| Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }\n}","impl<Q, R, K, V> fmt::Debug for Range<'_, '_, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q> + fmt::Debug,\n    V: fmt::Debug,\n    R: RangeBounds<Q> + fmt::Debug,\n    Q: Ord + ?Sized,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Range\")\n            .field(\"range\", &self.range)\n            .field(\"head\", &self.head)\n            .field(\"tail\", &self.tail)\n            .finish()\n    }\n}"],"base::RefEntry":["impl<'a, K, V> Clone for RefEntry<'a, K, V> {\n    fn clone(&self) -> RefEntry<'a, K, V> {\n        unsafe {\n            // Incrementing will always succeed since we're already holding a reference to the node.\n            Node::try_increment(self.node);\n        }\n        RefEntry {\n            parent: self.parent,\n            node: self.node,\n        }\n    }\n}","impl<'a, K, V> RefEntry<'a, K, V>\nwhere\n    K: Ord,\n{\n    /// Moves to the next entry in the skip list.\n    pub fn move_next(&mut self, guard: &Guard) -> bool {\n        match self.next(guard) {\n            None => false,\n            Some(e) => {\n                mem::replace(self, e).release(guard);\n                true\n            }\n        }\n    }\n\n    /// Returns the next entry in the skip list.\n    pub fn next(&self, guard: &Guard) -> Option<RefEntry<'a, K, V>> {\n        self.parent.check_guard(guard);\n        unsafe {\n            let mut n = self.node;\n            loop {\n                n = self\n                    .parent\n                    .next_node(&n.tower, Bound::Excluded(&n.key), guard)?;\n                if let Some(e) = RefEntry::try_acquire(self.parent, n) {\n                    return Some(e);\n                }\n            }\n        }\n    }\n    /// Moves to the previous entry in the skip list.\n    pub fn move_prev(&mut self, guard: &Guard) -> bool {\n        match self.prev(guard) {\n            None => false,\n            Some(e) => {\n                mem::replace(self, e).release(guard);\n                true\n            }\n        }\n    }\n\n    /// Returns the previous entry in the skip list.\n    pub fn prev(&self, guard: &Guard) -> Option<RefEntry<'a, K, V>> {\n        self.parent.check_guard(guard);\n        unsafe {\n            let mut n = self.node;\n            loop {\n                n = self\n                    .parent\n                    .search_bound(Bound::Excluded(&n.key), true, guard)?;\n                if let Some(e) = RefEntry::try_acquire(self.parent, n) {\n                    return Some(e);\n                }\n            }\n        }\n    }\n}","impl<'a, K: 'a, V: 'a> RefEntry<'a, K, V> {\n    /// Returns `true` if the entry is removed from the skip list.\n    pub fn is_removed(&self) -> bool {\n        self.node.is_removed()\n    }\n\n    /// Returns a reference to the key.\n    pub fn key(&self) -> &K {\n        &self.node.key\n    }\n\n    /// Returns a reference to the value.\n    pub fn value(&self) -> &V {\n        &self.node.value\n    }\n\n    /// Returns a reference to the parent `SkipList`\n    pub fn skiplist(&self) -> &'a SkipList<K, V> {\n        self.parent\n    }\n\n    /// Releases the reference on the entry.\n    pub fn release(self, guard: &Guard) {\n        self.parent.check_guard(guard);\n        unsafe { self.node.decrement(guard) }\n    }\n\n    /// Releases the reference of the entry, pinning the thread only when\n    /// the reference count of the node becomes 0.\n    pub fn release_with_pin<F>(self, pin: F)\n    where\n        F: FnOnce() -> Guard,\n    {\n        unsafe { self.node.decrement_with_pin(self.parent, pin) }\n    }\n\n    /// Tries to create a new `RefEntry` by incrementing the reference count of\n    /// a node.\n    unsafe fn try_acquire(\n        parent: &'a SkipList<K, V>,\n        node: &Node<K, V>,\n    ) -> Option<RefEntry<'a, K, V>> {\n        if node.try_increment() {\n            Some(RefEntry {\n                parent,\n\n                // We re-bind the lifetime of the node here to that of the skip\n                // list since we now hold a reference to it.\n                node: &*(node as *const _),\n            })\n        } else {\n            None\n        }\n    }\n}","impl<K, V> RefEntry<'_, K, V>\nwhere\n    K: Ord + Send + 'static,\n    V: Send + 'static,\n{\n    /// Removes the entry from the skip list.\n    ///\n    /// Returns `true` if this call removed the entry and `false` if it was already removed.\n    pub fn remove(&self, guard: &Guard) -> bool {\n        self.parent.check_guard(guard);\n\n        // Try marking the tower.\n        if self.node.mark_tower() {\n            // Success - the entry is removed. Now decrement `len`.\n            self.parent.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n\n            // Search for the key to unlink the node from the skip list.\n            self.parent\n                .search_bound(Bound::Included(&self.node.key), false, guard);\n\n            true\n        } else {\n            false\n        }\n    }\n}","impl<K, V> fmt::Debug for RefEntry<'_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"RefEntry\")\n            .field(self.key())\n            .field(self.value())\n            .finish()\n    }\n}"],"base::RefIter":["impl<'a, K: 'a, V: 'a> RefIter<'a, K, V>\nwhere\n    K: Ord,\n{\n    /// TODO\n    pub fn next(&mut self, guard: &Guard) -> Option<RefEntry<'a, K, V>> {\n        self.parent.check_guard(guard);\n        self.head = match self.head {\n            Some(ref e) => {\n                let next_head = e.next(guard);\n                unsafe {\n                    e.node.decrement(guard);\n                }\n                next_head\n            }\n            None => try_pin_loop(|| self.parent.front(guard)),\n        };\n        let mut finished = false;\n        if let (&Some(ref h), &Some(ref t)) = (&self.head, &self.tail) {\n            if h.key() >= t.key() {\n                finished = true;\n            }\n        }\n        if finished {\n            self.head = None;\n            self.tail = None;\n        }\n        self.head.clone()\n    }\n\n    /// TODO\n    pub fn next_back(&mut self, guard: &Guard) -> Option<RefEntry<'a, K, V>> {\n        self.parent.check_guard(guard);\n        self.tail = match self.tail {\n            Some(ref e) => {\n                let next_tail = e.prev(guard);\n                unsafe {\n                    e.node.decrement(guard);\n                }\n                next_tail\n            }\n            None => try_pin_loop(|| self.parent.back(guard)),\n        };\n        let mut finished = false;\n        if let (&Some(ref h), &Some(ref t)) = (&self.head, &self.tail) {\n            if h.key() >= t.key() {\n                finished = true;\n            }\n        }\n        if finished {\n            self.head = None;\n            self.tail = None;\n        }\n        self.tail.clone()\n    }\n}","impl<K, V> fmt::Debug for RefIter<'_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut d = f.debug_struct(\"RefIter\");\n        match &self.head {\n            None => d.field(\"head\", &None::<(&K, &V)>),\n            Some(e) => d.field(\"head\", &(e.key(), e.value())),\n        };\n        match &self.tail {\n            None => d.field(\"tail\", &None::<(&K, &V)>),\n            Some(e) => d.field(\"tail\", &(e.key(), e.value())),\n        };\n        d.finish()\n    }\n}"],"base::RefRange":["impl<'a, Q, R, K: 'a, V: 'a> RefRange<'a, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n    /// TODO\n    pub fn next(&mut self, guard: &Guard) -> Option<RefEntry<'a, K, V>> {\n        self.parent.check_guard(guard);\n        self.head = match self.head {\n            Some(ref e) => e.next(guard),\n            None => try_pin_loop(|| self.parent.lower_bound(self.range.start_bound(), guard)),\n        };\n        let mut finished = false;\n        if let Some(ref h) = self.head {\n            let bound = match self.tail {\n                Some(ref t) => Bound::Excluded(t.key().borrow()),\n                None => self.range.end_bound(),\n            };\n            if !below_upper_bound(&bound, h.key().borrow()) {\n                finished = true;\n            }\n        }\n        if finished {\n            self.head = None;\n            self.tail = None;\n        }\n        self.head.clone()\n    }\n\n    /// TODO: docs\n    pub fn next_back(&mut self, guard: &Guard) -> Option<RefEntry<'a, K, V>> {\n        self.parent.check_guard(guard);\n        self.tail = match self.tail {\n            Some(ref e) => e.prev(guard),\n            None => try_pin_loop(|| self.parent.upper_bound(self.range.start_bound(), guard)),\n        };\n        let mut finished = false;\n        if let Some(ref t) = self.tail {\n            let bound = match self.head {\n                Some(ref h) => Bound::Excluded(h.key().borrow()),\n                None => self.range.end_bound(),\n            };\n            if !above_lower_bound(&bound, t.key().borrow()) {\n                finished = true;\n            }\n        }\n        if finished {\n            self.head = None;\n            self.tail = None;\n        }\n        self.tail.clone()\n    }\n}","impl<Q, R, K, V> fmt::Debug for RefRange<'_, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q> + fmt::Debug,\n    V: fmt::Debug,\n    R: RangeBounds<Q> + fmt::Debug,\n    Q: Ord + ?Sized,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RefRange\")\n            .field(\"range\", &self.range)\n            .field(\"head\", &self.head)\n            .field(\"tail\", &self.tail)\n            .finish()\n    }\n}","unsafe impl<Q, R, K, V> Send for RefRange<'_, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n}","unsafe impl<Q, R, K, V> Sync for RefRange<'_, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n}"],"base::SkipList":["impl<K, V> Drop for SkipList<K, V> {\n    fn drop(&mut self) {\n        unsafe {\n            let mut node = self.head[0]\n                .load(Ordering::Relaxed, epoch::unprotected())\n                .as_ref();\n\n            // Iterate through the whole skip list and destroy every node.\n            while let Some(n) = node {\n                // Unprotected loads are okay because this function is the only one currently using\n                // the skip list.\n                let next = n.tower[0]\n                    .load(Ordering::Relaxed, epoch::unprotected())\n                    .as_ref();\n\n                // Deallocate every node.\n                Node::finalize(n);\n\n                node = next;\n            }\n        }\n    }\n}","impl<K, V> IntoIterator for SkipList<K, V> {\n    type Item = (K, V);\n    type IntoIter = IntoIter<K, V>;\n\n    fn into_iter(self) -> IntoIter<K, V> {\n        unsafe {\n            // Load the front node.\n            //\n            // Unprotected loads are okay because this function is the only one currently using\n            // the skip list.\n            let front = self.head[0]\n                .load(Ordering::Relaxed, epoch::unprotected())\n                .as_raw();\n\n            // Clear the skip list by setting all pointers in head to null.\n            for level in 0..MAX_HEIGHT {\n                self.head[level].store(Shared::null(), Ordering::Relaxed);\n            }\n\n            IntoIter {\n                node: front as *mut Node<K, V>,\n            }\n        }\n    }\n}","impl<K, V> SkipList<K, V>\nwhere\n    K: Ord + Send + 'static,\n    V: Send + 'static,\n{\n    /// Inserts a `key`-`value` pair into the skip list and returns the new entry.\n    ///\n    /// If there is an existing entry with this key, it will be removed before inserting the new\n    /// one.\n    pub fn insert(&self, key: K, value: V, guard: &Guard) -> RefEntry<'_, K, V> {\n        self.insert_internal(key, value, true, guard)\n    }\n\n    /// Removes an entry with the specified `key` from the map and returns it.\n    pub fn remove<Q>(&self, key: &Q, guard: &Guard) -> Option<RefEntry<'_, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        self.check_guard(guard);\n\n        unsafe {\n            // Rebind the guard to the lifetime of self. This is a bit of a\n            // hack but it allows us to return references that are not bound to\n            // the lifetime of the guard.\n            let guard = &*(guard as *const _);\n\n            loop {\n                // Try searching for the key.\n                let search = self.search_position(key, guard);\n\n                let n = search.found?;\n\n                // First try incrementing the reference count because we have to return the node as\n                // an entry. If this fails, repeat the search.\n                let entry = match RefEntry::try_acquire(self, n) {\n                    Some(e) => e,\n                    None => continue,\n                };\n\n                // Try removing the node by marking its tower.\n                if n.mark_tower() {\n                    // Success! Decrement `len`.\n                    self.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n\n                    // Unlink the node at each level of the skip list. We could do this by simply\n                    // repeating the search, but it's usually faster to unlink it manually using\n                    // the `left` and `right` lists.\n                    for level in (0..n.height()).rev() {\n                        // TODO(Amanieu): can we use relaxed ordering here?\n                        let succ = n.tower[level].load(Ordering::SeqCst, guard).with_tag(0);\n\n                        // Try linking the predecessor and successor at this level.\n                        // TODO(Amanieu): can we use release ordering here?\n                        if search.left[level][level]\n                            .compare_and_set(\n                                Shared::from(n as *const _),\n                                succ,\n                                Ordering::SeqCst,\n                                guard,\n                            )\n                            .is_ok()\n                        {\n                            // Success! Decrement the reference count.\n                            n.decrement(guard);\n                        } else {\n                            // Failed! Just repeat the search to completely unlink the node.\n                            self.search_bound(Bound::Included(key), false, guard);\n                            break;\n                        }\n                    }\n\n                    return Some(entry);\n                }\n            }\n        }\n    }\n\n    /// Removes an entry from the front of the skip list.\n    pub fn pop_front(&self, guard: &Guard) -> Option<RefEntry<'_, K, V>> {\n        self.check_guard(guard);\n        loop {\n            let e = self.front(guard)?;\n            if let Some(e) = e.pin() {\n                if e.remove(guard) {\n                    return Some(e);\n                }\n            }\n        }\n    }\n\n    /// Removes an entry from the back of the skip list.\n    pub fn pop_back(&self, guard: &Guard) -> Option<RefEntry<'_, K, V>> {\n        self.check_guard(guard);\n        loop {\n            let e = self.back(guard)?;\n            if let Some(e) = e.pin() {\n                if e.remove(guard) {\n                    return Some(e);\n                }\n            }\n        }\n    }\n\n    /// Iterates over the map and removes every entry.\n    pub fn clear(&self, guard: &mut Guard) {\n        self.check_guard(guard);\n\n        /// Number of steps after which we repin the current thread and unlink removed nodes.\n        const BATCH_SIZE: usize = 100;\n\n        loop {\n            {\n                // Search for the first entry in order to unlink all the preceeding entries\n                // we have removed.\n                //\n                // By unlinking nodes in batches we make sure that the final search doesn't\n                // unlink all nodes at once, which could keep the current thread pinned for a\n                // long time.\n                let mut entry = self.lower_bound(Bound::Unbounded, guard);\n\n                for _ in 0..BATCH_SIZE {\n                    // Stop if we have reached the end of the list.\n                    let e = match entry {\n                        None => return,\n                        Some(e) => e,\n                    };\n\n                    // Before removing the current entry, first obtain the following one.\n                    let next = e.next();\n\n                    // Try removing the current entry.\n                    if e.node.mark_tower() {\n                        // Success! Decrement `len`.\n                        self.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n                    }\n\n                    entry = next;\n                }\n            }\n\n            // Repin the current thread because we don't want to keep it pinned in the same\n            // epoch for a too long time.\n            guard.repin();\n        }\n    }\n}","impl<K, V> SkipList<K, V>\nwhere\n    K: Ord,\n{\n    /// Returns the entry with the smallest key.\n    pub fn front<'a: 'g, 'g>(&'a self, guard: &'g Guard) -> Option<Entry<'a, 'g, K, V>> {\n        self.check_guard(guard);\n        let n = self.next_node(&self.head, Bound::Unbounded, guard)?;\n        Some(Entry {\n            parent: self,\n            node: n,\n            guard,\n        })\n    }\n\n    /// Returns the entry with the largest key.\n    pub fn back<'a: 'g, 'g>(&'a self, guard: &'g Guard) -> Option<Entry<'a, 'g, K, V>> {\n        self.check_guard(guard);\n        let n = self.search_bound(Bound::Unbounded, true, guard)?;\n        Some(Entry {\n            parent: self,\n            node: n,\n            guard,\n        })\n    }\n\n    /// Returns `true` if the map contains a value for the specified key.\n    pub fn contains_key<Q>(&self, key: &Q, guard: &Guard) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        self.get(key, guard).is_some()\n    }\n\n    /// Returns an entry with the specified `key`.\n    pub fn get<'a: 'g, 'g, Q>(&'a self, key: &Q, guard: &'g Guard) -> Option<Entry<'a, 'g, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        self.check_guard(guard);\n        let n = self.search_bound(Bound::Included(key), false, guard)?;\n        if n.key.borrow() != key {\n            return None;\n        }\n        Some(Entry {\n            parent: self,\n            node: n,\n            guard,\n        })\n    }\n\n    /// Returns an `Entry` pointing to the lowest element whose key is above\n    /// the given bound. If no such element is found then `None` is\n    /// returned.\n    pub fn lower_bound<'a: 'g, 'g, Q>(\n        &'a self,\n        bound: Bound<&Q>,\n        guard: &'g Guard,\n    ) -> Option<Entry<'a, 'g, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        self.check_guard(guard);\n        let n = self.search_bound(bound, false, guard)?;\n        Some(Entry {\n            parent: self,\n            node: n,\n            guard,\n        })\n    }\n\n    /// Returns an `Entry` pointing to the highest element whose key is below\n    /// the given bound. If no such element is found then `None` is\n    /// returned.\n    pub fn upper_bound<'a: 'g, 'g, Q>(\n        &'a self,\n        bound: Bound<&Q>,\n        guard: &'g Guard,\n    ) -> Option<Entry<'a, 'g, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        self.check_guard(guard);\n        let n = self.search_bound(bound, true, guard)?;\n        Some(Entry {\n            parent: self,\n            node: n,\n            guard,\n        })\n    }\n\n    /// Finds an entry with the specified key, or inserts a new `key`-`value` pair if none exist.\n    pub fn get_or_insert(&self, key: K, value: V, guard: &Guard) -> RefEntry<'_, K, V> {\n        self.insert_internal(key, value, false, guard)\n    }\n\n    /// Returns an iterator over all entries in the skip list.\n    pub fn iter<'a: 'g, 'g>(&'a self, guard: &'g Guard) -> Iter<'a, 'g, K, V> {\n        self.check_guard(guard);\n        Iter {\n            parent: self,\n            head: None,\n            tail: None,\n            guard,\n        }\n    }\n\n    /// Returns an iterator over all entries in the skip list.\n    pub fn ref_iter(&self) -> RefIter<'_, K, V> {\n        RefIter {\n            parent: self,\n            head: None,\n            tail: None,\n        }\n    }\n\n    /// Returns an iterator over a subset of entries in the skip list.\n    pub fn range<'a: 'g, 'g, Q, R>(\n        &'a self,\n        range: R,\n        guard: &'g Guard,\n    ) -> Range<'a, 'g, Q, R, K, V>\n    where\n        K: Borrow<Q>,\n        R: RangeBounds<Q>,\n        Q: Ord + ?Sized,\n    {\n        self.check_guard(guard);\n        Range {\n            parent: self,\n            head: None,\n            tail: None,\n            range,\n            guard,\n            _marker: PhantomData,\n        }\n    }\n\n    /// Returns an iterator over a subset of entries in the skip list.\n    #[allow(clippy::needless_lifetimes)]\n    pub fn ref_range<'a, Q, R>(&'a self, range: R) -> RefRange<'a, Q, R, K, V>\n    where\n        K: Borrow<Q>,\n        R: RangeBounds<Q>,\n        Q: Ord + ?Sized,\n    {\n        RefRange {\n            parent: self,\n            range,\n            head: None,\n            tail: None,\n            _marker: PhantomData,\n        }\n    }\n\n    /// Generates a random height and returns it.\n    fn random_height(&self) -> usize {\n        // Pseudorandom number generation from \"Xorshift RNGs\" by George Marsaglia.\n        //\n        // This particular set of operations generates 32-bit integers. See:\n        // https://en.wikipedia.org/wiki/Xorshift#Example_implementation\n        let mut num = self.hot_data.seed.load(Ordering::Relaxed);\n        num ^= num << 13;\n        num ^= num >> 17;\n        num ^= num << 5;\n        self.hot_data.seed.store(num, Ordering::Relaxed);\n\n        let mut height = cmp::min(MAX_HEIGHT, num.trailing_zeros() as usize + 1);\n        unsafe {\n            // Keep decreasing the height while it's much larger than all towers currently in the\n            // skip list.\n            //\n            // Note that we're loading the pointer only to check whether it is null, so it's okay\n            // to use `epoch::unprotected()` in this situation.\n            while height >= 4\n                && self.head[height - 2]\n                    .load(Ordering::Relaxed, epoch::unprotected())\n                    .is_null()\n            {\n                height -= 1;\n            }\n        }\n\n        // Track the max height to speed up lookups\n        let mut max_height = self.hot_data.max_height.load(Ordering::Relaxed);\n        while height > max_height {\n            match self.hot_data.max_height.compare_exchange_weak(\n                max_height,\n                height,\n                Ordering::Relaxed,\n                Ordering::Relaxed,\n            ) {\n                Ok(_) => break,\n                Err(h) => max_height = h,\n            }\n        }\n        height\n    }\n\n    /// If we encounter a deleted node while searching, help with the deletion\n    /// by attempting to unlink the node from the list.\n    ///\n    /// If the unlinking is successful then this function returns the next node\n    /// with which the search should continue on the current level.\n    #[cold]\n    unsafe fn help_unlink<'a>(\n        &'a self,\n        pred: &'a Atomic<Node<K, V>>,\n        curr: &'a Node<K, V>,\n        succ: Shared<'a, Node<K, V>>,\n        guard: &'a Guard,\n    ) -> Option<Shared<'a, Node<K, V>>> {\n        // If `succ` is marked, that means `curr` is removed. Let's try\n        // unlinking it from the skip list at this level.\n        match pred.compare_and_set(\n            Shared::from(curr as *const _),\n            succ.with_tag(0),\n            Ordering::Release,\n            guard,\n        ) {\n            Ok(_) => {\n                curr.decrement(guard);\n                Some(succ.with_tag(0))\n            }\n            Err(_) => None,\n        }\n    }\n\n    /// Returns the successor of a node.\n    ///\n    /// This will keep searching until a non-deleted node is found. If a deleted\n    /// node is reached then a search is performed using the given key.\n    fn next_node<'a>(\n        &'a self,\n        pred: &'a Tower<K, V>,\n        lower_bound: Bound<&K>,\n        guard: &'a Guard,\n    ) -> Option<&'a Node<K, V>> {\n        unsafe {\n            // Load the level 0 successor of the current node.\n            let mut curr = pred[0].load_consume(guard);\n\n            // If `curr` is marked, that means `pred` is removed and we have to use\n            // a key search.\n            if curr.tag() == 1 {\n                return self.search_bound(lower_bound, false, guard);\n            }\n\n            while let Some(c) = curr.as_ref() {\n                let succ = c.tower[0].load_consume(guard);\n\n                if succ.tag() == 1 {\n                    if let Some(c) = self.help_unlink(&pred[0], c, succ, guard) {\n                        // On success, continue searching through the current level.\n                        curr = c;\n                        continue;\n                    } else {\n                        // On failure, we cannot do anything reasonable to continue\n                        // searching from the current position. Restart the search.\n                        return self.search_bound(lower_bound, false, guard);\n                    }\n                }\n\n                return Some(c);\n            }\n\n            None\n        }\n    }\n\n    /// Searches for first/last node that is greater/less/equal to a key in the skip list.\n    ///\n    /// If `upper_bound == true`: the last node less than (or equal to) the key.\n    ///\n    /// If `upper_bound == false`: the first node greater than (or equal to) the key.\n    ///\n    /// This is unsafe because the returned nodes are bound to the lifetime of\n    /// the `SkipList`, not the `Guard`.\n    fn search_bound<'a, Q>(\n        &'a self,\n        bound: Bound<&Q>,\n        upper_bound: bool,\n        guard: &'a Guard,\n    ) -> Option<&'a Node<K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        unsafe {\n            'search: loop {\n                // The current level we're at.\n                let mut level = self.hot_data.max_height.load(Ordering::Relaxed);\n\n                // Fast loop to skip empty tower levels.\n                while level >= 1\n                    && self.head[level - 1]\n                        .load(Ordering::Relaxed, guard)\n                        .is_null()\n                {\n                    level -= 1;\n                }\n\n                // The current best node\n                let mut result = None;\n\n                // The predecessor node\n                let mut pred = &*self.head;\n\n                while level >= 1 {\n                    level -= 1;\n\n                    // Two adjacent nodes at the current level.\n                    let mut curr = pred[level].load_consume(guard);\n\n                    // If `curr` is marked, that means `pred` is removed and we have to restart the\n                    // search.\n                    if curr.tag() == 1 {\n                        continue 'search;\n                    }\n\n                    // Iterate through the current level until we reach a node with a key greater\n                    // than or equal to `key`.\n                    while let Some(c) = curr.as_ref() {\n                        let succ = c.tower[level].load_consume(guard);\n\n                        if succ.tag() == 1 {\n                            if let Some(c) = self.help_unlink(&pred[level], c, succ, guard) {\n                                // On success, continue searching through the current level.\n                                curr = c;\n                                continue;\n                            } else {\n                                // On failure, we cannot do anything reasonable to continue\n                                // searching from the current position. Restart the search.\n                                continue 'search;\n                            }\n                        }\n\n                        // If `curr` contains a key that is greater than (or equal) to `key`, we're\n                        // done with this level.\n                        //\n                        // The condition determines whether we should stop the search. For the upper\n                        // bound, we return the last node before the condition became true. For the\n                        // lower bound, we return the first node after the condition became true.\n                        if upper_bound {\n                            if !below_upper_bound(&bound, c.key.borrow()) {\n                                break;\n                            }\n                            result = Some(c);\n                        } else if above_lower_bound(&bound, c.key.borrow()) {\n                            result = Some(c);\n                            break;\n                        }\n\n                        // Move one step forward.\n                        pred = &c.tower;\n                        curr = succ;\n                    }\n                }\n\n                return result;\n            }\n        }\n    }\n\n    /// Searches for a key in the skip list and returns a list of all adjacent nodes.\n    fn search_position<'a, Q>(&'a self, key: &Q, guard: &'a Guard) -> Position<'a, K, V>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        unsafe {\n            'search: loop {\n                // The result of this search.\n                let mut result = Position {\n                    found: None,\n                    left: [&*self.head; MAX_HEIGHT],\n                    right: [Shared::null(); MAX_HEIGHT],\n                };\n\n                // The current level we're at.\n                let mut level = self.hot_data.max_height.load(Ordering::Relaxed);\n\n                // Fast loop to skip empty tower levels.\n                while level >= 1\n                    && self.head[level - 1]\n                        .load(Ordering::Relaxed, guard)\n                        .is_null()\n                {\n                    level -= 1;\n                }\n\n                // The predecessor node\n                let mut pred = &*self.head;\n\n                while level >= 1 {\n                    level -= 1;\n\n                    // Two adjacent nodes at the current level.\n                    let mut curr = pred[level].load_consume(guard);\n\n                    // If `curr` is marked, that means `pred` is removed and we have to restart the\n                    // search.\n                    if curr.tag() == 1 {\n                        continue 'search;\n                    }\n\n                    // Iterate through the current level until we reach a node with a key greater\n                    // than or equal to `key`.\n                    while let Some(c) = curr.as_ref() {\n                        let succ = c.tower[level].load_consume(guard);\n\n                        if succ.tag() == 1 {\n                            if let Some(c) = self.help_unlink(&pred[level], c, succ, guard) {\n                                // On success, continue searching through the current level.\n                                curr = c;\n                                continue;\n                            } else {\n                                // On failure, we cannot do anything reasonable to continue\n                                // searching from the current position. Restart the search.\n                                continue 'search;\n                            }\n                        }\n\n                        // If `curr` contains a key that is greater than or equal to `key`, we're\n                        // done with this level.\n                        match c.key.borrow().cmp(key) {\n                            cmp::Ordering::Greater => break,\n                            cmp::Ordering::Equal => {\n                                result.found = Some(c);\n                                break;\n                            }\n                            cmp::Ordering::Less => {}\n                        }\n\n                        // Move one step forward.\n                        pred = &c.tower;\n                        curr = succ;\n                    }\n\n                    // Store the position at the current level into the result.\n                    result.left[level] = pred;\n                    result.right[level] = curr;\n                }\n\n                return result;\n            }\n        }\n    }\n\n    /// Inserts an entry with the specified `key` and `value`.\n    ///\n    /// If `replace` is `true`, then any existing entry with this key will first be removed.\n    fn insert_internal(\n        &self,\n        key: K,\n        value: V,\n        replace: bool,\n        guard: &Guard,\n    ) -> RefEntry<'_, K, V> {\n        self.check_guard(guard);\n\n        unsafe {\n            // Rebind the guard to the lifetime of self. This is a bit of a\n            // hack but it allows us to return references that are not bound to\n            // the lifetime of the guard.\n            let guard = &*(guard as *const _);\n\n            let mut search;\n            loop {\n                // First try searching for the key.\n                // Note that the `Ord` implementation for `K` may panic during the search.\n                search = self.search_position(&key, guard);\n\n                let r = match search.found {\n                    Some(r) => r,\n                    None => break,\n                };\n\n                if replace {\n                    // If a node with the key was found and we should replace it, mark its tower\n                    // and then repeat the search.\n                    if r.mark_tower() {\n                        self.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n                    }\n                } else {\n                    // If a node with the key was found and we're not going to replace it, let's\n                    // try returning it as an entry.\n                    if let Some(e) = RefEntry::try_acquire(self, r) {\n                        return e;\n                    }\n\n                    // If we couldn't increment the reference count, that means someone has just\n                    // now removed the node.\n                    break;\n                }\n            }\n\n            // Create a new node.\n            let height = self.random_height();\n            let (node, n) = {\n                // The reference count is initially two to account for:\n                // 1. The entry that will be returned.\n                // 2. The link at the level 0 of the tower.\n                let n = Node::<K, V>::alloc(height, 2);\n\n                // Write the key and the value into the node.\n                ptr::write(&mut (*n).key, key);\n                ptr::write(&mut (*n).value, value);\n\n                (Shared::<Node<K, V>>::from(n as *const _), &*n)\n            };\n\n            // Optimistically increment `len`.\n            self.hot_data.len.fetch_add(1, Ordering::Relaxed);\n\n            loop {\n                // Set the lowest successor of `n` to `search.right[0]`.\n                n.tower[0].store(search.right[0], Ordering::Relaxed);\n\n                // Try installing the new node into the skip list (at level 0).\n                // TODO(Amanieu): can we use release ordering here?\n                if search.left[0][0]\n                    .compare_and_set(search.right[0], node, Ordering::SeqCst, guard)\n                    .is_ok()\n                {\n                    break;\n                }\n\n                // We failed. Let's search for the key and try again.\n                {\n                    // Create a guard that destroys the new node in case search panics.\n                    let sg = scopeguard::guard((), |_| {\n                        Node::finalize(node.as_raw());\n                    });\n                    search = self.search_position(&n.key, guard);\n                    mem::forget(sg);\n                }\n\n                if let Some(r) = search.found {\n                    if replace {\n                        // If a node with the key was found and we should replace it, mark its\n                        // tower and then repeat the search.\n                        if r.mark_tower() {\n                            self.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n                        }\n                    } else {\n                        // If a node with the key was found and we're not going to replace it,\n                        // let's try returning it as an entry.\n                        if let Some(e) = RefEntry::try_acquire(self, r) {\n                            // Destroy the new node.\n                            Node::finalize(node.as_raw());\n                            self.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n\n                            return e;\n                        }\n\n                        // If we couldn't increment the reference count, that means someone has\n                        // just now removed the node.\n                    }\n                }\n            }\n\n            // The new node was successfully installed. Let's create an entry associated with it.\n            let entry = RefEntry {\n                parent: self,\n                node: n,\n            };\n\n            // Build the rest of the tower above level 0.\n            'build: for level in 1..height {\n                loop {\n                    // Obtain the predecessor and successor at the current level.\n                    let pred = search.left[level];\n                    let succ = search.right[level];\n\n                    // Load the current value of the pointer in the tower at this level.\n                    // TODO(Amanieu): can we use relaxed ordering here?\n                    let next = n.tower[level].load(Ordering::SeqCst, guard);\n\n                    // If the current pointer is marked, that means another thread is already\n                    // removing the node we've just inserted. In that case, let's just stop\n                    // building the tower.\n                    if next.tag() == 1 {\n                        break 'build;\n                    }\n\n                    // When searching for `key` and traversing the skip list from the highest level\n                    // to the lowest, it is possible to observe a node with an equal key at higher\n                    // levels and then find it missing at the lower levels if it gets removed\n                    // during traversal. Even worse, it is possible to observe completely different\n                    // nodes with the exact same key at different levels.\n                    //\n                    // Linking the new node to a dead successor with an equal key could create\n                    // subtle corner cases that would require special care. It's much easier to\n                    // simply prohibit linking two nodes with equal keys.\n                    //\n                    // If the successor has the same key as the new node, that means it is marked\n                    // as removed and should be unlinked from the skip list. In that case, let's\n                    // repeat the search to make sure it gets unlinked and try again.\n                    //\n                    // If this comparison or the following search panics, we simply stop building\n                    // the tower without breaking any invariants. Note that building higher levels\n                    // is completely optional. Only the lowest level really matters, and all the\n                    // higher levels are there just to make searching faster.\n                    if succ.as_ref().map(|s| &s.key) == Some(&n.key) {\n                        search = self.search_position(&n.key, guard);\n                        continue;\n                    }\n\n                    // Change the pointer at the current level from `next` to `succ`. If this CAS\n                    // operation fails, that means another thread has marked the pointer and we\n                    // should stop building the tower.\n                    // TODO(Amanieu): can we use release ordering here?\n                    if n.tower[level]\n                        .compare_and_set(next, succ, Ordering::SeqCst, guard)\n                        .is_err()\n                    {\n                        break 'build;\n                    }\n\n                    // Increment the reference count. The current value will always be at least 1\n                    // because we are holding `entry`.\n                    n.refs_and_height\n                        .fetch_add(1 << HEIGHT_BITS, Ordering::Relaxed);\n\n                    // Try installing the new node at the current level.\n                    // TODO(Amanieu): can we use release ordering here?\n                    if pred[level]\n                        .compare_and_set(succ, node, Ordering::SeqCst, guard)\n                        .is_ok()\n                    {\n                        // Success! Continue on the next level.\n                        break;\n                    }\n\n                    // Installation failed. Decrement the reference count.\n                    (*n).refs_and_height\n                        .fetch_sub(1 << HEIGHT_BITS, Ordering::Relaxed);\n\n                    // We don't have the most up-to-date search results. Repeat the search.\n                    //\n                    // If this search panics, we simply stop building the tower without breaking\n                    // any invariants. Note that building higher levels is completely optional.\n                    // Only the lowest level really matters, and all the higher levels are there\n                    // just to make searching faster.\n                    search = self.search_position(&n.key, guard);\n                }\n            }\n\n            // If any pointer in the tower is marked, that means our node is in the process of\n            // removal or already removed. It is possible that another thread (either partially or\n            // completely) removed the new node while we were building the tower, and just after\n            // that we installed the new node at one of the higher levels. In order to undo that\n            // installation, we must repeat the search, which will unlink the new node at that\n            // level.\n            // TODO(Amanieu): can we use relaxed ordering here?\n            if n.tower[height - 1].load(Ordering::SeqCst, guard).tag() == 1 {\n                self.search_bound(Bound::Included(&n.key), false, guard);\n            }\n\n            // Finally, return the new entry.\n            entry\n        }\n    }\n}","impl<K, V> SkipList<K, V> {\n    /// Returns a new, empty skip list.\n    pub fn new(collector: Collector) -> SkipList<K, V> {\n        SkipList {\n            head: Head::new(),\n            collector,\n            hot_data: CachePadded::new(HotData {\n                seed: AtomicUsize::new(1),\n                len: AtomicUsize::new(0),\n                max_height: AtomicUsize::new(1),\n            }),\n        }\n    }\n\n    /// Returns `true` if the skip list is empty.\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns the number of entries in the skip list.\n    ///\n    /// If the skip list is being concurrently modified, consider the returned number just an\n    /// approximation without any guarantees.\n    pub fn len(&self) -> usize {\n        let len = self.hot_data.len.load(Ordering::Relaxed);\n\n        // Due to the relaxed  memory ordering, the length counter may sometimes\n        // underflow and produce a very large value. We treat such values as 0.\n        if len > isize::max_value() as usize {\n            0\n        } else {\n            len\n        }\n    }\n\n    /// Ensures that all `Guard`s used with the skip list come from the same\n    /// `Collector`.\n    fn check_guard(&self, guard: &Guard) {\n        if let Some(c) = guard.collector() {\n            assert!(c == &self.collector);\n        }\n    }\n}","impl<K, V> fmt::Debug for SkipList<K, V>\nwhere\n    K: Ord + fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"SkipList { .. }\")\n    }\n}","unsafe impl<K: Send + Sync, V: Send + Sync> Send for SkipList<K, V> {}","unsafe impl<K: Send + Sync, V: Send + Sync> Sync for SkipList<K, V> {}"],"base::Tower":["impl<K, V> Index<usize> for Tower<K, V> {\n    type Output = Atomic<Node<K, V>>;\n    fn index(&self, index: usize) -> &Atomic<Node<K, V>> {\n        // This implementation is actually unsafe since we don't check if the\n        // index is in-bounds. But this is fine since this is only used internally.\n        unsafe { self.pointers.get_unchecked(index) }\n    }\n}"],"map::Entry":["impl<'a, K, V> Clone for Entry<'a, K, V> {\n    fn clone(&self) -> Entry<'a, K, V> {\n        Entry {\n            inner: self.inner.clone(),\n        }\n    }\n}","impl<'a, K, V> Entry<'a, K, V>\nwhere\n    K: Ord,\n{\n    /// Moves to the next entry in the map.\n    pub fn move_next(&mut self) -> bool {\n        let guard = &epoch::pin();\n        self.inner.move_next(guard)\n    }\n\n    /// Moves to the previous entry in the map.\n    pub fn move_prev(&mut self) -> bool {\n        let guard = &epoch::pin();\n        self.inner.move_prev(guard)\n    }\n\n    /// Returns the next entry in the map.\n    pub fn next(&self) -> Option<Entry<'a, K, V>> {\n        let guard = &epoch::pin();\n        self.inner.next(guard).map(Entry::new)\n    }\n\n    /// Returns the previous entry in the map.\n    pub fn prev(&self) -> Option<Entry<'a, K, V>> {\n        let guard = &epoch::pin();\n        self.inner.prev(guard).map(Entry::new)\n    }\n}","impl<'a, K, V> Entry<'a, K, V> {\n    fn new(inner: base::RefEntry<'a, K, V>) -> Entry<'a, K, V> {\n        Entry {\n            inner: ManuallyDrop::new(inner),\n        }\n    }\n\n    /// Returns a reference to the key.\n    pub fn key(&self) -> &K {\n        self.inner.key()\n    }\n\n    /// Returns a reference to the value.\n    pub fn value(&self) -> &V {\n        self.inner.value()\n    }\n\n    /// Returns `true` if the entry is removed from the map.\n    pub fn is_removed(&self) -> bool {\n        self.inner.is_removed()\n    }\n}","impl<K, V> Drop for Entry<'_, K, V> {\n    fn drop(&mut self) {\n        unsafe {\n            ManuallyDrop::into_inner(ptr::read(&self.inner)).release_with_pin(epoch::pin);\n        }\n    }\n}","impl<K, V> Entry<'_, K, V>\nwhere\n    K: Ord + Send + 'static,\n    V: Send + 'static,\n{\n    /// Removes the entry from the map.\n    ///\n    /// Returns `true` if this call removed the entry and `false` if it was already removed.\n    pub fn remove(&self) -> bool {\n        let guard = &epoch::pin();\n        self.inner.remove(guard)\n    }\n}","impl<K, V> fmt::Debug for Entry<'_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"Entry\")\n            .field(self.key())\n            .field(self.value())\n            .finish()\n    }\n}"],"map::IntoIter":["impl<K, V> Iterator for IntoIter<K, V> {\n    type Item = (K, V);\n\n    fn next(&mut self) -> Option<(K, V)> {\n        self.inner.next()\n    }\n}","impl<K, V> fmt::Debug for IntoIter<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"IntoIter { .. }\")\n    }\n}"],"map::Iter":["impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V>\nwhere\n    K: Ord,\n{\n    fn next_back(&mut self) -> Option<Entry<'a, K, V>> {\n        let guard = &epoch::pin();\n        self.inner.next_back(guard).map(Entry::new)\n    }\n}","impl<'a, K, V> Iterator for Iter<'a, K, V>\nwhere\n    K: Ord,\n{\n    type Item = Entry<'a, K, V>;\n\n    fn next(&mut self) -> Option<Entry<'a, K, V>> {\n        let guard = &epoch::pin();\n        self.inner.next(guard).map(Entry::new)\n    }\n}","impl<K, V> fmt::Debug for Iter<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"Iter { .. }\")\n    }\n}"],"map::Range":["impl<'a, Q, R, K, V> DoubleEndedIterator for Range<'a, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n    fn next_back(&mut self) -> Option<Entry<'a, K, V>> {\n        let guard = &epoch::pin();\n        self.inner.next_back(guard).map(Entry::new)\n    }\n}","impl<'a, Q, R, K, V> Iterator for Range<'a, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n    type Item = Entry<'a, K, V>;\n\n    fn next(&mut self) -> Option<Entry<'a, K, V>> {\n        let guard = &epoch::pin();\n        self.inner.next(guard).map(Entry::new)\n    }\n}","impl<Q, R, K, V> fmt::Debug for Range<'_, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q> + fmt::Debug,\n    V: fmt::Debug,\n    R: RangeBounds<Q> + fmt::Debug,\n    Q: Ord + ?Sized,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Range\")\n            .field(\"range\", &self.inner.range)\n            .field(\"head\", &self.inner.head)\n            .field(\"tail\", &self.inner.tail)\n            .finish()\n    }\n}"],"map::SkipMap":["impl<K, V> Default for SkipMap<K, V> {\n    fn default() -> SkipMap<K, V> {\n        SkipMap::new()\n    }\n}","impl<K, V> FromIterator<(K, V)> for SkipMap<K, V>\nwhere\n    K: Ord,\n{\n    fn from_iter<I>(iter: I) -> SkipMap<K, V>\n    where\n        I: IntoIterator<Item = (K, V)>,\n    {\n        let s = SkipMap::new();\n        for (k, v) in iter {\n            s.get_or_insert(k, v);\n        }\n        s\n    }\n}","impl<K, V> IntoIterator for SkipMap<K, V> {\n    type Item = (K, V);\n    type IntoIter = IntoIter<K, V>;\n\n    fn into_iter(self) -> IntoIter<K, V> {\n        IntoIter {\n            inner: self.inner.into_iter(),\n        }\n    }\n}","impl<K, V> SkipMap<K, V>\nwhere\n    K: Ord + Send + 'static,\n    V: Send + 'static,\n{\n    /// Inserts a `key`-`value` pair into the map and returns the new entry.\n    ///\n    /// If there is an existing entry with this key, it will be removed before inserting the new\n    /// one.\n    pub fn insert(&self, key: K, value: V) -> Entry<'_, K, V> {\n        let guard = &epoch::pin();\n        Entry::new(self.inner.insert(key, value, guard))\n    }\n\n    /// Removes an entry with the specified `key` from the map and returns it.\n    pub fn remove<Q>(&self, key: &Q) -> Option<Entry<'_, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        let guard = &epoch::pin();\n        self.inner.remove(key, guard).map(Entry::new)\n    }\n\n    /// Removes an entry from the front of the map.\n    pub fn pop_front(&self) -> Option<Entry<'_, K, V>> {\n        let guard = &epoch::pin();\n        self.inner.pop_front(guard).map(Entry::new)\n    }\n\n    /// Removes an entry from the back of the map.\n    pub fn pop_back(&self) -> Option<Entry<'_, K, V>> {\n        let guard = &epoch::pin();\n        self.inner.pop_back(guard).map(Entry::new)\n    }\n\n    /// Iterates over the map and removes every entry.\n    pub fn clear(&self) {\n        let guard = &mut epoch::pin();\n        self.inner.clear(guard);\n    }\n}","impl<K, V> SkipMap<K, V>\nwhere\n    K: Ord,\n{\n    /// Returns the entry with the smallest key.\n    pub fn front(&self) -> Option<Entry<'_, K, V>> {\n        let guard = &epoch::pin();\n        try_pin_loop(|| self.inner.front(guard)).map(Entry::new)\n    }\n\n    /// Returns the entry with the largest key.\n    pub fn back(&self) -> Option<Entry<'_, K, V>> {\n        let guard = &epoch::pin();\n        try_pin_loop(|| self.inner.back(guard)).map(Entry::new)\n    }\n\n    /// Returns `true` if the map contains a value for the specified key.\n    pub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        let guard = &epoch::pin();\n        self.inner.contains_key(key, guard)\n    }\n\n    /// Returns an entry with the specified `key`.\n    pub fn get<Q>(&self, key: &Q) -> Option<Entry<'_, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        let guard = &epoch::pin();\n        try_pin_loop(|| self.inner.get(key, guard)).map(Entry::new)\n    }\n\n    /// Returns an `Entry` pointing to the lowest element whose key is above\n    /// the given bound. If no such element is found then `None` is\n    /// returned.\n    pub fn lower_bound<'a, Q>(&'a self, bound: Bound<&Q>) -> Option<Entry<'a, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        let guard = &epoch::pin();\n        try_pin_loop(|| self.inner.lower_bound(bound, guard)).map(Entry::new)\n    }\n\n    /// Returns an `Entry` pointing to the highest element whose key is below\n    /// the given bound. If no such element is found then `None` is\n    /// returned.\n    pub fn upper_bound<'a, Q>(&'a self, bound: Bound<&Q>) -> Option<Entry<'a, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        let guard = &epoch::pin();\n        try_pin_loop(|| self.inner.upper_bound(bound, guard)).map(Entry::new)\n    }\n\n    /// Finds an entry with the specified key, or inserts a new `key`-`value` pair if none exist.\n    pub fn get_or_insert(&self, key: K, value: V) -> Entry<'_, K, V> {\n        let guard = &epoch::pin();\n        Entry::new(self.inner.get_or_insert(key, value, guard))\n    }\n\n    /// Returns an iterator over all entries in the map.\n    pub fn iter(&self) -> Iter<'_, K, V> {\n        Iter {\n            inner: self.inner.ref_iter(),\n        }\n    }\n\n    /// Returns an iterator over a subset of entries in the skip list.\n    pub fn range<Q, R>(&self, range: R) -> Range<'_, Q, R, K, V>\n    where\n        K: Borrow<Q>,\n        R: RangeBounds<Q>,\n        Q: Ord + ?Sized,\n    {\n        Range {\n            inner: self.inner.ref_range(range),\n        }\n    }\n}","impl<K, V> SkipMap<K, V> {\n    /// Returns a new, empty map.\n    pub fn new() -> SkipMap<K, V> {\n        SkipMap {\n            inner: base::SkipList::new(epoch::default_collector().clone()),\n        }\n    }\n\n    /// Returns `true` if the map is empty.\n    pub fn is_empty(&self) -> bool {\n        self.inner.is_empty()\n    }\n\n    /// Returns the number of entries in the map.\n    ///\n    /// If the map is being concurrently modified, consider the returned number just an\n    /// approximation without any guarantees.\n    pub fn len(&self) -> usize {\n        self.inner.len()\n    }\n}","impl<K, V> fmt::Debug for SkipMap<K, V>\nwhere\n    K: Ord + fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"SkipMap { .. }\")\n    }\n}"],"set::Entry":["impl<'a, T> Clone for Entry<'a, T> {\n    fn clone(&self) -> Entry<'a, T> {\n        Entry {\n            inner: self.inner.clone(),\n        }\n    }\n}","impl<'a, T> Entry<'a, T>\nwhere\n    T: Ord,\n{\n    /// TODO\n    pub fn move_next(&mut self) -> bool {\n        self.inner.move_next()\n    }\n\n    /// TODO\n    pub fn move_prev(&mut self) -> bool {\n        self.inner.move_prev()\n    }\n\n    /// Returns the next entry in the set.\n    pub fn next(&self) -> Option<Entry<'a, T>> {\n        self.inner.next().map(Entry::new)\n    }\n\n    /// Returns the previous entry in the set.\n    pub fn prev(&self) -> Option<Entry<'a, T>> {\n        self.inner.prev().map(Entry::new)\n    }\n}","impl<'a, T> Entry<'a, T> {\n    fn new(inner: map::Entry<'a, T, ()>) -> Entry<'a, T> {\n        Entry { inner }\n    }\n\n    /// Returns a reference to the key.\n    pub fn value(&self) -> &T {\n        self.inner.key()\n    }\n\n    /// Returns `true` if the entry is removed from the set.\n    pub fn is_removed(&self) -> bool {\n        self.inner.is_removed()\n    }\n}","impl<T> Entry<'_, T>\nwhere\n    T: Ord + Send + 'static,\n{\n    /// Removes the entry from the set.\n    ///\n    /// Returns `true` if this call removed the entry and `false` if it was already removed.\n    pub fn remove(&self) -> bool {\n        self.inner.remove()\n    }\n}","impl<T> fmt::Debug for Entry<'_, T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Entry\")\n            .field(\"value\", self.value())\n            .finish()\n    }\n}"],"set::IntoIter":["impl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        self.inner.next().map(|(k, ())| k)\n    }\n}","impl<T> fmt::Debug for IntoIter<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"IntoIter { .. }\")\n    }\n}"],"set::Iter":["impl<'a, T> DoubleEndedIterator for Iter<'a, T>\nwhere\n    T: Ord,\n{\n    fn next_back(&mut self) -> Option<Entry<'a, T>> {\n        self.inner.next_back().map(Entry::new)\n    }\n}","impl<'a, T> Iterator for Iter<'a, T>\nwhere\n    T: Ord,\n{\n    type Item = Entry<'a, T>;\n\n    fn next(&mut self) -> Option<Entry<'a, T>> {\n        self.inner.next().map(Entry::new)\n    }\n}","impl<T> fmt::Debug for Iter<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"Iter { .. }\")\n    }\n}"],"set::Range":["impl<'a, Q, R, T> DoubleEndedIterator for Range<'a, Q, R, T>\nwhere\n    T: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n    fn next_back(&mut self) -> Option<Entry<'a, T>> {\n        self.inner.next_back().map(Entry::new)\n    }\n}","impl<'a, Q, R, T> Iterator for Range<'a, Q, R, T>\nwhere\n    T: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n    type Item = Entry<'a, T>;\n\n    fn next(&mut self) -> Option<Entry<'a, T>> {\n        self.inner.next().map(Entry::new)\n    }\n}","impl<Q, R, T> fmt::Debug for Range<'_, Q, R, T>\nwhere\n    T: Ord + Borrow<Q> + fmt::Debug,\n    R: RangeBounds<Q> + fmt::Debug,\n    Q: Ord + ?Sized,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Range\")\n            .field(\"range\", &self.inner.inner.range)\n            .field(\"head\", &self.inner.inner.head.as_ref().map(|e| e.key()))\n            .field(\"tail\", &self.inner.inner.tail.as_ref().map(|e| e.key()))\n            .finish()\n    }\n}"],"set::SkipSet":["impl<T> Default for SkipSet<T> {\n    fn default() -> SkipSet<T> {\n        SkipSet::new()\n    }\n}","impl<T> FromIterator<T> for SkipSet<T>\nwhere\n    T: Ord,\n{\n    fn from_iter<I>(iter: I) -> SkipSet<T>\n    where\n        I: IntoIterator<Item = T>,\n    {\n        let s = SkipSet::new();\n        for t in iter {\n            s.get_or_insert(t);\n        }\n        s\n    }\n}","impl<T> IntoIterator for SkipSet<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    fn into_iter(self) -> IntoIter<T> {\n        IntoIter {\n            inner: self.inner.into_iter(),\n        }\n    }\n}","impl<T> SkipSet<T>\nwhere\n    T: Ord + Send + 'static,\n{\n    /// Inserts a `key`-`value` pair into the set and returns the new entry.\n    ///\n    /// If there is an existing entry with this key, it will be removed before inserting the new\n    /// one.\n    pub fn insert(&self, key: T) -> Entry<'_, T> {\n        Entry::new(self.inner.insert(key, ()))\n    }\n\n    /// Removes an entry with the specified key from the set and returns it.\n    pub fn remove<Q>(&self, key: &Q) -> Option<Entry<'_, T>>\n    where\n        T: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        self.inner.remove(key).map(Entry::new)\n    }\n\n    /// Removes an entry from the front of the map.\n    pub fn pop_front(&self) -> Option<Entry<'_, T>> {\n        self.inner.pop_front().map(Entry::new)\n    }\n\n    /// Removes an entry from the back of the map.\n    pub fn pop_back(&self) -> Option<Entry<'_, T>> {\n        self.inner.pop_back().map(Entry::new)\n    }\n\n    /// Iterates over the set and removes every entry.\n    pub fn clear(&self) {\n        self.inner.clear();\n    }\n}","impl<T> SkipSet<T>\nwhere\n    T: Ord,\n{\n    /// Returns the entry with the smallest key.\n    pub fn front(&self) -> Option<Entry<'_, T>> {\n        self.inner.front().map(Entry::new)\n    }\n\n    /// Returns the entry with the largest key.\n    pub fn back(&self) -> Option<Entry<'_, T>> {\n        self.inner.back().map(Entry::new)\n    }\n\n    /// Returns `true` if the set contains a value for the specified key.\n    pub fn contains<Q>(&self, key: &Q) -> bool\n    where\n        T: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        self.inner.contains_key(key)\n    }\n\n    /// Returns an entry with the specified `key`.\n    pub fn get<Q>(&self, key: &Q) -> Option<Entry<'_, T>>\n    where\n        T: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        self.inner.get(key).map(Entry::new)\n    }\n\n    /// Returns an `Entry` pointing to the lowest element whose key is above\n    /// the given bound. If no such element is found then `None` is\n    /// returned.\n    pub fn lower_bound<'a, Q>(&'a self, bound: Bound<&Q>) -> Option<Entry<'a, T>>\n    where\n        T: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        self.inner.lower_bound(bound).map(Entry::new)\n    }\n\n    /// Returns an `Entry` pointing to the highest element whose key is below\n    /// the given bound. If no such element is found then `None` is\n    /// returned.\n    pub fn upper_bound<'a, Q>(&'a self, bound: Bound<&Q>) -> Option<Entry<'a, T>>\n    where\n        T: Borrow<Q>,\n        Q: Ord + ?Sized,\n    {\n        self.inner.upper_bound(bound).map(Entry::new)\n    }\n\n    /// Finds an entry with the specified key, or inserts a new `key`-`value` pair if none exist.\n    pub fn get_or_insert(&self, key: T) -> Entry<'_, T> {\n        Entry::new(self.inner.get_or_insert(key, ()))\n    }\n\n    /// Returns an iterator over all entries in the map.\n    pub fn iter(&self) -> Iter<'_, T> {\n        Iter {\n            inner: self.inner.iter(),\n        }\n    }\n\n    /// Returns an iterator over a subset of entries in the skip list.\n    pub fn range<Q, R>(&self, range: R) -> Range<'_, Q, R, T>\n    where\n        T: Borrow<Q>,\n        R: RangeBounds<Q>,\n        Q: Ord + ?Sized,\n    {\n        Range {\n            inner: self.inner.range(range),\n        }\n    }\n}","impl<T> SkipSet<T> {\n    /// Returns a new, empty set.\n    pub fn new() -> SkipSet<T> {\n        SkipSet {\n            inner: map::SkipMap::new(),\n        }\n    }\n\n    /// Returns `true` if the set is empty.\n    pub fn is_empty(&self) -> bool {\n        self.inner.is_empty()\n    }\n\n    /// Returns the number of entries in the set.\n    ///\n    /// If the set is being concurrently modified, consider the returned number just an\n    /// approximation without any guarantees.\n    pub fn len(&self) -> usize {\n        self.inner.len()\n    }\n}","impl<T> fmt::Debug for SkipSet<T>\nwhere\n    T: Ord + fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(\"SkipSet { .. }\")\n    }\n}"]},"single_path_import":{"base::SkipList":"SkipList","map::SkipMap":"SkipMap","set::SkipSet":"SkipSet"},"srcs":{"<&'a map::SkipMap<K, V> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Iter<'a, K, V>{\n        self.iter()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<&'a set::SkipSet<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Iter<'a, T>{\n        self.iter()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<base::Entry<'_, '_, K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_tuple(\"Entry\")\n            .field(self.key())\n            .field(self.value())\n            .finish()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::Entry<'a, 'g, K, V> as std::clone::Clone>::clone":["fn clone(&self) -> Entry<'a, 'g, K, V>{\n        Entry {\n            parent: self.parent,\n            node: self.node,\n            guard: self.guard,\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::Head<K, V> as std::ops::Deref>::deref":["fn deref(&self) -> &Tower<K, V>{\n        unsafe { &*(self as *const _ as *const Tower<K, V>) }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::IntoIter<K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"IntoIter { .. }\")\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::IntoIter<K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<(K, V)>{\n        loop {\n            // Have we reached the end of the skip list?\n            if self.node.is_null() {\n                return None;\n            }\n\n            unsafe {\n                // Take the key and value out of the node.\n                let key = ptr::read(&(*self.node).key);\n                let value = ptr::read(&(*self.node).value);\n\n                // Get the next node in the skip list.\n                //\n                // Unprotected loads are okay because this function is the only one currently using\n                // the skip list.\n                let next = (*self.node).tower[0].load(Ordering::Relaxed, epoch::unprotected());\n\n                // Deallocate the current node and move to the next one.\n                Node::dealloc(self.node);\n                self.node = next.as_raw() as *mut Node<K, V>;\n\n                // The current node may be marked. If it is, it's been removed from the skip list\n                // and we should just skip it.\n                if next.tag() == 0 {\n                    return Some((key, value));\n                }\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::IntoIter<K, V> as std::ops::Drop>::drop":["fn drop(&mut self){\n        // Iterate through the whole chain and destroy every node.\n        while !self.node.is_null() {\n            unsafe {\n                // Unprotected loads are okay because this function is the only one currently using\n                // the skip list.\n                let next = (*self.node).tower[0].load(Ordering::Relaxed, epoch::unprotected());\n\n                // We can safely do this without defering because references to\n                // keys & values that we give out never outlive the SkipList.\n                Node::finalize(self.node);\n\n                self.node = next.as_raw() as *mut Node<K, V>;\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::Iter<'_, '_, K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Iter\")\n            .field(\"head\", &self.head.map(|n| (&n.key, &n.value)))\n            .field(\"tail\", &self.tail.map(|n| (&n.key, &n.value)))\n            .finish()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::Iter<'a, 'g, K, V> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Entry<'a, 'g, K, V>>{\n        self.tail = match self.tail {\n            Some(n) => self\n                .parent\n                .search_bound(Bound::Excluded(&n.key), true, self.guard),\n            None => self.parent.search_bound(Bound::Unbounded, true, self.guard),\n        };\n        if let (Some(h), Some(t)) = (self.head, self.tail) {\n            if h.key >= t.key {\n                self.head = None;\n                self.tail = None;\n            }\n        }\n        self.tail.map(|n| Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::Iter<'a, 'g, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Entry<'a, 'g, K, V>>{\n        self.head = match self.head {\n            Some(n) => self\n                .parent\n                .next_node(&n.tower, Bound::Excluded(&n.key), self.guard),\n            None => self\n                .parent\n                .next_node(&self.parent.head, Bound::Unbounded, self.guard),\n        };\n        if let (Some(h), Some(t)) = (self.head, self.tail) {\n            if h.key >= t.key {\n                self.head = None;\n                self.tail = None;\n            }\n        }\n        self.head.map(|n| Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::Node<K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_tuple(\"Node\")\n            .field(&self.key)\n            .field(&self.value)\n            .finish()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::Range<'_, '_, Q, R, K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Range\")\n            .field(\"range\", &self.range)\n            .field(\"head\", &self.head)\n            .field(\"tail\", &self.tail)\n            .finish()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::Range<'a, 'g, Q, R, K, V> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Entry<'a, 'g, K, V>>{\n        self.tail = match self.tail {\n            Some(n) => self\n                .parent\n                .search_bound(Bound::Excluded(&n.key.borrow()), true, self.guard),\n            None => self\n                .parent\n                .search_bound(self.range.end_bound(), true, self.guard),\n        };\n        if let Some(t) = self.tail {\n            let bound = match self.head {\n                Some(h) => Bound::Excluded(h.key.borrow()),\n                None => self.range.start_bound(),\n            };\n            if !above_lower_bound(&bound, t.key.borrow()) {\n                self.head = None;\n                self.tail = None;\n            }\n        }\n        self.tail.map(|n| Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::Range<'a, 'g, Q, R, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Entry<'a, 'g, K, V>>{\n        self.head = match self.head {\n            Some(n) => self\n                .parent\n                .next_node(&n.tower, Bound::Excluded(&n.key), self.guard),\n            None => self\n                .parent\n                .search_bound(self.range.start_bound(), false, self.guard),\n        };\n        if let Some(h) = self.head {\n            let bound = match self.tail {\n                Some(t) => Bound::Excluded(t.key.borrow()),\n                None => self.range.end_bound(),\n            };\n            if !below_upper_bound(&bound, h.key.borrow()) {\n                self.head = None;\n                self.tail = None;\n            }\n        }\n        self.head.map(|n| Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::RefEntry<'_, K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_tuple(\"RefEntry\")\n            .field(self.key())\n            .field(self.value())\n            .finish()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::RefEntry<'a, K, V> as std::clone::Clone>::clone":["fn clone(&self) -> RefEntry<'a, K, V>{\n        unsafe {\n            // Incrementing will always succeed since we're already holding a reference to the node.\n            Node::try_increment(self.node);\n        }\n        RefEntry {\n            parent: self.parent,\n            node: self.node,\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::RefIter<'_, K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let mut d = f.debug_struct(\"RefIter\");\n        match &self.head {\n            None => d.field(\"head\", &None::<(&K, &V)>),\n            Some(e) => d.field(\"head\", &(e.key(), e.value())),\n        };\n        match &self.tail {\n            None => d.field(\"tail\", &None::<(&K, &V)>),\n            Some(e) => d.field(\"tail\", &(e.key(), e.value())),\n        };\n        d.finish()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::RefRange<'_, Q, R, K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"RefRange\")\n            .field(\"range\", &self.range)\n            .field(\"head\", &self.head)\n            .field(\"tail\", &self.tail)\n            .finish()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::SkipList<K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"SkipList { .. }\")\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::SkipList<K, V> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> IntoIter<K, V>{\n        unsafe {\n            // Load the front node.\n            //\n            // Unprotected loads are okay because this function is the only one currently using\n            // the skip list.\n            let front = self.head[0]\n                .load(Ordering::Relaxed, epoch::unprotected())\n                .as_raw();\n\n            // Clear the skip list by setting all pointers in head to null.\n            for level in 0..MAX_HEIGHT {\n                self.head[level].store(Shared::null(), Ordering::Relaxed);\n            }\n\n            IntoIter {\n                node: front as *mut Node<K, V>,\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::SkipList<K, V> as std::ops::Drop>::drop":["fn drop(&mut self){\n        unsafe {\n            let mut node = self.head[0]\n                .load(Ordering::Relaxed, epoch::unprotected())\n                .as_ref();\n\n            // Iterate through the whole skip list and destroy every node.\n            while let Some(n) = node {\n                // Unprotected loads are okay because this function is the only one currently using\n                // the skip list.\n                let next = n.tower[0]\n                    .load(Ordering::Relaxed, epoch::unprotected())\n                    .as_ref();\n\n                // Deallocate every node.\n                Node::finalize(n);\n\n                node = next;\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<base::Tower<K, V> as std::ops::Index<usize>>::index":["fn index(&self, index: usize) -> &Atomic<Node<K, V>>{\n        // This implementation is actually unsafe since we don't check if the\n        // index is in-bounds. But this is fine since this is only used internally.\n        unsafe { self.pointers.get_unchecked(index) }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"<map::Entry<'_, K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_tuple(\"Entry\")\n            .field(self.key())\n            .field(self.value())\n            .finish()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::Entry<'_, K, V> as std::ops::Drop>::drop":["fn drop(&mut self){\n        unsafe {\n            ManuallyDrop::into_inner(ptr::read(&self.inner)).release_with_pin(epoch::pin);\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::Entry<'a, K, V> as std::clone::Clone>::clone":["fn clone(&self) -> Entry<'a, K, V>{\n        Entry {\n            inner: self.inner.clone(),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::IntoIter<K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"IntoIter { .. }\")\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::IntoIter<K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<(K, V)>{\n        self.inner.next()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::Iter<'_, K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"Iter { .. }\")\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::Iter<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Entry<'a, K, V>>{\n        let guard = &epoch::pin();\n        self.inner.next_back(guard).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::Iter<'a, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Entry<'a, K, V>>{\n        let guard = &epoch::pin();\n        self.inner.next(guard).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::Range<'_, Q, R, K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Range\")\n            .field(\"range\", &self.inner.range)\n            .field(\"head\", &self.inner.head)\n            .field(\"tail\", &self.inner.tail)\n            .finish()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::Range<'a, Q, R, K, V> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Entry<'a, K, V>>{\n        let guard = &epoch::pin();\n        self.inner.next_back(guard).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::Range<'a, Q, R, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Entry<'a, K, V>>{\n        let guard = &epoch::pin();\n        self.inner.next(guard).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::SkipMap<K, V> as std::default::Default>::default":["fn default() -> SkipMap<K, V>{\n        SkipMap::new()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::SkipMap<K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"SkipMap { .. }\")\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::SkipMap<K, V> as std::iter::FromIterator<(K, V)>>::from_iter":["fn from_iter<I>(iter: I) -> SkipMap<K, V>\n    where\n        I: IntoIterator<Item = (K, V)>,{\n        let s = SkipMap::new();\n        for (k, v) in iter {\n            s.get_or_insert(k, v);\n        }\n        s\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<map::SkipMap<K, V> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> IntoIter<K, V>{\n        IntoIter {\n            inner: self.inner.into_iter(),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"<set::Entry<'_, T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Entry\")\n            .field(\"value\", self.value())\n            .finish()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::Entry<'a, T> as std::clone::Clone>::clone":["fn clone(&self) -> Entry<'a, T>{\n        Entry {\n            inner: self.inner.clone(),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::IntoIter<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"IntoIter { .. }\")\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::IntoIter<T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<T>{\n        self.inner.next().map(|(k, ())| k)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::Iter<'_, T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"Iter { .. }\")\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::Iter<'a, T> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Entry<'a, T>>{\n        self.inner.next_back().map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::Iter<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Entry<'a, T>>{\n        self.inner.next().map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::Range<'_, Q, R, T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Range\")\n            .field(\"range\", &self.inner.inner.range)\n            .field(\"head\", &self.inner.inner.head.as_ref().map(|e| e.key()))\n            .field(\"tail\", &self.inner.inner.tail.as_ref().map(|e| e.key()))\n            .finish()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::Range<'a, Q, R, T> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Entry<'a, T>>{\n        self.inner.next_back().map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::Range<'a, Q, R, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Entry<'a, T>>{\n        self.inner.next().map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::SkipSet<T> as std::default::Default>::default":["fn default() -> SkipSet<T>{\n        SkipSet::new()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::SkipSet<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.pad(\"SkipSet { .. }\")\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::SkipSet<T> as std::iter::FromIterator<T>>::from_iter":["fn from_iter<I>(iter: I) -> SkipSet<T>\n    where\n        I: IntoIterator<Item = T>,{\n        let s = SkipSet::new();\n        for t in iter {\n            s.get_or_insert(t);\n        }\n        s\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"<set::SkipSet<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> IntoIter<T>{\n        IntoIter {\n            inner: self.inner.into_iter(),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"base::Entry":["/// An entry in a skip list, protected by a `Guard`.\n///\n/// The lifetimes of the key and value are the same as that of the `Guard`\n/// used when creating the `Entry` (`'g`). This lifetime is also constrained to\n/// not outlive the `SkipList`.\npub struct Entry<'a: 'g, 'g, K, V> {\n    parent: &'a SkipList<K, V>,\n    node: &'g Node<K, V>,\n    guard: &'g Guard,\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Entry::<'a, 'g, K, V>::is_removed":["/// Returns `true` if the entry is removed from the skip list.\npub fn is_removed(&self) -> bool{\n        self.node.is_removed()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Entry::<'a, 'g, K, V>::key":["/// Returns a reference to the key.\npub fn key(&self) -> &'g K{\n        &self.node.key\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Entry::<'a, 'g, K, V>::move_next":["/// Moves to the next entry in the skip list.\npub fn move_next(&mut self) -> bool{\n        match self.next() {\n            None => false,\n            Some(n) => {\n                *self = n;\n                true\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Entry::<'a, 'g, K, V>::move_prev":["/// Moves to the previous entry in the skip list.\npub fn move_prev(&mut self) -> bool{\n        match self.prev() {\n            None => false,\n            Some(n) => {\n                *self = n;\n                true\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Entry::<'a, 'g, K, V>::next":["/// Returns the next entry in the skip list.\npub fn next(&self) -> Option<Entry<'a, 'g, K, V>>{\n        let n = self.parent.next_node(\n            &self.node.tower,\n            Bound::Excluded(&self.node.key),\n            self.guard,\n        )?;\n        Some(Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Entry::<'a, 'g, K, V>::pin":["/// Attempts to pin the entry with a reference count, ensuring that it\n/// remains accessible even after the `Guard` is dropped.\n///\n/// This method may return `None` if the reference count is already 0 and\n/// the node has been queued for deletion.\npub fn pin(&self) -> Option<RefEntry<'a, K, V>>{\n        unsafe { RefEntry::try_acquire(self.parent, self.node) }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Entry::<'a, 'g, K, V>::prev":["/// Returns the previous entry in the skip list.\npub fn prev(&self) -> Option<Entry<'a, 'g, K, V>>{\n        let n = self\n            .parent\n            .search_bound(Bound::Excluded(&self.node.key), true, self.guard)?;\n        Some(Entry {\n            parent: self.parent,\n            node: n,\n            guard: self.guard,\n        })\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Entry::<'a, 'g, K, V>::remove":["/// Removes the entry from the skip list.\n///\n/// Returns `true` if this call removed the entry and `false` if it was already removed.\npub fn remove(&self) -> bool{\n        // Try marking the tower.\n        if self.node.mark_tower() {\n            // Success - the entry is removed. Now decrement `len`.\n            self.parent.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n\n            // Search for the key to unlink the node from the skip list.\n            self.parent\n                .search_bound(Bound::Included(&self.node.key), false, self.guard);\n\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Entry::<'a, 'g, K, V>::skiplist":["/// Returns a reference to the parent `SkipList`\npub fn skiplist(&self) -> &'a SkipList<K, V>{\n        self.parent\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Entry::<'a, 'g, K, V>::value":["/// Returns a reference to the value.\npub fn value(&self) -> &'g V{\n        &self.node.value\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Head":["/// Tower at the head of a skip list.\n///\n/// This is located in the `SkipList` struct itself and holds a full height\n/// tower.\n#[repr(C)]\nstruct Head<K, V> {\n    pointers: [Atomic<Node<K, V>>; MAX_HEIGHT],\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Head::<K, V>::new":["/// Initializes a `Head`.\n#[inline]\nfn new() -> Head<K, V>{\n        // Initializing arrays in rust is a pain...\n        Head {\n            pointers: Default::default(),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::HotData":["/// Frequently modified data associated with a skip list.\nstruct HotData {\n    /// The seed for random height generation.\n    seed: AtomicUsize,\n\n    /// The number of entries in the skip list.\n    len: AtomicUsize,\n\n    /// Highest tower currently in use. This value is used as a hint for where\n    /// to start lookups and never decreases.\n    max_height: AtomicUsize,\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::IntoIter":["/// An owning iterator over the entries of a `SkipList`.\npub struct IntoIter<K, V> {\n    /// The current node.\n    ///\n    /// All preceeding nods have already been destroyed.\n    node: *mut Node<K, V>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Iter":["/// An iterator over the entries of a `SkipList`.\npub struct Iter<'a: 'g, 'g, K, V> {\n    parent: &'a SkipList<K, V>,\n    head: Option<&'g Node<K, V>>,\n    tail: Option<&'g Node<K, V>>,\n    guard: &'g Guard,\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Node":["/// A skip list node.\n///\n/// This struct is marked with `repr(C)` so that the specific order of fields is enforced.\n/// It is important that the tower is the last field since it is dynamically sized. The key,\n/// reference count, and height are kept close to the tower to improve cache locality during\n/// skip list traversal.\n#[repr(C)]\nstruct Node<K, V> {\n    /// The value.\n    value: V,\n\n    /// The key.\n    key: K,\n\n    /// Keeps the reference count and the height of its tower.\n    ///\n    /// The reference count is equal to the number of `Entry`s pointing to this node, plus the\n    /// number of levels in which this node is installed.\n    refs_and_height: AtomicUsize,\n\n    /// The tower of atomic pointers.\n    tower: Tower<K, V>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Node::<K, V>::alloc":["/// Allocates a node.\n///\n/// The returned node will start with reference count of `ref_count` and the tower will be initialized\n/// with null pointers. However, the key and the value will be left uninitialized, and that is\n/// why this function is unsafe.\nunsafe fn alloc(height: usize, ref_count: usize) -> *mut Self{\n        let layout = Self::get_layout(height);\n        let ptr = alloc(layout) as *mut Self;\n        if ptr.is_null() {\n            handle_alloc_error(layout);\n        }\n\n        ptr::write(\n            &mut (*ptr).refs_and_height,\n            AtomicUsize::new((height - 1) | ref_count << HEIGHT_BITS),\n        );\n        ptr::write_bytes((*ptr).tower.pointers.as_mut_ptr(), 0, height);\n        ptr\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Node::<K, V>::dealloc":["/// Deallocates a node.\n///\n/// This function will not run any destructors.\nunsafe fn dealloc(ptr: *mut Self){\n        let height = (*ptr).height();\n        let layout = Self::get_layout(height);\n        dealloc(ptr as *mut u8, layout);\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Node::<K, V>::decrement":["/// Decrements the reference count of a node, destroying it if the count becomes zero.\n#[inline]\nunsafe fn decrement(&self, guard: &Guard){\n        if self\n            .refs_and_height\n            .fetch_sub(1 << HEIGHT_BITS, Ordering::Release)\n            >> HEIGHT_BITS\n            == 1\n        {\n            fence(Ordering::Acquire);\n            guard.defer_unchecked(move || Self::finalize(self));\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Node::<K, V>::decrement_with_pin":["/// Decrements the reference count of a node, pinning the thread and destoying the node\n/// if the count become zero.\n#[inline]\nunsafe fn decrement_with_pin<F>(&self, parent: &SkipList<K, V>, pin: F)\n    where\n        F: FnOnce() -> Guard,{\n        if self\n            .refs_and_height\n            .fetch_sub(1 << HEIGHT_BITS, Ordering::Release)\n            >> HEIGHT_BITS\n            == 1\n        {\n            fence(Ordering::Acquire);\n            let guard = &pin();\n            parent.check_guard(guard);\n            guard.defer_unchecked(move || Self::finalize(self));\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Node::<K, V>::finalize":["/// Drops the key and value of a node, then deallocates it.\n#[cold]\nunsafe fn finalize(ptr: *const Self){\n        let ptr = ptr as *mut Self;\n\n        // Call destructors: drop the key and the value.\n        ptr::drop_in_place(&mut (*ptr).key);\n        ptr::drop_in_place(&mut (*ptr).value);\n\n        // Finally, deallocate the memory occupied by the node.\n        Node::dealloc(ptr);\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Node::<K, V>::get_layout":["/// Returns the layout of a node with the given `height`.\nunsafe fn get_layout(height: usize) -> Layout{\n        assert!(1 <= height && height <= MAX_HEIGHT);\n\n        let size_self = mem::size_of::<Self>();\n        let align_self = mem::align_of::<Self>();\n        let size_pointer = mem::size_of::<Atomic<Self>>();\n\n        Layout::from_size_align_unchecked(size_self + size_pointer * height, align_self)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Node::<K, V>::height":["/// Returns the height of this node's tower.\n#[inline]\nfn height(&self) -> usize{\n        (self.refs_and_height.load(Ordering::Relaxed) & HEIGHT_MASK) + 1\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Node::<K, V>::is_removed":["/// Returns `true` if the node is removed.\n#[inline]\nfn is_removed(&self) -> bool{\n        let tag = unsafe {\n            // We're loading the pointer only for the tag, so it's okay to use\n            // `epoch::unprotected()` in this situation.\n            self.tower[0]\n                .load(Ordering::Relaxed, epoch::unprotected())\n                .tag()\n        };\n        tag == 1\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Node::<K, V>::mark_tower":["/// Marks all pointers in the tower and returns `true` if the level 0 was not marked.\nfn mark_tower(&self) -> bool{\n        let height = self.height();\n\n        for level in (0..height).rev() {\n            let tag = unsafe {\n                // We're loading the pointer only for the tag, so it's okay to use\n                // `epoch::unprotected()` in this situation.\n                // TODO(Amanieu): can we use release ordering here?\n                self.tower[level]\n                    .fetch_or(1, Ordering::SeqCst, epoch::unprotected())\n                    .tag()\n            };\n\n            // If the level 0 pointer was already marked, somebody else removed the node.\n            if level == 0 && tag == 1 {\n                return false;\n            }\n        }\n\n        // We marked the level 0 pointer, therefore we removed the node.\n        true\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Node::<K, V>::try_increment":["/// Attempts to increment the reference count of a node and returns `true` on success.\n///\n/// The reference count can be incremented only if it is non-zero.\n///\n/// # Panics\n///\n/// Panics if the reference count overflows.\n#[inline]\nunsafe fn try_increment(&self) -> bool{\n        let mut refs_and_height = self.refs_and_height.load(Ordering::Relaxed);\n\n        loop {\n            // If the reference count is zero, then the node has already been\n            // queued for deletion. Incrementing it again could lead to a\n            // double-free.\n            if refs_and_height & !HEIGHT_MASK == 0 {\n                return false;\n            }\n\n            // If all bits in the reference count are ones, we're about to overflow it.\n            let new_refs_and_height = refs_and_height\n                .checked_add(1 << HEIGHT_BITS)\n                .expect(\"SkipList reference count overflow\");\n\n            // Try incrementing the count.\n            match self.refs_and_height.compare_exchange_weak(\n                refs_and_height,\n                new_refs_and_height,\n                Ordering::Relaxed,\n                Ordering::Relaxed,\n            ) {\n                Ok(_) => return true,\n                Err(current) => refs_and_height = current,\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Position":["/// A search result.\n///\n/// The result indicates whether the key was found, as well as what were the adjacent nodes to the\n/// key on each level of the skip list.\nstruct Position<'a, K, V> {\n    /// Reference to a node with the given key, if found.\n    ///\n    /// If this is `Some` then it will point to the same node as `right[0]`.\n    found: Option<&'a Node<K, V>>,\n\n    /// Adjacent nodes with smaller keys (predecessors).\n    left: [&'a Tower<K, V>; MAX_HEIGHT],\n\n    /// Adjacent nodes with equal or greater keys (successors).\n    right: [Shared<'a, Node<K, V>>; MAX_HEIGHT],\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Range":["/// An iterator over a subset of entries of a `SkipList`.\npub struct Range<'a: 'g, 'g, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n    parent: &'a SkipList<K, V>,\n    head: Option<&'g Node<K, V>>,\n    tail: Option<&'g Node<K, V>>,\n    range: R,\n    guard: &'g Guard,\n    _marker: PhantomData<fn() -> Q>, // covariant over `Q`\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry":["/// A reference-counted entry in a skip list.\n///\n/// You *must* call `release` to free this type, otherwise the node will be\n/// leaked. This is because releasing the entry requires a `Guard`.\npub struct RefEntry<'a, K, V> {\n    parent: &'a SkipList<K, V>,\n    node: &'a Node<K, V>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'_, K, V>::remove":["/// Removes the entry from the skip list.\n///\n/// Returns `true` if this call removed the entry and `false` if it was already removed.\npub fn remove(&self, guard: &Guard) -> bool{\n        self.parent.check_guard(guard);\n\n        // Try marking the tower.\n        if self.node.mark_tower() {\n            // Success - the entry is removed. Now decrement `len`.\n            self.parent.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n\n            // Search for the key to unlink the node from the skip list.\n            self.parent\n                .search_bound(Bound::Included(&self.node.key), false, guard);\n\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'a, K, V>::is_removed":["/// Returns `true` if the entry is removed from the skip list.\npub fn is_removed(&self) -> bool{\n        self.node.is_removed()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'a, K, V>::key":["/// Returns a reference to the key.\npub fn key(&self) -> &K{\n        &self.node.key\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'a, K, V>::move_next":["/// Moves to the next entry in the skip list.\npub fn move_next(&mut self, guard: &Guard) -> bool{\n        match self.next(guard) {\n            None => false,\n            Some(e) => {\n                mem::replace(self, e).release(guard);\n                true\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'a, K, V>::move_prev":["/// Moves to the previous entry in the skip list.\npub fn move_prev(&mut self, guard: &Guard) -> bool{\n        match self.prev(guard) {\n            None => false,\n            Some(e) => {\n                mem::replace(self, e).release(guard);\n                true\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'a, K, V>::next":["/// Returns the next entry in the skip list.\npub fn next(&self, guard: &Guard) -> Option<RefEntry<'a, K, V>>{\n        self.parent.check_guard(guard);\n        unsafe {\n            let mut n = self.node;\n            loop {\n                n = self\n                    .parent\n                    .next_node(&n.tower, Bound::Excluded(&n.key), guard)?;\n                if let Some(e) = RefEntry::try_acquire(self.parent, n) {\n                    return Some(e);\n                }\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'a, K, V>::prev":["/// Returns the previous entry in the skip list.\npub fn prev(&self, guard: &Guard) -> Option<RefEntry<'a, K, V>>{\n        self.parent.check_guard(guard);\n        unsafe {\n            let mut n = self.node;\n            loop {\n                n = self\n                    .parent\n                    .search_bound(Bound::Excluded(&n.key), true, guard)?;\n                if let Some(e) = RefEntry::try_acquire(self.parent, n) {\n                    return Some(e);\n                }\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'a, K, V>::release":["/// Releases the reference on the entry.\npub fn release(self, guard: &Guard){\n        self.parent.check_guard(guard);\n        unsafe { self.node.decrement(guard) }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'a, K, V>::release_with_pin":["/// Releases the reference of the entry, pinning the thread only when\n/// the reference count of the node becomes 0.\npub fn release_with_pin<F>(self, pin: F)\n    where\n        F: FnOnce() -> Guard,{\n        unsafe { self.node.decrement_with_pin(self.parent, pin) }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'a, K, V>::skiplist":["/// Returns a reference to the parent `SkipList`\npub fn skiplist(&self) -> &'a SkipList<K, V>{\n        self.parent\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'a, K, V>::try_acquire":["/// Tries to create a new `RefEntry` by incrementing the reference count of\n/// a node.\nunsafe fn try_acquire(\n        parent: &'a SkipList<K, V>,\n        node: &Node<K, V>,\n    ) -> Option<RefEntry<'a, K, V>>{\n        if node.try_increment() {\n            Some(RefEntry {\n                parent,\n\n                // We re-bind the lifetime of the node here to that of the skip\n                // list since we now hold a reference to it.\n                node: &*(node as *const _),\n            })\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefEntry::<'a, K, V>::value":["/// Returns a reference to the value.\npub fn value(&self) -> &V{\n        &self.node.value\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefIter":["/// An iterator over reference-counted entries of a `SkipList`.\npub struct RefIter<'a, K, V> {\n    parent: &'a SkipList<K, V>,\n    head: Option<RefEntry<'a, K, V>>,\n    tail: Option<RefEntry<'a, K, V>>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefIter::<'a, K, V>::next":["/// TODO\npub fn next(&mut self, guard: &Guard) -> Option<RefEntry<'a, K, V>>{\n        self.parent.check_guard(guard);\n        self.head = match self.head {\n            Some(ref e) => {\n                let next_head = e.next(guard);\n                unsafe {\n                    e.node.decrement(guard);\n                }\n                next_head\n            }\n            None => try_pin_loop(|| self.parent.front(guard)),\n        };\n        let mut finished = false;\n        if let (&Some(ref h), &Some(ref t)) = (&self.head, &self.tail) {\n            if h.key() >= t.key() {\n                finished = true;\n            }\n        }\n        if finished {\n            self.head = None;\n            self.tail = None;\n        }\n        self.head.clone()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefIter::<'a, K, V>::next_back":["/// TODO\npub fn next_back(&mut self, guard: &Guard) -> Option<RefEntry<'a, K, V>>{\n        self.parent.check_guard(guard);\n        self.tail = match self.tail {\n            Some(ref e) => {\n                let next_tail = e.prev(guard);\n                unsafe {\n                    e.node.decrement(guard);\n                }\n                next_tail\n            }\n            None => try_pin_loop(|| self.parent.back(guard)),\n        };\n        let mut finished = false;\n        if let (&Some(ref h), &Some(ref t)) = (&self.head, &self.tail) {\n            if h.key() >= t.key() {\n                finished = true;\n            }\n        }\n        if finished {\n            self.head = None;\n            self.tail = None;\n        }\n        self.tail.clone()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefRange":["/// An iterator over reference-counted subset of entries of a `SkipList`.\npub struct RefRange<'a, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n    parent: &'a SkipList<K, V>,\n    pub(crate) head: Option<RefEntry<'a, K, V>>,\n    pub(crate) tail: Option<RefEntry<'a, K, V>>,\n    pub(crate) range: R,\n    _marker: PhantomData<fn() -> Q>, // covariant over `Q`\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefRange::<'a, Q, R, K, V>::next":["/// TODO\npub fn next(&mut self, guard: &Guard) -> Option<RefEntry<'a, K, V>>{\n        self.parent.check_guard(guard);\n        self.head = match self.head {\n            Some(ref e) => e.next(guard),\n            None => try_pin_loop(|| self.parent.lower_bound(self.range.start_bound(), guard)),\n        };\n        let mut finished = false;\n        if let Some(ref h) = self.head {\n            let bound = match self.tail {\n                Some(ref t) => Bound::Excluded(t.key().borrow()),\n                None => self.range.end_bound(),\n            };\n            if !below_upper_bound(&bound, h.key().borrow()) {\n                finished = true;\n            }\n        }\n        if finished {\n            self.head = None;\n            self.tail = None;\n        }\n        self.head.clone()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::RefRange::<'a, Q, R, K, V>::next_back":["/// TODO: docs\npub fn next_back(&mut self, guard: &Guard) -> Option<RefEntry<'a, K, V>>{\n        self.parent.check_guard(guard);\n        self.tail = match self.tail {\n            Some(ref e) => e.prev(guard),\n            None => try_pin_loop(|| self.parent.upper_bound(self.range.start_bound(), guard)),\n        };\n        let mut finished = false;\n        if let Some(ref t) = self.tail {\n            let bound = match self.head {\n                Some(ref h) => Bound::Excluded(h.key().borrow()),\n                None => self.range.end_bound(),\n            };\n            if !above_lower_bound(&bound, t.key().borrow()) {\n                finished = true;\n            }\n        }\n        if finished {\n            self.head = None;\n            self.tail = None;\n        }\n        self.tail.clone()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList":["/// A lock-free skip list.\npub struct SkipList<K, V> {\n    /// The head of the skip list (just a dummy node, not a real entry).\n    head: Head<K, V>,\n\n    /// The `Collector` associated with this skip list.\n    collector: Collector,\n\n    /// Hot data associated with the skip list, stored in a dedicated cache line.\n    hot_data: CachePadded<HotData>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::back":["/// Returns the entry with the largest key.\npub fn back<'a: 'g, 'g>(&'a self, guard: &'g Guard) -> Option<Entry<'a, 'g, K, V>>{\n        self.check_guard(guard);\n        let n = self.search_bound(Bound::Unbounded, true, guard)?;\n        Some(Entry {\n            parent: self,\n            node: n,\n            guard,\n        })\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::check_guard":["/// Ensures that all `Guard`s used with the skip list come from the same\n/// `Collector`.\nfn check_guard(&self, guard: &Guard){\n        if let Some(c) = guard.collector() {\n            assert!(c == &self.collector);\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::clear":["/// Iterates over the map and removes every entry.\npub fn clear(&self, guard: &mut Guard){\n        self.check_guard(guard);\n\n        /// Number of steps after which we repin the current thread and unlink removed nodes.\n        const BATCH_SIZE: usize = 100;\n\n        loop {\n            {\n                // Search for the first entry in order to unlink all the preceeding entries\n                // we have removed.\n                //\n                // By unlinking nodes in batches we make sure that the final search doesn't\n                // unlink all nodes at once, which could keep the current thread pinned for a\n                // long time.\n                let mut entry = self.lower_bound(Bound::Unbounded, guard);\n\n                for _ in 0..BATCH_SIZE {\n                    // Stop if we have reached the end of the list.\n                    let e = match entry {\n                        None => return,\n                        Some(e) => e,\n                    };\n\n                    // Before removing the current entry, first obtain the following one.\n                    let next = e.next();\n\n                    // Try removing the current entry.\n                    if e.node.mark_tower() {\n                        // Success! Decrement `len`.\n                        self.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n                    }\n\n                    entry = next;\n                }\n            }\n\n            // Repin the current thread because we don't want to keep it pinned in the same\n            // epoch for a too long time.\n            guard.repin();\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::contains_key":["/// Returns `true` if the map contains a value for the specified key.\npub fn contains_key<Q>(&self, key: &Q, guard: &Guard) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        self.get(key, guard).is_some()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::front":["/// Returns the entry with the smallest key.\npub fn front<'a: 'g, 'g>(&'a self, guard: &'g Guard) -> Option<Entry<'a, 'g, K, V>>{\n        self.check_guard(guard);\n        let n = self.next_node(&self.head, Bound::Unbounded, guard)?;\n        Some(Entry {\n            parent: self,\n            node: n,\n            guard,\n        })\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::get":["/// Returns an entry with the specified `key`.\npub fn get<'a: 'g, 'g, Q>(&'a self, key: &Q, guard: &'g Guard) -> Option<Entry<'a, 'g, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        self.check_guard(guard);\n        let n = self.search_bound(Bound::Included(key), false, guard)?;\n        if n.key.borrow() != key {\n            return None;\n        }\n        Some(Entry {\n            parent: self,\n            node: n,\n            guard,\n        })\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::get_or_insert":["/// Finds an entry with the specified key, or inserts a new `key`-`value` pair if none exist.\npub fn get_or_insert(&self, key: K, value: V, guard: &Guard) -> RefEntry<'_, K, V>{\n        self.insert_internal(key, value, false, guard)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::help_unlink":["/// If we encounter a deleted node while searching, help with the deletion\n/// by attempting to unlink the node from the list.\n///\n/// If the unlinking is successful then this function returns the next node\n/// with which the search should continue on the current level.\n#[cold]\nunsafe fn help_unlink<'a>(\n        &'a self,\n        pred: &'a Atomic<Node<K, V>>,\n        curr: &'a Node<K, V>,\n        succ: Shared<'a, Node<K, V>>,\n        guard: &'a Guard,\n    ) -> Option<Shared<'a, Node<K, V>>>{\n        // If `succ` is marked, that means `curr` is removed. Let's try\n        // unlinking it from the skip list at this level.\n        match pred.compare_and_set(\n            Shared::from(curr as *const _),\n            succ.with_tag(0),\n            Ordering::Release,\n            guard,\n        ) {\n            Ok(_) => {\n                curr.decrement(guard);\n                Some(succ.with_tag(0))\n            }\n            Err(_) => None,\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::insert":["/// Inserts a `key`-`value` pair into the skip list and returns the new entry.\n///\n/// If there is an existing entry with this key, it will be removed before inserting the new\n/// one.\npub fn insert(&self, key: K, value: V, guard: &Guard) -> RefEntry<'_, K, V>{\n        self.insert_internal(key, value, true, guard)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::insert_internal":["/// Inserts an entry with the specified `key` and `value`.\n///\n/// If `replace` is `true`, then any existing entry with this key will first be removed.\nfn insert_internal(\n        &self,\n        key: K,\n        value: V,\n        replace: bool,\n        guard: &Guard,\n    ) -> RefEntry<'_, K, V>{\n        self.check_guard(guard);\n\n        unsafe {\n            // Rebind the guard to the lifetime of self. This is a bit of a\n            // hack but it allows us to return references that are not bound to\n            // the lifetime of the guard.\n            let guard = &*(guard as *const _);\n\n            let mut search;\n            loop {\n                // First try searching for the key.\n                // Note that the `Ord` implementation for `K` may panic during the search.\n                search = self.search_position(&key, guard);\n\n                let r = match search.found {\n                    Some(r) => r,\n                    None => break,\n                };\n\n                if replace {\n                    // If a node with the key was found and we should replace it, mark its tower\n                    // and then repeat the search.\n                    if r.mark_tower() {\n                        self.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n                    }\n                } else {\n                    // If a node with the key was found and we're not going to replace it, let's\n                    // try returning it as an entry.\n                    if let Some(e) = RefEntry::try_acquire(self, r) {\n                        return e;\n                    }\n\n                    // If we couldn't increment the reference count, that means someone has just\n                    // now removed the node.\n                    break;\n                }\n            }\n\n            // Create a new node.\n            let height = self.random_height();\n            let (node, n) = {\n                // The reference count is initially two to account for:\n                // 1. The entry that will be returned.\n                // 2. The link at the level 0 of the tower.\n                let n = Node::<K, V>::alloc(height, 2);\n\n                // Write the key and the value into the node.\n                ptr::write(&mut (*n).key, key);\n                ptr::write(&mut (*n).value, value);\n\n                (Shared::<Node<K, V>>::from(n as *const _), &*n)\n            };\n\n            // Optimistically increment `len`.\n            self.hot_data.len.fetch_add(1, Ordering::Relaxed);\n\n            loop {\n                // Set the lowest successor of `n` to `search.right[0]`.\n                n.tower[0].store(search.right[0], Ordering::Relaxed);\n\n                // Try installing the new node into the skip list (at level 0).\n                // TODO(Amanieu): can we use release ordering here?\n                if search.left[0][0]\n                    .compare_and_set(search.right[0], node, Ordering::SeqCst, guard)\n                    .is_ok()\n                {\n                    break;\n                }\n\n                // We failed. Let's search for the key and try again.\n                {\n                    // Create a guard that destroys the new node in case search panics.\n                    let sg = scopeguard::guard((), |_| {\n                        Node::finalize(node.as_raw());\n                    });\n                    search = self.search_position(&n.key, guard);\n                    mem::forget(sg);\n                }\n\n                if let Some(r) = search.found {\n                    if replace {\n                        // If a node with the key was found and we should replace it, mark its\n                        // tower and then repeat the search.\n                        if r.mark_tower() {\n                            self.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n                        }\n                    } else {\n                        // If a node with the key was found and we're not going to replace it,\n                        // let's try returning it as an entry.\n                        if let Some(e) = RefEntry::try_acquire(self, r) {\n                            // Destroy the new node.\n                            Node::finalize(node.as_raw());\n                            self.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n\n                            return e;\n                        }\n\n                        // If we couldn't increment the reference count, that means someone has\n                        // just now removed the node.\n                    }\n                }\n            }\n\n            // The new node was successfully installed. Let's create an entry associated with it.\n            let entry = RefEntry {\n                parent: self,\n                node: n,\n            };\n\n            // Build the rest of the tower above level 0.\n            'build: for level in 1..height {\n                loop {\n                    // Obtain the predecessor and successor at the current level.\n                    let pred = search.left[level];\n                    let succ = search.right[level];\n\n                    // Load the current value of the pointer in the tower at this level.\n                    // TODO(Amanieu): can we use relaxed ordering here?\n                    let next = n.tower[level].load(Ordering::SeqCst, guard);\n\n                    // If the current pointer is marked, that means another thread is already\n                    // removing the node we've just inserted. In that case, let's just stop\n                    // building the tower.\n                    if next.tag() == 1 {\n                        break 'build;\n                    }\n\n                    // When searching for `key` and traversing the skip list from the highest level\n                    // to the lowest, it is possible to observe a node with an equal key at higher\n                    // levels and then find it missing at the lower levels if it gets removed\n                    // during traversal. Even worse, it is possible to observe completely different\n                    // nodes with the exact same key at different levels.\n                    //\n                    // Linking the new node to a dead successor with an equal key could create\n                    // subtle corner cases that would require special care. It's much easier to\n                    // simply prohibit linking two nodes with equal keys.\n                    //\n                    // If the successor has the same key as the new node, that means it is marked\n                    // as removed and should be unlinked from the skip list. In that case, let's\n                    // repeat the search to make sure it gets unlinked and try again.\n                    //\n                    // If this comparison or the following search panics, we simply stop building\n                    // the tower without breaking any invariants. Note that building higher levels\n                    // is completely optional. Only the lowest level really matters, and all the\n                    // higher levels are there just to make searching faster.\n                    if succ.as_ref().map(|s| &s.key) == Some(&n.key) {\n                        search = self.search_position(&n.key, guard);\n                        continue;\n                    }\n\n                    // Change the pointer at the current level from `next` to `succ`. If this CAS\n                    // operation fails, that means another thread has marked the pointer and we\n                    // should stop building the tower.\n                    // TODO(Amanieu): can we use release ordering here?\n                    if n.tower[level]\n                        .compare_and_set(next, succ, Ordering::SeqCst, guard)\n                        .is_err()\n                    {\n                        break 'build;\n                    }\n\n                    // Increment the reference count. The current value will always be at least 1\n                    // because we are holding `entry`.\n                    n.refs_and_height\n                        .fetch_add(1 << HEIGHT_BITS, Ordering::Relaxed);\n\n                    // Try installing the new node at the current level.\n                    // TODO(Amanieu): can we use release ordering here?\n                    if pred[level]\n                        .compare_and_set(succ, node, Ordering::SeqCst, guard)\n                        .is_ok()\n                    {\n                        // Success! Continue on the next level.\n                        break;\n                    }\n\n                    // Installation failed. Decrement the reference count.\n                    (*n).refs_and_height\n                        .fetch_sub(1 << HEIGHT_BITS, Ordering::Relaxed);\n\n                    // We don't have the most up-to-date search results. Repeat the search.\n                    //\n                    // If this search panics, we simply stop building the tower without breaking\n                    // any invariants. Note that building higher levels is completely optional.\n                    // Only the lowest level really matters, and all the higher levels are there\n                    // just to make searching faster.\n                    search = self.search_position(&n.key, guard);\n                }\n            }\n\n            // If any pointer in the tower is marked, that means our node is in the process of\n            // removal or already removed. It is possible that another thread (either partially or\n            // completely) removed the new node while we were building the tower, and just after\n            // that we installed the new node at one of the higher levels. In order to undo that\n            // installation, we must repeat the search, which will unlink the new node at that\n            // level.\n            // TODO(Amanieu): can we use relaxed ordering here?\n            if n.tower[height - 1].load(Ordering::SeqCst, guard).tag() == 1 {\n                self.search_bound(Bound::Included(&n.key), false, guard);\n            }\n\n            // Finally, return the new entry.\n            entry\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::is_empty":["/// Returns `true` if the skip list is empty.\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::iter":["/// Returns an iterator over all entries in the skip list.\npub fn iter<'a: 'g, 'g>(&'a self, guard: &'g Guard) -> Iter<'a, 'g, K, V>{\n        self.check_guard(guard);\n        Iter {\n            parent: self,\n            head: None,\n            tail: None,\n            guard,\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::len":["/// Returns the number of entries in the skip list.\n///\n/// If the skip list is being concurrently modified, consider the returned number just an\n/// approximation without any guarantees.\npub fn len(&self) -> usize{\n        let len = self.hot_data.len.load(Ordering::Relaxed);\n\n        // Due to the relaxed  memory ordering, the length counter may sometimes\n        // underflow and produce a very large value. We treat such values as 0.\n        if len > isize::max_value() as usize {\n            0\n        } else {\n            len\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::lower_bound":["/// Returns an `Entry` pointing to the lowest element whose key is above\n/// the given bound. If no such element is found then `None` is\n/// returned.\npub fn lower_bound<'a: 'g, 'g, Q>(\n        &'a self,\n        bound: Bound<&Q>,\n        guard: &'g Guard,\n    ) -> Option<Entry<'a, 'g, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        self.check_guard(guard);\n        let n = self.search_bound(bound, false, guard)?;\n        Some(Entry {\n            parent: self,\n            node: n,\n            guard,\n        })\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::new":["/// Returns a new, empty skip list.\npub fn new(collector: Collector) -> SkipList<K, V>{\n        SkipList {\n            head: Head::new(),\n            collector,\n            hot_data: CachePadded::new(HotData {\n                seed: AtomicUsize::new(1),\n                len: AtomicUsize::new(0),\n                max_height: AtomicUsize::new(1),\n            }),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::next_node":["/// Returns the successor of a node.\n///\n/// This will keep searching until a non-deleted node is found. If a deleted\n/// node is reached then a search is performed using the given key.\nfn next_node<'a>(\n        &'a self,\n        pred: &'a Tower<K, V>,\n        lower_bound: Bound<&K>,\n        guard: &'a Guard,\n    ) -> Option<&'a Node<K, V>>{\n        unsafe {\n            // Load the level 0 successor of the current node.\n            let mut curr = pred[0].load_consume(guard);\n\n            // If `curr` is marked, that means `pred` is removed and we have to use\n            // a key search.\n            if curr.tag() == 1 {\n                return self.search_bound(lower_bound, false, guard);\n            }\n\n            while let Some(c) = curr.as_ref() {\n                let succ = c.tower[0].load_consume(guard);\n\n                if succ.tag() == 1 {\n                    if let Some(c) = self.help_unlink(&pred[0], c, succ, guard) {\n                        // On success, continue searching through the current level.\n                        curr = c;\n                        continue;\n                    } else {\n                        // On failure, we cannot do anything reasonable to continue\n                        // searching from the current position. Restart the search.\n                        return self.search_bound(lower_bound, false, guard);\n                    }\n                }\n\n                return Some(c);\n            }\n\n            None\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::pop_back":["/// Removes an entry from the back of the skip list.\npub fn pop_back(&self, guard: &Guard) -> Option<RefEntry<'_, K, V>>{\n        self.check_guard(guard);\n        loop {\n            let e = self.back(guard)?;\n            if let Some(e) = e.pin() {\n                if e.remove(guard) {\n                    return Some(e);\n                }\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::pop_front":["/// Removes an entry from the front of the skip list.\npub fn pop_front(&self, guard: &Guard) -> Option<RefEntry<'_, K, V>>{\n        self.check_guard(guard);\n        loop {\n            let e = self.front(guard)?;\n            if let Some(e) = e.pin() {\n                if e.remove(guard) {\n                    return Some(e);\n                }\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::random_height":["/// Generates a random height and returns it.\nfn random_height(&self) -> usize{\n        // Pseudorandom number generation from \"Xorshift RNGs\" by George Marsaglia.\n        //\n        // This particular set of operations generates 32-bit integers. See:\n        // https://en.wikipedia.org/wiki/Xorshift#Example_implementation\n        let mut num = self.hot_data.seed.load(Ordering::Relaxed);\n        num ^= num << 13;\n        num ^= num >> 17;\n        num ^= num << 5;\n        self.hot_data.seed.store(num, Ordering::Relaxed);\n\n        let mut height = cmp::min(MAX_HEIGHT, num.trailing_zeros() as usize + 1);\n        unsafe {\n            // Keep decreasing the height while it's much larger than all towers currently in the\n            // skip list.\n            //\n            // Note that we're loading the pointer only to check whether it is null, so it's okay\n            // to use `epoch::unprotected()` in this situation.\n            while height >= 4\n                && self.head[height - 2]\n                    .load(Ordering::Relaxed, epoch::unprotected())\n                    .is_null()\n            {\n                height -= 1;\n            }\n        }\n\n        // Track the max height to speed up lookups\n        let mut max_height = self.hot_data.max_height.load(Ordering::Relaxed);\n        while height > max_height {\n            match self.hot_data.max_height.compare_exchange_weak(\n                max_height,\n                height,\n                Ordering::Relaxed,\n                Ordering::Relaxed,\n            ) {\n                Ok(_) => break,\n                Err(h) => max_height = h,\n            }\n        }\n        height\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::range":["/// Returns an iterator over a subset of entries in the skip list.\npub fn range<'a: 'g, 'g, Q, R>(\n        &'a self,\n        range: R,\n        guard: &'g Guard,\n    ) -> Range<'a, 'g, Q, R, K, V>\n    where\n        K: Borrow<Q>,\n        R: RangeBounds<Q>,\n        Q: Ord + ?Sized,{\n        self.check_guard(guard);\n        Range {\n            parent: self,\n            head: None,\n            tail: None,\n            range,\n            guard,\n            _marker: PhantomData,\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::ref_iter":["/// Returns an iterator over all entries in the skip list.\npub fn ref_iter(&self) -> RefIter<'_, K, V>{\n        RefIter {\n            parent: self,\n            head: None,\n            tail: None,\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::ref_range":["/// Returns an iterator over a subset of entries in the skip list.\n#[allow(clippy::needless_lifetimes)]\npub fn ref_range<'a, Q, R>(&'a self, range: R) -> RefRange<'a, Q, R, K, V>\n    where\n        K: Borrow<Q>,\n        R: RangeBounds<Q>,\n        Q: Ord + ?Sized,{\n        RefRange {\n            parent: self,\n            range,\n            head: None,\n            tail: None,\n            _marker: PhantomData,\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::remove":["/// Removes an entry with the specified `key` from the map and returns it.\npub fn remove<Q>(&self, key: &Q, guard: &Guard) -> Option<RefEntry<'_, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        self.check_guard(guard);\n\n        unsafe {\n            // Rebind the guard to the lifetime of self. This is a bit of a\n            // hack but it allows us to return references that are not bound to\n            // the lifetime of the guard.\n            let guard = &*(guard as *const _);\n\n            loop {\n                // Try searching for the key.\n                let search = self.search_position(key, guard);\n\n                let n = search.found?;\n\n                // First try incrementing the reference count because we have to return the node as\n                // an entry. If this fails, repeat the search.\n                let entry = match RefEntry::try_acquire(self, n) {\n                    Some(e) => e,\n                    None => continue,\n                };\n\n                // Try removing the node by marking its tower.\n                if n.mark_tower() {\n                    // Success! Decrement `len`.\n                    self.hot_data.len.fetch_sub(1, Ordering::Relaxed);\n\n                    // Unlink the node at each level of the skip list. We could do this by simply\n                    // repeating the search, but it's usually faster to unlink it manually using\n                    // the `left` and `right` lists.\n                    for level in (0..n.height()).rev() {\n                        // TODO(Amanieu): can we use relaxed ordering here?\n                        let succ = n.tower[level].load(Ordering::SeqCst, guard).with_tag(0);\n\n                        // Try linking the predecessor and successor at this level.\n                        // TODO(Amanieu): can we use release ordering here?\n                        if search.left[level][level]\n                            .compare_and_set(\n                                Shared::from(n as *const _),\n                                succ,\n                                Ordering::SeqCst,\n                                guard,\n                            )\n                            .is_ok()\n                        {\n                            // Success! Decrement the reference count.\n                            n.decrement(guard);\n                        } else {\n                            // Failed! Just repeat the search to completely unlink the node.\n                            self.search_bound(Bound::Included(key), false, guard);\n                            break;\n                        }\n                    }\n\n                    return Some(entry);\n                }\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::search_bound":["/// Searches for first/last node that is greater/less/equal to a key in the skip list.\n///\n/// If `upper_bound == true`: the last node less than (or equal to) the key.\n///\n/// If `upper_bound == false`: the first node greater than (or equal to) the key.\n///\n/// This is unsafe because the returned nodes are bound to the lifetime of\n/// the `SkipList`, not the `Guard`.\nfn search_bound<'a, Q>(\n        &'a self,\n        bound: Bound<&Q>,\n        upper_bound: bool,\n        guard: &'a Guard,\n    ) -> Option<&'a Node<K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        unsafe {\n            'search: loop {\n                // The current level we're at.\n                let mut level = self.hot_data.max_height.load(Ordering::Relaxed);\n\n                // Fast loop to skip empty tower levels.\n                while level >= 1\n                    && self.head[level - 1]\n                        .load(Ordering::Relaxed, guard)\n                        .is_null()\n                {\n                    level -= 1;\n                }\n\n                // The current best node\n                let mut result = None;\n\n                // The predecessor node\n                let mut pred = &*self.head;\n\n                while level >= 1 {\n                    level -= 1;\n\n                    // Two adjacent nodes at the current level.\n                    let mut curr = pred[level].load_consume(guard);\n\n                    // If `curr` is marked, that means `pred` is removed and we have to restart the\n                    // search.\n                    if curr.tag() == 1 {\n                        continue 'search;\n                    }\n\n                    // Iterate through the current level until we reach a node with a key greater\n                    // than or equal to `key`.\n                    while let Some(c) = curr.as_ref() {\n                        let succ = c.tower[level].load_consume(guard);\n\n                        if succ.tag() == 1 {\n                            if let Some(c) = self.help_unlink(&pred[level], c, succ, guard) {\n                                // On success, continue searching through the current level.\n                                curr = c;\n                                continue;\n                            } else {\n                                // On failure, we cannot do anything reasonable to continue\n                                // searching from the current position. Restart the search.\n                                continue 'search;\n                            }\n                        }\n\n                        // If `curr` contains a key that is greater than (or equal) to `key`, we're\n                        // done with this level.\n                        //\n                        // The condition determines whether we should stop the search. For the upper\n                        // bound, we return the last node before the condition became true. For the\n                        // lower bound, we return the first node after the condition became true.\n                        if upper_bound {\n                            if !below_upper_bound(&bound, c.key.borrow()) {\n                                break;\n                            }\n                            result = Some(c);\n                        } else if above_lower_bound(&bound, c.key.borrow()) {\n                            result = Some(c);\n                            break;\n                        }\n\n                        // Move one step forward.\n                        pred = &c.tower;\n                        curr = succ;\n                    }\n                }\n\n                return result;\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::search_position":["/// Searches for a key in the skip list and returns a list of all adjacent nodes.\nfn search_position<'a, Q>(&'a self, key: &Q, guard: &'a Guard) -> Position<'a, K, V>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        unsafe {\n            'search: loop {\n                // The result of this search.\n                let mut result = Position {\n                    found: None,\n                    left: [&*self.head; MAX_HEIGHT],\n                    right: [Shared::null(); MAX_HEIGHT],\n                };\n\n                // The current level we're at.\n                let mut level = self.hot_data.max_height.load(Ordering::Relaxed);\n\n                // Fast loop to skip empty tower levels.\n                while level >= 1\n                    && self.head[level - 1]\n                        .load(Ordering::Relaxed, guard)\n                        .is_null()\n                {\n                    level -= 1;\n                }\n\n                // The predecessor node\n                let mut pred = &*self.head;\n\n                while level >= 1 {\n                    level -= 1;\n\n                    // Two adjacent nodes at the current level.\n                    let mut curr = pred[level].load_consume(guard);\n\n                    // If `curr` is marked, that means `pred` is removed and we have to restart the\n                    // search.\n                    if curr.tag() == 1 {\n                        continue 'search;\n                    }\n\n                    // Iterate through the current level until we reach a node with a key greater\n                    // than or equal to `key`.\n                    while let Some(c) = curr.as_ref() {\n                        let succ = c.tower[level].load_consume(guard);\n\n                        if succ.tag() == 1 {\n                            if let Some(c) = self.help_unlink(&pred[level], c, succ, guard) {\n                                // On success, continue searching through the current level.\n                                curr = c;\n                                continue;\n                            } else {\n                                // On failure, we cannot do anything reasonable to continue\n                                // searching from the current position. Restart the search.\n                                continue 'search;\n                            }\n                        }\n\n                        // If `curr` contains a key that is greater than or equal to `key`, we're\n                        // done with this level.\n                        match c.key.borrow().cmp(key) {\n                            cmp::Ordering::Greater => break,\n                            cmp::Ordering::Equal => {\n                                result.found = Some(c);\n                                break;\n                            }\n                            cmp::Ordering::Less => {}\n                        }\n\n                        // Move one step forward.\n                        pred = &c.tower;\n                        curr = succ;\n                    }\n\n                    // Store the position at the current level into the result.\n                    result.left[level] = pred;\n                    result.right[level] = curr;\n                }\n\n                return result;\n            }\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::SkipList::<K, V>::upper_bound":["/// Returns an `Entry` pointing to the highest element whose key is below\n/// the given bound. If no such element is found then `None` is\n/// returned.\npub fn upper_bound<'a: 'g, 'g, Q>(\n        &'a self,\n        bound: Bound<&Q>,\n        guard: &'g Guard,\n    ) -> Option<Entry<'a, 'g, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        self.check_guard(guard);\n        let n = self.search_bound(bound, true, guard)?;\n        Some(Entry {\n            parent: self,\n            node: n,\n            guard,\n        })\n    }","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::Tower":["/// The tower of atomic pointers.\n///\n/// The actual size of the tower will vary depending on the height that a node\n/// was allocated with.\n#[repr(C)]\nstruct Tower<K, V> {\n    pointers: [Atomic<Node<K, V>>; 0],\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::above_lower_bound":["/// Helper function to check if a value is above a lower bound\nfn above_lower_bound<T: Ord + ?Sized>(bound: &Bound<&T>, other: &T) -> bool{\n    match *bound {\n        Bound::Unbounded => true,\n        Bound::Included(key) => other >= key,\n        Bound::Excluded(key) => other > key,\n    }\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::below_upper_bound":["/// Helper function to check if a value is below an upper bound\nfn below_upper_bound<T: Ord + ?Sized>(bound: &Bound<&T>, other: &T) -> bool{\n    match *bound {\n        Bound::Unbounded => true,\n        Bound::Included(key) => other <= key,\n        Bound::Excluded(key) => other < key,\n    }\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"base::try_pin_loop":["/// Helper function to retry an operation until pinning succeeds or `None` is\n/// returned.\npub(crate) fn try_pin_loop<'a: 'g, 'g, F, K, V>(mut f: F) -> Option<RefEntry<'a, K, V>>\nwhere\n    F: FnMut() -> Option<Entry<'a, 'g, K, V>>,{\n    loop {\n        if let Some(e) = f()?.pin() {\n            return Some(e);\n        }\n    }\n}","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))"],"map::Entry":["/// A reference-counted entry in a map.\npub struct Entry<'a, K, V> {\n    inner: ManuallyDrop<base::RefEntry<'a, K, V>>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::Entry::<'_, K, V>::remove":["/// Removes the entry from the map.\n///\n/// Returns `true` if this call removed the entry and `false` if it was already removed.\npub fn remove(&self) -> bool{\n        let guard = &epoch::pin();\n        self.inner.remove(guard)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::Entry::<'a, K, V>::is_removed":["/// Returns `true` if the entry is removed from the map.\npub fn is_removed(&self) -> bool{\n        self.inner.is_removed()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::Entry::<'a, K, V>::key":["/// Returns a reference to the key.\npub fn key(&self) -> &K{\n        self.inner.key()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::Entry::<'a, K, V>::move_next":["/// Moves to the next entry in the map.\npub fn move_next(&mut self) -> bool{\n        let guard = &epoch::pin();\n        self.inner.move_next(guard)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::Entry::<'a, K, V>::move_prev":["/// Moves to the previous entry in the map.\npub fn move_prev(&mut self) -> bool{\n        let guard = &epoch::pin();\n        self.inner.move_prev(guard)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::Entry::<'a, K, V>::new":["fn new(inner: base::RefEntry<'a, K, V>) -> Entry<'a, K, V>{\n        Entry {\n            inner: ManuallyDrop::new(inner),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::Entry::<'a, K, V>::next":["/// Returns the next entry in the map.\npub fn next(&self) -> Option<Entry<'a, K, V>>{\n        let guard = &epoch::pin();\n        self.inner.next(guard).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::Entry::<'a, K, V>::prev":["/// Returns the previous entry in the map.\npub fn prev(&self) -> Option<Entry<'a, K, V>>{\n        let guard = &epoch::pin();\n        self.inner.prev(guard).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::Entry::<'a, K, V>::value":["/// Returns a reference to the value.\npub fn value(&self) -> &V{\n        self.inner.value()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::IntoIter":["/// An owning iterator over the entries of a `SkipMap`.\npub struct IntoIter<K, V> {\n    inner: base::IntoIter<K, V>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::Iter":["/// An iterator over the entries of a `SkipMap`.\npub struct Iter<'a, K, V> {\n    inner: base::RefIter<'a, K, V>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::Range":["/// An iterator over the entries of a `SkipMap`.\npub struct Range<'a, Q, R, K, V>\nwhere\n    K: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n    pub(crate) inner: base::RefRange<'a, Q, R, K, V>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap":["/// A map based on a lock-free skip list.\npub struct SkipMap<K, V> {\n    inner: base::SkipList<K, V>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::back":["/// Returns the entry with the largest key.\npub fn back(&self) -> Option<Entry<'_, K, V>>{\n        let guard = &epoch::pin();\n        try_pin_loop(|| self.inner.back(guard)).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::clear":["/// Iterates over the map and removes every entry.\npub fn clear(&self){\n        let guard = &mut epoch::pin();\n        self.inner.clear(guard);\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::contains_key":["/// Returns `true` if the map contains a value for the specified key.\npub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        let guard = &epoch::pin();\n        self.inner.contains_key(key, guard)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::front":["/// Returns the entry with the smallest key.\npub fn front(&self) -> Option<Entry<'_, K, V>>{\n        let guard = &epoch::pin();\n        try_pin_loop(|| self.inner.front(guard)).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::get":["/// Returns an entry with the specified `key`.\npub fn get<Q>(&self, key: &Q) -> Option<Entry<'_, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        let guard = &epoch::pin();\n        try_pin_loop(|| self.inner.get(key, guard)).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::get_or_insert":["/// Finds an entry with the specified key, or inserts a new `key`-`value` pair if none exist.\npub fn get_or_insert(&self, key: K, value: V) -> Entry<'_, K, V>{\n        let guard = &epoch::pin();\n        Entry::new(self.inner.get_or_insert(key, value, guard))\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::insert":["/// Inserts a `key`-`value` pair into the map and returns the new entry.\n///\n/// If there is an existing entry with this key, it will be removed before inserting the new\n/// one.\npub fn insert(&self, key: K, value: V) -> Entry<'_, K, V>{\n        let guard = &epoch::pin();\n        Entry::new(self.inner.insert(key, value, guard))\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::is_empty":["/// Returns `true` if the map is empty.\npub fn is_empty(&self) -> bool{\n        self.inner.is_empty()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::iter":["/// Returns an iterator over all entries in the map.\npub fn iter(&self) -> Iter<'_, K, V>{\n        Iter {\n            inner: self.inner.ref_iter(),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::len":["/// Returns the number of entries in the map.\n///\n/// If the map is being concurrently modified, consider the returned number just an\n/// approximation without any guarantees.\npub fn len(&self) -> usize{\n        self.inner.len()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::lower_bound":["/// Returns an `Entry` pointing to the lowest element whose key is above\n/// the given bound. If no such element is found then `None` is\n/// returned.\npub fn lower_bound<'a, Q>(&'a self, bound: Bound<&Q>) -> Option<Entry<'a, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        let guard = &epoch::pin();\n        try_pin_loop(|| self.inner.lower_bound(bound, guard)).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::new":["/// Returns a new, empty map.\npub fn new() -> SkipMap<K, V>{\n        SkipMap {\n            inner: base::SkipList::new(epoch::default_collector().clone()),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::pop_back":["/// Removes an entry from the back of the map.\npub fn pop_back(&self) -> Option<Entry<'_, K, V>>{\n        let guard = &epoch::pin();\n        self.inner.pop_back(guard).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::pop_front":["/// Removes an entry from the front of the map.\npub fn pop_front(&self) -> Option<Entry<'_, K, V>>{\n        let guard = &epoch::pin();\n        self.inner.pop_front(guard).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::range":["/// Returns an iterator over a subset of entries in the skip list.\npub fn range<Q, R>(&self, range: R) -> Range<'_, Q, R, K, V>\n    where\n        K: Borrow<Q>,\n        R: RangeBounds<Q>,\n        Q: Ord + ?Sized,{\n        Range {\n            inner: self.inner.ref_range(range),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::remove":["/// Removes an entry with the specified `key` from the map and returns it.\npub fn remove<Q>(&self, key: &Q) -> Option<Entry<'_, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        let guard = &epoch::pin();\n        self.inner.remove(key, guard).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"map::SkipMap::<K, V>::upper_bound":["/// Returns an `Entry` pointing to the highest element whose key is below\n/// the given bound. If no such element is found then `None` is\n/// returned.\npub fn upper_bound<'a, Q>(&'a self, bound: Bound<&Q>) -> Option<Entry<'a, K, V>>\n    where\n        K: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        let guard = &epoch::pin();\n        try_pin_loop(|| self.inner.upper_bound(bound, guard)).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))"],"set::Entry":["/// TODO\npub struct Entry<'a, T> {\n    inner: map::Entry<'a, T, ()>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::Entry::<'_, T>::remove":["/// Removes the entry from the set.\n///\n/// Returns `true` if this call removed the entry and `false` if it was already removed.\npub fn remove(&self) -> bool{\n        self.inner.remove()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::Entry::<'a, T>::is_removed":["/// Returns `true` if the entry is removed from the set.\npub fn is_removed(&self) -> bool{\n        self.inner.is_removed()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::Entry::<'a, T>::move_next":["/// TODO\npub fn move_next(&mut self) -> bool{\n        self.inner.move_next()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::Entry::<'a, T>::move_prev":["/// TODO\npub fn move_prev(&mut self) -> bool{\n        self.inner.move_prev()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::Entry::<'a, T>::new":["fn new(inner: map::Entry<'a, T, ()>) -> Entry<'a, T>{\n        Entry { inner }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::Entry::<'a, T>::next":["/// Returns the next entry in the set.\npub fn next(&self) -> Option<Entry<'a, T>>{\n        self.inner.next().map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::Entry::<'a, T>::prev":["/// Returns the previous entry in the set.\npub fn prev(&self) -> Option<Entry<'a, T>>{\n        self.inner.prev().map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::Entry::<'a, T>::value":["/// Returns a reference to the key.\npub fn value(&self) -> &T{\n        self.inner.key()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::IntoIter":["/// An owning iterator over the entries of a `SkipSet`.\npub struct IntoIter<T> {\n    inner: map::IntoIter<T, ()>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::Iter":["/// An iterator over the entries of a `SkipSet`.\npub struct Iter<'a, T> {\n    inner: map::Iter<'a, T, ()>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::Range":["/// An iterator over the entries of a `SkipMap`.\npub struct Range<'a, Q, R, T>\nwhere\n    T: Ord + Borrow<Q>,\n    R: RangeBounds<Q>,\n    Q: Ord + ?Sized,\n{\n    inner: map::Range<'a, Q, R, T, ()>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet":["/// A set based on a lock-free skip list.\npub struct SkipSet<T> {\n    inner: map::SkipMap<T, ()>,\n}","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::back":["/// Returns the entry with the largest key.\npub fn back(&self) -> Option<Entry<'_, T>>{\n        self.inner.back().map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::clear":["/// Iterates over the set and removes every entry.\npub fn clear(&self){\n        self.inner.clear();\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::contains":["/// Returns `true` if the set contains a value for the specified key.\npub fn contains<Q>(&self, key: &Q) -> bool\n    where\n        T: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        self.inner.contains_key(key)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::front":["/// Returns the entry with the smallest key.\npub fn front(&self) -> Option<Entry<'_, T>>{\n        self.inner.front().map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::get":["/// Returns an entry with the specified `key`.\npub fn get<Q>(&self, key: &Q) -> Option<Entry<'_, T>>\n    where\n        T: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        self.inner.get(key).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::get_or_insert":["/// Finds an entry with the specified key, or inserts a new `key`-`value` pair if none exist.\npub fn get_or_insert(&self, key: T) -> Entry<'_, T>{\n        Entry::new(self.inner.get_or_insert(key, ()))\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::insert":["/// Inserts a `key`-`value` pair into the set and returns the new entry.\n///\n/// If there is an existing entry with this key, it will be removed before inserting the new\n/// one.\npub fn insert(&self, key: T) -> Entry<'_, T>{\n        Entry::new(self.inner.insert(key, ()))\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::is_empty":["/// Returns `true` if the set is empty.\npub fn is_empty(&self) -> bool{\n        self.inner.is_empty()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::iter":["/// Returns an iterator over all entries in the map.\npub fn iter(&self) -> Iter<'_, T>{\n        Iter {\n            inner: self.inner.iter(),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::len":["/// Returns the number of entries in the set.\n///\n/// If the set is being concurrently modified, consider the returned number just an\n/// approximation without any guarantees.\npub fn len(&self) -> usize{\n        self.inner.len()\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::lower_bound":["/// Returns an `Entry` pointing to the lowest element whose key is above\n/// the given bound. If no such element is found then `None` is\n/// returned.\npub fn lower_bound<'a, Q>(&'a self, bound: Bound<&Q>) -> Option<Entry<'a, T>>\n    where\n        T: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        self.inner.lower_bound(bound).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::new":["/// Returns a new, empty set.\npub fn new() -> SkipSet<T>{\n        SkipSet {\n            inner: map::SkipMap::new(),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::pop_back":["/// Removes an entry from the back of the map.\npub fn pop_back(&self) -> Option<Entry<'_, T>>{\n        self.inner.pop_back().map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::pop_front":["/// Removes an entry from the front of the map.\npub fn pop_front(&self) -> Option<Entry<'_, T>>{\n        self.inner.pop_front().map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::range":["/// Returns an iterator over a subset of entries in the skip list.\npub fn range<Q, R>(&self, range: R) -> Range<'_, Q, R, T>\n    where\n        T: Borrow<Q>,\n        R: RangeBounds<Q>,\n        Q: Ord + ?Sized,{\n        Range {\n            inner: self.inner.range(range),\n        }\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::remove":["/// Removes an entry with the specified key from the set and returns it.\npub fn remove<Q>(&self, key: &Q) -> Option<Entry<'_, T>>\n    where\n        T: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        self.inner.remove(key).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"],"set::SkipSet::<T>::upper_bound":["/// Returns an `Entry` pointing to the highest element whose key is below\n/// the given bound. If no such element is found then `None` is\n/// returned.\npub fn upper_bound<'a, Q>(&'a self, bound: Bound<&Q>) -> Option<Entry<'a, T>>\n    where\n        T: Borrow<Q>,\n        Q: Ord + ?Sized,{\n        self.inner.upper_bound(bound).map(Entry::new)\n    }","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))"]},"struct_constructor":{"(K, V)":["next"],"base::Entry":["back","clone","front","get","lower_bound","next","next_back","prev","upper_bound"],"base::Head":["new"],"base::IntoIter":["into_iter"],"base::Iter":["iter"],"base::Position":["search_position"],"base::Range":["range"],"base::RefEntry":["clone","get_or_insert","insert","insert_internal","next","next_back","pin","pop_back","pop_front","prev","remove","try_acquire","try_pin_loop"],"base::RefIter":["ref_iter"],"base::RefRange":["ref_range"],"base::SkipList":["new"],"bool":["above_lower_bound","below_upper_bound","contains","contains_key","is_empty","is_removed","mark_tower","move_next","move_prev","remove","try_increment"],"map::Entry":["back","clone","front","get","get_or_insert","insert","lower_bound","new","next","next_back","pop_back","pop_front","prev","remove","upper_bound"],"map::IntoIter":["into_iter"],"map::Iter":["into_iter","iter"],"map::Range":["range"],"map::SkipMap":["default","from_iter","new"],"set::Entry":["back","clone","front","get","get_or_insert","insert","lower_bound","new","next","next_back","pop_back","pop_front","prev","remove","upper_bound"],"set::IntoIter":["into_iter"],"set::Iter":["into_iter","iter"],"set::Range":["range"],"set::SkipSet":["default","from_iter","new"],"std::alloc::Layout":["get_layout"],"usize":["height","len","random_height"]},"struct_to_trait":{"base::Entry":["std::clone::Clone","std::fmt::Debug"],"base::Head":["std::ops::Deref"],"base::IntoIter":["std::fmt::Debug","std::iter::Iterator","std::ops::Drop"],"base::Iter":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"base::Node":["std::fmt::Debug"],"base::Range":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"base::RefEntry":["std::clone::Clone","std::fmt::Debug"],"base::RefIter":["std::fmt::Debug"],"base::RefRange":["std::fmt::Debug","std::marker::Send","std::marker::Sync"],"base::SkipList":["std::fmt::Debug","std::iter::IntoIterator","std::marker::Send","std::marker::Sync","std::ops::Drop"],"base::Tower":["std::ops::Index"],"map::Entry":["std::clone::Clone","std::fmt::Debug","std::ops::Drop"],"map::IntoIter":["std::fmt::Debug","std::iter::Iterator"],"map::Iter":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"map::Range":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"map::SkipMap":["std::default::Default","std::fmt::Debug","std::iter::FromIterator","std::iter::IntoIterator"],"set::Entry":["std::clone::Clone","std::fmt::Debug"],"set::IntoIter":["std::fmt::Debug","std::iter::Iterator"],"set::Iter":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"set::Range":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"set::SkipSet":["std::default::Default","std::fmt::Debug","std::iter::FromIterator","std::iter::IntoIterator"]},"targets":{"<&'a map::SkipMap<K, V> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::iter::IntoIterator"],"<&'a set::SkipSet<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::iter::IntoIterator"],"<base::Entry<'_, '_, K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::fmt::Debug"],"<base::Entry<'a, 'g, K, V> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::clone::Clone"],"<base::Head<K, V> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::ops::Deref"],"<base::IntoIter<K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::fmt::Debug"],"<base::IntoIter<K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::iter::Iterator"],"<base::IntoIter<K, V> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::ops::Drop"],"<base::Iter<'_, '_, K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::fmt::Debug"],"<base::Iter<'a, 'g, K, V> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::iter::DoubleEndedIterator"],"<base::Iter<'a, 'g, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::iter::Iterator"],"<base::Node<K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::fmt::Debug"],"<base::Range<'_, '_, Q, R, K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::fmt::Debug"],"<base::Range<'a, 'g, Q, R, K, V> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::iter::DoubleEndedIterator"],"<base::Range<'a, 'g, Q, R, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::iter::Iterator"],"<base::RefEntry<'_, K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::fmt::Debug"],"<base::RefEntry<'a, K, V> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::clone::Clone"],"<base::RefIter<'_, K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::fmt::Debug"],"<base::RefRange<'_, Q, R, K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::fmt::Debug"],"<base::SkipList<K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::fmt::Debug"],"<base::SkipList<K, V> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::iter::IntoIterator"],"<base::SkipList<K, V> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::ops::Drop"],"<base::Tower<K, V> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))","std::ops::Index"],"<map::Entry<'_, K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::fmt::Debug"],"<map::Entry<'_, K, V> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::ops::Drop"],"<map::Entry<'a, K, V> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::clone::Clone"],"<map::IntoIter<K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::fmt::Debug"],"<map::IntoIter<K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::iter::Iterator"],"<map::Iter<'_, K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::fmt::Debug"],"<map::Iter<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::Iter<'a, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::iter::Iterator"],"<map::Range<'_, Q, R, K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::fmt::Debug"],"<map::Range<'a, Q, R, K, V> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::Range<'a, Q, R, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::iter::Iterator"],"<map::SkipMap<K, V> as std::default::Default>::default":["default","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::default::Default"],"<map::SkipMap<K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::fmt::Debug"],"<map::SkipMap<K, V> as std::iter::FromIterator<(K, V)>>::from_iter":["from_iter","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::iter::FromIterator"],"<map::SkipMap<K, V> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))","std::iter::IntoIterator"],"<set::Entry<'_, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::fmt::Debug"],"<set::Entry<'a, T> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::clone::Clone"],"<set::IntoIter<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::fmt::Debug"],"<set::IntoIter<T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::iter::Iterator"],"<set::Iter<'_, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::fmt::Debug"],"<set::Iter<'a, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::iter::DoubleEndedIterator"],"<set::Iter<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::iter::Iterator"],"<set::Range<'_, Q, R, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::fmt::Debug"],"<set::Range<'a, Q, R, T> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::iter::DoubleEndedIterator"],"<set::Range<'a, Q, R, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::iter::Iterator"],"<set::SkipSet<T> as std::default::Default>::default":["default","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::default::Default"],"<set::SkipSet<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::fmt::Debug"],"<set::SkipSet<T> as std::iter::FromIterator<T>>::from_iter":["from_iter","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::iter::FromIterator"],"<set::SkipSet<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))","std::iter::IntoIterator"],"base::Entry::<'a, 'g, K, V>::is_removed":["is_removed","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Entry::<'a, 'g, K, V>::key":["key","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Entry::<'a, 'g, K, V>::move_next":["move_next","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Entry::<'a, 'g, K, V>::move_prev":["move_prev","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Entry::<'a, 'g, K, V>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Entry::<'a, 'g, K, V>::pin":["pin","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Entry::<'a, 'g, K, V>::prev":["prev","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Entry::<'a, 'g, K, V>::remove":["remove","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Entry::<'a, 'g, K, V>::skiplist":["skiplist","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Entry::<'a, 'g, K, V>::value":["value","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Head::<K, V>::new":["new","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Node::<K, V>::alloc":["alloc","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Node::<K, V>::dealloc":["dealloc","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Node::<K, V>::decrement":["decrement","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Node::<K, V>::decrement_with_pin":["decrement_with_pin","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Node::<K, V>::finalize":["finalize","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Node::<K, V>::get_layout":["get_layout","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Node::<K, V>::height":["height","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Node::<K, V>::is_removed":["is_removed","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Node::<K, V>::mark_tower":["mark_tower","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::Node::<K, V>::try_increment":["try_increment","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'_, K, V>::remove":["remove","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'a, K, V>::is_removed":["is_removed","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'a, K, V>::key":["key","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'a, K, V>::move_next":["move_next","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'a, K, V>::move_prev":["move_prev","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'a, K, V>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'a, K, V>::prev":["prev","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'a, K, V>::release":["release","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'a, K, V>::release_with_pin":["release_with_pin","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'a, K, V>::skiplist":["skiplist","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'a, K, V>::try_acquire":["try_acquire","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefEntry::<'a, K, V>::value":["value","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefIter::<'a, K, V>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefIter::<'a, K, V>::next_back":["next_back","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefRange::<'a, Q, R, K, V>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::RefRange::<'a, Q, R, K, V>::next_back":["next_back","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::back":["back","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::check_guard":["check_guard","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::clear":["clear","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::contains_key":["contains_key","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::front":["front","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::get":["get","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::get_or_insert":["get_or_insert","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::help_unlink":["help_unlink","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::insert":["insert","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::insert_internal":["insert_internal","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::is_empty":["is_empty","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::iter":["iter","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::len":["len","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::lower_bound":["lower_bound","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::new":["new","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::next_node":["next_node","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::pop_back":["pop_back","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::pop_front":["pop_front","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::random_height":["random_height","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::range":["range","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::ref_iter":["ref_iter","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::ref_range":["ref_range","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::remove":["remove","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::search_bound":["search_bound","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::search_position":["search_position","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::SkipList::<K, V>::upper_bound":["upper_bound","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::above_lower_bound":["above_lower_bound","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::below_upper_bound":["below_upper_bound","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"base::try_pin_loop":["try_pin_loop","Real(LocalPath(\"crossbeam-skiplist/src/base.rs\"))",""],"map::Entry::<'_, K, V>::remove":["remove","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::Entry::<'a, K, V>::is_removed":["is_removed","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::Entry::<'a, K, V>::key":["key","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::Entry::<'a, K, V>::move_next":["move_next","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::Entry::<'a, K, V>::move_prev":["move_prev","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::Entry::<'a, K, V>::new":["new","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::Entry::<'a, K, V>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::Entry::<'a, K, V>::prev":["prev","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::Entry::<'a, K, V>::value":["value","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::back":["back","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::clear":["clear","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::contains_key":["contains_key","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::front":["front","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::get":["get","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::get_or_insert":["get_or_insert","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::insert":["insert","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::is_empty":["is_empty","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::iter":["iter","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::len":["len","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::lower_bound":["lower_bound","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::new":["new","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::pop_back":["pop_back","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::pop_front":["pop_front","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::range":["range","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::remove":["remove","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"map::SkipMap::<K, V>::upper_bound":["upper_bound","Real(LocalPath(\"crossbeam-skiplist/src/map.rs\"))",""],"set::Entry::<'_, T>::remove":["remove","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::Entry::<'a, T>::is_removed":["is_removed","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::Entry::<'a, T>::move_next":["move_next","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::Entry::<'a, T>::move_prev":["move_prev","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::Entry::<'a, T>::new":["new","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::Entry::<'a, T>::next":["next","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::Entry::<'a, T>::prev":["prev","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::Entry::<'a, T>::value":["value","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::back":["back","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::clear":["clear","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::contains":["contains","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::front":["front","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::get":["get","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::get_or_insert":["get_or_insert","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::insert":["insert","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::is_empty":["is_empty","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::iter":["iter","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::len":["len","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::lower_bound":["lower_bound","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::new":["new","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::pop_back":["pop_back","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::pop_front":["pop_front","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::range":["range","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::remove":["remove","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""],"set::SkipSet::<T>::upper_bound":["upper_bound","Real(LocalPath(\"crossbeam-skiplist/src/set.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["base::Entry","base::RefEntry","map::Entry","set::Entry"],"std::default::Default":["map::SkipMap","set::SkipSet"],"std::fmt::Debug":["base::Entry","base::IntoIter","base::Iter","base::Node","base::Range","base::RefEntry","base::RefIter","base::RefRange","base::SkipList","map::Entry","map::IntoIter","map::Iter","map::Range","map::SkipMap","set::Entry","set::IntoIter","set::Iter","set::Range","set::SkipSet"],"std::iter::DoubleEndedIterator":["base::Iter","base::Range","map::Iter","map::Range","set::Iter","set::Range"],"std::iter::FromIterator":["map::SkipMap","set::SkipSet"],"std::iter::IntoIterator":["base::SkipList","map::SkipMap","set::SkipSet"],"std::iter::Iterator":["base::IntoIter","base::Iter","base::Range","map::IntoIter","map::Iter","map::Range","set::IntoIter","set::Iter","set::Range"],"std::marker::Send":["base::RefRange","base::SkipList"],"std::marker::Sync":["base::RefRange","base::SkipList"],"std::ops::Deref":["base::Head"],"std::ops::Drop":["base::IntoIter","base::SkipList","map::Entry"],"std::ops::Index":["base::Tower"]},"type_to_def_path":{"base::Entry<'a, 'g, K, V>":"base::Entry","base::Head<K, V>":"base::Head","base::HotData":"base::HotData","base::IntoIter<K, V>":"base::IntoIter","base::Iter<'a, 'g, K, V>":"base::Iter","base::Node<K, V>":"base::Node","base::Position<'a, K, V>":"base::Position","base::Range<'a, 'g, Q, R, K, V>":"base::Range","base::RefEntry<'a, K, V>":"base::RefEntry","base::RefIter<'a, K, V>":"base::RefIter","base::RefRange<'a, Q, R, K, V>":"base::RefRange","base::SkipList<K, V>":"base::SkipList","base::Tower<K, V>":"base::Tower","map::Entry<'a, K, V>":"map::Entry","map::IntoIter<K, V>":"map::IntoIter","map::Iter<'a, K, V>":"map::Iter","map::Range<'a, Q, R, K, V>":"map::Range","map::SkipMap<K, V>":"map::SkipMap","set::Entry<'a, T>":"set::Entry","set::IntoIter<T>":"set::IntoIter","set::Iter<'a, T>":"set::Iter","set::Range<'a, Q, R, T>":"set::Range","set::SkipSet<T>":"set::SkipSet"}}