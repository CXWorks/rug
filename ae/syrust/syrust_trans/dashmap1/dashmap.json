{"dependencies":{"<&'a DashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<&'a DashMap<K, V, S> as std::ops::BitAnd<&Q>>::bitand":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<&'a DashMap<K, V, S> as std::ops::BitOr<&Q>>::bitor":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<&'a DashMap<K, V, S> as std::ops::Shl<(K, V)>>::shl":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<&'a DashMap<K, V, S> as std::ops::Shr<&Q>>::shr":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<&'a DashMap<K, V, S> as std::ops::Sub<&Q>>::sub":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<DashMap<K, V, S> as std::clone::Clone>::clone":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<DashMap<K, V, S> as std::default::Default>::default":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<DashMap<K, V, S> as std::fmt::Debug>::fmt":["DashMap","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<DashMap<K, V, S> as std::iter::Extend<(K, V)>>::extend":["DashMap","std::alloc::Allocator","std::boxed::Box","std::iter::IntoIterator","std::marker::Sized"],"<DashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_alter":["DashMap","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::ops::FnOnce"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_alter_all":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::FnMut"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_capacity":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_entry":["DashMap","lock::RwLockWriteGuard","mapref::entry::Entry","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_get":["DashMap","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_get_mut":["DashMap","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_get_read_shard":["DashMap","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_hasher":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_insert":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_iter":["DashMap","iter::Iter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_iter_mut":["DashMap","iter::IterMut","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_len":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_remove":["DashMap","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_remove_if":["DashMap","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::ops::FnOnce","std::option::Option"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_retain":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::FnMut"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_shard_count":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_shrink_to_fit":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_yield_read_shard":["DashMap","lock::RwLockReadGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_yield_write_shard":["DashMap","lock::RwLockWriteGuard","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<DashMap<K, V> as std::iter::FromIterator<(K, V)>>::from_iter":["DashMap","std::alloc::Allocator","std::boxed::Box","std::iter::IntoIterator","std::marker::Sized"],"<iter::Iter<'a, K, V, S, M> as std::iter::Iterator>::next":["iter::Iter","std::marker::Sized","std::option::Option"],"<iter::IterMut<'a, K, V, S, M> as std::iter::Iterator>::next":["iter::IterMut","std::marker::Sized","std::option::Option"],"<iter::OwningIter<K, V, S> as std::iter::Iterator>::next":["DashMap","iter::OwningIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<iter_set::Iter<'a, K, S, M> as std::iter::Iterator>::next":["iter::Iter","iter_set::Iter","std::marker::Sized","std::option::Option"],"<iter_set::OwningIter<K, S> as std::iter::Iterator>::next":["DashMap","iter::OwningIter","iter_set::OwningIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<lock::RwLock<T> as std::default::Default>::default":["lock::RwLock","std::cell::UnsafeCell","std::sync::atomic::AtomicUsize"],"<lock::RwLock<T> as std::fmt::Debug>::fmt":["lock::RwLock","std::cell::UnsafeCell","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::atomic::AtomicUsize"],"<lock::RwLockReadGuard<'a, T> as std::fmt::Debug>::fmt":["lock::RwLockReadGuard","std::fmt::Formatter","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::atomic::AtomicUsize"],"<lock::RwLockReadGuard<'rwlock, T> as std::ops::Deref>::deref":["lock::RwLockReadGuard","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<lock::RwLockReadGuard<'rwlock, T> as std::ops::Drop>::drop":["lock::RwLockReadGuard","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<lock::RwLockUpgradeableGuard<'a, T> as std::fmt::Debug>::fmt":["lock::RwLockUpgradeableGuard","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::atomic::AtomicUsize"],"<lock::RwLockUpgradeableGuard<'rwlock, T> as std::ops::Deref>::deref":["lock::RwLockUpgradeableGuard","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<lock::RwLockUpgradeableGuard<'rwlock, T> as std::ops::Drop>::drop":["lock::RwLockUpgradeableGuard","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<lock::RwLockWriteGuard<'a, T> as std::fmt::Debug>::fmt":["lock::RwLockWriteGuard","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::atomic::AtomicUsize"],"<lock::RwLockWriteGuard<'rwlock, T> as std::ops::Deref>::deref":["lock::RwLockWriteGuard","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<lock::RwLockWriteGuard<'rwlock, T> as std::ops::DerefMut>::deref_mut":["lock::RwLockWriteGuard","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<lock::RwLockWriteGuard<'rwlock, T> as std::ops::Drop>::drop":["lock::RwLockWriteGuard","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<mapref::multiple::RefMulti<'a, K, V, S> as std::ops::Deref>::deref":["mapref::multiple::RefMulti","std::marker::Sized","std::sync::Arc"],"<mapref::multiple::RefMutMulti<'a, K, V, S> as std::ops::Deref>::deref":["mapref::multiple::RefMutMulti","std::marker::Sized","std::sync::Arc"],"<mapref::multiple::RefMutMulti<'a, K, V, S> as std::ops::DerefMut>::deref_mut":["mapref::multiple::RefMutMulti","std::marker::Sized","std::sync::Arc"],"<mapref::one::Ref<'a, K, V, S> as std::ops::Deref>::deref":["lock::RwLockReadGuard","mapref::one::Ref","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<mapref::one::RefMut<'a, K, V, S> as std::ops::Deref>::deref":["lock::RwLockWriteGuard","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<mapref::one::RefMut<'a, K, V, S> as std::ops::DerefMut>::deref_mut":["lock::RwLockWriteGuard","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<read_only::ReadOnlyView<K, V, S> as std::clone::Clone>::clone":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<read_only::ReadOnlyView<K, V, S> as std::fmt::Debug>::fmt":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<set::DashSet<K, S> as std::clone::Clone>::clone":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<set::DashSet<K, S> as std::clone::Clone>::clone_from":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<set::DashSet<K, S> as std::default::Default>::default":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<set::DashSet<K, S> as std::fmt::Debug>::fmt":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<set::DashSet<K, S> as std::iter::Extend<K>>::extend":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::iter::IntoIterator","std::marker::Sized"],"<set::DashSet<K, S> as std::iter::IntoIterator>::into_iter":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<set::DashSet<K> as std::iter::FromIterator<K>>::from_iter":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::iter::IntoIterator","std::marker::Sized"],"<setref::multiple::RefMulti<'a, K, S> as std::ops::Deref>::deref":["mapref::multiple::RefMulti","setref::multiple::RefMulti","std::marker::Sized","std::sync::Arc"],"<setref::one::Ref<'a, K, S> as std::ops::Deref>::deref":["lock::RwLockReadGuard","mapref::one::Ref","setref::one::Ref","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"<util::AbortOnPanic as std::ops::Drop>::drop":["util::AbortOnPanic"],"<util::SharedValue<T> as std::clone::Clone>::clone":["std::cell::UnsafeCell","std::marker::Sized","util::SharedValue"],"DashMap":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V, S>::alter":["DashMap","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::ops::FnOnce"],"DashMap::<K, V, S>::alter_all":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::FnMut"],"DashMap::<K, V, S>::capacity":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V, S>::clear":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V, S>::contains_key":["DashMap","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized"],"DashMap::<K, V, S>::determine_shard":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V, S>::entry":["DashMap","lock::RwLockWriteGuard","mapref::entry::Entry","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"DashMap::<K, V, S>::get":["DashMap","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"DashMap::<K, V, S>::get_mut":["DashMap","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"DashMap::<K, V, S>::hash_usize":["DashMap","std::alloc::Allocator","std::boxed::Box","std::hash::Hash","std::marker::Sized"],"DashMap::<K, V, S>::hasher":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V, S>::insert":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"DashMap::<K, V, S>::into_read_only":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V, S>::is_empty":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V, S>::iter":["DashMap","iter::Iter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"DashMap::<K, V, S>::iter_mut":["DashMap","iter::IterMut","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"DashMap::<K, V, S>::len":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V, S>::remove":["DashMap","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"DashMap::<K, V, S>::remove_if":["DashMap","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::ops::FnOnce","std::option::Option"],"DashMap::<K, V, S>::retain":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::FnMut"],"DashMap::<K, V, S>::shards":["DashMap","lock::RwLock","std::alloc::Allocator","std::boxed::Box","std::cell::UnsafeCell","std::marker::Sized","std::sync::atomic::AtomicUsize"],"DashMap::<K, V, S>::shrink_to_fit":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V, S>::with_capacity_and_hasher":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V, S>::with_hasher":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V>::new":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"DashMap::<K, V>::with_capacity":["DashMap","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"iter::Iter":["iter::Iter","std::marker::Sized","std::option::Option"],"iter::Iter::<'a, K, V, S, M>::new":["iter::Iter","std::marker::Sized","std::option::Option"],"iter::IterMut":["iter::IterMut","std::marker::Sized","std::option::Option"],"iter::IterMut::<'a, K, V, S, M>::new":["iter::IterMut","std::marker::Sized","std::option::Option"],"iter::OwningIter":["DashMap","iter::OwningIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"iter::OwningIter::<K, V, S>::new":["DashMap","iter::OwningIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"iter_set::Iter":["iter::Iter","iter_set::Iter","std::marker::Sized","std::option::Option"],"iter_set::Iter::<'a, K, S, M>::new":["iter::Iter","iter_set::Iter","std::marker::Sized","std::option::Option"],"iter_set::OwningIter":["DashMap","iter::OwningIter","iter_set::OwningIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"iter_set::OwningIter::<K, S>::new":["DashMap","iter::OwningIter","iter_set::OwningIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"lock::RwLock":["lock::RwLock","std::cell::UnsafeCell","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::force_read_decrement":["lock::RwLock","std::cell::UnsafeCell","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::force_write_unlock":["lock::RwLock","std::cell::UnsafeCell","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::get":["lock::RwLock","std::cell::UnsafeCell","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::get_mut":["lock::RwLock","std::cell::UnsafeCell","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::into_inner":["lock::RwLock","std::cell::UnsafeCell","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::new":["lock::RwLock","std::cell::UnsafeCell","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::read":["lock::RwLock","lock::RwLockReadGuard","std::cell::UnsafeCell","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::try_read":["lock::RwLock","std::cell::UnsafeCell","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::try_upgradeable_read":["lock::RwLock","std::cell::UnsafeCell","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::try_write":["lock::RwLock","std::cell::UnsafeCell","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::try_write_internal":["lock::RwLock","std::cell::UnsafeCell","std::marker::Sized","std::option::Option","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::upgradeable_read":["lock::RwLock","lock::RwLockUpgradeableGuard","std::cell::UnsafeCell","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"lock::RwLock::<T>::write":["lock::RwLock","lock::RwLockWriteGuard","std::cell::UnsafeCell","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"lock::RwLockReadGuard":["lock::RwLockReadGuard","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"lock::RwLockUpgradeableGuard":["lock::RwLockUpgradeableGuard","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"lock::RwLockUpgradeableGuard::<'rwlock, T>::downgrade":["lock::RwLockReadGuard","lock::RwLockUpgradeableGuard","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"lock::RwLockUpgradeableGuard::<'rwlock, T>::try_upgrade":["lock::RwLockUpgradeableGuard","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::atomic::AtomicUsize"],"lock::RwLockUpgradeableGuard::<'rwlock, T>::try_upgrade_internal":["lock::RwLockUpgradeableGuard","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::sync::atomic::AtomicUsize"],"lock::RwLockUpgradeableGuard::<'rwlock, T>::upgrade":["lock::RwLockUpgradeableGuard","lock::RwLockWriteGuard","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"lock::RwLockWriteGuard":["lock::RwLockWriteGuard","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"lock::RwLockWriteGuard::<'rwlock, T>::downgrade":["lock::RwLockReadGuard","lock::RwLockWriteGuard","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"lock::compare_exchange":["std::marker::Sized","std::result::Result","std::sync::atomic::AtomicUsize","std::sync::atomic::Ordering"],"mapref::entry::Entry":["lock::RwLockWriteGuard","mapref::entry::Entry","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::Entry::<'a, K, V, S>::and_modify":["lock::RwLockWriteGuard","mapref::entry::Entry","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::Entry::<'a, K, V, S>::into_key":["lock::RwLockWriteGuard","mapref::entry::Entry","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::Entry::<'a, K, V, S>::key":["lock::RwLockWriteGuard","mapref::entry::Entry","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::Entry::<'a, K, V, S>::or_default":["DashMap","lock::RwLockWriteGuard","mapref::entry::Entry","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","mapref::one::RefMut","std::alloc::Allocator","std::boxed::Box","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::Entry::<'a, K, V, S>::or_insert":["lock::RwLockWriteGuard","mapref::entry::Entry","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::Entry::<'a, K, V, S>::or_insert_with":["lock::RwLockWriteGuard","mapref::entry::Entry","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::Entry::<'a, K, V, S>::or_try_insert_with":["lock::RwLockWriteGuard","mapref::entry::Entry","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::ptr::NonNull","std::result::Result","std::sync::atomic::AtomicUsize"],"mapref::entry::OccupiedEntry":["lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::get":["lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::get_mut":["lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::insert":["lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::into_key":["lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::into_ref":["lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::key":["lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::new":["lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::remove":["lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::remove_entry":["lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::replace_entry":["lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::VacantEntry":["lock::RwLockWriteGuard","mapref::entry::VacantEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::VacantEntry::<'a, K, V, S>::insert":["lock::RwLockWriteGuard","mapref::entry::VacantEntry","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::VacantEntry::<'a, K, V, S>::into_key":["lock::RwLockWriteGuard","mapref::entry::VacantEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::VacantEntry::<'a, K, V, S>::key":["lock::RwLockWriteGuard","mapref::entry::VacantEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::entry::VacantEntry::<'a, K, V, S>::new":["lock::RwLockWriteGuard","mapref::entry::VacantEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::multiple::RefMulti":["mapref::multiple::RefMulti","std::marker::Sized","std::sync::Arc"],"mapref::multiple::RefMulti::<'a, K, V, S>::key":["mapref::multiple::RefMulti","std::marker::Sized","std::sync::Arc"],"mapref::multiple::RefMulti::<'a, K, V, S>::new":["mapref::multiple::RefMulti","std::marker::Sized","std::sync::Arc"],"mapref::multiple::RefMulti::<'a, K, V, S>::pair":["mapref::multiple::RefMulti","std::marker::Sized","std::sync::Arc"],"mapref::multiple::RefMulti::<'a, K, V, S>::value":["mapref::multiple::RefMulti","std::marker::Sized","std::sync::Arc"],"mapref::multiple::RefMutMulti":["mapref::multiple::RefMutMulti","std::marker::Sized","std::sync::Arc"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::key":["mapref::multiple::RefMutMulti","std::marker::Sized","std::sync::Arc"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::new":["mapref::multiple::RefMutMulti","std::marker::Sized","std::sync::Arc"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::pair":["mapref::multiple::RefMutMulti","std::marker::Sized","std::sync::Arc"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::pair_mut":["mapref::multiple::RefMutMulti","std::marker::Sized","std::sync::Arc"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::value":["mapref::multiple::RefMutMulti","std::marker::Sized","std::sync::Arc"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::value_mut":["mapref::multiple::RefMutMulti","std::marker::Sized","std::sync::Arc"],"mapref::one::Ref":["lock::RwLockReadGuard","mapref::one::Ref","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::Ref::<'a, K, V, S>::key":["lock::RwLockReadGuard","mapref::one::Ref","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::Ref::<'a, K, V, S>::new":["lock::RwLockReadGuard","mapref::one::Ref","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::Ref::<'a, K, V, S>::pair":["lock::RwLockReadGuard","mapref::one::Ref","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::Ref::<'a, K, V, S>::value":["lock::RwLockReadGuard","mapref::one::Ref","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::RefMut":["lock::RwLockWriteGuard","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::RefMut::<'a, K, V, S>::downgrade":["lock::RwLockReadGuard","lock::RwLockWriteGuard","mapref::one::Ref","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::RefMut::<'a, K, V, S>::key":["lock::RwLockWriteGuard","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::RefMut::<'a, K, V, S>::new":["lock::RwLockWriteGuard","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::RefMut::<'a, K, V, S>::pair":["lock::RwLockWriteGuard","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::RefMut::<'a, K, V, S>::pair_mut":["lock::RwLockWriteGuard","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::RefMut::<'a, K, V, S>::value":["lock::RwLockWriteGuard","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"mapref::one::RefMut::<'a, K, V, S>::value_mut":["lock::RwLockWriteGuard","mapref::one::RefMut","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"ncb":[],"read_only::ReadOnlyView":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"read_only::ReadOnlyView::<K, V, S>::capacity":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"read_only::ReadOnlyView::<K, V, S>::contains_key":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized"],"read_only::ReadOnlyView::<K, V, S>::get":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"read_only::ReadOnlyView::<K, V, S>::get_key_value":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"read_only::ReadOnlyView::<K, V, S>::into_inner":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"read_only::ReadOnlyView::<K, V, S>::is_empty":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"read_only::ReadOnlyView::<K, V, S>::iter":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"read_only::ReadOnlyView::<K, V, S>::keys":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"read_only::ReadOnlyView::<K, V, S>::len":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"read_only::ReadOnlyView::<K, V, S>::new":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"read_only::ReadOnlyView::<K, V, S>::shard_read_iter":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"read_only::ReadOnlyView::<K, V, S>::values":["DashMap","read_only::ReadOnlyView","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"set::DashSet":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"set::DashSet::<K, S>::capacity":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"set::DashSet::<K, S>::clear":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"set::DashSet::<K, S>::contains":["DashMap","set::DashSet","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized"],"set::DashSet::<K, S>::get":["DashMap","set::DashSet","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"set::DashSet::<K, S>::hash_usize":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::hash::Hash","std::marker::Sized"],"set::DashSet::<K, S>::insert":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"set::DashSet::<K, S>::is_empty":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"set::DashSet::<K, S>::iter":["DashMap","iter::Iter","iter_set::Iter","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"set::DashSet::<K, S>::len":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"set::DashSet::<K, S>::remove":["DashMap","set::DashSet","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"set::DashSet::<K, S>::remove_if":["DashMap","set::DashSet","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::ops::FnOnce","std::option::Option"],"set::DashSet::<K, S>::retain":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::FnMut"],"set::DashSet::<K, S>::shrink_to_fit":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"set::DashSet::<K, S>::with_capacity_and_hasher":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"set::DashSet::<K, S>::with_hasher":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"set::DashSet::<K>::new":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"set::DashSet::<K>::with_capacity":["DashMap","set::DashSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"setref::multiple::RefMulti":["mapref::multiple::RefMulti","setref::multiple::RefMulti","std::marker::Sized","std::sync::Arc"],"setref::multiple::RefMulti::<'a, K, S>::key":["mapref::multiple::RefMulti","setref::multiple::RefMulti","std::marker::Sized","std::sync::Arc"],"setref::multiple::RefMulti::<'a, K, S>::new":["mapref::multiple::RefMulti","setref::multiple::RefMulti","std::marker::Sized","std::sync::Arc"],"setref::one::Ref":["lock::RwLockReadGuard","mapref::one::Ref","setref::one::Ref","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"setref::one::Ref::<'a, K, S>::key":["lock::RwLockReadGuard","mapref::one::Ref","setref::one::Ref","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"setref::one::Ref::<'a, K, S>::new":["lock::RwLockReadGuard","mapref::one::Ref","setref::one::Ref","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"shard_amount":[],"t::Map::_alter":["std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::ops::FnOnce"],"t::Map::_alter_all":["std::marker::Sized","std::ops::FnMut"],"t::Map::_capacity":[],"t::Map::_clear":[],"t::Map::_contains_key":["std::borrow::Borrow","std::cmp::Eq","std::hash::Hash"],"t::Map::_entry":["lock::RwLockWriteGuard","mapref::entry::Entry","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"t::Map::_get":["std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"t::Map::_get_mut":["std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"t::Map::_get_read_shard":["std::collections::HashMap","std::marker::Sized"],"t::Map::_hasher":[],"t::Map::_insert":["std::marker::Sized","std::option::Option"],"t::Map::_is_empty":[],"t::Map::_iter":["iter::Iter","std::marker::Sized","std::option::Option"],"t::Map::_iter_mut":["iter::IterMut","std::marker::Sized","std::option::Option"],"t::Map::_len":[],"t::Map::_remove":["std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::option::Option"],"t::Map::_remove_if":["std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::ops::FnOnce","std::option::Option"],"t::Map::_retain":["std::marker::Sized","std::ops::FnMut"],"t::Map::_shard_count":[],"t::Map::_shrink_to_fit":[],"t::Map::_yield_read_shard":["lock::RwLockReadGuard","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"t::Map::_yield_write_shard":["lock::RwLockWriteGuard","std::marker::PhantomData","std::ptr::NonNull","std::sync::atomic::AtomicUsize"],"util::AbortOnPanic":["util::AbortOnPanic"],"util::SharedValue":["std::cell::UnsafeCell","std::marker::Sized","util::SharedValue"],"util::SharedValue::<T>::as_ptr":["std::cell::UnsafeCell","std::marker::Sized","util::SharedValue"],"util::SharedValue::<T>::get":["std::cell::UnsafeCell","std::marker::Sized","util::SharedValue"],"util::SharedValue::<T>::get_mut":["std::cell::UnsafeCell","std::marker::Sized","util::SharedValue"],"util::SharedValue::<T>::into_inner":["std::cell::UnsafeCell","std::marker::Sized","util::SharedValue"],"util::SharedValue::<T>::new":["std::cell::UnsafeCell","std::marker::Sized","util::SharedValue"],"util::change_lifetime_const":["std::marker::Sized"],"util::change_lifetime_mut":["std::marker::Sized"],"util::map_in_place_2":["std::marker::Sized","std::ops::FnOnce"],"util::ptr_size_bits":[]},"glob_path_import":{},"self_to_fn":{"DashMap":["impl<'a, K: 'a + Eq + Hash, V: 'a, S: 'a + BuildHasher + Clone> Map<'a, K, V, S>\n    for DashMap<K, V, S>\n{\n    fn _shard_count(&self) -> usize {\n        self.shards.len()\n    }\n\n    unsafe fn _get_read_shard(&'a self, i: usize) -> &'a HashMap<K, V, S> {\n        debug_assert!(i < self.shards.len());\n\n        self.shards.get_unchecked(i).get()\n    }\n\n    unsafe fn _yield_read_shard(&'a self, i: usize) -> RwLockReadGuard<'a, HashMap<K, V, S>> {\n        debug_assert!(i < self.shards.len());\n\n        self.shards.get_unchecked(i).read()\n    }\n\n    unsafe fn _yield_write_shard(&'a self, i: usize) -> RwLockWriteGuard<'a, HashMap<K, V, S>> {\n        debug_assert!(i < self.shards.len());\n\n        self.shards.get_unchecked(i).write()\n    }\n\n    fn _insert(&self, key: K, value: V) -> Option<V> {\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let mut shard = unsafe { self._yield_write_shard(idx) };\n\n        shard\n            .insert(key, SharedValue::new(value))\n            .map(|v| v.into_inner())\n    }\n\n    fn _remove<Q>(&self, key: &Q) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let mut shard = unsafe { self._yield_write_shard(idx) };\n\n        shard.remove_entry(key).map(|(k, v)| (k, v.into_inner()))\n    }\n\n    fn _remove_if<Q>(&self, key: &Q, f: impl FnOnce(&K, &V) -> bool) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let mut shard = unsafe { self._yield_write_shard(idx) };\n\n        if let Some((k, v)) = shard.get_key_value(key) {\n            if f(k, v.get()) {\n                shard.remove_entry(key).map(|(k, v)| (k, v.into_inner()))\n            } else {\n                None\n            }\n        } else {\n            None\n        }\n    }\n\n    fn _iter(&'a self) -> Iter<'a, K, V, S, DashMap<K, V, S>> {\n        Iter::new(self)\n    }\n\n    fn _iter_mut(&'a self) -> IterMut<'a, K, V, S, DashMap<K, V, S>> {\n        IterMut::new(self)\n    }\n\n    fn _get<Q>(&'a self, key: &Q) -> Option<Ref<'a, K, V, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let shard = unsafe { self._yield_read_shard(idx) };\n\n        if let Some((kptr, vptr)) = shard.get_key_value(key) {\n            unsafe {\n                let kptr = util::change_lifetime_const(kptr);\n\n                let vptr = util::change_lifetime_const(vptr);\n\n                Some(Ref::new(shard, kptr, vptr.get()))\n            }\n        } else {\n            None\n        }\n    }\n\n    fn _get_mut<Q>(&'a self, key: &Q) -> Option<RefMut<'a, K, V, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let shard = unsafe { self._yield_write_shard(idx) };\n\n        if let Some((kptr, vptr)) = shard.get_key_value(key) {\n            unsafe {\n                let kptr = util::change_lifetime_const(kptr);\n\n                let vptr = &mut *vptr.as_ptr();\n\n                Some(RefMut::new(shard, kptr, vptr))\n            }\n        } else {\n            None\n        }\n    }\n\n    fn _shrink_to_fit(&self) {\n        self.shards.iter().for_each(|s| s.write().shrink_to_fit());\n    }\n\n    fn _retain(&self, mut f: impl FnMut(&K, &mut V) -> bool) {\n        self.shards\n            .iter()\n            .for_each(|s| s.write().retain(|k, v| f(k, v.get_mut())));\n    }\n\n    fn _len(&self) -> usize {\n        self.shards.iter().map(|s| s.read().len()).sum()\n    }\n\n    fn _capacity(&self) -> usize {\n        self.shards.iter().map(|s| s.read().capacity()).sum()\n    }\n\n    fn _alter<Q>(&self, key: &Q, f: impl FnOnce(&K, V) -> V)\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        if let Some(mut r) = self.get_mut(key) {\n            util::map_in_place_2(r.pair_mut(), f);\n        }\n    }\n\n    fn _alter_all(&self, mut f: impl FnMut(&K, V) -> V) {\n        self.shards.iter().for_each(|s| {\n            s.write()\n                .iter_mut()\n                .for_each(|(k, v)| util::map_in_place_2((k, v.get_mut()), &mut f));\n        });\n    }\n\n    fn _entry(&'a self, key: K) -> Entry<'a, K, V, S> {\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let shard = unsafe { self._yield_write_shard(idx) };\n\n        if let Some((kptr, vptr)) = shard.get_key_value(&key) {\n            unsafe {\n                let kptr = util::change_lifetime_const(kptr);\n\n                let vptr = &mut *vptr.as_ptr();\n\n                Entry::Occupied(OccupiedEntry::new(shard, key, (kptr, vptr)))\n            }\n        } else {\n            Entry::Vacant(VacantEntry::new(shard, key))\n        }\n    }\n\n    fn _hasher(&self) -> S {\n        self.hasher.clone()\n    }\n}","impl<'a, K: 'a + Eq + Hash, V: 'a, S: BuildHasher + Clone> DashMap<K, V, S> {\n    /// Wraps this `DashMap` into a read-only view. This view allows to obtain raw references to the stored values.\n\n    pub fn into_read_only(self) -> ReadOnlyView<K, V, S> {\n        ReadOnlyView::new(self)\n    }\n\n    /// Creates a new DashMap with a capacity of 0 and the provided hasher.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let reviews = DashMap::with_hasher(s);\n    /// reviews.insert(\"Veloren\", \"What a fantastic game!\");\n    /// ```\n\n    pub fn with_hasher(hasher: S) -> Self {\n        Self::with_capacity_and_hasher(0, hasher)\n    }\n\n    /// Creates a new DashMap with a specified starting capacity and hasher.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mappings = DashMap::with_capacity_and_hasher(2, s);\n    /// mappings.insert(2, 4);\n    /// mappings.insert(8, 16);\n    /// ```\n\n    pub fn with_capacity_and_hasher(mut capacity: usize, hasher: S) -> Self {\n        let shard_amount = shard_amount();\n        let shift = util::ptr_size_bits() - ncb(shard_amount);\n\n        if capacity != 0 {\n            capacity = (capacity + (shard_amount - 1)) & !(shard_amount - 1);\n        }\n\n        let cps = capacity / shard_amount;\n\n        let shards = (0..shard_amount)\n            .map(|_| RwLock::new(HashMap::with_capacity_and_hasher(cps, hasher.clone())))\n            .collect();\n\n        Self {\n            shift,\n            shards,\n            hasher,\n        }\n    }\n\n    /// Hash a given item to produce a usize.\n    /// Uses the provided or default HashBuilder.\n\n    pub fn hash_usize<T: Hash>(&self, item: &T) -> usize {\n        let mut hasher = self.hasher.build_hasher();\n\n        item.hash(&mut hasher);\n\n        hasher.finish() as usize\n    }\n\n    cfg_if! {\n        if #[cfg(feature = \"raw-api\")] {\n            /// Allows you to peek at the inner shards that store your data.\n            /// You should probably not use this unless you know what you are doing.\n            ///\n            /// Requires the `raw-api` feature to be enabled.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use dashmap::DashMap;\n            ///\n            /// let map = DashMap::<(), ()>::new();\n            /// println!(\"Amount of shards: {}\", map.shards().len());\n            /// ```\n\n            pub fn shards(&self) -> &[RwLock<HashMap<K, V, S>>] {\n                &self.shards\n            }\n        } else {\n            #[allow(dead_code)]\n\n            pub(crate) fn shards(&self) -> &[RwLock<HashMap<K, V, S>>] {\n                &self.shards\n            }\n        }\n    }\n\n    cfg_if! {\n        if #[cfg(feature = \"raw-api\")] {\n            /// Finds which shard a certain key is stored in.\n            /// You should probably not use this unless you know what you are doing.\n            /// Note that shard selection is dependent on the default or provided HashBuilder.\n            ///\n            /// Requires the `raw-api` feature to be enabled.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use dashmap::DashMap;\n            ///\n            /// let map = DashMap::new();\n            /// map.insert(\"coca-cola\", 1.4);\n            /// println!(\"coca-cola is stored in shard: {}\", map.determine_map(\"coca-cola\"));\n            /// ```\n\n            pub fn determine_map<Q>(&self, key: &Q) -> usize\n            where\n                K: Borrow<Q>,\n                Q: Hash + Eq + ?Sized,\n            {\n                let hash = self.hash_usize(&key);\n                self.determine_shard(hash)\n            }\n        }\n    }\n\n    cfg_if! {\n        if #[cfg(feature = \"raw-api\")] {\n            /// Finds which shard a certain hash is stored in.\n            ///\n            /// Requires the `raw-api` feature to be enabled.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use dashmap::DashMap;\n            ///\n            /// let map: DashMap<i32, i32> = DashMap::new();\n            /// let key = \"key\";\n            /// let hash = map.hash_usize(&key);\n            /// println!(\"hash is stored in shard: {}\", map.determine_shard(hash));\n            /// ```\n\n            pub fn determine_shard(&self, hash: usize) -> usize {\n                // Leave the high 7 bits for the HashBrown SIMD tag.\n                (hash << 7) >> self.shift\n            }\n        } else {\n\n            pub(crate) fn determine_shard(&self, hash: usize) -> usize {\n                // Leave the high 7 bits for the HashBrown SIMD tag.\n                (hash << 7) >> self.shift\n            }\n        }\n    }\n\n    /// Returns a reference to the map's [`BuildHasher`].\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use dashmap::DashMap;\n    /// use ahash::RandomState;\n    ///\n    /// let hasher = RandomState::new();\n    /// let map: DashMap<i32, i32> = DashMap::new();\n    /// let hasher: &RandomState = map.hasher();\n    /// ```\n    ///\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n\n    pub fn hasher(&self) -> &S {\n        &self.hasher\n    }\n\n    /// Inserts a key and a value into the map.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let map = DashMap::new();\n    /// map.insert(\"I am the key!\", \"And I am the value!\");\n    /// ```\n\n    pub fn insert(&self, key: K, value: V) -> Option<V> {\n        self._insert(key, value)\n    }\n\n    /// Removes an entry from the map, returning the key and value if they existed in the map.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let soccer_team = DashMap::new();\n    /// soccer_team.insert(\"Jack\", \"Goalie\");\n    /// assert_eq!(soccer_team.remove(\"Jack\").unwrap().1, \"Goalie\");\n    /// ```\n\n    pub fn remove<Q>(&self, key: &Q) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        self._remove(key)\n    }\n\n    /// Removes an entry from the map, returning the key and value\n    /// if the entry existed and the provided conditional function returned true.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let soccer_team = DashMap::new();\n    /// soccer_team.insert(\"Sam\", \"Forward\");\n    /// soccer_team.remove_if(\"Sam\", |_, position| position == &\"Goalie\");\n    /// assert!(soccer_team.contains_key(\"Sam\"));\n    /// ```\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let soccer_team = DashMap::new();\n    /// soccer_team.insert(\"Sam\", \"Forward\");\n    /// soccer_team.remove_if(\"Sam\", |_, position| position == &\"Forward\");\n    /// assert!(!soccer_team.contains_key(\"Sam\"));\n    /// ```\n\n    pub fn remove_if<Q>(&self, key: &Q, f: impl FnOnce(&K, &V) -> bool) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        self._remove_if(key, f)\n    }\n\n    /// Creates an iterator over a DashMap yielding immutable references.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let words = DashMap::new();\n    /// words.insert(\"hello\", \"world\");\n    /// assert_eq!(words.iter().count(), 1);\n    /// ```\n\n    pub fn iter(&'a self) -> Iter<'a, K, V, S, DashMap<K, V, S>> {\n        self._iter()\n    }\n\n    /// Iterator over a DashMap yielding mutable references.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let map = DashMap::new();\n    /// map.insert(\"Johnny\", 21);\n    /// map.iter_mut().for_each(|mut r| *r += 1);\n    /// assert_eq!(*map.get(\"Johnny\").unwrap(), 22);\n    /// ```\n\n    pub fn iter_mut(&'a self) -> IterMut<'a, K, V, S, DashMap<K, V, S>> {\n        self._iter_mut()\n    }\n\n    /// Get a immutable reference to an entry in the map\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let youtubers = DashMap::new();\n    /// youtubers.insert(\"Bosnian Bill\", 457000);\n    /// assert_eq!(*youtubers.get(\"Bosnian Bill\").unwrap(), 457000);\n    /// ```\n\n    pub fn get<Q>(&'a self, key: &Q) -> Option<Ref<'a, K, V, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        self._get(key)\n    }\n\n    /// Get a mutable reference to an entry in the map\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let class = DashMap::new();\n    /// class.insert(\"Albin\", 15);\n    /// *class.get_mut(\"Albin\").unwrap() -= 1;\n    /// assert_eq!(*class.get(\"Albin\").unwrap(), 14);\n    /// ```\n\n    pub fn get_mut<Q>(&'a self, key: &Q) -> Option<RefMut<'a, K, V, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        self._get_mut(key)\n    }\n\n    /// Remove excess capacity to reduce memory usage.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n\n    pub fn shrink_to_fit(&self) {\n        self._shrink_to_fit();\n    }\n\n    /// Retain elements that whose predicates return true\n    /// and discard elements whose predicates return false.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let people = DashMap::new();\n    /// people.insert(\"Albin\", 15);\n    /// people.insert(\"Jones\", 22);\n    /// people.insert(\"Charlie\", 27);\n    /// people.retain(|_, v| *v > 20);\n    /// assert_eq!(people.len(), 2);\n    /// ```\n\n    pub fn retain(&self, f: impl FnMut(&K, &mut V) -> bool) {\n        self._retain(f);\n    }\n\n    /// Fetches the total number of key-value pairs stored in the map.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let people = DashMap::new();\n    /// people.insert(\"Albin\", 15);\n    /// people.insert(\"Jones\", 22);\n    /// people.insert(\"Charlie\", 27);\n    /// assert_eq!(people.len(), 3);\n    /// ```\n\n    pub fn len(&self) -> usize {\n        self._len()\n    }\n\n    /// Checks if the map is empty or not.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let map = DashMap::<(), ()>::new();\n    /// assert!(map.is_empty());\n    /// ```\n\n    pub fn is_empty(&self) -> bool {\n        self._is_empty()\n    }\n\n    /// Removes all key-value pairs in the map.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let stats = DashMap::new();\n    /// stats.insert(\"Goals\", 4);\n    /// assert!(!stats.is_empty());\n    /// stats.clear();\n    /// assert!(stats.is_empty());\n    /// ```\n\n    pub fn clear(&self) {\n        self._clear();\n    }\n\n    /// Returns how many key-value pairs the map can store without reallocating.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\n\n    pub fn capacity(&self) -> usize {\n        self._capacity()\n    }\n\n    /// Modify a specific value according to a function.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let stats = DashMap::new();\n    /// stats.insert(\"Goals\", 4);\n    /// stats.alter(\"Goals\", |_, v| v * 2);\n    /// assert_eq!(*stats.get(\"Goals\").unwrap(), 8);\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// If the given closure panics, then `alter_all` will abort the process\n\n    pub fn alter<Q>(&self, key: &Q, f: impl FnOnce(&K, V) -> V)\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        self._alter(key, f);\n    }\n\n    /// Modify every value in the map according to a function.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let stats = DashMap::new();\n    /// stats.insert(\"Wins\", 4);\n    /// stats.insert(\"Losses\", 2);\n    /// stats.alter_all(|_, v| v + 1);\n    /// assert_eq!(*stats.get(\"Wins\").unwrap(), 5);\n    /// assert_eq!(*stats.get(\"Losses\").unwrap(), 3);\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// If the given closure panics, then `alter_all` will abort the process\n\n    pub fn alter_all(&self, f: impl FnMut(&K, V) -> V) {\n        self._alter_all(f);\n    }\n\n    /// Checks if the map contains a specific key.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let team_sizes = DashMap::new();\n    /// team_sizes.insert(\"Dakota Cherries\", 23);\n    /// assert!(team_sizes.contains_key(\"Dakota Cherries\"));\n    /// ```\n\n    pub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        self._contains_key(key)\n    }\n\n    /// Advanced entry API that tries to mimic `std::collections::HashMap`.\n    /// See the documentation on `dashmap::mapref::entry` for more details.\n    ///\n    /// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n\n    pub fn entry(&'a self, key: K) -> Entry<'a, K, V, S> {\n        self._entry(key)\n    }\n}","impl<'a, K: 'a + Eq + Hash, V: 'a> DashMap<K, V, RandomState> {\n    /// Creates a new DashMap with a capacity of 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let reviews = DashMap::new();\n    /// reviews.insert(\"Veloren\", \"What a fantastic game!\");\n    /// ```\n\n    pub fn new() -> Self {\n        DashMap::with_hasher(RandomState::default())\n    }\n\n    /// Creates a new DashMap with a specified starting capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashMap;\n    ///\n    /// let mappings = DashMap::with_capacity(2);\n    /// mappings.insert(2, 4);\n    /// mappings.insert(8, 16);\n    /// ```\n\n    pub fn with_capacity(capacity: usize) -> Self {\n        DashMap::with_capacity_and_hasher(capacity, RandomState::default())\n    }\n}","impl<'a, K: Eq + Hash, V, S: BuildHasher + Clone> IntoIterator for DashMap<K, V, S> {\n    type Item = (K, V);\n\n    type IntoIter = OwningIter<K, V, S>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        OwningIter::new(self)\n    }\n}","impl<K, V, S> Default for DashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: Default + BuildHasher + Clone,\n{\n    fn default() -> Self {\n        Self::with_hasher(Default::default())\n    }\n}","impl<K: Eq + Hash + Clone, V: Clone, S: Clone> Clone for DashMap<K, V, S> {\n    fn clone(&self) -> Self {\n        let mut inner_shards = Vec::new();\n\n        for shard in self.shards.iter() {\n            let shard = shard.read();\n\n            inner_shards.push(RwLock::new((*shard).clone()));\n        }\n\n        Self {\n            shift: self.shift,\n            shards: inner_shards.into_boxed_slice(),\n            hasher: self.hasher.clone(),\n        }\n    }\n}","impl<K: Eq + Hash + fmt::Debug, V: fmt::Debug, S: BuildHasher + Clone> fmt::Debug\n    for DashMap<K, V, S>\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut pmap = f.debug_map();\n\n        for r in self {\n            let (k, v) = r.pair();\n\n            pmap.entry(k, v);\n        }\n\n        pmap.finish()\n    }\n}","impl<K: Eq + Hash, V, S: BuildHasher + Clone> Extend<(K, V)> for DashMap<K, V, S> {\n    fn extend<I: IntoIterator<Item = (K, V)>>(&mut self, intoiter: I) {\n        for pair in intoiter.into_iter() {\n            self.insert(pair.0, pair.1);\n        }\n    }\n}","impl<K: Eq + Hash, V> FromIterator<(K, V)> for DashMap<K, V, RandomState> {\n    fn from_iter<I: IntoIterator<Item = (K, V)>>(intoiter: I) -> Self {\n        let mut map = DashMap::new();\n\n        map.extend(intoiter);\n\n        map\n    }\n}"],"iter::Iter":["impl<'a, K: Eq + Hash, V, S: 'a + BuildHasher + Clone, M: Map<'a, K, V, S>> Iter<'a, K, V, S, M> {\n    pub(crate) fn new(map: &'a M) -> Self {\n        Self {\n            map,\n            shard_i: 0,\n            current: None,\n        }\n    }\n}","impl<'a, K: Eq + Hash, V, S: 'a + BuildHasher + Clone, M: Map<'a, K, V, S>> Iterator\n    for Iter<'a, K, V, S, M>\n{\n    type Item = RefMulti<'a, K, V, S>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            if let Some(current) = self.current.as_mut() {\n                if let Some((k, v)) = current.1.next() {\n                    let guard = current.0.clone();\n\n                    return Some(RefMulti::new(guard, k, v.get()));\n                }\n            }\n\n            if self.shard_i == self.map._shard_count() {\n                return None;\n            }\n\n            let guard = unsafe { self.map._yield_read_shard(self.shard_i) };\n\n            let sref: &HashMap<K, V, S> = unsafe { util::change_lifetime_const(&*guard) };\n\n            let iter = sref.iter();\n\n            self.current = Some((Arc::new(guard), iter));\n\n            self.shard_i += 1;\n        }\n    }\n}","unsafe impl<'a, 'i, K, V, S, M> Send for Iter<'i, K, V, S, M>\nwhere\n    K: 'a + Eq + Hash + Send,\n    V: 'a + Send,\n    S: 'a + BuildHasher + Clone,\n    M: Map<'a, K, V, S>,\n{\n}","unsafe impl<'a, 'i, K, V, S, M> Sync for Iter<'i, K, V, S, M>\nwhere\n    K: 'a + Eq + Hash + Sync,\n    V: 'a + Sync,\n    S: 'a + BuildHasher + Clone,\n    M: Map<'a, K, V, S>,\n{\n}"],"iter::IterMut":["impl<'a, K: Eq + Hash, V, S: 'a + BuildHasher + Clone, M: Map<'a, K, V, S>>\n    IterMut<'a, K, V, S, M>\n{\n    pub(crate) fn new(map: &'a M) -> Self {\n        Self {\n            map,\n            shard_i: 0,\n            current: None,\n        }\n    }\n}","impl<'a, K: Eq + Hash, V, S: 'a + BuildHasher + Clone, M: Map<'a, K, V, S>> Iterator\n    for IterMut<'a, K, V, S, M>\n{\n    type Item = RefMutMulti<'a, K, V, S>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            if let Some(current) = self.current.as_mut() {\n                if let Some((k, v)) = current.1.next() {\n                    let guard = current.0.clone();\n\n                    unsafe {\n                        let k = util::change_lifetime_const(k);\n\n                        let v = &mut *v.as_ptr();\n\n                        return Some(RefMutMulti::new(guard, k, v));\n                    }\n                }\n            }\n\n            if self.shard_i == self.map._shard_count() {\n                return None;\n            }\n\n            let mut guard = unsafe { self.map._yield_write_shard(self.shard_i) };\n\n            let sref: &mut HashMap<K, V, S> = unsafe { util::change_lifetime_mut(&mut *guard) };\n\n            let iter = sref.iter_mut();\n\n            self.current = Some((Arc::new(guard), iter));\n\n            self.shard_i += 1;\n        }\n    }\n}","unsafe impl<'a, 'i, K, V, S, M> Send for IterMut<'i, K, V, S, M>\nwhere\n    K: 'a + Eq + Hash + Send,\n    V: 'a + Send,\n    S: 'a + BuildHasher + Clone,\n    M: Map<'a, K, V, S>,\n{\n}","unsafe impl<'a, 'i, K, V, S, M> Sync for IterMut<'i, K, V, S, M>\nwhere\n    K: 'a + Eq + Hash + Sync,\n    V: 'a + Sync,\n    S: 'a + BuildHasher + Clone,\n    M: Map<'a, K, V, S>,\n{\n}"],"iter::OwningIter":["impl<K: Eq + Hash, V, S: BuildHasher + Clone> Iterator for OwningIter<K, V, S> {\n    type Item = (K, V);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            if let Some(current) = self.current.as_mut() {\n                if let Some((k, v)) = current.next() {\n                    return Some((k, v.into_inner()));\n                }\n            }\n\n            if self.shard_i == self.map._shard_count() {\n                return None;\n            }\n\n            //let guard = unsafe { self.map._yield_read_shard(self.shard_i) };\n            let mut shard_wl = unsafe { self.map._yield_write_shard(self.shard_i) };\n\n            let hasher = self.map._hasher();\n\n            let map = mem::replace(&mut *shard_wl, HashMap::with_hasher(hasher));\n\n            drop(shard_wl);\n\n            let iter = map.into_iter();\n\n            //unsafe { ptr::write(&mut self.current, Some((arcee, iter))); }\n            self.current = Some(iter);\n\n            self.shard_i += 1;\n        }\n    }\n}","impl<K: Eq + Hash, V, S: BuildHasher + Clone> OwningIter<K, V, S> {\n    pub(crate) fn new(map: DashMap<K, V, S>) -> Self {\n        Self {\n            map,\n            shard_i: 0,\n            current: None,\n        }\n    }\n}","unsafe impl<K, V, S> Send for OwningIter<K, V, S>\nwhere\n    K: Eq + Hash + Send,\n    V: Send,\n    S: BuildHasher + Clone + Send,\n{\n}","unsafe impl<K, V, S> Sync for OwningIter<K, V, S>\nwhere\n    K: Eq + Hash + Sync,\n    V: Sync,\n    S: BuildHasher + Clone + Sync,\n{\n}"],"iter_set::Iter":["impl<'a, K: Eq + Hash, S: 'a + BuildHasher + Clone, M: Map<'a, K, (), S>> Iter<'a, K, S, M> {\n    pub(crate) fn new(inner: crate::iter::Iter<'a, K, (), S, M>) -> Self {\n        Self { inner }\n    }\n}","impl<'a, K: Eq + Hash, S: 'a + BuildHasher + Clone, M: Map<'a, K, (), S>> Iterator\n    for Iter<'a, K, S, M>\n{\n    type Item = RefMulti<'a, K, S>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(RefMulti::new)\n    }\n}","unsafe impl<'a, 'i, K, S, M> Send for Iter<'i, K, S, M>\nwhere\n    K: 'a + Eq + Hash + Send,\n    S: 'a + BuildHasher + Clone,\n    M: Map<'a, K, (), S>,\n{\n}","unsafe impl<'a, 'i, K, S, M> Sync for Iter<'i, K, S, M>\nwhere\n    K: 'a + Eq + Hash + Sync,\n    S: 'a + BuildHasher + Clone,\n    M: Map<'a, K, (), S>,\n{\n}"],"iter_set::OwningIter":["impl<K: Eq + Hash, S: BuildHasher + Clone> Iterator for OwningIter<K, S> {\n    type Item = K;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|(k, _)| k)\n    }\n}","impl<K: Eq + Hash, S: BuildHasher + Clone> OwningIter<K, S> {\n    pub(crate) fn new(inner: crate::iter::OwningIter<K, (), S>) -> Self {\n        Self { inner }\n    }\n}","unsafe impl<K, S> Send for OwningIter<K, S>\nwhere\n    K: Eq + Hash + Send,\n    S: BuildHasher + Clone + Send,\n{\n}","unsafe impl<K, S> Sync for OwningIter<K, S>\nwhere\n    K: Eq + Hash + Sync,\n    S: BuildHasher + Clone + Sync,\n{\n}"],"lock::RwLock":["impl<T: ?Sized + Default> Default for RwLock<T> {\n    fn default() -> RwLock<T> {\n        RwLock::new(Default::default())\n    }\n}","impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self.try_read() {\n            Some(guard) => write!(f, \"RwLock {{ data: \")\n                .and_then(|()| (&*guard).fmt(f))\n                .and_then(|()| write!(f, \"}}\")),\n            None => write!(f, \"RwLock {{ <locked> }}\"),\n        }\n    }\n}","impl<T: ?Sized> RwLock<T> {\n    pub fn read(&self) -> RwLockReadGuard<T> {\n        loop {\n            match self.try_read() {\n                Some(guard) => return guard,\n                None => cpu_relax(),\n            }\n        }\n    }\n\n    pub fn try_read(&self) -> Option<RwLockReadGuard<T>> {\n        let value = self.lock.fetch_add(READER, Ordering::Acquire);\n\n        // We check the UPGRADED bit here so that new readers are prevented when an UPGRADED lock is held.\n        // This helps reduce writer starvation.\n        if value & (WRITER | UPGRADED) != 0 {\n            // Lock is taken, undo.\n            self.lock.fetch_sub(READER, Ordering::Release);\n\n            None\n        } else {\n            Some(RwLockReadGuard {\n                lock: &self.lock,\n                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n            })\n        }\n    }\n\n    /// # Safety\n    ///\n    /// This is only safe if the lock is currently locked in read mode and the number of readers is not 0.\n\n    pub unsafe fn force_read_decrement(&self) {\n        debug_assert!(self.lock.load(Ordering::Relaxed) & !WRITER > 0);\n\n        self.lock.fetch_sub(READER, Ordering::Release);\n    }\n\n    /// # Safety\n    ///\n    /// The lock must be locked in write mode.\n\n    pub unsafe fn force_write_unlock(&self) {\n        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED), 0);\n\n        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n    }\n\n    fn try_write_internal(&self, strong: bool) -> Option<RwLockWriteGuard<T>> {\n        if compare_exchange(\n            &self.lock,\n            0,\n            WRITER,\n            Ordering::Acquire,\n            Ordering::Relaxed,\n            strong,\n        )\n        .is_ok()\n        {\n            Some(RwLockWriteGuard {\n                lock: &self.lock,\n                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n                _invariant: PhantomData,\n            })\n        } else {\n            None\n        }\n    }\n\n    pub fn write(&self) -> RwLockWriteGuard<T> {\n        loop {\n            match self.try_write_internal(false) {\n                Some(guard) => return guard,\n                None => cpu_relax(),\n            }\n        }\n    }\n\n    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {\n        self.try_write_internal(true)\n    }\n\n    pub fn upgradeable_read(&self) -> RwLockUpgradeableGuard<T> {\n        loop {\n            match self.try_upgradeable_read() {\n                Some(guard) => return guard,\n                None => cpu_relax(),\n            }\n        }\n    }\n\n    pub fn try_upgradeable_read(&self) -> Option<RwLockUpgradeableGuard<T>> {\n        if self.lock.fetch_or(UPGRADED, Ordering::Acquire) & (WRITER | UPGRADED) == 0 {\n            Some(RwLockUpgradeableGuard {\n                lock: &self.lock,\n                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n                _invariant: PhantomData,\n            })\n        } else {\n            None\n        }\n    }\n\n    pub fn get(&self) -> &T {\n        unsafe { &*self.data.get() }\n    }\n\n    pub fn get_mut(&mut self) -> &mut T {\n        unsafe { &mut *self.data.get() }\n    }\n}","impl<T> RwLock<T> {\n    pub const fn new(user_data: T) -> RwLock<T> {\n        RwLock {\n            lock: AtomicUsize::new(0),\n            data: UnsafeCell::new(user_data),\n        }\n    }\n\n    pub fn into_inner(self) -> T {\n        let RwLock { data, .. } = self;\n\n        data.into_inner()\n    }\n}","unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}","unsafe impl<T: ?Sized + Send> Send for RwLock<T> {}"],"lock::RwLockReadGuard":["Debug","impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        unsafe { self.data.as_ref() }\n    }\n}","impl<'rwlock, T: ?Sized> Drop for RwLockReadGuard<'rwlock, T> {\n    fn drop(&mut self) {\n        debug_assert!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED) > 0);\n\n        self.lock.fetch_sub(READER, Ordering::Release);\n    }\n}","unsafe impl<'a, T: Send> Send for RwLockReadGuard<'a, T> {}","unsafe impl<'a, T: Sync> Sync for RwLockReadGuard<'a, T> {}"],"lock::RwLockUpgradeableGuard":["Debug","impl<'rwlock, T: ?Sized> Deref for RwLockUpgradeableGuard<'rwlock, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        unsafe { self.data.as_ref() }\n    }\n}","impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\n    fn drop(&mut self) {\n        debug_assert_eq!(\n            self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED),\n            UPGRADED\n        );\n\n        self.lock.fetch_sub(UPGRADED, Ordering::AcqRel);\n    }\n}","impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n    fn try_upgrade_internal(self, strong: bool) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\n        if compare_exchange(\n            &self.lock,\n            UPGRADED,\n            WRITER,\n            Ordering::Acquire,\n            Ordering::Relaxed,\n            strong,\n        )\n        .is_ok()\n        {\n            let out = Ok(RwLockWriteGuard {\n                lock: &self.lock,\n                data: self.data,\n                _invariant: PhantomData,\n            });\n\n            mem::forget(self);\n\n            out\n        } else {\n            Err(self)\n        }\n    }\n\n    pub fn upgrade(mut self) -> RwLockWriteGuard<'rwlock, T> {\n        loop {\n            self = match self.try_upgrade_internal(false) {\n                Ok(guard) => return guard,\n                Err(e) => e,\n            };\n\n            cpu_relax();\n        }\n    }\n\n    pub fn try_upgrade(self) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\n        self.try_upgrade_internal(true)\n    }\n\n    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\n        self.lock.fetch_add(READER, Ordering::Acquire);\n\n        RwLockReadGuard {\n            lock: &self.lock,\n            data: self.data,\n        }\n    }\n}"],"lock::RwLockWriteGuard":["Debug","impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        unsafe { self.data.as_ref() }\n    }\n}","impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n    fn deref_mut(&mut self) -> &mut T {\n        unsafe { self.data.as_mut() }\n    }\n}","impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n    fn drop(&mut self) {\n        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & WRITER, WRITER);\n\n        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n    }\n}","impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\n        self.lock.fetch_add(READER, Ordering::Acquire);\n\n        RwLockReadGuard {\n            lock: &self.lock,\n            data: self.data,\n        }\n    }\n}","unsafe impl<'a, T: Send> Send for RwLockWriteGuard<'a, T> {}","unsafe impl<'a, T: Sync> Sync for RwLockWriteGuard<'a, T> {}"],"mapref::entry::Entry":["impl<'a, K: Eq + Hash, V, S: BuildHasher> Entry<'a, K, V, S> {\n    /// Apply a function to the stored value if it exists.\n\n    pub fn and_modify(self, f: impl FnOnce(&mut V)) -> Self {\n        match self {\n            Entry::Occupied(mut entry) => {\n                f(entry.get_mut());\n\n                Entry::Occupied(entry)\n            }\n\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }\n\n    /// Get the key of the entry.\n\n    pub fn key(&self) -> &K {\n        match *self {\n            Entry::Occupied(ref entry) => entry.key(),\n            Entry::Vacant(ref entry) => entry.key(),\n        }\n    }\n\n    /// Into the key of the entry.\n\n    pub fn into_key(self) -> K {\n        match self {\n            Entry::Occupied(entry) => entry.into_key(),\n            Entry::Vacant(entry) => entry.into_key(),\n        }\n    }\n\n    /// Return a mutable reference to the element if it exists,\n    /// otherwise insert the default and return a mutable reference to that.\n\n    pub fn or_default(self) -> RefMut<'a, K, V, S>\n    where\n        V: Default,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_ref(),\n            Entry::Vacant(entry) => entry.insert(V::default()),\n        }\n    }\n\n    /// Return a mutable reference to the element if it exists,\n    /// otherwise a provided value and return a mutable reference to that.\n\n    pub fn or_insert(self, value: V) -> RefMut<'a, K, V, S> {\n        match self {\n            Entry::Occupied(entry) => entry.into_ref(),\n            Entry::Vacant(entry) => entry.insert(value),\n        }\n    }\n\n    /// Return a mutable reference to the element if it exists,\n    /// otherwise insert the result of a provided function and return a mutable reference to that.\n\n    pub fn or_insert_with(self, value: impl FnOnce() -> V) -> RefMut<'a, K, V, S> {\n        match self {\n            Entry::Occupied(entry) => entry.into_ref(),\n            Entry::Vacant(entry) => entry.insert(value()),\n        }\n    }\n\n    pub fn or_try_insert_with<E>(\n        self,\n        value: impl FnOnce() -> Result<V, E>,\n    ) -> Result<RefMut<'a, K, V, S>, E> {\n        match self {\n            Entry::Occupied(entry) => Ok(entry.into_ref()),\n            Entry::Vacant(entry) => Ok(entry.insert(value()?)),\n        }\n    }\n}"],"mapref::entry::OccupiedEntry":["impl<'a, K: Eq + Hash, V, S: BuildHasher> OccupiedEntry<'a, K, V, S> {\n    pub(crate) fn new(\n        shard: RwLockWriteGuard<'a, HashMap<K, V, S>>,\n        key: K,\n        elem: (&'a K, &'a mut V),\n    ) -> Self {\n        Self { shard, elem, key }\n    }\n\n    pub fn get(&self) -> &V {\n        self.elem.1\n    }\n\n    pub fn get_mut(&mut self) -> &mut V {\n        self.elem.1\n    }\n\n    pub fn insert(&mut self, value: V) -> V {\n        mem::replace(self.elem.1, value)\n    }\n\n    pub fn into_ref(self) -> RefMut<'a, K, V, S> {\n        RefMut::new(self.shard, self.elem.0, self.elem.1)\n    }\n\n    pub fn into_key(self) -> K {\n        self.key\n    }\n\n    pub fn key(&self) -> &K {\n        self.elem.0\n    }\n\n    pub fn remove(mut self) -> V {\n        self.shard.remove(self.elem.0).unwrap().into_inner()\n    }\n\n    pub fn remove_entry(mut self) -> (K, V) {\n        let (k, v) = self.shard.remove_entry(self.elem.0).unwrap();\n\n        (k, v.into_inner())\n    }\n\n    pub fn replace_entry(mut self, value: V) -> (K, V) {\n        let nk = self.key;\n\n        let (k, v) = self.shard.remove_entry(self.elem.0).unwrap();\n\n        self.shard.insert(nk, SharedValue::new(value));\n\n        (k, v.into_inner())\n    }\n}","unsafe impl<'a, K: Eq + Hash + Send + Sync, V: Send + Sync, S: BuildHasher> Sync\n    for OccupiedEntry<'a, K, V, S>\n{\n}","unsafe impl<'a, K: Eq + Hash + Send, V: Send, S: BuildHasher> Send for OccupiedEntry<'a, K, V, S> {}"],"mapref::entry::VacantEntry":["impl<'a, K: Eq + Hash, V, S: BuildHasher> VacantEntry<'a, K, V, S> {\n    pub(crate) fn new(shard: RwLockWriteGuard<'a, HashMap<K, V, S>>, key: K) -> Self {\n        Self { shard, key }\n    }\n\n    pub fn insert(mut self, value: V) -> RefMut<'a, K, V, S> {\n        unsafe {\n            let c: K = ptr::read(&self.key);\n\n            self.shard.insert(self.key, SharedValue::new(value));\n\n            let (k, v) = self.shard.get_key_value(&c).unwrap();\n\n            let k = util::change_lifetime_const(k);\n\n            let v = &mut *v.as_ptr();\n\n            let r = RefMut::new(self.shard, k, v);\n\n            mem::forget(c);\n\n            r\n        }\n    }\n\n    pub fn into_key(self) -> K {\n        self.key\n    }\n\n    pub fn key(&self) -> &K {\n        &self.key\n    }\n}","unsafe impl<'a, K: Eq + Hash + Send + Sync, V: Send + Sync, S: BuildHasher> Sync\n    for VacantEntry<'a, K, V, S>\n{\n}","unsafe impl<'a, K: Eq + Hash + Send, V: Send, S: BuildHasher> Send for VacantEntry<'a, K, V, S> {}"],"mapref::multiple::RefMulti":["impl<'a, K: Eq + Hash, V, S: BuildHasher> Deref for RefMulti<'a, K, V, S> {\n    type Target = V;\n\n    fn deref(&self) -> &V {\n        self.value()\n    }\n}","impl<'a, K: Eq + Hash, V, S: BuildHasher> RefMulti<'a, K, V, S> {\n    pub(crate) fn new(\n        guard: Arc<RwLockReadGuard<'a, HashMap<K, V, S>>>,\n        k: &'a K,\n        v: &'a V,\n    ) -> Self {\n        Self {\n            _guard: guard,\n            k,\n            v,\n        }\n    }\n\n    pub fn key(&self) -> &K {\n        self.k\n    }\n\n    pub fn value(&self) -> &V {\n        self.v\n    }\n\n    pub fn pair(&self) -> (&K, &V) {\n        (self.k, self.v)\n    }\n}","unsafe impl<'a, K: Eq + Hash + Send + Sync, V: Send + Sync, S: BuildHasher> Sync\n    for RefMulti<'a, K, V, S>\n{\n}","unsafe impl<'a, K: Eq + Hash + Send, V: Send, S: BuildHasher> Send for RefMulti<'a, K, V, S> {}"],"mapref::multiple::RefMutMulti":["impl<'a, K: Eq + Hash, V, S: BuildHasher> Deref for RefMutMulti<'a, K, V, S> {\n    type Target = V;\n\n    fn deref(&self) -> &V {\n        self.value()\n    }\n}","impl<'a, K: Eq + Hash, V, S: BuildHasher> DerefMut for RefMutMulti<'a, K, V, S> {\n    fn deref_mut(&mut self) -> &mut V {\n        self.value_mut()\n    }\n}","impl<'a, K: Eq + Hash, V, S: BuildHasher> RefMutMulti<'a, K, V, S> {\n    pub(crate) fn new(\n        guard: Arc<RwLockWriteGuard<'a, HashMap<K, V, S>>>,\n        k: &'a K,\n        v: &'a mut V,\n    ) -> Self {\n        Self {\n            _guard: guard,\n            k,\n            v,\n        }\n    }\n\n    pub fn key(&self) -> &K {\n        self.k\n    }\n\n    pub fn value(&self) -> &V {\n        self.v\n    }\n\n    pub fn value_mut(&mut self) -> &mut V {\n        self.v\n    }\n\n    pub fn pair(&self) -> (&K, &V) {\n        (self.k, self.v)\n    }\n\n    pub fn pair_mut(&mut self) -> (&K, &mut V) {\n        (self.k, self.v)\n    }\n}","unsafe impl<'a, K: Eq + Hash + Send + Sync, V: Send + Sync, S: BuildHasher> Sync\n    for RefMutMulti<'a, K, V, S>\n{\n}","unsafe impl<'a, K: Eq + Hash + Send, V: Send, S: BuildHasher> Send for RefMutMulti<'a, K, V, S> {}"],"mapref::one::Ref":["impl<'a, K: Eq + Hash, V, S: BuildHasher> Deref for Ref<'a, K, V, S> {\n    type Target = V;\n\n    fn deref(&self) -> &V {\n        self.value()\n    }\n}","impl<'a, K: Eq + Hash, V, S: BuildHasher> Ref<'a, K, V, S> {\n    pub(crate) fn new(guard: RwLockReadGuard<'a, HashMap<K, V, S>>, k: &'a K, v: &'a V) -> Self {\n        Self {\n            _guard: guard,\n            k,\n            v,\n        }\n    }\n\n    pub fn key(&self) -> &K {\n        self.k\n    }\n\n    pub fn value(&self) -> &V {\n        self.v\n    }\n\n    pub fn pair(&self) -> (&K, &V) {\n        (self.k, self.v)\n    }\n}","unsafe impl<'a, K: Eq + Hash + Send + Sync, V: Send + Sync, S: BuildHasher> Sync\n    for Ref<'a, K, V, S>\n{\n}","unsafe impl<'a, K: Eq + Hash + Send, V: Send, S: BuildHasher> Send for Ref<'a, K, V, S> {}"],"mapref::one::RefMut":["impl<'a, K: Eq + Hash, V, S: BuildHasher> Deref for RefMut<'a, K, V, S> {\n    type Target = V;\n\n    fn deref(&self) -> &V {\n        self.value()\n    }\n}","impl<'a, K: Eq + Hash, V, S: BuildHasher> DerefMut for RefMut<'a, K, V, S> {\n    fn deref_mut(&mut self) -> &mut V {\n        self.value_mut()\n    }\n}","impl<'a, K: Eq + Hash, V, S: BuildHasher> RefMut<'a, K, V, S> {\n    pub(crate) fn new(\n        guard: RwLockWriteGuard<'a, HashMap<K, V, S>>,\n        k: &'a K,\n        v: &'a mut V,\n    ) -> Self {\n        Self { guard, k, v }\n    }\n\n    pub fn key(&self) -> &K {\n        self.k\n    }\n\n    pub fn value(&self) -> &V {\n        self.v\n    }\n\n    pub fn value_mut(&mut self) -> &mut V {\n        self.v\n    }\n\n    pub fn pair(&self) -> (&K, &V) {\n        (self.k, self.v)\n    }\n\n    pub fn pair_mut(&mut self) -> (&K, &mut V) {\n        (self.k, self.v)\n    }\n\n    pub fn downgrade(self) -> Ref<'a, K, V, S> {\n        Ref::new(self.guard.downgrade(), self.k, self.v)\n    }\n}","unsafe impl<'a, K: Eq + Hash + Send + Sync, V: Send + Sync, S: BuildHasher> Sync\n    for RefMut<'a, K, V, S>\n{\n}","unsafe impl<'a, K: Eq + Hash + Send, V: Send, S: BuildHasher> Send for RefMut<'a, K, V, S> {}"],"read_only::ReadOnlyView":["impl<'a, K: 'a + Eq + Hash, V: 'a, S: BuildHasher + Clone> ReadOnlyView<K, V, S> {\n    /// Returns the number of elements in the map.\n\n    pub fn len(&self) -> usize {\n        self.map.len()\n    }\n\n    /// Returns `true` if the map contains no elements.\n\n    pub fn is_empty(&self) -> bool {\n        self.map.is_empty()\n    }\n\n    /// Returns the number of elements the map can hold without reallocating.\n\n    pub fn capacity(&self) -> usize {\n        self.map.capacity()\n    }\n\n    /// Returns `true` if the map contains a value for the specified key.\n\n    pub fn contains_key<Q>(&'a self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        let hash = self.map.hash_usize(&key);\n\n        let idx = self.map.determine_shard(hash);\n\n        let shard = unsafe { self.map._get_read_shard(idx) };\n\n        shard.contains_key(key)\n    }\n\n    /// Returns a reference to the value corresponding to the key.\n\n    pub fn get<Q>(&'a self, key: &Q) -> Option<&'a V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        let hash = self.map.hash_usize(&key);\n\n        let idx = self.map.determine_shard(hash);\n\n        let shard = unsafe { self.map._get_read_shard(idx) };\n\n        shard.get(key).map(|v| v.get())\n    }\n\n    /// Returns the key-value pair corresponding to the supplied key.\n\n    pub fn get_key_value<Q>(&'a self, key: &Q) -> Option<(&'a K, &'a V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        let hash = self.map.hash_usize(&key);\n\n        let idx = self.map.determine_shard(hash);\n\n        let shard = unsafe { self.map._get_read_shard(idx) };\n\n        shard.get_key_value(key).map(|(k, v)| (k, v.get()))\n    }\n\n    fn shard_read_iter(&'a self) -> impl Iterator<Item = &'a HashMap<K, V, S>> + 'a {\n        (0..self.map._shard_count())\n            .map(move |shard_i| unsafe { self.map._get_read_shard(shard_i) })\n    }\n\n    /// An iterator visiting all key-value pairs in arbitrary order. The iterator element type is `(&'a K, &'a V)`.\n\n    pub fn iter(&'a self) -> impl Iterator<Item = (&'a K, &'a V)> + 'a {\n        self.shard_read_iter()\n            .flat_map(|shard| shard.iter())\n            .map(|(k, v)| (k, v.get()))\n    }\n\n    /// An iterator visiting all keys in arbitrary order. The iterator element type is `&'a K`.\n\n    pub fn keys(&'a self) -> impl Iterator<Item = &'a K> + 'a {\n        self.shard_read_iter().flat_map(|shard| shard.keys())\n    }\n\n    /// An iterator visiting all values in arbitrary order. The iterator element type is `&'a V`.\n\n    pub fn values(&'a self) -> impl Iterator<Item = &'a V> + 'a {\n        self.shard_read_iter()\n            .flat_map(|shard| shard.values())\n            .map(|v| v.get())\n    }\n}","impl<K, V, S> ReadOnlyView<K, V, S> {\n    pub(crate) fn new(map: DashMap<K, V, S>) -> Self {\n        Self { map }\n    }\n\n    /// Consumes this `ReadOnlyView`, returning the underlying `DashMap`.\n\n    pub fn into_inner(self) -> DashMap<K, V, S> {\n        self.map\n    }\n}","impl<K: Eq + Hash + Clone, V: Clone, S: Clone> Clone for ReadOnlyView<K, V, S> {\n    fn clone(&self) -> Self {\n        Self {\n            map: self.map.clone(),\n        }\n    }\n}","impl<K: Eq + Hash + fmt::Debug, V: fmt::Debug, S: BuildHasher + Clone> fmt::Debug\n    for ReadOnlyView<K, V, S>\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.map.fmt(f)\n    }\n}"],"set::DashSet":["impl<'a, K: 'a + Eq + Hash, S: BuildHasher + Clone> DashSet<K, S> {\n    /// Creates a new DashMap with a capacity of 0 and the provided hasher.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let games = DashSet::with_hasher(s);\n    /// games.insert(\"Veloren\");\n    /// ```\n\n    pub fn with_hasher(hasher: S) -> Self {\n        Self::with_capacity_and_hasher(0, hasher)\n    }\n\n    /// Creates a new DashMap with a specified starting capacity and hasher.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let numbers = DashSet::with_capacity_and_hasher(2, s);\n    /// numbers.insert(2);\n    /// numbers.insert(8);\n    /// ```\n\n    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> Self {\n        Self {\n            inner: DashMap::with_capacity_and_hasher(capacity, hasher),\n        }\n    }\n\n    /// Hash a given item to produce a usize.\n    /// Uses the provided or default HashBuilder.\n\n    pub fn hash_usize<T: Hash>(&self, item: &T) -> usize {\n        self.inner.hash_usize(item)\n    }\n\n    cfg_if! {\n        if #[cfg(feature = \"raw-api\")] {\n            /// Allows you to peek at the inner shards that store your data.\n            /// You should probably not use this unless you know what you are doing.\n            ///\n            /// Requires the `raw-api` feature to be enabled.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use dashmap::DashSet;\n            ///\n            /// let set = DashSet::<()>::new();\n            /// println!(\"Amount of shards: {}\", set.shards().len());\n            /// ```\n\n            pub fn shards(&self) -> &[RwLock<HashMap<K, (), S>>] {\n                self.inner.shards()\n            }\n        }\n    }\n\n    cfg_if! {\n        if #[cfg(feature = \"raw-api\")] {\n            /// Finds which shard a certain key is stored in.\n            /// You should probably not use this unless you know what you are doing.\n            /// Note that shard selection is dependent on the default or provided HashBuilder.\n            ///\n            /// Requires the `raw-api` feature to be enabled.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use dashmap::DashSet;\n            ///\n            /// let set = DashSet::new();\n            /// set.insert(\"coca-cola\");\n            /// println!(\"coca-cola is stored in shard: {}\", set.determine_map(\"coca-cola\"));\n            /// ```\n\n            pub fn determine_map<Q>(&self, key: &Q) -> usize\n            where\n                K: Borrow<Q>,\n                Q: Hash + Eq + ?Sized,\n            {\n                self.inner.determine_map(key)\n            }\n        }\n    }\n\n    cfg_if! {\n        if #[cfg(feature = \"raw-api\")] {\n            /// Finds which shard a certain hash is stored in.\n            ///\n            /// Requires the `raw-api` feature to be enabled.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// use dashmap::DashSet;\n            ///\n            /// let set: DashSet<i32> = DashSet::new();\n            /// let key = \"key\";\n            /// let hash = set.hash_usize(&key);\n            /// println!(\"hash is stored in shard: {}\", set.determine_shard(hash));\n            /// ```\n\n            pub fn determine_shard(&self, hash: usize) -> usize {\n                self.inner.determine_shard(hash)\n            }\n        }\n    }\n\n    /// Inserts a key into the set. Returns true if the key was not already in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let set = DashSet::new();\n    /// set.insert(\"I am the key!\");\n    /// ```\n\n    pub fn insert(&self, key: K) -> bool {\n        self.inner.insert(key, ()).is_none()\n    }\n\n    /// Removes an entry from the map, returning the key if it existed in the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let soccer_team = DashSet::new();\n    /// soccer_team.insert(\"Jack\");\n    /// assert_eq!(soccer_team.remove(\"Jack\").unwrap(), \"Jack\");\n    /// ```\n\n    pub fn remove<Q>(&self, key: &Q) -> Option<K>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        self.inner.remove(key).map(|(k, _)| k)\n    }\n\n    /// Removes an entry from the set, returning the key\n    /// if the entry existed and the provided conditional function returned true.\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let soccer_team = DashSet::new();\n    /// soccer_team.insert(\"Sam\");\n    /// soccer_team.remove_if(\"Sam\", |player| player.starts_with(\"Ja\"));\n    /// assert!(soccer_team.contains(\"Sam\"));\n    /// ```\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let soccer_team = DashSet::new();\n    /// soccer_team.insert(\"Sam\");\n    /// soccer_team.remove_if(\"Jacob\", |player| player.starts_with(\"Ja\"));\n    /// assert!(!soccer_team.contains(\"Jacob\"));\n    /// ```\n\n    pub fn remove_if<Q>(&self, key: &Q, f: impl FnOnce(&K) -> bool) -> Option<K>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        // TODO: Don't create another closure around f\n        self.inner.remove_if(key, |k, _| f(k)).map(|(k, _)| k)\n    }\n\n    /// Creates an iterator over a DashMap yielding immutable references.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let words = DashSet::new();\n    /// words.insert(\"hello\");\n    /// assert_eq!(words.iter().count(), 1);\n    /// ```\n\n    pub fn iter(&'a self) -> Iter<'a, K, S, DashMap<K, (), S>> {\n        let iter = self.inner.iter();\n\n        Iter::new(iter)\n    }\n\n    /// Get a reference to an entry in the set\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let youtubers = DashSet::new();\n    /// youtubers.insert(\"Bosnian Bill\");\n    /// assert_eq!(*youtubers.get(\"Bosnian Bill\").unwrap(), \"Bosnian Bill\");\n    /// ```\n\n    pub fn get<Q>(&'a self, key: &Q) -> Option<Ref<'a, K, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        self.inner.get(key).map(Ref::new)\n    }\n\n    /// Remove excess capacity to reduce memory usage.\n\n    pub fn shrink_to_fit(&self) {\n        self.inner.shrink_to_fit()\n    }\n\n    /// Retain elements that whose predicates return true\n    /// and discard elements whose predicates return false.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let people = DashSet::new();\n    /// people.insert(\"Albin\");\n    /// people.insert(\"Jones\");\n    /// people.insert(\"Charlie\");\n    /// people.retain(|name| name.contains('i'));\n    /// assert_eq!(people.len(), 2);\n    /// ```\n\n    pub fn retain(&self, mut f: impl FnMut(&K) -> bool) {\n        // TODO: Don't create another closure\n        self.inner.retain(|k, _| f(k))\n    }\n\n    /// Fetches the total number of keys stored in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let people = DashSet::new();\n    /// people.insert(\"Albin\");\n    /// people.insert(\"Jones\");\n    /// people.insert(\"Charlie\");\n    /// assert_eq!(people.len(), 3);\n    /// ```\n\n    pub fn len(&self) -> usize {\n        self.inner.len()\n    }\n\n    /// Checks if the set is empty or not.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let map = DashSet::<()>::new();\n    /// assert!(map.is_empty());\n    /// ```\n\n    pub fn is_empty(&self) -> bool {\n        self.inner.is_empty()\n    }\n\n    /// Removes all keys in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let people = DashSet::new();\n    /// people.insert(\"Albin\");\n    /// assert!(!people.is_empty());\n    /// people.clear();\n    /// assert!(people.is_empty());\n    /// ```\n\n    pub fn clear(&self) {\n        self.inner.clear()\n    }\n\n    /// Returns how many keys the set can store without reallocating.\n\n    pub fn capacity(&self) -> usize {\n        self.inner.capacity()\n    }\n\n    /// Checks if the set contains a specific key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let people = DashSet::new();\n    /// people.insert(\"Dakota Cherries\");\n    /// assert!(people.contains(\"Dakota Cherries\"));\n    /// ```\n\n    pub fn contains<Q>(&self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        self.inner.contains_key(key)\n    }\n}","impl<'a, K: 'a + Eq + Hash> DashSet<K, RandomState> {\n    /// Creates a new DashSet with a capacity of 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let games = DashSet::new();\n    /// games.insert(\"Veloren\");\n    /// ```\n\n    pub fn new() -> Self {\n        Self::with_hasher(RandomState::default())\n    }\n\n    /// Creates a new DashMap with a specified starting capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use dashmap::DashSet;\n    ///\n    /// let numbers = DashSet::with_capacity(2);\n    /// numbers.insert(2);\n    /// numbers.insert(8);\n    /// ```\n\n    pub fn with_capacity(capacity: usize) -> Self {\n        Self::with_capacity_and_hasher(capacity, RandomState::default())\n    }\n}","impl<'a, K: Eq + Hash, S: BuildHasher + Clone> IntoIterator for DashSet<K, S> {\n    type Item = K;\n\n    type IntoIter = OwningIter<K, S>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        OwningIter::new(self.inner.into_iter())\n    }\n}","impl<K, S> Default for DashSet<K, S>\nwhere\n    K: Eq + Hash,\n    S: Default + BuildHasher + Clone,\n{\n    fn default() -> Self {\n        Self::with_hasher(Default::default())\n    }\n}","impl<K: Eq + Hash + Clone, S: Clone> Clone for DashSet<K, S> {\n    fn clone(&self) -> Self {\n        Self {\n            inner: self.inner.clone(),\n        }\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        self.inner.clone_from(&source.inner)\n    }\n}","impl<K: Eq + Hash + fmt::Debug, S: BuildHasher + Clone> fmt::Debug for DashSet<K, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.inner, f)\n    }\n}","impl<K: Eq + Hash, S: BuildHasher + Clone> Extend<K> for DashSet<K, S> {\n    fn extend<T: IntoIterator<Item = K>>(&mut self, iter: T) {\n        let iter = iter.into_iter().map(|k| (k, ()));\n\n        self.inner.extend(iter)\n    }\n}","impl<K: Eq + Hash> FromIterator<K> for DashSet<K, RandomState> {\n    fn from_iter<I: IntoIterator<Item = K>>(iter: I) -> Self {\n        let mut set = DashSet::new();\n\n        set.extend(iter);\n\n        set\n    }\n}"],"setref::multiple::RefMulti":["impl<'a, K: Eq + Hash, S: BuildHasher> Deref for RefMulti<'a, K, S> {\n    type Target = K;\n\n    fn deref(&self) -> &K {\n        self.key()\n    }\n}","impl<'a, K: Eq + Hash, S: BuildHasher> RefMulti<'a, K, S> {\n    pub(crate) fn new(inner: mapref::multiple::RefMulti<'a, K, (), S>) -> Self {\n        Self { inner }\n    }\n\n    pub fn key(&self) -> &K {\n        self.inner.key()\n    }\n}"],"setref::one::Ref":["impl<'a, K: Eq + Hash, S: BuildHasher> Deref for Ref<'a, K, S> {\n    type Target = K;\n\n    fn deref(&self) -> &K {\n        self.key()\n    }\n}","impl<'a, K: Eq + Hash, S: BuildHasher> Ref<'a, K, S> {\n    pub(crate) fn new(inner: mapref::one::Ref<'a, K, (), S>) -> Self {\n        Self { inner }\n    }\n\n    pub fn key(&self) -> &K {\n        self.inner.key()\n    }\n}","unsafe impl<'a, K: Eq + Hash + Send + Sync, S: BuildHasher> Sync for Ref<'a, K, S> {}","unsafe impl<'a, K: Eq + Hash + Send, S: BuildHasher> Send for Ref<'a, K, S> {}"],"util::AbortOnPanic":["impl Drop for AbortOnPanic {\n    fn drop(&mut self) {\n        cfg_if::cfg_if! {\n            if #[cfg(feature = \"no_std\")] {\n                // Note: This is hard, as core/no_std has no concept of threads or knowledge of panicking.\n                // An alternative would be to do this:\n                //\n                // ```rust\n                // // Elsewhere in the library/host binary\n                // use core::sync::atomic::{AtomicBool, Ordering};\n                //\n                // static UNWINDING: AtomicBool = AtomicBool::new(false);\n                //\n                // #[panic_handler]\n                // fn panic(info: &PanicInfo) -> ! {\n                //      UNWINDING.store(true, Ordering::Relaxed);\n                //\n                //      unsafe {\n                //          core::intrinsics::abort();\n                //      }\n                // }\n                //\n                // // In AbortOnPanic::drop\n                // if UNWINDING.load(Ordering::Relaxed) {\n                //      unsafe {\n                //          core::intrinsics::abort();\n                //      }\n                // }\n                // ```\n                //\n                // Now, this isn't an ideal solution for multiple reasons, as it uses intrinsics which require a feature\n                // and can be overwritten by the user without them even knowing. That being said, *most* users of no_std\n                // do tend to use panic = \"abort\", which solves this problem for us by aborting on panics.\n            } else {\n                if std::thread::panicking() {\n                    std::process::abort()\n                }\n            }\n        }\n    }\n}"],"util::SharedValue":["impl<T: Clone> Clone for SharedValue<T> {\n    fn clone(&self) -> Self {\n        let inner = self.get().clone();\n\n        Self {\n            value: UnsafeCell::new(inner),\n        }\n    }\n}","impl<T> SharedValue<T> {\n    /// Create a new `SharedValue<T>`\n\n    pub const fn new(value: T) -> Self {\n        Self {\n            value: UnsafeCell::new(value),\n        }\n    }\n\n    /// Get a shared reference to `T`\n\n    pub fn get(&self) -> &T {\n        unsafe { &*self.value.get() }\n    }\n\n    /// Get an unique reference to `T`\n\n    pub fn get_mut(&mut self) -> &mut T {\n        unsafe { &mut *self.value.get() }\n    }\n\n    /// Unwraps the value\n\n    pub fn into_inner(self) -> T {\n        self.value.into_inner()\n    }\n\n    /// Get a mutable raw pointer to the underlying value\n\n    pub(crate) fn as_ptr(&self) -> *mut T {\n        self.value.get()\n    }\n}","unsafe impl<T: Send> Send for SharedValue<T> {}","unsafe impl<T: Sync> Sync for SharedValue<T> {}"]},"single_path_import":{"read_only::ReadOnlyView":"ReadOnlyView","set::DashSet":"DashSet","t::Map":"Map"},"srcs":{"<&'a DashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a DashMap<K, V, S> as std::ops::BitAnd<&Q>>::bitand":["fn bitand(self, key: &Q) -> Self::Output{\n        self.contains_key(key)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a DashMap<K, V, S> as std::ops::BitOr<&Q>>::bitor":["fn bitor(self, key: &Q) -> Self::Output{\n        self.get_mut(key).unwrap()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a DashMap<K, V, S> as std::ops::Shl<(K, V)>>::shl":["fn shl(self, pair: (K, V)) -> Self::Output{\n        self.insert(pair.0, pair.1)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a DashMap<K, V, S> as std::ops::Shr<&Q>>::shr":["fn shr(self, key: &Q) -> Self::Output{\n        self.get(key).unwrap()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a DashMap<K, V, S> as std::ops::Sub<&Q>>::sub":["fn sub(self, key: &Q) -> Self::Output{\n        self.remove(key)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        let mut inner_shards = Vec::new();\n\n        for shard in self.shards.iter() {\n            let shard = shard.read();\n\n            inner_shards.push(RwLock::new((*shard).clone()));\n        }\n\n        Self {\n            shift: self.shift,\n            shards: inner_shards.into_boxed_slice(),\n            hasher: self.hasher.clone(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as std::default::Default>::default":["fn default() -> Self{\n        Self::with_hasher(Default::default())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let mut pmap = f.debug_map();\n\n        for r in self {\n            let (k, v) = r.pair();\n\n            pmap.entry(k, v);\n        }\n\n        pmap.finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as std::iter::Extend<(K, V)>>::extend":["fn extend<I: IntoIterator<Item = (K, V)>>(&mut self, intoiter: I){\n        for pair in intoiter.into_iter() {\n            self.insert(pair.0, pair.1);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        OwningIter::new(self)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_alter":["fn _alter<Q>(&self, key: &Q, f: impl FnOnce(&K, V) -> V)\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        if let Some(mut r) = self.get_mut(key) {\n            util::map_in_place_2(r.pair_mut(), f);\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_alter_all":["fn _alter_all(&self, mut f: impl FnMut(&K, V) -> V){\n        self.shards.iter().for_each(|s| {\n            s.write()\n                .iter_mut()\n                .for_each(|(k, v)| util::map_in_place_2((k, v.get_mut()), &mut f));\n        });\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_capacity":["fn _capacity(&self) -> usize{\n        self.shards.iter().map(|s| s.read().capacity()).sum()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_entry":["fn _entry(&'a self, key: K) -> Entry<'a, K, V, S>{\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let shard = unsafe { self._yield_write_shard(idx) };\n\n        if let Some((kptr, vptr)) = shard.get_key_value(&key) {\n            unsafe {\n                let kptr = util::change_lifetime_const(kptr);\n\n                let vptr = &mut *vptr.as_ptr();\n\n                Entry::Occupied(OccupiedEntry::new(shard, key, (kptr, vptr)))\n            }\n        } else {\n            Entry::Vacant(VacantEntry::new(shard, key))\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_get":["fn _get<Q>(&'a self, key: &Q) -> Option<Ref<'a, K, V, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let shard = unsafe { self._yield_read_shard(idx) };\n\n        if let Some((kptr, vptr)) = shard.get_key_value(key) {\n            unsafe {\n                let kptr = util::change_lifetime_const(kptr);\n\n                let vptr = util::change_lifetime_const(vptr);\n\n                Some(Ref::new(shard, kptr, vptr.get()))\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_get_mut":["fn _get_mut<Q>(&'a self, key: &Q) -> Option<RefMut<'a, K, V, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let shard = unsafe { self._yield_write_shard(idx) };\n\n        if let Some((kptr, vptr)) = shard.get_key_value(key) {\n            unsafe {\n                let kptr = util::change_lifetime_const(kptr);\n\n                let vptr = &mut *vptr.as_ptr();\n\n                Some(RefMut::new(shard, kptr, vptr))\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_get_read_shard":["unsafe fn _get_read_shard(&'a self, i: usize) -> &'a HashMap<K, V, S>{\n        debug_assert!(i < self.shards.len());\n\n        self.shards.get_unchecked(i).get()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_hasher":["fn _hasher(&self) -> S{\n        self.hasher.clone()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_insert":["fn _insert(&self, key: K, value: V) -> Option<V>{\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let mut shard = unsafe { self._yield_write_shard(idx) };\n\n        shard\n            .insert(key, SharedValue::new(value))\n            .map(|v| v.into_inner())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_iter":["fn _iter(&'a self) -> Iter<'a, K, V, S, DashMap<K, V, S>>{\n        Iter::new(self)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_iter_mut":["fn _iter_mut(&'a self) -> IterMut<'a, K, V, S, DashMap<K, V, S>>{\n        IterMut::new(self)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_len":["fn _len(&self) -> usize{\n        self.shards.iter().map(|s| s.read().len()).sum()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_remove":["fn _remove<Q>(&self, key: &Q) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let mut shard = unsafe { self._yield_write_shard(idx) };\n\n        shard.remove_entry(key).map(|(k, v)| (k, v.into_inner()))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_remove_if":["fn _remove_if<Q>(&self, key: &Q, f: impl FnOnce(&K, &V) -> bool) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        let hash = self.hash_usize(&key);\n\n        let idx = self.determine_shard(hash);\n\n        let mut shard = unsafe { self._yield_write_shard(idx) };\n\n        if let Some((k, v)) = shard.get_key_value(key) {\n            if f(k, v.get()) {\n                shard.remove_entry(key).map(|(k, v)| (k, v.into_inner()))\n            } else {\n                None\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_retain":["fn _retain(&self, mut f: impl FnMut(&K, &mut V) -> bool){\n        self.shards\n            .iter()\n            .for_each(|s| s.write().retain(|k, v| f(k, v.get_mut())));\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_shard_count":["fn _shard_count(&self) -> usize{\n        self.shards.len()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_shrink_to_fit":["fn _shrink_to_fit(&self){\n        self.shards.iter().for_each(|s| s.write().shrink_to_fit());\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_yield_read_shard":["unsafe fn _yield_read_shard(&'a self, i: usize) -> RwLockReadGuard<'a, HashMap<K, V, S>>{\n        debug_assert!(i < self.shards.len());\n\n        self.shards.get_unchecked(i).read()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_yield_write_shard":["unsafe fn _yield_write_shard(&'a self, i: usize) -> RwLockWriteGuard<'a, HashMap<K, V, S>>{\n        debug_assert!(i < self.shards.len());\n\n        self.shards.get_unchecked(i).write()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DashMap<K, V> as std::iter::FromIterator<(K, V)>>::from_iter":["fn from_iter<I: IntoIterator<Item = (K, V)>>(intoiter: I) -> Self{\n        let mut map = DashMap::new();\n\n        map.extend(intoiter);\n\n        map\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<iter::Iter<'a, K, V, S, M> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        loop {\n            if let Some(current) = self.current.as_mut() {\n                if let Some((k, v)) = current.1.next() {\n                    let guard = current.0.clone();\n\n                    return Some(RefMulti::new(guard, k, v.get()));\n                }\n            }\n\n            if self.shard_i == self.map._shard_count() {\n                return None;\n            }\n\n            let guard = unsafe { self.map._yield_read_shard(self.shard_i) };\n\n            let sref: &HashMap<K, V, S> = unsafe { util::change_lifetime_const(&*guard) };\n\n            let iter = sref.iter();\n\n            self.current = Some((Arc::new(guard), iter));\n\n            self.shard_i += 1;\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::IterMut<'a, K, V, S, M> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        loop {\n            if let Some(current) = self.current.as_mut() {\n                if let Some((k, v)) = current.1.next() {\n                    let guard = current.0.clone();\n\n                    unsafe {\n                        let k = util::change_lifetime_const(k);\n\n                        let v = &mut *v.as_ptr();\n\n                        return Some(RefMutMulti::new(guard, k, v));\n                    }\n                }\n            }\n\n            if self.shard_i == self.map._shard_count() {\n                return None;\n            }\n\n            let mut guard = unsafe { self.map._yield_write_shard(self.shard_i) };\n\n            let sref: &mut HashMap<K, V, S> = unsafe { util::change_lifetime_mut(&mut *guard) };\n\n            let iter = sref.iter_mut();\n\n            self.current = Some((Arc::new(guard), iter));\n\n            self.shard_i += 1;\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::OwningIter<K, V, S> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        loop {\n            if let Some(current) = self.current.as_mut() {\n                if let Some((k, v)) = current.next() {\n                    return Some((k, v.into_inner()));\n                }\n            }\n\n            if self.shard_i == self.map._shard_count() {\n                return None;\n            }\n\n            //let guard = unsafe { self.map._yield_read_shard(self.shard_i) };\n            let mut shard_wl = unsafe { self.map._yield_write_shard(self.shard_i) };\n\n            let hasher = self.map._hasher();\n\n            let map = mem::replace(&mut *shard_wl, HashMap::with_hasher(hasher));\n\n            drop(shard_wl);\n\n            let iter = map.into_iter();\n\n            //unsafe { ptr::write(&mut self.current, Some((arcee, iter))); }\n            self.current = Some(iter);\n\n            self.shard_i += 1;\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter_set::Iter<'a, K, S, M> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(RefMulti::new)\n    }","Real(LocalPath(\"src/iter_set.rs\"))"],"<iter_set::OwningIter<K, S> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|(k, _)| k)\n    }","Real(LocalPath(\"src/iter_set.rs\"))"],"<lock::RwLock<T> as std::default::Default>::default":["fn default() -> RwLock<T>{\n        RwLock::new(Default::default())\n    }","Real(LocalPath(\"src/lock.rs\"))"],"<lock::RwLock<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self.try_read() {\n            Some(guard) => write!(f, \"RwLock {{ data: \")\n                .and_then(|()| (&*guard).fmt(f))\n                .and_then(|()| write!(f, \"}}\")),\n            None => write!(f, \"RwLock {{ <locked> }}\"),\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"<lock::RwLockReadGuard<'rwlock, T> as std::ops::Deref>::deref":["fn deref(&self) -> &T{\n        unsafe { self.data.as_ref() }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"<lock::RwLockReadGuard<'rwlock, T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        debug_assert!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED) > 0);\n\n        self.lock.fetch_sub(READER, Ordering::Release);\n    }","Real(LocalPath(\"src/lock.rs\"))"],"<lock::RwLockUpgradeableGuard<'rwlock, T> as std::ops::Deref>::deref":["fn deref(&self) -> &T{\n        unsafe { self.data.as_ref() }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"<lock::RwLockUpgradeableGuard<'rwlock, T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        debug_assert_eq!(\n            self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED),\n            UPGRADED\n        );\n\n        self.lock.fetch_sub(UPGRADED, Ordering::AcqRel);\n    }","Real(LocalPath(\"src/lock.rs\"))"],"<lock::RwLockWriteGuard<'rwlock, T> as std::ops::Deref>::deref":["fn deref(&self) -> &T{\n        unsafe { self.data.as_ref() }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"<lock::RwLockWriteGuard<'rwlock, T> as std::ops::DerefMut>::deref_mut":["fn deref_mut(&mut self) -> &mut T{\n        unsafe { self.data.as_mut() }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"<lock::RwLockWriteGuard<'rwlock, T> as std::ops::Drop>::drop":["fn drop(&mut self){\n        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & WRITER, WRITER);\n\n        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n    }","Real(LocalPath(\"src/lock.rs\"))"],"<mapref::multiple::RefMulti<'a, K, V, S> as std::ops::Deref>::deref":["fn deref(&self) -> &V{\n        self.value()\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"<mapref::multiple::RefMutMulti<'a, K, V, S> as std::ops::Deref>::deref":["fn deref(&self) -> &V{\n        self.value()\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"<mapref::multiple::RefMutMulti<'a, K, V, S> as std::ops::DerefMut>::deref_mut":["fn deref_mut(&mut self) -> &mut V{\n        self.value_mut()\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"<mapref::one::Ref<'a, K, V, S> as std::ops::Deref>::deref":["fn deref(&self) -> &V{\n        self.value()\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"<mapref::one::RefMut<'a, K, V, S> as std::ops::Deref>::deref":["fn deref(&self) -> &V{\n        self.value()\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"<mapref::one::RefMut<'a, K, V, S> as std::ops::DerefMut>::deref_mut":["fn deref_mut(&mut self) -> &mut V{\n        self.value_mut()\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"<read_only::ReadOnlyView<K, V, S> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        Self {\n            map: self.map.clone(),\n        }\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"<read_only::ReadOnlyView<K, V, S> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        self.map.fmt(f)\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"<set::DashSet<K, S> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        Self {\n            inner: self.inner.clone(),\n        }\n    }","Real(LocalPath(\"src/set.rs\"))"],"<set::DashSet<K, S> as std::clone::Clone>::clone_from":["fn clone_from(&mut self, source: &Self){\n        self.inner.clone_from(&source.inner)\n    }","Real(LocalPath(\"src/set.rs\"))"],"<set::DashSet<K, S> as std::default::Default>::default":["fn default() -> Self{\n        Self::with_hasher(Default::default())\n    }","Real(LocalPath(\"src/set.rs\"))"],"<set::DashSet<K, S> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Debug::fmt(&self.inner, f)\n    }","Real(LocalPath(\"src/set.rs\"))"],"<set::DashSet<K, S> as std::iter::Extend<K>>::extend":["fn extend<T: IntoIterator<Item = K>>(&mut self, iter: T){\n        let iter = iter.into_iter().map(|k| (k, ()));\n\n        self.inner.extend(iter)\n    }","Real(LocalPath(\"src/set.rs\"))"],"<set::DashSet<K, S> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        OwningIter::new(self.inner.into_iter())\n    }","Real(LocalPath(\"src/set.rs\"))"],"<set::DashSet<K> as std::iter::FromIterator<K>>::from_iter":["fn from_iter<I: IntoIterator<Item = K>>(iter: I) -> Self{\n        let mut set = DashSet::new();\n\n        set.extend(iter);\n\n        set\n    }","Real(LocalPath(\"src/set.rs\"))"],"<setref::multiple::RefMulti<'a, K, S> as std::ops::Deref>::deref":["fn deref(&self) -> &K{\n        self.key()\n    }","Real(LocalPath(\"src/setref/multiple.rs\"))"],"<setref::one::Ref<'a, K, S> as std::ops::Deref>::deref":["fn deref(&self) -> &K{\n        self.key()\n    }","Real(LocalPath(\"src/setref/one.rs\"))"],"<util::AbortOnPanic as std::ops::Drop>::drop":["fn drop(&mut self){\n        cfg_if::cfg_if! {\n            if #[cfg(feature = \"no_std\")] {\n                // Note: This is hard, as core/no_std has no concept of threads or knowledge of panicking.\n                // An alternative would be to do this:\n                //\n                // ```rust\n                // // Elsewhere in the library/host binary\n                // use core::sync::atomic::{AtomicBool, Ordering};\n                //\n                // static UNWINDING: AtomicBool = AtomicBool::new(false);\n                //\n                // #[panic_handler]\n                // fn panic(info: &PanicInfo) -> ! {\n                //      UNWINDING.store(true, Ordering::Relaxed);\n                //\n                //      unsafe {\n                //          core::intrinsics::abort();\n                //      }\n                // }\n                //\n                // // In AbortOnPanic::drop\n                // if UNWINDING.load(Ordering::Relaxed) {\n                //      unsafe {\n                //          core::intrinsics::abort();\n                //      }\n                // }\n                // ```\n                //\n                // Now, this isn't an ideal solution for multiple reasons, as it uses intrinsics which require a feature\n                // and can be overwritten by the user without them even knowing. That being said, *most* users of no_std\n                // do tend to use panic = \"abort\", which solves this problem for us by aborting on panics.\n            } else {\n                if std::thread::panicking() {\n                    std::process::abort()\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/util.rs\"))"],"<util::SharedValue<T> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        let inner = self.get().clone();\n\n        Self {\n            value: UnsafeCell::new(inner),\n        }\n    }","Real(LocalPath(\"src/util.rs\"))"],"DashMap":["/// DashMap is an implementation of a concurrent associative array/hashmap in Rust.\n///\n/// DashMap tries to implement an easy to use API similar to `std::collections::HashMap`\n/// with some slight changes to handle concurrency.\n///\n/// DashMap tries to be very simple to use and to be a direct replacement for `RwLock<HashMap<K, V, S>>`.\n/// To accomplish these all methods take `&self` instead modifying methods taking `&mut self`.\n/// This allows you to put a DashMap in an `Arc<T>` and share it between threads while being able to modify it.\npub struct DashMap<K, V, S = RandomState> {\n    shift: usize,\n    shards: Box<[RwLock<HashMap<K, V, S>>]>,\n    hasher: S,\n}","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::alter":["/// Modify a specific value according to a function.\n///\n/// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let stats = DashMap::new();\n/// stats.insert(\"Goals\", 4);\n/// stats.alter(\"Goals\", |_, v| v * 2);\n/// assert_eq!(*stats.get(\"Goals\").unwrap(), 8);\n/// ```\n///\n/// # Panics\n///\n/// If the given closure panics, then `alter_all` will abort the process\npub fn alter<Q>(&self, key: &Q, f: impl FnOnce(&K, V) -> V)\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        self._alter(key, f);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::alter_all":["/// Modify every value in the map according to a function.\n///\n/// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let stats = DashMap::new();\n/// stats.insert(\"Wins\", 4);\n/// stats.insert(\"Losses\", 2);\n/// stats.alter_all(|_, v| v + 1);\n/// assert_eq!(*stats.get(\"Wins\").unwrap(), 5);\n/// assert_eq!(*stats.get(\"Losses\").unwrap(), 3);\n/// ```\n///\n/// # Panics\n///\n/// If the given closure panics, then `alter_all` will abort the process\npub fn alter_all(&self, f: impl FnMut(&K, V) -> V){\n        self._alter_all(f);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::capacity":["/// Returns how many key-value pairs the map can store without reallocating.\n///\n/// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\npub fn capacity(&self) -> usize{\n        self._capacity()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::clear":["/// Removes all key-value pairs in the map.\n///\n/// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let stats = DashMap::new();\n/// stats.insert(\"Goals\", 4);\n/// assert!(!stats.is_empty());\n/// stats.clear();\n/// assert!(stats.is_empty());\n/// ```\npub fn clear(&self){\n        self._clear();\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::contains_key":["/// Checks if the map contains a specific key.\n///\n/// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let team_sizes = DashMap::new();\n/// team_sizes.insert(\"Dakota Cherries\", 23);\n/// assert!(team_sizes.contains_key(\"Dakota Cherries\"));\n/// ```\npub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        self._contains_key(key)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::determine_shard":["pub(crate) fn determine_shard(&self, hash: usize) -> usize{\n                // Leave the high 7 bits for the HashBrown SIMD tag.\n                (hash << 7) >> self.shift\n            }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::entry":["/// Advanced entry API that tries to mimic `std::collections::HashMap`.\n/// See the documentation on `dashmap::mapref::entry` for more details.\n///\n/// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\npub fn entry(&'a self, key: K) -> Entry<'a, K, V, S>{\n        self._entry(key)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::get":["/// Get a immutable reference to an entry in the map\n///\n/// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let youtubers = DashMap::new();\n/// youtubers.insert(\"Bosnian Bill\", 457000);\n/// assert_eq!(*youtubers.get(\"Bosnian Bill\").unwrap(), 457000);\n/// ```\npub fn get<Q>(&'a self, key: &Q) -> Option<Ref<'a, K, V, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        self._get(key)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::get_mut":["/// Get a mutable reference to an entry in the map\n///\n/// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let class = DashMap::new();\n/// class.insert(\"Albin\", 15);\n/// *class.get_mut(\"Albin\").unwrap() -= 1;\n/// assert_eq!(*class.get(\"Albin\").unwrap(), 14);\n/// ```\npub fn get_mut<Q>(&'a self, key: &Q) -> Option<RefMut<'a, K, V, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        self._get_mut(key)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::hash_usize":["/// Hash a given item to produce a usize.\n/// Uses the provided or default HashBuilder.\npub fn hash_usize<T: Hash>(&self, item: &T) -> usize{\n        let mut hasher = self.hasher.build_hasher();\n\n        item.hash(&mut hasher);\n\n        hasher.finish() as usize\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::hasher":["/// Returns a reference to the map's [`BuildHasher`].\n///\n/// # Examples\n///\n/// ```rust\n/// use dashmap::DashMap;\n/// use ahash::RandomState;\n///\n/// let hasher = RandomState::new();\n/// let map: DashMap<i32, i32> = DashMap::new();\n/// let hasher: &RandomState = map.hasher();\n/// ```\n///\n/// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\npub fn hasher(&self) -> &S{\n        &self.hasher\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::insert":["/// Inserts a key and a value into the map.\n///\n/// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let map = DashMap::new();\n/// map.insert(\"I am the key!\", \"And I am the value!\");\n/// ```\npub fn insert(&self, key: K, value: V) -> Option<V>{\n        self._insert(key, value)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::into_read_only":["/// Wraps this `DashMap` into a read-only view. This view allows to obtain raw references to the stored values.\npub fn into_read_only(self) -> ReadOnlyView<K, V, S>{\n        ReadOnlyView::new(self)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::is_empty":["/// Checks if the map is empty or not.\n///\n/// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let map = DashMap::<(), ()>::new();\n/// assert!(map.is_empty());\n/// ```\npub fn is_empty(&self) -> bool{\n        self._is_empty()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::iter":["/// Creates an iterator over a DashMap yielding immutable references.\n///\n/// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let words = DashMap::new();\n/// words.insert(\"hello\", \"world\");\n/// assert_eq!(words.iter().count(), 1);\n/// ```\npub fn iter(&'a self) -> Iter<'a, K, V, S, DashMap<K, V, S>>{\n        self._iter()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::iter_mut":["/// Iterator over a DashMap yielding mutable references.\n///\n/// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let map = DashMap::new();\n/// map.insert(\"Johnny\", 21);\n/// map.iter_mut().for_each(|mut r| *r += 1);\n/// assert_eq!(*map.get(\"Johnny\").unwrap(), 22);\n/// ```\npub fn iter_mut(&'a self) -> IterMut<'a, K, V, S, DashMap<K, V, S>>{\n        self._iter_mut()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::len":["/// Fetches the total number of key-value pairs stored in the map.\n///\n/// **Locking behaviour:** May deadlock if called when holding a mutable reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let people = DashMap::new();\n/// people.insert(\"Albin\", 15);\n/// people.insert(\"Jones\", 22);\n/// people.insert(\"Charlie\", 27);\n/// assert_eq!(people.len(), 3);\n/// ```\npub fn len(&self) -> usize{\n        self._len()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::remove":["/// Removes an entry from the map, returning the key and value if they existed in the map.\n///\n/// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let soccer_team = DashMap::new();\n/// soccer_team.insert(\"Jack\", \"Goalie\");\n/// assert_eq!(soccer_team.remove(\"Jack\").unwrap().1, \"Goalie\");\n/// ```\npub fn remove<Q>(&self, key: &Q) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        self._remove(key)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::remove_if":["/// Removes an entry from the map, returning the key and value\n/// if the entry existed and the provided conditional function returned true.\n///\n/// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let soccer_team = DashMap::new();\n/// soccer_team.insert(\"Sam\", \"Forward\");\n/// soccer_team.remove_if(\"Sam\", |_, position| position == &\"Goalie\");\n/// assert!(soccer_team.contains_key(\"Sam\"));\n/// ```\n/// ```\n/// use dashmap::DashMap;\n///\n/// let soccer_team = DashMap::new();\n/// soccer_team.insert(\"Sam\", \"Forward\");\n/// soccer_team.remove_if(\"Sam\", |_, position| position == &\"Forward\");\n/// assert!(!soccer_team.contains_key(\"Sam\"));\n/// ```\npub fn remove_if<Q>(&self, key: &Q, f: impl FnOnce(&K, &V) -> bool) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        self._remove_if(key, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::retain":["/// Retain elements that whose predicates return true\n/// and discard elements whose predicates return false.\n///\n/// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let people = DashMap::new();\n/// people.insert(\"Albin\", 15);\n/// people.insert(\"Jones\", 22);\n/// people.insert(\"Charlie\", 27);\n/// people.retain(|_, v| *v > 20);\n/// assert_eq!(people.len(), 2);\n/// ```\npub fn retain(&self, f: impl FnMut(&K, &mut V) -> bool){\n        self._retain(f);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::shards":["#[allow(dead_code)]\npub(crate) fn shards(&self) -> &[RwLock<HashMap<K, V, S>>]{\n                &self.shards\n            }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::shrink_to_fit":["/// Remove excess capacity to reduce memory usage.\n///\n/// **Locking behaviour:** May deadlock if called when holding any sort of reference into the map.\npub fn shrink_to_fit(&self){\n        self._shrink_to_fit();\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::with_capacity_and_hasher":["/// Creates a new DashMap with a specified starting capacity and hasher.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n/// use std::collections::hash_map::RandomState;\n///\n/// let s = RandomState::new();\n/// let mappings = DashMap::with_capacity_and_hasher(2, s);\n/// mappings.insert(2, 4);\n/// mappings.insert(8, 16);\n/// ```\npub fn with_capacity_and_hasher(mut capacity: usize, hasher: S) -> Self{\n        let shard_amount = shard_amount();\n        let shift = util::ptr_size_bits() - ncb(shard_amount);\n\n        if capacity != 0 {\n            capacity = (capacity + (shard_amount - 1)) & !(shard_amount - 1);\n        }\n\n        let cps = capacity / shard_amount;\n\n        let shards = (0..shard_amount)\n            .map(|_| RwLock::new(HashMap::with_capacity_and_hasher(cps, hasher.clone())))\n            .collect();\n\n        Self {\n            shift,\n            shards,\n            hasher,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V, S>::with_hasher":["/// Creates a new DashMap with a capacity of 0 and the provided hasher.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n/// use std::collections::hash_map::RandomState;\n///\n/// let s = RandomState::new();\n/// let reviews = DashMap::with_hasher(s);\n/// reviews.insert(\"Veloren\", \"What a fantastic game!\");\n/// ```\npub fn with_hasher(hasher: S) -> Self{\n        Self::with_capacity_and_hasher(0, hasher)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V>::new":["/// Creates a new DashMap with a capacity of 0.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let reviews = DashMap::new();\n/// reviews.insert(\"Veloren\", \"What a fantastic game!\");\n/// ```\npub fn new() -> Self{\n        DashMap::with_hasher(RandomState::default())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DashMap::<K, V>::with_capacity":["/// Creates a new DashMap with a specified starting capacity.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let mappings = DashMap::with_capacity(2);\n/// mappings.insert(2, 4);\n/// mappings.insert(8, 16);\n/// ```\npub fn with_capacity(capacity: usize) -> Self{\n        DashMap::with_capacity_and_hasher(capacity, RandomState::default())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"iter::Iter":["/// Iterator over a DashMap yielding immutable references.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let map = DashMap::new();\n/// map.insert(\"hello\", \"world\");\n/// assert_eq!(map.iter().count(), 1);\n/// ```\npub struct Iter<'a, K, V, S = RandomState, M = DashMap<K, V, S>> {\n    map: &'a M,\n    shard_i: usize,\n    current: Option<GuardIter<'a, K, V, S>>,\n}","Real(LocalPath(\"src/iter.rs\"))"],"iter::Iter::<'a, K, V, S, M>::new":["pub(crate) fn new(map: &'a M) -> Self{\n        Self {\n            map,\n            shard_i: 0,\n            current: None,\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"iter::IterMut":["/// Iterator over a DashMap yielding mutable references.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let map = DashMap::new();\n/// map.insert(\"Johnny\", 21);\n/// map.iter_mut().for_each(|mut r| *r += 1);\n/// assert_eq!(*map.get(\"Johnny\").unwrap(), 22);\n/// ```\npub struct IterMut<'a, K, V, S = RandomState, M = DashMap<K, V, S>> {\n    map: &'a M,\n    shard_i: usize,\n    current: Option<GuardIterMut<'a, K, V, S>>,\n}","Real(LocalPath(\"src/iter.rs\"))"],"iter::IterMut::<'a, K, V, S, M>::new":["pub(crate) fn new(map: &'a M) -> Self{\n        Self {\n            map,\n            shard_i: 0,\n            current: None,\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"iter::OwningIter":["/// Iterator over a DashMap yielding key value pairs.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashMap;\n///\n/// let map = DashMap::new();\n/// map.insert(\"hello\", \"world\");\n/// map.insert(\"alex\", \"steve\");\n/// let pairs: Vec<(&'static str, &'static str)> = map.into_iter().collect();\n/// assert_eq!(pairs.len(), 2);\n/// ```\npub struct OwningIter<K, V, S = RandomState> {\n    map: DashMap<K, V, S>,\n    shard_i: usize,\n    current: Option<GuardOwningIter<K, V>>,\n}","Real(LocalPath(\"src/iter.rs\"))"],"iter::OwningIter::<K, V, S>::new":["pub(crate) fn new(map: DashMap<K, V, S>) -> Self{\n        Self {\n            map,\n            shard_i: 0,\n            current: None,\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"iter_set::Iter":["pub struct Iter<'a, K, S, M> {\n    inner: crate::iter::Iter<'a, K, (), S, M>,\n}","Real(LocalPath(\"src/iter_set.rs\"))"],"iter_set::Iter::<'a, K, S, M>::new":["pub(crate) fn new(inner: crate::iter::Iter<'a, K, (), S, M>) -> Self{\n        Self { inner }\n    }","Real(LocalPath(\"src/iter_set.rs\"))"],"iter_set::OwningIter":["pub struct OwningIter<K, S> {\n    inner: crate::iter::OwningIter<K, (), S>,\n}","Real(LocalPath(\"src/iter_set.rs\"))"],"iter_set::OwningIter::<K, S>::new":["pub(crate) fn new(inner: crate::iter::OwningIter<K, (), S>) -> Self{\n        Self { inner }\n    }","Real(LocalPath(\"src/iter_set.rs\"))"],"lock::RwLock":["pub struct RwLock<T: ?Sized> {\n    lock: AtomicUsize,\n    data: UnsafeCell<T>,\n}","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::force_read_decrement":["/// # Safety\n///\n/// This is only safe if the lock is currently locked in read mode and the number of readers is not 0.\npub unsafe fn force_read_decrement(&self){\n        debug_assert!(self.lock.load(Ordering::Relaxed) & !WRITER > 0);\n\n        self.lock.fetch_sub(READER, Ordering::Release);\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::force_write_unlock":["/// # Safety\n///\n/// The lock must be locked in write mode.\npub unsafe fn force_write_unlock(&self){\n        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED), 0);\n\n        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::get":["pub fn get(&self) -> &T{\n        unsafe { &*self.data.get() }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::get_mut":["pub fn get_mut(&mut self) -> &mut T{\n        unsafe { &mut *self.data.get() }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::into_inner":["pub fn into_inner(self) -> T{\n        let RwLock { data, .. } = self;\n\n        data.into_inner()\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::new":["pub const fn new(user_data: T) -> RwLock<T>{\n        RwLock {\n            lock: AtomicUsize::new(0),\n            data: UnsafeCell::new(user_data),\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::read":["pub fn read(&self) -> RwLockReadGuard<T>{\n        loop {\n            match self.try_read() {\n                Some(guard) => return guard,\n                None => cpu_relax(),\n            }\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::try_read":["pub fn try_read(&self) -> Option<RwLockReadGuard<T>>{\n        let value = self.lock.fetch_add(READER, Ordering::Acquire);\n\n        // We check the UPGRADED bit here so that new readers are prevented when an UPGRADED lock is held.\n        // This helps reduce writer starvation.\n        if value & (WRITER | UPGRADED) != 0 {\n            // Lock is taken, undo.\n            self.lock.fetch_sub(READER, Ordering::Release);\n\n            None\n        } else {\n            Some(RwLockReadGuard {\n                lock: &self.lock,\n                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n            })\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::try_upgradeable_read":["pub fn try_upgradeable_read(&self) -> Option<RwLockUpgradeableGuard<T>>{\n        if self.lock.fetch_or(UPGRADED, Ordering::Acquire) & (WRITER | UPGRADED) == 0 {\n            Some(RwLockUpgradeableGuard {\n                lock: &self.lock,\n                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n                _invariant: PhantomData,\n            })\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::try_write":["pub fn try_write(&self) -> Option<RwLockWriteGuard<T>>{\n        self.try_write_internal(true)\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::try_write_internal":["fn try_write_internal(&self, strong: bool) -> Option<RwLockWriteGuard<T>>{\n        if compare_exchange(\n            &self.lock,\n            0,\n            WRITER,\n            Ordering::Acquire,\n            Ordering::Relaxed,\n            strong,\n        )\n        .is_ok()\n        {\n            Some(RwLockWriteGuard {\n                lock: &self.lock,\n                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n                _invariant: PhantomData,\n            })\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::upgradeable_read":["pub fn upgradeable_read(&self) -> RwLockUpgradeableGuard<T>{\n        loop {\n            match self.try_upgradeable_read() {\n                Some(guard) => return guard,\n                None => cpu_relax(),\n            }\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLock::<T>::write":["pub fn write(&self) -> RwLockWriteGuard<T>{\n        loop {\n            match self.try_write_internal(false) {\n                Some(guard) => return guard,\n                None => cpu_relax(),\n            }\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLockReadGuard":["pub struct RwLockReadGuard<'a, T: 'a + ?Sized> {\n    lock: &'a AtomicUsize,\n    data: NonNull<T>,\n}","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLockUpgradeableGuard":["pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized> {\n    lock: &'a AtomicUsize,\n    data: NonNull<T>,\n    #[doc(hidden)]\n    _invariant: PhantomData<&'a mut T>,\n}","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLockUpgradeableGuard::<'rwlock, T>::downgrade":["pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T>{\n        self.lock.fetch_add(READER, Ordering::Acquire);\n\n        RwLockReadGuard {\n            lock: &self.lock,\n            data: self.data,\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLockUpgradeableGuard::<'rwlock, T>::try_upgrade":["pub fn try_upgrade(self) -> Result<RwLockWriteGuard<'rwlock, T>, Self>{\n        self.try_upgrade_internal(true)\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLockUpgradeableGuard::<'rwlock, T>::try_upgrade_internal":["fn try_upgrade_internal(self, strong: bool) -> Result<RwLockWriteGuard<'rwlock, T>, Self>{\n        if compare_exchange(\n            &self.lock,\n            UPGRADED,\n            WRITER,\n            Ordering::Acquire,\n            Ordering::Relaxed,\n            strong,\n        )\n        .is_ok()\n        {\n            let out = Ok(RwLockWriteGuard {\n                lock: &self.lock,\n                data: self.data,\n                _invariant: PhantomData,\n            });\n\n            mem::forget(self);\n\n            out\n        } else {\n            Err(self)\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLockUpgradeableGuard::<'rwlock, T>::upgrade":["pub fn upgrade(mut self) -> RwLockWriteGuard<'rwlock, T>{\n        loop {\n            self = match self.try_upgrade_internal(false) {\n                Ok(guard) => return guard,\n                Err(e) => e,\n            };\n\n            cpu_relax();\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLockWriteGuard":["pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\n    lock: &'a AtomicUsize,\n    data: NonNull<T>,\n    #[doc(hidden)]\n    _invariant: PhantomData<&'a mut T>,\n}","Real(LocalPath(\"src/lock.rs\"))"],"lock::RwLockWriteGuard::<'rwlock, T>::downgrade":["pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T>{\n        self.lock.fetch_add(READER, Ordering::Acquire);\n\n        RwLockReadGuard {\n            lock: &self.lock,\n            data: self.data,\n        }\n    }","Real(LocalPath(\"src/lock.rs\"))"],"lock::compare_exchange":["fn compare_exchange(\n    atomic: &AtomicUsize,\n    current: usize,\n    new: usize,\n    success: Ordering,\n    failure: Ordering,\n    strong: bool,\n) -> Result<usize, usize>{\n    if strong {\n        atomic.compare_exchange(current, new, success, failure)\n    } else {\n        atomic.compare_exchange_weak(current, new, success, failure)\n    }\n}","Real(LocalPath(\"src/lock.rs\"))"],"mapref::entry::Entry":["pub enum Entry<'a, K, V, S = RandomState> {\n    Occupied(OccupiedEntry<'a, K, V, S>),\n    Vacant(VacantEntry<'a, K, V, S>),\n}","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::Entry::<'a, K, V, S>::and_modify":["/// Apply a function to the stored value if it exists.\npub fn and_modify(self, f: impl FnOnce(&mut V)) -> Self{\n        match self {\n            Entry::Occupied(mut entry) => {\n                f(entry.get_mut());\n\n                Entry::Occupied(entry)\n            }\n\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::Entry::<'a, K, V, S>::into_key":["/// Into the key of the entry.\npub fn into_key(self) -> K{\n        match self {\n            Entry::Occupied(entry) => entry.into_key(),\n            Entry::Vacant(entry) => entry.into_key(),\n        }\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::Entry::<'a, K, V, S>::key":["/// Get the key of the entry.\npub fn key(&self) -> &K{\n        match *self {\n            Entry::Occupied(ref entry) => entry.key(),\n            Entry::Vacant(ref entry) => entry.key(),\n        }\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::Entry::<'a, K, V, S>::or_default":["/// Return a mutable reference to the element if it exists,\n/// otherwise insert the default and return a mutable reference to that.\npub fn or_default(self) -> RefMut<'a, K, V, S>\n    where\n        V: Default,{\n        match self {\n            Entry::Occupied(entry) => entry.into_ref(),\n            Entry::Vacant(entry) => entry.insert(V::default()),\n        }\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::Entry::<'a, K, V, S>::or_insert":["/// Return a mutable reference to the element if it exists,\n/// otherwise a provided value and return a mutable reference to that.\npub fn or_insert(self, value: V) -> RefMut<'a, K, V, S>{\n        match self {\n            Entry::Occupied(entry) => entry.into_ref(),\n            Entry::Vacant(entry) => entry.insert(value),\n        }\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::Entry::<'a, K, V, S>::or_insert_with":["/// Return a mutable reference to the element if it exists,\n/// otherwise insert the result of a provided function and return a mutable reference to that.\npub fn or_insert_with(self, value: impl FnOnce() -> V) -> RefMut<'a, K, V, S>{\n        match self {\n            Entry::Occupied(entry) => entry.into_ref(),\n            Entry::Vacant(entry) => entry.insert(value()),\n        }\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::Entry::<'a, K, V, S>::or_try_insert_with":["pub fn or_try_insert_with<E>(\n        self,\n        value: impl FnOnce() -> Result<V, E>,\n    ) -> Result<RefMut<'a, K, V, S>, E>{\n        match self {\n            Entry::Occupied(entry) => Ok(entry.into_ref()),\n            Entry::Vacant(entry) => Ok(entry.insert(value()?)),\n        }\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::OccupiedEntry":["pub struct OccupiedEntry<'a, K, V, S> {\n    shard: RwLockWriteGuard<'a, HashMap<K, V, S>>,\n    elem: (&'a K, &'a mut V),\n    key: K,\n}","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::get":["pub fn get(&self) -> &V{\n        self.elem.1\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::get_mut":["pub fn get_mut(&mut self) -> &mut V{\n        self.elem.1\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::insert":["pub fn insert(&mut self, value: V) -> V{\n        mem::replace(self.elem.1, value)\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::into_key":["pub fn into_key(self) -> K{\n        self.key\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::into_ref":["pub fn into_ref(self) -> RefMut<'a, K, V, S>{\n        RefMut::new(self.shard, self.elem.0, self.elem.1)\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::key":["pub fn key(&self) -> &K{\n        self.elem.0\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::new":["pub(crate) fn new(\n        shard: RwLockWriteGuard<'a, HashMap<K, V, S>>,\n        key: K,\n        elem: (&'a K, &'a mut V),\n    ) -> Self{\n        Self { shard, elem, key }\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::remove":["pub fn remove(mut self) -> V{\n        self.shard.remove(self.elem.0).unwrap().into_inner()\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::remove_entry":["pub fn remove_entry(mut self) -> (K, V){\n        let (k, v) = self.shard.remove_entry(self.elem.0).unwrap();\n\n        (k, v.into_inner())\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::OccupiedEntry::<'a, K, V, S>::replace_entry":["pub fn replace_entry(mut self, value: V) -> (K, V){\n        let nk = self.key;\n\n        let (k, v) = self.shard.remove_entry(self.elem.0).unwrap();\n\n        self.shard.insert(nk, SharedValue::new(value));\n\n        (k, v.into_inner())\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::VacantEntry":["pub struct VacantEntry<'a, K, V, S> {\n    shard: RwLockWriteGuard<'a, HashMap<K, V, S>>,\n    key: K,\n}","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::VacantEntry::<'a, K, V, S>::insert":["pub fn insert(mut self, value: V) -> RefMut<'a, K, V, S>{\n        unsafe {\n            let c: K = ptr::read(&self.key);\n\n            self.shard.insert(self.key, SharedValue::new(value));\n\n            let (k, v) = self.shard.get_key_value(&c).unwrap();\n\n            let k = util::change_lifetime_const(k);\n\n            let v = &mut *v.as_ptr();\n\n            let r = RefMut::new(self.shard, k, v);\n\n            mem::forget(c);\n\n            r\n        }\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::VacantEntry::<'a, K, V, S>::into_key":["pub fn into_key(self) -> K{\n        self.key\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::VacantEntry::<'a, K, V, S>::key":["pub fn key(&self) -> &K{\n        &self.key\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::entry::VacantEntry::<'a, K, V, S>::new":["pub(crate) fn new(shard: RwLockWriteGuard<'a, HashMap<K, V, S>>, key: K) -> Self{\n        Self { shard, key }\n    }","Real(LocalPath(\"src/mapref/entry.rs\"))"],"mapref::multiple::RefMulti":["pub struct RefMulti<'a, K, V, S = RandomState> {\n    _guard: Arc<RwLockReadGuard<'a, HashMap<K, V, S>>>,\n    k: &'a K,\n    v: &'a V,\n}","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::multiple::RefMulti::<'a, K, V, S>::key":["pub fn key(&self) -> &K{\n        self.k\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::multiple::RefMulti::<'a, K, V, S>::new":["pub(crate) fn new(\n        guard: Arc<RwLockReadGuard<'a, HashMap<K, V, S>>>,\n        k: &'a K,\n        v: &'a V,\n    ) -> Self{\n        Self {\n            _guard: guard,\n            k,\n            v,\n        }\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::multiple::RefMulti::<'a, K, V, S>::pair":["pub fn pair(&self) -> (&K, &V){\n        (self.k, self.v)\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::multiple::RefMulti::<'a, K, V, S>::value":["pub fn value(&self) -> &V{\n        self.v\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::multiple::RefMutMulti":["pub struct RefMutMulti<'a, K, V, S = RandomState> {\n    _guard: Arc<RwLockWriteGuard<'a, HashMap<K, V, S>>>,\n    k: &'a K,\n    v: &'a mut V,\n}","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::key":["pub fn key(&self) -> &K{\n        self.k\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::new":["pub(crate) fn new(\n        guard: Arc<RwLockWriteGuard<'a, HashMap<K, V, S>>>,\n        k: &'a K,\n        v: &'a mut V,\n    ) -> Self{\n        Self {\n            _guard: guard,\n            k,\n            v,\n        }\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::pair":["pub fn pair(&self) -> (&K, &V){\n        (self.k, self.v)\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::pair_mut":["pub fn pair_mut(&mut self) -> (&K, &mut V){\n        (self.k, self.v)\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::value":["pub fn value(&self) -> &V{\n        self.v\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::multiple::RefMutMulti::<'a, K, V, S>::value_mut":["pub fn value_mut(&mut self) -> &mut V{\n        self.v\n    }","Real(LocalPath(\"src/mapref/multiple.rs\"))"],"mapref::one::Ref":["pub struct Ref<'a, K, V, S = RandomState> {\n    _guard: RwLockReadGuard<'a, HashMap<K, V, S>>,\n    k: &'a K,\n    v: &'a V,\n}","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::Ref::<'a, K, V, S>::key":["pub fn key(&self) -> &K{\n        self.k\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::Ref::<'a, K, V, S>::new":["pub(crate) fn new(guard: RwLockReadGuard<'a, HashMap<K, V, S>>, k: &'a K, v: &'a V) -> Self{\n        Self {\n            _guard: guard,\n            k,\n            v,\n        }\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::Ref::<'a, K, V, S>::pair":["pub fn pair(&self) -> (&K, &V){\n        (self.k, self.v)\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::Ref::<'a, K, V, S>::value":["pub fn value(&self) -> &V{\n        self.v\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::RefMut":["pub struct RefMut<'a, K, V, S = RandomState> {\n    guard: RwLockWriteGuard<'a, HashMap<K, V, S>>,\n    k: &'a K,\n    v: &'a mut V,\n}","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::RefMut::<'a, K, V, S>::downgrade":["pub fn downgrade(self) -> Ref<'a, K, V, S>{\n        Ref::new(self.guard.downgrade(), self.k, self.v)\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::RefMut::<'a, K, V, S>::key":["pub fn key(&self) -> &K{\n        self.k\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::RefMut::<'a, K, V, S>::new":["pub(crate) fn new(\n        guard: RwLockWriteGuard<'a, HashMap<K, V, S>>,\n        k: &'a K,\n        v: &'a mut V,\n    ) -> Self{\n        Self { guard, k, v }\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::RefMut::<'a, K, V, S>::pair":["pub fn pair(&self) -> (&K, &V){\n        (self.k, self.v)\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::RefMut::<'a, K, V, S>::pair_mut":["pub fn pair_mut(&mut self) -> (&K, &mut V){\n        (self.k, self.v)\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::RefMut::<'a, K, V, S>::value":["pub fn value(&self) -> &V{\n        self.v\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"mapref::one::RefMut::<'a, K, V, S>::value_mut":["pub fn value_mut(&mut self) -> &mut V{\n        self.v\n    }","Real(LocalPath(\"src/mapref/one.rs\"))"],"ncb":["fn ncb(shard_amount: usize) -> usize{\n    shard_amount.trailing_zeros() as usize\n}","Real(LocalPath(\"src/lib.rs\"))"],"read_only::ReadOnlyView":["/// A read-only view into a `DashMap`. Allows to obtain raw references to the stored values.\npub struct ReadOnlyView<K, V, S = RandomState> {\n    map: DashMap<K, V, S>,\n}","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::capacity":["/// Returns the number of elements the map can hold without reallocating.\npub fn capacity(&self) -> usize{\n        self.map.capacity()\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::contains_key":["/// Returns `true` if the map contains a value for the specified key.\npub fn contains_key<Q>(&'a self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        let hash = self.map.hash_usize(&key);\n\n        let idx = self.map.determine_shard(hash);\n\n        let shard = unsafe { self.map._get_read_shard(idx) };\n\n        shard.contains_key(key)\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::get":["/// Returns a reference to the value corresponding to the key.\npub fn get<Q>(&'a self, key: &Q) -> Option<&'a V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        let hash = self.map.hash_usize(&key);\n\n        let idx = self.map.determine_shard(hash);\n\n        let shard = unsafe { self.map._get_read_shard(idx) };\n\n        shard.get(key).map(|v| v.get())\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::get_key_value":["/// Returns the key-value pair corresponding to the supplied key.\npub fn get_key_value<Q>(&'a self, key: &Q) -> Option<(&'a K, &'a V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        let hash = self.map.hash_usize(&key);\n\n        let idx = self.map.determine_shard(hash);\n\n        let shard = unsafe { self.map._get_read_shard(idx) };\n\n        shard.get_key_value(key).map(|(k, v)| (k, v.get()))\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::into_inner":["/// Consumes this `ReadOnlyView`, returning the underlying `DashMap`.\npub fn into_inner(self) -> DashMap<K, V, S>{\n        self.map\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::is_empty":["/// Returns `true` if the map contains no elements.\npub fn is_empty(&self) -> bool{\n        self.map.is_empty()\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::iter":["/// An iterator visiting all key-value pairs in arbitrary order. The iterator element type is `(&'a K, &'a V)`.\npub fn iter(&'a self) -> impl Iterator<Item = (&'a K, &'a V)> + 'a{\n        self.shard_read_iter()\n            .flat_map(|shard| shard.iter())\n            .map(|(k, v)| (k, v.get()))\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::keys":["/// An iterator visiting all keys in arbitrary order. The iterator element type is `&'a K`.\npub fn keys(&'a self) -> impl Iterator<Item = &'a K> + 'a{\n        self.shard_read_iter().flat_map(|shard| shard.keys())\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::len":["/// Returns the number of elements in the map.\npub fn len(&self) -> usize{\n        self.map.len()\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::new":["pub(crate) fn new(map: DashMap<K, V, S>) -> Self{\n        Self { map }\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::shard_read_iter":["fn shard_read_iter(&'a self) -> impl Iterator<Item = &'a HashMap<K, V, S>> + 'a{\n        (0..self.map._shard_count())\n            .map(move |shard_i| unsafe { self.map._get_read_shard(shard_i) })\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"read_only::ReadOnlyView::<K, V, S>::values":["/// An iterator visiting all values in arbitrary order. The iterator element type is `&'a V`.\npub fn values(&'a self) -> impl Iterator<Item = &'a V> + 'a{\n        self.shard_read_iter()\n            .flat_map(|shard| shard.values())\n            .map(|v| v.get())\n    }","Real(LocalPath(\"src/read_only.rs\"))"],"set::DashSet":["/// DashSet is a thin wrapper around [`DashMap`] using `()` as the value type. It uses\n/// methods and types which are more convenient to work with on a set.\n///\n/// [`DashMap`]: struct.DashMap.html\npub struct DashSet<K, S = RandomState> {\n    inner: DashMap<K, (), S>,\n}","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::capacity":["/// Returns how many keys the set can store without reallocating.\npub fn capacity(&self) -> usize{\n        self.inner.capacity()\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::clear":["/// Removes all keys in the set.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let people = DashSet::new();\n/// people.insert(\"Albin\");\n/// assert!(!people.is_empty());\n/// people.clear();\n/// assert!(people.is_empty());\n/// ```\npub fn clear(&self){\n        self.inner.clear()\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::contains":["/// Checks if the set contains a specific key.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let people = DashSet::new();\n/// people.insert(\"Dakota Cherries\");\n/// assert!(people.contains(\"Dakota Cherries\"));\n/// ```\npub fn contains<Q>(&self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        self.inner.contains_key(key)\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::get":["/// Get a reference to an entry in the set\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let youtubers = DashSet::new();\n/// youtubers.insert(\"Bosnian Bill\");\n/// assert_eq!(*youtubers.get(\"Bosnian Bill\").unwrap(), \"Bosnian Bill\");\n/// ```\npub fn get<Q>(&'a self, key: &Q) -> Option<Ref<'a, K, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        self.inner.get(key).map(Ref::new)\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::hash_usize":["/// Hash a given item to produce a usize.\n/// Uses the provided or default HashBuilder.\npub fn hash_usize<T: Hash>(&self, item: &T) -> usize{\n        self.inner.hash_usize(item)\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::insert":["/// Inserts a key into the set. Returns true if the key was not already in the set.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let set = DashSet::new();\n/// set.insert(\"I am the key!\");\n/// ```\npub fn insert(&self, key: K) -> bool{\n        self.inner.insert(key, ()).is_none()\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::is_empty":["/// Checks if the set is empty or not.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let map = DashSet::<()>::new();\n/// assert!(map.is_empty());\n/// ```\npub fn is_empty(&self) -> bool{\n        self.inner.is_empty()\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::iter":["/// Creates an iterator over a DashMap yielding immutable references.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let words = DashSet::new();\n/// words.insert(\"hello\");\n/// assert_eq!(words.iter().count(), 1);\n/// ```\npub fn iter(&'a self) -> Iter<'a, K, S, DashMap<K, (), S>>{\n        let iter = self.inner.iter();\n\n        Iter::new(iter)\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::len":["/// Fetches the total number of keys stored in the set.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let people = DashSet::new();\n/// people.insert(\"Albin\");\n/// people.insert(\"Jones\");\n/// people.insert(\"Charlie\");\n/// assert_eq!(people.len(), 3);\n/// ```\npub fn len(&self) -> usize{\n        self.inner.len()\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::remove":["/// Removes an entry from the map, returning the key if it existed in the map.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let soccer_team = DashSet::new();\n/// soccer_team.insert(\"Jack\");\n/// assert_eq!(soccer_team.remove(\"Jack\").unwrap(), \"Jack\");\n/// ```\npub fn remove<Q>(&self, key: &Q) -> Option<K>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        self.inner.remove(key).map(|(k, _)| k)\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::remove_if":["/// Removes an entry from the set, returning the key\n/// if the entry existed and the provided conditional function returned true.\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let soccer_team = DashSet::new();\n/// soccer_team.insert(\"Sam\");\n/// soccer_team.remove_if(\"Sam\", |player| player.starts_with(\"Ja\"));\n/// assert!(soccer_team.contains(\"Sam\"));\n/// ```\n/// ```\n/// use dashmap::DashSet;\n///\n/// let soccer_team = DashSet::new();\n/// soccer_team.insert(\"Sam\");\n/// soccer_team.remove_if(\"Jacob\", |player| player.starts_with(\"Ja\"));\n/// assert!(!soccer_team.contains(\"Jacob\"));\n/// ```\npub fn remove_if<Q>(&self, key: &Q, f: impl FnOnce(&K) -> bool) -> Option<K>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        // TODO: Don't create another closure around f\n        self.inner.remove_if(key, |k, _| f(k)).map(|(k, _)| k)\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::retain":["/// Retain elements that whose predicates return true\n/// and discard elements whose predicates return false.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let people = DashSet::new();\n/// people.insert(\"Albin\");\n/// people.insert(\"Jones\");\n/// people.insert(\"Charlie\");\n/// people.retain(|name| name.contains('i'));\n/// assert_eq!(people.len(), 2);\n/// ```\npub fn retain(&self, mut f: impl FnMut(&K) -> bool){\n        // TODO: Don't create another closure\n        self.inner.retain(|k, _| f(k))\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::shrink_to_fit":["/// Remove excess capacity to reduce memory usage.\npub fn shrink_to_fit(&self){\n        self.inner.shrink_to_fit()\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::with_capacity_and_hasher":["/// Creates a new DashMap with a specified starting capacity and hasher.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n/// use std::collections::hash_map::RandomState;\n///\n/// let s = RandomState::new();\n/// let numbers = DashSet::with_capacity_and_hasher(2, s);\n/// numbers.insert(2);\n/// numbers.insert(8);\n/// ```\npub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> Self{\n        Self {\n            inner: DashMap::with_capacity_and_hasher(capacity, hasher),\n        }\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K, S>::with_hasher":["/// Creates a new DashMap with a capacity of 0 and the provided hasher.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n/// use std::collections::hash_map::RandomState;\n///\n/// let s = RandomState::new();\n/// let games = DashSet::with_hasher(s);\n/// games.insert(\"Veloren\");\n/// ```\npub fn with_hasher(hasher: S) -> Self{\n        Self::with_capacity_and_hasher(0, hasher)\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K>::new":["/// Creates a new DashSet with a capacity of 0.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let games = DashSet::new();\n/// games.insert(\"Veloren\");\n/// ```\npub fn new() -> Self{\n        Self::with_hasher(RandomState::default())\n    }","Real(LocalPath(\"src/set.rs\"))"],"set::DashSet::<K>::with_capacity":["/// Creates a new DashMap with a specified starting capacity.\n///\n/// # Examples\n///\n/// ```\n/// use dashmap::DashSet;\n///\n/// let numbers = DashSet::with_capacity(2);\n/// numbers.insert(2);\n/// numbers.insert(8);\n/// ```\npub fn with_capacity(capacity: usize) -> Self{\n        Self::with_capacity_and_hasher(capacity, RandomState::default())\n    }","Real(LocalPath(\"src/set.rs\"))"],"setref::multiple::RefMulti":["pub struct RefMulti<'a, K, S = RandomState> {\n    inner: mapref::multiple::RefMulti<'a, K, (), S>,\n}","Real(LocalPath(\"src/setref/multiple.rs\"))"],"setref::multiple::RefMulti::<'a, K, S>::key":["pub fn key(&self) -> &K{\n        self.inner.key()\n    }","Real(LocalPath(\"src/setref/multiple.rs\"))"],"setref::multiple::RefMulti::<'a, K, S>::new":["pub(crate) fn new(inner: mapref::multiple::RefMulti<'a, K, (), S>) -> Self{\n        Self { inner }\n    }","Real(LocalPath(\"src/setref/multiple.rs\"))"],"setref::one::Ref":["pub struct Ref<'a, K, S = RandomState> {\n    inner: mapref::one::Ref<'a, K, (), S>,\n}","Real(LocalPath(\"src/setref/one.rs\"))"],"setref::one::Ref::<'a, K, S>::key":["pub fn key(&self) -> &K{\n        self.inner.key()\n    }","Real(LocalPath(\"src/setref/one.rs\"))"],"setref::one::Ref::<'a, K, S>::new":["pub(crate) fn new(inner: mapref::one::Ref<'a, K, (), S>) -> Self{\n        Self { inner }\n    }","Real(LocalPath(\"src/setref/one.rs\"))"],"shard_amount":["fn shard_amount() -> usize{\n    (num_cpus::get() * 4).next_power_of_two()\n}","Real(LocalPath(\"src/lib.rs\"))"],"t::Map":["/// Implementation detail that is exposed due to generic constraints in public types.\npub trait Map<'a, K: 'a + Eq + Hash, V: 'a, S: 'a + Clone + BuildHasher> {\n    fn _shard_count(&self) -> usize;\n\n    /// # Safety\n    ///\n    /// The index must not be out of bounds.\n\n    unsafe fn _get_read_shard(&'a self, i: usize) -> &'a HashMap<K, V, S>;\n\n    /// # Safety\n    ///\n    /// The index must not be out of bounds.\n\n    unsafe fn _yield_read_shard(&'a self, i: usize) -> RwLockReadGuard<'a, HashMap<K, V, S>>;\n\n    /// # Safety\n    ///\n    /// The index must not be out of bounds.\n\n    unsafe fn _yield_write_shard(&'a self, i: usize) -> RwLockWriteGuard<'a, HashMap<K, V, S>>;\n\n    fn _insert(&self, key: K, value: V) -> Option<V>;\n\n    fn _remove<Q>(&self, key: &Q) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized;\n\n    fn _remove_if<Q>(&self, key: &Q, f: impl FnOnce(&K, &V) -> bool) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized;\n\n    fn _iter(&'a self) -> Iter<'a, K, V, S, Self>\n    where\n        Self: Sized;\n\n    fn _iter_mut(&'a self) -> IterMut<'a, K, V, S, Self>\n    where\n        Self: Sized;\n\n    fn _get<Q>(&'a self, key: &Q) -> Option<Ref<'a, K, V, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized;\n\n    fn _get_mut<Q>(&'a self, key: &Q) -> Option<RefMut<'a, K, V, S>>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized;\n\n    fn _shrink_to_fit(&self);\n\n    fn _retain(&self, f: impl FnMut(&K, &mut V) -> bool);\n\n    fn _len(&self) -> usize;\n\n    fn _capacity(&self) -> usize;\n\n    fn _alter<Q>(&self, key: &Q, f: impl FnOnce(&K, V) -> V)\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized;\n\n    fn _alter_all(&self, f: impl FnMut(&K, V) -> V);\n\n    fn _entry(&'a self, key: K) -> Entry<'a, K, V, S>;\n\n    fn _hasher(&self) -> S;\n\n    // provided\n    fn _clear(&self) {\n        self._retain(|_, _| false)\n    }\n\n    fn _contains_key<Q>(&'a self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,\n    {\n        self._get(key).is_some()\n    }\n\n    fn _is_empty(&self) -> bool {\n        self._len() == 0\n    }\n}","Real(LocalPath(\"src/t.rs\"))"],"t::Map::_clear":["fn _clear(&self){\n        self._retain(|_, _| false)\n    }","Real(LocalPath(\"src/t.rs\"))"],"t::Map::_contains_key":["fn _contains_key<Q>(&'a self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq + ?Sized,{\n        self._get(key).is_some()\n    }","Real(LocalPath(\"src/t.rs\"))"],"t::Map::_is_empty":["fn _is_empty(&self) -> bool{\n        self._len() == 0\n    }","Real(LocalPath(\"src/t.rs\"))"],"util::AbortOnPanic":["struct AbortOnPanic;","Real(LocalPath(\"src/util.rs\"))"],"util::SharedValue":["/// A simple wrapper around `T`\n///\n/// This is to prevent UB when using `HashMap::get_key_value`, because\n/// `HashMap` doesn't expose an api to get the key and value, where\n/// the value is a `&mut T`.\n///\n/// See [#10](https://github.com/xacrimon/dashmap/issues/10) for details\n///\n/// This type is meant to be an implementation detail, but must be exposed due to the `Dashmap::shards`\n#[repr(transparent)]\npub struct SharedValue<T> {\n    value: UnsafeCell<T>,\n}","Real(LocalPath(\"src/util.rs\"))"],"util::SharedValue::<T>::as_ptr":["/// Get a mutable raw pointer to the underlying value\npub(crate) fn as_ptr(&self) -> *mut T{\n        self.value.get()\n    }","Real(LocalPath(\"src/util.rs\"))"],"util::SharedValue::<T>::get":["/// Get a shared reference to `T`\npub fn get(&self) -> &T{\n        unsafe { &*self.value.get() }\n    }","Real(LocalPath(\"src/util.rs\"))"],"util::SharedValue::<T>::get_mut":["/// Get an unique reference to `T`\npub fn get_mut(&mut self) -> &mut T{\n        unsafe { &mut *self.value.get() }\n    }","Real(LocalPath(\"src/util.rs\"))"],"util::SharedValue::<T>::into_inner":["/// Unwraps the value\npub fn into_inner(self) -> T{\n        self.value.into_inner()\n    }","Real(LocalPath(\"src/util.rs\"))"],"util::SharedValue::<T>::new":["/// Create a new `SharedValue<T>`\npub const fn new(value: T) -> Self{\n        Self {\n            value: UnsafeCell::new(value),\n        }\n    }","Real(LocalPath(\"src/util.rs\"))"],"util::change_lifetime_const":["/// # Safety\n///\n/// Requires that you ensure the reference does not become invalid.\n/// The object has to outlive the reference.\npub unsafe fn change_lifetime_const<'a, 'b, T>(x: &'a T) -> &'b T{\n    &*(x as *const T)\n}","Real(LocalPath(\"src/util.rs\"))"],"util::change_lifetime_mut":["/// # Safety\n///\n/// Requires that you ensure the reference does not become invalid.\n/// The object has to outlive the reference.\npub unsafe fn change_lifetime_mut<'a, 'b, T>(x: &'a mut T) -> &'b mut T{\n    &mut *(x as *mut T)\n}","Real(LocalPath(\"src/util.rs\"))"],"util::map_in_place_2":["pub fn map_in_place_2<T, U, F: FnOnce(U, T) -> T>((k, v): (U, &mut T), f: F){\n    unsafe {\n        // # Safety\n        //\n        // If the closure panics, we must abort otherwise we could double drop `T`\n        let _promote_panic_to_abort = AbortOnPanic;\n\n        ptr::write(v, f(k, ptr::read(v)));\n    }\n}","Real(LocalPath(\"src/util.rs\"))"],"util::ptr_size_bits":["pub const fn ptr_size_bits() -> usize{\n    mem::size_of::<usize>() * 8\n}","Real(LocalPath(\"src/util.rs\"))"]},"struct_constructor":{"&[lock::RwLock<std::collections::HashMap<K, util::SharedValue<V>, S>>]":["shards"],"(&'a K, &'a V)":["get_key_value"],"(&K, &V)":["pair"],"(&K, &mut V)":["pair_mut"],"(K, V)":["_remove","_remove_if","remove","remove_entry","remove_if","replace_entry"],"<&'a DashMap<K, V, S> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a DashMap<K, V, S> as std::ops::BitAnd<&Q>>::Output":["bitand"],"<&'a DashMap<K, V, S> as std::ops::BitOr<&Q>>::Output":["bitor"],"<&'a DashMap<K, V, S> as std::ops::Shl<(K, V)>>::Output":["shl"],"<&'a DashMap<K, V, S> as std::ops::Shr<&Q>>::Output":["shr"],"<&'a DashMap<K, V, S> as std::ops::Sub<&Q>>::Output":["sub"],"<DashMap<K, V, S> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<iter::Iter<'a, K, V, S, M> as std::iter::Iterator>::Item":["next"],"<iter::IterMut<'a, K, V, S, M> as std::iter::Iterator>::Item":["next"],"<iter::OwningIter<K, V, S> as std::iter::Iterator>::Item":["next"],"<iter_set::Iter<'a, K, S, M> as std::iter::Iterator>::Item":["next"],"<iter_set::OwningIter<K, S> as std::iter::Iterator>::Item":["next"],"<set::DashSet<K, S> as std::iter::IntoIterator>::IntoIter":["into_iter"],"DashMap":["clone","default","from_iter","into_inner","new","with_capacity","with_capacity_and_hasher","with_hasher"],"bool":["_contains_key","_is_empty","contains","contains_key","insert","is_empty"],"impl std::iter::Iterator<Item = &'a K> + 'a":["keys"],"impl std::iter::Iterator<Item = &'a V> + 'a":["values"],"impl std::iter::Iterator<Item = &'a std::collections::HashMap<K, util::SharedValue<V>, S>> + 'a":["shard_read_iter"],"impl std::iter::Iterator<Item = (&'a K, &'a V)> + 'a":["iter"],"iter::Iter":["_iter","iter","new"],"iter::IterMut":["_iter_mut","iter_mut","new"],"iter::OwningIter":["new"],"iter_set::Iter":["iter","new"],"iter_set::OwningIter":["new"],"lock::RwLock":["default","new"],"lock::RwLockReadGuard":["_yield_read_shard","downgrade","read","try_read"],"lock::RwLockUpgradeableGuard":["try_upgradeable_read","upgradeable_read"],"lock::RwLockWriteGuard":["_yield_write_shard","try_upgrade","try_upgrade_internal","try_write","try_write_internal","upgrade","write"],"mapref::entry::Entry":["_entry","entry"],"mapref::entry::OccupiedEntry":["new"],"mapref::entry::VacantEntry":["new"],"mapref::multiple::RefMulti":["new"],"mapref::multiple::RefMutMulti":["new"],"mapref::one::Ref":["_get","downgrade","get","new"],"mapref::one::RefMut":["_get_mut","get_mut","insert","into_ref","new","or_default","or_insert","or_insert_with","or_try_insert_with"],"read_only::ReadOnlyView":["clone","into_read_only","new"],"set::DashSet":["clone","default","from_iter","new","with_capacity","with_capacity_and_hasher","with_hasher"],"setref::multiple::RefMulti":["new"],"setref::one::Ref":["get","new"],"usize":["_capacity","_len","_shard_count","capacity","hash_usize","len","ptr_size_bits","shard_amount"],"util::SharedValue":["clone","new"]},"struct_to_trait":{"DashMap":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","t::Map"],"iter::Iter":["std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iter::IterMut":["std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iter::OwningIter":["std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iter_set::Iter":["std::iter::Iterator","std::marker::Send","std::marker::Sync"],"iter_set::OwningIter":["std::iter::Iterator","std::marker::Send","std::marker::Sync"],"lock::RwLock":["std::default::Default","std::fmt::Debug","std::marker::Send","std::marker::Sync"],"lock::RwLockReadGuard":["std::fmt::Debug","std::marker::Send","std::marker::Sync","std::ops::Deref","std::ops::Drop"],"lock::RwLockUpgradeableGuard":["std::fmt::Debug","std::ops::Deref","std::ops::Drop"],"lock::RwLockWriteGuard":["std::fmt::Debug","std::marker::Send","std::marker::Sync","std::ops::Deref","std::ops::DerefMut","std::ops::Drop"],"mapref::entry::OccupiedEntry":["std::marker::Send","std::marker::Sync"],"mapref::entry::VacantEntry":["std::marker::Send","std::marker::Sync"],"mapref::multiple::RefMulti":["std::marker::Send","std::marker::Sync","std::ops::Deref"],"mapref::multiple::RefMutMulti":["std::marker::Send","std::marker::Sync","std::ops::Deref","std::ops::DerefMut"],"mapref::one::Ref":["std::marker::Send","std::marker::Sync","std::ops::Deref"],"mapref::one::RefMut":["std::marker::Send","std::marker::Sync","std::ops::Deref","std::ops::DerefMut"],"read_only::ReadOnlyView":["std::clone::Clone","std::fmt::Debug"],"set::DashSet":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator"],"setref::multiple::RefMulti":["std::ops::Deref"],"setref::one::Ref":["std::marker::Send","std::marker::Sync","std::ops::Deref"],"util::AbortOnPanic":["std::ops::Drop"],"util::SharedValue":["std::clone::Clone","std::marker::Send","std::marker::Sync"]},"targets":{"<&'a DashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<&'a DashMap<K, V, S> as std::ops::BitAnd<&Q>>::bitand":["bitand","Real(LocalPath(\"src/lib.rs\"))","std::ops::BitAnd"],"<&'a DashMap<K, V, S> as std::ops::BitOr<&Q>>::bitor":["bitor","Real(LocalPath(\"src/lib.rs\"))","std::ops::BitOr"],"<&'a DashMap<K, V, S> as std::ops::Shl<(K, V)>>::shl":["shl","Real(LocalPath(\"src/lib.rs\"))","std::ops::Shl"],"<&'a DashMap<K, V, S> as std::ops::Shr<&Q>>::shr":["shr","Real(LocalPath(\"src/lib.rs\"))","std::ops::Shr"],"<&'a DashMap<K, V, S> as std::ops::Sub<&Q>>::sub":["sub","Real(LocalPath(\"src/lib.rs\"))","std::ops::Sub"],"<DashMap<K, V, S> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","std::clone::Clone"],"<DashMap<K, V, S> as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<DashMap<K, V, S> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<DashMap<K, V, S> as std::iter::Extend<(K, V)>>::extend":["extend","Real(LocalPath(\"src/lib.rs\"))","std::iter::Extend"],"<DashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_alter":["_alter","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_alter_all":["_alter_all","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_capacity":["_capacity","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_entry":["_entry","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_get":["_get","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_get_mut":["_get_mut","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_get_read_shard":["_get_read_shard","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_hasher":["_hasher","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_insert":["_insert","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_iter":["_iter","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_iter_mut":["_iter_mut","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_len":["_len","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_remove":["_remove","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_remove_if":["_remove_if","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_retain":["_retain","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_shard_count":["_shard_count","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_shrink_to_fit":["_shrink_to_fit","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_yield_read_shard":["_yield_read_shard","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V, S> as t::Map<'a, K, V, S>>::_yield_write_shard":["_yield_write_shard","Real(LocalPath(\"src/lib.rs\"))","t::Map"],"<DashMap<K, V> as std::iter::FromIterator<(K, V)>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::FromIterator"],"<iter::Iter<'a, K, V, S, M> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::IterMut<'a, K, V, S, M> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter::OwningIter<K, V, S> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<iter_set::Iter<'a, K, S, M> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iter_set.rs\"))","std::iter::Iterator"],"<iter_set::OwningIter<K, S> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iter_set.rs\"))","std::iter::Iterator"],"<lock::RwLock<T> as std::default::Default>::default":["default","Real(LocalPath(\"src/lock.rs\"))","std::default::Default"],"<lock::RwLock<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lock.rs\"))","std::fmt::Debug"],"<lock::RwLockReadGuard<'rwlock, T> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/lock.rs\"))","std::ops::Deref"],"<lock::RwLockReadGuard<'rwlock, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lock.rs\"))","std::ops::Drop"],"<lock::RwLockUpgradeableGuard<'rwlock, T> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/lock.rs\"))","std::ops::Deref"],"<lock::RwLockUpgradeableGuard<'rwlock, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lock.rs\"))","std::ops::Drop"],"<lock::RwLockWriteGuard<'rwlock, T> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/lock.rs\"))","std::ops::Deref"],"<lock::RwLockWriteGuard<'rwlock, T> as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/lock.rs\"))","std::ops::DerefMut"],"<lock::RwLockWriteGuard<'rwlock, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lock.rs\"))","std::ops::Drop"],"<mapref::multiple::RefMulti<'a, K, V, S> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/mapref/multiple.rs\"))","std::ops::Deref"],"<mapref::multiple::RefMutMulti<'a, K, V, S> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/mapref/multiple.rs\"))","std::ops::Deref"],"<mapref::multiple::RefMutMulti<'a, K, V, S> as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/mapref/multiple.rs\"))","std::ops::DerefMut"],"<mapref::one::Ref<'a, K, V, S> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/mapref/one.rs\"))","std::ops::Deref"],"<mapref::one::RefMut<'a, K, V, S> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/mapref/one.rs\"))","std::ops::Deref"],"<mapref::one::RefMut<'a, K, V, S> as std::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/mapref/one.rs\"))","std::ops::DerefMut"],"<read_only::ReadOnlyView<K, V, S> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/read_only.rs\"))","std::clone::Clone"],"<read_only::ReadOnlyView<K, V, S> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/read_only.rs\"))","std::fmt::Debug"],"<set::DashSet<K, S> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/set.rs\"))","std::clone::Clone"],"<set::DashSet<K, S> as std::clone::Clone>::clone_from":["clone_from","Real(LocalPath(\"src/set.rs\"))","std::clone::Clone"],"<set::DashSet<K, S> as std::default::Default>::default":["default","Real(LocalPath(\"src/set.rs\"))","std::default::Default"],"<set::DashSet<K, S> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/set.rs\"))","std::fmt::Debug"],"<set::DashSet<K, S> as std::iter::Extend<K>>::extend":["extend","Real(LocalPath(\"src/set.rs\"))","std::iter::Extend"],"<set::DashSet<K, S> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/set.rs\"))","std::iter::IntoIterator"],"<set::DashSet<K> as std::iter::FromIterator<K>>::from_iter":["from_iter","Real(LocalPath(\"src/set.rs\"))","std::iter::FromIterator"],"<setref::multiple::RefMulti<'a, K, S> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/setref/multiple.rs\"))","std::ops::Deref"],"<setref::one::Ref<'a, K, S> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/setref/one.rs\"))","std::ops::Deref"],"<util::AbortOnPanic as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/util.rs\"))","std::ops::Drop"],"<util::SharedValue<T> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/util.rs\"))","std::clone::Clone"],"DashMap::<K, V, S>::alter":["alter","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::alter_all":["alter_all","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::capacity":["capacity","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::clear":["clear","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::contains_key":["contains_key","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::determine_shard":["determine_shard","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::entry":["entry","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::get":["get","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::get_mut":["get_mut","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::hash_usize":["hash_usize","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::hasher":["hasher","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::insert":["insert","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::into_read_only":["into_read_only","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::is_empty":["is_empty","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::iter":["iter","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::iter_mut":["iter_mut","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::len":["len","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::remove":["remove","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::remove_if":["remove_if","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::retain":["retain","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::shards":["shards","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::shrink_to_fit":["shrink_to_fit","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::with_capacity_and_hasher":["with_capacity_and_hasher","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V, S>::with_hasher":["with_hasher","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"DashMap::<K, V>::with_capacity":["with_capacity","Real(LocalPath(\"src/lib.rs\"))",""],"iter::Iter::<'a, K, V, S, M>::new":["new","Real(LocalPath(\"src/iter.rs\"))",""],"iter::IterMut::<'a, K, V, S, M>::new":["new","Real(LocalPath(\"src/iter.rs\"))",""],"iter::OwningIter::<K, V, S>::new":["new","Real(LocalPath(\"src/iter.rs\"))",""],"iter_set::Iter::<'a, K, S, M>::new":["new","Real(LocalPath(\"src/iter_set.rs\"))",""],"iter_set::OwningIter::<K, S>::new":["new","Real(LocalPath(\"src/iter_set.rs\"))",""],"lock::RwLock::<T>::force_read_decrement":["force_read_decrement","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::force_write_unlock":["force_write_unlock","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::get":["get","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::get_mut":["get_mut","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::into_inner":["into_inner","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::new":["new","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::read":["read","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::try_read":["try_read","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::try_upgradeable_read":["try_upgradeable_read","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::try_write":["try_write","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::try_write_internal":["try_write_internal","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::upgradeable_read":["upgradeable_read","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLock::<T>::write":["write","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLockUpgradeableGuard::<'rwlock, T>::downgrade":["downgrade","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLockUpgradeableGuard::<'rwlock, T>::try_upgrade":["try_upgrade","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLockUpgradeableGuard::<'rwlock, T>::try_upgrade_internal":["try_upgrade_internal","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLockUpgradeableGuard::<'rwlock, T>::upgrade":["upgrade","Real(LocalPath(\"src/lock.rs\"))",""],"lock::RwLockWriteGuard::<'rwlock, T>::downgrade":["downgrade","Real(LocalPath(\"src/lock.rs\"))",""],"lock::compare_exchange":["compare_exchange","Real(LocalPath(\"src/lock.rs\"))",""],"mapref::entry::Entry::<'a, K, V, S>::and_modify":["and_modify","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::Entry::<'a, K, V, S>::into_key":["into_key","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::Entry::<'a, K, V, S>::key":["key","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::Entry::<'a, K, V, S>::or_default":["or_default","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::Entry::<'a, K, V, S>::or_insert":["or_insert","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::Entry::<'a, K, V, S>::or_insert_with":["or_insert_with","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::Entry::<'a, K, V, S>::or_try_insert_with":["or_try_insert_with","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::OccupiedEntry::<'a, K, V, S>::get":["get","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::OccupiedEntry::<'a, K, V, S>::get_mut":["get_mut","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::OccupiedEntry::<'a, K, V, S>::insert":["insert","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::OccupiedEntry::<'a, K, V, S>::into_key":["into_key","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::OccupiedEntry::<'a, K, V, S>::into_ref":["into_ref","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::OccupiedEntry::<'a, K, V, S>::key":["key","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::OccupiedEntry::<'a, K, V, S>::new":["new","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::OccupiedEntry::<'a, K, V, S>::remove":["remove","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::OccupiedEntry::<'a, K, V, S>::remove_entry":["remove_entry","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::OccupiedEntry::<'a, K, V, S>::replace_entry":["replace_entry","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::VacantEntry::<'a, K, V, S>::insert":["insert","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::VacantEntry::<'a, K, V, S>::into_key":["into_key","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::VacantEntry::<'a, K, V, S>::key":["key","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::entry::VacantEntry::<'a, K, V, S>::new":["new","Real(LocalPath(\"src/mapref/entry.rs\"))",""],"mapref::multiple::RefMulti::<'a, K, V, S>::key":["key","Real(LocalPath(\"src/mapref/multiple.rs\"))",""],"mapref::multiple::RefMulti::<'a, K, V, S>::new":["new","Real(LocalPath(\"src/mapref/multiple.rs\"))",""],"mapref::multiple::RefMulti::<'a, K, V, S>::pair":["pair","Real(LocalPath(\"src/mapref/multiple.rs\"))",""],"mapref::multiple::RefMulti::<'a, K, V, S>::value":["value","Real(LocalPath(\"src/mapref/multiple.rs\"))",""],"mapref::multiple::RefMutMulti::<'a, K, V, S>::key":["key","Real(LocalPath(\"src/mapref/multiple.rs\"))",""],"mapref::multiple::RefMutMulti::<'a, K, V, S>::new":["new","Real(LocalPath(\"src/mapref/multiple.rs\"))",""],"mapref::multiple::RefMutMulti::<'a, K, V, S>::pair":["pair","Real(LocalPath(\"src/mapref/multiple.rs\"))",""],"mapref::multiple::RefMutMulti::<'a, K, V, S>::pair_mut":["pair_mut","Real(LocalPath(\"src/mapref/multiple.rs\"))",""],"mapref::multiple::RefMutMulti::<'a, K, V, S>::value":["value","Real(LocalPath(\"src/mapref/multiple.rs\"))",""],"mapref::multiple::RefMutMulti::<'a, K, V, S>::value_mut":["value_mut","Real(LocalPath(\"src/mapref/multiple.rs\"))",""],"mapref::one::Ref::<'a, K, V, S>::key":["key","Real(LocalPath(\"src/mapref/one.rs\"))",""],"mapref::one::Ref::<'a, K, V, S>::new":["new","Real(LocalPath(\"src/mapref/one.rs\"))",""],"mapref::one::Ref::<'a, K, V, S>::pair":["pair","Real(LocalPath(\"src/mapref/one.rs\"))",""],"mapref::one::Ref::<'a, K, V, S>::value":["value","Real(LocalPath(\"src/mapref/one.rs\"))",""],"mapref::one::RefMut::<'a, K, V, S>::downgrade":["downgrade","Real(LocalPath(\"src/mapref/one.rs\"))",""],"mapref::one::RefMut::<'a, K, V, S>::key":["key","Real(LocalPath(\"src/mapref/one.rs\"))",""],"mapref::one::RefMut::<'a, K, V, S>::new":["new","Real(LocalPath(\"src/mapref/one.rs\"))",""],"mapref::one::RefMut::<'a, K, V, S>::pair":["pair","Real(LocalPath(\"src/mapref/one.rs\"))",""],"mapref::one::RefMut::<'a, K, V, S>::pair_mut":["pair_mut","Real(LocalPath(\"src/mapref/one.rs\"))",""],"mapref::one::RefMut::<'a, K, V, S>::value":["value","Real(LocalPath(\"src/mapref/one.rs\"))",""],"mapref::one::RefMut::<'a, K, V, S>::value_mut":["value_mut","Real(LocalPath(\"src/mapref/one.rs\"))",""],"ncb":["ncb","Real(LocalPath(\"src/lib.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::capacity":["capacity","Real(LocalPath(\"src/read_only.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::contains_key":["contains_key","Real(LocalPath(\"src/read_only.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::get":["get","Real(LocalPath(\"src/read_only.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::get_key_value":["get_key_value","Real(LocalPath(\"src/read_only.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::into_inner":["into_inner","Real(LocalPath(\"src/read_only.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::is_empty":["is_empty","Real(LocalPath(\"src/read_only.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::iter":["iter","Real(LocalPath(\"src/read_only.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::keys":["keys","Real(LocalPath(\"src/read_only.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::len":["len","Real(LocalPath(\"src/read_only.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::new":["new","Real(LocalPath(\"src/read_only.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::shard_read_iter":["shard_read_iter","Real(LocalPath(\"src/read_only.rs\"))",""],"read_only::ReadOnlyView::<K, V, S>::values":["values","Real(LocalPath(\"src/read_only.rs\"))",""],"set::DashSet::<K, S>::capacity":["capacity","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::clear":["clear","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::contains":["contains","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::get":["get","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::hash_usize":["hash_usize","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::insert":["insert","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::is_empty":["is_empty","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::iter":["iter","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::len":["len","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::remove":["remove","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::remove_if":["remove_if","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::retain":["retain","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::shrink_to_fit":["shrink_to_fit","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::with_capacity_and_hasher":["with_capacity_and_hasher","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K, S>::with_hasher":["with_hasher","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K>::new":["new","Real(LocalPath(\"src/set.rs\"))",""],"set::DashSet::<K>::with_capacity":["with_capacity","Real(LocalPath(\"src/set.rs\"))",""],"setref::multiple::RefMulti::<'a, K, S>::key":["key","Real(LocalPath(\"src/setref/multiple.rs\"))",""],"setref::multiple::RefMulti::<'a, K, S>::new":["new","Real(LocalPath(\"src/setref/multiple.rs\"))",""],"setref::one::Ref::<'a, K, S>::key":["key","Real(LocalPath(\"src/setref/one.rs\"))",""],"setref::one::Ref::<'a, K, S>::new":["new","Real(LocalPath(\"src/setref/one.rs\"))",""],"shard_amount":["shard_amount","Real(LocalPath(\"src/lib.rs\"))",""],"t::Map::_clear":["_clear","Real(LocalPath(\"src/t.rs\"))",""],"t::Map::_contains_key":["_contains_key","Real(LocalPath(\"src/t.rs\"))",""],"t::Map::_is_empty":["_is_empty","Real(LocalPath(\"src/t.rs\"))",""],"util::SharedValue::<T>::as_ptr":["as_ptr","Real(LocalPath(\"src/util.rs\"))",""],"util::SharedValue::<T>::get":["get","Real(LocalPath(\"src/util.rs\"))",""],"util::SharedValue::<T>::get_mut":["get_mut","Real(LocalPath(\"src/util.rs\"))",""],"util::SharedValue::<T>::into_inner":["into_inner","Real(LocalPath(\"src/util.rs\"))",""],"util::SharedValue::<T>::new":["new","Real(LocalPath(\"src/util.rs\"))",""],"util::change_lifetime_const":["change_lifetime_const","Real(LocalPath(\"src/util.rs\"))",""],"util::change_lifetime_mut":["change_lifetime_mut","Real(LocalPath(\"src/util.rs\"))",""],"util::map_in_place_2":["map_in_place_2","Real(LocalPath(\"src/util.rs\"))",""],"util::ptr_size_bits":["ptr_size_bits","Real(LocalPath(\"src/util.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["DashMap","read_only::ReadOnlyView","set::DashSet","util::SharedValue"],"std::default::Default":["DashMap","lock::RwLock","set::DashSet"],"std::fmt::Debug":["DashMap","lock::RwLock","lock::RwLockReadGuard","lock::RwLockUpgradeableGuard","lock::RwLockWriteGuard","read_only::ReadOnlyView","set::DashSet"],"std::iter::Extend":["DashMap","set::DashSet"],"std::iter::FromIterator":["DashMap","set::DashSet"],"std::iter::IntoIterator":["DashMap","set::DashSet"],"std::iter::Iterator":["iter::Iter","iter::IterMut","iter::OwningIter","iter_set::Iter","iter_set::OwningIter"],"std::marker::Send":["iter::Iter","iter::IterMut","iter::OwningIter","iter_set::Iter","iter_set::OwningIter","lock::RwLock","lock::RwLockReadGuard","lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","mapref::multiple::RefMulti","mapref::multiple::RefMutMulti","mapref::one::Ref","mapref::one::RefMut","setref::one::Ref","util::SharedValue"],"std::marker::Sync":["iter::Iter","iter::IterMut","iter::OwningIter","iter_set::Iter","iter_set::OwningIter","lock::RwLock","lock::RwLockReadGuard","lock::RwLockWriteGuard","mapref::entry::OccupiedEntry","mapref::entry::VacantEntry","mapref::multiple::RefMulti","mapref::multiple::RefMutMulti","mapref::one::Ref","mapref::one::RefMut","setref::one::Ref","util::SharedValue"],"std::ops::Deref":["lock::RwLockReadGuard","lock::RwLockUpgradeableGuard","lock::RwLockWriteGuard","mapref::multiple::RefMulti","mapref::multiple::RefMutMulti","mapref::one::Ref","mapref::one::RefMut","setref::multiple::RefMulti","setref::one::Ref"],"std::ops::DerefMut":["lock::RwLockWriteGuard","mapref::multiple::RefMutMulti","mapref::one::RefMut"],"std::ops::Drop":["lock::RwLockReadGuard","lock::RwLockUpgradeableGuard","lock::RwLockWriteGuard","util::AbortOnPanic"],"t::Map":["DashMap"]},"type_to_def_path":{"DashMap<K, V, S>":"DashMap","iter::Iter<'a, K, V, S, M>":"iter::Iter","iter::IterMut<'a, K, V, S, M>":"iter::IterMut","iter::OwningIter<K, V, S>":"iter::OwningIter","iter_set::Iter<'a, K, S, M>":"iter_set::Iter","iter_set::OwningIter<K, S>":"iter_set::OwningIter","lock::RwLock<T>":"lock::RwLock","lock::RwLockReadGuard<'a, T>":"lock::RwLockReadGuard","lock::RwLockUpgradeableGuard<'a, T>":"lock::RwLockUpgradeableGuard","lock::RwLockWriteGuard<'a, T>":"lock::RwLockWriteGuard","mapref::entry::Entry<'a, K, V, S>":"mapref::entry::Entry","mapref::entry::OccupiedEntry<'a, K, V, S>":"mapref::entry::OccupiedEntry","mapref::entry::VacantEntry<'a, K, V, S>":"mapref::entry::VacantEntry","mapref::multiple::RefMulti<'a, K, V, S>":"mapref::multiple::RefMulti","mapref::multiple::RefMutMulti<'a, K, V, S>":"mapref::multiple::RefMutMulti","mapref::one::Ref<'a, K, V, S>":"mapref::one::Ref","mapref::one::RefMut<'a, K, V, S>":"mapref::one::RefMut","read_only::ReadOnlyView<K, V, S>":"read_only::ReadOnlyView","set::DashSet<K, S>":"set::DashSet","setref::multiple::RefMulti<'a, K, S>":"setref::multiple::RefMulti","setref::one::Ref<'a, K, S>":"setref::one::Ref","util::AbortOnPanic":"util::AbortOnPanic","util::SharedValue<T>":"util::SharedValue"}}