{"dependencies":{"<error::HcidError as std::clone::Clone>::clone":["error::HcidError","std::string::String"],"<error::HcidError as std::cmp::PartialEq>::eq":["error::HcidError","std::string::String"],"<error::HcidError as std::convert::From<&'a str>>::from":["error::HcidError","std::string::String"],"<error::HcidError as std::convert::From<reed_solomon::DecoderError>>::from":["error::HcidError","reed_solomon::DecoderError","std::string::String"],"<error::HcidError as std::convert::From<std::num::ParseIntError>>::from":["error::HcidError","std::num::ParseIntError","std::string::String"],"<error::HcidError as std::convert::From<std::string::String>>::from":["error::HcidError","std::string::String"],"<error::HcidError as std::error::Error>::cause":["error::HcidError","std::marker::Sized","std::option::Option","std::string::String"],"<error::HcidError as std::error::Error>::description":["error::HcidError","std::string::String"],"<error::HcidError as std::fmt::Debug>::fmt":["error::HcidError","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<error::HcidError as std::fmt::Display>::fmt":["error::HcidError","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"HcidEncoding":["HcidEncoding","HcidEncodingConfig","reed_solomon::Decoder","reed_solomon::Encoder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"HcidEncoding::decode":["HcidEncoding","HcidEncodingConfig","reed_solomon::Decoder","reed_solomon::Encoder","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"HcidEncoding::encode":["HcidEncoding","HcidEncodingConfig","reed_solomon::Decoder","reed_solomon::Encoder","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"HcidEncoding::is_corrupt":["HcidEncoding","HcidEncodingConfig","reed_solomon::Decoder","reed_solomon::Encoder","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"HcidEncoding::new":["HcidEncodingConfig","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"HcidEncoding::pre_decode":["HcidEncoding","HcidEncodingConfig","reed_solomon::Decoder","reed_solomon::Encoder","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"HcidEncoding::pre_is_corrupt":["HcidEncoding","HcidEncodingConfig","reed_solomon::Decoder","reed_solomon::Encoder","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"HcidEncoding::with_kind":["std::marker::Sized","std::result::Result"],"HcidEncodingConfig":["HcidEncodingConfig","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"HcidEncodingConfig::new":["std::marker::Sized","std::result::Result"],"b32::decode":["std::marker::Sized","std::result::Result"],"b32::encode":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"error::HcidError":["error::HcidError","std::string::String"],"util::b32_correct":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"util::cap_decode":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"util::cap_encode_bin":["std::marker::Sized","std::result::Result"],"util::char_lower":[],"util::char_upper":[]},"glob_path_import":{},"self_to_fn":{"HcidEncoding":["impl HcidEncoding {\n    /// create a new HcidEncoding instance from given HcidEncodingConfig\n    pub fn new(config: HcidEncodingConfig) -> HcidResult<Self> {\n        // set up a reed-solomon encoder with proper parity count\n        let rs_enc = reed_solomon::Encoder::new(\n            config.base_parity_byte_count + config.cap_parity_byte_count,\n        );\n\n        // set up a reed-solomon decoder with proper parity count\n        let rs_dec = reed_solomon::Decoder::new(\n            config.base_parity_byte_count + config.cap_parity_byte_count,\n        );\n\n        Ok(Self {\n            config,\n            rs_enc,\n            rs_dec,\n        })\n    }\n\n    /// create a new config given a kind token string\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// extern crate hcid;\n    /// let hca0 = hcid::HcidEncoding::with_kind(\"hca0\").unwrap();\n    /// let hck0 = hcid::HcidEncoding::with_kind(\"hck0\").unwrap();\n    /// let hcs0 = hcid::HcidEncoding::with_kind(\"hcs0\").unwrap();\n    /// ```\n    pub fn with_kind(kind: &str) -> HcidResult<Self> {\n        HcidEncoding::new(HcidEncodingConfig::new(kind)?)\n    }\n\n    /// encode a string to base32 with this instance's configuration\n    pub fn encode(&self, data: &[u8]) -> HcidResult<String> {\n        if data.len() != self.config.key_byte_count {\n            return Err(HcidError(String::from(format!(\n                \"BadDataLen:{},Expected:{}\",\n                data.len(),\n                self.config.key_byte_count\n            ))));\n        }\n\n        // generate reed-solomon parity bytes\n        let full_parity = self.rs_enc.encode(data);\n\n        // extract the bytes that will be encoded as capitalization\n        let cap_bytes = &full_parity[full_parity.len() - self.config.cap_parity_byte_count..];\n\n        // base is the bytes that will be base32 encoded\n        let mut base = self.config.prefix.clone();\n        base.extend_from_slice(\n            &full_parity[0..full_parity.len() - self.config.cap_parity_byte_count],\n        );\n\n        // do the base32 encoding\n        let mut base32 = b32::encode(&base);\n\n        if base32.len() != self.config.encoded_char_count {\n            return Err(HcidError(String::from(format!(\n                \"InternalGeneratedBadLen:{},Expected:{}\",\n                base32.len(),\n                self.config.encoded_char_count\n            ))));\n        }\n\n        // capitalize the prefix with a fixed scheme\n        cap_encode_bin(\n            &mut base32[0..self.config.prefix_cap.len()],\n            &self.config.prefix_cap,\n            3,\n        )?;\n\n        // iterate over segments, applying parity capitalization\n        for i in 0..cap_bytes.len() {\n            let seg_start = self.config.prefix_cap.len() + (i * self.config.cap_segment_char_count);\n            let seg = &mut base32[seg_start..seg_start + self.config.cap_segment_char_count];\n            let bin = format!(\"{:08b}\", cap_bytes[i]).into_bytes();\n            cap_encode_bin(seg, &bin, 8)?;\n        }\n        \n        // we only use ascii characters\n        // use unchecked for performance / so we don't allocate again\n        unsafe {\n            // return the result as a String for ease of use\n            Ok(String::from_utf8_unchecked(base32))\n        }\n    }\n\n    /// decode the data from a base32 string with this instance's configuration.  Reed-Solomon can\n    /// correct up to 1/2 its parity size worth of erasures (if no other errors are present).\n    pub fn decode(&self, data: &str) -> HcidResult<Vec<u8>> {\n        // get our parsed data with erasures\n        let (data, erasures) = self.pre_decode(data)?;\n\n        if erasures.len() > ( self.config.base_parity_byte_count + self.config.cap_parity_byte_count ) / 2 {\n            // our reed-solomon library makes bad corrections once erasure count exceeds 1/2 the\n            // parity count (it takes 2 parity symbols to find/correct one error, 1 parity symbol to\n            // correct a known erasure)\n            return Err(HcidError(String::from(\"TooManyErrors\")));\n        }\n\n        // optimise for the case where there are no transcription errors\n        // this makes correcting more expensive if there *are*,\n        // but on average makes the system more efficient\n        if self.pre_is_corrupt(&data, &erasures)? {\n            // apply reed-solomon correction\n            // will \"throw\" on too many errors\n            Ok(\n                self.rs_dec.correct(&data, Some(&erasures[..]))?[0..self.config.key_byte_count]\n                    .to_vec(),\n            )\n        } else {\n            Ok(data[0..self.config.key_byte_count].to_vec())\n        }\n    }\n\n    /// a lighter-weight check to determine if a base32 string is corrupt\n    pub fn is_corrupt(&self, data: &str) -> HcidResult<bool> {\n        // get our parsed data with erasures\n        let (data, erasures) = match self.pre_decode(data) {\n            Ok(v) => v,\n            Err(_) => return Ok(true),\n        };\n\n        match self.pre_is_corrupt(&data, &erasures) {\n            Ok(v) => Ok(v),\n            Err(_) => Ok(true),\n        }\n    }\n\n    /// internal helper for is_corrupt checking\n    fn pre_is_corrupt(&self, data: &[u8], erasures: &[u8]) -> HcidResult<bool> {\n        // if we have any erasures, we can exit early\n        if erasures.len() > 0 {\n            return Ok(true);\n        }\n\n        // slightly more efficient reed-solomon corruption check\n        Ok(self.rs_dec.is_corrupted(&data))\n    }\n\n    /// internal helper for preparing decoding\n    fn pre_decode(&self, data: &str) -> HcidResult<(Vec<u8>, Vec<u8>)> {\n        if data.len() != self.config.encoded_char_count {\n            return Err(HcidError(String::from(format!(\n                \"BadIdLen:{},Expected:{}\",\n                data.len(),\n                self.config.encoded_char_count\n            ))));\n        }\n\n        let key_base_byte_size = self.config.key_byte_count + self.config.base_parity_byte_count;\n        // All char_erasures are indexed from the 0th char of the full codeword w/ prefix, but\n        // byte_erasures are indexed from the 0th byte of the key+parity (ie. without the prefix).\n        // Any byte of key, or base/cap parity could be erased.\n        let mut byte_erasures = vec![b'0'; key_base_byte_size + self.config.cap_parity_byte_count];\n        let mut char_erasures = vec![b'0'; data.len()];\n\n        // correct any transliteration errors into our base32 alphabet\n        // marking any unrecognizable characters as char-level erasures\n        let mut data = b32_correct(data.as_bytes(), &mut char_erasures);\n\n        // Pull out the parity data that was encoded as capitalization.  If its erasure,\n        // determine the \n        let mut cap_bytes: Vec<u8> = Vec::new();\n        let mut all_zro = true;\n        let mut all_one = true;\n        for i in 0..self.config.cap_parity_byte_count {\n            // For cap. parity, indexing starts after pre-defined Base-32 prefix\n            let char_idx = self.config.prefix_cap.len() + (i * self.config.cap_segment_char_count);\n            match cap_decode(\n                char_idx,\n                &data[char_idx..char_idx + self.config.cap_segment_char_count],\n                &char_erasures\n            )? {\n                None => {\n                    byte_erasures[key_base_byte_size + i] = b'1';\n                    cap_bytes.push(0)\n                }\n                Some(parity) => {\n                    if all_zro && parity != 0x00_u8 {\n                        all_zro = false\n                    }\n                    if all_one && parity != 0xFF_u8 {\n                        all_one = false\n                    }\n                    cap_bytes.push(parity)\n                }\n            }\n        }\n\n        // If either all caps or all lower case (or erasure), assume the casing was lost (eg. QR\n        // code, or dns segment); mark all cap-derived parity as erasures.  This allows validation\n        // of codeword if all remaining parity is intact and key is correct; since no parity\n        // capacity remains, no correction will be attempted.  There is only a low probability that\n        // any remaining errors will be detected, in this case.  However, we're no *worse* off than\n        // if we had no R-S parity at all.\n        if all_zro || all_one {\n            for i in 0..self.config.cap_parity_byte_count {\n                byte_erasures[key_base_byte_size + i] = b'1';\n            }\n        }\n\n        // we have the cap data, uppercase everything\n        for c in data.iter_mut() {\n            char_upper(c);\n        }\n\n        // do the base32 decode\n        let mut data = b32::decode(&data)?;\n\n        if &data[0..self.config.prefix.len()] != self.config.prefix.as_slice() {\n            return Err(HcidError(String::from(\"PrefixMismatch\")));\n        }\n\n        // remove the prefix bytes\n        data.drain(0..self.config.prefix.len());\n\n        // append our cap parity bytes\n        data.append(&mut cap_bytes);\n\n        // Sort through the char-level erasures (5 bits), and associate them with byte-level data (8\n        // bits) -- in the (now prefix-free) data buffer, so that we mark the proper erasures for\n        // reed-solomon correction.  Some of these chars span multiple bytes... we need to mark both.\n        for i in self.config.prefix_cap.len()..char_erasures.len() {\n            let c = char_erasures[i];\n            if c == b'1' {\n                // 1st and last bit of 5-bit segment may index different bytes\n                byte_erasures[( i * 5 + 0 ) / 8 - self.config.prefix.len()] = b'1';\n                byte_erasures[( i * 5 + 4 ) / 8 - self.config.prefix.len()] = b'1';\n            }\n        }\n\n        // translate erasures into the form expected by our reed-solomon lib\n        let mut erasures: Vec<u8> = Vec::new();\n        for i in 0..byte_erasures.len() {\n            if byte_erasures[i] == b'1' {\n                data[i] = 0;\n                erasures.push(i as u8);\n            }\n        }\n\n        Ok((data, erasures))\n    }\n}"],"HcidEncodingConfig":["impl HcidEncodingConfig {\n    /// create a new config given a kind token string\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// extern crate hcid;\n    /// let hca0 = hcid::HcidEncodingConfig::new(\"hca0\").unwrap();\n    /// let hck0 = hcid::HcidEncodingConfig::new(\"hck0\").unwrap();\n    /// let hcs0 = hcid::HcidEncodingConfig::new(\"hcs0\").unwrap();\n    /// ```\n    pub fn new(kind: &str) -> HcidResult<Self> {\n        let kind_b = kind.as_bytes();\n        if kind_b.len() != 4 || kind_b[0] != 104 || kind_b[1] != 99 ||\n                (kind_b[3] != 48 && kind_b[3] != 49) ||\n                kind_b[2] < 51 || kind_b[2] > 122 {\n            return Err(format!(\"invalid kind: `{}`\", kind).into());\n        }\n\n        let version = if kind_b[3] == 48 { 0 } else { 1 };\n        let res = HC_CODE_MAP[(kind_b[2] - 51) as usize][version as usize];\n\n        if res == 0xff {\n            return Err(format!(\"invalid kind: `{}`\", kind).into());\n        }\n\n        Ok(HcidEncodingConfig {\n            key_byte_count: 32,\n            base_parity_byte_count: 4,\n            cap_parity_byte_count: 4,\n            prefix: vec![0x38, res, 0x24],\n            prefix_cap: b\"101\".to_vec(),\n            cap_segment_char_count: 15,\n            encoded_char_count: 63,\n        })\n    }\n}"],"error::HcidError":["Clone","Debug","PartialEq","impl From<String> for HcidError {\n    fn from(error: String) -> Self {\n        Self(error)\n    }\n}","impl From<reed_solomon::DecoderError> for HcidError {\n    fn from(error: reed_solomon::DecoderError) -> Self {\n        Self(format!(\"{:?}\", error))\n    }\n}","impl From<std::num::ParseIntError> for HcidError {\n    fn from(error: std::num::ParseIntError) -> Self {\n        Self(format!(\"{:?}\", error))\n    }\n}","impl std::error::Error for HcidError {\n    fn description(&self) -> &str {\n        &self.0\n    }\n    fn cause(&self) -> Option<&std::error::Error> {\n        None\n    }\n}","impl std::fmt::Display for HcidError {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}","impl<'a> From<&'a str> for HcidError {\n    fn from(error: &'a str) -> Self {\n        Self(error.to_string())\n    }\n}"]},"single_path_import":{"error::HcidError":"HcidError","error::HcidResult":"HcidResult"},"srcs":{"<error::HcidError as std::convert::From<&'a str>>::from":["fn from(error: &'a str) -> Self{\n        Self(error.to_string())\n    }","Real(LocalPath(\"hcid/src/error.rs\"))"],"<error::HcidError as std::convert::From<reed_solomon::DecoderError>>::from":["fn from(error: reed_solomon::DecoderError) -> Self{\n        Self(format!(\"{:?}\", error))\n    }","Real(LocalPath(\"hcid/src/error.rs\"))"],"<error::HcidError as std::convert::From<std::num::ParseIntError>>::from":["fn from(error: std::num::ParseIntError) -> Self{\n        Self(format!(\"{:?}\", error))\n    }","Real(LocalPath(\"hcid/src/error.rs\"))"],"<error::HcidError as std::convert::From<std::string::String>>::from":["fn from(error: String) -> Self{\n        Self(error)\n    }","Real(LocalPath(\"hcid/src/error.rs\"))"],"<error::HcidError as std::error::Error>::cause":["fn cause(&self) -> Option<&std::error::Error>{\n        None\n    }","Real(LocalPath(\"hcid/src/error.rs\"))"],"<error::HcidError as std::error::Error>::description":["fn description(&self) -> &str{\n        &self.0\n    }","Real(LocalPath(\"hcid/src/error.rs\"))"],"<error::HcidError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        write!(f, \"{:?}\", self)\n    }","Real(LocalPath(\"hcid/src/error.rs\"))"],"HcidEncoding":["/// an instance that can encode / decode a particular hcid encoding configuration\npub struct HcidEncoding {\n    config: HcidEncodingConfig,\n    rs_enc: reed_solomon::Encoder,\n    rs_dec: reed_solomon::Decoder,\n}","Real(LocalPath(\"hcid/src/lib.rs\"))"],"HcidEncoding::decode":["/// decode the data from a base32 string with this instance's configuration.  Reed-Solomon can\n/// correct up to 1/2 its parity size worth of erasures (if no other errors are present).\npub fn decode(&self, data: &str) -> HcidResult<Vec<u8>>{\n        // get our parsed data with erasures\n        let (data, erasures) = self.pre_decode(data)?;\n\n        if erasures.len() > ( self.config.base_parity_byte_count + self.config.cap_parity_byte_count ) / 2 {\n            // our reed-solomon library makes bad corrections once erasure count exceeds 1/2 the\n            // parity count (it takes 2 parity symbols to find/correct one error, 1 parity symbol to\n            // correct a known erasure)\n            return Err(HcidError(String::from(\"TooManyErrors\")));\n        }\n\n        // optimise for the case where there are no transcription errors\n        // this makes correcting more expensive if there *are*,\n        // but on average makes the system more efficient\n        if self.pre_is_corrupt(&data, &erasures)? {\n            // apply reed-solomon correction\n            // will \"throw\" on too many errors\n            Ok(\n                self.rs_dec.correct(&data, Some(&erasures[..]))?[0..self.config.key_byte_count]\n                    .to_vec(),\n            )\n        } else {\n            Ok(data[0..self.config.key_byte_count].to_vec())\n        }\n    }","Real(LocalPath(\"hcid/src/lib.rs\"))"],"HcidEncoding::encode":["/// encode a string to base32 with this instance's configuration\npub fn encode(&self, data: &[u8]) -> HcidResult<String>{\n        if data.len() != self.config.key_byte_count {\n            return Err(HcidError(String::from(format!(\n                \"BadDataLen:{},Expected:{}\",\n                data.len(),\n                self.config.key_byte_count\n            ))));\n        }\n\n        // generate reed-solomon parity bytes\n        let full_parity = self.rs_enc.encode(data);\n\n        // extract the bytes that will be encoded as capitalization\n        let cap_bytes = &full_parity[full_parity.len() - self.config.cap_parity_byte_count..];\n\n        // base is the bytes that will be base32 encoded\n        let mut base = self.config.prefix.clone();\n        base.extend_from_slice(\n            &full_parity[0..full_parity.len() - self.config.cap_parity_byte_count],\n        );\n\n        // do the base32 encoding\n        let mut base32 = b32::encode(&base);\n\n        if base32.len() != self.config.encoded_char_count {\n            return Err(HcidError(String::from(format!(\n                \"InternalGeneratedBadLen:{},Expected:{}\",\n                base32.len(),\n                self.config.encoded_char_count\n            ))));\n        }\n\n        // capitalize the prefix with a fixed scheme\n        cap_encode_bin(\n            &mut base32[0..self.config.prefix_cap.len()],\n            &self.config.prefix_cap,\n            3,\n        )?;\n\n        // iterate over segments, applying parity capitalization\n        for i in 0..cap_bytes.len() {\n            let seg_start = self.config.prefix_cap.len() + (i * self.config.cap_segment_char_count);\n            let seg = &mut base32[seg_start..seg_start + self.config.cap_segment_char_count];\n            let bin = format!(\"{:08b}\", cap_bytes[i]).into_bytes();\n            cap_encode_bin(seg, &bin, 8)?;\n        }\n        \n        // we only use ascii characters\n        // use unchecked for performance / so we don't allocate again\n        unsafe {\n            // return the result as a String for ease of use\n            Ok(String::from_utf8_unchecked(base32))\n        }\n    }","Real(LocalPath(\"hcid/src/lib.rs\"))"],"HcidEncoding::is_corrupt":["/// a lighter-weight check to determine if a base32 string is corrupt\npub fn is_corrupt(&self, data: &str) -> HcidResult<bool>{\n        // get our parsed data with erasures\n        let (data, erasures) = match self.pre_decode(data) {\n            Ok(v) => v,\n            Err(_) => return Ok(true),\n        };\n\n        match self.pre_is_corrupt(&data, &erasures) {\n            Ok(v) => Ok(v),\n            Err(_) => Ok(true),\n        }\n    }","Real(LocalPath(\"hcid/src/lib.rs\"))"],"HcidEncoding::new":["/// create a new HcidEncoding instance from given HcidEncodingConfig\npub fn new(config: HcidEncodingConfig) -> HcidResult<Self>{\n        // set up a reed-solomon encoder with proper parity count\n        let rs_enc = reed_solomon::Encoder::new(\n            config.base_parity_byte_count + config.cap_parity_byte_count,\n        );\n\n        // set up a reed-solomon decoder with proper parity count\n        let rs_dec = reed_solomon::Decoder::new(\n            config.base_parity_byte_count + config.cap_parity_byte_count,\n        );\n\n        Ok(Self {\n            config,\n            rs_enc,\n            rs_dec,\n        })\n    }","Real(LocalPath(\"hcid/src/lib.rs\"))"],"HcidEncoding::pre_decode":["/// internal helper for preparing decoding\nfn pre_decode(&self, data: &str) -> HcidResult<(Vec<u8>, Vec<u8>)>{\n        if data.len() != self.config.encoded_char_count {\n            return Err(HcidError(String::from(format!(\n                \"BadIdLen:{},Expected:{}\",\n                data.len(),\n                self.config.encoded_char_count\n            ))));\n        }\n\n        let key_base_byte_size = self.config.key_byte_count + self.config.base_parity_byte_count;\n        // All char_erasures are indexed from the 0th char of the full codeword w/ prefix, but\n        // byte_erasures are indexed from the 0th byte of the key+parity (ie. without the prefix).\n        // Any byte of key, or base/cap parity could be erased.\n        let mut byte_erasures = vec![b'0'; key_base_byte_size + self.config.cap_parity_byte_count];\n        let mut char_erasures = vec![b'0'; data.len()];\n\n        // correct any transliteration errors into our base32 alphabet\n        // marking any unrecognizable characters as char-level erasures\n        let mut data = b32_correct(data.as_bytes(), &mut char_erasures);\n\n        // Pull out the parity data that was encoded as capitalization.  If its erasure,\n        // determine the \n        let mut cap_bytes: Vec<u8> = Vec::new();\n        let mut all_zro = true;\n        let mut all_one = true;\n        for i in 0..self.config.cap_parity_byte_count {\n            // For cap. parity, indexing starts after pre-defined Base-32 prefix\n            let char_idx = self.config.prefix_cap.len() + (i * self.config.cap_segment_char_count);\n            match cap_decode(\n                char_idx,\n                &data[char_idx..char_idx + self.config.cap_segment_char_count],\n                &char_erasures\n            )? {\n                None => {\n                    byte_erasures[key_base_byte_size + i] = b'1';\n                    cap_bytes.push(0)\n                }\n                Some(parity) => {\n                    if all_zro && parity != 0x00_u8 {\n                        all_zro = false\n                    }\n                    if all_one && parity != 0xFF_u8 {\n                        all_one = false\n                    }\n                    cap_bytes.push(parity)\n                }\n            }\n        }\n\n        // If either all caps or all lower case (or erasure), assume the casing was lost (eg. QR\n        // code, or dns segment); mark all cap-derived parity as erasures.  This allows validation\n        // of codeword if all remaining parity is intact and key is correct; since no parity\n        // capacity remains, no correction will be attempted.  There is only a low probability that\n        // any remaining errors will be detected, in this case.  However, we're no *worse* off than\n        // if we had no R-S parity at all.\n        if all_zro || all_one {\n            for i in 0..self.config.cap_parity_byte_count {\n                byte_erasures[key_base_byte_size + i] = b'1';\n            }\n        }\n\n        // we have the cap data, uppercase everything\n        for c in data.iter_mut() {\n            char_upper(c);\n        }\n\n        // do the base32 decode\n        let mut data = b32::decode(&data)?;\n\n        if &data[0..self.config.prefix.len()] != self.config.prefix.as_slice() {\n            return Err(HcidError(String::from(\"PrefixMismatch\")));\n        }\n\n        // remove the prefix bytes\n        data.drain(0..self.config.prefix.len());\n\n        // append our cap parity bytes\n        data.append(&mut cap_bytes);\n\n        // Sort through the char-level erasures (5 bits), and associate them with byte-level data (8\n        // bits) -- in the (now prefix-free) data buffer, so that we mark the proper erasures for\n        // reed-solomon correction.  Some of these chars span multiple bytes... we need to mark both.\n        for i in self.config.prefix_cap.len()..char_erasures.len() {\n            let c = char_erasures[i];\n            if c == b'1' {\n                // 1st and last bit of 5-bit segment may index different bytes\n                byte_erasures[( i * 5 + 0 ) / 8 - self.config.prefix.len()] = b'1';\n                byte_erasures[( i * 5 + 4 ) / 8 - self.config.prefix.len()] = b'1';\n            }\n        }\n\n        // translate erasures into the form expected by our reed-solomon lib\n        let mut erasures: Vec<u8> = Vec::new();\n        for i in 0..byte_erasures.len() {\n            if byte_erasures[i] == b'1' {\n                data[i] = 0;\n                erasures.push(i as u8);\n            }\n        }\n\n        Ok((data, erasures))\n    }","Real(LocalPath(\"hcid/src/lib.rs\"))"],"HcidEncoding::pre_is_corrupt":["/// internal helper for is_corrupt checking\nfn pre_is_corrupt(&self, data: &[u8], erasures: &[u8]) -> HcidResult<bool>{\n        // if we have any erasures, we can exit early\n        if erasures.len() > 0 {\n            return Ok(true);\n        }\n\n        // slightly more efficient reed-solomon corruption check\n        Ok(self.rs_dec.is_corrupted(&data))\n    }","Real(LocalPath(\"hcid/src/lib.rs\"))"],"HcidEncoding::with_kind":["/// create a new config given a kind token string\n///\n/// # Example\n///\n/// ```\n/// extern crate hcid;\n/// let hca0 = hcid::HcidEncoding::with_kind(\"hca0\").unwrap();\n/// let hck0 = hcid::HcidEncoding::with_kind(\"hck0\").unwrap();\n/// let hcs0 = hcid::HcidEncoding::with_kind(\"hcs0\").unwrap();\n/// ```\npub fn with_kind(kind: &str) -> HcidResult<Self>{\n        HcidEncoding::new(HcidEncodingConfig::new(kind)?)\n    }","Real(LocalPath(\"hcid/src/lib.rs\"))"],"HcidEncodingConfig":["/// represents an encoding configuration for hcid rendering and parsing\npub struct HcidEncodingConfig {\n    /// byte count of actuall key data that will be encoded\n    pub key_byte_count: usize,\n    /// parity bytes that will be encoded directly into the base32 string (appended after key)\n    pub base_parity_byte_count: usize,\n    /// parity bytes that will be encoded in the alpha capitalization (appended after base parity)\n    pub cap_parity_byte_count: usize,\n    /// bytes to prefix before rendering to base32\n    pub prefix: Vec<u8>,\n    /// binary indication of the capitalization for prefix characters\n    pub prefix_cap: Vec<u8>,\n    /// how many characters are in a capitalization parity segment\n    pub cap_segment_char_count: usize,\n    /// how many characters long the fully rendered base32 string should be\n    pub encoded_char_count: usize,\n}","Real(LocalPath(\"hcid/src/lib.rs\"))"],"HcidEncodingConfig::new":["/// create a new config given a kind token string\n///\n/// # Example\n///\n/// ```\n/// extern crate hcid;\n/// let hca0 = hcid::HcidEncodingConfig::new(\"hca0\").unwrap();\n/// let hck0 = hcid::HcidEncodingConfig::new(\"hck0\").unwrap();\n/// let hcs0 = hcid::HcidEncodingConfig::new(\"hcs0\").unwrap();\n/// ```\npub fn new(kind: &str) -> HcidResult<Self>{\n        let kind_b = kind.as_bytes();\n        if kind_b.len() != 4 || kind_b[0] != 104 || kind_b[1] != 99 ||\n                (kind_b[3] != 48 && kind_b[3] != 49) ||\n                kind_b[2] < 51 || kind_b[2] > 122 {\n            return Err(format!(\"invalid kind: `{}`\", kind).into());\n        }\n\n        let version = if kind_b[3] == 48 { 0 } else { 1 };\n        let res = HC_CODE_MAP[(kind_b[2] - 51) as usize][version as usize];\n\n        if res == 0xff {\n            return Err(format!(\"invalid kind: `{}`\", kind).into());\n        }\n\n        Ok(HcidEncodingConfig {\n            key_byte_count: 32,\n            base_parity_byte_count: 4,\n            cap_parity_byte_count: 4,\n            prefix: vec![0x38, res, 0x24],\n            prefix_cap: b\"101\".to_vec(),\n            cap_segment_char_count: 15,\n            encoded_char_count: 63,\n        })\n    }","Real(LocalPath(\"hcid/src/lib.rs\"))"],"b32::decode":["/// decode an already sanitized holochain base32 string into a byte buffer\npub fn decode (data: &[u8]) -> crate::HcidResult<Vec<u8>>{\n    let mut out: Vec<u8> = vec![];\n\n    let mut bits: usize = 0;\n    let mut tmp: usize = 0;\n\n    for c in data {\n        if c < &51 || *c as usize >= REV_LOOKUP.len() + 51 {\n            return Err(\"bad input\".into());\n        }\n\n        let v: usize = REV_LOOKUP[(c - 51) as usize] as usize;\n\n        if v == 255 {\n            return Err(\"bad input\".into());\n        }\n\n        tmp = (tmp << 5) | v;\n        bits += 5;\n\n        if bits >= 8 {\n            bits -= 8;\n            out.push((0xff & (tmp >> bits)) as u8)\n        }\n    }\n\n    if bits >= 5 || (0xff & (tmp << (8 - bits))) != 0 {\n        return Err(\"unexpected eof\".into());\n    }\n\n    Ok(out)\n}","Real(LocalPath(\"hcid/src/b32.rs\"))"],"b32::encode":["/// encode a byte buffer into basic holochain base32\npub fn encode (data: &[u8]) -> Vec<u8>{\n    let mut out: Vec<u8> = vec![];\n\n    let mut bits: usize = 0;\n    let mut tmp: usize = 0;\n\n    for c in data {\n        tmp = (tmp << 8) | (0xff & c) as usize;\n        bits += 8;\n\n        while bits > 5 {\n            bits -= 5;\n            out.push(ALPHABET[MASK & (tmp >> bits)])\n        }\n    }\n\n    if bits > 0 {\n        out.push(ALPHABET[MASK & (tmp << (5 - bits))])\n    }\n\n    out\n}","Real(LocalPath(\"hcid/src/b32.rs\"))"],"error::HcidError":["/// a simple struct(String) for reporting hcid errors\npub struct HcidError(pub String);","Real(LocalPath(\"hcid/src/error.rs\"))"],"util::b32_correct":["/// correct and transliteration faults\n/// also note any invalid characters as erasures (character-level)\npub fn b32_correct(data: &[u8], char_erasures: &mut Vec<u8>) -> Vec<u8>{\n    let mut out: Vec<u8> = Vec::new();\n\n    let len = data.len();\n    for i in 0..len {\n        out.push(match data[i] {\n            b'0' => b'O',\n            b'1' | b'l' | b'L' => b'I',\n            b'2' => b'Z',\n            b'A'..=b'Z' | b'a'..=b'z' | b'3'..=b'9' => data[i],\n            _ => {\n                // we cannot translate this character\n                // mark it as an erasure... see if we can continue\n                char_erasures[i] = b'1';\n                b'A'\n            }\n        })\n    }\n\n    out\n}","Real(LocalPath(\"hcid/src/util.rs\"))"],"util::cap_decode":["/// Pull parity bytes out that were encoded as capitalization, translate character-level erasures\n/// into byte-level erasures of R-S parity symbols.  Any erasures in the capitalizataion-encoded\n/// parity result in a missing byte indication.  All {char,byte}_erasures are indexed from the 0th\n/// char/byte of the original full codeword, including prefix.  Returns None (erasure) or u8 value.\npub fn cap_decode(\n    char_offset: usize,\n    data: &[u8],\n    char_erasures: &Vec<u8>,\n) -> HcidResult<Option<u8>>{\n    let mut bin = String::new();\n\n    // iterate over input data\n    for i in 0..data.len() {\n        if char_erasures[char_offset + i] == b'1' {\n            // If char is known to be lost, parity byte will be marked as an erasure\n            bin.clear();\n            break;\n        }\n\n        let c = data[i];\n\n        // is alpha\n        if c >= b'A' && c <= b'Z' {\n            // uppercase = bit on\n            bin.push('1');\n        } else if c >= b'a' && c <= b'z' {\n            // lowercase = bit off\n            bin.push('0');\n        }\n\n        // we have our 8 bits! proceed\n        if bin.len() >= 8 {\n            break;\n        }\n    }\n\n    // We did not get a full byte iff we don't have 8 bits.  Later (when the caller has all decoded\n    // parity), it should be determined if they are all 1's/0's, indicating capitalization is lost.\n    if bin.len() < 8 {\n        Ok(None)\n    } else {\n        Ok(Some(u8::from_str_radix(&bin, 2)?))\n    }\n}","Real(LocalPath(\"hcid/src/util.rs\"))"],"util::cap_encode_bin":["/// encode `bin` into `seg` as capitalization\n/// if `min` is not met, lowercase the whole thing\n/// as an indication that we did not have enough alpha characters\npub fn cap_encode_bin(seg: &mut [u8], bin: &[u8], min: usize) -> HcidResult<()>{\n    let mut count = 0;\n    let mut bin_idx = 0;\n    for c in seg.iter_mut() {\n        if bin_idx >= bin.len() {\n            char_lower(c);\n            continue;\n        }\n        // is alpha\n        if (*c >= b'A' && *c <= b'Z') || (*c >= b'a' && *c <= b'z') {\n            count += 1;\n            // is 1\n            if bin[bin_idx] == b'1' {\n                // the bit is on: uppercase\n                char_upper(c);\n            } else {\n                // the bit is off: lowercase\n                char_lower(c);\n            }\n            bin_idx += 1;\n        }\n    }\n    if count < min {\n        // not enough alpha characters to encode the min\n        // mark everything as lower\n        for c in seg.iter_mut() {\n            char_lower(c);\n        }\n    }\n    Ok(())\n}","Real(LocalPath(\"hcid/src/util.rs\"))"],"util::char_lower":["/// modify a character to be ascii upper-case in-place\npub fn char_lower(c: &mut u8){\n    if *c >= b'A' && *c <= b'Z' {\n        *c ^= 32;\n    }\n}","Real(LocalPath(\"hcid/src/util.rs\"))"],"util::char_upper":["/// modify a character to be ascii lower-case in-place\npub fn char_upper(c: &mut u8){\n    if *c >= b'a' && *c <= b'z' {\n        *c ^= 32;\n    }\n}","Real(LocalPath(\"hcid/src/util.rs\"))"]},"struct_constructor":{"&dyn std::error::Error":["cause"],"&str":["description"],"(std::vec::Vec<u8>, std::vec::Vec<u8>)":["pre_decode"],"HcidEncoding":["new","with_kind"],"HcidEncodingConfig":["new"],"bool":["eq","is_corrupt","pre_is_corrupt"],"error::HcidError":["clone","from"],"std::string::String":["encode"],"std::vec::Vec":["b32_correct","decode","encode"],"u8":["cap_decode"]},"struct_to_trait":{"error::HcidError":["std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralPartialEq"]},"targets":{"<error::HcidError as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"hcid/src/error.rs\"))","std::convert::From"],"<error::HcidError as std::convert::From<reed_solomon::DecoderError>>::from":["from","Real(LocalPath(\"hcid/src/error.rs\"))","std::convert::From"],"<error::HcidError as std::convert::From<std::num::ParseIntError>>::from":["from","Real(LocalPath(\"hcid/src/error.rs\"))","std::convert::From"],"<error::HcidError as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"hcid/src/error.rs\"))","std::convert::From"],"<error::HcidError as std::error::Error>::cause":["cause","Real(LocalPath(\"hcid/src/error.rs\"))","std::error::Error"],"<error::HcidError as std::error::Error>::description":["description","Real(LocalPath(\"hcid/src/error.rs\"))","std::error::Error"],"<error::HcidError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"hcid/src/error.rs\"))","std::fmt::Display"],"HcidEncoding::decode":["decode","Real(LocalPath(\"hcid/src/lib.rs\"))",""],"HcidEncoding::encode":["encode","Real(LocalPath(\"hcid/src/lib.rs\"))",""],"HcidEncoding::is_corrupt":["is_corrupt","Real(LocalPath(\"hcid/src/lib.rs\"))",""],"HcidEncoding::new":["new","Real(LocalPath(\"hcid/src/lib.rs\"))",""],"HcidEncoding::pre_decode":["pre_decode","Real(LocalPath(\"hcid/src/lib.rs\"))",""],"HcidEncoding::pre_is_corrupt":["pre_is_corrupt","Real(LocalPath(\"hcid/src/lib.rs\"))",""],"HcidEncoding::with_kind":["with_kind","Real(LocalPath(\"hcid/src/lib.rs\"))",""],"HcidEncodingConfig::new":["new","Real(LocalPath(\"hcid/src/lib.rs\"))",""],"b32::decode":["decode","Real(LocalPath(\"hcid/src/b32.rs\"))",""],"b32::encode":["encode","Real(LocalPath(\"hcid/src/b32.rs\"))",""],"util::b32_correct":["b32_correct","Real(LocalPath(\"hcid/src/util.rs\"))",""],"util::cap_decode":["cap_decode","Real(LocalPath(\"hcid/src/util.rs\"))",""],"util::cap_encode_bin":["cap_encode_bin","Real(LocalPath(\"hcid/src/util.rs\"))",""],"util::char_lower":["char_lower","Real(LocalPath(\"hcid/src/util.rs\"))",""],"util::char_upper":["char_upper","Real(LocalPath(\"hcid/src/util.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["error::HcidError"],"std::cmp::PartialEq":["error::HcidError"],"std::convert::From":["error::HcidError"],"std::error::Error":["error::HcidError"],"std::fmt::Debug":["error::HcidError"],"std::fmt::Display":["error::HcidError"],"std::marker::StructuralPartialEq":["error::HcidError"]},"type_to_def_path":{"HcidEncoding":"HcidEncoding","HcidEncodingConfig":"HcidEncodingConfig","error::HcidError":"error::HcidError"}}