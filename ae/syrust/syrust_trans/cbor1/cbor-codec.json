{"dependencies":{"<A as skip::Skip>::skip":["std::marker::Sized","std::result::Result"],"<decoder::BytesIter<'r, R> as std::iter::Iterator>::next":["decoder::BytesIter","decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::option::Option"],"<decoder::Config as std::clone::Clone>::clone":["decoder::Config"],"<decoder::Config as std::cmp::Eq>::assert_receiver_is_total_eq":["decoder::Config"],"<decoder::Config as std::cmp::PartialEq>::eq":["decoder::Config"],"<decoder::Config as std::fmt::Debug>::fmt":["decoder::Config","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<decoder::DecodeError as std::convert::From<slice::ReadSliceError>>::from":["decoder::Config","decoder::DecodeError","slice::ReadSliceError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::str::Utf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"<decoder::DecodeError as std::convert::From<std::io::Error>>::from":["decoder::Config","decoder::DecodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::str::Utf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"<decoder::DecodeError as std::convert::From<std::str::Utf8Error>>::from":["decoder::Config","decoder::DecodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::str::Utf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"<decoder::DecodeError as std::convert::From<std::string::FromUtf8Error>>::from":["decoder::Config","decoder::DecodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::str::Utf8Error","std::string::FromUtf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"<decoder::DecodeError as std::error::Error>::cause":["decoder::Config","decoder::DecodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::option::Option","std::str::Utf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"<decoder::DecodeError as std::error::Error>::description":["decoder::Config","decoder::DecodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::str::Utf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"<decoder::DecodeError as std::fmt::Debug>::fmt":["decoder::Config","decoder::DecodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result","std::str::Utf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"<decoder::DecodeError as std::fmt::Display>::fmt":["decoder::Config","decoder::DecodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result","std::str::Utf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"<decoder::TextIter<'r, R> as std::iter::Iterator>::next":["decoder::Config","decoder::Decoder","decoder::Kernel","decoder::TextIter","std::marker::Sized","std::option::Option"],"<encoder::EncodeError as std::convert::From<std::io::Error>>::from":["decoder::Config","encoder::EncodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"<encoder::EncodeError as std::error::Error>::cause":["decoder::Config","encoder::EncodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"<encoder::EncodeError as std::error::Error>::description":["decoder::Config","encoder::EncodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"<encoder::EncodeError as std::fmt::Debug>::fmt":["decoder::Config","encoder::EncodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"<encoder::EncodeError as std::fmt::Display>::fmt":["decoder::Config","encoder::EncodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"<slice::ReadSliceError as std::error::Error>::cause":["slice::ReadSliceError","std::io::Error","std::marker::Sized","std::option::Option"],"<slice::ReadSliceError as std::error::Error>::description":["slice::ReadSliceError","std::io::Error"],"<slice::ReadSliceError as std::fmt::Debug>::fmt":["slice::ReadSliceError","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result"],"<slice::ReadSliceError as std::fmt::Display>::fmt":["slice::ReadSliceError","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result"],"<std::io::Cursor<&'r [u8]> as slice::ReadSlice>::read_slice":["std::io::Cursor","std::marker::Sized","std::result::Result"],"<std::io::Cursor<std::vec::Vec<u8>> as slice::ReadSlice>::read_slice":["std::io::Cursor","std::marker::Sized","std::result::Result"],"<types::Tag as std::clone::Clone>::clone":["types::Tag"],"<types::Tag as std::cmp::Eq>::assert_receiver_is_total_eq":["types::Tag"],"<types::Tag as std::cmp::Ord>::cmp":["std::cmp::Ordering","types::Tag"],"<types::Tag as std::cmp::PartialEq>::eq":["types::Tag"],"<types::Tag as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","types::Tag"],"<types::Tag as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","types::Tag"],"<types::Tag as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","types::Tag"],"<types::Type as std::clone::Clone>::clone":["types::Type"],"<types::Type as std::cmp::Eq>::assert_receiver_is_total_eq":["types::Type"],"<types::Type as std::cmp::Ord>::cmp":["std::cmp::Ordering","types::Type"],"<types::Type as std::cmp::PartialEq>::eq":["types::Type"],"<types::Type as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","types::Type"],"<types::Type as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","types::Type"],"<types::Type as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","types::Type"],"<value::Bytes as std::clone::Clone>::clone":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::vec::Vec","value::Bytes"],"<value::Bytes as std::cmp::Eq>::assert_receiver_is_total_eq":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::vec::Vec","value::Bytes"],"<value::Bytes as std::cmp::Ord>::cmp":["std::alloc::Allocator","std::cmp::Ordering","std::collections::LinkedList","std::marker::Sized","std::vec::Vec","value::Bytes"],"<value::Bytes as std::cmp::PartialEq>::eq":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::vec::Vec","value::Bytes"],"<value::Bytes as std::cmp::PartialOrd>::partial_cmp":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::option::Option","std::vec::Vec","value::Bytes"],"<value::Bytes as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::collections::LinkedList","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","value::Bytes"],"<value::Bytes as std::hash::Hash>::hash":["std::alloc::Allocator","std::collections::LinkedList","std::hash::Hasher","std::marker::Sized","std::vec::Vec","value::Bytes"],"<value::Int as std::clone::Clone>::clone":["value::Int"],"<value::Int as std::cmp::Eq>::assert_receiver_is_total_eq":["value::Int"],"<value::Int as std::cmp::Ord>::cmp":["std::cmp::Ordering","value::Int"],"<value::Int as std::cmp::PartialEq>::eq":["value::Int"],"<value::Int as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","value::Int"],"<value::Int as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","value::Int"],"<value::Int as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","value::Int"],"<value::Key as std::clone::Clone>::clone":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","value::Bytes","value::Int","value::Key","value::Text"],"<value::Key as std::cmp::Eq>::assert_receiver_is_total_eq":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","value::Bytes","value::Int","value::Key","value::Text"],"<value::Key as std::cmp::Ord>::cmp":["std::alloc::Allocator","std::cmp::Ordering","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","value::Bytes","value::Int","value::Key","value::Text"],"<value::Key as std::cmp::PartialEq>::eq":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","value::Bytes","value::Int","value::Key","value::Text"],"<value::Key as std::cmp::PartialOrd>::partial_cmp":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Bytes","value::Int","value::Key","value::Text"],"<value::Key as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::collections::LinkedList","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Bytes","value::Int","value::Key","value::Text"],"<value::Key as std::hash::Hash>::hash":["std::alloc::Allocator","std::collections::LinkedList","std::hash::Hasher","std::marker::Sized","std::string::String","std::vec::Vec","value::Bytes","value::Int","value::Key","value::Text"],"<value::Simple as std::clone::Clone>::clone":["value::Simple"],"<value::Simple as std::cmp::Eq>::assert_receiver_is_total_eq":["value::Simple"],"<value::Simple as std::cmp::Ord>::cmp":["std::cmp::Ordering","value::Simple"],"<value::Simple as std::cmp::PartialEq>::eq":["value::Simple"],"<value::Simple as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","value::Simple"],"<value::Simple as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","value::Simple"],"<value::Simple as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","value::Simple"],"<value::Text as std::clone::Clone>::clone":["std::collections::LinkedList","std::marker::Sized","std::string::String","value::Text"],"<value::Text as std::cmp::Eq>::assert_receiver_is_total_eq":["std::collections::LinkedList","std::marker::Sized","std::string::String","value::Text"],"<value::Text as std::cmp::Ord>::cmp":["std::cmp::Ordering","std::collections::LinkedList","std::marker::Sized","std::string::String","value::Text"],"<value::Text as std::cmp::PartialEq>::eq":["std::collections::LinkedList","std::marker::Sized","std::string::String","value::Text"],"<value::Text as std::cmp::PartialOrd>::partial_cmp":["std::collections::LinkedList","std::marker::Sized","std::option::Option","std::string::String","value::Text"],"<value::Text as std::fmt::Debug>::fmt":["std::collections::LinkedList","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","value::Text"],"<value::Text as std::hash::Hash>::hash":["std::collections::LinkedList","std::hash::Hasher","std::marker::Sized","std::string::String","value::Text"],"<value::Value as std::clone::Clone>::clone":["decoder::Config","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"<value::Value as std::cmp::PartialEq>::eq":["decoder::Config","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"<value::Value as std::cmp::PartialOrd>::partial_cmp":["decoder::Config","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"<value::Value as std::fmt::Debug>::fmt":["decoder::Config","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"decoder::BytesIter":["decoder::BytesIter","decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized"],"decoder::Config":["decoder::Config"],"decoder::Config::default":["decoder::Config"],"decoder::DecodeError":["decoder::Config","decoder::DecodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::str::Utf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"decoder::Decoder":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized"],"decoder::Decoder::<R>::array":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::array_begin":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::bool":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::bytes":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::bytes_borrow":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::bytes_iter":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::f16":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::f32":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::f64":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::i16":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::i32":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::i64":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::i8":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::int":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::into_reader":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized"],"decoder::Decoder::<R>::kernel":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized"],"decoder::Decoder::<R>::new":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized"],"decoder::Decoder::<R>::object":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::object_begin":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::read_bytes":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::simple":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::skip":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::skip_until_break":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Decoder::<R>::skip_value":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::tag":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::text":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::text_borrow":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::text_iter":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::typeinfo":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::typeinfo::go":["byteorder::ReadBytesExt","decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::u16":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::u32":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::u64":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Decoder::<R>::u8":["decoder::Config","decoder::Decoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::GenericDecoder":["decoder::Config","decoder::Decoder","decoder::GenericDecoder","decoder::Kernel","std::marker::Sized"],"decoder::GenericDecoder::<R>::borrow_mut":["decoder::Config","decoder::Decoder","decoder::GenericDecoder","decoder::Kernel","std::marker::Sized"],"decoder::GenericDecoder::<R>::decode_key":["decoder::Config","decoder::Decoder","decoder::GenericDecoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::GenericDecoder::<R>::decode_value":["decoder::Config","decoder::Decoder","decoder::GenericDecoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::GenericDecoder::<R>::from_decoder":["decoder::Config","decoder::Decoder","decoder::GenericDecoder","decoder::Kernel","std::marker::Sized"],"decoder::GenericDecoder::<R>::into_inner":["decoder::Config","decoder::Decoder","decoder::GenericDecoder","decoder::Kernel","std::marker::Sized"],"decoder::GenericDecoder::<R>::new":["decoder::Config","decoder::Decoder","decoder::GenericDecoder","decoder::Kernel","std::marker::Sized"],"decoder::GenericDecoder::<R>::value":["decoder::Config","decoder::Decoder","decoder::GenericDecoder","decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Kernel":["decoder::Kernel","std::marker::Sized"],"decoder::Kernel::<R>::bool":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::f16":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::f32":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::f64":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::i16":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::i32":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::i64":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::i8":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::int":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::into_reader":["decoder::Kernel","std::marker::Sized"],"decoder::Kernel::<R>::new":["decoder::Kernel","std::marker::Sized"],"decoder::Kernel::<R>::raw_data":["decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Kernel::<R>::raw_slice":["decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Kernel::<R>::read_raw_data":["decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Kernel::<R>::simple":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::typeinfo":["decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::Kernel::<R>::u16":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::u32":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::u64":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::u8":["decoder::Kernel","std::marker::Sized","std::result::Result","types::Type"],"decoder::Kernel::<R>::unsigned":["decoder::Kernel","std::marker::Sized","std::result::Result"],"decoder::TextIter":["decoder::Config","decoder::Decoder","decoder::Kernel","decoder::TextIter","std::marker::Sized"],"decoder::ffi::c_ldexpf":[],"decoder::ffi::ldexpf":[],"decoder::is_break":["decoder::Config","decoder::DecodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::str::Utf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"decoder::is_null":["decoder::Config","decoder::DecodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::str::Utf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"decoder::is_undefined":["decoder::Config","decoder::DecodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::str::Utf8Error","std::string::String","std::vec::Vec","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"decoder::maybe":["std::marker::Sized","std::result::Result"],"decoder::opt":["std::marker::Sized","std::result::Result"],"decoder::or_break":["std::marker::Sized","std::result::Result"],"decoder::unexpected_type":["std::marker::Sized","std::result::Result","types::Type"],"encoder::EncodeError":["decoder::Config","encoder::EncodeError","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::io::Error","std::marker::Sized","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"encoder::Encoder":["encoder::Encoder","std::marker::Sized"],"encoder::Encoder::<W>::array":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::array_begin":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::array_end":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::bool":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::bytes":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::bytes_iter":["decoder::BytesIter","decoder::Config","decoder::Decoder","decoder::Kernel","encoder::Encoder","std::iter::Iterator","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::f32":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::f64":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::i16":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::i32":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::i64":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::i8":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::int":["encoder::Encoder","std::marker::Sized","std::result::Result","value::Int"],"encoder::Encoder::<W>::into_writer":["encoder::Encoder","std::marker::Sized"],"encoder::Encoder::<W>::new":["encoder::Encoder","std::marker::Sized"],"encoder::Encoder::<W>::null":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::object":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::object_begin":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::object_end":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::simple":["encoder::Encoder","std::marker::Sized","std::result::Result","value::Simple"],"encoder::Encoder::<W>::tag":["encoder::Encoder","std::marker::Sized","std::result::Result","types::Tag"],"encoder::Encoder::<W>::text":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::text_iter":["decoder::BytesIter","decoder::Config","decoder::Decoder","decoder::Kernel","encoder::Encoder","std::iter::Iterator","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::type_len":["encoder::Encoder","std::marker::Sized","std::result::Result","types::Type"],"encoder::Encoder::<W>::u16":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::u32":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::u64":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::u8":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::undefined":["encoder::Encoder","std::marker::Sized","std::result::Result"],"encoder::Encoder::<W>::writer":["encoder::Encoder","std::marker::Sized"],"encoder::GenericEncoder":["encoder::Encoder","encoder::GenericEncoder","std::marker::Sized"],"encoder::GenericEncoder::<W>::borrow_mut":["encoder::Encoder","encoder::GenericEncoder","std::marker::Sized"],"encoder::GenericEncoder::<W>::from_encoder":["encoder::Encoder","encoder::GenericEncoder","std::marker::Sized"],"encoder::GenericEncoder::<W>::into_inner":["encoder::Encoder","encoder::GenericEncoder","std::marker::Sized"],"encoder::GenericEncoder::<W>::key":["encoder::Encoder","encoder::GenericEncoder","std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Bytes","value::Int","value::Key","value::Text"],"encoder::GenericEncoder::<W>::new":["encoder::Encoder","encoder::GenericEncoder","std::marker::Sized"],"encoder::GenericEncoder::<W>::value":["decoder::Config","encoder::Encoder","encoder::GenericEncoder","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"skip::Skip::skip":["std::marker::Sized","std::result::Result"],"slice::ReadSlice::read_slice":["std::marker::Sized","std::result::Result"],"slice::ReadSliceError":["slice::ReadSliceError","std::io::Error"],"types::Tag":["types::Tag"],"types::Tag::of":["types::Tag"],"types::Tag::to":["types::Tag"],"types::Type":["types::Type"],"types::Type::major":["types::Type"],"types::Type::read":["byteorder::ReadBytesExt","std::marker::Sized","std::result::Result"],"value::Bytes":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::vec::Vec","value::Bytes"],"value::Cursor":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::at":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::bool":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::bytes":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::bytes_chunked":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::bytes_plain":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::field":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::float32":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::float64":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::get":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Bytes","value::Cursor","value::Int","value::Key","value::Text"],"value::Cursor::<'r>::i16":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::i32":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::i64":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::i8":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::maybe":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::new":["decoder::Config","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Cursor","value::Int","value::Simple","value::Text","value::Value"],"value::Cursor::<'r>::of":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::opt":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::text":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::text_chunked":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::text_plain":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::u16":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::u32":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::u64":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::u8":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Cursor::<'r>::value":["std::marker::Sized","std::option::Option","value::Cursor"],"value::Int":["value::Int"],"value::Int::from_i64":["value::Int"],"value::Int::from_u64":["value::Int"],"value::Int::i64":["std::marker::Sized","std::option::Option","value::Int"],"value::Int::u64":["std::marker::Sized","std::option::Option","value::Int"],"value::Key":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","value::Bytes","value::Int","value::Key","value::Text"],"value::Key::i64":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","value::Bytes","value::Int","value::Key","value::Text"],"value::Key::u64":["std::alloc::Allocator","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","value::Bytes","value::Int","value::Key","value::Text"],"value::Simple":["value::Simple"],"value::Text":["std::collections::LinkedList","std::marker::Sized","std::string::String","value::Text"],"value::Value":["decoder::Config","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"value::check":["decoder::Config","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"],"value::check::fun":["decoder::Config","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::collections::LinkedList","std::marker::Sized","std::string::String","std::vec::Vec","types::Tag","value::Bytes","value::Int","value::Simple","value::Text","value::Value"]},"glob_path_import":{},"self_to_fn":{"<A as skip::Skip>::A":["impl<A: Seek> Skip for A {\n    /// `n` must be in range `[0, i64::MAX]`.\n    fn skip(&mut self, n: u64) -> Result<()> {\n        if n > i64::MAX as u64 {\n            return Err(Error::new(ErrorKind::Other, \"n too large\"))\n        }\n        self.seek(SeekFrom::Current(n as i64)).and(Ok(()))\n    }\n}"],"decoder::BytesIter":["impl<'r, R: 'r + ReadBytesExt> Iterator for BytesIter<'r, R> {\n    type Item = DecodeResult<Vec<u8>>;\n\n    fn next(&mut self) -> Option<DecodeResult<Vec<u8>>> {\n        match or_break(self.decoder.bytes()) {\n            Ok(None)    => None,\n            Ok(Some(b)) => Some(Ok(b)),\n            Err(e)      => Some(Err(e))\n        }\n    }\n}"],"decoder::Config":["Clone","Debug","Eq","PartialEq","impl Config {\n    /// Create default configuration with\n    ///\n    /// - `max_len_array` = 1000\n    /// - `max_len_bytes` = 5 MB\n    /// - `max_len_text` = 5 MB\n    /// - `max_size_map` = 1000\n    /// - `max_nesting` = 16\n    /// - `skip_tags` = false\n    /// - `check_tags` = true\n    pub fn default() -> Config { DEFAULT_CONFIG }\n}"],"decoder::DecodeError":["Debug","impl Error for DecodeError {\n    fn description(&self) -> &str {\n        match *self {\n            DecodeError::DuplicateKey(_)    => \"duplicate key in objects\",\n            DecodeError::IntOverflow(_)     => \"integer overflow\",\n            DecodeError::InvalidKey(_)      => \"invalid object key\",\n            DecodeError::InvalidTag(_)      => \"invalid tag\",\n            DecodeError::InvalidUtf8(_)     => \"invalid utf-8\",\n            DecodeError::IoError(_)         => \"i/o error\",\n            DecodeError::TooNested          => \"too deeply nested objects/arrays\",\n            DecodeError::UnexpectedEOF      => \"unexpected eof\",\n            DecodeError::UnexpectedBreak    => \"unexpected break\",\n            DecodeError::Other(_)           => \"other error\",\n            DecodeError::TooLong{..}        => \"value is too long\",\n            DecodeError::UnexpectedType{..} => \"unexpected type\"\n        }\n    }\n\n    fn cause(&self) -> Option<&Error> {\n        match *self {\n            DecodeError::IoError(ref e)     => Some(e),\n            DecodeError::InvalidUtf8(ref e) => Some(e),\n            DecodeError::Other(ref e)       => Some(&**e),\n            _                               => None\n        }\n    }\n}","impl From<ReadSliceError> for DecodeError {\n    fn from(e: ReadSliceError) -> DecodeError {\n        match e {\n            ReadSliceError::InsufficientData => DecodeError::UnexpectedEOF,\n            ReadSliceError::IoError(e)       => DecodeError::IoError(e)\n        }\n    }\n}","impl From<Utf8Error> for DecodeError {\n    fn from(e: Utf8Error) -> DecodeError {\n        DecodeError::InvalidUtf8(e)\n    }\n}","impl From<io::Error> for DecodeError {\n    fn from(e: io::Error) -> DecodeError {\n        DecodeError::IoError(e)\n    }\n}","impl From<string::FromUtf8Error> for DecodeError {\n    fn from(e: string::FromUtf8Error) -> DecodeError {\n        DecodeError::InvalidUtf8(e.utf8_error())\n    }\n}","impl fmt::Display for DecodeError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        match *self {\n            DecodeError::DuplicateKey(ref k) => write!(f, \"DecodeError: duplicate key: {:?}\", *k),\n            DecodeError::IntOverflow(n)      => write!(f, \"DecodeError: integer overflow: {}\", n),\n            DecodeError::InvalidKey(ref k)   => write!(f, \"DecodeError: unsuitable map key: {:?}\", *k),\n            DecodeError::InvalidTag(ref v)   => write!(f, \"DecodeError: value does not match tag: {:?}\", *v),\n            DecodeError::InvalidUtf8(ref e)  => write!(f, \"DecodeError: Invalid UTF-8 encoding: {}\", *e),\n            DecodeError::IoError(ref e)      => write!(f, \"DecodeError: I/O error: {}\", *e),\n            DecodeError::TooNested           => write!(f, \"DecodeError: value is too nested\"),\n            DecodeError::UnexpectedEOF       => write!(f, \"DecodeError: unexpected end-of-file\"),\n            DecodeError::UnexpectedBreak     => write!(f, \"DecodeError: unexpected break\"),\n            DecodeError::Other(ref e)        => write!(f, \"DecodeError: other: {:?}\", e),\n            DecodeError::TooLong{max:m, actual:a} => write!(f, \"DecodeError: value is too long {} (max={})\", a, m),\n            DecodeError::UnexpectedType{datatype:t, info:i} => write!(f, \"DecodeError: unexpected type {:?} (info={})\", t, i)\n        }\n    }\n}"],"decoder::Decoder":["impl<R: ReadBytesExt + ReadSlice> Decoder<R> {\n    /// Decode a single UTF-8 encoded String and borrow it from underlying\n    /// buffer instead of allocating.\n    ///\n    /// Please note that indefinite strings are not supported by this method.\n    pub fn text_borrow(&mut self) -> DecodeResult<&str> {\n        match self.typeinfo()? {\n            (Type::Text, 31) => unexpected_type(&(Type::Text, 31)),\n            (Type::Text,  i) => {\n                let max  = self.config.max_len_text;\n                let data = self.kernel.raw_slice(i, max)?;\n                from_utf8(data).map_err(From::from)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }\n\n    /// Decode a single byte string and borrow it from underlying\n    /// buffer instead of allocating.\n    ///\n    /// Please note that indefinite byte strings are not supported by this\n    /// method.\n    pub fn bytes_borrow(&mut self) -> DecodeResult<&[u8]> {\n        match self.typeinfo()? {\n            (Type::Bytes, 31) => unexpected_type(&(Type::Bytes, 31)),\n            (Type::Bytes,  i) => {\n                let max = self.config.max_len_bytes;\n                self.kernel.raw_slice(i, max)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }\n}","impl<R: ReadBytesExt + Skip> Decoder<R> {\n    /// Skip over a single CBOR value.\n    ///\n    /// Please note that this function does not validate the value hence\n    /// it might not even be well-formed CBOR. Instead `skip` is an\n    /// optimisation over `GenericDecoder::value()` and generally only\n    /// determines as much information as necessary to safely skip a value\n    /// without keeping all of it in memory.\n    pub fn skip(&mut self) -> DecodeResult<()> {\n        let start = self.config.max_nesting;\n        self.skip_value(start).and(Ok(()))\n    }\n\n    fn skip_value(&mut self, level: usize) -> DecodeResult<bool> {\n        if level == 0 {\n            return Err(DecodeError::TooNested)\n        }\n        match self.typeinfo()? {\n            (Type::UInt8, n)     => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::UInt16, n)    => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::UInt32, n)    => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::UInt64, n)    => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::Int8, n)      => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::Int16, n)     => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::Int32, n)     => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::Int64, n)     => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::Bool, _)      => Ok(true),\n            (Type::Null, _)      => Ok(true),\n            (Type::Undefined, _) => Ok(true),\n            (Type::Break, _)     => Ok(false),\n            (Type::Float16, _)   => {\n                self.kernel.reader.skip(2)?;\n                Ok(true)\n            }\n            (Type::Float32, _) => {\n                self.kernel.reader.skip(4)?;\n                Ok(true)\n            }\n            (Type::Float64, _) => {\n                self.kernel.reader.skip(8)?;\n                Ok(true)\n            }\n            (Type::Bytes, 31) => self.skip_until_break(Type::Bytes).and(Ok(true)),\n            (Type::Bytes, a)  => {\n                let n = self.kernel.unsigned(a)?;\n                self.kernel.reader.skip(n)?;\n                Ok(true)\n            }\n            (Type::Text, 31) => self.skip_until_break(Type::Text).and(Ok(true)),\n            (Type::Text, a)  => {\n                let n = self.kernel.unsigned(a)?;\n                self.kernel.reader.skip(n)?;\n                Ok(true)\n            }\n            (Type::Array, 31) => {\n                while self.skip_value(level - 1)? {}\n                Ok(true)\n            }\n            (Type::Object, 31) => {\n                while self.skip_value(level - 1)? {}\n                Ok(true)\n            }\n            (Type::Array, a) => {\n                let n = self.kernel.unsigned(a)?;\n                for _ in 0 .. n {\n                    self.skip_value(level - 1)?;\n                }\n                Ok(true)\n            }\n            (Type::Object, a) => {\n                let n = self.kernel.unsigned(a)?;\n                // n == number of fields => need to skip over keys and values.\n                // Instead of doubling n we loop twice in order to avoid\n                // overflowing n.\n                for _ in 0 .. n {\n                    self.skip_value(level - 1)?;\n                }\n                for _ in 0 .. n {\n                    self.skip_value(level - 1)?;\n                }\n                Ok(true)\n            }\n            (Type::Unassigned {..}, _) => Ok(true),\n            (Type::Reserved {..}, _)   => Ok(true),\n            ti@(Type::Tagged, _)       => unexpected_type(&ti),\n            ti@(Type::Unknown {..}, _) => unexpected_type(&ti)\n        }\n    }\n\n    // Skip over `Text` or `Bytes` until a `Break` is encountered.\n    fn skip_until_break(&mut self, ty: Type) -> DecodeResult<()> {\n        loop {\n            let (t, a) = self.typeinfo()?;\n            if t == Type::Break {\n                break\n            }\n            if t != ty || a == 31 {\n                return unexpected_type(&(t, a))\n            }\n            let n = self.kernel.unsigned(a)?;\n            self.kernel.reader.skip(n)?\n        }\n        Ok(())\n    }\n}","impl<R: ReadBytesExt> Decoder<R> {\n    pub fn new(c: Config, r: R) -> Decoder<R> {\n        Decoder { kernel: Kernel::new(r), config: c }\n    }\n\n    pub fn into_reader(self) -> R {\n        self.kernel.into_reader()\n    }\n\n    pub fn kernel(&mut self) -> &mut Kernel<R> {\n        &mut self.kernel\n    }\n\n    pub fn simple(&mut self) -> DecodeResult<Simple> {\n        self.typeinfo().and_then(|ti| self.kernel.simple(&ti))\n    }\n\n    pub fn bool(&mut self) -> DecodeResult<bool> {\n        self.typeinfo().and_then(|ti| self.kernel.bool(&ti))\n    }\n\n    pub fn u8(&mut self) -> DecodeResult<u8> {\n        self.typeinfo().and_then(|ti| self.kernel.u8(&ti))\n    }\n\n    pub fn u16(&mut self) -> DecodeResult<u16> {\n        self.typeinfo().and_then(|ti| self.kernel.u16(&ti))\n    }\n\n    pub fn u32(&mut self) -> DecodeResult<u32> {\n        self.typeinfo().and_then(|ti| self.kernel.u32(&ti))\n    }\n\n    pub fn u64(&mut self) -> DecodeResult<u64> {\n        self.typeinfo().and_then(|ti| self.kernel.u64(&ti))\n    }\n\n    pub fn i8(&mut self) -> DecodeResult<i8> {\n        self.typeinfo().and_then(|ti| self.kernel.i8(&ti))\n    }\n\n    pub fn i16(&mut self) -> DecodeResult<i16> {\n        self.typeinfo().and_then(|ti| self.kernel.i16(&ti))\n    }\n\n    pub fn i32(&mut self) -> DecodeResult<i32> {\n        self.typeinfo().and_then(|ti| self.kernel.i32(&ti))\n    }\n\n    pub fn i64(&mut self) -> DecodeResult<i64> {\n        self.typeinfo().and_then(|ti| self.kernel.i64(&ti))\n    }\n\n    pub fn int(&mut self) -> DecodeResult<Int> {\n        self.typeinfo().and_then(|ti| self.kernel.int(&ti))\n    }\n\n    pub fn f16(&mut self) -> DecodeResult<f32> {\n        self.typeinfo().and_then(|ti| self.kernel.f16(&ti))\n    }\n\n    pub fn f32(&mut self) -> DecodeResult<f32> {\n        self.typeinfo().and_then(|ti| self.kernel.f32(&ti))\n    }\n\n    pub fn f64(&mut self) -> DecodeResult<f64> {\n        self.typeinfo().and_then(|ti| self.kernel.f64(&ti))\n    }\n\n    /// Decode a single byte string into the given buffer.\n    ///\n    /// The provided buffer must be large enough to hold the entire\n    /// byte string, otherwise an error is returned.\n    ///\n    /// Please note that indefinite byte strings are not supported by this\n    /// method (Consider using `Decoder::bytes_iter()` for this use-case).\n    pub fn read_bytes(&mut self, b: &mut [u8]) -> DecodeResult<usize> {\n        match self.typeinfo()? {\n            (Type::Bytes, 31) => unexpected_type(&(Type::Bytes, 31)),\n            (Type::Bytes,  i) => self.kernel.read_raw_data(i, b),\n            ti                => unexpected_type(&ti)\n        }\n    }\n\n    /// Decode a single byte string.\n    ///\n    /// Please note that indefinite byte strings are not supported by this\n    /// method (Consider using `Decoder::bytes_iter()` for this use-case).\n    pub fn bytes(&mut self) -> DecodeResult<Vec<u8>> {\n        match self.typeinfo()? {\n            (Type::Bytes, 31) => unexpected_type(&(Type::Bytes, 31)),\n            (Type::Bytes,  i) => {\n                let max = self.config.max_len_bytes;\n                self.kernel.raw_data(i, max)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }\n\n    /// Decode an indefinite byte string.\n    pub fn bytes_iter(&mut self) -> DecodeResult<BytesIter<R>> {\n        match self.typeinfo()? {\n            (Type::Bytes, 31) => Ok(BytesIter { decoder: self }),\n            ti                => unexpected_type(&ti)\n        }\n    }\n\n    /// Decode a single UTF-8 encoded String.\n    ///\n    /// Please note that indefinite strings are not supported by this method\n    /// (Consider using `Decoder::text_iter()` for this use-case).\n    pub fn text(&mut self) -> DecodeResult<String> {\n        match self.typeinfo()? {\n            (Type::Text, 31) => unexpected_type(&(Type::Text, 31)),\n            (Type::Text,  i) => {\n                let max  = self.config.max_len_text;\n                let data = self.kernel.raw_data(i, max)?;\n                String::from_utf8(data).map_err(From::from)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }\n\n    /// Decode an indefinite string.\n    pub fn text_iter(&mut self) -> DecodeResult<TextIter<R>> {\n        match self.typeinfo()? {\n            (Type::Text, 31) => Ok(TextIter { decoder: self }),\n            ti               => unexpected_type(&ti)\n        }\n    }\n\n    /// Decode a `Tag`.\n    /// If no tag is found an `UnexpectedType` error is returned.\n    pub fn tag(&mut self) -> DecodeResult<Tag> {\n        match self.kernel.typeinfo()? {\n            (Type::Tagged, i) => self.kernel.unsigned(i).map(Tag::of),\n            ti                => unexpected_type(&ti)\n        }\n    }\n\n    /// Decode the begin of an array. The length is returned unless it\n    /// exceeds the configured maximum.\n    ///\n    /// Please note that indefinite arrays are not supported by this method\n    /// (Consider using `Decoder::array_begin()` for this use-case).\n    pub fn array(&mut self) -> DecodeResult<usize> {\n        match self.typeinfo()? {\n            (Type::Array, 31) => unexpected_type(&(Type::Array, 31)),\n            (Type::Array,  a) => {\n                let len = self.kernel.unsigned(a)?;\n                if len > self.config.max_len_array as u64 {\n                    return Err(DecodeError::TooLong { max: self.config.max_len_array, actual: len })\n                }\n                Ok(len as usize)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }\n\n    /// Decode the begin of an indefinite array.\n    /// After this one can continue decoding items, but a `Break` value\n    /// will be encountered at some unknown point.\n    ///\n    /// (Consider using `or_break` around every decoding step within an\n    /// indefinite array to handle this case).\n    pub fn array_begin(&mut self) -> DecodeResult<()> {\n        match self.typeinfo()? {\n            (Type::Array, 31) => Ok(()),\n            ti                => unexpected_type(&ti)\n        }\n    }\n\n    /// Decode the begin of an object. The size (number of key-value pairs)\n    /// is returned unless it exceeds the configured maximum.\n    ///\n    /// Please note that indefinite objects are not supported by this method\n    /// (Consider using `Decoder::object_begin` for this use-case).\n    pub fn object(&mut self) -> DecodeResult<usize> {\n        match self.typeinfo()? {\n            (Type::Object, 31) => unexpected_type(&(Type::Object, 31)),\n            (Type::Object,  a) => {\n                let len = self.kernel.unsigned(a)?;\n                if len > self.config.max_size_map as u64 {\n                    return Err(DecodeError::TooLong { max: self.config.max_size_map, actual: len })\n                }\n                Ok(len as usize)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }\n\n    /// Decode the begin of an indefinite object.\n    /// After this one can continue decoding items, but a `Break` value\n    /// will be encountered at some unknown point.\n    ///\n    /// (Consider using `or_break` around every decoding step within an\n    /// indefinite object to handle this case).\n    pub fn object_begin(&mut self) -> DecodeResult<()> {\n        match self.typeinfo()? {\n            (Type::Object, 31) => Ok(()),\n            ti                 => unexpected_type(&ti)\n        }\n    }\n\n    // Decode type information while skipping tags\n    fn typeinfo(&mut self) -> DecodeResult<TypeInfo> {\n        fn go<A: ReadBytesExt>(d: &mut Decoder<A>, level: usize) -> DecodeResult<TypeInfo> {\n            if level == 0 {\n                return Err(DecodeError::TooNested)\n            }\n            match d.kernel.typeinfo()? {\n                (Type::Tagged, i) => d.kernel.unsigned(i).and(go(d, level - 1)),\n                ti                => Ok(ti)\n            }\n        }\n        let start = self.config.max_nesting;\n        go(self, start)\n    }\n}"],"decoder::GenericDecoder":["impl<R: ReadBytesExt> GenericDecoder<R> {\n    pub fn new(c: Config, r: R) -> GenericDecoder<R> {\n        GenericDecoder { decoder: Decoder::new(c, r) }\n    }\n\n    pub fn from_decoder(d: Decoder<R>) -> GenericDecoder<R> {\n        GenericDecoder { decoder: d }\n    }\n\n    pub fn into_inner(self) -> Decoder<R> {\n        self.decoder\n    }\n\n    pub fn borrow_mut(&mut self) -> &mut Decoder<R> {\n        &mut self.decoder\n    }\n\n    /// Decode into a `Value`, i.e. an intermediate representation which\n    /// can be further deconstructed using a `Cursor`.\n    /// This supports indefinite decoding as well as tag validation\n    /// (if not disabled).\n    pub fn value(&mut self) -> DecodeResult<Value> {\n        let start = self.decoder.config.max_nesting;\n        self.decode_value(start)\n    }\n\n    fn decode_value(&mut self, level: usize) -> DecodeResult<Value> {\n        if level == 0 {\n            return Err(DecodeError::TooNested)\n        }\n        match self.decoder.kernel.typeinfo()? {\n            ti@(Type::UInt8, _)   => self.decoder.kernel.u8(&ti).map(Value::U8),\n            ti@(Type::UInt16, _)  => self.decoder.kernel.u16(&ti).map(Value::U16),\n            ti@(Type::UInt32, _)  => self.decoder.kernel.u32(&ti).map(Value::U32),\n            ti@(Type::UInt64, _)  => self.decoder.kernel.u64(&ti).map(Value::U64),\n            ti@(Type::Int8, _)    =>\n                self.decoder.kernel.i16(&ti)\n                    .map(|n| {\n                        if n > i8::MAX as i16 || n < i8::MIN as i16 {\n                            Value::I16(n)\n                        } else {\n                            Value::I8(n as i8)\n                        }\n                    }),\n            ti@(Type::Int16, _) =>\n                self.decoder.kernel.i32(&ti)\n                    .map(|n| {\n                        if n > i16::MAX as i32 || n < i16::MIN as i32 {\n                            Value::I32(n)\n                        } else {\n                            Value::I16(n as i16)\n                        }\n                    }),\n            ti@(Type::Int32, _) =>\n                self.decoder.kernel.i64(&ti)\n                    .map(|n| {\n                        if n > i32::MAX as i64 || n < i32::MIN as i64 {\n                            Value::I64(n)\n                        } else {\n                            Value::I32(n as i32)\n                        }\n                    }),\n            (Type::Int64, a) =>\n                self.decoder.kernel.unsigned(a)\n                    .map(|n| {\n                        if n > i64::MAX as u64 {\n                            Value::Int(Int::Neg(n))\n                        } else {\n                            Value::I64(-1 - n as i64)\n                        }\n                    }),\n            ti@(Type::Float16, _) => self.decoder.kernel.f16(&ti).map(Value::F32),\n            ti@(Type::Float32, _) => self.decoder.kernel.f32(&ti).map(Value::F32),\n            ti@(Type::Float64, _) => self.decoder.kernel.f64(&ti).map(Value::F64),\n            ti@(Type::Bool, _)    => self.decoder.kernel.bool(&ti).map(Value::Bool),\n            (Type::Null, _)       => Ok(Value::Null),\n            (Type::Undefined, _)  => Ok(Value::Undefined),\n            (Type::Break, _)      => Ok(Value::Break),\n            (Type::Bytes, 31)     => { // indefinite byte string\n                let mut i = 0u64;\n                let mut v = LinkedList::new();\n                loop {\n                    match self.decoder.bytes() {\n                        Ok(chunk) => {\n                            i += chunk.len() as u64;\n                            if i > self.decoder.config.max_len_bytes as u64 {\n                                return Err(DecodeError::TooLong { max: self.decoder.config.max_len_bytes, actual: i })\n                            }\n                            v.push_back(chunk)\n                        }\n                        Err(ref e) if is_break(e) => break,\n                        Err(e)                    => return Err(e)\n                    }\n                }\n                Ok(Value::Bytes(Bytes::Chunks(v)))\n            }\n            (Type::Bytes, a) => {\n                let max = self.decoder.config.max_len_bytes;\n                self.decoder.kernel.raw_data(a, max).map(|x| Value::Bytes(Bytes::Bytes(x)))\n            }\n            (Type::Text, 31) => { // indefinite string\n                let mut i = 0u64;\n                let mut v = LinkedList::new();\n                loop {\n                    match self.decoder.text() {\n                        Ok(chunk) => {\n                            i += chunk.len() as u64;\n                            if i > self.decoder.config.max_len_text as u64 {\n                                return Err(DecodeError::TooLong { max: self.decoder.config.max_len_text, actual: i })\n                            }\n                            v.push_back(chunk)\n                        }\n                        Err(ref e) if is_break(e) => break,\n                        Err(e)                    => return Err(e)\n                    }\n                }\n                Ok(Value::Text(Text::Chunks(v)))\n            }\n            (Type::Text, a) => {\n                let max  = self.decoder.config.max_len_text;\n                let data = self.decoder.kernel.raw_data(a, max)?;\n                String::from_utf8(data).map(|x| Value::Text(Text::Text(x))).map_err(From::from)\n            }\n            (Type::Array, 31) => { // indefinite length array\n                let mut i = 0u64;\n                let mut v = Vec::new();\n                loop {\n                    i += 1;\n                    if i > self.decoder.config.max_len_array as u64 {\n                        return Err(DecodeError::TooLong { max: self.decoder.config.max_len_array, actual: i })\n                    }\n                    match self.decode_value(level - 1) {\n                        Ok(Value::Break) => break,\n                        Ok(x)            => v.push(x),\n                        e                => return e\n                    }\n                }\n                Ok(Value::Array(v))\n            }\n            (Type::Array, a) => {\n                let len = self.decoder.kernel.unsigned(a)?;\n                if len > self.decoder.config.max_len_array as u64 {\n                    return Err(DecodeError::TooLong { max: self.decoder.config.max_len_array, actual: len })\n                }\n                let n = len as usize;\n                let mut v = Vec::with_capacity(n);\n                for _ in 0 .. n {\n                    v.push(self.decode_value(level - 1)?);\n                }\n                Ok(Value::Array(v))\n            }\n            (Type::Object, 31) => { // indefinite size object\n                let mut i = 0u64;\n                let mut m = BTreeMap::new();\n                loop {\n                    i += 1;\n                    if i > self.decoder.config.max_size_map as u64 {\n                        return Err(DecodeError::TooLong { max: self.decoder.config.max_size_map, actual: i })\n                    }\n                    match self.decode_key(level - 1) {\n                        Ok(key) => {\n                            if m.contains_key(&key) {\n                                return Err(DecodeError::DuplicateKey(key))\n                            }\n                            match self.decode_value(level - 1)? {\n                                Value::Break => return Err(DecodeError::UnexpectedBreak),\n                                value        => { m.insert(key, value); }\n                            }\n                        }\n                        Err(DecodeError::InvalidKey(Value::Break)) => break,\n                        Err(e) => return Err(e)\n                    }\n                }\n                Ok(Value::Map(m))\n            }\n            (Type::Object, a) => {\n                let len = self.decoder.kernel.unsigned(a)?;\n                if len > self.decoder.config.max_size_map as u64 {\n                    return Err(DecodeError::TooLong { max: self.decoder.config.max_size_map, actual: len })\n                }\n                let n = len as usize;\n                let mut m = BTreeMap::new();\n                for _ in 0 .. n {\n                    let key = self.decode_key(level - 1)?;\n                    if m.contains_key(&key) {\n                        return Err(DecodeError::DuplicateKey(key))\n                    }\n                    m.insert(key, self.decode_value(level - 1)?);\n                }\n                Ok(Value::Map(m))\n            }\n            (Type::Tagged, a) => {\n                let tag = self.decoder.kernel.unsigned(a).map(Tag::of)?;\n                if self.decoder.config.skip_tags {\n                    return self.decode_value(level - 1)\n                }\n                let val = self.decode_value(level - 1).map(|v| Value::Tagged(tag, Box::new(v)))?;\n                if self.decoder.config.check_tags && !value::check(&val) {\n                    return Err(DecodeError::InvalidTag(val))\n                }\n                Ok(val)\n            }\n            (Type::Unassigned { major: 7, info: a }, _) => Ok(Value::Simple(Simple::Unassigned(a))),\n            (Type::Reserved { major: 7, info: a }, _)   => Ok(Value::Simple(Simple::Reserved(a))),\n            ti => unexpected_type(&ti)\n        }\n    }\n\n    fn decode_key(&mut self, level: usize) -> DecodeResult<Key> {\n        match self.decode_value(level)? {\n            Value::Bool(x)  => Ok(Key::Bool(x)),\n            Value::Bytes(x) => Ok(Key::Bytes(x)),\n            Value::Text(x)  => Ok(Key::Text(x)),\n            Value::I8(x)    => Ok(Key::i64(x as i64)),\n            Value::I16(x)   => Ok(Key::i64(x as i64)),\n            Value::I32(x)   => Ok(Key::i64(x as i64)),\n            Value::I64(x)   => Ok(Key::i64(x)),\n            Value::U8(x)    => Ok(Key::u64(x as u64)),\n            Value::U16(x)   => Ok(Key::u64(x as u64)),\n            Value::U32(x)   => Ok(Key::u64(x as u64)),\n            Value::U64(x)   => Ok(Key::u64(x)),\n            Value::Int(x)   => Ok(Key::Int(x)),\n            other           => Err(DecodeError::InvalidKey(other))\n        }\n    }\n\n}"],"decoder::Kernel":["impl<R: ReadBytesExt + ReadSlice> Kernel<R> {\n    /// Read `begin` as the length and return that many raw bytes as a slice.\n    ///\n    /// If length is greater than the given `max_len`, `DecodeError::TooLong`\n    /// is returned instead.\n    pub fn raw_slice(&mut self, begin: u8, max_len: usize) -> DecodeResult<&[u8]> {\n        let len = self.unsigned(begin)?;\n        if len > max_len as u64 {\n            return Err(DecodeError::TooLong { max: max_len, actual: len })\n        }\n        self.reader.read_slice(len as usize).map_err(From::from)\n    }\n}","impl<R: ReadBytesExt> Kernel<R> {\n    pub fn new(r: R) -> Kernel<R> {\n        Kernel { reader: r }\n    }\n\n    pub fn into_reader(self) -> R {\n        self.reader\n    }\n\n    pub fn typeinfo(&mut self) -> DecodeResult<TypeInfo> {\n        Type::read(&mut self.reader).map_err(From::from)\n    }\n\n    pub fn simple(&mut self, ti: &TypeInfo) -> DecodeResult<Simple> {\n        match ti.0 {\n            Type::Unassigned { major: 7, info: a } => Ok(Simple::Unassigned(a)),\n            Type::Reserved   { major: 7, info: a } => Ok(Simple::Reserved(a)),\n            _                                      => unexpected_type(ti)\n        }\n    }\n\n    pub fn bool(&mut self, ti: &TypeInfo) -> DecodeResult<bool> {\n        match *ti {\n            (Type::Bool, 20) => Ok(false),\n            (Type::Bool, 21) => Ok(true),\n            _                => unexpected_type(ti)\n        }\n    }\n\n    pub fn u8(&mut self, ti: &TypeInfo) -> DecodeResult<u8> {\n        match *ti {\n            (Type::UInt8, n @ 0...23) => Ok(n),\n            (Type::UInt8, 24) => self.reader.read_u8().map_err(From::from),\n            _                 => unexpected_type(ti)\n        }\n    }\n\n    pub fn u16(&mut self, ti: &TypeInfo) -> DecodeResult<u16> {\n        match *ti {\n            (Type::UInt8, n @ 0...23) => Ok(n as u16),\n            (Type::UInt8, 24)  => self.reader.read_u8().map(|n| n as u16).map_err(From::from),\n            (Type::UInt16, 25) => self.reader.read_u16::<BigEndian>().map_err(From::from),\n            _                  => unexpected_type(ti)\n        }\n    }\n\n    pub fn u32(&mut self, ti: &TypeInfo) -> DecodeResult<u32> {\n        match *ti {\n            (Type::UInt8, n @ 0...23) => Ok(n as u32),\n            (Type::UInt8, 24)  => self.reader.read_u8().map(|n| n as u32).map_err(From::from),\n            (Type::UInt16, 25) => self.reader.read_u16::<BigEndian>().map(|n| n as u32).map_err(From::from),\n            (Type::UInt32, 26) => self.reader.read_u32::<BigEndian>().map_err(From::from),\n            _                  => unexpected_type(ti)\n        }\n    }\n\n    pub fn u64(&mut self, ti: &TypeInfo) -> DecodeResult<u64> {\n        match *ti {\n            (Type::UInt8, n @ 0...23) => Ok(n as u64),\n            (Type::UInt8, 24)  => self.reader.read_u8().map(|n| n as u64).map_err(From::from),\n            (Type::UInt16, 25) => self.reader.read_u16::<BigEndian>().map(|n| n as u64).map_err(From::from),\n            (Type::UInt32, 26) => self.reader.read_u32::<BigEndian>().map(|n| n as u64).map_err(From::from),\n            (Type::UInt64, 27) => self.reader.read_u64::<BigEndian>().map_err(From::from),\n            _                  => unexpected_type(ti)\n        }\n    }\n\n    pub fn i8(&mut self, ti: &TypeInfo) -> DecodeResult<i8> {\n        match *ti {\n            (Type::Int8, n @ 0...23) => Ok(-1 - n as i8),\n            (Type::Int8, 24)         => read_signed_byte!(self, u8, i8, i8),\n            (Type::UInt8, _)         => cast_unsigned!(self, u8, ti, u8, i8, i8),\n            _                        => unexpected_type(ti)\n        }\n    }\n\n    pub fn i16(&mut self, ti: &TypeInfo) -> DecodeResult<i16> {\n        match *ti {\n            (Type::Int8, n @ 0...23) => Ok(-1 - n as i16),\n            (Type::Int8, 24)         => read_signed_byte!(self, u8, i16, i16),\n            (Type::Int16, 25)        => read_signed!(self, read_u16, u16, i16, i16),\n            (Type::UInt8, _)         => cast_unsigned!(self, u8, ti, u8, i16, i16),\n            (Type::UInt16, _)        => cast_unsigned!(self, u16, ti, u16, i16, i16),\n            _                        => unexpected_type(ti)\n        }\n    }\n\n    pub fn i32(&mut self, ti: &TypeInfo) -> DecodeResult<i32> {\n        match *ti {\n            (Type::Int8, n @ 0...23) => Ok(-1 - n as i32),\n            (Type::Int8, 24)         => read_signed_byte!(self, u8, i32, i32),\n            (Type::Int16, 25)        => read_signed!(self, read_u16, u16, i32, i32),\n            (Type::Int32, 26)        => read_signed!(self, read_u32, u32, i32, i32),\n            (Type::UInt8, _)         => cast_unsigned!(self, u8, ti, u8, i32, i32),\n            (Type::UInt16, _)        => cast_unsigned!(self, u16, ti, u16, i32, i32),\n            (Type::UInt32, _)        => cast_unsigned!(self, u32, ti, u32, i32, i32),\n            _                        => unexpected_type(ti)\n        }\n    }\n\n    pub fn i64(&mut self, ti: &TypeInfo) -> DecodeResult<i64> {\n        match *ti {\n            (Type::Int8, n @ 0...23) => Ok(-1 - n as i64),\n            (Type::Int8, 24)         => read_signed_byte!(self, u8, i64, i64),\n            (Type::Int16, 25)        => read_signed!(self, read_u16, u16, i64, i64),\n            (Type::Int32, 26)        => read_signed!(self, read_u32, u32, i64, i64),\n            (Type::Int64, 27)        => read_signed!(self, read_u64, u64, i64, i64),\n            (Type::UInt8, _)         => cast_unsigned!(self, u8, ti, u8, i64, i64),\n            (Type::UInt16, _)        => cast_unsigned!(self, u16, ti, u16, i64, i64),\n            (Type::UInt32, _)        => cast_unsigned!(self, u32, ti, u32, i64, i64),\n            (Type::UInt64, _)        => cast_unsigned!(self, u64, ti, u64, i64, i64),\n            _                        => unexpected_type(ti)\n        }\n    }\n\n    pub fn int(&mut self, ti: &TypeInfo) -> DecodeResult<Int> {\n        match *ti {\n              (Type::Int8, a)\n            | (Type::Int16, a)\n            | (Type::Int32, a)\n            | (Type::Int64, a) =>\n                self.unsigned(a).map(Int::Neg),\n\n              (Type::UInt8, a)\n            | (Type::UInt16, a)\n            | (Type::UInt32, a)\n            | (Type::UInt64, a) =>\n                self.unsigned(a).map(Int::Pos),\n\n            _ => unexpected_type(ti)\n        }\n    }\n\n    pub fn f16(&mut self, ti: &TypeInfo) -> DecodeResult<f32> {\n        match ti.0 {\n            Type::Float16 => {\n                // Copied from RFC 7049 Appendix D:\n                let half  = self.reader.read_u16::<BigEndian>()?;\n                let exp   = half >> 10 & 0x1F;\n                let mant  = half & 0x3FF;\n                let value = match exp {\n                    0  => ffi::c_ldexpf(mant as f32, -24),\n                    31 => if mant == 0 { f32::INFINITY } else { f32::NAN },\n                    _  => ffi::c_ldexpf(mant as f32 + 1024.0, exp as isize - 25)\n                };\n                Ok(if half & 0x8000 == 0 { value } else { - value })\n            }\n            _ => unexpected_type(ti)\n        }\n    }\n\n    pub fn f32(&mut self, ti: &TypeInfo) -> DecodeResult<f32> {\n        match ti.0 {\n            Type::Float32 => self.reader.read_f32::<BigEndian>().map_err(From::from),\n            _             => unexpected_type(ti)\n        }\n    }\n\n    pub fn f64(&mut self, ti: &TypeInfo) -> DecodeResult<f64> {\n        match ti.0 {\n            Type::Float64 => self.reader.read_f64::<BigEndian>().map_err(From::from),\n            _             => unexpected_type(ti)\n        }\n    }\n\n    /// Decode `first` and potentially the following bytes as an\n    /// unsigned value following the rules of major type 0.\n    pub fn unsigned(&mut self, first: u8) -> DecodeResult<u64> {\n        match first {\n            n @ 0...23 => Ok(n as u64),\n            24 => self.reader.read_u8().map(|n| n as u64).map_err(From::from),\n            25 => self.reader.read_u16::<BigEndian>().map(|n| n as u64).map_err(From::from),\n            26 => self.reader.read_u32::<BigEndian>().map(|n| n as u64).map_err(From::from),\n            27 => self.reader.read_u64::<BigEndian>().map_err(From::from),\n            _  => unexpected_type(&(Type::UInt64, first))\n        }\n    }\n\n    /// Read `begin` as the length and return that many raw bytes.\n    ///\n    /// If length is greater than the given `max_len`, `DecodeError::TooLong`\n    /// is returned instead.\n    pub fn raw_data(&mut self, begin: u8, max_len: usize) -> DecodeResult<Vec<u8>> {\n        let len = self.unsigned(begin)?;\n        if len > max_len as u64 {\n            return Err(DecodeError::TooLong { max: max_len, actual: len })\n        }\n        let n = len as usize;\n        let mut v = vec![0u8; n];\n        let mut i = 0;\n        while i < n {\n            match self.reader.read(&mut v[i..]) {\n                Ok(0)  => return Err(DecodeError::UnexpectedEOF),\n                Ok(j)  => i += j,\n                Err(e) =>\n                    if e.kind() != io::ErrorKind::Interrupted {\n                        return Err(DecodeError::IoError(e))\n                    }\n            }\n        }\n        Ok(v)\n    }\n\n    /// Read `begin` as the length and read that many raw bytes into `buf`.\n    ///\n    /// If length is greater than the given buffer, `DecodeError::TooLong`\n    /// is returned instead.\n    pub fn read_raw_data(&mut self, begin: u8, buf: &mut [u8]) -> DecodeResult<usize> {\n        let len = self.unsigned(begin)?;\n        if len > buf.len() as u64 {\n            return Err(DecodeError::TooLong { max: buf.len(), actual: len })\n        }\n        let n = len as usize;\n        let mut i = 0;\n        while i < n {\n            match self.reader.read(&mut buf[i..]) {\n                Ok(0)  => return Err(DecodeError::UnexpectedEOF),\n                Ok(j)  => i += j,\n                Err(e) =>\n                    if e.kind() != io::ErrorKind::Interrupted {\n                        return Err(DecodeError::IoError(e))\n                    }\n            }\n        }\n        Ok(n)\n    }\n}"],"decoder::TextIter":["impl<'r, R: 'r + ReadBytesExt> Iterator for TextIter<'r, R> {\n    type Item = DecodeResult<String>;\n\n    fn next(&mut self) -> Option<DecodeResult<String>> {\n        match or_break(self.decoder.text()) {\n            Ok(None)    => None,\n            Ok(Some(b)) => Some(Ok(b)),\n            Err(e)      => Some(Err(e))\n        }\n    }\n}"],"encoder::EncodeError":["Debug","impl Error for EncodeError {\n    fn description(&self) -> &str {\n        match *self {\n            EncodeError::IoError(_)            => \"i/o error\",\n            EncodeError::UnexpectedEOF         => \"unexpected eof\",\n            EncodeError::InvalidValue(_)       => \"invalid value\",\n            EncodeError::InvalidSimpleValue(_) => \"invalid simple value\",\n            EncodeError::Other(_)              => \"other error\"\n        }\n    }\n\n    fn cause(&self) -> Option<&Error> {\n        match *self {\n            EncodeError::IoError(ref e) => Some(e),\n            EncodeError::Other(ref e)   => Some(&**e),\n            _                           => None\n        }\n    }\n}","impl From<io::Error> for EncodeError {\n    fn from(e: io::Error) -> EncodeError {\n        EncodeError::IoError(e)\n    }\n}","impl fmt::Display for EncodeError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        match *self {\n            EncodeError::IoError(ref e)            => write!(f, \"EncodeError: I/O error: {}\", *e),\n            EncodeError::UnexpectedEOF             => write!(f, \"EncodeError: unexpected end-of-file\"),\n            EncodeError::InvalidValue(ref v)       => write!(f, \"EncodeError: invalid value {:?}\", v),\n            EncodeError::InvalidSimpleValue(ref s) => write!(f, \"EncodeError: invalid simple value {:?}\", s),\n            EncodeError::Other(ref e)              => write!(f, \"EncodeError: other error: {}\", e)\n        }\n    }\n}"],"encoder::Encoder":["impl<W: WriteBytesExt> Encoder<W> {\n    pub fn new(w: W) -> Encoder<W> {\n        Encoder { writer: w }\n    }\n\n    pub fn into_writer(self) -> W {\n        self.writer\n    }\n\n    pub fn writer(&mut self) -> &mut W {\n        &mut self.writer\n    }\n\n    pub fn u8(&mut self, x: u8) -> EncodeResult {\n        let ref mut w = self.writer;\n        match x {\n            0...23 => w.write_u8(x).map_err(From::from),\n            _      => w.write_u8(24).and(w.write_u8(x)).map_err(From::from)\n        }\n    }\n\n    pub fn u16(&mut self, x: u16) -> EncodeResult {\n        let ref mut w = self.writer;\n        match x {\n            0...23    => w.write_u8(x as u8).map_err(From::from),\n            24...0xFF => w.write_u8(24).and(w.write_u8(x as u8)).map_err(From::from),\n            _         => w.write_u8(25).and(w.write_u16::<BigEndian>(x)).map_err(From::from)\n        }\n    }\n\n    pub fn u32(&mut self, x: u32) -> EncodeResult {\n        let ref mut w = self.writer;\n        match x {\n            0...23         => w.write_u8(x as u8).map_err(From::from),\n            24...0xFF      => w.write_u8(24).and(w.write_u8(x as u8)).map_err(From::from),\n            0x100...0xFFFF => w.write_u8(25).and(w.write_u16::<BigEndian>(x as u16)).map_err(From::from),\n            _              => w.write_u8(26).and(w.write_u32::<BigEndian>(x)).map_err(From::from)\n        }\n    }\n\n    pub fn u64(&mut self, x: u64) -> EncodeResult {\n        let ref mut w = self.writer;\n        match x {\n            0...23                => w.write_u8(x as u8).map_err(From::from),\n            24...0xFF             => w.write_u8(24).and(w.write_u8(x as u8)).map_err(From::from),\n            0x100...0xFFFF        => w.write_u8(25).and(w.write_u16::<BigEndian>(x as u16)).map_err(From::from),\n            0x100000...0xFFFFFFFF => w.write_u8(26).and(w.write_u32::<BigEndian>(x as u32)).map_err(From::from),\n            _                     => w.write_u8(27).and(w.write_u64::<BigEndian>(x)).map_err(From::from)\n        }\n    }\n\n    pub fn i8(&mut self, x: i8) -> EncodeResult {\n        if x >= 0 {\n            self.u8(x as u8)\n        } else {\n            let ref mut w = self.writer;\n            match (-1 - x) as u8 {\n                n @ 0...23 => w.write_u8(0b001_00000 | n).map_err(From::from),\n                n          => w.write_u8(0b001_00000 | 24).and(w.write_u8(n)).map_err(From::from)\n            }\n        }\n    }\n\n    pub fn i16(&mut self, x: i16) -> EncodeResult {\n        if x >= 0 {\n            self.u16(x as u16)\n        } else {\n            let ref mut w = self.writer;\n            match (-1 - x) as u16 {\n                n @ 0...23    => w.write_u8(0b001_00000 | n as u8).map_err(From::from),\n                n @ 24...0xFF => w.write_u8(0b001_00000 | 24).and(w.write_u8(n as u8)).map_err(From::from),\n                n             => w.write_u8(0b001_00000 | 25).and(w.write_u16::<BigEndian>(n)).map_err(From::from)\n            }\n        }\n    }\n\n    pub fn i32(&mut self, x: i32) -> EncodeResult {\n        if x >= 0 {\n            self.u32(x as u32)\n        } else {\n            let ref mut w = self.writer;\n            match (-1 - x) as u32 {\n                n @ 0...23         => w.write_u8(0b001_00000 | n as u8).map_err(From::from),\n                n @ 24...0xFF      => w.write_u8(0b001_00000 | 24).and(w.write_u8(n as u8)).map_err(From::from),\n                n @ 0x100...0xFFFF => w.write_u8(0b001_00000 | 25).and(w.write_u16::<BigEndian>(n as u16)).map_err(From::from),\n                n                  => w.write_u8(0b001_00000 | 26).and(w.write_u32::<BigEndian>(n)).map_err(From::from)\n            }\n        }\n    }\n\n    pub fn i64(&mut self, x: i64) -> EncodeResult {\n        if x >= 0 {\n            self.u64(x as u64)\n        } else {\n            let ref mut w = self.writer;\n            match (-1 - x) as u64 {\n                n @ 0...23                => w.write_u8(0b001_00000 | n as u8).map_err(From::from),\n                n @ 24...0xFF             => w.write_u8(0b001_00000 | 24).and(w.write_u8(n as u8)).map_err(From::from),\n                n @ 0x100...0xFFFF        => w.write_u8(0b001_00000 | 25).and(w.write_u16::<BigEndian>(n as u16)).map_err(From::from),\n                n @ 0x100000...0xFFFFFFFF => w.write_u8(0b001_00000 | 26).and(w.write_u32::<BigEndian>(n as u32)).map_err(From::from),\n                n                         => w.write_u8(0b001_00000 | 27).and(w.write_u64::<BigEndian>(n)).map_err(From::from)\n            }\n        }\n    }\n\n    pub fn int(&mut self, x: Int) -> EncodeResult {\n        match x {\n            Int::Pos(v) => self.u64(v),\n            Int::Neg(v) => {\n                let ref mut w = self.writer;\n                match v {\n                    n @ 0...23                => w.write_u8(0b001_00000 | n as u8).map_err(From::from),\n                    n @ 24...0xFF             => w.write_u8(0b001_00000 | 24).and(w.write_u8(n as u8)).map_err(From::from),\n                    n @ 0x100...0xFFFF        => w.write_u8(0b001_00000 | 25).and(w.write_u16::<BigEndian>(n as u16)).map_err(From::from),\n                    n @ 0x100000...0xFFFFFFFF => w.write_u8(0b001_00000 | 26).and(w.write_u32::<BigEndian>(n as u32)).map_err(From::from),\n                    n                         => w.write_u8(0b001_00000 | 27).and(w.write_u64::<BigEndian>(n)).map_err(From::from)\n                }\n            }\n        }\n    }\n\n    pub fn f32(&mut self, x: f32) -> EncodeResult {\n        self.writer.write_u8(0b111_00000 | 26)\n            .and(self.writer.write_f32::<BigEndian>(x))\n            .map_err(From::from)\n    }\n\n    pub fn f64(&mut self, x: f64) -> EncodeResult {\n        self.writer.write_u8(0b111_00000 | 27)\n            .and(self.writer.write_f64::<BigEndian>(x))\n            .map_err(From::from)\n    }\n\n    pub fn bool(&mut self, x: bool) -> EncodeResult {\n        self.writer.write_u8(0b111_00000 | if x {21} else {20}).map_err(From::from)\n    }\n\n    pub fn simple(&mut self, x: Simple) -> EncodeResult {\n        let ref mut w = self.writer;\n        match x {\n            Simple::Unassigned(n) => match n {\n                0...19 | 28...30 => w.write_u8(0b111_00000 | n).map_err(From::from),\n                32...255         => w.write_u8(0b111_00000 | 24).and(w.write_u8(n)).map_err(From::from),\n                _                => Err(EncodeError::InvalidSimpleValue(x))\n            },\n            Simple::Reserved(n) => match n {\n                0...31 => w.write_u8(0b111_00000 | 24).and(w.write_u8(n)).map_err(From::from),\n                _      => Err(EncodeError::InvalidSimpleValue(x))\n            }\n        }\n    }\n\n    pub fn bytes(&mut self, x: &[u8]) -> EncodeResult {\n        self.type_len(Type::Bytes, x.len() as u64)\n            .and(self.writer.write_all(x).map_err(From::from))\n    }\n\n    /// Indefinite byte string encoding. (RFC 7049 section 2.2.2)\n    pub fn bytes_iter<'r, I: Iterator<Item=&'r [u8]>>(&mut self, iter: I) -> EncodeResult {\n        self.writer.write_u8(0b010_11111)?;\n        for x in iter {\n            self.bytes(x)?\n        }\n        self.writer.write_u8(0b111_11111).map_err(From::from)\n    }\n\n    pub fn text(&mut self, x: &str) -> EncodeResult {\n        self.type_len(Type::Text, x.len() as u64)\n            .and(self.writer.write_all(x.as_bytes()).map_err(From::from))\n    }\n\n    /// Indefinite string encoding. (RFC 7049 section 2.2.2)\n    pub fn text_iter<'r, I: Iterator<Item=&'r str>>(&mut self, iter: I) -> EncodeResult {\n        self.writer.write_u8(0b011_11111)?;\n        for x in iter {\n            self.text(x)?\n        }\n        self.writer.write_u8(0b111_11111).map_err(From::from)\n    }\n\n    pub fn null(&mut self) -> EncodeResult {\n        self.writer.write_u8(0b111_00000 | 22).map_err(From::from)\n    }\n\n    pub fn undefined(&mut self) -> EncodeResult {\n        self.writer.write_u8(0b111_00000 | 23).map_err(From::from)\n    }\n\n    pub fn tag(&mut self, x: Tag) -> EncodeResult {\n        self.type_len(Type::Tagged, x.to())\n    }\n\n    pub fn array(&mut self, len: usize) -> EncodeResult {\n        self.type_len(Type::Array, len as u64)\n    }\n\n    /// Indefinite array encoding. (RFC 7049 section 2.2.1)\n    pub fn array_begin(&mut self) -> EncodeResult {\n        self.writer.write_u8(0b100_11111).map_err(From::from)\n    }\n\n    /// End of indefinite array encoding. (RFC 7049 section 2.2.1)\n    pub fn array_end(&mut self) -> EncodeResult {\n        self.writer.write_u8(0b111_11111).map_err(From::from)\n    }\n\n    pub fn object(&mut self, len: usize) -> EncodeResult {\n        self.type_len(Type::Object, len as u64)\n    }\n\n    /// Indefinite object encoding. (RFC 7049 section 2.2.1)\n    pub fn object_begin(&mut self) -> EncodeResult {\n        self.writer.write_u8(0b101_11111).map_err(From::from)\n    }\n\n    /// End of indefinite object encoding. (RFC 7049 section 2.2.1)\n    pub fn object_end(&mut self) -> EncodeResult {\n        self.writer.write_u8(0b111_11111).map_err(From::from)\n    }\n\n    fn type_len(&mut self, t: Type, x: u64) -> EncodeResult {\n        let ref mut w = self.writer;\n        match x {\n            0...23                => w.write_u8(t.major() << 5 | x as u8).map_err(From::from),\n            24...0xFF             => w.write_u8(t.major() << 5 | 24).and(w.write_u8(x as u8)).map_err(From::from),\n            0x100...0xFFFF        => w.write_u8(t.major() << 5 | 25).and(w.write_u16::<BigEndian>(x as u16)).map_err(From::from),\n            0x100000...0xFFFFFFFF => w.write_u8(t.major() << 5 | 26).and(w.write_u32::<BigEndian>(x as u32)).map_err(From::from),\n            _                     => w.write_u8(t.major() << 5 | 27).and(w.write_u64::<BigEndian>(x)).map_err(From::from)\n        }\n    }\n}"],"encoder::GenericEncoder":["impl<W: WriteBytesExt> GenericEncoder<W> {\n    pub fn new(w: W) -> GenericEncoder<W> {\n        GenericEncoder { encoder: Encoder::new(w) }\n    }\n\n    pub fn from_encoder(e: Encoder<W>) -> GenericEncoder<W> {\n        GenericEncoder { encoder: e }\n    }\n\n    pub fn into_inner(self) -> Encoder<W> {\n        self.encoder\n    }\n\n    pub fn borrow_mut(&mut self) -> &mut Encoder<W> {\n        &mut self.encoder\n    }\n\n    pub fn value(&mut self, x: &Value) -> EncodeResult {\n        match *x {\n            Value::Array(ref vv) => {\n                self.encoder.array(vv.len())?;\n                for v in vv {\n                    self.value(v)?\n                }\n                Ok(())\n            }\n            Value::Bytes(Bytes::Bytes(ref bb))  => self.encoder.bytes(&bb[..]),\n            Value::Bytes(Bytes::Chunks(ref bb)) => self.encoder.bytes_iter(bb.iter().map(|v| &v[..])),\n            Value::Text(Text::Text(ref txt))    => self.encoder.text(txt),\n            Value::Text(Text::Chunks(ref txt))  => self.encoder.text_iter(txt.iter().map(|v| &v[..])),\n            Value::Map(ref m) => {\n                self.encoder.object(m.len())?;\n                for (k, v) in m {\n                    self.key(k).and(self.value(v))?\n                }\n                Ok(())\n            }\n            Value::Tagged(t, ref val) => {\n                self.encoder.tag(t)?;\n                self.value(&*val)\n            }\n            Value::Undefined => self.encoder.undefined(),\n            Value::Null      => self.encoder.null(),\n            Value::Simple(s) => self.encoder.simple(s),\n            Value::Bool(b)   => self.encoder.bool(b),\n            Value::U8(n)     => self.encoder.u8(n),\n            Value::U16(n)    => self.encoder.u16(n),\n            Value::U32(n)    => self.encoder.u32(n),\n            Value::U64(n)    => self.encoder.u64(n),\n            Value::F32(n)    => self.encoder.f32(n),\n            Value::F64(n)    => self.encoder.f64(n),\n            Value::I8(n)     => self.encoder.i8(n),\n            Value::I16(n)    => self.encoder.i16(n),\n            Value::I32(n)    => self.encoder.i32(n),\n            Value::I64(n)    => self.encoder.i64(n),\n            Value::Int(n)    => self.encoder.int(n),\n            Value::Break     => Err(EncodeError::InvalidValue(Value::Break))\n        }\n    }\n\n    fn key(&mut self, x: &Key) -> EncodeResult {\n        match *x {\n            Key::Bool(b) => self.encoder.bool(b),\n            Key::Int(n)  => self.encoder.int(n),\n            Key::Bytes(Bytes::Bytes(ref bb))  => self.encoder.bytes(&bb[..]),\n            Key::Bytes(Bytes::Chunks(ref bb)) => self.encoder.bytes_iter(bb.iter().map(|v| &v[..])),\n            Key::Text(Text::Text(ref txt))    => self.encoder.text(txt),\n            Key::Text(Text::Chunks(ref txt))  => self.encoder.text_iter(txt.iter().map(|v| &v[..]))\n        }\n    }\n}"],"slice::ReadSliceError":["Debug","impl Error for ReadSliceError {\n    fn description(&self) -> &str {\n        \"ReadSliceError\"\n    }\n\n    fn cause(&self) -> Option<&Error> {\n        match *self {\n            ReadSliceError::IoError(ref e) => Some(e),\n            _                              => None\n        }\n    }\n}","impl fmt::Display for ReadSliceError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        match *self {\n            ReadSliceError::IoError(ref e)   => write!(f, \"ReadSliceError: I/O error: {}\", *e),\n            ReadSliceError::InsufficientData => write!(f, \"ReadSliceError: not enough data available\")\n        }\n    }\n}"],"std::io::Cursor":["impl ReadSlice for Cursor<Vec<u8>> {\n    fn read_slice(&mut self, n: usize) -> Result<&[u8], ReadSliceError> {\n        let start = self.position() as usize;\n        if self.get_ref().len() - start < n {\n            return Err(ReadSliceError::InsufficientData)\n        }\n        self.set_position((start + n) as u64);\n        Ok(&self.get_ref()[start .. start + n])\n    }\n}","impl<'r> ReadSlice for Cursor<&'r [u8]> {\n    fn read_slice(&mut self, n: usize) -> Result<&[u8], ReadSliceError> {\n        let start = self.position() as usize;\n        if self.get_ref().len() - start < n {\n            return Err(ReadSliceError::InsufficientData)\n        }\n        self.set_position((start + n) as u64);\n        Ok(&self.get_ref()[start .. start + n])\n    }\n}"],"types::Tag":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Tag {\n    pub fn of(x: u64) -> Tag {\n        match x {\n            0     => Tag::DateTime,\n            1     => Tag::Timestamp,\n            2     => Tag::Bignum,\n            3     => Tag::NegativeBignum,\n            4     => Tag::Decimal,\n            5     => Tag::Bigfloat,\n            21    => Tag::ToBase64Url,\n            22    => Tag::ToBase64,\n            23    => Tag::ToBase16,\n            24    => Tag::Cbor,\n            32    => Tag::Uri,\n            33    => Tag::Base64Url,\n            34    => Tag::Base64,\n            35    => Tag::Regex,\n            36    => Tag::Mime,\n            55799 => Tag::CborSelf,\n            _     => Tag::Unassigned(x)\n        }\n    }\n\n    pub fn to(&self) -> u64 {\n        match *self {\n            Tag::DateTime       => 0,\n            Tag::Timestamp      => 1,\n            Tag::Bignum         => 2,\n            Tag::NegativeBignum => 3,\n            Tag::Decimal        => 4,\n            Tag::Bigfloat       => 5,\n            Tag::ToBase64Url    => 21,\n            Tag::ToBase64       => 22,\n            Tag::ToBase16       => 23,\n            Tag::Cbor           => 24,\n            Tag::Uri            => 32,\n            Tag::Base64Url      => 33,\n            Tag::Base64         => 34,\n            Tag::Regex          => 35,\n            Tag::Mime           => 36,\n            Tag::CborSelf       => 55799,\n            Tag::Unassigned(x)  => x\n        }\n    }\n}"],"types::Type":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Type {\n    pub fn major(&self) -> u8 {\n        match *self {\n            Type::Array => 4,\n            Type::Bool  => 7,\n            Type::Break => 7,\n            Type::Bytes => 2,\n            Type::Float16 => 7,\n            Type::Float32 => 7,\n            Type::Float64 => 7,\n            Type::Int16   => 1,\n            Type::Int32   => 1,\n            Type::Int64   => 1,\n            Type::Int8    => 1,\n            Type::Null    => 7,\n            Type::Object  => 5,\n            Type::Tagged  => 6,\n            Type::Text    => 3,\n            Type::UInt16  => 0,\n            Type::UInt32  => 0,\n            Type::UInt64  => 0,\n            Type::UInt8   => 0,\n            Type::Undefined => 7,\n            Type::Unknown { major: m, .. } => m,\n            Type::Reserved { major: m, .. } => m,\n            Type::Unassigned { major: m, .. } => m\n        }\n    }\n\n    pub fn read<R: ReadBytesExt>(r: &mut R) -> Result<(Type, u8), Error> {\n        let b = r.read_u8()?;\n        match ((b & 0b111_00000) >> 5, b & 0b000_11111) {\n            (0, a @ 0...24)  => Ok((Type::UInt8, a)),\n            (0, 25)          => Ok((Type::UInt16, 25)),\n            (0, 26)          => Ok((Type::UInt32, 26)),\n            (0, 27)          => Ok((Type::UInt64, 27)),\n            (1, a @ 0...24)  => Ok((Type::Int8, a)),\n            (1, 25)          => Ok((Type::Int16, 25)),\n            (1, 26)          => Ok((Type::Int32, 26)),\n            (1, 27)          => Ok((Type::Int64, 27)),\n            (2, a)           => Ok((Type::Bytes, a)),\n            (3, a)           => Ok((Type::Text, a)),\n            (4, a)           => Ok((Type::Array, a)),\n            (5, a)           => Ok((Type::Object, a)),\n            (6, a)           => Ok((Type::Tagged, a)),\n            (7, a @ 0...19)  => Ok((Type::Unassigned { major: 7, info: a }, a)),\n            (7, 20)          => Ok((Type::Bool, 20)),\n            (7, 21)          => Ok((Type::Bool, 21)),\n            (7, 22)          => Ok((Type::Null, 22)),\n            (7, 23)          => Ok((Type::Undefined, 23)),\n            (7, 24)          => match r.read_u8()? {\n                a @ 0...31 => Ok((Type::Reserved { major: 7, info: a }, a)),\n                a          => Ok((Type::Unassigned { major: 7, info: a }, a))\n            },\n            (7, 25)          => Ok((Type::Float16, 25)),\n            (7, 26)          => Ok((Type::Float32, 26)),\n            (7, 27)          => Ok((Type::Float64, 27)),\n            (7, a @ 28...30) => Ok((Type::Unassigned { major: 7, info: a }, a)),\n            (7, 31)          => Ok((Type::Break, 31)),\n            (m, a)           => Ok((Type::Unknown { major: m, info: a }, a))\n        }\n    }\n}"],"value::Bytes":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd"],"value::Cursor":["impl<'r> Cursor<'r> {\n    pub fn new(v: &'r Value) -> Cursor<'r> {\n        Cursor { value: Some(v) }\n    }\n\n    fn of(v: Option<&'r Value>) -> Cursor<'r> {\n        Cursor { value: v }\n    }\n\n    pub fn at(&self, i: usize) -> Cursor<'r> {\n        match self.value {\n            Some(&Value::Array(ref a)) => Cursor::of(a.get(i)),\n            _                          => Cursor::of(None)\n        }\n    }\n\n    pub fn get(&self, k: Key) -> Cursor<'r> {\n        match self.value {\n            Some(&Value::Map(ref m)) => Cursor::of(m.get(&k)),\n            _                        => Cursor::of(None)\n        }\n    }\n\n    pub fn field(&self, s: &str) -> Cursor<'r> {\n        self.get(Key::Text(Text::Text(String::from(s))))\n    }\n\n    pub fn value(&self) -> Option<&Value> {\n        self.value\n    }\n\n    pub fn opt(&self) -> Option<Cursor<'r>> {\n        match self.value {\n            Some(&Value::Null) => None,\n            Some(ref v)        => Some(Cursor::new(v)),\n            _                  => None\n        }\n    }\n\n    pub fn maybe(&self) -> Option<Cursor<'r>> {\n        match self.value {\n            Some(&Value::Undefined) => None,\n            Some(ref v)             => Some(Cursor::new(v)),\n            _                       => None\n        }\n    }\n\n    pub fn bool(&self) -> Option<bool> {\n        match self.value {\n            Some(&Value::Bool(x)) => Some(x),\n            _                     => None\n        }\n    }\n\n    pub fn bytes(&self) -> Option<&Bytes> {\n        match self.value {\n            Some(&Value::Bytes(ref x)) => Some(x),\n            _                          => None\n        }\n    }\n\n    pub fn bytes_plain(&self) -> Option<&Vec<u8>> {\n        match self.value {\n            Some(&Value::Bytes(Bytes::Bytes(ref x))) => Some(x),\n            _                                        => None\n        }\n    }\n\n    pub fn bytes_chunked(&self) -> Option<&LinkedList<Vec<u8>>> {\n        match self.value {\n            Some(&Value::Bytes(Bytes::Chunks(ref x))) => Some(x),\n            _                                         => None\n        }\n    }\n\n    pub fn text(&self) -> Option<&Text> {\n        match self.value {\n            Some(&Value::Text(ref x)) => Some(x),\n            _                         => None\n        }\n    }\n\n    pub fn text_plain(&self) -> Option<&String> {\n        match self.value {\n            Some(&Value::Text(Text::Text(ref x))) => Some(x),\n            _                                     => None\n        }\n    }\n\n    pub fn text_chunked(&self) -> Option<&LinkedList<String>> {\n        match self.value {\n            Some(&Value::Text(Text::Chunks(ref x))) => Some(x),\n            _                                       => None\n        }\n    }\n\n    pub fn float32(&self) -> Option<f32> {\n        match self.value {\n            Some(&Value::F32(x)) => Some(x),\n            _                    => None\n        }\n    }\n\n    pub fn float64(&self) -> Option<f64> {\n        match self.value {\n            Some(&Value::F64(x)) => Some(x),\n            _                    => None\n        }\n    }\n\n    pub fn u8(&self) -> Option<u8> {\n        match self.value {\n            Some(&Value::U8(x)) => Some(x),\n            _                   => None\n        }\n    }\n\n    pub fn u16(&self) -> Option<u16> {\n        match self.value {\n            Some(&Value::U16(x)) => Some(x),\n            _                    => None\n        }\n    }\n\n    pub fn u32(&self) -> Option<u32> {\n        match self.value {\n            Some(&Value::U32(x)) => Some(x),\n            _                    => None\n        }\n    }\n\n    pub fn u64(&self) -> Option<u64> {\n        match self.value {\n            Some(&Value::U64(x)) => Some(x),\n            _                    => None\n        }\n    }\n\n    pub fn i8(&self) -> Option<i8> {\n        match self.value {\n            Some(&Value::I8(x)) => Some(x),\n            _                   => None\n        }\n    }\n\n    pub fn i16(&self) -> Option<i16> {\n        match self.value {\n            Some(&Value::I16(x)) => Some(x),\n            _                    => None\n        }\n    }\n\n    pub fn i32(&self) -> Option<i32> {\n        match self.value {\n            Some(&Value::I32(x)) => Some(x),\n            _                    => None\n        }\n    }\n\n    pub fn i64(&self) -> Option<i64> {\n        match self.value {\n            Some(&Value::I64(x)) => Some(x),\n            _                    => None\n        }\n    }\n}"],"value::Int":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Int {\n    pub fn from_u64(n: u64) -> Int {\n        Int::Pos(n)\n    }\n\n    pub fn from_i64(n: i64) -> Int {\n        if n < 0 {\n            Int::Neg(i64::abs(n) as u64 - 1)\n        } else {\n            Int::Pos(n as u64)\n        }\n    }\n\n    /// Map this value to an `i64`. If the value does not\n    /// fit within `[i64::MIN, i64::MAX]`, `None` is returned instead.\n    pub fn i64(&self) -> Option<i64> {\n        match *self {\n            Int::Neg(n) if n <= i64::MAX as u64 => Some(-1 - n as i64),\n            Int::Pos(n) if n <= i64::MAX as u64 => Some(n as i64),\n            _ => None\n        }\n    }\n\n    /// Map this value to a `u64`. If the value is negative,\n    /// `None` is returned instead.\n    pub fn u64(&self) -> Option<u64> {\n        match *self {\n            Int::Pos(n) => Some(n),\n            _           => None\n        }\n    }\n}"],"value::Key":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Key {\n    pub fn u64(n: u64) -> Key {\n        Key::Int(Int::from_u64(n))\n    }\n\n    pub fn i64(n: i64) -> Key {\n        Key::Int(Int::from_i64(n))\n    }\n}"],"value::Simple":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd"],"value::Text":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd"],"value::Value":["Clone","Debug","PartialEq","PartialOrd"]},"single_path_import":{"decoder::Config":"Config","decoder::DecodeError":"DecodeError","decoder::DecodeResult":"DecodeResult","decoder::Decoder":"Decoder","decoder::GenericDecoder":"GenericDecoder","decoder::maybe":"maybe","decoder::opt":"opt","decoder::or_break":"or_break","encoder::EncodeError":"EncodeError","encoder::EncodeResult":"EncodeResult","encoder::Encoder":"Encoder","encoder::GenericEncoder":"GenericEncoder"},"srcs":{"<A as skip::Skip>::skip":["/// `n` must be in range `[0, i64::MAX]`.\nfn skip(&mut self, n: u64) -> Result<()>{\n        if n > i64::MAX as u64 {\n            return Err(Error::new(ErrorKind::Other, \"n too large\"))\n        }\n        self.seek(SeekFrom::Current(n as i64)).and(Ok(()))\n    }","Real(LocalPath(\"src/skip.rs\"))"],"<decoder::BytesIter<'r, R> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<DecodeResult<Vec<u8>>>{\n        match or_break(self.decoder.bytes()) {\n            Ok(None)    => None,\n            Ok(Some(b)) => Some(Ok(b)),\n            Err(e)      => Some(Err(e))\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"<decoder::DecodeError as std::convert::From<slice::ReadSliceError>>::from":["fn from(e: ReadSliceError) -> DecodeError{\n        match e {\n            ReadSliceError::InsufficientData => DecodeError::UnexpectedEOF,\n            ReadSliceError::IoError(e)       => DecodeError::IoError(e)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"<decoder::DecodeError as std::convert::From<std::io::Error>>::from":["fn from(e: io::Error) -> DecodeError{\n        DecodeError::IoError(e)\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"<decoder::DecodeError as std::convert::From<std::str::Utf8Error>>::from":["fn from(e: Utf8Error) -> DecodeError{\n        DecodeError::InvalidUtf8(e)\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"<decoder::DecodeError as std::convert::From<std::string::FromUtf8Error>>::from":["fn from(e: string::FromUtf8Error) -> DecodeError{\n        DecodeError::InvalidUtf8(e.utf8_error())\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"<decoder::DecodeError as std::error::Error>::cause":["fn cause(&self) -> Option<&Error>{\n        match *self {\n            DecodeError::IoError(ref e)     => Some(e),\n            DecodeError::InvalidUtf8(ref e) => Some(e),\n            DecodeError::Other(ref e)       => Some(&**e),\n            _                               => None\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"<decoder::DecodeError as std::error::Error>::description":["fn description(&self) -> &str{\n        match *self {\n            DecodeError::DuplicateKey(_)    => \"duplicate key in objects\",\n            DecodeError::IntOverflow(_)     => \"integer overflow\",\n            DecodeError::InvalidKey(_)      => \"invalid object key\",\n            DecodeError::InvalidTag(_)      => \"invalid tag\",\n            DecodeError::InvalidUtf8(_)     => \"invalid utf-8\",\n            DecodeError::IoError(_)         => \"i/o error\",\n            DecodeError::TooNested          => \"too deeply nested objects/arrays\",\n            DecodeError::UnexpectedEOF      => \"unexpected eof\",\n            DecodeError::UnexpectedBreak    => \"unexpected break\",\n            DecodeError::Other(_)           => \"other error\",\n            DecodeError::TooLong{..}        => \"value is too long\",\n            DecodeError::UnexpectedType{..} => \"unexpected type\"\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"<decoder::DecodeError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error>{\n        match *self {\n            DecodeError::DuplicateKey(ref k) => write!(f, \"DecodeError: duplicate key: {:?}\", *k),\n            DecodeError::IntOverflow(n)      => write!(f, \"DecodeError: integer overflow: {}\", n),\n            DecodeError::InvalidKey(ref k)   => write!(f, \"DecodeError: unsuitable map key: {:?}\", *k),\n            DecodeError::InvalidTag(ref v)   => write!(f, \"DecodeError: value does not match tag: {:?}\", *v),\n            DecodeError::InvalidUtf8(ref e)  => write!(f, \"DecodeError: Invalid UTF-8 encoding: {}\", *e),\n            DecodeError::IoError(ref e)      => write!(f, \"DecodeError: I/O error: {}\", *e),\n            DecodeError::TooNested           => write!(f, \"DecodeError: value is too nested\"),\n            DecodeError::UnexpectedEOF       => write!(f, \"DecodeError: unexpected end-of-file\"),\n            DecodeError::UnexpectedBreak     => write!(f, \"DecodeError: unexpected break\"),\n            DecodeError::Other(ref e)        => write!(f, \"DecodeError: other: {:?}\", e),\n            DecodeError::TooLong{max:m, actual:a} => write!(f, \"DecodeError: value is too long {} (max={})\", a, m),\n            DecodeError::UnexpectedType{datatype:t, info:i} => write!(f, \"DecodeError: unexpected type {:?} (info={})\", t, i)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"<decoder::TextIter<'r, R> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<DecodeResult<String>>{\n        match or_break(self.decoder.text()) {\n            Ok(None)    => None,\n            Ok(Some(b)) => Some(Ok(b)),\n            Err(e)      => Some(Err(e))\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"<encoder::EncodeError as std::convert::From<std::io::Error>>::from":["fn from(e: io::Error) -> EncodeError{\n        EncodeError::IoError(e)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"<encoder::EncodeError as std::error::Error>::cause":["fn cause(&self) -> Option<&Error>{\n        match *self {\n            EncodeError::IoError(ref e) => Some(e),\n            EncodeError::Other(ref e)   => Some(&**e),\n            _                           => None\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"<encoder::EncodeError as std::error::Error>::description":["fn description(&self) -> &str{\n        match *self {\n            EncodeError::IoError(_)            => \"i/o error\",\n            EncodeError::UnexpectedEOF         => \"unexpected eof\",\n            EncodeError::InvalidValue(_)       => \"invalid value\",\n            EncodeError::InvalidSimpleValue(_) => \"invalid simple value\",\n            EncodeError::Other(_)              => \"other error\"\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"<encoder::EncodeError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error>{\n        match *self {\n            EncodeError::IoError(ref e)            => write!(f, \"EncodeError: I/O error: {}\", *e),\n            EncodeError::UnexpectedEOF             => write!(f, \"EncodeError: unexpected end-of-file\"),\n            EncodeError::InvalidValue(ref v)       => write!(f, \"EncodeError: invalid value {:?}\", v),\n            EncodeError::InvalidSimpleValue(ref s) => write!(f, \"EncodeError: invalid simple value {:?}\", s),\n            EncodeError::Other(ref e)              => write!(f, \"EncodeError: other error: {}\", e)\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"<slice::ReadSliceError as std::error::Error>::cause":["fn cause(&self) -> Option<&Error>{\n        match *self {\n            ReadSliceError::IoError(ref e) => Some(e),\n            _                              => None\n        }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::ReadSliceError as std::error::Error>::description":["fn description(&self) -> &str{\n        \"ReadSliceError\"\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<slice::ReadSliceError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error>{\n        match *self {\n            ReadSliceError::IoError(ref e)   => write!(f, \"ReadSliceError: I/O error: {}\", *e),\n            ReadSliceError::InsufficientData => write!(f, \"ReadSliceError: not enough data available\")\n        }\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<std::io::Cursor<&'r [u8]> as slice::ReadSlice>::read_slice":["fn read_slice(&mut self, n: usize) -> Result<&[u8], ReadSliceError>{\n        let start = self.position() as usize;\n        if self.get_ref().len() - start < n {\n            return Err(ReadSliceError::InsufficientData)\n        }\n        self.set_position((start + n) as u64);\n        Ok(&self.get_ref()[start .. start + n])\n    }","Real(LocalPath(\"src/slice.rs\"))"],"<std::io::Cursor<std::vec::Vec<u8>> as slice::ReadSlice>::read_slice":["fn read_slice(&mut self, n: usize) -> Result<&[u8], ReadSliceError>{\n        let start = self.position() as usize;\n        if self.get_ref().len() - start < n {\n            return Err(ReadSliceError::InsufficientData)\n        }\n        self.set_position((start + n) as u64);\n        Ok(&self.get_ref()[start .. start + n])\n    }","Real(LocalPath(\"src/slice.rs\"))"],"decoder::BytesIter":["/// Iterator over the chunks of an indefinite bytes item.\npub struct BytesIter<'r, R: 'r> {\n    decoder: &'r mut Decoder<R>\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Config":["/// `Config` contains various settings which limit resource consumption\n/// or enable certain validation options. Please note that the various\n/// maximum length/size values apply to an individual element only.\n///\n/// This is mainly to prevent attackers from providing CBOR values whose\n/// length is larger than the available memory. In combination the memory\n/// consumption can still become large and it is best to limit the incoming\n/// bytes to a specific upper bound, e.g. by using `std::io::Take`.\npub struct Config {\n    /// Maximum number of array elements\n    pub max_len_array: usize,\n    /// Maximum length of a byte string\n    pub max_len_bytes: usize,\n    /// Maximum length of a string\n    pub max_len_text: usize,\n    /// Maximum number of object fields\n    pub max_size_map: usize,\n    /// Maximum recursion steps when decoder `Value`s\n    pub max_nesting: usize,\n    /// Ignore `Tag`s when decoding `Value`s\n    pub skip_tags: bool,\n    /// Validate `Value` type matches `Tag`.\n    pub check_tags: bool\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Config::default":["/// Create default configuration with\n///\n/// - `max_len_array` = 1000\n/// - `max_len_bytes` = 5 MB\n/// - `max_len_text` = 5 MB\n/// - `max_size_map` = 1000\n/// - `max_nesting` = 16\n/// - `skip_tags` = false\n/// - `check_tags` = true\npub fn default() -> Config{ DEFAULT_CONFIG }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::DecodeError":["pub enum DecodeError {\n    /// An object contains the same key multiple times\n    DuplicateKey(Key),\n    /// The signed integer is greater that its max value\n    IntOverflow(u64),\n    /// The decoded `Value` can not serve as a `Key` in an object\n    InvalidKey(Value),\n    /// The type of `Value` is not what is expected for a `Tag`\n    InvalidTag(Value),\n    /// The string is not encoded in UTF-8\n    InvalidUtf8(Utf8Error),\n    /// Some I/O error\n    IoError(io::Error),\n    /// The maximum configured length is exceeded\n    TooLong { max: usize, actual: u64 },\n    /// `Value`s are nested deeper than the configured maximum\n    TooNested,\n    /// The end of file has been encountered unexpectedly\n    UnexpectedEOF,\n    /// And unexpected type has been encountered\n    UnexpectedType { datatype: Type, info: u8 },\n    /// A break was encountered at some unexpected point while\n    /// decoding an indefinite object.\n    UnexpectedBreak,\n    /// Some other error.\n    Other(Box<Error + Send + Sync>)\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder":["/// The actual decoder type definition\npub struct Decoder<R> {\n    kernel: Kernel<R>,\n    config: Config\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::array":["/// Decode the begin of an array. The length is returned unless it\n/// exceeds the configured maximum.\n///\n/// Please note that indefinite arrays are not supported by this method\n/// (Consider using `Decoder::array_begin()` for this use-case).\npub fn array(&mut self) -> DecodeResult<usize>{\n        match self.typeinfo()? {\n            (Type::Array, 31) => unexpected_type(&(Type::Array, 31)),\n            (Type::Array,  a) => {\n                let len = self.kernel.unsigned(a)?;\n                if len > self.config.max_len_array as u64 {\n                    return Err(DecodeError::TooLong { max: self.config.max_len_array, actual: len })\n                }\n                Ok(len as usize)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::array_begin":["/// Decode the begin of an indefinite array.\n/// After this one can continue decoding items, but a `Break` value\n/// will be encountered at some unknown point.\n///\n/// (Consider using `or_break` around every decoding step within an\n/// indefinite array to handle this case).\npub fn array_begin(&mut self) -> DecodeResult<()>{\n        match self.typeinfo()? {\n            (Type::Array, 31) => Ok(()),\n            ti                => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::bool":["pub fn bool(&mut self) -> DecodeResult<bool>{\n        self.typeinfo().and_then(|ti| self.kernel.bool(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::bytes":["/// Decode a single byte string.\n///\n/// Please note that indefinite byte strings are not supported by this\n/// method (Consider using `Decoder::bytes_iter()` for this use-case).\npub fn bytes(&mut self) -> DecodeResult<Vec<u8>>{\n        match self.typeinfo()? {\n            (Type::Bytes, 31) => unexpected_type(&(Type::Bytes, 31)),\n            (Type::Bytes,  i) => {\n                let max = self.config.max_len_bytes;\n                self.kernel.raw_data(i, max)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::bytes_borrow":["/// Decode a single byte string and borrow it from underlying\n/// buffer instead of allocating.\n///\n/// Please note that indefinite byte strings are not supported by this\n/// method.\npub fn bytes_borrow(&mut self) -> DecodeResult<&[u8]>{\n        match self.typeinfo()? {\n            (Type::Bytes, 31) => unexpected_type(&(Type::Bytes, 31)),\n            (Type::Bytes,  i) => {\n                let max = self.config.max_len_bytes;\n                self.kernel.raw_slice(i, max)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::bytes_iter":["/// Decode an indefinite byte string.\npub fn bytes_iter(&mut self) -> DecodeResult<BytesIter<R>>{\n        match self.typeinfo()? {\n            (Type::Bytes, 31) => Ok(BytesIter { decoder: self }),\n            ti                => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::f16":["pub fn f16(&mut self) -> DecodeResult<f32>{\n        self.typeinfo().and_then(|ti| self.kernel.f16(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::f32":["pub fn f32(&mut self) -> DecodeResult<f32>{\n        self.typeinfo().and_then(|ti| self.kernel.f32(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::f64":["pub fn f64(&mut self) -> DecodeResult<f64>{\n        self.typeinfo().and_then(|ti| self.kernel.f64(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::i16":["pub fn i16(&mut self) -> DecodeResult<i16>{\n        self.typeinfo().and_then(|ti| self.kernel.i16(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::i32":["pub fn i32(&mut self) -> DecodeResult<i32>{\n        self.typeinfo().and_then(|ti| self.kernel.i32(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::i64":["pub fn i64(&mut self) -> DecodeResult<i64>{\n        self.typeinfo().and_then(|ti| self.kernel.i64(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::i8":["pub fn i8(&mut self) -> DecodeResult<i8>{\n        self.typeinfo().and_then(|ti| self.kernel.i8(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::int":["pub fn int(&mut self) -> DecodeResult<Int>{\n        self.typeinfo().and_then(|ti| self.kernel.int(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::into_reader":["pub fn into_reader(self) -> R{\n        self.kernel.into_reader()\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::kernel":["pub fn kernel(&mut self) -> &mut Kernel<R>{\n        &mut self.kernel\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::new":["pub fn new(c: Config, r: R) -> Decoder<R>{\n        Decoder { kernel: Kernel::new(r), config: c }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::object":["/// Decode the begin of an object. The size (number of key-value pairs)\n/// is returned unless it exceeds the configured maximum.\n///\n/// Please note that indefinite objects are not supported by this method\n/// (Consider using `Decoder::object_begin` for this use-case).\npub fn object(&mut self) -> DecodeResult<usize>{\n        match self.typeinfo()? {\n            (Type::Object, 31) => unexpected_type(&(Type::Object, 31)),\n            (Type::Object,  a) => {\n                let len = self.kernel.unsigned(a)?;\n                if len > self.config.max_size_map as u64 {\n                    return Err(DecodeError::TooLong { max: self.config.max_size_map, actual: len })\n                }\n                Ok(len as usize)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::object_begin":["/// Decode the begin of an indefinite object.\n/// After this one can continue decoding items, but a `Break` value\n/// will be encountered at some unknown point.\n///\n/// (Consider using `or_break` around every decoding step within an\n/// indefinite object to handle this case).\npub fn object_begin(&mut self) -> DecodeResult<()>{\n        match self.typeinfo()? {\n            (Type::Object, 31) => Ok(()),\n            ti                 => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::read_bytes":["/// Decode a single byte string into the given buffer.\n///\n/// The provided buffer must be large enough to hold the entire\n/// byte string, otherwise an error is returned.\n///\n/// Please note that indefinite byte strings are not supported by this\n/// method (Consider using `Decoder::bytes_iter()` for this use-case).\npub fn read_bytes(&mut self, b: &mut [u8]) -> DecodeResult<usize>{\n        match self.typeinfo()? {\n            (Type::Bytes, 31) => unexpected_type(&(Type::Bytes, 31)),\n            (Type::Bytes,  i) => self.kernel.read_raw_data(i, b),\n            ti                => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::simple":["pub fn simple(&mut self) -> DecodeResult<Simple>{\n        self.typeinfo().and_then(|ti| self.kernel.simple(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::skip":["/// Skip over a single CBOR value.\n///\n/// Please note that this function does not validate the value hence\n/// it might not even be well-formed CBOR. Instead `skip` is an\n/// optimisation over `GenericDecoder::value()` and generally only\n/// determines as much information as necessary to safely skip a value\n/// without keeping all of it in memory.\npub fn skip(&mut self) -> DecodeResult<()>{\n        let start = self.config.max_nesting;\n        self.skip_value(start).and(Ok(()))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::skip_until_break":["fn skip_until_break(&mut self, ty: Type) -> DecodeResult<()>{\n        loop {\n            let (t, a) = self.typeinfo()?;\n            if t == Type::Break {\n                break\n            }\n            if t != ty || a == 31 {\n                return unexpected_type(&(t, a))\n            }\n            let n = self.kernel.unsigned(a)?;\n            self.kernel.reader.skip(n)?\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::skip_value":["fn skip_value(&mut self, level: usize) -> DecodeResult<bool>{\n        if level == 0 {\n            return Err(DecodeError::TooNested)\n        }\n        match self.typeinfo()? {\n            (Type::UInt8, n)     => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::UInt16, n)    => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::UInt32, n)    => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::UInt64, n)    => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::Int8, n)      => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::Int16, n)     => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::Int32, n)     => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::Int64, n)     => self.kernel.unsigned(n).and(Ok(true)),\n            (Type::Bool, _)      => Ok(true),\n            (Type::Null, _)      => Ok(true),\n            (Type::Undefined, _) => Ok(true),\n            (Type::Break, _)     => Ok(false),\n            (Type::Float16, _)   => {\n                self.kernel.reader.skip(2)?;\n                Ok(true)\n            }\n            (Type::Float32, _) => {\n                self.kernel.reader.skip(4)?;\n                Ok(true)\n            }\n            (Type::Float64, _) => {\n                self.kernel.reader.skip(8)?;\n                Ok(true)\n            }\n            (Type::Bytes, 31) => self.skip_until_break(Type::Bytes).and(Ok(true)),\n            (Type::Bytes, a)  => {\n                let n = self.kernel.unsigned(a)?;\n                self.kernel.reader.skip(n)?;\n                Ok(true)\n            }\n            (Type::Text, 31) => self.skip_until_break(Type::Text).and(Ok(true)),\n            (Type::Text, a)  => {\n                let n = self.kernel.unsigned(a)?;\n                self.kernel.reader.skip(n)?;\n                Ok(true)\n            }\n            (Type::Array, 31) => {\n                while self.skip_value(level - 1)? {}\n                Ok(true)\n            }\n            (Type::Object, 31) => {\n                while self.skip_value(level - 1)? {}\n                Ok(true)\n            }\n            (Type::Array, a) => {\n                let n = self.kernel.unsigned(a)?;\n                for _ in 0 .. n {\n                    self.skip_value(level - 1)?;\n                }\n                Ok(true)\n            }\n            (Type::Object, a) => {\n                let n = self.kernel.unsigned(a)?;\n                // n == number of fields => need to skip over keys and values.\n                // Instead of doubling n we loop twice in order to avoid\n                // overflowing n.\n                for _ in 0 .. n {\n                    self.skip_value(level - 1)?;\n                }\n                for _ in 0 .. n {\n                    self.skip_value(level - 1)?;\n                }\n                Ok(true)\n            }\n            (Type::Unassigned {..}, _) => Ok(true),\n            (Type::Reserved {..}, _)   => Ok(true),\n            ti@(Type::Tagged, _)       => unexpected_type(&ti),\n            ti@(Type::Unknown {..}, _) => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::tag":["/// Decode a `Tag`.\n/// If no tag is found an `UnexpectedType` error is returned.\npub fn tag(&mut self) -> DecodeResult<Tag>{\n        match self.kernel.typeinfo()? {\n            (Type::Tagged, i) => self.kernel.unsigned(i).map(Tag::of),\n            ti                => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::text":["/// Decode a single UTF-8 encoded String.\n///\n/// Please note that indefinite strings are not supported by this method\n/// (Consider using `Decoder::text_iter()` for this use-case).\npub fn text(&mut self) -> DecodeResult<String>{\n        match self.typeinfo()? {\n            (Type::Text, 31) => unexpected_type(&(Type::Text, 31)),\n            (Type::Text,  i) => {\n                let max  = self.config.max_len_text;\n                let data = self.kernel.raw_data(i, max)?;\n                String::from_utf8(data).map_err(From::from)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::text_borrow":["/// Decode a single UTF-8 encoded String and borrow it from underlying\n/// buffer instead of allocating.\n///\n/// Please note that indefinite strings are not supported by this method.\npub fn text_borrow(&mut self) -> DecodeResult<&str>{\n        match self.typeinfo()? {\n            (Type::Text, 31) => unexpected_type(&(Type::Text, 31)),\n            (Type::Text,  i) => {\n                let max  = self.config.max_len_text;\n                let data = self.kernel.raw_slice(i, max)?;\n                from_utf8(data).map_err(From::from)\n            }\n            ti => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::text_iter":["/// Decode an indefinite string.\npub fn text_iter(&mut self) -> DecodeResult<TextIter<R>>{\n        match self.typeinfo()? {\n            (Type::Text, 31) => Ok(TextIter { decoder: self }),\n            ti               => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::typeinfo":["fn typeinfo(&mut self) -> DecodeResult<TypeInfo>{\n        fn go<A: ReadBytesExt>(d: &mut Decoder<A>, level: usize) -> DecodeResult<TypeInfo> {\n            if level == 0 {\n                return Err(DecodeError::TooNested)\n            }\n            match d.kernel.typeinfo()? {\n                (Type::Tagged, i) => d.kernel.unsigned(i).and(go(d, level - 1)),\n                ti                => Ok(ti)\n            }\n        }\n        let start = self.config.max_nesting;\n        go(self, start)\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::typeinfo::go":["fn go<A: ReadBytesExt>(d: &mut Decoder<A>, level: usize) -> DecodeResult<TypeInfo>{\n            if level == 0 {\n                return Err(DecodeError::TooNested)\n            }\n            match d.kernel.typeinfo()? {\n                (Type::Tagged, i) => d.kernel.unsigned(i).and(go(d, level - 1)),\n                ti                => Ok(ti)\n            }\n        }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::u16":["pub fn u16(&mut self) -> DecodeResult<u16>{\n        self.typeinfo().and_then(|ti| self.kernel.u16(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::u32":["pub fn u32(&mut self) -> DecodeResult<u32>{\n        self.typeinfo().and_then(|ti| self.kernel.u32(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::u64":["pub fn u64(&mut self) -> DecodeResult<u64>{\n        self.typeinfo().and_then(|ti| self.kernel.u64(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Decoder::<R>::u8":["pub fn u8(&mut self) -> DecodeResult<u8>{\n        self.typeinfo().and_then(|ti| self.kernel.u8(&ti))\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::GenericDecoder":["/// A generic decoder decodes arbitrary CBOR into a `Value` AST.\npub struct GenericDecoder<R> {\n    decoder: Decoder<R>\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::GenericDecoder::<R>::borrow_mut":["pub fn borrow_mut(&mut self) -> &mut Decoder<R>{\n        &mut self.decoder\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::GenericDecoder::<R>::decode_key":["fn decode_key(&mut self, level: usize) -> DecodeResult<Key>{\n        match self.decode_value(level)? {\n            Value::Bool(x)  => Ok(Key::Bool(x)),\n            Value::Bytes(x) => Ok(Key::Bytes(x)),\n            Value::Text(x)  => Ok(Key::Text(x)),\n            Value::I8(x)    => Ok(Key::i64(x as i64)),\n            Value::I16(x)   => Ok(Key::i64(x as i64)),\n            Value::I32(x)   => Ok(Key::i64(x as i64)),\n            Value::I64(x)   => Ok(Key::i64(x)),\n            Value::U8(x)    => Ok(Key::u64(x as u64)),\n            Value::U16(x)   => Ok(Key::u64(x as u64)),\n            Value::U32(x)   => Ok(Key::u64(x as u64)),\n            Value::U64(x)   => Ok(Key::u64(x)),\n            Value::Int(x)   => Ok(Key::Int(x)),\n            other           => Err(DecodeError::InvalidKey(other))\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::GenericDecoder::<R>::decode_value":["fn decode_value(&mut self, level: usize) -> DecodeResult<Value>{\n        if level == 0 {\n            return Err(DecodeError::TooNested)\n        }\n        match self.decoder.kernel.typeinfo()? {\n            ti@(Type::UInt8, _)   => self.decoder.kernel.u8(&ti).map(Value::U8),\n            ti@(Type::UInt16, _)  => self.decoder.kernel.u16(&ti).map(Value::U16),\n            ti@(Type::UInt32, _)  => self.decoder.kernel.u32(&ti).map(Value::U32),\n            ti@(Type::UInt64, _)  => self.decoder.kernel.u64(&ti).map(Value::U64),\n            ti@(Type::Int8, _)    =>\n                self.decoder.kernel.i16(&ti)\n                    .map(|n| {\n                        if n > i8::MAX as i16 || n < i8::MIN as i16 {\n                            Value::I16(n)\n                        } else {\n                            Value::I8(n as i8)\n                        }\n                    }),\n            ti@(Type::Int16, _) =>\n                self.decoder.kernel.i32(&ti)\n                    .map(|n| {\n                        if n > i16::MAX as i32 || n < i16::MIN as i32 {\n                            Value::I32(n)\n                        } else {\n                            Value::I16(n as i16)\n                        }\n                    }),\n            ti@(Type::Int32, _) =>\n                self.decoder.kernel.i64(&ti)\n                    .map(|n| {\n                        if n > i32::MAX as i64 || n < i32::MIN as i64 {\n                            Value::I64(n)\n                        } else {\n                            Value::I32(n as i32)\n                        }\n                    }),\n            (Type::Int64, a) =>\n                self.decoder.kernel.unsigned(a)\n                    .map(|n| {\n                        if n > i64::MAX as u64 {\n                            Value::Int(Int::Neg(n))\n                        } else {\n                            Value::I64(-1 - n as i64)\n                        }\n                    }),\n            ti@(Type::Float16, _) => self.decoder.kernel.f16(&ti).map(Value::F32),\n            ti@(Type::Float32, _) => self.decoder.kernel.f32(&ti).map(Value::F32),\n            ti@(Type::Float64, _) => self.decoder.kernel.f64(&ti).map(Value::F64),\n            ti@(Type::Bool, _)    => self.decoder.kernel.bool(&ti).map(Value::Bool),\n            (Type::Null, _)       => Ok(Value::Null),\n            (Type::Undefined, _)  => Ok(Value::Undefined),\n            (Type::Break, _)      => Ok(Value::Break),\n            (Type::Bytes, 31)     => { // indefinite byte string\n                let mut i = 0u64;\n                let mut v = LinkedList::new();\n                loop {\n                    match self.decoder.bytes() {\n                        Ok(chunk) => {\n                            i += chunk.len() as u64;\n                            if i > self.decoder.config.max_len_bytes as u64 {\n                                return Err(DecodeError::TooLong { max: self.decoder.config.max_len_bytes, actual: i })\n                            }\n                            v.push_back(chunk)\n                        }\n                        Err(ref e) if is_break(e) => break,\n                        Err(e)                    => return Err(e)\n                    }\n                }\n                Ok(Value::Bytes(Bytes::Chunks(v)))\n            }\n            (Type::Bytes, a) => {\n                let max = self.decoder.config.max_len_bytes;\n                self.decoder.kernel.raw_data(a, max).map(|x| Value::Bytes(Bytes::Bytes(x)))\n            }\n            (Type::Text, 31) => { // indefinite string\n                let mut i = 0u64;\n                let mut v = LinkedList::new();\n                loop {\n                    match self.decoder.text() {\n                        Ok(chunk) => {\n                            i += chunk.len() as u64;\n                            if i > self.decoder.config.max_len_text as u64 {\n                                return Err(DecodeError::TooLong { max: self.decoder.config.max_len_text, actual: i })\n                            }\n                            v.push_back(chunk)\n                        }\n                        Err(ref e) if is_break(e) => break,\n                        Err(e)                    => return Err(e)\n                    }\n                }\n                Ok(Value::Text(Text::Chunks(v)))\n            }\n            (Type::Text, a) => {\n                let max  = self.decoder.config.max_len_text;\n                let data = self.decoder.kernel.raw_data(a, max)?;\n                String::from_utf8(data).map(|x| Value::Text(Text::Text(x))).map_err(From::from)\n            }\n            (Type::Array, 31) => { // indefinite length array\n                let mut i = 0u64;\n                let mut v = Vec::new();\n                loop {\n                    i += 1;\n                    if i > self.decoder.config.max_len_array as u64 {\n                        return Err(DecodeError::TooLong { max: self.decoder.config.max_len_array, actual: i })\n                    }\n                    match self.decode_value(level - 1) {\n                        Ok(Value::Break) => break,\n                        Ok(x)            => v.push(x),\n                        e                => return e\n                    }\n                }\n                Ok(Value::Array(v))\n            }\n            (Type::Array, a) => {\n                let len = self.decoder.kernel.unsigned(a)?;\n                if len > self.decoder.config.max_len_array as u64 {\n                    return Err(DecodeError::TooLong { max: self.decoder.config.max_len_array, actual: len })\n                }\n                let n = len as usize;\n                let mut v = Vec::with_capacity(n);\n                for _ in 0 .. n {\n                    v.push(self.decode_value(level - 1)?);\n                }\n                Ok(Value::Array(v))\n            }\n            (Type::Object, 31) => { // indefinite size object\n                let mut i = 0u64;\n                let mut m = BTreeMap::new();\n                loop {\n                    i += 1;\n                    if i > self.decoder.config.max_size_map as u64 {\n                        return Err(DecodeError::TooLong { max: self.decoder.config.max_size_map, actual: i })\n                    }\n                    match self.decode_key(level - 1) {\n                        Ok(key) => {\n                            if m.contains_key(&key) {\n                                return Err(DecodeError::DuplicateKey(key))\n                            }\n                            match self.decode_value(level - 1)? {\n                                Value::Break => return Err(DecodeError::UnexpectedBreak),\n                                value        => { m.insert(key, value); }\n                            }\n                        }\n                        Err(DecodeError::InvalidKey(Value::Break)) => break,\n                        Err(e) => return Err(e)\n                    }\n                }\n                Ok(Value::Map(m))\n            }\n            (Type::Object, a) => {\n                let len = self.decoder.kernel.unsigned(a)?;\n                if len > self.decoder.config.max_size_map as u64 {\n                    return Err(DecodeError::TooLong { max: self.decoder.config.max_size_map, actual: len })\n                }\n                let n = len as usize;\n                let mut m = BTreeMap::new();\n                for _ in 0 .. n {\n                    let key = self.decode_key(level - 1)?;\n                    if m.contains_key(&key) {\n                        return Err(DecodeError::DuplicateKey(key))\n                    }\n                    m.insert(key, self.decode_value(level - 1)?);\n                }\n                Ok(Value::Map(m))\n            }\n            (Type::Tagged, a) => {\n                let tag = self.decoder.kernel.unsigned(a).map(Tag::of)?;\n                if self.decoder.config.skip_tags {\n                    return self.decode_value(level - 1)\n                }\n                let val = self.decode_value(level - 1).map(|v| Value::Tagged(tag, Box::new(v)))?;\n                if self.decoder.config.check_tags && !value::check(&val) {\n                    return Err(DecodeError::InvalidTag(val))\n                }\n                Ok(val)\n            }\n            (Type::Unassigned { major: 7, info: a }, _) => Ok(Value::Simple(Simple::Unassigned(a))),\n            (Type::Reserved { major: 7, info: a }, _)   => Ok(Value::Simple(Simple::Reserved(a))),\n            ti => unexpected_type(&ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::GenericDecoder::<R>::from_decoder":["pub fn from_decoder(d: Decoder<R>) -> GenericDecoder<R>{\n        GenericDecoder { decoder: d }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::GenericDecoder::<R>::into_inner":["pub fn into_inner(self) -> Decoder<R>{\n        self.decoder\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::GenericDecoder::<R>::new":["pub fn new(c: Config, r: R) -> GenericDecoder<R>{\n        GenericDecoder { decoder: Decoder::new(c, r) }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::GenericDecoder::<R>::value":["/// Decode into a `Value`, i.e. an intermediate representation which\n/// can be further deconstructed using a `Cursor`.\n/// This supports indefinite decoding as well as tag validation\n/// (if not disabled).\npub fn value(&mut self) -> DecodeResult<Value>{\n        let start = self.decoder.config.max_nesting;\n        self.decode_value(start)\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel":["/// This decoding kernel reads from an underlying `std::io::Read` type\n/// primitive CBOR values such as unsigned and signed integers as well\n/// as raw bytes.\n/// It forms the basis on which `Decoder` and `GenericDecoder` add logic\n/// for handling `Tag`s, heterogenous data and generic value decoding.\npub struct Kernel<R> {\n    reader: R\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::bool":["pub fn bool(&mut self, ti: &TypeInfo) -> DecodeResult<bool>{\n        match *ti {\n            (Type::Bool, 20) => Ok(false),\n            (Type::Bool, 21) => Ok(true),\n            _                => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::f16":["pub fn f16(&mut self, ti: &TypeInfo) -> DecodeResult<f32>{\n        match ti.0 {\n            Type::Float16 => {\n                // Copied from RFC 7049 Appendix D:\n                let half  = self.reader.read_u16::<BigEndian>()?;\n                let exp   = half >> 10 & 0x1F;\n                let mant  = half & 0x3FF;\n                let value = match exp {\n                    0  => ffi::c_ldexpf(mant as f32, -24),\n                    31 => if mant == 0 { f32::INFINITY } else { f32::NAN },\n                    _  => ffi::c_ldexpf(mant as f32 + 1024.0, exp as isize - 25)\n                };\n                Ok(if half & 0x8000 == 0 { value } else { - value })\n            }\n            _ => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::f32":["pub fn f32(&mut self, ti: &TypeInfo) -> DecodeResult<f32>{\n        match ti.0 {\n            Type::Float32 => self.reader.read_f32::<BigEndian>().map_err(From::from),\n            _             => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::f64":["pub fn f64(&mut self, ti: &TypeInfo) -> DecodeResult<f64>{\n        match ti.0 {\n            Type::Float64 => self.reader.read_f64::<BigEndian>().map_err(From::from),\n            _             => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::i16":["pub fn i16(&mut self, ti: &TypeInfo) -> DecodeResult<i16>{\n        match *ti {\n            (Type::Int8, n @ 0...23) => Ok(-1 - n as i16),\n            (Type::Int8, 24)         => read_signed_byte!(self, u8, i16, i16),\n            (Type::Int16, 25)        => read_signed!(self, read_u16, u16, i16, i16),\n            (Type::UInt8, _)         => cast_unsigned!(self, u8, ti, u8, i16, i16),\n            (Type::UInt16, _)        => cast_unsigned!(self, u16, ti, u16, i16, i16),\n            _                        => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::i32":["pub fn i32(&mut self, ti: &TypeInfo) -> DecodeResult<i32>{\n        match *ti {\n            (Type::Int8, n @ 0...23) => Ok(-1 - n as i32),\n            (Type::Int8, 24)         => read_signed_byte!(self, u8, i32, i32),\n            (Type::Int16, 25)        => read_signed!(self, read_u16, u16, i32, i32),\n            (Type::Int32, 26)        => read_signed!(self, read_u32, u32, i32, i32),\n            (Type::UInt8, _)         => cast_unsigned!(self, u8, ti, u8, i32, i32),\n            (Type::UInt16, _)        => cast_unsigned!(self, u16, ti, u16, i32, i32),\n            (Type::UInt32, _)        => cast_unsigned!(self, u32, ti, u32, i32, i32),\n            _                        => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::i64":["pub fn i64(&mut self, ti: &TypeInfo) -> DecodeResult<i64>{\n        match *ti {\n            (Type::Int8, n @ 0...23) => Ok(-1 - n as i64),\n            (Type::Int8, 24)         => read_signed_byte!(self, u8, i64, i64),\n            (Type::Int16, 25)        => read_signed!(self, read_u16, u16, i64, i64),\n            (Type::Int32, 26)        => read_signed!(self, read_u32, u32, i64, i64),\n            (Type::Int64, 27)        => read_signed!(self, read_u64, u64, i64, i64),\n            (Type::UInt8, _)         => cast_unsigned!(self, u8, ti, u8, i64, i64),\n            (Type::UInt16, _)        => cast_unsigned!(self, u16, ti, u16, i64, i64),\n            (Type::UInt32, _)        => cast_unsigned!(self, u32, ti, u32, i64, i64),\n            (Type::UInt64, _)        => cast_unsigned!(self, u64, ti, u64, i64, i64),\n            _                        => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::i8":["pub fn i8(&mut self, ti: &TypeInfo) -> DecodeResult<i8>{\n        match *ti {\n            (Type::Int8, n @ 0...23) => Ok(-1 - n as i8),\n            (Type::Int8, 24)         => read_signed_byte!(self, u8, i8, i8),\n            (Type::UInt8, _)         => cast_unsigned!(self, u8, ti, u8, i8, i8),\n            _                        => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::int":["pub fn int(&mut self, ti: &TypeInfo) -> DecodeResult<Int>{\n        match *ti {\n              (Type::Int8, a)\n            | (Type::Int16, a)\n            | (Type::Int32, a)\n            | (Type::Int64, a) =>\n                self.unsigned(a).map(Int::Neg),\n\n              (Type::UInt8, a)\n            | (Type::UInt16, a)\n            | (Type::UInt32, a)\n            | (Type::UInt64, a) =>\n                self.unsigned(a).map(Int::Pos),\n\n            _ => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::into_reader":["pub fn into_reader(self) -> R{\n        self.reader\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::new":["pub fn new(r: R) -> Kernel<R>{\n        Kernel { reader: r }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::raw_data":["/// Read `begin` as the length and return that many raw bytes.\n///\n/// If length is greater than the given `max_len`, `DecodeError::TooLong`\n/// is returned instead.\npub fn raw_data(&mut self, begin: u8, max_len: usize) -> DecodeResult<Vec<u8>>{\n        let len = self.unsigned(begin)?;\n        if len > max_len as u64 {\n            return Err(DecodeError::TooLong { max: max_len, actual: len })\n        }\n        let n = len as usize;\n        let mut v = vec![0u8; n];\n        let mut i = 0;\n        while i < n {\n            match self.reader.read(&mut v[i..]) {\n                Ok(0)  => return Err(DecodeError::UnexpectedEOF),\n                Ok(j)  => i += j,\n                Err(e) =>\n                    if e.kind() != io::ErrorKind::Interrupted {\n                        return Err(DecodeError::IoError(e))\n                    }\n            }\n        }\n        Ok(v)\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::raw_slice":["/// Read `begin` as the length and return that many raw bytes as a slice.\n///\n/// If length is greater than the given `max_len`, `DecodeError::TooLong`\n/// is returned instead.\npub fn raw_slice(&mut self, begin: u8, max_len: usize) -> DecodeResult<&[u8]>{\n        let len = self.unsigned(begin)?;\n        if len > max_len as u64 {\n            return Err(DecodeError::TooLong { max: max_len, actual: len })\n        }\n        self.reader.read_slice(len as usize).map_err(From::from)\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::read_raw_data":["/// Read `begin` as the length and read that many raw bytes into `buf`.\n///\n/// If length is greater than the given buffer, `DecodeError::TooLong`\n/// is returned instead.\npub fn read_raw_data(&mut self, begin: u8, buf: &mut [u8]) -> DecodeResult<usize>{\n        let len = self.unsigned(begin)?;\n        if len > buf.len() as u64 {\n            return Err(DecodeError::TooLong { max: buf.len(), actual: len })\n        }\n        let n = len as usize;\n        let mut i = 0;\n        while i < n {\n            match self.reader.read(&mut buf[i..]) {\n                Ok(0)  => return Err(DecodeError::UnexpectedEOF),\n                Ok(j)  => i += j,\n                Err(e) =>\n                    if e.kind() != io::ErrorKind::Interrupted {\n                        return Err(DecodeError::IoError(e))\n                    }\n            }\n        }\n        Ok(n)\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::simple":["pub fn simple(&mut self, ti: &TypeInfo) -> DecodeResult<Simple>{\n        match ti.0 {\n            Type::Unassigned { major: 7, info: a } => Ok(Simple::Unassigned(a)),\n            Type::Reserved   { major: 7, info: a } => Ok(Simple::Reserved(a)),\n            _                                      => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::typeinfo":["pub fn typeinfo(&mut self) -> DecodeResult<TypeInfo>{\n        Type::read(&mut self.reader).map_err(From::from)\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::u16":["pub fn u16(&mut self, ti: &TypeInfo) -> DecodeResult<u16>{\n        match *ti {\n            (Type::UInt8, n @ 0...23) => Ok(n as u16),\n            (Type::UInt8, 24)  => self.reader.read_u8().map(|n| n as u16).map_err(From::from),\n            (Type::UInt16, 25) => self.reader.read_u16::<BigEndian>().map_err(From::from),\n            _                  => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::u32":["pub fn u32(&mut self, ti: &TypeInfo) -> DecodeResult<u32>{\n        match *ti {\n            (Type::UInt8, n @ 0...23) => Ok(n as u32),\n            (Type::UInt8, 24)  => self.reader.read_u8().map(|n| n as u32).map_err(From::from),\n            (Type::UInt16, 25) => self.reader.read_u16::<BigEndian>().map(|n| n as u32).map_err(From::from),\n            (Type::UInt32, 26) => self.reader.read_u32::<BigEndian>().map_err(From::from),\n            _                  => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::u64":["pub fn u64(&mut self, ti: &TypeInfo) -> DecodeResult<u64>{\n        match *ti {\n            (Type::UInt8, n @ 0...23) => Ok(n as u64),\n            (Type::UInt8, 24)  => self.reader.read_u8().map(|n| n as u64).map_err(From::from),\n            (Type::UInt16, 25) => self.reader.read_u16::<BigEndian>().map(|n| n as u64).map_err(From::from),\n            (Type::UInt32, 26) => self.reader.read_u32::<BigEndian>().map(|n| n as u64).map_err(From::from),\n            (Type::UInt64, 27) => self.reader.read_u64::<BigEndian>().map_err(From::from),\n            _                  => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::u8":["pub fn u8(&mut self, ti: &TypeInfo) -> DecodeResult<u8>{\n        match *ti {\n            (Type::UInt8, n @ 0...23) => Ok(n),\n            (Type::UInt8, 24) => self.reader.read_u8().map_err(From::from),\n            _                 => unexpected_type(ti)\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::Kernel::<R>::unsigned":["/// Decode `first` and potentially the following bytes as an\n/// unsigned value following the rules of major type 0.\npub fn unsigned(&mut self, first: u8) -> DecodeResult<u64>{\n        match first {\n            n @ 0...23 => Ok(n as u64),\n            24 => self.reader.read_u8().map(|n| n as u64).map_err(From::from),\n            25 => self.reader.read_u16::<BigEndian>().map(|n| n as u64).map_err(From::from),\n            26 => self.reader.read_u32::<BigEndian>().map(|n| n as u64).map_err(From::from),\n            27 => self.reader.read_u64::<BigEndian>().map_err(From::from),\n            _  => unexpected_type(&(Type::UInt64, first))\n        }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::TextIter":["/// Iterator over the chunks of an indefinite text item.\npub struct TextIter<'r, R: 'r> {\n    decoder: &'r mut Decoder<R>\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::ffi::c_ldexpf":["#[inline]\npub fn c_ldexpf(x: f32, exp: isize) -> f32{\n        unsafe { ldexpf(x, exp as c_int) }\n    }","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::is_break":["fn is_break(e: &DecodeError) -> bool{\n    match *e {\n        DecodeError::UnexpectedType { datatype: Type::Break, .. } => true,\n        _ => false\n    }\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::is_null":["fn is_null(e: &DecodeError) -> bool{\n    match *e {\n        DecodeError::UnexpectedType { datatype: Type::Null, .. } => true,\n        _ => false\n    }\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::is_undefined":["fn is_undefined(e: &DecodeError) -> bool{\n    match *e {\n        DecodeError::UnexpectedType { datatype: Type::Undefined, .. } => true,\n        _ => false\n    }\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::maybe":["/// When decoding an item which may be `Undefined` this function\n/// will map `Undefined` to `None` and any other value to `Some(value)`.\npub fn maybe<A>(r: DecodeResult<A>) -> DecodeResult<Option<A>>{\n    match r {\n        Ok(x)  => Ok(Some(x)),\n        Err(e) => if is_undefined(&e) { Ok(None) } else { Err(e) }\n    }\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::opt":["/// When decoding an optional item, i.e. a `Null` value has to be\n/// considered, this function will map `Null` to `None` and any\n/// other value to `Some(value)`.\npub fn opt<A>(r: DecodeResult<A>) -> DecodeResult<Option<A>>{\n    match r {\n        Ok(x)  => Ok(Some(x)),\n        Err(e) => if is_null(&e) { Ok(None) } else { Err(e) }\n    }\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::or_break":["/// When decoding an indefinite item, every element item can be a `Break`\n/// value. By wrapping it in `or_break`, this case can be handled more\n/// conveniently.\npub fn or_break<A>(r: DecodeResult<A>) -> DecodeResult<Option<A>>{\n    match r {\n        Ok(x)  => Ok(Some(x)),\n        Err(e) => if is_break(&e) { Ok(None) } else { Err(e) }\n    }\n}","Real(LocalPath(\"src/decoder.rs\"))"],"decoder::unexpected_type":["fn unexpected_type<A>(ti: &TypeInfo) -> DecodeResult<A>{\n    Err(DecodeError::UnexpectedType { datatype: ti.0, info: ti.1 })\n}","Real(LocalPath(\"src/decoder.rs\"))"],"encoder::EncodeError":["pub enum EncodeError {\n    /// Some I/O error\n    IoError(io::Error),\n    /// The end of file has been encountered unexpectedly\n    UnexpectedEOF,\n    /// The provided `Simple` value is neither unassigned nor reserved\n    InvalidSimpleValue(Simple),\n    /// Certain values (e.g. `Value::Break`) are not legal to encode as\n    /// independent units. Attempting to do so will trigger this error.\n    InvalidValue(Value),\n    /// Some other error.\n    Other(Box<Error + Send + Sync>)\n}","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder":["/// The actual encoder type definition\npub struct Encoder<W> {\n    writer: W\n}","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::array":["pub fn array(&mut self, len: usize) -> EncodeResult{\n        self.type_len(Type::Array, len as u64)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::array_begin":["/// Indefinite array encoding. (RFC 7049 section 2.2.1)\npub fn array_begin(&mut self) -> EncodeResult{\n        self.writer.write_u8(0b100_11111).map_err(From::from)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::array_end":["/// End of indefinite array encoding. (RFC 7049 section 2.2.1)\npub fn array_end(&mut self) -> EncodeResult{\n        self.writer.write_u8(0b111_11111).map_err(From::from)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::bool":["pub fn bool(&mut self, x: bool) -> EncodeResult{\n        self.writer.write_u8(0b111_00000 | if x {21} else {20}).map_err(From::from)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::bytes":["pub fn bytes(&mut self, x: &[u8]) -> EncodeResult{\n        self.type_len(Type::Bytes, x.len() as u64)\n            .and(self.writer.write_all(x).map_err(From::from))\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::bytes_iter":["/// Indefinite byte string encoding. (RFC 7049 section 2.2.2)\npub fn bytes_iter<'r, I: Iterator<Item=&'r [u8]>>(&mut self, iter: I) -> EncodeResult{\n        self.writer.write_u8(0b010_11111)?;\n        for x in iter {\n            self.bytes(x)?\n        }\n        self.writer.write_u8(0b111_11111).map_err(From::from)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::f32":["pub fn f32(&mut self, x: f32) -> EncodeResult{\n        self.writer.write_u8(0b111_00000 | 26)\n            .and(self.writer.write_f32::<BigEndian>(x))\n            .map_err(From::from)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::f64":["pub fn f64(&mut self, x: f64) -> EncodeResult{\n        self.writer.write_u8(0b111_00000 | 27)\n            .and(self.writer.write_f64::<BigEndian>(x))\n            .map_err(From::from)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::i16":["pub fn i16(&mut self, x: i16) -> EncodeResult{\n        if x >= 0 {\n            self.u16(x as u16)\n        } else {\n            let ref mut w = self.writer;\n            match (-1 - x) as u16 {\n                n @ 0...23    => w.write_u8(0b001_00000 | n as u8).map_err(From::from),\n                n @ 24...0xFF => w.write_u8(0b001_00000 | 24).and(w.write_u8(n as u8)).map_err(From::from),\n                n             => w.write_u8(0b001_00000 | 25).and(w.write_u16::<BigEndian>(n)).map_err(From::from)\n            }\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::i32":["pub fn i32(&mut self, x: i32) -> EncodeResult{\n        if x >= 0 {\n            self.u32(x as u32)\n        } else {\n            let ref mut w = self.writer;\n            match (-1 - x) as u32 {\n                n @ 0...23         => w.write_u8(0b001_00000 | n as u8).map_err(From::from),\n                n @ 24...0xFF      => w.write_u8(0b001_00000 | 24).and(w.write_u8(n as u8)).map_err(From::from),\n                n @ 0x100...0xFFFF => w.write_u8(0b001_00000 | 25).and(w.write_u16::<BigEndian>(n as u16)).map_err(From::from),\n                n                  => w.write_u8(0b001_00000 | 26).and(w.write_u32::<BigEndian>(n)).map_err(From::from)\n            }\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::i64":["pub fn i64(&mut self, x: i64) -> EncodeResult{\n        if x >= 0 {\n            self.u64(x as u64)\n        } else {\n            let ref mut w = self.writer;\n            match (-1 - x) as u64 {\n                n @ 0...23                => w.write_u8(0b001_00000 | n as u8).map_err(From::from),\n                n @ 24...0xFF             => w.write_u8(0b001_00000 | 24).and(w.write_u8(n as u8)).map_err(From::from),\n                n @ 0x100...0xFFFF        => w.write_u8(0b001_00000 | 25).and(w.write_u16::<BigEndian>(n as u16)).map_err(From::from),\n                n @ 0x100000...0xFFFFFFFF => w.write_u8(0b001_00000 | 26).and(w.write_u32::<BigEndian>(n as u32)).map_err(From::from),\n                n                         => w.write_u8(0b001_00000 | 27).and(w.write_u64::<BigEndian>(n)).map_err(From::from)\n            }\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::i8":["pub fn i8(&mut self, x: i8) -> EncodeResult{\n        if x >= 0 {\n            self.u8(x as u8)\n        } else {\n            let ref mut w = self.writer;\n            match (-1 - x) as u8 {\n                n @ 0...23 => w.write_u8(0b001_00000 | n).map_err(From::from),\n                n          => w.write_u8(0b001_00000 | 24).and(w.write_u8(n)).map_err(From::from)\n            }\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::int":["pub fn int(&mut self, x: Int) -> EncodeResult{\n        match x {\n            Int::Pos(v) => self.u64(v),\n            Int::Neg(v) => {\n                let ref mut w = self.writer;\n                match v {\n                    n @ 0...23                => w.write_u8(0b001_00000 | n as u8).map_err(From::from),\n                    n @ 24...0xFF             => w.write_u8(0b001_00000 | 24).and(w.write_u8(n as u8)).map_err(From::from),\n                    n @ 0x100...0xFFFF        => w.write_u8(0b001_00000 | 25).and(w.write_u16::<BigEndian>(n as u16)).map_err(From::from),\n                    n @ 0x100000...0xFFFFFFFF => w.write_u8(0b001_00000 | 26).and(w.write_u32::<BigEndian>(n as u32)).map_err(From::from),\n                    n                         => w.write_u8(0b001_00000 | 27).and(w.write_u64::<BigEndian>(n)).map_err(From::from)\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::into_writer":["pub fn into_writer(self) -> W{\n        self.writer\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::new":["pub fn new(w: W) -> Encoder<W>{\n        Encoder { writer: w }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::null":["pub fn null(&mut self) -> EncodeResult{\n        self.writer.write_u8(0b111_00000 | 22).map_err(From::from)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::object":["pub fn object(&mut self, len: usize) -> EncodeResult{\n        self.type_len(Type::Object, len as u64)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::object_begin":["/// Indefinite object encoding. (RFC 7049 section 2.2.1)\npub fn object_begin(&mut self) -> EncodeResult{\n        self.writer.write_u8(0b101_11111).map_err(From::from)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::object_end":["/// End of indefinite object encoding. (RFC 7049 section 2.2.1)\npub fn object_end(&mut self) -> EncodeResult{\n        self.writer.write_u8(0b111_11111).map_err(From::from)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::simple":["pub fn simple(&mut self, x: Simple) -> EncodeResult{\n        let ref mut w = self.writer;\n        match x {\n            Simple::Unassigned(n) => match n {\n                0...19 | 28...30 => w.write_u8(0b111_00000 | n).map_err(From::from),\n                32...255         => w.write_u8(0b111_00000 | 24).and(w.write_u8(n)).map_err(From::from),\n                _                => Err(EncodeError::InvalidSimpleValue(x))\n            },\n            Simple::Reserved(n) => match n {\n                0...31 => w.write_u8(0b111_00000 | 24).and(w.write_u8(n)).map_err(From::from),\n                _      => Err(EncodeError::InvalidSimpleValue(x))\n            }\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::tag":["pub fn tag(&mut self, x: Tag) -> EncodeResult{\n        self.type_len(Type::Tagged, x.to())\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::text":["pub fn text(&mut self, x: &str) -> EncodeResult{\n        self.type_len(Type::Text, x.len() as u64)\n            .and(self.writer.write_all(x.as_bytes()).map_err(From::from))\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::text_iter":["/// Indefinite string encoding. (RFC 7049 section 2.2.2)\npub fn text_iter<'r, I: Iterator<Item=&'r str>>(&mut self, iter: I) -> EncodeResult{\n        self.writer.write_u8(0b011_11111)?;\n        for x in iter {\n            self.text(x)?\n        }\n        self.writer.write_u8(0b111_11111).map_err(From::from)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::type_len":["fn type_len(&mut self, t: Type, x: u64) -> EncodeResult{\n        let ref mut w = self.writer;\n        match x {\n            0...23                => w.write_u8(t.major() << 5 | x as u8).map_err(From::from),\n            24...0xFF             => w.write_u8(t.major() << 5 | 24).and(w.write_u8(x as u8)).map_err(From::from),\n            0x100...0xFFFF        => w.write_u8(t.major() << 5 | 25).and(w.write_u16::<BigEndian>(x as u16)).map_err(From::from),\n            0x100000...0xFFFFFFFF => w.write_u8(t.major() << 5 | 26).and(w.write_u32::<BigEndian>(x as u32)).map_err(From::from),\n            _                     => w.write_u8(t.major() << 5 | 27).and(w.write_u64::<BigEndian>(x)).map_err(From::from)\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::u16":["pub fn u16(&mut self, x: u16) -> EncodeResult{\n        let ref mut w = self.writer;\n        match x {\n            0...23    => w.write_u8(x as u8).map_err(From::from),\n            24...0xFF => w.write_u8(24).and(w.write_u8(x as u8)).map_err(From::from),\n            _         => w.write_u8(25).and(w.write_u16::<BigEndian>(x)).map_err(From::from)\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::u32":["pub fn u32(&mut self, x: u32) -> EncodeResult{\n        let ref mut w = self.writer;\n        match x {\n            0...23         => w.write_u8(x as u8).map_err(From::from),\n            24...0xFF      => w.write_u8(24).and(w.write_u8(x as u8)).map_err(From::from),\n            0x100...0xFFFF => w.write_u8(25).and(w.write_u16::<BigEndian>(x as u16)).map_err(From::from),\n            _              => w.write_u8(26).and(w.write_u32::<BigEndian>(x)).map_err(From::from)\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::u64":["pub fn u64(&mut self, x: u64) -> EncodeResult{\n        let ref mut w = self.writer;\n        match x {\n            0...23                => w.write_u8(x as u8).map_err(From::from),\n            24...0xFF             => w.write_u8(24).and(w.write_u8(x as u8)).map_err(From::from),\n            0x100...0xFFFF        => w.write_u8(25).and(w.write_u16::<BigEndian>(x as u16)).map_err(From::from),\n            0x100000...0xFFFFFFFF => w.write_u8(26).and(w.write_u32::<BigEndian>(x as u32)).map_err(From::from),\n            _                     => w.write_u8(27).and(w.write_u64::<BigEndian>(x)).map_err(From::from)\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::u8":["pub fn u8(&mut self, x: u8) -> EncodeResult{\n        let ref mut w = self.writer;\n        match x {\n            0...23 => w.write_u8(x).map_err(From::from),\n            _      => w.write_u8(24).and(w.write_u8(x)).map_err(From::from)\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::undefined":["pub fn undefined(&mut self) -> EncodeResult{\n        self.writer.write_u8(0b111_00000 | 23).map_err(From::from)\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::Encoder::<W>::writer":["pub fn writer(&mut self) -> &mut W{\n        &mut self.writer\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::GenericEncoder":["/// A generic encoder encodes a `Value`.\npub struct GenericEncoder<W> {\n    encoder: Encoder<W>\n}","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::GenericEncoder::<W>::borrow_mut":["pub fn borrow_mut(&mut self) -> &mut Encoder<W>{\n        &mut self.encoder\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::GenericEncoder::<W>::from_encoder":["pub fn from_encoder(e: Encoder<W>) -> GenericEncoder<W>{\n        GenericEncoder { encoder: e }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::GenericEncoder::<W>::into_inner":["pub fn into_inner(self) -> Encoder<W>{\n        self.encoder\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::GenericEncoder::<W>::key":["fn key(&mut self, x: &Key) -> EncodeResult{\n        match *x {\n            Key::Bool(b) => self.encoder.bool(b),\n            Key::Int(n)  => self.encoder.int(n),\n            Key::Bytes(Bytes::Bytes(ref bb))  => self.encoder.bytes(&bb[..]),\n            Key::Bytes(Bytes::Chunks(ref bb)) => self.encoder.bytes_iter(bb.iter().map(|v| &v[..])),\n            Key::Text(Text::Text(ref txt))    => self.encoder.text(txt),\n            Key::Text(Text::Chunks(ref txt))  => self.encoder.text_iter(txt.iter().map(|v| &v[..]))\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::GenericEncoder::<W>::new":["pub fn new(w: W) -> GenericEncoder<W>{\n        GenericEncoder { encoder: Encoder::new(w) }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"encoder::GenericEncoder::<W>::value":["pub fn value(&mut self, x: &Value) -> EncodeResult{\n        match *x {\n            Value::Array(ref vv) => {\n                self.encoder.array(vv.len())?;\n                for v in vv {\n                    self.value(v)?\n                }\n                Ok(())\n            }\n            Value::Bytes(Bytes::Bytes(ref bb))  => self.encoder.bytes(&bb[..]),\n            Value::Bytes(Bytes::Chunks(ref bb)) => self.encoder.bytes_iter(bb.iter().map(|v| &v[..])),\n            Value::Text(Text::Text(ref txt))    => self.encoder.text(txt),\n            Value::Text(Text::Chunks(ref txt))  => self.encoder.text_iter(txt.iter().map(|v| &v[..])),\n            Value::Map(ref m) => {\n                self.encoder.object(m.len())?;\n                for (k, v) in m {\n                    self.key(k).and(self.value(v))?\n                }\n                Ok(())\n            }\n            Value::Tagged(t, ref val) => {\n                self.encoder.tag(t)?;\n                self.value(&*val)\n            }\n            Value::Undefined => self.encoder.undefined(),\n            Value::Null      => self.encoder.null(),\n            Value::Simple(s) => self.encoder.simple(s),\n            Value::Bool(b)   => self.encoder.bool(b),\n            Value::U8(n)     => self.encoder.u8(n),\n            Value::U16(n)    => self.encoder.u16(n),\n            Value::U32(n)    => self.encoder.u32(n),\n            Value::U64(n)    => self.encoder.u64(n),\n            Value::F32(n)    => self.encoder.f32(n),\n            Value::F64(n)    => self.encoder.f64(n),\n            Value::I8(n)     => self.encoder.i8(n),\n            Value::I16(n)    => self.encoder.i16(n),\n            Value::I32(n)    => self.encoder.i32(n),\n            Value::I64(n)    => self.encoder.i64(n),\n            Value::Int(n)    => self.encoder.int(n),\n            Value::Break     => Err(EncodeError::InvalidValue(Value::Break))\n        }\n    }","Real(LocalPath(\"src/encoder.rs\"))"],"skip::Skip":["/// Type which supports skipping a number of bytes.\n///\n/// Similar in spirit to `std::io::Seek` but only allows\n/// uni-directional movement.\npub trait Skip {\n    /// Skip over `n` consecutive bytes.\n    fn skip(&mut self, n: u64) -> Result<()>;\n}","Real(LocalPath(\"src/skip.rs\"))"],"slice::ReadSlice":["/// Type which supports reading a slice of bytes.\npub trait ReadSlice {\n    fn read_slice(&mut self, n: usize) -> Result<&[u8], ReadSliceError>;\n}","Real(LocalPath(\"src/slice.rs\"))"],"slice::ReadSliceError":["pub enum ReadSliceError {\n    IoError(io::Error),\n    InsufficientData\n}","Real(LocalPath(\"src/slice.rs\"))"],"types::Tag":["/// CBOR tags (corresponding to `Type::Tagged`).\npub enum Tag {\n    DateTime,\n    Timestamp,\n    Bignum,\n    NegativeBignum,\n    Decimal,\n    Bigfloat,\n    Unassigned(u64),\n    ToBase64Url,\n    ToBase64,\n    ToBase16,\n    Cbor,\n    Uri,\n    Base64Url,\n    Base64,\n    Regex,\n    Mime,\n    CborSelf\n}","Real(LocalPath(\"src/types.rs\"))"],"types::Tag::of":["pub fn of(x: u64) -> Tag{\n        match x {\n            0     => Tag::DateTime,\n            1     => Tag::Timestamp,\n            2     => Tag::Bignum,\n            3     => Tag::NegativeBignum,\n            4     => Tag::Decimal,\n            5     => Tag::Bigfloat,\n            21    => Tag::ToBase64Url,\n            22    => Tag::ToBase64,\n            23    => Tag::ToBase16,\n            24    => Tag::Cbor,\n            32    => Tag::Uri,\n            33    => Tag::Base64Url,\n            34    => Tag::Base64,\n            35    => Tag::Regex,\n            36    => Tag::Mime,\n            55799 => Tag::CborSelf,\n            _     => Tag::Unassigned(x)\n        }\n    }","Real(LocalPath(\"src/types.rs\"))"],"types::Tag::to":["pub fn to(&self) -> u64{\n        match *self {\n            Tag::DateTime       => 0,\n            Tag::Timestamp      => 1,\n            Tag::Bignum         => 2,\n            Tag::NegativeBignum => 3,\n            Tag::Decimal        => 4,\n            Tag::Bigfloat       => 5,\n            Tag::ToBase64Url    => 21,\n            Tag::ToBase64       => 22,\n            Tag::ToBase16       => 23,\n            Tag::Cbor           => 24,\n            Tag::Uri            => 32,\n            Tag::Base64Url      => 33,\n            Tag::Base64         => 34,\n            Tag::Regex          => 35,\n            Tag::Mime           => 36,\n            Tag::CborSelf       => 55799,\n            Tag::Unassigned(x)  => x\n        }\n    }","Real(LocalPath(\"src/types.rs\"))"],"types::Type":["/// The CBOR types.\npub enum Type {\n    Array,\n    Bool,\n    Break,\n    Bytes,\n    Float16,\n    Float32,\n    Float64,\n    Int16,\n    Int32,\n    Int64,\n    Int8,\n    Null,\n    Object,\n    Tagged,\n    Text,\n    UInt16,\n    UInt32,\n    UInt64,\n    UInt8,\n    Undefined,\n    Unknown { major: u8, info: u8 },\n    Reserved { major: u8, info: u8 },\n    Unassigned { major: u8, info: u8 }\n}","Real(LocalPath(\"src/types.rs\"))"],"types::Type::major":["pub fn major(&self) -> u8{\n        match *self {\n            Type::Array => 4,\n            Type::Bool  => 7,\n            Type::Break => 7,\n            Type::Bytes => 2,\n            Type::Float16 => 7,\n            Type::Float32 => 7,\n            Type::Float64 => 7,\n            Type::Int16   => 1,\n            Type::Int32   => 1,\n            Type::Int64   => 1,\n            Type::Int8    => 1,\n            Type::Null    => 7,\n            Type::Object  => 5,\n            Type::Tagged  => 6,\n            Type::Text    => 3,\n            Type::UInt16  => 0,\n            Type::UInt32  => 0,\n            Type::UInt64  => 0,\n            Type::UInt8   => 0,\n            Type::Undefined => 7,\n            Type::Unknown { major: m, .. } => m,\n            Type::Reserved { major: m, .. } => m,\n            Type::Unassigned { major: m, .. } => m\n        }\n    }","Real(LocalPath(\"src/types.rs\"))"],"types::Type::read":["pub fn read<R: ReadBytesExt>(r: &mut R) -> Result<(Type, u8), Error>{\n        let b = r.read_u8()?;\n        match ((b & 0b111_00000) >> 5, b & 0b000_11111) {\n            (0, a @ 0...24)  => Ok((Type::UInt8, a)),\n            (0, 25)          => Ok((Type::UInt16, 25)),\n            (0, 26)          => Ok((Type::UInt32, 26)),\n            (0, 27)          => Ok((Type::UInt64, 27)),\n            (1, a @ 0...24)  => Ok((Type::Int8, a)),\n            (1, 25)          => Ok((Type::Int16, 25)),\n            (1, 26)          => Ok((Type::Int32, 26)),\n            (1, 27)          => Ok((Type::Int64, 27)),\n            (2, a)           => Ok((Type::Bytes, a)),\n            (3, a)           => Ok((Type::Text, a)),\n            (4, a)           => Ok((Type::Array, a)),\n            (5, a)           => Ok((Type::Object, a)),\n            (6, a)           => Ok((Type::Tagged, a)),\n            (7, a @ 0...19)  => Ok((Type::Unassigned { major: 7, info: a }, a)),\n            (7, 20)          => Ok((Type::Bool, 20)),\n            (7, 21)          => Ok((Type::Bool, 21)),\n            (7, 22)          => Ok((Type::Null, 22)),\n            (7, 23)          => Ok((Type::Undefined, 23)),\n            (7, 24)          => match r.read_u8()? {\n                a @ 0...31 => Ok((Type::Reserved { major: 7, info: a }, a)),\n                a          => Ok((Type::Unassigned { major: 7, info: a }, a))\n            },\n            (7, 25)          => Ok((Type::Float16, 25)),\n            (7, 26)          => Ok((Type::Float32, 26)),\n            (7, 27)          => Ok((Type::Float64, 27)),\n            (7, a @ 28...30) => Ok((Type::Unassigned { major: 7, info: a }, a)),\n            (7, 31)          => Ok((Type::Break, 31)),\n            (m, a)           => Ok((Type::Unknown { major: m, info: a }, a))\n        }\n    }","Real(LocalPath(\"src/types.rs\"))"],"value::Bytes":["/// A unification of plain an indefinitly sized byte strings.\npub enum Bytes {\n    Bytes(Vec<u8>),\n    Chunks(LinkedList<Vec<u8>>)\n}","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor":["/// A `Cursor` allows conventient navigation in a `Value` AST.\n/// `Value`s can be converted to native Rust types if possible and\n/// collections can be traversed using `at` or `get`.\npub struct Cursor<'r> {\n    value: Option<&'r Value>\n}","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::at":["pub fn at(&self, i: usize) -> Cursor<'r>{\n        match self.value {\n            Some(&Value::Array(ref a)) => Cursor::of(a.get(i)),\n            _                          => Cursor::of(None)\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::bool":["pub fn bool(&self) -> Option<bool>{\n        match self.value {\n            Some(&Value::Bool(x)) => Some(x),\n            _                     => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::bytes":["pub fn bytes(&self) -> Option<&Bytes>{\n        match self.value {\n            Some(&Value::Bytes(ref x)) => Some(x),\n            _                          => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::bytes_chunked":["pub fn bytes_chunked(&self) -> Option<&LinkedList<Vec<u8>>>{\n        match self.value {\n            Some(&Value::Bytes(Bytes::Chunks(ref x))) => Some(x),\n            _                                         => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::bytes_plain":["pub fn bytes_plain(&self) -> Option<&Vec<u8>>{\n        match self.value {\n            Some(&Value::Bytes(Bytes::Bytes(ref x))) => Some(x),\n            _                                        => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::field":["pub fn field(&self, s: &str) -> Cursor<'r>{\n        self.get(Key::Text(Text::Text(String::from(s))))\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::float32":["pub fn float32(&self) -> Option<f32>{\n        match self.value {\n            Some(&Value::F32(x)) => Some(x),\n            _                    => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::float64":["pub fn float64(&self) -> Option<f64>{\n        match self.value {\n            Some(&Value::F64(x)) => Some(x),\n            _                    => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::get":["pub fn get(&self, k: Key) -> Cursor<'r>{\n        match self.value {\n            Some(&Value::Map(ref m)) => Cursor::of(m.get(&k)),\n            _                        => Cursor::of(None)\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::i16":["pub fn i16(&self) -> Option<i16>{\n        match self.value {\n            Some(&Value::I16(x)) => Some(x),\n            _                    => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::i32":["pub fn i32(&self) -> Option<i32>{\n        match self.value {\n            Some(&Value::I32(x)) => Some(x),\n            _                    => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::i64":["pub fn i64(&self) -> Option<i64>{\n        match self.value {\n            Some(&Value::I64(x)) => Some(x),\n            _                    => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::i8":["pub fn i8(&self) -> Option<i8>{\n        match self.value {\n            Some(&Value::I8(x)) => Some(x),\n            _                   => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::maybe":["pub fn maybe(&self) -> Option<Cursor<'r>>{\n        match self.value {\n            Some(&Value::Undefined) => None,\n            Some(ref v)             => Some(Cursor::new(v)),\n            _                       => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::new":["pub fn new(v: &'r Value) -> Cursor<'r>{\n        Cursor { value: Some(v) }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::of":["fn of(v: Option<&'r Value>) -> Cursor<'r>{\n        Cursor { value: v }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::opt":["pub fn opt(&self) -> Option<Cursor<'r>>{\n        match self.value {\n            Some(&Value::Null) => None,\n            Some(ref v)        => Some(Cursor::new(v)),\n            _                  => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::text":["pub fn text(&self) -> Option<&Text>{\n        match self.value {\n            Some(&Value::Text(ref x)) => Some(x),\n            _                         => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::text_chunked":["pub fn text_chunked(&self) -> Option<&LinkedList<String>>{\n        match self.value {\n            Some(&Value::Text(Text::Chunks(ref x))) => Some(x),\n            _                                       => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::text_plain":["pub fn text_plain(&self) -> Option<&String>{\n        match self.value {\n            Some(&Value::Text(Text::Text(ref x))) => Some(x),\n            _                                     => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::u16":["pub fn u16(&self) -> Option<u16>{\n        match self.value {\n            Some(&Value::U16(x)) => Some(x),\n            _                    => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::u32":["pub fn u32(&self) -> Option<u32>{\n        match self.value {\n            Some(&Value::U32(x)) => Some(x),\n            _                    => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::u64":["pub fn u64(&self) -> Option<u64>{\n        match self.value {\n            Some(&Value::U64(x)) => Some(x),\n            _                    => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::u8":["pub fn u8(&self) -> Option<u8>{\n        match self.value {\n            Some(&Value::U8(x)) => Some(x),\n            _                   => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Cursor::<'r>::value":["pub fn value(&self) -> Option<&Value>{\n        self.value\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Int":["/// Type to represent all possible CBOR integer values.\n///\n/// Since the encoding of negative integers (major type 1) follows\n/// unsigned integers (major type 0), mapping negative integers\n/// to `i8`, `i16`, `i32` or `i64` can result in integer overflows.\n/// If all possible values should be handled, this type can be used.\npub enum Int {\n    Neg(u64),\n    Pos(u64)\n}","Real(LocalPath(\"src/value.rs\"))"],"value::Int::from_i64":["pub fn from_i64(n: i64) -> Int{\n        if n < 0 {\n            Int::Neg(i64::abs(n) as u64 - 1)\n        } else {\n            Int::Pos(n as u64)\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Int::from_u64":["pub fn from_u64(n: u64) -> Int{\n        Int::Pos(n)\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Int::i64":["/// Map this value to an `i64`. If the value does not\n/// fit within `[i64::MIN, i64::MAX]`, `None` is returned instead.\npub fn i64(&self) -> Option<i64>{\n        match *self {\n            Int::Neg(n) if n <= i64::MAX as u64 => Some(-1 - n as i64),\n            Int::Pos(n) if n <= i64::MAX as u64 => Some(n as i64),\n            _ => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Int::u64":["/// Map this value to a `u64`. If the value is negative,\n/// `None` is returned instead.\npub fn u64(&self) -> Option<u64>{\n        match *self {\n            Int::Pos(n) => Some(n),\n            _           => None\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Key":["/// CBOR allows heterogenous keys in objects. This enum unifies\n/// all currently allowed key types.\npub enum Key {\n    Bool(bool),\n    Bytes(Bytes),\n    Int(Int),\n    Text(Text)\n}","Real(LocalPath(\"src/value.rs\"))"],"value::Key::i64":["pub fn i64(n: i64) -> Key{\n        Key::Int(Int::from_i64(n))\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Key::u64":["pub fn u64(n: u64) -> Key{\n        Key::Int(Int::from_u64(n))\n    }","Real(LocalPath(\"src/value.rs\"))"],"value::Simple":["/// Most simple types (e.g. `bool` are covered elsewhere) but this\n/// value captures those value ranges of CBOR type `Simple` (major 7)\n/// which are either not assigned or reserved.\npub enum Simple {\n    Unassigned(u8),\n    Reserved(u8)\n}","Real(LocalPath(\"src/value.rs\"))"],"value::Text":["/// A unification of plain and indefinitly sized strings.\npub enum Text {\n    Text(String),\n    Chunks(LinkedList<String>)\n}","Real(LocalPath(\"src/value.rs\"))"],"value::Value":["/// The generic CBOR representation.\npub enum Value {\n    Array(Vec<Value>),\n    Bool(bool),\n    Break,\n    Bytes(Bytes),\n    F32(f32),\n    F64(f64),\n    I8(i8),\n    I16(i16),\n    I32(i32),\n    I64(i64),\n    Int(Int),\n    Map(BTreeMap<Key, Value>),\n    Null,\n    Simple(Simple),\n    Tagged(Tag, Box<Value>),\n    Text(Text),\n    U8(u8),\n    U16(u16),\n    U32(u32),\n    U64(u64),\n    Undefined\n}","Real(LocalPath(\"src/value.rs\"))"],"value::check":["/// Inspect the given `Value` which must be a `Value::Tagged` and\n/// ensure that the `Tag` and type of value match according to\n/// RFC 7049 section 2.4\npub fn check(value: &Value) -> bool{\n    fn fun(t: Tag, b: &Value) -> bool {\n        match (t, b) {\n            (Tag::DateTime, &Value::Text(_))        => true,\n            (Tag::Timestamp, &Value::U8(_))         => true,\n            (Tag::Timestamp, &Value::U16(_))        => true,\n            (Tag::Timestamp, &Value::U32(_))        => true,\n            (Tag::Timestamp, &Value::U64(_))        => true,\n            (Tag::Timestamp, &Value::I8(_))         => true,\n            (Tag::Timestamp, &Value::I16(_))        => true,\n            (Tag::Timestamp, &Value::I32(_))        => true,\n            (Tag::Timestamp, &Value::I64(_))        => true,\n            (Tag::Timestamp, &Value::F32(_))        => true,\n            (Tag::Timestamp, &Value::F64(_))        => true,\n            (Tag::Bignum, &Value::Bytes(_))         => true,\n            (Tag::NegativeBignum, &Value::Bytes(_)) => true,\n            (Tag::ToBase64, _)                      => true,\n            (Tag::ToBase64Url, _)                   => true,\n            (Tag::ToBase16, _)                      => true,\n            (Tag::Cbor, &Value::Bytes(_))           => true,\n            (Tag::Uri, &Value::Text(_))             => true,\n            (Tag::Base64, &Value::Text(_))          => true,\n            (Tag::Base64Url, &Value::Text(_))       => true,\n            (Tag::Regex, &Value::Text(_))           => true,\n            (Tag::Mime, &Value::Text(_))            => true,\n            (Tag::CborSelf, _)                      => true,\n            (Tag::Decimal, &Value::Array(ref a))\n            | (Tag::Bigfloat, &Value::Array(ref a)) => {\n                if a.len() != 2 {\n                    return false\n                }\n                let is_integral = |v: &Value| {\n                    match *v {\n                        Value::U8(_) | Value::U16(_) | Value::U32(_) | Value::U64(_) => true,\n                        Value::I8(_) | Value::I16(_) | Value::I32(_) | Value::I64(_) => true,\n                        _                                                            => false\n                    }\n                };\n                let is_bignum = |v: &Value| {\n                    fun(Tag::Bignum, v) || fun(Tag::NegativeBignum, v)\n                };\n                let ref e = a[0];\n                let ref m = a[1];\n                is_integral(e) && (is_integral(m) || is_bignum(m))\n            }\n            (Tag::Unassigned(_), _) => true,\n            _                       => false\n        }\n    }\n\n    match *value {\n        Value::Tagged(t, ref b) => fun(t, &*b),\n        _                       => false\n    }\n}","Real(LocalPath(\"src/value.rs\"))"],"value::check::fun":["fn fun(t: Tag, b: &Value) -> bool{\n        match (t, b) {\n            (Tag::DateTime, &Value::Text(_))        => true,\n            (Tag::Timestamp, &Value::U8(_))         => true,\n            (Tag::Timestamp, &Value::U16(_))        => true,\n            (Tag::Timestamp, &Value::U32(_))        => true,\n            (Tag::Timestamp, &Value::U64(_))        => true,\n            (Tag::Timestamp, &Value::I8(_))         => true,\n            (Tag::Timestamp, &Value::I16(_))        => true,\n            (Tag::Timestamp, &Value::I32(_))        => true,\n            (Tag::Timestamp, &Value::I64(_))        => true,\n            (Tag::Timestamp, &Value::F32(_))        => true,\n            (Tag::Timestamp, &Value::F64(_))        => true,\n            (Tag::Bignum, &Value::Bytes(_))         => true,\n            (Tag::NegativeBignum, &Value::Bytes(_)) => true,\n            (Tag::ToBase64, _)                      => true,\n            (Tag::ToBase64Url, _)                   => true,\n            (Tag::ToBase16, _)                      => true,\n            (Tag::Cbor, &Value::Bytes(_))           => true,\n            (Tag::Uri, &Value::Text(_))             => true,\n            (Tag::Base64, &Value::Text(_))          => true,\n            (Tag::Base64Url, &Value::Text(_))       => true,\n            (Tag::Regex, &Value::Text(_))           => true,\n            (Tag::Mime, &Value::Text(_))            => true,\n            (Tag::CborSelf, _)                      => true,\n            (Tag::Decimal, &Value::Array(ref a))\n            | (Tag::Bigfloat, &Value::Array(ref a)) => {\n                if a.len() != 2 {\n                    return false\n                }\n                let is_integral = |v: &Value| {\n                    match *v {\n                        Value::U8(_) | Value::U16(_) | Value::U32(_) | Value::U64(_) => true,\n                        Value::I8(_) | Value::I16(_) | Value::I32(_) | Value::I64(_) => true,\n                        _                                                            => false\n                    }\n                };\n                let is_bignum = |v: &Value| {\n                    fun(Tag::Bignum, v) || fun(Tag::NegativeBignum, v)\n                };\n                let ref e = a[0];\n                let ref m = a[1];\n                is_integral(e) && (is_integral(m) || is_bignum(m))\n            }\n            (Tag::Unassigned(_), _) => true,\n            _                       => false\n        }\n    }","Real(LocalPath(\"src/value.rs\"))"]},"struct_constructor":{"&[u8]":["bytes_borrow","raw_slice","read_slice"],"&dyn std::error::Error":["cause"],"&std::string::String":["text_plain"],"&str":["description","text_borrow"],"&value::Bytes":["bytes"],"&value::Text":["text"],"&value::Value":["value"],"(types::Type, u8)":["go","read","typeinfo"],"bool":["bool","check","eq","fun","is_break","is_null","is_undefined","skip_value"],"decoder::BytesIter":["bytes_iter"],"decoder::Config":["clone","default"],"decoder::DecodeError":["from"],"decoder::Decoder":["into_inner","new"],"decoder::GenericDecoder":["from_decoder","new"],"decoder::Kernel":["new"],"decoder::TextIter":["text_iter"],"encoder::EncodeError":["from"],"encoder::Encoder":["into_inner","new"],"encoder::GenericEncoder":["from_encoder","new"],"f32":["f16","f32","float32"],"f64":["f64","float64"],"i16":["i16"],"i32":["i32"],"i64":["i64"],"i8":["i8"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::string::String":["next","text"],"std::vec::Vec":["bytes","next","raw_data"],"types::Tag":["clone","of","tag"],"types::Type":["clone"],"u16":["u16"],"u32":["u32"],"u64":["to","u64","unsigned"],"u8":["major","u8"],"usize":["array","object","read_bytes","read_raw_data"],"value::Bytes":["clone"],"value::Cursor":["at","field","get","maybe","new","of","opt"],"value::Int":["clone","from_i64","from_u64","int"],"value::Key":["clone","decode_key","i64","u64"],"value::Simple":["clone","simple"],"value::Text":["clone"],"value::Value":["clone","decode_value","value"]},"struct_to_trait":{"<A as skip::Skip>::A":["skip::Skip"],"decoder::BytesIter":["std::iter::Iterator"],"decoder::Config":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"decoder::DecodeError":["std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display"],"decoder::TextIter":["std::iter::Iterator"],"encoder::EncodeError":["std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display"],"slice::ReadSliceError":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"std::io::Cursor":["slice::ReadSlice"],"types::Tag":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"types::Type":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"value::Bytes":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"value::Int":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"value::Key":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"value::Simple":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"value::Text":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"value::Value":["std::clone::Clone","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::StructuralPartialEq"]},"targets":{"<A as skip::Skip>::skip":["skip","Real(LocalPath(\"src/skip.rs\"))","skip::Skip"],"<decoder::BytesIter<'r, R> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/decoder.rs\"))","std::iter::Iterator"],"<decoder::DecodeError as std::convert::From<slice::ReadSliceError>>::from":["from","Real(LocalPath(\"src/decoder.rs\"))","std::convert::From"],"<decoder::DecodeError as std::convert::From<std::io::Error>>::from":["from","Real(LocalPath(\"src/decoder.rs\"))","std::convert::From"],"<decoder::DecodeError as std::convert::From<std::str::Utf8Error>>::from":["from","Real(LocalPath(\"src/decoder.rs\"))","std::convert::From"],"<decoder::DecodeError as std::convert::From<std::string::FromUtf8Error>>::from":["from","Real(LocalPath(\"src/decoder.rs\"))","std::convert::From"],"<decoder::DecodeError as std::error::Error>::cause":["cause","Real(LocalPath(\"src/decoder.rs\"))","std::error::Error"],"<decoder::DecodeError as std::error::Error>::description":["description","Real(LocalPath(\"src/decoder.rs\"))","std::error::Error"],"<decoder::DecodeError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/decoder.rs\"))","std::fmt::Display"],"<decoder::TextIter<'r, R> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/decoder.rs\"))","std::iter::Iterator"],"<encoder::EncodeError as std::convert::From<std::io::Error>>::from":["from","Real(LocalPath(\"src/encoder.rs\"))","std::convert::From"],"<encoder::EncodeError as std::error::Error>::cause":["cause","Real(LocalPath(\"src/encoder.rs\"))","std::error::Error"],"<encoder::EncodeError as std::error::Error>::description":["description","Real(LocalPath(\"src/encoder.rs\"))","std::error::Error"],"<encoder::EncodeError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/encoder.rs\"))","std::fmt::Display"],"<slice::ReadSliceError as std::error::Error>::cause":["cause","Real(LocalPath(\"src/slice.rs\"))","std::error::Error"],"<slice::ReadSliceError as std::error::Error>::description":["description","Real(LocalPath(\"src/slice.rs\"))","std::error::Error"],"<slice::ReadSliceError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/slice.rs\"))","std::fmt::Display"],"<std::io::Cursor<&'r [u8]> as slice::ReadSlice>::read_slice":["read_slice","Real(LocalPath(\"src/slice.rs\"))","slice::ReadSlice"],"<std::io::Cursor<std::vec::Vec<u8>> as slice::ReadSlice>::read_slice":["read_slice","Real(LocalPath(\"src/slice.rs\"))","slice::ReadSlice"],"decoder::Config::default":["default","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::array":["array","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::array_begin":["array_begin","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::bool":["bool","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::bytes":["bytes","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::bytes_borrow":["bytes_borrow","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::bytes_iter":["bytes_iter","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::f16":["f16","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::f32":["f32","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::f64":["f64","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::i16":["i16","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::i32":["i32","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::i64":["i64","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::i8":["i8","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::int":["int","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::into_reader":["into_reader","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::kernel":["kernel","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::new":["new","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::object":["object","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::object_begin":["object_begin","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::read_bytes":["read_bytes","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::simple":["simple","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::skip":["skip","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::skip_until_break":["skip_until_break","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::skip_value":["skip_value","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::tag":["tag","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::text":["text","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::text_borrow":["text_borrow","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::text_iter":["text_iter","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::typeinfo":["typeinfo","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::typeinfo::go":["go","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::u16":["u16","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::u32":["u32","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::u64":["u64","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Decoder::<R>::u8":["u8","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::GenericDecoder::<R>::borrow_mut":["borrow_mut","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::GenericDecoder::<R>::decode_key":["decode_key","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::GenericDecoder::<R>::decode_value":["decode_value","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::GenericDecoder::<R>::from_decoder":["from_decoder","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::GenericDecoder::<R>::into_inner":["into_inner","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::GenericDecoder::<R>::new":["new","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::GenericDecoder::<R>::value":["value","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::bool":["bool","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::f16":["f16","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::f32":["f32","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::f64":["f64","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::i16":["i16","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::i32":["i32","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::i64":["i64","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::i8":["i8","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::int":["int","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::into_reader":["into_reader","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::new":["new","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::raw_data":["raw_data","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::raw_slice":["raw_slice","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::read_raw_data":["read_raw_data","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::simple":["simple","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::typeinfo":["typeinfo","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::u16":["u16","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::u32":["u32","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::u64":["u64","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::u8":["u8","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::Kernel::<R>::unsigned":["unsigned","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::ffi::c_ldexpf":["c_ldexpf","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::is_break":["is_break","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::is_null":["is_null","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::is_undefined":["is_undefined","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::maybe":["maybe","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::opt":["opt","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::or_break":["or_break","Real(LocalPath(\"src/decoder.rs\"))",""],"decoder::unexpected_type":["unexpected_type","Real(LocalPath(\"src/decoder.rs\"))",""],"encoder::Encoder::<W>::array":["array","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::array_begin":["array_begin","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::array_end":["array_end","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::bool":["bool","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::bytes":["bytes","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::bytes_iter":["bytes_iter","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::f32":["f32","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::f64":["f64","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::i16":["i16","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::i32":["i32","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::i64":["i64","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::i8":["i8","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::int":["int","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::into_writer":["into_writer","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::new":["new","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::null":["null","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::object":["object","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::object_begin":["object_begin","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::object_end":["object_end","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::simple":["simple","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::tag":["tag","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::text":["text","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::text_iter":["text_iter","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::type_len":["type_len","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::u16":["u16","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::u32":["u32","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::u64":["u64","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::u8":["u8","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::undefined":["undefined","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::Encoder::<W>::writer":["writer","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::GenericEncoder::<W>::borrow_mut":["borrow_mut","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::GenericEncoder::<W>::from_encoder":["from_encoder","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::GenericEncoder::<W>::into_inner":["into_inner","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::GenericEncoder::<W>::key":["key","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::GenericEncoder::<W>::new":["new","Real(LocalPath(\"src/encoder.rs\"))",""],"encoder::GenericEncoder::<W>::value":["value","Real(LocalPath(\"src/encoder.rs\"))",""],"types::Tag::of":["of","Real(LocalPath(\"src/types.rs\"))",""],"types::Tag::to":["to","Real(LocalPath(\"src/types.rs\"))",""],"types::Type::major":["major","Real(LocalPath(\"src/types.rs\"))",""],"types::Type::read":["read","Real(LocalPath(\"src/types.rs\"))",""],"value::Cursor::<'r>::at":["at","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::bool":["bool","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::bytes":["bytes","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::bytes_chunked":["bytes_chunked","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::bytes_plain":["bytes_plain","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::field":["field","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::float32":["float32","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::float64":["float64","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::get":["get","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::i16":["i16","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::i32":["i32","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::i64":["i64","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::i8":["i8","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::maybe":["maybe","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::new":["new","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::of":["of","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::opt":["opt","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::text":["text","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::text_chunked":["text_chunked","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::text_plain":["text_plain","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::u16":["u16","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::u32":["u32","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::u64":["u64","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::u8":["u8","Real(LocalPath(\"src/value.rs\"))",""],"value::Cursor::<'r>::value":["value","Real(LocalPath(\"src/value.rs\"))",""],"value::Int::from_i64":["from_i64","Real(LocalPath(\"src/value.rs\"))",""],"value::Int::from_u64":["from_u64","Real(LocalPath(\"src/value.rs\"))",""],"value::Int::i64":["i64","Real(LocalPath(\"src/value.rs\"))",""],"value::Int::u64":["u64","Real(LocalPath(\"src/value.rs\"))",""],"value::Key::i64":["i64","Real(LocalPath(\"src/value.rs\"))",""],"value::Key::u64":["u64","Real(LocalPath(\"src/value.rs\"))",""],"value::check":["check","Real(LocalPath(\"src/value.rs\"))",""],"value::check::fun":["fun","Real(LocalPath(\"src/value.rs\"))",""]},"trait_to_struct":{"skip::Skip":["<A as skip::Skip>::A"],"slice::ReadSlice":["std::io::Cursor"],"std::clone::Clone":["decoder::Config","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"std::cmp::Eq":["decoder::Config","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text"],"std::cmp::Ord":["types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text"],"std::cmp::PartialEq":["decoder::Config","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"std::cmp::PartialOrd":["types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"std::convert::From":["decoder::DecodeError","encoder::EncodeError"],"std::error::Error":["decoder::DecodeError","encoder::EncodeError","slice::ReadSliceError"],"std::fmt::Debug":["decoder::Config","decoder::DecodeError","encoder::EncodeError","slice::ReadSliceError","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"],"std::fmt::Display":["decoder::DecodeError","encoder::EncodeError","slice::ReadSliceError"],"std::hash::Hash":["types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text"],"std::iter::Iterator":["decoder::BytesIter","decoder::TextIter"],"std::marker::Copy":["types::Tag","types::Type","value::Int","value::Simple"],"std::marker::StructuralEq":["decoder::Config","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text"],"std::marker::StructuralPartialEq":["decoder::Config","types::Tag","types::Type","value::Bytes","value::Int","value::Key","value::Simple","value::Text","value::Value"]},"type_to_def_path":{"decoder::BytesIter<'r, R>":"decoder::BytesIter","decoder::Config":"decoder::Config","decoder::DecodeError":"decoder::DecodeError","decoder::Decoder<R>":"decoder::Decoder","decoder::GenericDecoder<R>":"decoder::GenericDecoder","decoder::Kernel<R>":"decoder::Kernel","decoder::TextIter<'r, R>":"decoder::TextIter","encoder::EncodeError":"encoder::EncodeError","encoder::Encoder<W>":"encoder::Encoder","encoder::GenericEncoder<W>":"encoder::GenericEncoder","slice::ReadSliceError":"slice::ReadSliceError","types::Tag":"types::Tag","types::Type":"types::Type","value::Bytes":"value::Bytes","value::Cursor<'r>":"value::Cursor","value::Int":"value::Int","value::Key":"value::Key","value::Simple":"value::Simple","value::Text":"value::Text","value::Value":"value::Value"}}