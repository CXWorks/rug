{"dependencies":{"<&'a byte_record::ByteRecord as std::cmp::PartialEq<[T]>>::eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<&'a byte_record::ByteRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_any":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_bool":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_byte_buf":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_bytes":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_char":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_enum":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_f32":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_f64":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i128":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i16":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i32":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i64":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i8":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_identifier":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_ignored_any":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_map":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_newtype_struct":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_option":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_seq":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_str":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_string":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_struct":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_tuple":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_tuple_struct":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u128":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u16":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u32":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u64":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u8":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_unit":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_unit_struct":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::EnumAccess<'de>>::variant_seed":["deserializer::DeRecordWrap","serde::de::DeserializeSeed","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::MapAccess<'de>>::next_key_seed":["deserializer::DeRecordWrap","serde::de::DeserializeSeed","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::MapAccess<'de>>::next_value_seed":["deserializer::DeRecordWrap","serde::de::DeserializeSeed","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::SeqAccess<'de>>::next_element_seed":["deserializer::DeRecordWrap","serde::de::DeserializeSeed","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["deserializer::DeRecordWrap","serde::de::DeserializeSeed","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::struct_variant":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::tuple_variant":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::unit_variant":["deserializer::DeRecordWrap","std::marker::Sized","std::result::Result"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_bool":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_bytes":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_char":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_f32":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_f64":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i128":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i16":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i32":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i64":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i8":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_map":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_newtype_struct":["csv_core::Writer","error::Error","serde::Serialize","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_newtype_variant":["csv_core::Writer","error::Error","serde::Serialize","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_none":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_seq":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_some":["csv_core::Writer","error::Error","serde::Serialize","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_str":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_struct":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_struct_variant":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_tuple":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_tuple_struct":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_tuple_variant":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u128":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u16":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u32":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u64":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u8":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_unit":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_unit_struct":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_unit_variant":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeMap>::end":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeMap>::serialize_key":["csv_core::Writer","error::Error","serde::Serialize","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeMap>::serialize_value":["csv_core::Writer","error::Error","serde::Serialize","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeSeq>::end":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeSeq>::serialize_element":["csv_core::Writer","error::Error","serde::Serialize","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStruct>::end":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStruct>::serialize_field":["csv_core::Writer","error::Error","serde::Serialize","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStructVariant>::end":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStructVariant>::serialize_field":["csv_core::Writer","error::Error","serde::Serialize","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTuple>::end":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTuple>::serialize_element":["csv_core::Writer","error::Error","serde::Serialize","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleStruct>::end":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleStruct>::serialize_field":["csv_core::Writer","error::Error","serde::Serialize","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleVariant>::end":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleVariant>::serialize_field":["csv_core::Writer","error::Error","serde::Serialize","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_bool":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_bytes":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_char":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_f32":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_f64":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i128":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i16":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i32":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i64":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i8":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_map":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_newtype_struct":["csv_core::Writer","serde::Serialize","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_newtype_variant":["csv_core::Writer","serde::Serialize","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_none":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_seq":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_some":["csv_core::Writer","serde::Serialize","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_str":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_struct":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_struct_variant":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_tuple":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_tuple_struct":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_tuple_variant":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u128":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u16":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u32":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u64":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u8":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_unit":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_unit_struct":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_unit_variant":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeMap>::end":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeMap>::serialize_key":["csv_core::Writer","serde::Serialize","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeMap>::serialize_value":["csv_core::Writer","serde::Serialize","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeSeq>::end":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeSeq>::serialize_element":["csv_core::Writer","serde::Serialize","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStruct>::end":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStruct>::serialize_field":["csv_core::Writer","serde::Serialize","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStructVariant>::end":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStructVariant>::serialize_field":["csv_core::Writer","serde::Serialize","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTuple>::end":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTuple>::serialize_element":["csv_core::Writer","serde::Serialize","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleStruct>::end":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleStruct>::serialize_field":["csv_core::Writer","serde::Serialize","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleVariant>::end":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleVariant>::serialize_field":["csv_core::Writer","serde::Serialize","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<&'a string_record::StringRecord as std::cmp::PartialEq<[T]>>::eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"<&'a string_record::StringRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","string_record::StringRecord"],"<&'a string_record::StringRecord as std::iter::IntoIterator>::into_iter":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord","string_record::StringRecordIter"],"<&'r byte_record::ByteRecord as std::iter::IntoIterator>::into_iter":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<QuoteStyle as std::clone::Clone>::clone":["QuoteStyle"],"<QuoteStyle as std::default::Default>::default":["QuoteStyle"],"<QuoteStyle as std::fmt::Debug>::fmt":["QuoteStyle","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<Terminator as std::clone::Clone>::clone":["Terminator"],"<Terminator as std::default::Default>::default":["Terminator"],"<Terminator as std::fmt::Debug>::fmt":["Terminator","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<Trim as std::clone::Clone>::clone":["Trim"],"<Trim as std::cmp::PartialEq>::eq":["Trim"],"<Trim as std::default::Default>::default":["Trim"],"<Trim as std::fmt::Debug>::fmt":["Trim","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<byte_record::Bounds as std::clone::Clone>::clone":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<byte_record::Bounds as std::cmp::Eq>::assert_receiver_is_total_eq":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<byte_record::Bounds as std::cmp::PartialEq>::eq":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<byte_record::Bounds as std::default::Default>::default":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<byte_record::Bounds as std::fmt::Debug>::fmt":["byte_record::Bounds","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<byte_record::ByteRecord as std::clone::Clone>::clone":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<byte_record::ByteRecord as std::cmp::Eq>::assert_receiver_is_total_eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<byte_record::ByteRecord as std::cmp::PartialEq<[T]>>::eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<byte_record::ByteRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"<byte_record::ByteRecord as std::cmp::PartialEq>::eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<byte_record::ByteRecord as std::convert::From<&'a [T]>>::from":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<byte_record::ByteRecord as std::convert::From<std::vec::Vec<T>>>::from":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"<byte_record::ByteRecord as std::convert::From<string_record::StringRecord>>::from":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"<byte_record::ByteRecord as std::default::Default>::default":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<byte_record::ByteRecord as std::fmt::Debug>::fmt":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<byte_record::ByteRecord as std::iter::Extend<T>>::extend":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::iter::IntoIterator","std::marker::Sized"],"<byte_record::ByteRecord as std::iter::FromIterator<T>>::from_iter":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::iter::IntoIterator","std::marker::Sized"],"<byte_record::ByteRecord as std::ops::Index<usize>>::index":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<byte_record::ByteRecordInner as std::clone::Clone>::clone":["byte_record::Bounds","byte_record::ByteRecordInner","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<byte_record::ByteRecordInner as std::cmp::Eq>::assert_receiver_is_total_eq":["byte_record::Bounds","byte_record::ByteRecordInner","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<byte_record::ByteRecordInner as std::cmp::PartialEq>::eq":["byte_record::Bounds","byte_record::ByteRecordInner","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<byte_record::ByteRecordInner as std::fmt::Debug>::fmt":["byte_record::Bounds","byte_record::ByteRecordInner","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<byte_record::ByteRecordIter<'r> as std::iter::DoubleEndedIterator>::next_back":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<byte_record::ByteRecordIter<'r> as std::iter::Iterator>::count":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<byte_record::ByteRecordIter<'r> as std::iter::Iterator>::next":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<byte_record::ByteRecordIter<'r> as std::iter::Iterator>::size_hint":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<byte_record::Position as std::clone::Clone>::clone":["byte_record::Position"],"<byte_record::Position as std::cmp::Eq>::assert_receiver_is_total_eq":["byte_record::Position"],"<byte_record::Position as std::cmp::PartialEq>::eq":["byte_record::Position"],"<byte_record::Position as std::fmt::Debug>::fmt":["byte_record::Position","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::error":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeByteRecord","deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::has_headers":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeByteRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::infer_deserialize":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeByteRecord","serde::de::Visitor","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option","std::result::Result"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_field":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeByteRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option","std::result::Result"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_field_bytes":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeByteRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option","std::result::Result"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_header":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeByteRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option","std::result::Result"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_header_bytes":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeByteRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option","std::result::Result"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::peek_field":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeByteRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::error":["deserializer::DeRecordWrap","deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::has_headers":["deserializer::DeRecordWrap","std::marker::Sized"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::infer_deserialize":["deserializer::DeRecordWrap","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_field":["deserializer::DeRecordWrap","std::marker::Sized","std::result::Result"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_field_bytes":["deserializer::DeRecordWrap","std::marker::Sized","std::result::Result"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_header":["deserializer::DeRecordWrap","std::marker::Sized","std::result::Result"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_header_bytes":["deserializer::DeRecordWrap","std::marker::Sized","std::result::Result"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::peek_field":["deserializer::DeRecordWrap","std::marker::Sized","std::option::Option"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::error":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeStringRecord","deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::has_headers":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeStringRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::infer_deserialize":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeStringRecord","serde::de::Visitor","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option","std::result::Result"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_field":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeStringRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option","std::result::Result"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_field_bytes":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeStringRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option","std::result::Result"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_header":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeStringRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option","std::result::Result"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_header_bytes":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeStringRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option","std::result::Result"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::peek_field":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeStringRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option"],"<deserializer::DeserializeError as serde::de::Error>::custom":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::fmt::Display","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeserializeError as std::clone::Clone>::clone":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeserializeError as std::cmp::Eq>::assert_receiver_is_total_eq":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeserializeError as std::cmp::PartialEq>::eq":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeserializeError as std::error::Error>::description":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeserializeError as std::fmt::Debug>::fmt":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::fmt::Formatter","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::result::Result","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeserializeError as std::fmt::Display>::fmt":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::fmt::Formatter","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::result::Result","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeserializeErrorKind as std::clone::Clone>::clone":["deserializer::DeserializeErrorKind","std::num::ParseFloatError","std::num::ParseIntError","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeserializeErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq":["deserializer::DeserializeErrorKind","std::num::ParseFloatError","std::num::ParseIntError","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeserializeErrorKind as std::cmp::PartialEq>::eq":["deserializer::DeserializeErrorKind","std::num::ParseFloatError","std::num::ParseIntError","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeserializeErrorKind as std::fmt::Debug>::fmt":["deserializer::DeserializeErrorKind","std::fmt::Formatter","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::result::Result","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<deserializer::DeserializeErrorKind as std::fmt::Display>::fmt":["deserializer::DeserializeErrorKind","std::fmt::Formatter","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::result::Result","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<error::Error as std::convert::From<std::io::Error>>::from":["error::Error","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized"],"<error::Error as std::error::Error>::source":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<error::Error as std::fmt::Debug>::fmt":["error::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error as std::fmt::Display>::fmt":["error::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::ErrorKind as std::fmt::Debug>::fmt":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::ErrorKind","error::Utf8Error","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::result::Result","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"<error::FromUtf8Error as std::clone::Clone>::clone":["byte_record::ByteRecord","error::FromUtf8Error","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::FromUtf8Error as std::cmp::Eq>::assert_receiver_is_total_eq":["byte_record::ByteRecord","error::FromUtf8Error","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::FromUtf8Error as std::cmp::PartialEq>::eq":["byte_record::ByteRecord","error::FromUtf8Error","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::FromUtf8Error as std::error::Error>::source":["byte_record::ByteRecord","error::FromUtf8Error","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<error::FromUtf8Error as std::fmt::Debug>::fmt":["byte_record::ByteRecord","error::FromUtf8Error","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::FromUtf8Error as std::fmt::Display>::fmt":["byte_record::ByteRecord","error::FromUtf8Error","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::IntoInnerError<W> as std::error::Error>::source":["error::IntoInnerError","std::io::Error","std::marker::Sized","std::option::Option"],"<error::IntoInnerError<W> as std::fmt::Debug>::fmt":["error::IntoInnerError","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result"],"<error::IntoInnerError<W> as std::fmt::Display>::fmt":["error::IntoInnerError","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result"],"<error::Utf8Error as std::clone::Clone>::clone":["error::Utf8Error"],"<error::Utf8Error as std::cmp::Eq>::assert_receiver_is_total_eq":["error::Utf8Error"],"<error::Utf8Error as std::cmp::PartialEq>::eq":["error::Utf8Error"],"<error::Utf8Error as std::fmt::Debug>::fmt":["error::Utf8Error","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Utf8Error as std::fmt::Display>::fmt":["error::Utf8Error","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reader::ByteRecordsIntoIter<R> as std::iter::Iterator>::next":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"<reader::ByteRecordsIter<'r, R> as std::iter::Iterator>::next":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"<reader::DeserializeRecordsIntoIter<R, D> as std::iter::Iterator>::next":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"<reader::DeserializeRecordsIter<'r, R, D> as std::iter::Iterator>::next":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"<reader::Headers as std::fmt::Debug>::fmt":["byte_record::ByteRecord","reader::Headers","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reader::Reader<R> as std::fmt::Debug>::fmt":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::io::BufReader","std::marker::Sized","std::option::Option","std::result::Result"],"<reader::ReaderBuilder as std::default::Default>::default":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<reader::ReaderBuilder as std::fmt::Debug>::fmt":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reader::ReaderState as std::fmt::Debug>::fmt":["Trim","byte_record::Position","reader::ReaderState","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<reader::StringRecordsIntoIter<R> as std::iter::Iterator>::next":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIntoIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"<reader::StringRecordsIter<'r, R> as std::iter::Iterator>::next":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"<string_record::StringRecord as std::clone::Clone>::clone":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"<string_record::StringRecord as std::cmp::Eq>::assert_receiver_is_total_eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"<string_record::StringRecord as std::cmp::PartialEq<[T]>>::eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"<string_record::StringRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","string_record::StringRecord"],"<string_record::StringRecord as std::cmp::PartialEq>::eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"<string_record::StringRecord as std::convert::From<&'a [T]>>::from":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"<string_record::StringRecord as std::convert::From<std::vec::Vec<T>>>::from":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","string_record::StringRecord"],"<string_record::StringRecord as std::default::Default>::default":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"<string_record::StringRecord as std::fmt::Debug>::fmt":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","string_record::StringRecord"],"<string_record::StringRecord as std::iter::Extend<T>>::extend":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::iter::IntoIterator","std::marker::Sized","string_record::StringRecord"],"<string_record::StringRecord as std::iter::FromIterator<T>>::from_iter":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::iter::IntoIterator","std::marker::Sized","string_record::StringRecord"],"<string_record::StringRecord as std::ops::Index<usize>>::index":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"<string_record::StringRecordIter<'r> as std::iter::DoubleEndedIterator>::next_back":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","string_record::StringRecordIter"],"<string_record::StringRecordIter<'r> as std::iter::Iterator>::count":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecordIter"],"<string_record::StringRecordIter<'r> as std::iter::Iterator>::next":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","string_record::StringRecordIter"],"<string_record::StringRecordIter<'r> as std::iter::Iterator>::size_hint":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","string_record::StringRecordIter"],"<writer::Buffer as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","writer::Buffer"],"<writer::HeaderState as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","writer::HeaderState"],"<writer::Writer<W> as std::fmt::Debug>::fmt":["csv_core::Writer","std::alloc::Allocator","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<writer::Writer<W> as std::ops::Drop>::drop":["csv_core::Writer","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"<writer::WriterBuilder as std::default::Default>::default":["csv_core::WriterBuilder","writer::WriterBuilder"],"<writer::WriterBuilder as std::fmt::Debug>::fmt":["csv_core::WriterBuilder","std::fmt::Formatter","std::marker::Sized","std::result::Result","writer::WriterBuilder"],"<writer::WriterState as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","writer::HeaderState","writer::WriterState"],"QuoteStyle":["QuoteStyle"],"QuoteStyle::to_core":["QuoteStyle","csv_core::QuoteStyle"],"Terminator":["Terminator"],"Terminator::to_core":["Terminator","csv_core::Terminator"],"Trim":["Trim"],"Trim::should_trim_fields":["Trim"],"Trim::should_trim_headers":["Trim"],"byte_record::Bounds":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"byte_record::Bounds::add":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"byte_record::Bounds::end":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"byte_record::Bounds::ends":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"byte_record::Bounds::expand":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"byte_record::Bounds::get":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"byte_record::Bounds::len":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"byte_record::Bounds::with_capacity":["byte_record::Bounds","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"byte_record::ByteRecord":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::as_parts":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"byte_record::ByteRecord::as_slice":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::clear":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::deserialize":["byte_record::ByteRecord","serde::Deserialize","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result"],"byte_record::ByteRecord::expand_ends":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::expand_fields":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::get":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"byte_record::ByteRecord::is_empty":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::iter":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::iter_eq":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::convert::AsRef","std::iter::IntoIterator","std::marker::Sized"],"byte_record::ByteRecord::len":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::new":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::position":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"byte_record::ByteRecord::push_field":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::range":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"byte_record::ByteRecord::set_len":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::set_position":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"byte_record::ByteRecord::trim":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::truncate":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecord::validate":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"byte_record::ByteRecord::with_capacity":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::ByteRecordInner":["byte_record::Bounds","byte_record::ByteRecordInner","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"byte_record::ByteRecordIter":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"byte_record::Position":["byte_record::Position"],"byte_record::Position::byte":["byte_record::Position"],"byte_record::Position::line":["byte_record::Position"],"byte_record::Position::new":["byte_record::Position"],"byte_record::Position::record":["byte_record::Position"],"byte_record::Position::set_byte":["byte_record::Position"],"byte_record::Position::set_line":["byte_record::Position"],"byte_record::Position::set_record":["byte_record::Position"],"deserializer::DeByteRecord":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeByteRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option"],"deserializer::DeRecord::error":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"deserializer::DeRecord::has_headers":[],"deserializer::DeRecord::infer_deserialize":["serde::de::Visitor","std::marker::Sized","std::result::Result"],"deserializer::DeRecord::next_field":["std::marker::Sized","std::result::Result"],"deserializer::DeRecord::next_field_bytes":["std::marker::Sized","std::result::Result"],"deserializer::DeRecord::next_header":["std::marker::Sized","std::result::Result"],"deserializer::DeRecord::next_header_bytes":["std::marker::Sized","std::result::Result"],"deserializer::DeRecord::peek_field":["std::marker::Sized","std::option::Option"],"deserializer::DeRecordWrap":["deserializer::DeRecordWrap","std::marker::Sized"],"deserializer::DeStringRecord":["byte_record::ByteRecord","byte_record::ByteRecordIter","deserializer::DeStringRecord","std::alloc::Allocator","std::boxed::Box","std::iter::Iterator","std::iter::Peekable","std::marker::Sized","std::option::Option"],"deserializer::DeserializeError":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"deserializer::DeserializeError::field":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"deserializer::DeserializeError::kind":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"deserializer::DeserializeErrorKind":["deserializer::DeserializeErrorKind","std::num::ParseFloatError","std::num::ParseIntError","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"deserializer::DeserializeErrorKind::description":["deserializer::DeserializeErrorKind","std::num::ParseFloatError","std::num::ParseIntError","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"deserializer::deserialize_byte_record":["byte_record::ByteRecord","serde::Deserialize","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result"],"deserializer::deserialize_string_record":["byte_record::ByteRecord","serde::Deserialize","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result","string_record::StringRecord"],"deserializer::try_float":["std::marker::Sized","std::option::Option"],"deserializer::try_float_bytes":["std::marker::Sized","std::option::Option"],"deserializer::try_negative_integer128":["std::marker::Sized","std::option::Option"],"deserializer::try_negative_integer128_bytes":["std::marker::Sized","std::option::Option"],"deserializer::try_negative_integer64":["std::marker::Sized","std::option::Option"],"deserializer::try_negative_integer64_bytes":["std::marker::Sized","std::option::Option"],"deserializer::try_positive_integer128":["std::marker::Sized","std::option::Option"],"deserializer::try_positive_integer128_bytes":["std::marker::Sized","std::option::Option"],"deserializer::try_positive_integer64":["std::marker::Sized","std::option::Option"],"deserializer::try_positive_integer64_bytes":["std::marker::Sized","std::option::Option"],"error::<impl std::convert::From<error::Error> for std::io::Error>::from":["error::Error","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized"],"error::Error":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Error::into_kind":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::Error","error::ErrorKind","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"error::Error::is_io_error":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Error::kind":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::Error","error::ErrorKind","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"error::Error::new":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::Error","error::ErrorKind","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"error::Error::position":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"error::ErrorKind":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::ErrorKind","error::Utf8Error","std::io::Error","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"error::ErrorKind::position":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::ErrorKind","error::Utf8Error","std::io::Error","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"error::FromUtf8Error":["byte_record::ByteRecord","error::FromUtf8Error","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::FromUtf8Error::into_byte_record":["byte_record::ByteRecord","error::FromUtf8Error","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::FromUtf8Error::new":["byte_record::ByteRecord","error::FromUtf8Error","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::FromUtf8Error::utf8_error":["byte_record::ByteRecord","error::FromUtf8Error","error::Utf8Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::IntoInnerError":["error::IntoInnerError","std::io::Error","std::marker::Sized"],"error::IntoInnerError::<W>::error":["error::IntoInnerError","std::io::Error","std::marker::Sized"],"error::IntoInnerError::<W>::into_inner":["error::IntoInnerError","std::io::Error","std::marker::Sized"],"error::IntoInnerError::<W>::new":["error::IntoInnerError","std::io::Error","std::marker::Sized"],"error::Utf8Error":["error::Utf8Error"],"error::Utf8Error::field":["error::Utf8Error"],"error::Utf8Error::valid_up_to":["error::Utf8Error"],"error::new_utf8_error":["error::Utf8Error"],"invalid_option":["serde::Deserialize","serde::Deserializer","std::marker::Sized","std::result::Result"],"reader::ByteRecordsIntoIter":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::ByteRecordsIntoIter::<R>::into_reader":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::ByteRecordsIntoIter::<R>::new":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::ByteRecordsIntoIter::<R>::reader":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::ByteRecordsIntoIter::<R>::reader_mut":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::ByteRecordsIter":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::ByteRecordsIter::<'r, R>::new":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::ByteRecordsIter::<'r, R>::reader":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::ByteRecordsIter::<'r, R>::reader_mut":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::DeserializeRecordsIntoIter":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::DeserializeRecordsIntoIter::<R, D>::into_reader":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::DeserializeRecordsIntoIter::<R, D>::new":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::DeserializeRecordsIntoIter::<R, D>::reader":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::DeserializeRecordsIntoIter::<R, D>::reader_mut":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::DeserializeRecordsIter":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::DeserializeRecordsIter::<'r, R, D>::new":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::DeserializeRecordsIter::<'r, R, D>::reader":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::DeserializeRecordsIter::<'r, R, D>::reader_mut":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::Headers":["byte_record::ByteRecord","reader::Headers","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"reader::Reader":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::byte_headers":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","std::result::Result"],"reader::Reader::<R>::byte_records":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::deserialize":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIter","reader::Reader","reader::ReaderState","serde::de::DeserializeOwned","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::Reader::<R>::from_reader":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::get_mut":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::get_ref":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::has_headers":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::headers":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","std::result::Result"],"reader::Reader::<R>::into_byte_records":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ByteRecordsIntoIter","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::into_deserialize":["Trim","byte_record::ByteRecord","byte_record::Position","reader::DeserializeRecordsIntoIter","reader::Reader","reader::ReaderState","serde::de::DeserializeOwned","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::PhantomData","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::Reader::<R>::into_inner":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::into_records":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIntoIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::Reader::<R>::is_done":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::new":["Trim","byte_record::Position","reader::Reader","reader::ReaderBuilder","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::position":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::read_byte_record":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","std::result::Result"],"reader::Reader::<R>::read_byte_record_impl":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","std::result::Result"],"reader::Reader::<R>::read_record":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","std::result::Result","string_record::StringRecord"],"reader::Reader::<R>::records":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::Reader::<R>::seek":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","std::result::Result"],"reader::Reader::<R>::seek_raw":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::io::SeekFrom","std::marker::Sized","std::option::Option","std::result::Result"],"reader::Reader::<R>::set_byte_headers":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option"],"reader::Reader::<R>::set_headers":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::Reader::<R>::set_headers_impl":["Trim","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","std::result::Result"],"reader::Reader::<reader::Reader<std::fs::File>>::from_path":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"reader::ReaderBuilder":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::ascii":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::buffer_capacity":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::comment":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"reader::ReaderBuilder::delimiter":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::double_quote":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::escape":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"reader::ReaderBuilder::flexible":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::from_path":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::convert::AsRef","std::marker::Sized","std::result::Result"],"reader::ReaderBuilder::from_reader":["Trim","byte_record::Position","reader::Reader","reader::ReaderBuilder","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::io::Read","std::marker::Sized","std::option::Option"],"reader::ReaderBuilder::has_headers":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::new":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::nfa":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::quote":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::quoting":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::terminator":["Terminator","Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderBuilder::trim":["Trim","reader::ReaderBuilder","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"reader::ReaderState":["Trim","byte_record::Position","reader::ReaderState","std::marker::Sized","std::option::Option"],"reader::ReaderState::add_record":["Trim","byte_record::ByteRecord","byte_record::Position","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result"],"reader::StringRecordsIntoIter":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIntoIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::StringRecordsIntoIter::<R>::into_reader":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIntoIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::StringRecordsIntoIter::<R>::new":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIntoIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::StringRecordsIntoIter::<R>::reader":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIntoIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::StringRecordsIntoIter::<R>::reader_mut":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIntoIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::StringRecordsIter":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::StringRecordsIter::<'r, R>::new":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::StringRecordsIter::<'r, R>::reader":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"reader::StringRecordsIter::<'r, R>::reader_mut":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","reader::StringRecordsIter","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::marker::Sized","std::option::Option","string_record::StringRecord"],"serializer::<impl serde::ser::Error for error::Error>::custom":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"serializer::HeaderState":["error::Error","serializer::HeaderState","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"serializer::SeHeader":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"serializer::SeHeader::<'w, W>::handle_container":["csv_core::Writer","deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::io::Write","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::result::Result","std::str::ParseBoolError","std::str::Utf8Error","std::string::String","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"serializer::SeHeader::<'w, W>::handle_scalar":["csv_core::Writer","deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::io::Write","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::result::Result","std::str::ParseBoolError","std::str::Utf8Error","std::string::String","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"serializer::SeHeader::<'w, W>::new":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"serializer::SeHeader::<'w, W>::wrote_header":["csv_core::Writer","error::Error","serializer::HeaderState","serializer::SeHeader","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"serializer::SeRecord":["csv_core::Writer","serializer::SeRecord","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"serializer::error_container_inside_struct":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"serializer::error_scalar_outside_struct":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::marker::Sized","std::num::ParseFloatError","std::num::ParseIntError","std::option::Option","std::str::ParseBoolError","std::str::Utf8Error","std::string::String"],"serializer::serialize":["csv_core::Writer","serde::Serialize","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"serializer::serialize_header":["csv_core::Writer","serde::Serialize","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"string_record::StringRecord":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::as_byte_record":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::as_slice":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::clear":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::deserialize":["byte_record::ByteRecord","serde::Deserialize","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result","string_record::StringRecord"],"string_record::StringRecord::from_byte_record":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"string_record::StringRecord::from_byte_record_lossy":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::get":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","string_record::StringRecord"],"string_record::StringRecord::into_byte_record":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::is_empty":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::iter":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord","string_record::StringRecordIter"],"string_record::StringRecord::len":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::new":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::position":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","string_record::StringRecord"],"string_record::StringRecord::push_field":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::range":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","string_record::StringRecord"],"string_record::StringRecord::read":["Trim","byte_record::ByteRecord","byte_record::Position","reader::Reader","reader::ReaderState","std::alloc::Allocator","std::boxed::Box","std::io::BufReader","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result","string_record::StringRecord"],"string_record::StringRecord::set_position":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","string_record::StringRecord"],"string_record::StringRecord::trim":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::truncate":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecord::with_capacity":["byte_record::ByteRecord","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecord"],"string_record::StringRecordIter":["byte_record::ByteRecord","byte_record::ByteRecordIter","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","string_record::StringRecordIter"],"writer::Buffer":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","writer::Buffer"],"writer::Buffer::clear":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","writer::Buffer"],"writer::Buffer::readable":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","writer::Buffer"],"writer::Buffer::writable":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","writer::Buffer"],"writer::Buffer::written":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","writer::Buffer"],"writer::HeaderState":["writer::HeaderState"],"writer::Writer":["csv_core::Writer","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::check_field_count":["csv_core::Writer","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::flush":["csv_core::Writer","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::flush_buf":["csv_core::Writer","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::from_writer":["csv_core::Writer","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::into_inner":["csv_core::Writer","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::new":["csv_core::Writer","csv_core::WriterBuilder","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterBuilder","writer::WriterState"],"writer::Writer::<W>::serialize":["csv_core::Writer","serde::Serialize","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::write_byte_record":["byte_record::ByteRecord","csv_core::Writer","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::write_delimiter":["csv_core::Writer","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::write_field":["csv_core::Writer","std::alloc::Allocator","std::convert::AsRef","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::write_field_impl":["csv_core::Writer","std::alloc::Allocator","std::convert::AsRef","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::write_record":["csv_core::Writer","std::alloc::Allocator","std::convert::AsRef","std::io::Write","std::iter::IntoIterator","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::write_terminator":["csv_core::Writer","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<W>::write_terminator_into_buffer":["csv_core::Writer","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterState"],"writer::Writer::<std::fs::File>::from_path":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"writer::WriterBuilder":["csv_core::WriterBuilder","writer::WriterBuilder"],"writer::WriterBuilder::buffer_capacity":["csv_core::WriterBuilder","writer::WriterBuilder"],"writer::WriterBuilder::delimiter":["csv_core::WriterBuilder","writer::WriterBuilder"],"writer::WriterBuilder::double_quote":["csv_core::WriterBuilder","writer::WriterBuilder"],"writer::WriterBuilder::escape":["csv_core::WriterBuilder","writer::WriterBuilder"],"writer::WriterBuilder::flexible":["csv_core::WriterBuilder","writer::WriterBuilder"],"writer::WriterBuilder::from_path":["csv_core::WriterBuilder","std::convert::AsRef","std::marker::Sized","std::result::Result","writer::WriterBuilder"],"writer::WriterBuilder::from_writer":["csv_core::Writer","csv_core::WriterBuilder","std::alloc::Allocator","std::io::Write","std::marker::Sized","std::option::Option","std::vec::Vec","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterBuilder","writer::WriterState"],"writer::WriterBuilder::has_headers":["csv_core::WriterBuilder","writer::WriterBuilder"],"writer::WriterBuilder::new":["csv_core::WriterBuilder","writer::WriterBuilder"],"writer::WriterBuilder::quote":["csv_core::WriterBuilder","writer::WriterBuilder"],"writer::WriterBuilder::quote_style":["QuoteStyle","csv_core::WriterBuilder","writer::WriterBuilder"],"writer::WriterBuilder::terminator":["Terminator","csv_core::WriterBuilder","writer::WriterBuilder"],"writer::WriterState":["std::marker::Sized","std::option::Option","writer::HeaderState","writer::WriterState"]},"glob_path_import":{},"self_to_fn":{"QuoteStyle":["Clone","Copy","Debug","impl Default for QuoteStyle {\n    fn default() -> QuoteStyle {\n        QuoteStyle::Necessary\n    }\n}","impl QuoteStyle {\n    fn to_core(self) -> csv_core::QuoteStyle {\n        match self {\n            QuoteStyle::Always => csv_core::QuoteStyle::Always,\n            QuoteStyle::Necessary => csv_core::QuoteStyle::Necessary,\n            QuoteStyle::NonNumeric => csv_core::QuoteStyle::NonNumeric,\n            QuoteStyle::Never => csv_core::QuoteStyle::Never,\n            _ => unreachable!(),\n        }\n    }\n}"],"Terminator":["Clone","Copy","Debug","impl Default for Terminator {\n    fn default() -> Terminator {\n        Terminator::CRLF\n    }\n}","impl Terminator {\n    /// Convert this to the csv_core type of the same name.\n    fn to_core(self) -> csv_core::Terminator {\n        match self {\n            Terminator::CRLF => csv_core::Terminator::CRLF,\n            Terminator::Any(b) => csv_core::Terminator::Any(b),\n            _ => unreachable!(),\n        }\n    }\n}"],"Trim":["Clone","Copy","Debug","PartialEq","impl Default for Trim {\n    fn default() -> Trim {\n        Trim::None\n    }\n}","impl Trim {\n    fn should_trim_fields(&self) -> bool {\n        self == &Trim::Fields || self == &Trim::All\n    }\n\n    fn should_trim_headers(&self) -> bool {\n        self == &Trim::Headers || self == &Trim::All\n    }\n}"],"byte_record::Bounds":["Clone","Debug","Eq","PartialEq","impl Bounds {\n    /// Create a new set of bounds with the given capacity for storing the\n    /// ends of fields.\n    #[inline]\n    fn with_capacity(capacity: usize) -> Bounds {\n        Bounds { ends: vec![0; capacity], len: 0 }\n    }\n\n    /// Returns the bounds of field `i`.\n    #[inline]\n    fn get(&self, i: usize) -> Option<Range<usize>> {\n        if i >= self.len {\n            return None;\n        }\n        let end = match self.ends.get(i) {\n            None => return None,\n            Some(&end) => end,\n        };\n        let start = match i.checked_sub(1).and_then(|i| self.ends.get(i)) {\n            None => 0,\n            Some(&start) => start,\n        };\n        Some(ops::Range { start: start, end: end })\n    }\n\n    /// Returns a slice of ending positions of all fields.\n    #[inline]\n    fn ends(&self) -> &[usize] {\n        &self.ends[..self.len]\n    }\n\n    /// Return the last position of the last field.\n    ///\n    /// If there are no fields, this returns `0`.\n    #[inline]\n    fn end(&self) -> usize {\n        self.ends().last().map(|&i| i).unwrap_or(0)\n    }\n\n    /// Returns the number of fields in these bounds.\n    #[inline]\n    fn len(&self) -> usize {\n        self.len\n    }\n\n    /// Expand the capacity for storing field ending positions.\n    #[inline]\n    fn expand(&mut self) {\n        let new_len = self.ends.len().checked_mul(2).unwrap();\n        self.ends.resize(cmp::max(4, new_len), 0);\n    }\n\n    /// Add a new field with the given ending position.\n    #[inline]\n    fn add(&mut self, pos: usize) {\n        if self.len >= self.ends.len() {\n            self.expand();\n        }\n        self.ends[self.len] = pos;\n        self.len += 1;\n    }\n}","impl Default for Bounds {\n    #[inline]\n    fn default() -> Bounds {\n        Bounds::with_capacity(0)\n    }\n}"],"byte_record::ByteRecord":["Clone","Eq","impl ByteRecord {\n    /// Create a new empty `ByteRecord`.\n    ///\n    /// Note that you may find the `ByteRecord::from` constructor more\n    /// convenient, which is provided by an impl on the `From` trait.\n    ///\n    /// # Example: create an empty record\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// let record = ByteRecord::new();\n    /// assert_eq!(record.len(), 0);\n    /// ```\n    ///\n    /// # Example: initialize a record from a `Vec`\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// let record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// assert_eq!(record.len(), 3);\n    /// ```\n    #[inline]\n    pub fn new() -> ByteRecord {\n        ByteRecord::with_capacity(0, 0)\n    }\n\n    /// Create a new empty `ByteRecord` with the given capacity settings.\n    ///\n    /// `buffer` refers to the capacity of the buffer used to store the\n    /// actual row contents. `fields` refers to the number of fields one\n    /// might expect to store.\n    #[inline]\n    pub fn with_capacity(buffer: usize, fields: usize) -> ByteRecord {\n        ByteRecord(Box::new(ByteRecordInner {\n            pos: None,\n            fields: vec![0; buffer],\n            bounds: Bounds::with_capacity(fields),\n        }))\n    }\n\n    /// Deserialize this record.\n    ///\n    /// The `D` type parameter refers to the type that this record should be\n    /// deserialized into. The `'de` lifetime refers to the lifetime of the\n    /// `ByteRecord`. The `'de` lifetime permits deserializing into structs\n    /// that borrow field data from this record.\n    ///\n    /// An optional `headers` parameter permits deserializing into a struct\n    /// based on its field names (corresponding to header values) rather than\n    /// the order in which the fields are defined.\n    ///\n    /// # Example: without headers\n    ///\n    /// This shows how to deserialize a single row into a struct based on the\n    /// order in which fields occur. This example also shows how to borrow\n    /// fields from the `ByteRecord`, which results in zero allocation\n    /// deserialization.\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::ByteRecord;\n    /// use serde::Deserialize;\n    ///\n    /// #[derive(Deserialize)]\n    /// struct Row<'a> {\n    ///     city: &'a str,\n    ///     country: &'a str,\n    ///     population: u64,\n    /// }\n    ///\n    /// # fn main() { example().unwrap() }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let record = ByteRecord::from(vec![\n    ///         \"Boston\", \"United States\", \"4628910\",\n    ///     ]);\n    ///\n    ///     let row: Row = record.deserialize(None)?;\n    ///     assert_eq!(row.city, \"Boston\");\n    ///     assert_eq!(row.country, \"United States\");\n    ///     assert_eq!(row.population, 4628910);\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Example: with headers\n    ///\n    /// This example is like the previous one, but shows how to deserialize\n    /// into a struct based on the struct's field names. For this to work,\n    /// you must provide a header row.\n    ///\n    /// This example also shows that you can deserialize into owned data\n    /// types (e.g., `String`) instead of borrowed data types (e.g., `&str`).\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::ByteRecord;\n    /// use serde::Deserialize;\n    ///\n    /// #[derive(Deserialize)]\n    /// struct Row {\n    ///     city: String,\n    ///     country: String,\n    ///     population: u64,\n    /// }\n    ///\n    /// # fn main() { example().unwrap() }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     // Notice that the fields are not in the same order\n    ///     // as the fields in the struct!\n    ///     let header = ByteRecord::from(vec![\n    ///         \"country\", \"city\", \"population\",\n    ///     ]);\n    ///     let record = ByteRecord::from(vec![\n    ///         \"United States\", \"Boston\", \"4628910\",\n    ///     ]);\n    ///\n    ///     let row: Row = record.deserialize(Some(&header))?;\n    ///     assert_eq!(row.city, \"Boston\");\n    ///     assert_eq!(row.country, \"United States\");\n    ///     assert_eq!(row.population, 4628910);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn deserialize<'de, D: Deserialize<'de>>(\n        &'de self,\n        headers: Option<&'de ByteRecord>,\n    ) -> Result<D> {\n        deserialize_byte_record(self, headers)\n    }\n\n    /// Returns an iterator over all fields in this record.\n    ///\n    /// # Example\n    ///\n    /// This example shows how to iterate over each field in a `ByteRecord`.\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// let record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// for field in record.iter() {\n    ///     assert!(field == b\"a\" || field == b\"b\" || field == b\"c\");\n    /// }\n    /// ```\n    #[inline]\n    pub fn iter(&self) -> ByteRecordIter {\n        self.into_iter()\n    }\n\n    /// Return the field at index `i`.\n    ///\n    /// If no field at index `i` exists, then this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// let record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// assert_eq!(record.get(1), Some(&b\"b\"[..]));\n    /// assert_eq!(record.get(3), None);\n    /// ```\n    #[inline]\n    pub fn get(&self, i: usize) -> Option<&[u8]> {\n        self.0.bounds.get(i).map(|range| &self.0.fields[range])\n    }\n\n    /// Returns true if and only if this record is empty.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// assert!(ByteRecord::new().is_empty());\n    /// ```\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns the number of fields in this record.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// let record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// assert_eq!(record.len(), 3);\n    /// ```\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.0.bounds.len()\n    }\n\n    /// Truncate this record to `n` fields.\n    ///\n    /// If `n` is greater than the number of fields in this record, then this\n    /// has no effect.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// let mut record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// assert_eq!(record.len(), 3);\n    /// record.truncate(1);\n    /// assert_eq!(record.len(), 1);\n    /// assert_eq!(record, vec![\"a\"]);\n    /// ```\n    #[inline]\n    pub fn truncate(&mut self, n: usize) {\n        if n <= self.len() {\n            self.0.bounds.len = n;\n        }\n    }\n\n    /// Clear this record so that it has zero fields.\n    ///\n    /// This is equivalent to calling `truncate(0)`.\n    ///\n    /// Note that it is not necessary to clear the record to reuse it with\n    /// the CSV reader.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// let mut record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// assert_eq!(record.len(), 3);\n    /// record.clear();\n    /// assert_eq!(record.len(), 0);\n    /// ```\n    #[inline]\n    pub fn clear(&mut self) {\n        self.truncate(0);\n    }\n\n    /// Trim the fields of this record so that leading and trailing whitespace\n    /// is removed.\n    ///\n    /// This method uses the ASCII definition of whitespace. That is, only\n    /// bytes in the class `[\\t\\n\\v\\f\\r ]` are trimmed.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// let mut record = ByteRecord::from(vec![\n    ///     \"  \", \"\\tfoo\", \"bar  \", \"b a z\",\n    /// ]);\n    /// record.trim();\n    /// assert_eq!(record, vec![\"\", \"foo\", \"bar\", \"b a z\"]);\n    /// ```\n    pub fn trim(&mut self) {\n        let length = self.len();\n        if length == 0 {\n            return;\n        }\n        // TODO: We could likely do this in place, but for now, we allocate.\n        let mut trimmed =\n            ByteRecord::with_capacity(self.as_slice().len(), self.len());\n        trimmed.set_position(self.position().cloned());\n        for field in &*self {\n            trimmed.push_field(field.trim());\n        }\n        *self = trimmed;\n    }\n\n    /// Add a new field to this record.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// let mut record = ByteRecord::new();\n    /// record.push_field(b\"foo\");\n    /// assert_eq!(&record[0], b\"foo\");\n    /// ```\n    #[inline]\n    pub fn push_field(&mut self, field: &[u8]) {\n        let (s, e) = (self.0.bounds.end(), self.0.bounds.end() + field.len());\n        while e > self.0.fields.len() {\n            self.expand_fields();\n        }\n        self.0.fields[s..e].copy_from_slice(field);\n        self.0.bounds.add(e);\n    }\n\n    /// Return the position of this record, if available.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::{ByteRecord, ReaderBuilder};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut record = ByteRecord::new();\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .has_headers(false)\n    ///         .from_reader(\"a,b,c\\nx,y,z\".as_bytes());\n    ///\n    ///     assert!(rdr.read_byte_record(&mut record)?);\n    ///     {\n    ///         let pos = record.position().expect(\"a record position\");\n    ///         assert_eq!(pos.byte(), 0);\n    ///         assert_eq!(pos.line(), 1);\n    ///         assert_eq!(pos.record(), 0);\n    ///     }\n    ///\n    ///     assert!(rdr.read_byte_record(&mut record)?);\n    ///     {\n    ///         let pos = record.position().expect(\"a record position\");\n    ///         assert_eq!(pos.byte(), 6);\n    ///         assert_eq!(pos.line(), 2);\n    ///         assert_eq!(pos.record(), 1);\n    ///     }\n    ///\n    ///     // Finish the CSV reader for good measure.\n    ///     assert!(!rdr.read_byte_record(&mut record)?);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[inline]\n    pub fn position(&self) -> Option<&Position> {\n        self.0.pos.as_ref()\n    }\n\n    /// Set the position of this record.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::{ByteRecord, Position};\n    ///\n    /// let mut record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// let mut pos = Position::new();\n    /// pos.set_byte(100);\n    /// pos.set_line(4);\n    /// pos.set_record(2);\n    ///\n    /// record.set_position(Some(pos.clone()));\n    /// assert_eq!(record.position(), Some(&pos));\n    /// ```\n    #[inline]\n    pub fn set_position(&mut self, pos: Option<Position>) {\n        self.0.pos = pos;\n    }\n\n    /// Return the start and end position of a field in this record.\n    ///\n    /// If no such field exists at the given index, then return `None`.\n    ///\n    /// The range returned can be used with the slice returned by `as_slice`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// let record = ByteRecord::from(vec![\"foo\", \"quux\", \"z\"]);\n    /// let range = record.range(1).expect(\"a record range\");\n    /// assert_eq!(&record.as_slice()[range], &b\"quux\"[..]);\n    /// ```\n    #[inline]\n    pub fn range(&self, i: usize) -> Option<Range<usize>> {\n        self.0.bounds.get(i)\n    }\n\n    /// Return the entire row as a single byte slice. The slice returned stores\n    /// all fields contiguously. The boundaries of each field can be determined\n    /// via the `range` method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::ByteRecord;\n    ///\n    /// let record = ByteRecord::from(vec![\"foo\", \"quux\", \"z\"]);\n    /// assert_eq!(record.as_slice(), &b\"fooquuxz\"[..]);\n    /// ```\n    #[inline]\n    pub fn as_slice(&self) -> &[u8] {\n        &self.0.fields[..self.0.bounds.end()]\n    }\n\n    /// Retrieve the underlying parts of a byte record.\n    #[inline]\n    pub(crate) fn as_parts(&mut self) -> (&mut Vec<u8>, &mut Vec<usize>) {\n        let inner = &mut *self.0;\n        (&mut inner.fields, &mut inner.bounds.ends)\n    }\n\n    /// Set the number of fields in the given record record.\n    #[inline]\n    pub(crate) fn set_len(&mut self, len: usize) {\n        self.0.bounds.len = len;\n    }\n\n    /// Expand the capacity for storing fields.\n    #[inline]\n    pub(crate) fn expand_fields(&mut self) {\n        let new_len = self.0.fields.len().checked_mul(2).unwrap();\n        self.0.fields.resize(cmp::max(4, new_len), 0);\n    }\n\n    /// Expand the capacity for storing field ending positions.\n    #[inline]\n    pub(crate) fn expand_ends(&mut self) {\n        self.0.bounds.expand();\n    }\n\n    /// Validate the given record as UTF-8.\n    ///\n    /// If it's not UTF-8, return an error.\n    #[inline]\n    pub(crate) fn validate(&self) -> result::Result<(), Utf8Error> {\n        // If the entire buffer is ASCII, then we have nothing to fear.\n        if self.0.fields[..self.0.bounds.end()].is_ascii() {\n            return Ok(());\n        }\n        // Otherwise, we must check each field individually to ensure that\n        // it's valid UTF-8.\n        for (i, field) in self.iter().enumerate() {\n            if let Err(err) = field.to_str() {\n                return Err(new_utf8_error(i, err.valid_up_to()));\n            }\n        }\n        Ok(())\n    }\n\n    /// Compare the given byte record with the iterator of fields for equality.\n    pub(crate) fn iter_eq<I, T>(&self, other: I) -> bool\n    where\n        I: IntoIterator<Item = T>,\n        T: AsRef<[u8]>,\n    {\n        let mut it_record = self.iter();\n        let mut it_other = other.into_iter();\n        loop {\n            match (it_record.next(), it_other.next()) {\n                (None, None) => return true,\n                (None, Some(_)) | (Some(_), None) => return false,\n                (Some(x), Some(y)) => {\n                    if x != y.as_ref() {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n}","impl Default for ByteRecord {\n    #[inline]\n    fn default() -> ByteRecord {\n        ByteRecord::new()\n    }\n}","impl From<StringRecord> for ByteRecord {\n    #[inline]\n    fn from(record: StringRecord) -> ByteRecord {\n        record.into_byte_record()\n    }\n}","impl PartialEq for ByteRecord {\n    fn eq(&self, other: &ByteRecord) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n        self.iter().zip(other.iter()).all(|e| e.0 == e.1)\n    }\n}","impl fmt::Debug for ByteRecord {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let mut fields = vec![];\n        for field in self {\n            fields.push(BString::from(field.to_vec()));\n        }\n        write!(f, \"ByteRecord({:?})\", fields)\n    }\n}","impl ops::Index<usize> for ByteRecord {\n    type Output = [u8];\n    #[inline]\n    fn index(&self, i: usize) -> &[u8] {\n        self.get(i).unwrap()\n    }\n}","impl<'a, T: AsRef<[u8]>> From<&'a [T]> for ByteRecord {\n    #[inline]\n    fn from(xs: &'a [T]) -> ByteRecord {\n        ByteRecord::from_iter(xs)\n    }\n}","impl<T: AsRef<[u8]>> Extend<T> for ByteRecord {\n    #[inline]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        for x in iter {\n            self.push_field(x.as_ref());\n        }\n    }\n}","impl<T: AsRef<[u8]>> From<Vec<T>> for ByteRecord {\n    #[inline]\n    fn from(xs: Vec<T>) -> ByteRecord {\n        ByteRecord::from_iter(&xs)\n    }\n}","impl<T: AsRef<[u8]>> FromIterator<T> for ByteRecord {\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> ByteRecord {\n        let mut record = ByteRecord::new();\n        record.extend(iter);\n        record\n    }\n}","impl<T: AsRef<[u8]>> PartialEq<Vec<T>> for ByteRecord {\n    fn eq(&self, other: &Vec<T>) -> bool {\n        self.iter_eq(other)\n    }\n}","impl<T: AsRef<[u8]>> PartialEq<[T]> for ByteRecord {\n    fn eq(&self, other: &[T]) -> bool {\n        self.iter_eq(other)\n    }\n}"],"byte_record::ByteRecordInner":["Clone","Debug","Eq","PartialEq"],"byte_record::ByteRecordIter":["impl<'r> DoubleEndedIterator for ByteRecordIter<'r> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'r [u8]> {\n        if self.i_forward == self.i_reverse {\n            None\n        } else {\n            self.i_reverse -= 1;\n            let start = self\n                .i_reverse\n                .checked_sub(1)\n                .map(|i| self.r.0.bounds.ends()[i])\n                .unwrap_or(0);\n            let end = self.last_start;\n            self.last_start = start;\n            Some(&self.r.0.fields[start..end])\n        }\n    }\n}","impl<'r> ExactSizeIterator for ByteRecordIter<'r> {}","impl<'r> Iterator for ByteRecordIter<'r> {\n    type Item = &'r [u8];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'r [u8]> {\n        if self.i_forward == self.i_reverse {\n            None\n        } else {\n            let start = self.last_end;\n            let end = self.r.0.bounds.ends()[self.i_forward];\n            self.i_forward += 1;\n            self.last_end = end;\n            Some(&self.r.0.fields[start..end])\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let x = self.i_reverse - self.i_forward;\n        (x, Some(x))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n}"],"byte_record::Position":["Clone","Debug","Eq","PartialEq","impl Position {\n    /// Returns a new position initialized to the start value.\n    #[inline]\n    pub fn new() -> Position {\n        Position { byte: 0, line: 1, record: 0 }\n    }\n\n    /// The byte offset, starting at `0`, of this position.\n    #[inline]\n    pub fn byte(&self) -> u64 {\n        self.byte\n    }\n    /// The line number, starting at `1`, of this position.\n    #[inline]\n    pub fn line(&self) -> u64 {\n        self.line\n    }\n    /// The record index, starting with the first record at `0`.\n    #[inline]\n    pub fn record(&self) -> u64 {\n        self.record\n    }\n\n    /// Set the byte offset of this position.\n    #[inline]\n    pub fn set_byte(&mut self, byte: u64) -> &mut Position {\n        self.byte = byte;\n        self\n    }\n\n    /// Set the line number of this position.\n    ///\n    /// If the line number is less than `1`, then this method panics.\n    #[inline]\n    pub fn set_line(&mut self, line: u64) -> &mut Position {\n        assert!(line > 0);\n        self.line = line;\n        self\n    }\n\n    /// Set the record index of this position.\n    #[inline]\n    pub fn set_record(&mut self, record: u64) -> &mut Position {\n        self.record = record;\n        self\n    }\n}"],"deserializer::DeByteRecord":["impl<'r> DeRecord<'r> for DeByteRecord<'r> {\n    #[inline]\n    fn has_headers(&self) -> bool {\n        self.headers.is_some()\n    }\n\n    #[inline]\n    fn next_header(&mut self) -> Result<Option<&'r str>, DeserializeError> {\n        match self.next_header_bytes() {\n            Ok(Some(field)) => Ok(Some(\n                str::from_utf8(field)\n                    .map_err(|err| self.error(DEK::InvalidUtf8(err)))?,\n            )),\n            Ok(None) => Ok(None),\n            Err(err) => Err(err),\n        }\n    }\n\n    #[inline]\n    fn next_header_bytes(\n        &mut self,\n    ) -> Result<Option<&'r [u8]>, DeserializeError> {\n        Ok(self.headers.as_mut().and_then(|it| it.next()))\n    }\n\n    #[inline]\n    fn next_field(&mut self) -> Result<&'r str, DeserializeError> {\n        self.next_field_bytes().and_then(|field| {\n            str::from_utf8(field)\n                .map_err(|err| self.error(DEK::InvalidUtf8(err)))\n        })\n    }\n\n    #[inline]\n    fn next_field_bytes(&mut self) -> Result<&'r [u8], DeserializeError> {\n        match self.it.next() {\n            Some(field) => {\n                self.field += 1;\n                Ok(field)\n            }\n            None => Err(DeserializeError {\n                field: None,\n                kind: DEK::UnexpectedEndOfRow,\n            }),\n        }\n    }\n\n    #[inline]\n    fn peek_field(&mut self) -> Option<&'r [u8]> {\n        self.it.peek().map(|s| *s)\n    }\n\n    fn error(&self, kind: DeserializeErrorKind) -> DeserializeError {\n        DeserializeError {\n            field: Some(self.field.saturating_sub(1)),\n            kind: kind,\n        }\n    }\n\n    fn infer_deserialize<'de, V: Visitor<'de>>(\n        &mut self,\n        visitor: V,\n    ) -> Result<V::Value, DeserializeError> {\n        let x = self.next_field_bytes()?;\n        if x == b\"true\" {\n            return visitor.visit_bool(true);\n        } else if x == b\"false\" {\n            return visitor.visit_bool(false);\n        } else if let Some(n) = try_positive_integer64_bytes(x) {\n            return visitor.visit_u64(n);\n        } else if let Some(n) = try_negative_integer64_bytes(x) {\n            return visitor.visit_i64(n);\n        }\n        serde_if_integer128! {\n            if let Some(n) = try_positive_integer128_bytes(x) {\n                return visitor.visit_u128(n);\n            } else if let Some(n) = try_negative_integer128_bytes(x) {\n                return visitor.visit_i128(n);\n            }\n        }\n        if let Some(n) = try_float_bytes(x) {\n            visitor.visit_f64(n)\n        } else if let Ok(s) = str::from_utf8(x) {\n            visitor.visit_str(s)\n        } else {\n            visitor.visit_bytes(x)\n        }\n    }\n}"],"deserializer::DeRecordWrap":["impl<'r, T: DeRecord<'r>> DeRecord<'r> for DeRecordWrap<T> {\n    #[inline]\n    fn has_headers(&self) -> bool {\n        self.0.has_headers()\n    }\n\n    #[inline]\n    fn next_header(&mut self) -> Result<Option<&'r str>, DeserializeError> {\n        self.0.next_header()\n    }\n\n    #[inline]\n    fn next_header_bytes(\n        &mut self,\n    ) -> Result<Option<&'r [u8]>, DeserializeError> {\n        self.0.next_header_bytes()\n    }\n\n    #[inline]\n    fn next_field(&mut self) -> Result<&'r str, DeserializeError> {\n        self.0.next_field()\n    }\n\n    #[inline]\n    fn next_field_bytes(&mut self) -> Result<&'r [u8], DeserializeError> {\n        self.0.next_field_bytes()\n    }\n\n    #[inline]\n    fn peek_field(&mut self) -> Option<&'r [u8]> {\n        self.0.peek_field()\n    }\n\n    #[inline]\n    fn error(&self, kind: DeserializeErrorKind) -> DeserializeError {\n        self.0.error(kind)\n    }\n\n    #[inline]\n    fn infer_deserialize<'de, V: Visitor<'de>>(\n        &mut self,\n        visitor: V,\n    ) -> Result<V::Value, DeserializeError> {\n        self.0.infer_deserialize(visitor)\n    }\n}"],"deserializer::DeStringRecord":["impl<'r> DeRecord<'r> for DeStringRecord<'r> {\n    #[inline]\n    fn has_headers(&self) -> bool {\n        self.headers.is_some()\n    }\n\n    #[inline]\n    fn next_header(&mut self) -> Result<Option<&'r str>, DeserializeError> {\n        Ok(self.headers.as_mut().and_then(|it| it.next()))\n    }\n\n    #[inline]\n    fn next_header_bytes(\n        &mut self,\n    ) -> Result<Option<&'r [u8]>, DeserializeError> {\n        Ok(self.next_header()?.map(|s| s.as_bytes()))\n    }\n\n    #[inline]\n    fn next_field(&mut self) -> Result<&'r str, DeserializeError> {\n        match self.it.next() {\n            Some(field) => {\n                self.field += 1;\n                Ok(field)\n            }\n            None => Err(DeserializeError {\n                field: None,\n                kind: DEK::UnexpectedEndOfRow,\n            }),\n        }\n    }\n\n    #[inline]\n    fn next_field_bytes(&mut self) -> Result<&'r [u8], DeserializeError> {\n        self.next_field().map(|s| s.as_bytes())\n    }\n\n    #[inline]\n    fn peek_field(&mut self) -> Option<&'r [u8]> {\n        self.it.peek().map(|s| s.as_bytes())\n    }\n\n    fn error(&self, kind: DeserializeErrorKind) -> DeserializeError {\n        DeserializeError {\n            field: Some(self.field.saturating_sub(1)),\n            kind: kind,\n        }\n    }\n\n    fn infer_deserialize<'de, V: Visitor<'de>>(\n        &mut self,\n        visitor: V,\n    ) -> Result<V::Value, DeserializeError> {\n        let x = self.next_field()?;\n        if x == \"true\" {\n            return visitor.visit_bool(true);\n        } else if x == \"false\" {\n            return visitor.visit_bool(false);\n        } else if let Some(n) = try_positive_integer64(x) {\n            return visitor.visit_u64(n);\n        } else if let Some(n) = try_negative_integer64(x) {\n            return visitor.visit_i64(n);\n        }\n        serde_if_integer128! {\n            if let Some(n) = try_positive_integer128(x) {\n                return visitor.visit_u128(n);\n            } else if let Some(n) = try_negative_integer128(x) {\n                return visitor.visit_i128(n);\n            }\n        }\n        if let Some(n) = try_float(x) {\n            visitor.visit_f64(n)\n        } else {\n            visitor.visit_str(x)\n        }\n    }\n}"],"deserializer::DeserializeError":["Clone","Debug","Eq","PartialEq","impl DeserializeError {\n    /// Return the field index (starting at 0) of this error, if available.\n    pub fn field(&self) -> Option<u64> {\n        self.field\n    }\n\n    /// Return the underlying error kind.\n    pub fn kind(&self) -> &DeserializeErrorKind {\n        &self.kind\n    }\n}","impl SerdeError for DeserializeError {\n    fn custom<T: fmt::Display>(msg: T) -> DeserializeError {\n        DeserializeError { field: None, kind: DEK::Message(msg.to_string()) }\n    }\n}","impl StdError for DeserializeError {\n    fn description(&self) -> &str {\n        self.kind.description()\n    }\n}","impl fmt::Display for DeserializeError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if let Some(field) = self.field {\n            write!(f, \"field {}: {}\", field, self.kind)\n        } else {\n            write!(f, \"{}\", self.kind)\n        }\n    }\n}"],"deserializer::DeserializeErrorKind":["Clone","Debug","Eq","PartialEq","impl DeserializeErrorKind {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        use self::DeserializeErrorKind::*;\n\n        match *self {\n            Message(_) => \"deserialization error\",\n            Unsupported(_) => \"unsupported deserializer method\",\n            UnexpectedEndOfRow => \"expected field, but got end of row\",\n            InvalidUtf8(ref err) => err.description(),\n            ParseBool(ref err) => err.description(),\n            ParseInt(ref err) => err.description(),\n            ParseFloat(ref err) => err.description(),\n        }\n    }\n}","impl fmt::Display for DeserializeErrorKind {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::DeserializeErrorKind::*;\n\n        match *self {\n            Message(ref msg) => write!(f, \"{}\", msg),\n            Unsupported(ref which) => {\n                write!(f, \"unsupported deserializer method: {}\", which)\n            }\n            UnexpectedEndOfRow => write!(f, \"{}\", self.description()),\n            InvalidUtf8(ref err) => err.fmt(f),\n            ParseBool(ref err) => err.fmt(f),\n            ParseInt(ref err) => err.fmt(f),\n            ParseFloat(ref err) => err.fmt(f),\n        }\n    }\n}"],"error::Error":["Debug","impl Error {\n    /// A crate private constructor for `Error`.\n    pub(crate) fn new(kind: ErrorKind) -> Error {\n        Error(Box::new(kind))\n    }\n\n    /// Return the specific type of this error.\n    pub fn kind(&self) -> &ErrorKind {\n        &self.0\n    }\n\n    /// Unwrap this error into its underlying type.\n    pub fn into_kind(self) -> ErrorKind {\n        *self.0\n    }\n\n    /// Returns true if this is an I/O error.\n    ///\n    /// If this is true, the underlying `ErrorKind` is guaranteed to be\n    /// `ErrorKind::Io`.\n    pub fn is_io_error(&self) -> bool {\n        match *self.0 {\n            ErrorKind::Io(_) => true,\n            _ => false,\n        }\n    }\n\n    /// Return the position for this error, if one exists.\n    ///\n    /// This is a convenience function that permits callers to easily access\n    /// the position on an error without doing case analysis on `ErrorKind`.\n    pub fn position(&self) -> Option<&Position> {\n        self.0.position()\n    }\n}","impl From<io::Error> for Error {\n    fn from(err: io::Error) -> Error {\n        Error::new(ErrorKind::Io(err))\n    }\n}","impl SerdeError for Error {\n    fn custom<T: fmt::Display>(msg: T) -> Error {\n        Error::new(ErrorKind::Serialize(msg.to_string()))\n    }\n}","impl StdError for Error {\n    fn source(&self) -> Option<&(dyn StdError + 'static)> {\n        match *self.0 {\n            ErrorKind::Io(ref err) => Some(err),\n            ErrorKind::Utf8 { ref err, .. } => Some(err),\n            ErrorKind::UnequalLengths { .. } => None,\n            ErrorKind::Seek => None,\n            ErrorKind::Serialize(_) => None,\n            ErrorKind::Deserialize { ref err, .. } => Some(err),\n            _ => unreachable!(),\n        }\n    }\n}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self.0 {\n            ErrorKind::Io(ref err) => err.fmt(f),\n            ErrorKind::Utf8 { pos: None, ref err } => {\n                write!(f, \"CSV parse error: field {}: {}\", err.field(), err)\n            }\n            ErrorKind::Utf8 { pos: Some(ref pos), ref err } => write!(\n                f,\n                \"CSV parse error: record {} \\\n                 (line {}, field: {}, byte: {}): {}\",\n                pos.record(),\n                pos.line(),\n                err.field(),\n                pos.byte(),\n                err\n            ),\n            ErrorKind::UnequalLengths { pos: None, expected_len, len } => {\n                write!(\n                    f,\n                    \"CSV error: \\\n                     found record with {} fields, but the previous record \\\n                     has {} fields\",\n                    len, expected_len\n                )\n            }\n            ErrorKind::UnequalLengths {\n                pos: Some(ref pos),\n                expected_len,\n                len,\n            } => write!(\n                f,\n                \"CSV error: record {} (line: {}, byte: {}): \\\n                 found record with {} fields, but the previous record \\\n                 has {} fields\",\n                pos.record(),\n                pos.line(),\n                pos.byte(),\n                len,\n                expected_len\n            ),\n            ErrorKind::Seek => write!(\n                f,\n                \"CSV error: cannot access headers of CSV data \\\n                 when the parser was seeked before the first record \\\n                 could be read\"\n            ),\n            ErrorKind::Serialize(ref err) => {\n                write!(f, \"CSV write error: {}\", err)\n            }\n            ErrorKind::Deserialize { pos: None, ref err } => {\n                write!(f, \"CSV deserialize error: {}\", err)\n            }\n            ErrorKind::Deserialize { pos: Some(ref pos), ref err } => write!(\n                f,\n                \"CSV deserialize error: record {} \\\n                 (line: {}, byte: {}): {}\",\n                pos.record(),\n                pos.line(),\n                pos.byte(),\n                err\n            ),\n            _ => unreachable!(),\n        }\n    }\n}"],"error::ErrorKind":["Debug","impl ErrorKind {\n    /// Return the position for this error, if one exists.\n    ///\n    /// This is a convenience function that permits callers to easily access\n    /// the position on an error without doing case analysis on `ErrorKind`.\n    pub fn position(&self) -> Option<&Position> {\n        match *self {\n            ErrorKind::Utf8 { ref pos, .. } => pos.as_ref(),\n            ErrorKind::UnequalLengths { ref pos, .. } => pos.as_ref(),\n            ErrorKind::Deserialize { ref pos, .. } => pos.as_ref(),\n            _ => None,\n        }\n    }\n}"],"error::FromUtf8Error":["Clone","Debug","Eq","PartialEq","impl FromUtf8Error {\n    /// Create a new FromUtf8Error.\n    pub(crate) fn new(rec: ByteRecord, err: Utf8Error) -> FromUtf8Error {\n        FromUtf8Error { record: rec, err: err }\n    }\n\n    /// Access the underlying `ByteRecord` that failed UTF-8 validation.\n    pub fn into_byte_record(self) -> ByteRecord {\n        self.record\n    }\n\n    /// Access the underlying UTF-8 validation error.\n    pub fn utf8_error(&self) -> &Utf8Error {\n        &self.err\n    }\n}","impl StdError for FromUtf8Error {\n    fn source(&self) -> Option<&(dyn StdError + 'static)> {\n        Some(&self.err)\n    }\n}","impl fmt::Display for FromUtf8Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.err.fmt(f)\n    }\n}"],"error::IntoInnerError":["impl<W: std::any::Any> StdError for IntoInnerError<W> {\n    fn source(&self) -> Option<&(dyn StdError + 'static)> {\n        self.err.source()\n    }\n}","impl<W> IntoInnerError<W> {\n    /// Creates a new `IntoInnerError`.\n    ///\n    /// (This is a visibility hack. It's public in this module, but not in the\n    /// crate.)\n    pub(crate) fn new(wtr: W, err: io::Error) -> IntoInnerError<W> {\n        IntoInnerError { wtr: wtr, err: err }\n    }\n\n    /// Returns the error which caused the call to `into_inner` to fail.\n    ///\n    /// This error was returned when attempting to flush the internal buffer.\n    pub fn error(&self) -> &io::Error {\n        &self.err\n    }\n\n    /// Returns the underlying writer which generated the error.\n    ///\n    /// The returned value can be used for error recovery, such as\n    /// re-inspecting the buffer.\n    pub fn into_inner(self) -> W {\n        self.wtr\n    }\n}","impl<W> fmt::Debug for IntoInnerError<W> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.err.fmt(f)\n    }\n}","impl<W> fmt::Display for IntoInnerError<W> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.err.fmt(f)\n    }\n}"],"error::Utf8Error":["Clone","Debug","Eq","PartialEq","impl StdError for Utf8Error {}","impl Utf8Error {\n    /// The field index of a byte record in which UTF-8 validation failed.\n    pub fn field(&self) -> usize {\n        self.field\n    }\n    /// The index into the given field up to which valid UTF-8 was verified.\n    pub fn valid_up_to(&self) -> usize {\n        self.valid_up_to\n    }\n}","impl fmt::Display for Utf8Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"invalid utf-8: invalid UTF-8 in field {} near byte index {}\",\n            self.field, self.valid_up_to\n        )\n    }\n}"],"reader::ByteRecordsIntoIter":["impl<R: io::Read> ByteRecordsIntoIter<R> {\n    fn new(rdr: Reader<R>) -> ByteRecordsIntoIter<R> {\n        ByteRecordsIntoIter { rdr: rdr, rec: ByteRecord::new() }\n    }\n\n    /// Return a reference to the underlying CSV reader.\n    pub fn reader(&self) -> &Reader<R> {\n        &self.rdr\n    }\n\n    /// Return a mutable reference to the underlying CSV reader.\n    pub fn reader_mut(&mut self) -> &mut Reader<R> {\n        &mut self.rdr\n    }\n\n    /// Drop this iterator and return the underlying CSV reader.\n    pub fn into_reader(self) -> Reader<R> {\n        self.rdr\n    }\n}","impl<R: io::Read> Iterator for ByteRecordsIntoIter<R> {\n    type Item = Result<ByteRecord>;\n\n    fn next(&mut self) -> Option<Result<ByteRecord>> {\n        match self.rdr.read_byte_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(true) => Some(Ok(self.rec.clone())),\n            Ok(false) => None,\n        }\n    }\n}"],"reader::ByteRecordsIter":["impl<'r, R: io::Read> ByteRecordsIter<'r, R> {\n    fn new(rdr: &'r mut Reader<R>) -> ByteRecordsIter<'r, R> {\n        ByteRecordsIter { rdr: rdr, rec: ByteRecord::new() }\n    }\n\n    /// Return a reference to the underlying CSV reader.\n    pub fn reader(&self) -> &Reader<R> {\n        &self.rdr\n    }\n\n    /// Return a mutable reference to the underlying CSV reader.\n    pub fn reader_mut(&mut self) -> &mut Reader<R> {\n        &mut self.rdr\n    }\n}","impl<'r, R: io::Read> Iterator for ByteRecordsIter<'r, R> {\n    type Item = Result<ByteRecord>;\n\n    fn next(&mut self) -> Option<Result<ByteRecord>> {\n        match self.rdr.read_byte_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(true) => Some(Ok(self.rec.clone())),\n            Ok(false) => None,\n        }\n    }\n}"],"reader::DeserializeRecordsIntoIter":["impl<R: io::Read, D: DeserializeOwned> DeserializeRecordsIntoIter<R, D> {\n    fn new(mut rdr: Reader<R>) -> DeserializeRecordsIntoIter<R, D> {\n        let headers = if !rdr.state.has_headers {\n            None\n        } else {\n            rdr.headers().ok().map(Clone::clone)\n        };\n        DeserializeRecordsIntoIter {\n            rdr: rdr,\n            rec: StringRecord::new(),\n            headers: headers,\n            _priv: PhantomData,\n        }\n    }\n\n    /// Return a reference to the underlying CSV reader.\n    pub fn reader(&self) -> &Reader<R> {\n        &self.rdr\n    }\n\n    /// Return a mutable reference to the underlying CSV reader.\n    pub fn reader_mut(&mut self) -> &mut Reader<R> {\n        &mut self.rdr\n    }\n\n    /// Drop this iterator and return the underlying CSV reader.\n    pub fn into_reader(self) -> Reader<R> {\n        self.rdr\n    }\n}","impl<R: io::Read, D: DeserializeOwned> Iterator\n    for DeserializeRecordsIntoIter<R, D>\n{\n    type Item = Result<D>;\n\n    fn next(&mut self) -> Option<Result<D>> {\n        match self.rdr.read_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(false) => None,\n            Ok(true) => Some(self.rec.deserialize(self.headers.as_ref())),\n        }\n    }\n}"],"reader::DeserializeRecordsIter":["impl<'r, R: io::Read, D: DeserializeOwned> DeserializeRecordsIter<'r, R, D> {\n    fn new(rdr: &'r mut Reader<R>) -> DeserializeRecordsIter<'r, R, D> {\n        let headers = if !rdr.state.has_headers {\n            None\n        } else {\n            rdr.headers().ok().map(Clone::clone)\n        };\n        DeserializeRecordsIter {\n            rdr: rdr,\n            rec: StringRecord::new(),\n            headers: headers,\n            _priv: PhantomData,\n        }\n    }\n\n    /// Return a reference to the underlying CSV reader.\n    pub fn reader(&self) -> &Reader<R> {\n        &self.rdr\n    }\n\n    /// Return a mutable reference to the underlying CSV reader.\n    pub fn reader_mut(&mut self) -> &mut Reader<R> {\n        &mut self.rdr\n    }\n}","impl<'r, R: io::Read, D: DeserializeOwned> Iterator\n    for DeserializeRecordsIter<'r, R, D>\n{\n    type Item = Result<D>;\n\n    fn next(&mut self) -> Option<Result<D>> {\n        match self.rdr.read_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(false) => None,\n            Ok(true) => Some(self.rec.deserialize(self.headers.as_ref())),\n        }\n    }\n}"],"reader::Headers":["Debug"],"reader::Reader":["Debug","impl Reader<Reader<File>> {\n    /// Create a new CSV parser with a default configuration for the given\n    /// file path.\n    ///\n    /// To customize CSV parsing, use a `ReaderBuilder`.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use std::error::Error;\n    /// use csv::Reader;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut rdr = Reader::from_path(\"foo.csv\")?;\n    ///     for result in rdr.records() {\n    ///         let record = result?;\n    ///         println!(\"{:?}\", record);\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<Reader<File>> {\n        ReaderBuilder::new().from_path(path)\n    }\n}","impl<R: io::Read + io::Seek> Reader<R> {\n    /// Seeks the underlying reader to the position given.\n    ///\n    /// This comes with a few caveats:\n    ///\n    /// * Any internal buffer associated with this reader is cleared.\n    /// * If the given position does not correspond to a position immediately\n    ///   before the start of a record, then the behavior of this reader is\n    ///   unspecified.\n    /// * Any special logic that skips the first record in the CSV reader\n    ///   when reading or iterating over records is disabled.\n    ///\n    /// If the given position has a byte offset equivalent to the current\n    /// position, then no seeking is performed.\n    ///\n    /// If the header row has not already been read, then this will attempt\n    /// to read the header row before seeking. Therefore, it is possible that\n    /// this returns an error associated with reading CSV data.\n    ///\n    /// Note that seeking is performed based only on the byte offset in the\n    /// given position. Namely, the record or line numbers in the position may\n    /// be incorrect, but this will cause any future position generated by\n    /// this CSV reader to be similarly incorrect.\n    ///\n    /// # Example: seek to parse a record twice\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::io;\n    /// use csv::{Reader, Position};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,popcount\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \";\n    ///     let rdr = Reader::from_reader(io::Cursor::new(data));\n    ///     let mut iter = rdr.into_records();\n    ///     let mut pos = Position::new();\n    ///     loop {\n    ///         // Read the position immediately before each record.\n    ///         let next_pos = iter.reader().position().clone();\n    ///         if iter.next().is_none() {\n    ///             break;\n    ///         }\n    ///         pos = next_pos;\n    ///     }\n    ///\n    ///     // Now seek the reader back to `pos`. This will let us read the\n    ///     // last record again.\n    ///     iter.reader_mut().seek(pos)?;\n    ///     let mut iter = iter.into_reader().into_records();\n    ///     if let Some(result) = iter.next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Concord\", \"United States\", \"42695\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn seek(&mut self, pos: Position) -> Result<()> {\n        self.byte_headers()?;\n        self.state.seeked = true;\n        if pos.byte() == self.state.cur_pos.byte() {\n            return Ok(());\n        }\n        self.rdr.seek(io::SeekFrom::Start(pos.byte()))?;\n        self.core.reset();\n        self.core.set_line(pos.line());\n        self.state.cur_pos = pos;\n        self.state.eof = false;\n        Ok(())\n    }\n\n    /// This is like `seek`, but provides direct control over how the seeking\n    /// operation is performed via `io::SeekFrom`.\n    ///\n    /// The `pos` position given *should* correspond the position indicated\n    /// by `seek_from`, but there is no requirement. If the `pos` position\n    /// given is incorrect, then the position information returned by this\n    /// reader will be similarly incorrect.\n    ///\n    /// If the header row has not already been read, then this will attempt\n    /// to read the header row before seeking. Therefore, it is possible that\n    /// this returns an error associated with reading CSV data.\n    ///\n    /// Unlike `seek`, this will always cause an actual seek to be performed.\n    pub fn seek_raw(\n        &mut self,\n        seek_from: io::SeekFrom,\n        pos: Position,\n    ) -> Result<()> {\n        self.byte_headers()?;\n        self.state.seeked = true;\n        self.rdr.seek(seek_from)?;\n        self.core.reset();\n        self.core.set_line(pos.line());\n        self.state.cur_pos = pos;\n        self.state.eof = false;\n        Ok(())\n    }\n}","impl<R: io::Read> Reader<R> {\n    /// Create a new CSV reader given a builder and a source of underlying\n    /// bytes.\n    fn new(builder: &ReaderBuilder, rdr: R) -> Reader<R> {\n        Reader {\n            core: Box::new(builder.builder.build()),\n            rdr: io::BufReader::with_capacity(builder.capacity, rdr),\n            state: ReaderState {\n                headers: None,\n                has_headers: builder.has_headers,\n                flexible: builder.flexible,\n                trim: builder.trim,\n                first_field_count: None,\n                cur_pos: Position::new(),\n                first: false,\n                seeked: false,\n                eof: false,\n            },\n        }\n    }\n\n    /// Create a new CSV parser with a default configuration for the given\n    /// reader.\n    ///\n    /// To customize CSV parsing, use a `ReaderBuilder`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::Reader;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \";\n    ///     let mut rdr = Reader::from_reader(data.as_bytes());\n    ///     for result in rdr.records() {\n    ///         let record = result?;\n    ///         println!(\"{:?}\", record);\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn from_reader(rdr: R) -> Reader<R> {\n        ReaderBuilder::new().from_reader(rdr)\n    }\n\n    /// Returns a borrowed iterator over deserialized records.\n    ///\n    /// Each item yielded by this iterator is a `Result<D, Error>`.\n    /// Therefore, in order to access the record, callers must handle the\n    /// possibility of error (typically with `try!` or `?`).\n    ///\n    /// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n    /// default), then this does not include the first record. Additionally,\n    /// if `has_headers` is enabled, then deserializing into a struct will\n    /// automatically align the values in each row to the fields of a struct\n    /// based on the header row.\n    ///\n    /// # Example\n    ///\n    /// This shows how to deserialize CSV data into normal Rust structs. The\n    /// fields of the header row are used to match up the values in each row\n    /// to the fields of the struct.\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::Reader;\n    /// use serde::Deserialize;\n    ///\n    /// #[derive(Debug, Deserialize, Eq, PartialEq)]\n    /// struct Row {\n    ///     city: String,\n    ///     country: String,\n    ///     #[serde(rename = \"popcount\")]\n    ///     population: u64,\n    /// }\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,popcount\n    /// Boston,United States,4628910\n    /// \";\n    ///     let mut rdr = Reader::from_reader(data.as_bytes());\n    ///     let mut iter = rdr.deserialize();\n    ///\n    ///     if let Some(result) = iter.next() {\n    ///         let record: Row = result?;\n    ///         assert_eq!(record, Row {\n    ///             city: \"Boston\".to_string(),\n    ///             country: \"United States\".to_string(),\n    ///             population: 4628910,\n    ///         });\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// # Rules\n    ///\n    /// For the most part, any Rust type that maps straight-forwardly to a CSV\n    /// record is supported. This includes maps, structs, tuples and tuple\n    /// structs. Other Rust types, such as `Vec`s, arrays, and enums have\n    /// a more complicated story. In general, when working with CSV data, one\n    /// should avoid *nested sequences* as much as possible.\n    ///\n    /// Maps, structs, tuples and tuple structs map to CSV records in a simple\n    /// way. Tuples and tuple structs decode their fields in the order that\n    /// they are defined. Structs will do the same only if `has_headers` has\n    /// been disabled using [`ReaderBuilder`](struct.ReaderBuilder.html),\n    /// otherwise, structs and maps are deserialized based on the fields\n    /// defined in the header row. (If there is no header row, then\n    /// deserializing into a map will result in an error.)\n    ///\n    /// Nested sequences are supported in a limited capacity. Namely, they\n    /// are flattened. As a result, it's often useful to use a `Vec` to capture\n    /// a \"tail\" of fields in a record:\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::ReaderBuilder;\n    /// use serde::Deserialize;\n    ///\n    /// #[derive(Debug, Deserialize, Eq, PartialEq)]\n    /// struct Row {\n    ///     label: String,\n    ///     values: Vec<i32>,\n    /// }\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"foo,1,2,3\";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .has_headers(false)\n    ///         .from_reader(data.as_bytes());\n    ///     let mut iter = rdr.deserialize();\n    ///\n    ///     if let Some(result) = iter.next() {\n    ///         let record: Row = result?;\n    ///         assert_eq!(record, Row {\n    ///             label: \"foo\".to_string(),\n    ///             values: vec![1, 2, 3],\n    ///         });\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// In the above example, adding another field to the `Row` struct after\n    /// the `values` field will result in a deserialization error. This is\n    /// because the deserializer doesn't know when to stop reading fields\n    /// into the `values` vector, so it will consume the rest of the fields in\n    /// the record leaving none left over for the additional field.\n    ///\n    /// Finally, simple enums in Rust can be deserialized as well. Namely,\n    /// enums must either be variants with no arguments or variants with a\n    /// single argument. Variants with no arguments are deserialized based on\n    /// which variant name the field matches. Variants with a single argument\n    /// are deserialized based on which variant can store the data. The latter\n    /// is only supported when using \"untagged\" enum deserialization. The\n    /// following example shows both forms in action:\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::Reader;\n    /// use serde::Deserialize;\n    ///\n    /// #[derive(Debug, Deserialize, PartialEq)]\n    /// struct Row {\n    ///     label: Label,\n    ///     value: Number,\n    /// }\n    ///\n    /// #[derive(Debug, Deserialize, PartialEq)]\n    /// #[serde(rename_all = \"lowercase\")]\n    /// enum Label {\n    ///     Celsius,\n    ///     Fahrenheit,\n    /// }\n    ///\n    /// #[derive(Debug, Deserialize, PartialEq)]\n    /// #[serde(untagged)]\n    /// enum Number {\n    ///     Integer(i64),\n    ///     Float(f64),\n    /// }\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// label,value\n    /// celsius,22.2222\n    /// fahrenheit,72\n    /// \";\n    ///     let mut rdr = Reader::from_reader(data.as_bytes());\n    ///     let mut iter = rdr.deserialize();\n    ///\n    ///     // Read the first record.\n    ///     if let Some(result) = iter.next() {\n    ///         let record: Row = result?;\n    ///         assert_eq!(record, Row {\n    ///             label: Label::Celsius,\n    ///             value: Number::Float(22.2222),\n    ///         });\n    ///     } else {\n    ///         return Err(From::from(\n    ///             \"expected at least two records but got none\"));\n    ///     }\n    ///\n    ///     // Read the second record.\n    ///     if let Some(result) = iter.next() {\n    ///         let record: Row = result?;\n    ///         assert_eq!(record, Row {\n    ///             label: Label::Fahrenheit,\n    ///             value: Number::Integer(72),\n    ///         });\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\n    ///             \"expected at least two records but got only one\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn deserialize<D>(&mut self) -> DeserializeRecordsIter<R, D>\n    where\n        D: DeserializeOwned,\n    {\n        DeserializeRecordsIter::new(self)\n    }\n\n    /// Returns an owned iterator over deserialized records.\n    ///\n    /// Each item yielded by this iterator is a `Result<D, Error>`.\n    /// Therefore, in order to access the record, callers must handle the\n    /// possibility of error (typically with `try!` or `?`).\n    ///\n    /// This is mostly useful when you want to return a CSV iterator or store\n    /// it somewhere.\n    ///\n    /// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n    /// default), then this does not include the first record. Additionally,\n    /// if `has_headers` is enabled, then deserializing into a struct will\n    /// automatically align the values in each row to the fields of a struct\n    /// based on the header row.\n    ///\n    /// For more detailed deserialization rules, see the documentation on the\n    /// `deserialize` method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::Reader;\n    /// use serde::Deserialize;\n    ///\n    /// #[derive(Debug, Deserialize, Eq, PartialEq)]\n    /// struct Row {\n    ///     city: String,\n    ///     country: String,\n    ///     #[serde(rename = \"popcount\")]\n    ///     population: u64,\n    /// }\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,popcount\n    /// Boston,United States,4628910\n    /// \";\n    ///     let rdr = Reader::from_reader(data.as_bytes());\n    ///     let mut iter = rdr.into_deserialize();\n    ///\n    ///     if let Some(result) = iter.next() {\n    ///         let record: Row = result?;\n    ///         assert_eq!(record, Row {\n    ///             city: \"Boston\".to_string(),\n    ///             country: \"United States\".to_string(),\n    ///             population: 4628910,\n    ///         });\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn into_deserialize<D>(self) -> DeserializeRecordsIntoIter<R, D>\n    where\n        D: DeserializeOwned,\n    {\n        DeserializeRecordsIntoIter::new(self)\n    }\n\n    /// Returns a borrowed iterator over all records as strings.\n    ///\n    /// Each item yielded by this iterator is a `Result<StringRecord, Error>`.\n    /// Therefore, in order to access the record, callers must handle the\n    /// possibility of error (typically with `try!` or `?`).\n    ///\n    /// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n    /// default), then this does not include the first record.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::Reader;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// \";\n    ///     let mut rdr = Reader::from_reader(data.as_bytes());\n    ///     let mut iter = rdr.records();\n    ///\n    ///     if let Some(result) = iter.next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn records(&mut self) -> StringRecordsIter<R> {\n        StringRecordsIter::new(self)\n    }\n\n    /// Returns an owned iterator over all records as strings.\n    ///\n    /// Each item yielded by this iterator is a `Result<StringRecord, Error>`.\n    /// Therefore, in order to access the record, callers must handle the\n    /// possibility of error (typically with `try!` or `?`).\n    ///\n    /// This is mostly useful when you want to return a CSV iterator or store\n    /// it somewhere.\n    ///\n    /// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n    /// default), then this does not include the first record.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::Reader;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// \";\n    ///     let rdr = Reader::from_reader(data.as_bytes());\n    ///     let mut iter = rdr.into_records();\n    ///\n    ///     if let Some(result) = iter.next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn into_records(self) -> StringRecordsIntoIter<R> {\n        StringRecordsIntoIter::new(self)\n    }\n\n    /// Returns a borrowed iterator over all records as raw bytes.\n    ///\n    /// Each item yielded by this iterator is a `Result<ByteRecord, Error>`.\n    /// Therefore, in order to access the record, callers must handle the\n    /// possibility of error (typically with `try!` or `?`).\n    ///\n    /// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n    /// default), then this does not include the first record.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::Reader;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// \";\n    ///     let mut rdr = Reader::from_reader(data.as_bytes());\n    ///     let mut iter = rdr.byte_records();\n    ///\n    ///     if let Some(result) = iter.next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn byte_records(&mut self) -> ByteRecordsIter<R> {\n        ByteRecordsIter::new(self)\n    }\n\n    /// Returns an owned iterator over all records as raw bytes.\n    ///\n    /// Each item yielded by this iterator is a `Result<ByteRecord, Error>`.\n    /// Therefore, in order to access the record, callers must handle the\n    /// possibility of error (typically with `try!` or `?`).\n    ///\n    /// This is mostly useful when you want to return a CSV iterator or store\n    /// it somewhere.\n    ///\n    /// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n    /// default), then this does not include the first record.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::Reader;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// \";\n    ///     let rdr = Reader::from_reader(data.as_bytes());\n    ///     let mut iter = rdr.into_byte_records();\n    ///\n    ///     if let Some(result) = iter.next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn into_byte_records(self) -> ByteRecordsIntoIter<R> {\n        ByteRecordsIntoIter::new(self)\n    }\n\n    /// Returns a reference to the first row read by this parser.\n    ///\n    /// If no row has been read yet, then this will force parsing of the first\n    /// row.\n    ///\n    /// If there was a problem parsing the row or if it wasn't valid UTF-8,\n    /// then this returns an error.\n    ///\n    /// If the underlying reader emits EOF before any data, then this returns\n    /// an empty record.\n    ///\n    /// Note that this method may be used regardless of whether `has_headers`\n    /// was enabled (but it is enabled by default).\n    ///\n    /// # Example\n    ///\n    /// This example shows how to get the header row of CSV data. Notice that\n    /// the header row does not appear as a record in the iterator!\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::Reader;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// \";\n    ///     let mut rdr = Reader::from_reader(data.as_bytes());\n    ///\n    ///     // We can read the headers before iterating.\n    ///     {\n    ///         // `headers` borrows from the reader, so we put this in its\n    ///         // own scope. That way, the borrow ends before we try iterating\n    ///         // below. Alternatively, we could clone the headers.\n    ///         let headers = rdr.headers()?;\n    ///         assert_eq!(headers, vec![\"city\", \"country\", \"pop\"]);\n    ///     }\n    ///\n    ///     if let Some(result) = rdr.records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///     } else {\n    ///         return Err(From::from(\n    ///             \"expected at least one record but got none\"))\n    ///     }\n    ///\n    ///     // We can also read the headers after iterating.\n    ///     let headers = rdr.headers()?;\n    ///     assert_eq!(headers, vec![\"city\", \"country\", \"pop\"]);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn headers(&mut self) -> Result<&StringRecord> {\n        if self.state.headers.is_none() {\n            let mut record = ByteRecord::new();\n            self.read_byte_record_impl(&mut record)?;\n            self.set_headers_impl(Err(record));\n        }\n        let headers = self.state.headers.as_ref().unwrap();\n        match headers.string_record {\n            Ok(ref record) => Ok(record),\n            Err(ref err) => Err(Error::new(ErrorKind::Utf8 {\n                pos: headers.byte_record.position().map(Clone::clone),\n                err: err.clone(),\n            })),\n        }\n    }\n\n    /// Returns a reference to the first row read by this parser as raw bytes.\n    ///\n    /// If no row has been read yet, then this will force parsing of the first\n    /// row.\n    ///\n    /// If there was a problem parsing the row then this returns an error.\n    ///\n    /// If the underlying reader emits EOF before any data, then this returns\n    /// an empty record.\n    ///\n    /// Note that this method may be used regardless of whether `has_headers`\n    /// was enabled (but it is enabled by default).\n    ///\n    /// # Example\n    ///\n    /// This example shows how to get the header row of CSV data. Notice that\n    /// the header row does not appear as a record in the iterator!\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::Reader;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// \";\n    ///     let mut rdr = Reader::from_reader(data.as_bytes());\n    ///\n    ///     // We can read the headers before iterating.\n    ///     {\n    ///         // `headers` borrows from the reader, so we put this in its\n    ///         // own scope. That way, the borrow ends before we try iterating\n    ///         // below. Alternatively, we could clone the headers.\n    ///         let headers = rdr.byte_headers()?;\n    ///         assert_eq!(headers, vec![\"city\", \"country\", \"pop\"]);\n    ///     }\n    ///\n    ///     if let Some(result) = rdr.byte_records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///     } else {\n    ///         return Err(From::from(\n    ///             \"expected at least one record but got none\"))\n    ///     }\n    ///\n    ///     // We can also read the headers after iterating.\n    ///     let headers = rdr.byte_headers()?;\n    ///     assert_eq!(headers, vec![\"city\", \"country\", \"pop\"]);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn byte_headers(&mut self) -> Result<&ByteRecord> {\n        if self.state.headers.is_none() {\n            let mut record = ByteRecord::new();\n            self.read_byte_record_impl(&mut record)?;\n            self.set_headers_impl(Err(record));\n        }\n        Ok(&self.state.headers.as_ref().unwrap().byte_record)\n    }\n\n    /// Set the headers of this CSV parser manually.\n    ///\n    /// This overrides any other setting (including `set_byte_headers`). Any\n    /// automatic detection of headers is disabled. This may be called at any\n    /// time.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{Reader, StringRecord};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// \";\n    ///     let mut rdr = Reader::from_reader(data.as_bytes());\n    ///\n    ///     assert_eq!(rdr.headers()?, vec![\"city\", \"country\", \"pop\"]);\n    ///     rdr.set_headers(StringRecord::from(vec![\"a\", \"b\", \"c\"]));\n    ///     assert_eq!(rdr.headers()?, vec![\"a\", \"b\", \"c\"]);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn set_headers(&mut self, headers: StringRecord) {\n        self.set_headers_impl(Ok(headers));\n    }\n\n    /// Set the headers of this CSV parser manually as raw bytes.\n    ///\n    /// This overrides any other setting (including `set_headers`). Any\n    /// automatic detection of headers is disabled. This may be called at any\n    /// time.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{Reader, ByteRecord};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// \";\n    ///     let mut rdr = Reader::from_reader(data.as_bytes());\n    ///\n    ///     assert_eq!(rdr.byte_headers()?, vec![\"city\", \"country\", \"pop\"]);\n    ///     rdr.set_byte_headers(ByteRecord::from(vec![\"a\", \"b\", \"c\"]));\n    ///     assert_eq!(rdr.byte_headers()?, vec![\"a\", \"b\", \"c\"]);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn set_byte_headers(&mut self, headers: ByteRecord) {\n        self.set_headers_impl(Err(headers));\n    }\n\n    fn set_headers_impl(\n        &mut self,\n        headers: result::Result<StringRecord, ByteRecord>,\n    ) {\n        // If we have string headers, then get byte headers. But if we have\n        // byte headers, then get the string headers (or a UTF-8 error).\n        let (mut str_headers, mut byte_headers) = match headers {\n            Ok(string) => {\n                let bytes = string.clone().into_byte_record();\n                (Ok(string), bytes)\n            }\n            Err(bytes) => {\n                match StringRecord::from_byte_record(bytes.clone()) {\n                    Ok(str_headers) => (Ok(str_headers), bytes),\n                    Err(err) => (Err(err.utf8_error().clone()), bytes),\n                }\n            }\n        };\n        if self.state.trim.should_trim_headers() {\n            if let Ok(ref mut str_headers) = str_headers.as_mut() {\n                str_headers.trim();\n            }\n            byte_headers.trim();\n        }\n        self.state.headers = Some(Headers {\n            byte_record: byte_headers,\n            string_record: str_headers,\n        });\n    }\n\n    /// Read a single row into the given record. Returns false when no more\n    /// records could be read.\n    ///\n    /// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n    /// default), then this will never read the first record.\n    ///\n    /// This method is useful when you want to read records as fast as\n    /// as possible. It's less ergonomic than an iterator, but it permits the\n    /// caller to reuse the `StringRecord` allocation, which usually results\n    /// in higher throughput.\n    ///\n    /// Records read via this method are guaranteed to have a position set\n    /// on them, even if the reader is at EOF or if an error is returned.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{Reader, StringRecord};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// \";\n    ///     let mut rdr = Reader::from_reader(data.as_bytes());\n    ///     let mut record = StringRecord::new();\n    ///\n    ///     if rdr.read_record(&mut record)? {\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn read_record(&mut self, record: &mut StringRecord) -> Result<bool> {\n        let result = record.read(self);\n        // We need to trim again because trimming string records includes\n        // Unicode whitespace. (ByteRecord trimming only includes ASCII\n        // whitespace.)\n        if self.state.trim.should_trim_fields() {\n            record.trim();\n        }\n        result\n    }\n\n    /// Read a single row into the given byte record. Returns false when no\n    /// more records could be read.\n    ///\n    /// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n    /// default), then this will never read the first record.\n    ///\n    /// This method is useful when you want to read records as fast as\n    /// as possible. It's less ergonomic than an iterator, but it permits the\n    /// caller to reuse the `ByteRecord` allocation, which usually results\n    /// in higher throughput.\n    ///\n    /// Records read via this method are guaranteed to have a position set\n    /// on them, even if the reader is at EOF or if an error is returned.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{ByteRecord, Reader};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// \";\n    ///     let mut rdr = Reader::from_reader(data.as_bytes());\n    ///     let mut record = ByteRecord::new();\n    ///\n    ///     if rdr.read_byte_record(&mut record)? {\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn read_byte_record(\n        &mut self,\n        record: &mut ByteRecord,\n    ) -> Result<bool> {\n        if !self.state.seeked && !self.state.has_headers && !self.state.first {\n            // If the caller indicated \"no headers\" and we haven't yielded the\n            // first record yet, then we should yield our header row if we have\n            // one.\n            if let Some(ref headers) = self.state.headers {\n                self.state.first = true;\n                record.clone_from(&headers.byte_record);\n                if self.state.trim.should_trim_fields() {\n                    record.trim();\n                }\n                return Ok(!record.is_empty());\n            }\n        }\n        let ok = self.read_byte_record_impl(record)?;\n        self.state.first = true;\n        if !self.state.seeked && self.state.headers.is_none() {\n            self.set_headers_impl(Err(record.clone()));\n            // If the end user indicated that we have headers, then we should\n            // never return the first row. Instead, we should attempt to\n            // read and return the next one.\n            if self.state.has_headers {\n                let result = self.read_byte_record_impl(record);\n                if self.state.trim.should_trim_fields() {\n                    record.trim();\n                }\n                return result;\n            }\n        } else if self.state.trim.should_trim_fields() {\n            record.trim();\n        }\n        Ok(ok)\n    }\n\n    /// Read a byte record from the underlying CSV reader, without accounting\n    /// for headers.\n    #[inline(always)]\n    fn read_byte_record_impl(\n        &mut self,\n        record: &mut ByteRecord,\n    ) -> Result<bool> {\n        use csv_core::ReadRecordResult::*;\n\n        record.clear();\n        record.set_position(Some(self.state.cur_pos.clone()));\n        if self.state.eof {\n            return Ok(false);\n        }\n        let (mut outlen, mut endlen) = (0, 0);\n        loop {\n            let (res, nin, nout, nend) = {\n                let input = self.rdr.fill_buf()?;\n                let (fields, ends) = record.as_parts();\n                self.core.read_record(\n                    input,\n                    &mut fields[outlen..],\n                    &mut ends[endlen..],\n                )\n            };\n            self.rdr.consume(nin);\n            let byte = self.state.cur_pos.byte();\n            self.state\n                .cur_pos\n                .set_byte(byte + nin as u64)\n                .set_line(self.core.line());\n            outlen += nout;\n            endlen += nend;\n            match res {\n                InputEmpty => continue,\n                OutputFull => {\n                    record.expand_fields();\n                    continue;\n                }\n                OutputEndsFull => {\n                    record.expand_ends();\n                    continue;\n                }\n                Record => {\n                    record.set_len(endlen);\n                    self.state.add_record(record)?;\n                    return Ok(true);\n                }\n                End => {\n                    self.state.eof = true;\n                    return Ok(false);\n                }\n            }\n        }\n    }\n\n    /// Return the current position of this CSV reader.\n    ///\n    /// The byte offset in the position returned can be used to `seek` this\n    /// reader. In particular, seeking to a position returned here on the same\n    /// data will result in parsing the same subsequent record.\n    ///\n    /// # Example: reading the position\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::io;\n    /// use csv::{Reader, Position};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,popcount\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \";\n    ///     let rdr = Reader::from_reader(io::Cursor::new(data));\n    ///     let mut iter = rdr.into_records();\n    ///     let mut pos = Position::new();\n    ///     loop {\n    ///         // Read the position immediately before each record.\n    ///         let next_pos = iter.reader().position().clone();\n    ///         if iter.next().is_none() {\n    ///             break;\n    ///         }\n    ///         pos = next_pos;\n    ///     }\n    ///\n    ///     // `pos` should now be the position immediately before the last\n    ///     // record.\n    ///     assert_eq!(pos.byte(), 51);\n    ///     assert_eq!(pos.line(), 3);\n    ///     assert_eq!(pos.record(), 2);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn position(&self) -> &Position {\n        &self.state.cur_pos\n    }\n\n    /// Returns true if and only if this reader has been exhausted.\n    ///\n    /// When this returns true, no more records can be read from this reader\n    /// (unless it has been seeked to another position).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::io;\n    /// use csv::{Reader, Position};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,popcount\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \";\n    ///     let mut rdr = Reader::from_reader(io::Cursor::new(data));\n    ///     assert!(!rdr.is_done());\n    ///     for result in rdr.records() {\n    ///         let _ = result?;\n    ///     }\n    ///     assert!(rdr.is_done());\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn is_done(&self) -> bool {\n        self.state.eof\n    }\n\n    /// Returns true if and only if this reader has been configured to\n    /// interpret the first record as a header record.\n    pub fn has_headers(&self) -> bool {\n        self.state.has_headers\n    }\n\n    /// Returns a reference to the underlying reader.\n    pub fn get_ref(&self) -> &R {\n        self.rdr.get_ref()\n    }\n\n    /// Returns a mutable reference to the underlying reader.\n    pub fn get_mut(&mut self) -> &mut R {\n        self.rdr.get_mut()\n    }\n\n    /// Unwraps this CSV reader, returning the underlying reader.\n    ///\n    /// Note that any leftover data inside this reader's internal buffer is\n    /// lost.\n    pub fn into_inner(self) -> R {\n        self.rdr.into_inner()\n    }\n}"],"reader::ReaderBuilder":["Debug","impl Default for ReaderBuilder {\n    fn default() -> ReaderBuilder {\n        ReaderBuilder {\n            capacity: 8 * (1 << 10),\n            flexible: false,\n            has_headers: true,\n            trim: Trim::default(),\n            builder: Box::new(CoreReaderBuilder::default()),\n        }\n    }\n}","impl ReaderBuilder {\n    /// Create a new builder for configuring CSV parsing.\n    ///\n    /// To convert a builder into a reader, call one of the methods starting\n    /// with `from_`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{ReaderBuilder, StringRecord};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new().from_reader(data.as_bytes());\n    ///\n    ///     let records = rdr\n    ///         .records()\n    ///         .collect::<Result<Vec<StringRecord>, csv::Error>>()?;\n    ///     assert_eq!(records, vec![\n    ///         vec![\"Boston\", \"United States\", \"4628910\"],\n    ///         vec![\"Concord\", \"United States\", \"42695\"],\n    ///     ]);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn new() -> ReaderBuilder {\n        ReaderBuilder::default()\n    }\n\n    /// Build a CSV parser from this configuration that reads data from the\n    /// given file path.\n    ///\n    /// If there was a problem opening the file at the given path, then this\n    /// returns the corresponding error.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use std::error::Error;\n    /// use csv::ReaderBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut rdr = ReaderBuilder::new().from_path(\"foo.csv\")?;\n    ///     for result in rdr.records() {\n    ///         let record = result?;\n    ///         println!(\"{:?}\", record);\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn from_path<P: AsRef<Path>>(&self, path: P) -> Result<Reader<File>> {\n        Ok(Reader::new(self, File::open(path)?))\n    }\n\n    /// Build a CSV parser from this configuration that reads data from `rdr`.\n    ///\n    /// Note that the CSV reader is buffered automatically, so you should not\n    /// wrap `rdr` in a buffered reader like `io::BufReader`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::ReaderBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new().from_reader(data.as_bytes());\n    ///     for result in rdr.records() {\n    ///         let record = result?;\n    ///         println!(\"{:?}\", record);\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn from_reader<R: io::Read>(&self, rdr: R) -> Reader<R> {\n        Reader::new(self, rdr)\n    }\n\n    /// The field delimiter to use when parsing CSV.\n    ///\n    /// The default is `b','`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::ReaderBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city;country;pop\n    /// Boston;United States;4628910\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .delimiter(b';')\n    ///         .from_reader(data.as_bytes());\n    ///\n    ///     if let Some(result) = rdr.records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn delimiter(&mut self, delimiter: u8) -> &mut ReaderBuilder {\n        self.builder.delimiter(delimiter);\n        self\n    }\n\n    /// Whether to treat the first row as a special header row.\n    ///\n    /// By default, the first row is treated as a special header row, which\n    /// means the header is never returned by any of the record reading methods\n    /// or iterators. When this is disabled (`yes` set to `false`), the first\n    /// row is not treated specially.\n    ///\n    /// Note that the `headers` and `byte_headers` methods are unaffected by\n    /// whether this is set. Those methods always return the first record.\n    ///\n    /// # Example\n    ///\n    /// This example shows what happens when `has_headers` is disabled.\n    /// Namely, the first row is treated just like any other row.\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::ReaderBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States,4628910\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .has_headers(false)\n    ///         .from_reader(data.as_bytes());\n    ///     let mut iter = rdr.records();\n    ///\n    ///     // Read the first record.\n    ///     if let Some(result) = iter.next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"city\", \"country\", \"pop\"]);\n    ///     } else {\n    ///         return Err(From::from(\n    ///             \"expected at least two records but got none\"));\n    ///     }\n    ///\n    ///     // Read the second record.\n    ///     if let Some(result) = iter.next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///     } else {\n    ///         return Err(From::from(\n    ///             \"expected at least two records but got one\"))\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn has_headers(&mut self, yes: bool) -> &mut ReaderBuilder {\n        self.has_headers = yes;\n        self\n    }\n\n    /// Whether the number of fields in records is allowed to change or not.\n    ///\n    /// When disabled (which is the default), parsing CSV data will return an\n    /// error if a record is found with a number of fields different from the\n    /// number of fields in a previous record.\n    ///\n    /// When enabled, this error checking is turned off.\n    ///\n    /// # Example: flexible records enabled\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::ReaderBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     // Notice that the first row is missing the population count.\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .flexible(true)\n    ///         .from_reader(data.as_bytes());\n    ///\n    ///     if let Some(result) = rdr.records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// # Example: flexible records disabled\n    ///\n    /// This shows the error that appears when records of unequal length\n    /// are found and flexible records have been disabled (which is the\n    /// default).\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{ErrorKind, ReaderBuilder};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     // Notice that the first row is missing the population count.\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,United States\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .flexible(false)\n    ///         .from_reader(data.as_bytes());\n    ///\n    ///     if let Some(Err(err)) = rdr.records().next() {\n    ///         match *err.kind() {\n    ///             ErrorKind::UnequalLengths { expected_len, len, .. } => {\n    ///                 // The header row has 3 fields...\n    ///                 assert_eq!(expected_len, 3);\n    ///                 // ... but the first row has only 2 fields.\n    ///                 assert_eq!(len, 2);\n    ///                 Ok(())\n    ///             }\n    ///             ref wrong => {\n    ///                 Err(From::from(format!(\n    ///                     \"expected UnequalLengths error but got {:?}\",\n    ///                     wrong)))\n    ///             }\n    ///         }\n    ///     } else {\n    ///         Err(From::from(\n    ///             \"expected at least one errored record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn flexible(&mut self, yes: bool) -> &mut ReaderBuilder {\n        self.flexible = yes;\n        self\n    }\n\n    /// Whether fields are trimmed of leading and trailing whitespace or not.\n    ///\n    /// By default, no trimming is performed. This method permits one to\n    /// override that behavior and choose one of the following options:\n    ///\n    /// 1. `Trim::Headers` trims only header values.\n    /// 2. `Trim::Fields` trims only non-header or \"field\" values.\n    /// 3. `Trim::All` trims both header and non-header values.\n    ///\n    /// A value is only interpreted as a header value if this CSV reader is\n    /// configured to read a header record (which is the default).\n    ///\n    /// When reading string records, characters meeting the definition of\n    /// Unicode whitespace are trimmed. When reading byte records, characters\n    /// meeting the definition of ASCII whitespace are trimmed. ASCII\n    /// whitespace characters correspond to the set `[\\t\\n\\v\\f\\r ]`.\n    ///\n    /// # Example\n    ///\n    /// This example shows what happens when all values are trimmed.\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{ReaderBuilder, StringRecord, Trim};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city ,   country ,  pop\n    /// Boston,\\\"\n    ///    United States\\\",4628910\n    /// Concord,   United States   ,42695\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .trim(Trim::All)\n    ///         .from_reader(data.as_bytes());\n    ///     let records = rdr\n    ///         .records()\n    ///         .collect::<Result<Vec<StringRecord>, csv::Error>>()?;\n    ///     assert_eq!(records, vec![\n    ///         vec![\"Boston\", \"United States\", \"4628910\"],\n    ///         vec![\"Concord\", \"United States\", \"42695\"],\n    ///     ]);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn trim(&mut self, trim: Trim) -> &mut ReaderBuilder {\n        self.trim = trim;\n        self\n    }\n\n    /// The record terminator to use when parsing CSV.\n    ///\n    /// A record terminator can be any single byte. The default is a special\n    /// value, `Terminator::CRLF`, which treats any occurrence of `\\r`, `\\n`\n    /// or `\\r\\n` as a single record terminator.\n    ///\n    /// # Example: `$` as a record terminator\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{ReaderBuilder, Terminator};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"city,country,pop$Boston,United States,4628910\";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .terminator(Terminator::Any(b'$'))\n    ///         .from_reader(data.as_bytes());\n    ///\n    ///     if let Some(result) = rdr.records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn terminator(&mut self, term: Terminator) -> &mut ReaderBuilder {\n        self.builder.terminator(term.to_core());\n        self\n    }\n\n    /// The quote character to use when parsing CSV.\n    ///\n    /// The default is `b'\"'`.\n    ///\n    /// # Example: single quotes instead of double quotes\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::ReaderBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,'United States',4628910\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .quote(b'\\'')\n    ///         .from_reader(data.as_bytes());\n    ///\n    ///     if let Some(result) = rdr.records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn quote(&mut self, quote: u8) -> &mut ReaderBuilder {\n        self.builder.quote(quote);\n        self\n    }\n\n    /// The escape character to use when parsing CSV.\n    ///\n    /// In some variants of CSV, quotes are escaped using a special escape\n    /// character like `\\` (instead of escaping quotes by doubling them).\n    ///\n    /// By default, recognizing these idiosyncratic escapes is disabled.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::ReaderBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,\\\"The \\\\\\\"United\\\\\\\" States\\\",4628910\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .escape(Some(b'\\\\'))\n    ///         .from_reader(data.as_bytes());\n    ///\n    ///     if let Some(result) = rdr.records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\n    ///             \"Boston\", \"The \\\"United\\\" States\", \"4628910\",\n    ///         ]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn escape(&mut self, escape: Option<u8>) -> &mut ReaderBuilder {\n        self.builder.escape(escape);\n        self\n    }\n\n    /// Enable double quote escapes.\n    ///\n    /// This is enabled by default, but it may be disabled. When disabled,\n    /// doubled quotes are not interpreted as escapes.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::ReaderBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,\\\"The \\\"\\\"United\\\"\\\" States\\\",4628910\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .double_quote(false)\n    ///         .from_reader(data.as_bytes());\n    ///\n    ///     if let Some(result) = rdr.records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\n    ///             \"Boston\", \"The \\\"United\\\"\\\" States\\\"\", \"4628910\",\n    ///         ]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn double_quote(&mut self, yes: bool) -> &mut ReaderBuilder {\n        self.builder.double_quote(yes);\n        self\n    }\n\n    /// Enable or disable quoting.\n    ///\n    /// This is enabled by default, but it may be disabled. When disabled,\n    /// quotes are not treated specially.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::ReaderBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// Boston,\\\"The United States,4628910\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .quoting(false)\n    ///         .from_reader(data.as_bytes());\n    ///\n    ///     if let Some(result) = rdr.records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\n    ///             \"Boston\", \"\\\"The United States\", \"4628910\",\n    ///         ]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn quoting(&mut self, yes: bool) -> &mut ReaderBuilder {\n        self.builder.quoting(yes);\n        self\n    }\n\n    /// The comment character to use when parsing CSV.\n    ///\n    /// If the start of a record begins with the byte given here, then that\n    /// line is ignored by the CSV parser.\n    ///\n    /// This is disabled by default.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::ReaderBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city,country,pop\n    /// #Concord,United States,42695\n    /// Boston,United States,4628910\n    /// \";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .comment(Some(b'#'))\n    ///         .from_reader(data.as_bytes());\n    ///\n    ///     if let Some(result) = rdr.records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn comment(&mut self, comment: Option<u8>) -> &mut ReaderBuilder {\n        self.builder.comment(comment);\n        self\n    }\n\n    /// A convenience method for specifying a configuration to read ASCII\n    /// delimited text.\n    ///\n    /// This sets the delimiter and record terminator to the ASCII unit\n    /// separator (`\\x1F`) and record separator (`\\x1E`), respectively.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::ReaderBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let data = \"\\\n    /// city\\x1Fcountry\\x1Fpop\\x1EBoston\\x1FUnited States\\x1F4628910\";\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .ascii()\n    ///         .from_reader(data.as_bytes());\n    ///\n    ///     if let Some(result) = rdr.records().next() {\n    ///         let record = result?;\n    ///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n    ///         Ok(())\n    ///     } else {\n    ///         Err(From::from(\"expected at least one record but got none\"))\n    ///     }\n    /// }\n    /// ```\n    pub fn ascii(&mut self) -> &mut ReaderBuilder {\n        self.builder.ascii();\n        self\n    }\n\n    /// Set the capacity (in bytes) of the buffer used in the CSV reader.\n    /// This defaults to a reasonable setting.\n    pub fn buffer_capacity(&mut self, capacity: usize) -> &mut ReaderBuilder {\n        self.capacity = capacity;\n        self\n    }\n\n    /// Enable or disable the NFA for parsing CSV.\n    ///\n    /// This is intended to be a debug option. The NFA is always slower than\n    /// the DFA.\n    #[doc(hidden)]\n    pub fn nfa(&mut self, yes: bool) -> &mut ReaderBuilder {\n        self.builder.nfa(yes);\n        self\n    }\n}"],"reader::ReaderState":["Debug","impl ReaderState {\n    #[inline(always)]\n    fn add_record(&mut self, record: &ByteRecord) -> Result<()> {\n        let i = self.cur_pos.record();\n        self.cur_pos.set_record(i.checked_add(1).unwrap());\n        if !self.flexible {\n            match self.first_field_count {\n                None => self.first_field_count = Some(record.len() as u64),\n                Some(expected) => {\n                    if record.len() as u64 != expected {\n                        return Err(Error::new(ErrorKind::UnequalLengths {\n                            pos: record.position().map(Clone::clone),\n                            expected_len: expected,\n                            len: record.len() as u64,\n                        }));\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n}"],"reader::StringRecordsIntoIter":["impl<R: io::Read> Iterator for StringRecordsIntoIter<R> {\n    type Item = Result<StringRecord>;\n\n    fn next(&mut self) -> Option<Result<StringRecord>> {\n        match self.rdr.read_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(true) => Some(Ok(self.rec.clone())),\n            Ok(false) => None,\n        }\n    }\n}","impl<R: io::Read> StringRecordsIntoIter<R> {\n    fn new(rdr: Reader<R>) -> StringRecordsIntoIter<R> {\n        StringRecordsIntoIter { rdr: rdr, rec: StringRecord::new() }\n    }\n\n    /// Return a reference to the underlying CSV reader.\n    pub fn reader(&self) -> &Reader<R> {\n        &self.rdr\n    }\n\n    /// Return a mutable reference to the underlying CSV reader.\n    pub fn reader_mut(&mut self) -> &mut Reader<R> {\n        &mut self.rdr\n    }\n\n    /// Drop this iterator and return the underlying CSV reader.\n    pub fn into_reader(self) -> Reader<R> {\n        self.rdr\n    }\n}"],"reader::StringRecordsIter":["impl<'r, R: io::Read> Iterator for StringRecordsIter<'r, R> {\n    type Item = Result<StringRecord>;\n\n    fn next(&mut self) -> Option<Result<StringRecord>> {\n        match self.rdr.read_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(true) => Some(Ok(self.rec.clone())),\n            Ok(false) => None,\n        }\n    }\n}","impl<'r, R: io::Read> StringRecordsIter<'r, R> {\n    fn new(rdr: &'r mut Reader<R>) -> StringRecordsIter<'r, R> {\n        StringRecordsIter { rdr: rdr, rec: StringRecord::new() }\n    }\n\n    /// Return a reference to the underlying CSV reader.\n    pub fn reader(&self) -> &Reader<R> {\n        &self.rdr\n    }\n\n    /// Return a mutable reference to the underlying CSV reader.\n    pub fn reader_mut(&mut self) -> &mut Reader<R> {\n        &mut self.rdr\n    }\n}"],"serializer::SeHeader":["impl<'w, W: io::Write> SeHeader<'w, W> {\n    fn new(wtr: &'w mut Writer<W>) -> Self {\n        SeHeader { wtr: wtr, state: HeaderState::Write }\n    }\n\n    fn wrote_header(&self) -> bool {\n        use self::HeaderState::*;\n        match self.state {\n            Write | ErrorIfWrite(_) => false,\n            EncounteredStructField | InStructField => true,\n        }\n    }\n\n    fn handle_scalar<T: fmt::Display>(\n        &mut self,\n        name: T,\n    ) -> Result<(), Error> {\n        use self::HeaderState::*;\n\n        match self.state {\n            Write => {\n                self.state = ErrorIfWrite(error_scalar_outside_struct(name));\n                Ok(())\n            }\n            ErrorIfWrite(_) | InStructField => Ok(()),\n            EncounteredStructField => Err(error_scalar_outside_struct(name)),\n        }\n    }\n\n    fn handle_container<T: fmt::Display>(\n        &mut self,\n        name: T,\n    ) -> Result<&mut Self, Error> {\n        if let HeaderState::InStructField = self.state {\n            Err(error_container_inside_struct(name))\n        } else {\n            Ok(self)\n        }\n    }\n}"],"std::io::Error":["impl From<Error> for io::Error {\n    fn from(err: Error) -> io::Error {\n        io::Error::new(io::ErrorKind::Other, err)\n    }\n}"],"string_record::StringRecord":["Clone","Eq","impl Default for StringRecord {\n    #[inline]\n    fn default() -> StringRecord {\n        StringRecord::new()\n    }\n}","impl PartialEq for StringRecord {\n    fn eq(&self, other: &StringRecord) -> bool {\n        self.0.iter_eq(&other.0)\n    }\n}","impl StringRecord {\n    /// Create a new empty `StringRecord`.\n    ///\n    /// Note that you may find the `StringRecord::from` constructor more\n    /// convenient, which is provided by an impl on the `From` trait.\n    ///\n    /// # Example: create an empty record\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let record = StringRecord::new();\n    /// assert_eq!(record.len(), 0);\n    /// ```\n    ///\n    /// # Example: initialize a record from a `Vec`\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// assert_eq!(record.len(), 3);\n    /// ```\n    #[inline]\n    pub fn new() -> StringRecord {\n        StringRecord(ByteRecord::new())\n    }\n\n    /// Create a new empty `StringRecord` with the given capacity.\n    ///\n    /// `buffer` refers to the capacity of the buffer used to store the\n    /// actual row contents. `fields` refers to the number of fields one\n    /// might expect to store.\n    #[inline]\n    pub fn with_capacity(buffer: usize, fields: usize) -> StringRecord {\n        StringRecord(ByteRecord::with_capacity(buffer, fields))\n    }\n\n    /// Create a new `StringRecord` from a `ByteRecord`.\n    ///\n    /// Note that this does UTF-8 validation. If the given `ByteRecord` does\n    /// not contain valid UTF-8, then this returns an error. The error includes\n    /// the UTF-8 error and the original `ByteRecord`.\n    ///\n    /// # Example: valid UTF-8\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{ByteRecord, StringRecord};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let byte_record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n    ///     let str_record = StringRecord::from_byte_record(byte_record)?;\n    ///     assert_eq!(str_record.len(), 3);\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Example: invalid UTF-8\n    ///\n    /// ```\n    /// use csv::{ByteRecord, StringRecord};\n    ///\n    /// let byte_record = ByteRecord::from(vec![\n    ///     &b\"quux\"[..], &b\"foo\\xFFbar\"[..], &b\"c\"[..],\n    /// ]);\n    /// let err = StringRecord::from_byte_record(byte_record).unwrap_err();\n    /// assert_eq!(err.utf8_error().field(), 1);\n    /// assert_eq!(err.utf8_error().valid_up_to(), 3);\n    /// ```\n    #[inline]\n    pub fn from_byte_record(\n        record: ByteRecord,\n    ) -> result::Result<StringRecord, FromUtf8Error> {\n        match record.validate() {\n            Ok(()) => Ok(StringRecord(record)),\n            Err(err) => Err(FromUtf8Error::new(record, err)),\n        }\n    }\n\n    /// Lossily create a new `StringRecord` from a `ByteRecord`.\n    ///\n    /// This is like `StringRecord::from_byte_record`, except all invalid UTF-8\n    /// sequences are replaced with the `U+FFFD REPLACEMENT CHARACTER`, which\n    /// looks like this: .\n    ///\n    /// # Example: valid UTF-8\n    ///\n    /// ```\n    /// use csv::{ByteRecord, StringRecord};\n    ///\n    /// let byte_record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// let str_record = StringRecord::from_byte_record_lossy(byte_record);\n    /// assert_eq!(str_record.len(), 3);\n    /// ```\n    ///\n    /// # Example: invalid UTF-8\n    ///\n    /// ```\n    /// use csv::{ByteRecord, StringRecord};\n    ///\n    /// let byte_record = ByteRecord::from(vec![\n    ///     &b\"quux\"[..], &b\"foo\\xFFbar\"[..], &b\"c\"[..],\n    /// ]);\n    /// let str_record = StringRecord::from_byte_record_lossy(byte_record);\n    /// assert_eq!(&str_record[0], \"quux\");\n    /// assert_eq!(&str_record[1], \"foobar\");\n    /// assert_eq!(&str_record[2], \"c\");\n    /// ```\n    #[inline]\n    pub fn from_byte_record_lossy(record: ByteRecord) -> StringRecord {\n        // If the record is valid UTF-8, then take the easy path.\n        if let Ok(()) = record.validate() {\n            return StringRecord(record);\n        }\n        // TODO: We can be faster here. Not sure if it's worth it.\n        let mut str_record =\n            StringRecord::with_capacity(record.as_slice().len(), record.len());\n        for field in &record {\n            str_record.push_field(&String::from_utf8_lossy(field));\n        }\n        str_record\n    }\n\n    /// Deserialize this record.\n    ///\n    /// The `D` type parameter refers to the type that this record should be\n    /// deserialized into. The `'de` lifetime refers to the lifetime of the\n    /// `StringRecord`. The `'de` lifetime permits deserializing into structs\n    /// that borrow field data from this record.\n    ///\n    /// An optional `headers` parameter permits deserializing into a struct\n    /// based on its field names (corresponding to header values) rather than\n    /// the order in which the fields are defined.\n    ///\n    /// # Example: without headers\n    ///\n    /// This shows how to deserialize a single row into a struct based on the\n    /// order in which fields occur. This example also shows how to borrow\n    /// fields from the `StringRecord`, which results in zero allocation\n    /// deserialization.\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::StringRecord;\n    /// use serde::Deserialize;\n    ///\n    /// #[derive(Deserialize)]\n    /// struct Row<'a> {\n    ///     city: &'a str,\n    ///     country: &'a str,\n    ///     population: u64,\n    /// }\n    ///\n    /// # fn main() { example().unwrap() }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let record = StringRecord::from(vec![\n    ///         \"Boston\", \"United States\", \"4628910\",\n    ///     ]);\n    ///\n    ///     let row: Row = record.deserialize(None)?;\n    ///     assert_eq!(row.city, \"Boston\");\n    ///     assert_eq!(row.country, \"United States\");\n    ///     assert_eq!(row.population, 4628910);\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Example: with headers\n    ///\n    /// This example is like the previous one, but shows how to deserialize\n    /// into a struct based on the struct's field names. For this to work,\n    /// you must provide a header row.\n    ///\n    /// This example also shows that you can deserialize into owned data\n    /// types (e.g., `String`) instead of borrowed data types (e.g., `&str`).\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::StringRecord;\n    /// use serde::Deserialize;\n    ///\n    /// #[derive(Deserialize)]\n    /// struct Row {\n    ///     city: String,\n    ///     country: String,\n    ///     population: u64,\n    /// }\n    ///\n    /// # fn main() { example().unwrap() }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     // Notice that the fields are not in the same order\n    ///     // as the fields in the struct!\n    ///     let header = StringRecord::from(vec![\n    ///         \"country\", \"city\", \"population\",\n    ///     ]);\n    ///     let record = StringRecord::from(vec![\n    ///         \"United States\", \"Boston\", \"4628910\",\n    ///     ]);\n    ///\n    ///     let row: Row = record.deserialize(Some(&header))?;\n    ///     assert_eq!(row.city, \"Boston\");\n    ///     assert_eq!(row.country, \"United States\");\n    ///     assert_eq!(row.population, 4628910);\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn deserialize<'de, D: Deserialize<'de>>(\n        &'de self,\n        headers: Option<&'de StringRecord>,\n    ) -> Result<D> {\n        deserialize_string_record(self, headers)\n    }\n\n    /// Returns an iterator over all fields in this record.\n    ///\n    /// # Example\n    ///\n    /// This example shows how to iterate over each field in a `StringRecord`.\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// for field in record.iter() {\n    ///     assert!(field == \"a\" || field == \"b\" || field == \"c\");\n    /// }\n    /// ```\n    #[inline]\n    pub fn iter(&self) -> StringRecordIter {\n        self.into_iter()\n    }\n\n    /// Return the field at index `i`.\n    ///\n    /// If no field at index `i` exists, then this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// assert_eq!(record.get(1), Some(\"b\"));\n    /// assert_eq!(record.get(3), None);\n    /// ```\n    #[inline]\n    pub fn get(&self, i: usize) -> Option<&str> {\n        self.0.get(i).map(|bytes| {\n            debug_assert!(str::from_utf8(bytes).is_ok());\n            // This is safe because we guarantee that all string records\n            // have a valid UTF-8 buffer. It's also safe because we\n            // individually check each field for valid UTF-8.\n            unsafe { str::from_utf8_unchecked(bytes) }\n        })\n    }\n\n    /// Returns true if and only if this record is empty.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// assert!(StringRecord::new().is_empty());\n    /// ```\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns the number of fields in this record.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// assert_eq!(record.len(), 3);\n    /// ```\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    /// Truncate this record to `n` fields.\n    ///\n    /// If `n` is greater than the number of fields in this record, then this\n    /// has no effect.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let mut record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// assert_eq!(record.len(), 3);\n    /// record.truncate(1);\n    /// assert_eq!(record.len(), 1);\n    /// assert_eq!(record, vec![\"a\"]);\n    /// ```\n    #[inline]\n    pub fn truncate(&mut self, n: usize) {\n        self.0.truncate(n);\n    }\n\n    /// Clear this record so that it has zero fields.\n    ///\n    /// Note that it is not necessary to clear the record to reuse it with\n    /// the CSV reader.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let mut record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// assert_eq!(record.len(), 3);\n    /// record.clear();\n    /// assert_eq!(record.len(), 0);\n    /// ```\n    #[inline]\n    pub fn clear(&mut self) {\n        self.0.clear();\n    }\n\n    /// Trim the fields of this record so that leading and trailing whitespace\n    /// is removed.\n    ///\n    /// This method uses the Unicode definition of whitespace.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let mut record = StringRecord::from(vec![\n    ///     \"  \", \"\\u{3000}\\tfoo \", \"bar  \", \"b a z\",\n    /// ]);\n    /// record.trim();\n    /// assert_eq!(record, vec![\"\", \"foo\", \"bar\", \"b a z\"]);\n    /// ```\n    pub fn trim(&mut self) {\n        let length = self.len();\n        if length == 0 {\n            return;\n        }\n        // TODO: We could likely do this in place, but for now, we allocate.\n        let mut trimmed =\n            StringRecord::with_capacity(self.as_slice().len(), self.len());\n        trimmed.set_position(self.position().cloned());\n        for field in &*self {\n            trimmed.push_field(field.trim());\n        }\n        *self = trimmed;\n    }\n\n    /// Add a new field to this record.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let mut record = StringRecord::new();\n    /// record.push_field(\"foo\");\n    /// assert_eq!(&record[0], \"foo\");\n    /// ```\n    #[inline]\n    pub fn push_field(&mut self, field: &str) {\n        self.0.push_field(field.as_bytes());\n    }\n\n    /// Return the position of this record, if available.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{StringRecord, ReaderBuilder};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut record = StringRecord::new();\n    ///     let mut rdr = ReaderBuilder::new()\n    ///         .has_headers(false)\n    ///         .from_reader(\"a,b,c\\nx,y,z\".as_bytes());\n    ///\n    ///     assert!(rdr.read_record(&mut record)?);\n    ///     {\n    ///         let pos = record.position().expect(\"a record position\");\n    ///         assert_eq!(pos.byte(), 0);\n    ///         assert_eq!(pos.line(), 1);\n    ///         assert_eq!(pos.record(), 0);\n    ///     }\n    ///\n    ///     assert!(rdr.read_record(&mut record)?);\n    ///     {\n    ///         let pos = record.position().expect(\"a record position\");\n    ///         assert_eq!(pos.byte(), 6);\n    ///         assert_eq!(pos.line(), 2);\n    ///         assert_eq!(pos.record(), 1);\n    ///     }\n    ///\n    ///     // Finish the CSV reader for good measure.\n    ///     assert!(!rdr.read_record(&mut record)?);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[inline]\n    pub fn position(&self) -> Option<&Position> {\n        self.0.position()\n    }\n\n    /// Set the position of this record.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::{StringRecord, Position};\n    ///\n    /// let mut record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// let mut pos = Position::new();\n    /// pos.set_byte(100);\n    /// pos.set_line(4);\n    /// pos.set_record(2);\n    ///\n    /// record.set_position(Some(pos.clone()));\n    /// assert_eq!(record.position(), Some(&pos));\n    /// ```\n    #[inline]\n    pub fn set_position(&mut self, pos: Option<Position>) {\n        self.0.set_position(pos);\n    }\n\n    /// Return the start and end position of a field in this record.\n    ///\n    /// If no such field exists at the given index, then return `None`.\n    ///\n    /// The range returned can be used with the slice returned by `as_slice`.\n    /// Namely, the range returned is guaranteed to start and end at valid\n    /// UTF-8 sequence boundaries.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let record = StringRecord::from(vec![\"foo\", \"quux\", \"z\"]);\n    /// let range = record.range(1).expect(\"a record range\");\n    /// assert_eq!(&record.as_slice()[range], \"quux\");\n    /// ```\n    #[inline]\n    pub fn range(&self, i: usize) -> Option<Range<usize>> {\n        self.0.range(i)\n    }\n\n    /// Return the entire row as a single string slice. The slice returned\n    /// stores all fields contiguously. The boundaries of each field can be\n    /// determined via the `range` method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let record = StringRecord::from(vec![\"foo\", \"quux\", \"z\"]);\n    /// assert_eq!(record.as_slice(), \"fooquuxz\");\n    /// ```\n    #[inline]\n    pub fn as_slice(&self) -> &str {\n        debug_assert!(str::from_utf8(self.0.as_slice()).is_ok());\n        // This is safe because we guarantee that each field is valid UTF-8.\n        // If each field is valid UTF-8, then the entire buffer (up to the end\n        // of the last field) must also be valid UTF-8.\n        unsafe { str::from_utf8_unchecked(self.0.as_slice()) }\n    }\n\n    /// Return a reference to this record's raw\n    /// [`ByteRecord`](struct.ByteRecord.html).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let str_record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// let byte_record = str_record.as_byte_record();\n    /// assert_eq!(&byte_record[2], b\"c\");\n    /// ```\n    #[inline]\n    pub fn as_byte_record(&self) -> &ByteRecord {\n        &self.0\n    }\n\n    /// Convert this `StringRecord` into a\n    /// [`ByteRecord`](struct.ByteRecord.html).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use csv::StringRecord;\n    ///\n    /// let str_record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// let byte_record = str_record.into_byte_record();\n    /// assert_eq!(&byte_record[2], b\"c\");\n    /// ```\n    ///\n    /// Note that this can also be achieved using the `From` impl:\n    ///\n    /// ```\n    /// use csv::{ByteRecord, StringRecord};\n    ///\n    /// // Using ByteRecord::from...\n    /// let str_record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// assert_eq!(ByteRecord::from(str_record).len(), 3);\n    ///\n    /// // Using StringRecord::into...\n    /// let str_record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n    /// let byte_record: ByteRecord = str_record.into();\n    /// assert_eq!(byte_record.len(), 3);\n    /// ```\n    #[inline]\n    pub fn into_byte_record(self) -> ByteRecord {\n        self.0\n    }\n\n    /// A safe function for reading CSV data into a `StringRecord`.\n    ///\n    /// This relies on the internal representation of `StringRecord`.\n    #[inline(always)]\n    pub(crate) fn read<R: io::Read>(\n        &mut self,\n        rdr: &mut Reader<R>,\n    ) -> Result<bool> {\n        // SAFETY: This code is critical to upholding the safety of other code\n        // blocks in this module. Namely, after calling `read_byte_record`,\n        // it is possible for `record` to contain invalid UTF-8. We check for\n        // this in the `validate` method, and if it does have invalid UTF-8, we\n        // clear the record. (It is bad for `record` to contain invalid UTF-8\n        // because other accessor methods, like `get`, assume that every field\n        // is valid UTF-8.)\n        let pos = rdr.position().clone();\n        let read_res = rdr.read_byte_record(&mut self.0);\n        let utf8_res = match self.0.validate() {\n            Ok(()) => Ok(()),\n            Err(err) => {\n                // If this record isn't valid UTF-8, then completely wipe it.\n                self.0.clear();\n                Err(err)\n            }\n        };\n        match (read_res, utf8_res) {\n            (Err(err), _) => Err(err),\n            (Ok(_), Err(err)) => {\n                Err(Error::new(ErrorKind::Utf8 { pos: Some(pos), err: err }))\n            }\n            (Ok(eof), Ok(())) => Ok(eof),\n        }\n    }\n}","impl fmt::Debug for StringRecord {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let fields: Vec<&str> = self.iter().collect();\n        write!(f, \"StringRecord({:?})\", fields)\n    }\n}","impl ops::Index<usize> for StringRecord {\n    type Output = str;\n    #[inline]\n    fn index(&self, i: usize) -> &str {\n        self.get(i).unwrap()\n    }\n}","impl<'a, T: AsRef<str>> From<&'a [T]> for StringRecord {\n    #[inline]\n    fn from(xs: &'a [T]) -> StringRecord {\n        StringRecord::from_iter(xs)\n    }\n}","impl<T: AsRef<[u8]>> PartialEq<Vec<T>> for StringRecord {\n    fn eq(&self, other: &Vec<T>) -> bool {\n        self.0.iter_eq(other)\n    }\n}","impl<T: AsRef<[u8]>> PartialEq<[T]> for StringRecord {\n    fn eq(&self, other: &[T]) -> bool {\n        self.0.iter_eq(other)\n    }\n}","impl<T: AsRef<str>> Extend<T> for StringRecord {\n    #[inline]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        for x in iter {\n            self.push_field(x.as_ref());\n        }\n    }\n}","impl<T: AsRef<str>> From<Vec<T>> for StringRecord {\n    #[inline]\n    fn from(xs: Vec<T>) -> StringRecord {\n        StringRecord::from_iter(xs.into_iter())\n    }\n}","impl<T: AsRef<str>> FromIterator<T> for StringRecord {\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> StringRecord {\n        let mut record = StringRecord::new();\n        record.extend(iter);\n        record\n    }\n}"],"string_record::StringRecordIter":["impl<'r> DoubleEndedIterator for StringRecordIter<'r> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'r str> {\n        self.0.next_back().map(|bytes| {\n            debug_assert!(str::from_utf8(bytes).is_ok());\n            // See StringRecord::get for safety argument.\n            unsafe { str::from_utf8_unchecked(bytes) }\n        })\n    }\n}","impl<'r> Iterator for StringRecordIter<'r> {\n    type Item = &'r str;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'r str> {\n        self.0.next().map(|bytes| {\n            debug_assert!(str::from_utf8(bytes).is_ok());\n            // See StringRecord::get for safety argument.\n            unsafe { str::from_utf8_unchecked(bytes) }\n        })\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.0.len()\n    }\n}"],"writer::Buffer":["Debug","impl Buffer {\n    /// Returns a slice of the buffer's current contents.\n    ///\n    /// The slice returned may be empty.\n    #[inline]\n    fn readable(&self) -> &[u8] {\n        &self.buf[..self.len]\n    }\n\n    /// Returns a mutable slice of the remaining space in this buffer.\n    ///\n    /// The slice returned may be empty.\n    #[inline]\n    fn writable(&mut self) -> &mut [u8] {\n        &mut self.buf[self.len..]\n    }\n\n    /// Indicates that `n` bytes have been written to this buffer.\n    #[inline]\n    fn written(&mut self, n: usize) {\n        self.len += n;\n    }\n\n    /// Clear the buffer.\n    #[inline]\n    fn clear(&mut self) {\n        self.len = 0;\n    }\n}"],"writer::HeaderState":["Debug"],"writer::Writer":["Debug","impl Writer<File> {\n    /// Build a CSV writer with a default configuration that writes data to the\n    /// given file path. The file is truncated if it already exists.\n    ///\n    /// If there was a problem opening the file at the given path, then this\n    /// returns the corresponding error.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use std::error::Error;\n    /// use csv::Writer;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = Writer::from_path(\"foo.csv\")?;\n    ///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n    ///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n    ///     wtr.flush()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<Writer<File>> {\n        WriterBuilder::new().from_path(path)\n    }\n}","impl<W: io::Write> Drop for Writer<W> {\n    fn drop(&mut self) {\n        if self.wtr.is_some() && !self.state.panicked {\n            let _ = self.flush();\n        }\n    }\n}","impl<W: io::Write> Writer<W> {\n    fn new(builder: &WriterBuilder, wtr: W) -> Writer<W> {\n        let header_state = if builder.has_headers {\n            HeaderState::Write\n        } else {\n            HeaderState::None\n        };\n        Writer {\n            core: builder.builder.build(),\n            wtr: Some(wtr),\n            buf: Buffer { buf: vec![0; builder.capacity], len: 0 },\n            state: WriterState {\n                header: header_state,\n                flexible: builder.flexible,\n                first_field_count: None,\n                fields_written: 0,\n                panicked: false,\n            },\n        }\n    }\n\n    /// Build a CSV writer with a default configuration that writes data to\n    /// `wtr`.\n    ///\n    /// Note that the CSV writer is buffered automatically, so you should not\n    /// wrap `wtr` in a buffered writer like `io::BufWriter`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::Writer;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = Writer::from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n    ///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn from_writer(wtr: W) -> Writer<W> {\n        WriterBuilder::new().from_writer(wtr)\n    }\n\n    /// Serialize a single record using Serde.\n    ///\n    /// # Example\n    ///\n    /// This shows how to serialize normal Rust structs as CSV records. The\n    /// fields of the struct are used to write a header row automatically.\n    /// (Writing the header row automatically can be disabled by building the\n    /// CSV writer with a [`WriterBuilder`](struct.WriterBuilder.html) and\n    /// calling the `has_headers` method.)\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::Writer;\n    /// use serde::Serialize;\n    ///\n    /// #[derive(Serialize)]\n    /// struct Row<'a> {\n    ///     city: &'a str,\n    ///     country: &'a str,\n    ///     // Serde allows us to name our headers exactly,\n    ///     // even if they don't match our struct field names.\n    ///     #[serde(rename = \"popcount\")]\n    ///     population: u64,\n    /// }\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = Writer::from_writer(vec![]);\n    ///     wtr.serialize(Row {\n    ///         city: \"Boston\",\n    ///         country: \"United States\",\n    ///         population: 4628910,\n    ///     })?;\n    ///     wtr.serialize(Row {\n    ///         city: \"Concord\",\n    ///         country: \"United States\",\n    ///         population: 42695,\n    ///     })?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"\\\n    /// city,country,popcount\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \");\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Rules\n    ///\n    /// The behavior of `serialize` is fairly simple:\n    ///\n    /// 1. Nested containers (tuples, `Vec`s, structs, etc.) are always\n    ///    flattened (depth-first order).\n    ///\n    /// 2. If `has_headers` is `true` and the type contains field names, then\n    ///    a header row is automatically generated.\n    ///\n    /// However, some container types cannot be serialized, and if\n    /// `has_headers` is `true`, there are some additional restrictions on the\n    /// types that can be serialized. See below for details.\n    ///\n    /// For the purpose of this section, Rust types can be divided into three\n    /// categories: scalars, non-struct containers, and structs.\n    ///\n    /// ## Scalars\n    ///\n    /// Single values with no field names are written like the following. Note\n    /// that some of the outputs may be quoted, according to the selected\n    /// quoting style.\n    ///\n    /// | Name | Example Type | Example Value | Output |\n    /// | ---- | ---- | ---- | ---- |\n    /// | boolean | `bool` | `true` | `true` |\n    /// | integers | `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128` | `5` | `5` |\n    /// | floats | `f32`, `f64` | `3.14` | `3.14` |\n    /// | character | `char` | `''` | `` |\n    /// | string | `&str` | `\"hi\"` | `hi` |\n    /// | bytes | `&[u8]` | `b\"hi\"[..]` | `hi` |\n    /// | option | `Option` | `None` | *empty* |\n    /// | option |          | `Some(5)` | `5` |\n    /// | unit | `()` | `()` | *empty* |\n    /// | unit struct | `struct Foo;` | `Foo` | `Foo` |\n    /// | unit enum variant | `enum E { A, B }` | `E::A` | `A` |\n    /// | newtype struct | `struct Foo(u8);` | `Foo(5)` | `5` |\n    /// | newtype enum variant | `enum E { A(u8) }` | `E::A(5)` | `5` |\n    ///\n    /// Note that this table includes simple structs and enums. For example, to\n    /// serialize a field from either an integer or a float type, one can do\n    /// this:\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::Writer;\n    /// use serde::Serialize;\n    ///\n    /// #[derive(Serialize)]\n    /// struct Row {\n    ///     label: String,\n    ///     value: Value,\n    /// }\n    ///\n    /// #[derive(Serialize)]\n    /// enum Value {\n    ///     Integer(i64),\n    ///     Float(f64),\n    /// }\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = Writer::from_writer(vec![]);\n    ///     wtr.serialize(Row {\n    ///         label: \"foo\".to_string(),\n    ///         value: Value::Integer(3),\n    ///     })?;\n    ///     wtr.serialize(Row {\n    ///         label: \"bar\".to_string(),\n    ///         value: Value::Float(3.14),\n    ///     })?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"\\\n    /// label,value\n    /// foo,3\n    /// bar,3.14\n    /// \");\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Non-Struct Containers\n    ///\n    /// Nested containers are flattened to their scalar components, with the\n    /// exeption of a few types that are not allowed:\n    ///\n    /// | Name | Example Type | Example Value | Output |\n    /// | ---- | ---- | ---- | ---- |\n    /// | sequence | `Vec<u8>` | `vec![1, 2, 3]` | `1,2,3` |\n    /// | tuple | `(u8, bool)` | `(5, true)` | `5,true` |\n    /// | tuple struct | `Foo(u8, bool)` | `Foo(5, true)` | `5,true` |\n    /// | tuple enum variant | `enum E { A(u8, bool) }` | `E::A(5, true)` | *error* |\n    /// | struct enum variant | `enum E { V { a: u8, b: bool } }` | `E::V { a: 5, b: true }` | *error* |\n    /// | map | `BTreeMap<K, V>` | `BTreeMap::new()` | *error* |\n    ///\n    /// ## Structs\n    ///\n    /// Like the other containers, structs are flattened to their scalar\n    /// components:\n    ///\n    /// | Name | Example Type | Example Value | Output |\n    /// | ---- | ---- | ---- | ---- |\n    /// | struct | `struct Foo { a: u8, b: bool }` | `Foo { a: 5, b: true }` | `5,true` |\n    ///\n    /// If `has_headers` is `false`, then there are no additional restrictions;\n    /// types can be nested arbitrarily. For example:\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::WriterBuilder;\n    /// use serde::Serialize;\n    ///\n    /// #[derive(Serialize)]\n    /// struct Row {\n    ///     label: String,\n    ///     values: Vec<f64>,\n    /// }\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new()\n    ///         .has_headers(false)\n    ///         .from_writer(vec![]);\n    ///     wtr.serialize(Row {\n    ///         label: \"foo\".to_string(),\n    ///         values: vec![1.1234, 2.5678, 3.14],\n    ///     })?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"\\\n    /// foo,1.1234,2.5678,3.14\n    /// \");\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// However, if `has_headers` were enabled in the above example, then\n    /// serialization would return an error. Speficially, when `has_headers` is\n    /// `true`, there are two restrictions:\n    ///\n    /// 1. Named field values in structs must be scalars.\n    ///\n    /// 2. All scalars must be named field values in structs.\n    ///\n    /// Other than these two restrictions, types can be nested arbitrarily.\n    /// Here are a few examples:\n    ///\n    /// | Value | Header | Record |\n    /// | ---- | ---- | ---- |\n    /// | `(Foo { x: 5, y: 6 }, Bar { z: true })` | `x,y,z` | `5,6,true` |\n    /// | `vec![Foo { x: 5, y: 6 }, Foo { x: 7, y: 8 }]` | `x,y,x,y` | `5,6,7,8` |\n    /// | `(Foo { x: 5, y: 6 }, vec![Bar { z: Baz(true) }])` | `x,y,z` | `5,6,true` |\n    /// | `Foo { x: 5, y: (6, 7) }` | *error: restriction 1* | `5,6,7` |\n    /// | `(5, Foo { x: 6, y: 7 }` | *error: restriction 2* | `5,6,7` |\n    /// | `(Foo { x: 5, y: 6 }, true)` | *error: restriction 2* | `5,6,true` |\n    pub fn serialize<S: Serialize>(&mut self, record: S) -> Result<()> {\n        if let HeaderState::Write = self.state.header {\n            let wrote_header = serialize_header(self, &record)?;\n            if wrote_header {\n                self.write_terminator()?;\n                self.state.header = HeaderState::DidWrite;\n            } else {\n                self.state.header = HeaderState::DidNotWrite;\n            };\n        }\n        serialize(self, &record)?;\n        self.write_terminator()?;\n        Ok(())\n    }\n\n    /// Write a single record.\n    ///\n    /// This method accepts something that can be turned into an iterator that\n    /// yields elements that can be represented by a `&[u8]`.\n    ///\n    /// This may be called with an empty iterator, which will cause a record\n    /// terminator to be written. If no fields had been written, then a single\n    /// empty field is written before the terminator.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::Writer;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = Writer::from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n    ///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn write_record<I, T>(&mut self, record: I) -> Result<()>\n    where\n        I: IntoIterator<Item = T>,\n        T: AsRef<[u8]>,\n    {\n        for field in record.into_iter() {\n            self.write_field_impl(field)?;\n        }\n        self.write_terminator()\n    }\n\n    /// Write a single `ByteRecord`.\n    ///\n    /// This method accepts a borrowed `ByteRecord` and writes its contents\n    /// to the underlying writer.\n    ///\n    /// This is similar to `write_record` except that it specifically requires\n    /// a `ByteRecord`. This permits the writer to possibly write the record\n    /// more quickly than the more generic `write_record`.\n    ///\n    /// This may be called with an empty record, which will cause a record\n    /// terminator to be written. If no fields had been written, then a single\n    /// empty field is written before the terminator.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{ByteRecord, Writer};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = Writer::from_writer(vec![]);\n    ///     wtr.write_byte_record(&ByteRecord::from(&[\"a\", \"b\", \"c\"][..]))?;\n    ///     wtr.write_byte_record(&ByteRecord::from(&[\"x\", \"y\", \"z\"][..]))?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    #[inline(never)]\n    pub fn write_byte_record(&mut self, record: &ByteRecord) -> Result<()> {\n        if record.as_slice().is_empty() {\n            return self.write_record(record);\n        }\n        // The idea here is to find a fast path for shuffling our record into\n        // our buffer as quickly as possible. We do this because the underlying\n        // \"core\" CSV writer does a lot of book-keeping to maintain its state\n        // oriented API.\n        //\n        // The fast path occurs when we know our record will fit in whatever\n        // space we have left in our buffer. We can actually quickly compute\n        // the upper bound on the space required:\n        let upper_bound =\n            // The data itself plus the worst case: every byte is a quote.\n            (2 * record.as_slice().len())\n            // The number of field delimiters.\n            + (record.len().saturating_sub(1))\n            // The maximum number of quotes inserted around each field.\n            + (2 * record.len())\n            // The maximum number of bytes for the terminator.\n            + 2;\n        if self.buf.writable().len() < upper_bound {\n            return self.write_record(record);\n        }\n        let mut first = true;\n        for field in record.iter() {\n            if !first {\n                self.buf.writable()[0] = self.core.get_delimiter();\n                self.buf.written(1);\n            }\n            first = false;\n\n            if !self.core.should_quote(field) {\n                self.buf.writable()[..field.len()].copy_from_slice(field);\n                self.buf.written(field.len());\n            } else {\n                self.buf.writable()[0] = self.core.get_quote();\n                self.buf.written(1);\n                let (res, nin, nout) = csv_core::quote(\n                    field,\n                    self.buf.writable(),\n                    self.core.get_quote(),\n                    self.core.get_escape(),\n                    self.core.get_double_quote(),\n                );\n                debug_assert!(res == WriteResult::InputEmpty);\n                debug_assert!(nin == field.len());\n                self.buf.written(nout);\n                self.buf.writable()[0] = self.core.get_quote();\n                self.buf.written(1);\n            }\n        }\n        self.state.fields_written = record.len() as u64;\n        self.write_terminator_into_buffer()\n    }\n\n    /// Write a single field.\n    ///\n    /// One should prefer using `write_record` over this method. It is provided\n    /// for cases where writing a field at a time is more convenient than\n    /// writing a record at a time.\n    ///\n    /// Note that if this API is used, `write_record` should be called with an\n    /// empty iterator to write a record terminator.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::Writer;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = Writer::from_writer(vec![]);\n    ///     wtr.write_field(\"a\")?;\n    ///     wtr.write_field(\"b\")?;\n    ///     wtr.write_field(\"c\")?;\n    ///     wtr.write_record(None::<&[u8]>)?;\n    ///     wtr.write_field(\"x\")?;\n    ///     wtr.write_field(\"y\")?;\n    ///     wtr.write_field(\"z\")?;\n    ///     wtr.write_record(None::<&[u8]>)?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn write_field<T: AsRef<[u8]>>(&mut self, field: T) -> Result<()> {\n        self.write_field_impl(field)\n    }\n\n    /// Implementation of write_field.\n    ///\n    /// This is a separate method so we can force the compiler to inline it\n    /// into write_record.\n    #[inline(always)]\n    fn write_field_impl<T: AsRef<[u8]>>(&mut self, field: T) -> Result<()> {\n        if self.state.fields_written > 0 {\n            self.write_delimiter()?;\n        }\n        let mut field = field.as_ref();\n        loop {\n            let (res, nin, nout) = self.core.field(field, self.buf.writable());\n            field = &field[nin..];\n            self.buf.written(nout);\n            match res {\n                WriteResult::InputEmpty => {\n                    self.state.fields_written += 1;\n                    return Ok(());\n                }\n                WriteResult::OutputFull => self.flush_buf()?,\n            }\n        }\n    }\n\n    /// Flush the contents of the internal buffer to the underlying writer.\n    ///\n    /// If there was a problem writing to the underlying writer, then an error\n    /// is returned.\n    ///\n    /// Note that this also flushes the underlying writer.\n    pub fn flush(&mut self) -> io::Result<()> {\n        self.flush_buf()?;\n        self.wtr.as_mut().unwrap().flush()?;\n        Ok(())\n    }\n\n    /// Flush the contents of the internal buffer to the underlying writer,\n    /// without flushing the underlying writer.\n    fn flush_buf(&mut self) -> io::Result<()> {\n        self.state.panicked = true;\n        let result = self.wtr.as_mut().unwrap().write_all(self.buf.readable());\n        self.state.panicked = false;\n        result?;\n        self.buf.clear();\n        Ok(())\n    }\n\n    /// Flush the contents of the internal buffer and return the underlying\n    /// writer.\n    pub fn into_inner(\n        mut self,\n    ) -> result::Result<W, IntoInnerError<Writer<W>>> {\n        match self.flush() {\n            Ok(()) => Ok(self.wtr.take().unwrap()),\n            Err(err) => Err(IntoInnerError::new(self, err)),\n        }\n    }\n\n    /// Write a CSV delimiter.\n    fn write_delimiter(&mut self) -> Result<()> {\n        loop {\n            let (res, nout) = self.core.delimiter(self.buf.writable());\n            self.buf.written(nout);\n            match res {\n                WriteResult::InputEmpty => return Ok(()),\n                WriteResult::OutputFull => self.flush_buf()?,\n            }\n        }\n    }\n\n    /// Write a CSV terminator.\n    fn write_terminator(&mut self) -> Result<()> {\n        self.check_field_count()?;\n        loop {\n            let (res, nout) = self.core.terminator(self.buf.writable());\n            self.buf.written(nout);\n            match res {\n                WriteResult::InputEmpty => {\n                    self.state.fields_written = 0;\n                    return Ok(());\n                }\n                WriteResult::OutputFull => self.flush_buf()?,\n            }\n        }\n    }\n\n    /// Write a CSV terminator that is guaranteed to fit into the current\n    /// buffer.\n    #[inline(never)]\n    fn write_terminator_into_buffer(&mut self) -> Result<()> {\n        self.check_field_count()?;\n        match self.core.get_terminator() {\n            csv_core::Terminator::CRLF => {\n                self.buf.writable()[0] = b'\\r';\n                self.buf.writable()[1] = b'\\n';\n                self.buf.written(2);\n            }\n            csv_core::Terminator::Any(b) => {\n                self.buf.writable()[0] = b;\n                self.buf.written(1);\n            }\n            _ => unreachable!(),\n        }\n        self.state.fields_written = 0;\n        Ok(())\n    }\n\n    fn check_field_count(&mut self) -> Result<()> {\n        if !self.state.flexible {\n            match self.state.first_field_count {\n                None => {\n                    self.state.first_field_count =\n                        Some(self.state.fields_written);\n                }\n                Some(expected) if expected != self.state.fields_written => {\n                    return Err(Error::new(ErrorKind::UnequalLengths {\n                        pos: None,\n                        expected_len: expected,\n                        len: self.state.fields_written,\n                    }))\n                }\n                Some(_) => {}\n            }\n        }\n        Ok(())\n    }\n}"],"writer::WriterBuilder":["Debug","impl Default for WriterBuilder {\n    fn default() -> WriterBuilder {\n        WriterBuilder {\n            builder: CoreWriterBuilder::default(),\n            capacity: 8 * (1 << 10),\n            flexible: false,\n            has_headers: true,\n        }\n    }\n}","impl WriterBuilder {\n    /// Create a new builder for configuring CSV writing.\n    ///\n    /// To convert a builder into a writer, call one of the methods starting\n    /// with `from_`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::WriterBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new().from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n    ///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn new() -> WriterBuilder {\n        WriterBuilder::default()\n    }\n\n    /// Build a CSV writer from this configuration that writes data to the\n    /// given file path. The file is truncated if it already exists.\n    ///\n    /// If there was a problem opening the file at the given path, then this\n    /// returns the corresponding error.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use std::error::Error;\n    /// use csv::WriterBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new().from_path(\"foo.csv\")?;\n    ///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n    ///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n    ///     wtr.flush()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn from_path<P: AsRef<Path>>(&self, path: P) -> Result<Writer<File>> {\n        Ok(Writer::new(self, File::create(path)?))\n    }\n\n    /// Build a CSV writer from this configuration that writes data to `wtr`.\n    ///\n    /// Note that the CSV writer is buffered automatically, so you should not\n    /// wrap `wtr` in a buffered writer like `io::BufWriter`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::WriterBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new().from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n    ///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn from_writer<W: io::Write>(&self, wtr: W) -> Writer<W> {\n        Writer::new(self, wtr)\n    }\n\n    /// The field delimiter to use when writing CSV.\n    ///\n    /// The default is `b','`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::WriterBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new()\n    ///         .delimiter(b';')\n    ///         .from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n    ///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a;b;c\\nx;y;z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn delimiter(&mut self, delimiter: u8) -> &mut WriterBuilder {\n        self.builder.delimiter(delimiter);\n        self\n    }\n\n    /// Whether to write a header row before writing any other row.\n    ///\n    /// When this is enabled and the `serialize` method is used to write data\n    /// with something that contains field names (i.e., a struct), then a\n    /// header row is written containing the field names before any other row\n    /// is written.\n    ///\n    /// This option has no effect when using other methods to write rows. That\n    /// is, if you don't use `serialize`, then you must write your header row\n    /// explicitly if you want a header row.\n    ///\n    /// This is enabled by default.\n    ///\n    /// # Example: with headers\n    ///\n    /// This shows how the header will be automatically written from the field\n    /// names of a struct.\n    ///\n    /// ```\n    /// use std::error::Error;\n    ///\n    /// use csv::WriterBuilder;\n    /// use serde::Serialize;\n    ///\n    /// #[derive(Serialize)]\n    /// struct Row<'a> {\n    ///     city: &'a str,\n    ///     country: &'a str,\n    ///     // Serde allows us to name our headers exactly,\n    ///     // even if they don't match our struct field names.\n    ///     #[serde(rename = \"popcount\")]\n    ///     population: u64,\n    /// }\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new().from_writer(vec![]);\n    ///     wtr.serialize(Row {\n    ///         city: \"Boston\",\n    ///         country: \"United States\",\n    ///         population: 4628910,\n    ///     })?;\n    ///     wtr.serialize(Row {\n    ///         city: \"Concord\",\n    ///         country: \"United States\",\n    ///         population: 42695,\n    ///     })?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"\\\n    /// city,country,popcount\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \");\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Example: without headers\n    ///\n    /// This shows that serializing things that aren't structs (in this case,\n    /// a tuple struct) won't result in a header row being written. This means\n    /// you usually don't need to set `has_headers(false)` unless you\n    /// explicitly want to both write custom headers and serialize structs.\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::WriterBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new().from_writer(vec![]);\n    ///     wtr.serialize((\"Boston\", \"United States\", 4628910))?;\n    ///     wtr.serialize((\"Concord\", \"United States\", 42695))?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"\\\n    /// Boston,United States,4628910\n    /// Concord,United States,42695\n    /// \");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn has_headers(&mut self, yes: bool) -> &mut WriterBuilder {\n        self.has_headers = yes;\n        self\n    }\n\n    /// Whether the number of fields in records is allowed to change or not.\n    ///\n    /// When disabled (which is the default), writing CSV data will return an\n    /// error if a record is written with a number of fields different from the\n    /// number of fields written in a previous record.\n    ///\n    /// When enabled, this error checking is turned off.\n    ///\n    /// # Example: writing flexible records\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::WriterBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new()\n    ///         .flexible(true)\n    ///         .from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"b\"])?;\n    ///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,b\\nx,y,z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Example: error when `flexible` is disabled\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::WriterBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new()\n    ///         .flexible(false)\n    ///         .from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"b\"])?;\n    ///     let err = wtr.write_record(&[\"x\", \"y\", \"z\"]).unwrap_err();\n    ///     match *err.kind() {\n    ///         csv::ErrorKind::UnequalLengths { expected_len, len, .. } => {\n    ///             assert_eq!(expected_len, 2);\n    ///             assert_eq!(len, 3);\n    ///         }\n    ///         ref wrong => {\n    ///             panic!(\"expected UnequalLengths but got {:?}\", wrong);\n    ///         }\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn flexible(&mut self, yes: bool) -> &mut WriterBuilder {\n        self.flexible = yes;\n        self\n    }\n\n    /// The record terminator to use when writing CSV.\n    ///\n    /// A record terminator can be any single byte. The default is `\\n`.\n    ///\n    /// Note that RFC 4180 specifies that record terminators should be `\\r\\n`.\n    /// To use `\\r\\n`, use the special `Terminator::CRLF` value.\n    ///\n    /// # Example: CRLF\n    ///\n    /// This shows how to use RFC 4180 compliant record terminators.\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{Terminator, WriterBuilder};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new()\n    ///         .terminator(Terminator::CRLF)\n    ///         .from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n    ///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,b,c\\r\\nx,y,z\\r\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn terminator(&mut self, term: Terminator) -> &mut WriterBuilder {\n        self.builder.terminator(term.to_core());\n        self\n    }\n\n    /// The quoting style to use when writing CSV.\n    ///\n    /// By default, this is set to `QuoteStyle::Necessary`, which will only\n    /// use quotes when they are necessary to preserve the integrity of data.\n    ///\n    /// Note that unless the quote style is set to `Never`, an empty field is\n    /// quoted if it is the only field in a record.\n    ///\n    /// # Example: non-numeric quoting\n    ///\n    /// This shows how to quote non-numeric fields only.\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{QuoteStyle, WriterBuilder};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new()\n    ///         .quote_style(QuoteStyle::NonNumeric)\n    ///         .from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"5\", \"c\"])?;\n    ///     wtr.write_record(&[\"3.14\", \"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"\\\"a\\\",5,\\\"c\\\"\\n3.14,\\\"y\\\",\\\"z\\\"\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Example: never quote\n    ///\n    /// This shows how the CSV writer can be made to never write quotes, even\n    /// if it sacrifices the integrity of the data.\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::{QuoteStyle, WriterBuilder};\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new()\n    ///         .quote_style(QuoteStyle::Never)\n    ///         .from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"foo\\nbar\", \"c\"])?;\n    ///     wtr.write_record(&[\"g\\\"h\\\"i\", \"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,foo\\nbar,c\\ng\\\"h\\\"i,y,z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn quote_style(&mut self, style: QuoteStyle) -> &mut WriterBuilder {\n        self.builder.quote_style(style.to_core());\n        self\n    }\n\n    /// The quote character to use when writing CSV.\n    ///\n    /// The default is `b'\"'`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::WriterBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new()\n    ///         .quote(b'\\'')\n    ///         .from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"foo\\nbar\", \"c\"])?;\n    ///     wtr.write_record(&[\"g'h'i\", \"y\\\"y\\\"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,'foo\\nbar',c\\n'g''h''i',y\\\"y\\\"y,z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn quote(&mut self, quote: u8) -> &mut WriterBuilder {\n        self.builder.quote(quote);\n        self\n    }\n\n    /// Enable double quote escapes.\n    ///\n    /// This is enabled by default, but it may be disabled. When disabled,\n    /// quotes in field data are escaped instead of doubled.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::WriterBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new()\n    ///         .double_quote(false)\n    ///         .from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"foo\\\"bar\", \"c\"])?;\n    ///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,\\\"foo\\\\\\\"bar\\\",c\\nx,y,z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn double_quote(&mut self, yes: bool) -> &mut WriterBuilder {\n        self.builder.double_quote(yes);\n        self\n    }\n\n    /// The escape character to use when writing CSV.\n    ///\n    /// In some variants of CSV, quotes are escaped using a special escape\n    /// character like `\\` (instead of escaping quotes by doubling them).\n    ///\n    /// By default, writing these idiosyncratic escapes is disabled, and is\n    /// only used when `double_quote` is disabled.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use csv::WriterBuilder;\n    ///\n    /// # fn main() { example().unwrap(); }\n    /// fn example() -> Result<(), Box<dyn Error>> {\n    ///     let mut wtr = WriterBuilder::new()\n    ///         .double_quote(false)\n    ///         .escape(b'$')\n    ///         .from_writer(vec![]);\n    ///     wtr.write_record(&[\"a\", \"foo\\\"bar\", \"c\"])?;\n    ///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n    ///\n    ///     let data = String::from_utf8(wtr.into_inner()?)?;\n    ///     assert_eq!(data, \"a,\\\"foo$\\\"bar\\\",c\\nx,y,z\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn escape(&mut self, escape: u8) -> &mut WriterBuilder {\n        self.builder.escape(escape);\n        self\n    }\n\n    /// Set the capacity (in bytes) of the internal buffer used in the CSV\n    /// writer. This defaults to a reasonable setting.\n    pub fn buffer_capacity(&mut self, capacity: usize) -> &mut WriterBuilder {\n        self.capacity = capacity;\n        self\n    }\n}"],"writer::WriterState":["Debug"]},"single_path_import":{"byte_record::ByteRecord":"ByteRecord","byte_record::ByteRecordIter":"ByteRecordIter","byte_record::Position":"Position","deserializer::DeserializeError":"DeserializeError","deserializer::DeserializeErrorKind":"DeserializeErrorKind","error::Error":"Error","error::ErrorKind":"ErrorKind","error::FromUtf8Error":"FromUtf8Error","error::IntoInnerError":"IntoInnerError","error::Result":"Result","error::Utf8Error":"Utf8Error","reader::ByteRecordsIntoIter":"ByteRecordsIntoIter","reader::ByteRecordsIter":"ByteRecordsIter","reader::DeserializeRecordsIntoIter":"DeserializeRecordsIntoIter","reader::DeserializeRecordsIter":"DeserializeRecordsIter","reader::Reader":"Reader","reader::ReaderBuilder":"ReaderBuilder","reader::StringRecordsIntoIter":"StringRecordsIntoIter","reader::StringRecordsIter":"StringRecordsIter","string_record::StringRecord":"StringRecord","string_record::StringRecordIter":"StringRecordIter","writer::Writer":"Writer","writer::WriterBuilder":"WriterBuilder"},"srcs":{"<&'a byte_record::ByteRecord as std::cmp::PartialEq<[T]>>::eq":["fn eq(&self, other: &[T]) -> bool{\n        self.iter_eq(other)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<&'a byte_record::ByteRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["fn eq(&self, other: &Vec<T>) -> bool{\n        self.iter_eq(other)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_any":["fn deserialize_any<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        self.infer_deserialize(visitor)\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_bool":["fn deserialize_bool<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        visitor.visit_bool(\n            self.next_field()?\n                .parse()\n                .map_err(|err| self.error(DEK::ParseBool(err)))?,\n        )\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_byte_buf":["fn deserialize_byte_buf<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        self.next_field_bytes()\n            .and_then(|f| visitor.visit_byte_buf(f.to_vec()))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_bytes":["fn deserialize_bytes<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        self.next_field_bytes().and_then(|f| visitor.visit_borrowed_bytes(f))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_char":["fn deserialize_char<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        let field = self.next_field()?;\n        let len = field.chars().count();\n        if len != 1 {\n            return Err(self.error(DEK::Message(format!(\n                \"expected single character but got {} characters in '{}'\",\n                len, field\n            ))));\n        }\n        visitor.visit_char(field.chars().next().unwrap())\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_enum":["fn deserialize_enum<V: Visitor<'de>>(\n        self,\n        _name: &'static str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        visitor.visit_enum(self)\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_f32":["fn deserialize_f32<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        visitor.visit_f32(\n            self.next_field()?\n                .parse()\n                .map_err(|err| self.error(DEK::ParseFloat(err)))?,\n        )\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_f64":["fn deserialize_f64<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        visitor.visit_f64(\n            self.next_field()?\n                .parse()\n                .map_err(|err| self.error(DEK::ParseFloat(err)))?,\n        )\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i128":["fn $method<V: Visitor<'de>>(\n            self,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>{\n            let field = self.next_field()?;\n            let num =\n                if field.starts_with(\"0x\") {\n                    <$inttype>::from_str_radix(&field[2..], 16)\n                } else {\n                    field.parse()\n                };\n            visitor.$visit(num.map_err(|err| self.error(DEK::ParseInt(err)))?)\n        }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i16":["fn $method<V: Visitor<'de>>(\n            self,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>{\n            let field = self.next_field()?;\n            let num =\n                if field.starts_with(\"0x\") {\n                    <$inttype>::from_str_radix(&field[2..], 16)\n                } else {\n                    field.parse()\n                };\n            visitor.$visit(num.map_err(|err| self.error(DEK::ParseInt(err)))?)\n        }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i32":["fn $method<V: Visitor<'de>>(\n            self,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>{\n            let field = self.next_field()?;\n            let num =\n                if field.starts_with(\"0x\") {\n                    <$inttype>::from_str_radix(&field[2..], 16)\n                } else {\n                    field.parse()\n                };\n            visitor.$visit(num.map_err(|err| self.error(DEK::ParseInt(err)))?)\n        }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i64":["fn $method<V: Visitor<'de>>(\n            self,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>{\n            let field = self.next_field()?;\n            let num =\n                if field.starts_with(\"0x\") {\n                    <$inttype>::from_str_radix(&field[2..], 16)\n                } else {\n                    field.parse()\n                };\n            visitor.$visit(num.map_err(|err| self.error(DEK::ParseInt(err)))?)\n        }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i8":["fn $method<V: Visitor<'de>>(\n            self,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>{\n            let field = self.next_field()?;\n            let num =\n                if field.starts_with(\"0x\") {\n                    <$inttype>::from_str_radix(&field[2..], 16)\n                } else {\n                    field.parse()\n                };\n            visitor.$visit(num.map_err(|err| self.error(DEK::ParseInt(err)))?)\n        }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_identifier":["fn deserialize_identifier<V: Visitor<'de>>(\n        self,\n        _visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        Err(self.error(DEK::Unsupported(\"deserialize_identifier\".into())))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_ignored_any":["fn deserialize_ignored_any<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        // Read and drop the next field.\n        // This code is reached, e.g., when trying to deserialize a header\n        // that doesn't exist in the destination struct.\n        let _ = self.next_field()?;\n        visitor.visit_unit()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_map":["fn deserialize_map<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        if !self.has_headers() {\n            visitor.visit_seq(self)\n        } else {\n            visitor.visit_map(self)\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_newtype_struct":["fn deserialize_newtype_struct<V: Visitor<'de>>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        visitor.visit_newtype_struct(self)\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_option":["fn deserialize_option<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        match self.peek_field() {\n            None => visitor.visit_none(),\n            Some(f) if f.is_empty() => {\n                self.next_field().expect(\"empty field\");\n                visitor.visit_none()\n            }\n            Some(_) => visitor.visit_some(self),\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_seq":["fn deserialize_seq<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        visitor.visit_seq(self)\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_str":["fn deserialize_str<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        self.next_field().and_then(|f| visitor.visit_borrowed_str(f))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_string":["fn deserialize_string<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        self.next_field().and_then(|f| visitor.visit_str(f.into()))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_struct":["fn deserialize_struct<V: Visitor<'de>>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        if !self.has_headers() {\n            visitor.visit_seq(self)\n        } else {\n            visitor.visit_map(self)\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_tuple":["fn deserialize_tuple<V: Visitor<'de>>(\n        self,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        visitor.visit_seq(self)\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_tuple_struct":["fn deserialize_tuple_struct<V: Visitor<'de>>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        visitor.visit_seq(self)\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u128":["fn $method<V: Visitor<'de>>(\n            self,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>{\n            let field = self.next_field()?;\n            let num =\n                if field.starts_with(\"0x\") {\n                    <$inttype>::from_str_radix(&field[2..], 16)\n                } else {\n                    field.parse()\n                };\n            visitor.$visit(num.map_err(|err| self.error(DEK::ParseInt(err)))?)\n        }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u16":["fn $method<V: Visitor<'de>>(\n            self,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>{\n            let field = self.next_field()?;\n            let num =\n                if field.starts_with(\"0x\") {\n                    <$inttype>::from_str_radix(&field[2..], 16)\n                } else {\n                    field.parse()\n                };\n            visitor.$visit(num.map_err(|err| self.error(DEK::ParseInt(err)))?)\n        }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u32":["fn $method<V: Visitor<'de>>(\n            self,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>{\n            let field = self.next_field()?;\n            let num =\n                if field.starts_with(\"0x\") {\n                    <$inttype>::from_str_radix(&field[2..], 16)\n                } else {\n                    field.parse()\n                };\n            visitor.$visit(num.map_err(|err| self.error(DEK::ParseInt(err)))?)\n        }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u64":["fn $method<V: Visitor<'de>>(\n            self,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>{\n            let field = self.next_field()?;\n            let num =\n                if field.starts_with(\"0x\") {\n                    <$inttype>::from_str_radix(&field[2..], 16)\n                } else {\n                    field.parse()\n                };\n            visitor.$visit(num.map_err(|err| self.error(DEK::ParseInt(err)))?)\n        }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u8":["fn $method<V: Visitor<'de>>(\n            self,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>{\n            let field = self.next_field()?;\n            let num =\n                if field.starts_with(\"0x\") {\n                    <$inttype>::from_str_radix(&field[2..], 16)\n                } else {\n                    field.parse()\n                };\n            visitor.$visit(num.map_err(|err| self.error(DEK::ParseInt(err)))?)\n        }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_unit":["fn deserialize_unit<V: Visitor<'de>>(\n        self,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        visitor.visit_unit()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_unit_struct":["fn deserialize_unit_struct<V: Visitor<'de>>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        visitor.visit_unit()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::EnumAccess<'de>>::variant_seed":["fn variant_seed<V: DeserializeSeed<'de>>(\n        self,\n        seed: V,\n    ) -> Result<(V::Value, Self::Variant), Self::Error>{\n        let variant_name = self.next_field()?;\n        seed.deserialize(variant_name.into_deserializer()).map(|v| (v, self))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::MapAccess<'de>>::next_key_seed":["fn next_key_seed<K: DeserializeSeed<'de>>(\n        &mut self,\n        seed: K,\n    ) -> Result<Option<K::Value>, Self::Error>{\n        assert!(self.has_headers());\n        let field = match self.next_header_bytes()? {\n            None => return Ok(None),\n            Some(field) => field,\n        };\n        seed.deserialize(BorrowedBytesDeserializer::new(field)).map(Some)\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::MapAccess<'de>>::next_value_seed":["fn next_value_seed<K: DeserializeSeed<'de>>(\n        &mut self,\n        seed: K,\n    ) -> Result<K::Value, Self::Error>{\n        seed.deserialize(&mut **self)\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::SeqAccess<'de>>::next_element_seed":["fn next_element_seed<U: DeserializeSeed<'de>>(\n        &mut self,\n        seed: U,\n    ) -> Result<Option<U::Value>, Self::Error>{\n        if self.peek_field().is_none() {\n            Ok(None)\n        } else {\n            seed.deserialize(&mut **self).map(Some)\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["fn newtype_variant_seed<U: DeserializeSeed<'de>>(\n        self,\n        _seed: U,\n    ) -> Result<U::Value, Self::Error>{\n        let unexp = Unexpected::UnitVariant;\n        Err(DeserializeError::invalid_type(unexp, &\"newtype variant\"))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::struct_variant":["fn struct_variant<V: Visitor<'de>>(\n        self,\n        _fields: &'static [&'static str],\n        _visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        let unexp = Unexpected::UnitVariant;\n        Err(DeserializeError::invalid_type(unexp, &\"struct variant\"))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::tuple_variant":["fn tuple_variant<V: Visitor<'de>>(\n        self,\n        _len: usize,\n        _visitor: V,\n    ) -> Result<V::Value, Self::Error>{\n        let unexp = Unexpected::UnitVariant;\n        Err(DeserializeError::invalid_type(unexp, &\"tuple variant\"))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::unit_variant":["fn unit_variant(self) -> Result<(), Self::Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_bool":["fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_bytes":["fn serialize_bytes(self, _value: &[u8]) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(\"&[u8]\")\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_char":["fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_f32":["fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_f64":["fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i128":["fn serialize_i128(self, v: i128) -> Result<Self::Ok, Self::Error>{\n            self.handle_scalar(v)\n        }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i16":["fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i32":["fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i64":["fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i8":["fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_map":["fn serialize_map(\n        self,\n        _len: Option<usize>,\n    ) -> Result<Self::SerializeMap, Self::Error>{\n        // The right behavior for serializing maps isn't clear.\n        Err(Error::custom(\n            \"serializing maps is not supported, \\\n             if you have a use case, please file an issue at \\\n             https://github.com/BurntSushi/rust-csv\",\n        ))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_newtype_struct":["fn serialize_newtype_struct<T: ?Sized + Serialize>(\n        self,\n        name: &'static str,\n        _value: &T,\n    ) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(format!(\"{}(_)\", name))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_newtype_variant":["fn serialize_newtype_variant<T: ?Sized + Serialize>(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        _value: &T,\n    ) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(format!(\"{}::{}(_)\", name, variant))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_none":["fn serialize_none(self) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(\"None\")\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_seq":["fn serialize_seq(\n        self,\n        _len: Option<usize>,\n    ) -> Result<Self::SerializeSeq, Self::Error>{\n        self.handle_container(\"sequence\")\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_some":["fn serialize_some<T: ?Sized + Serialize>(\n        self,\n        _value: &T,\n    ) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(\"Some(_)\")\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_str":["fn serialize_str(self, value: &str) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(value)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_struct":["fn serialize_struct(\n        self,\n        name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error>{\n        self.handle_container(name)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_struct_variant":["fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error>{\n        Err(Error::custom(\"serializing enum struct variants is not supported\"))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_tuple":["fn serialize_tuple(\n        self,\n        _len: usize,\n    ) -> Result<Self::SerializeTuple, Self::Error>{\n        self.handle_container(\"tuple\")\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_tuple_struct":["fn serialize_tuple_struct(\n        self,\n        name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error>{\n        self.handle_container(name)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_tuple_variant":["fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error>{\n        Err(Error::custom(\"serializing enum tuple variants is not supported\"))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u128":["fn serialize_u128(self, v: u128) -> Result<Self::Ok, Self::Error>{\n            self.handle_scalar(v)\n        }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u16":["fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u32":["fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u64":["fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u8":["fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(v)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_unit":["fn serialize_unit(self) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(\"()\")\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_unit_struct":["fn serialize_unit_struct(\n        self,\n        name: &'static str,\n    ) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(name)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_unit_variant":["fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error>{\n        self.handle_scalar(format!(\"{}::{}\", name, variant))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeMap>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeMap>::serialize_key":["fn serialize_key<T: ?Sized + Serialize>(\n        &mut self,\n        _key: &T,\n    ) -> Result<(), Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeMap>::serialize_value":["fn serialize_value<T: ?Sized + Serialize>(\n        &mut self,\n        _value: &T,\n    ) -> Result<(), Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeSeq>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeSeq>::serialize_element":["fn serialize_element<T: ?Sized + Serialize>(\n        &mut self,\n        value: &T,\n    ) -> Result<(), Self::Error>{\n        value.serialize(&mut **self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStruct>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStruct>::serialize_field":["fn serialize_field<T: ?Sized + Serialize>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>{\n        // Grab old state and update state to `EncounteredStructField`.\n        let old_state =\n            mem::replace(&mut self.state, HeaderState::EncounteredStructField);\n        if let HeaderState::ErrorIfWrite(err) = old_state {\n            return Err(err);\n        }\n        self.wtr.write_field(key)?;\n\n        // Check that there aren't any containers in the value.\n        self.state = HeaderState::InStructField;\n        value.serialize(&mut **self)?;\n        self.state = HeaderState::EncounteredStructField;\n\n        Ok(())\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStructVariant>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStructVariant>::serialize_field":["fn serialize_field<T: ?Sized + Serialize>(\n        &mut self,\n        _key: &'static str,\n        _value: &T,\n    ) -> Result<(), Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTuple>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTuple>::serialize_element":["fn serialize_element<T: ?Sized + Serialize>(\n        &mut self,\n        value: &T,\n    ) -> Result<(), Self::Error>{\n        value.serialize(&mut **self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleStruct>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleStruct>::serialize_field":["fn serialize_field<T: ?Sized + Serialize>(\n        &mut self,\n        value: &T,\n    ) -> Result<(), Self::Error>{\n        value.serialize(&mut **self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleVariant>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleVariant>::serialize_field":["fn serialize_field<T: ?Sized + Serialize>(\n        &mut self,\n        _value: &T,\n    ) -> Result<(), Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_bool":["fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error>{\n        if v {\n            self.wtr.write_field(\"true\")\n        } else {\n            self.wtr.write_field(\"false\")\n        }\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_bytes":["fn serialize_bytes(self, value: &[u8]) -> Result<Self::Ok, Self::Error>{\n        self.wtr.write_field(value)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_char":["fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error>{\n        self.wtr.write_field(v.encode_utf8(&mut [0; 4]))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_f32":["fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error>{\n        let mut buffer = ryu::Buffer::new();\n        self.wtr.write_field(buffer.format(v))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_f64":["fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error>{\n        let mut buffer = ryu::Buffer::new();\n        self.wtr.write_field(buffer.format(v))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i128":["fn serialize_i128(self, v: i128) -> Result<Self::Ok, Self::Error>{\n            self.collect_str(&v)\n        }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i16":["fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error>{\n        let mut buffer = itoa::Buffer::new();\n        self.wtr.write_field(buffer.format(v))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i32":["fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error>{\n        let mut buffer = itoa::Buffer::new();\n        self.wtr.write_field(buffer.format(v))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i64":["fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error>{\n        let mut buffer = itoa::Buffer::new();\n        self.wtr.write_field(buffer.format(v))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i8":["fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error>{\n        let mut buffer = itoa::Buffer::new();\n        self.wtr.write_field(buffer.format(v))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_map":["fn serialize_map(\n        self,\n        _len: Option<usize>,\n    ) -> Result<Self::SerializeMap, Self::Error>{\n        // The right behavior for serializing maps isn't clear.\n        Err(Error::custom(\n            \"serializing maps is not supported, \\\n             if you have a use case, please file an issue at \\\n             https://github.com/BurntSushi/rust-csv\",\n        ))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_newtype_struct":["fn serialize_newtype_struct<T: ?Sized + Serialize>(\n        self,\n        _name: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>{\n        value.serialize(self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_newtype_variant":["fn serialize_newtype_variant<T: ?Sized + Serialize>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>{\n        value.serialize(self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_none":["fn serialize_none(self) -> Result<Self::Ok, Self::Error>{\n        self.wtr.write_field(&[])\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_seq":["fn serialize_seq(\n        self,\n        _len: Option<usize>,\n    ) -> Result<Self::SerializeSeq, Self::Error>{\n        Ok(self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_some":["fn serialize_some<T: ?Sized + Serialize>(\n        self,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>{\n        value.serialize(self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_str":["fn serialize_str(self, value: &str) -> Result<Self::Ok, Self::Error>{\n        self.wtr.write_field(value)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_struct":["fn serialize_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error>{\n        Ok(self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_struct_variant":["fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error>{\n        Err(Error::custom(\"serializing enum struct variants is not supported\"))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_tuple":["fn serialize_tuple(\n        self,\n        _len: usize,\n    ) -> Result<Self::SerializeTuple, Self::Error>{\n        Ok(self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_tuple_struct":["fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error>{\n        Ok(self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_tuple_variant":["fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error>{\n        Err(Error::custom(\"serializing enum tuple variants is not supported\"))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u128":["fn serialize_u128(self, v: u128) -> Result<Self::Ok, Self::Error>{\n            self.collect_str(&v)\n        }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u16":["fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error>{\n        let mut buffer = itoa::Buffer::new();\n        self.wtr.write_field(buffer.format(v))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u32":["fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error>{\n        let mut buffer = itoa::Buffer::new();\n        self.wtr.write_field(buffer.format(v))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u64":["fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error>{\n        let mut buffer = itoa::Buffer::new();\n        self.wtr.write_field(buffer.format(v))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u8":["fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error>{\n        let mut buffer = itoa::Buffer::new();\n        self.wtr.write_field(buffer.format(v))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_unit":["fn serialize_unit(self) -> Result<Self::Ok, Self::Error>{\n        None::<()>.serialize(self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_unit_struct":["fn serialize_unit_struct(\n        self,\n        name: &'static str,\n    ) -> Result<Self::Ok, Self::Error>{\n        self.wtr.write_field(name)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_unit_variant":["fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error>{\n        self.wtr.write_field(variant)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeMap>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeMap>::serialize_key":["fn serialize_key<T: ?Sized + Serialize>(\n        &mut self,\n        _key: &T,\n    ) -> Result<(), Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeMap>::serialize_value":["fn serialize_value<T: ?Sized + Serialize>(\n        &mut self,\n        _value: &T,\n    ) -> Result<(), Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeSeq>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeSeq>::serialize_element":["fn serialize_element<T: ?Sized + Serialize>(\n        &mut self,\n        value: &T,\n    ) -> Result<(), Self::Error>{\n        value.serialize(&mut **self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStruct>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStruct>::serialize_field":["fn serialize_field<T: ?Sized + Serialize>(\n        &mut self,\n        _key: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>{\n        value.serialize(&mut **self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStructVariant>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStructVariant>::serialize_field":["fn serialize_field<T: ?Sized + Serialize>(\n        &mut self,\n        _key: &'static str,\n        _value: &T,\n    ) -> Result<(), Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTuple>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTuple>::serialize_element":["fn serialize_element<T: ?Sized + Serialize>(\n        &mut self,\n        value: &T,\n    ) -> Result<(), Self::Error>{\n        value.serialize(&mut **self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleStruct>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleStruct>::serialize_field":["fn serialize_field<T: ?Sized + Serialize>(\n        &mut self,\n        value: &T,\n    ) -> Result<(), Self::Error>{\n        value.serialize(&mut **self)\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleVariant>::end":["fn end(self) -> Result<Self::Ok, Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleVariant>::serialize_field":["fn serialize_field<T: ?Sized + Serialize>(\n        &mut self,\n        _value: &T,\n    ) -> Result<(), Self::Error>{\n        unreachable!()\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"<&'a string_record::StringRecord as std::cmp::PartialEq<[T]>>::eq":["fn eq(&self, other: &[T]) -> bool{\n        self.0.iter_eq(other)\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<&'a string_record::StringRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["fn eq(&self, other: &Vec<T>) -> bool{\n        self.0.iter_eq(other)\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<&'a string_record::StringRecord as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> StringRecordIter<'a>{\n        StringRecordIter(self.0.iter())\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<&'r byte_record::ByteRecord as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> ByteRecordIter<'r>{\n        ByteRecordIter {\n            r: self,\n            last_start: self.as_slice().len(),\n            last_end: 0,\n            i_forward: 0,\n            i_reverse: self.len(),\n        }\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<QuoteStyle as std::default::Default>::default":["fn default() -> QuoteStyle{\n        QuoteStyle::Necessary\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Terminator as std::default::Default>::default":["fn default() -> Terminator{\n        Terminator::CRLF\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Trim as std::default::Default>::default":["fn default() -> Trim{\n        Trim::None\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<byte_record::Bounds as std::default::Default>::default":["#[inline]\nfn default() -> Bounds{\n        Bounds::with_capacity(0)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecord as std::cmp::PartialEq<[T]>>::eq":["fn eq(&self, other: &[T]) -> bool{\n        self.iter_eq(other)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["fn eq(&self, other: &Vec<T>) -> bool{\n        self.iter_eq(other)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecord as std::cmp::PartialEq>::eq":["fn eq(&self, other: &ByteRecord) -> bool{\n        if self.len() != other.len() {\n            return false;\n        }\n        self.iter().zip(other.iter()).all(|e| e.0 == e.1)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecord as std::convert::From<&'a [T]>>::from":["#[inline]\nfn from(xs: &'a [T]) -> ByteRecord{\n        ByteRecord::from_iter(xs)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecord as std::convert::From<std::vec::Vec<T>>>::from":["#[inline]\nfn from(xs: Vec<T>) -> ByteRecord{\n        ByteRecord::from_iter(&xs)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecord as std::convert::From<string_record::StringRecord>>::from":["#[inline]\nfn from(record: StringRecord) -> ByteRecord{\n        record.into_byte_record()\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecord as std::default::Default>::default":["#[inline]\nfn default() -> ByteRecord{\n        ByteRecord::new()\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecord as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let mut fields = vec![];\n        for field in self {\n            fields.push(BString::from(field.to_vec()));\n        }\n        write!(f, \"ByteRecord({:?})\", fields)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecord as std::iter::Extend<T>>::extend":["#[inline]\nfn extend<I: IntoIterator<Item = T>>(&mut self, iter: I){\n        for x in iter {\n            self.push_field(x.as_ref());\n        }\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecord as std::iter::FromIterator<T>>::from_iter":["#[inline]\nfn from_iter<I: IntoIterator<Item = T>>(iter: I) -> ByteRecord{\n        let mut record = ByteRecord::new();\n        record.extend(iter);\n        record\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecord as std::ops::Index<usize>>::index":["#[inline]\nfn index(&self, i: usize) -> &[u8]{\n        self.get(i).unwrap()\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecordIter<'r> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<&'r [u8]>{\n        if self.i_forward == self.i_reverse {\n            None\n        } else {\n            self.i_reverse -= 1;\n            let start = self\n                .i_reverse\n                .checked_sub(1)\n                .map(|i| self.r.0.bounds.ends()[i])\n                .unwrap_or(0);\n            let end = self.last_start;\n            self.last_start = start;\n            Some(&self.r.0.fields[start..end])\n        }\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecordIter<'r> as std::iter::Iterator>::count":["#[inline]\nfn count(self) -> usize{\n        self.len()\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecordIter<'r> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'r [u8]>{\n        if self.i_forward == self.i_reverse {\n            None\n        } else {\n            let start = self.last_end;\n            let end = self.r.0.bounds.ends()[self.i_forward];\n            self.i_forward += 1;\n            self.last_end = end;\n            Some(&self.r.0.fields[start..end])\n        }\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<byte_record::ByteRecordIter<'r> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let x = self.i_reverse - self.i_forward;\n        (x, Some(x))\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::error":["fn error(&self, kind: DeserializeErrorKind) -> DeserializeError{\n        DeserializeError {\n            field: Some(self.field.saturating_sub(1)),\n            kind: kind,\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::has_headers":["#[inline]\nfn has_headers(&self) -> bool{\n        self.headers.is_some()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::infer_deserialize":["fn infer_deserialize<'de, V: Visitor<'de>>(\n        &mut self,\n        visitor: V,\n    ) -> Result<V::Value, DeserializeError>{\n        let x = self.next_field_bytes()?;\n        if x == b\"true\" {\n            return visitor.visit_bool(true);\n        } else if x == b\"false\" {\n            return visitor.visit_bool(false);\n        } else if let Some(n) = try_positive_integer64_bytes(x) {\n            return visitor.visit_u64(n);\n        } else if let Some(n) = try_negative_integer64_bytes(x) {\n            return visitor.visit_i64(n);\n        }\n        serde_if_integer128! {\n            if let Some(n) = try_positive_integer128_bytes(x) {\n                return visitor.visit_u128(n);\n            } else if let Some(n) = try_negative_integer128_bytes(x) {\n                return visitor.visit_i128(n);\n            }\n        }\n        if let Some(n) = try_float_bytes(x) {\n            visitor.visit_f64(n)\n        } else if let Ok(s) = str::from_utf8(x) {\n            visitor.visit_str(s)\n        } else {\n            visitor.visit_bytes(x)\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_field":["#[inline]\nfn next_field(&mut self) -> Result<&'r str, DeserializeError>{\n        self.next_field_bytes().and_then(|field| {\n            str::from_utf8(field)\n                .map_err(|err| self.error(DEK::InvalidUtf8(err)))\n        })\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_field_bytes":["#[inline]\nfn next_field_bytes(&mut self) -> Result<&'r [u8], DeserializeError>{\n        match self.it.next() {\n            Some(field) => {\n                self.field += 1;\n                Ok(field)\n            }\n            None => Err(DeserializeError {\n                field: None,\n                kind: DEK::UnexpectedEndOfRow,\n            }),\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_header":["#[inline]\nfn next_header(&mut self) -> Result<Option<&'r str>, DeserializeError>{\n        match self.next_header_bytes() {\n            Ok(Some(field)) => Ok(Some(\n                str::from_utf8(field)\n                    .map_err(|err| self.error(DEK::InvalidUtf8(err)))?,\n            )),\n            Ok(None) => Ok(None),\n            Err(err) => Err(err),\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_header_bytes":["#[inline]\nfn next_header_bytes(\n        &mut self,\n    ) -> Result<Option<&'r [u8]>, DeserializeError>{\n        Ok(self.headers.as_mut().and_then(|it| it.next()))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::peek_field":["#[inline]\nfn peek_field(&mut self) -> Option<&'r [u8]>{\n        self.it.peek().map(|s| *s)\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::error":["#[inline]\nfn error(&self, kind: DeserializeErrorKind) -> DeserializeError{\n        self.0.error(kind)\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::has_headers":["#[inline]\nfn has_headers(&self) -> bool{\n        self.0.has_headers()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::infer_deserialize":["#[inline]\nfn infer_deserialize<'de, V: Visitor<'de>>(\n        &mut self,\n        visitor: V,\n    ) -> Result<V::Value, DeserializeError>{\n        self.0.infer_deserialize(visitor)\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_field":["#[inline]\nfn next_field(&mut self) -> Result<&'r str, DeserializeError>{\n        self.0.next_field()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_field_bytes":["#[inline]\nfn next_field_bytes(&mut self) -> Result<&'r [u8], DeserializeError>{\n        self.0.next_field_bytes()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_header":["#[inline]\nfn next_header(&mut self) -> Result<Option<&'r str>, DeserializeError>{\n        self.0.next_header()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_header_bytes":["#[inline]\nfn next_header_bytes(\n        &mut self,\n    ) -> Result<Option<&'r [u8]>, DeserializeError>{\n        self.0.next_header_bytes()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::peek_field":["#[inline]\nfn peek_field(&mut self) -> Option<&'r [u8]>{\n        self.0.peek_field()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::error":["fn error(&self, kind: DeserializeErrorKind) -> DeserializeError{\n        DeserializeError {\n            field: Some(self.field.saturating_sub(1)),\n            kind: kind,\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::has_headers":["#[inline]\nfn has_headers(&self) -> bool{\n        self.headers.is_some()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::infer_deserialize":["fn infer_deserialize<'de, V: Visitor<'de>>(\n        &mut self,\n        visitor: V,\n    ) -> Result<V::Value, DeserializeError>{\n        let x = self.next_field()?;\n        if x == \"true\" {\n            return visitor.visit_bool(true);\n        } else if x == \"false\" {\n            return visitor.visit_bool(false);\n        } else if let Some(n) = try_positive_integer64(x) {\n            return visitor.visit_u64(n);\n        } else if let Some(n) = try_negative_integer64(x) {\n            return visitor.visit_i64(n);\n        }\n        serde_if_integer128! {\n            if let Some(n) = try_positive_integer128(x) {\n                return visitor.visit_u128(n);\n            } else if let Some(n) = try_negative_integer128(x) {\n                return visitor.visit_i128(n);\n            }\n        }\n        if let Some(n) = try_float(x) {\n            visitor.visit_f64(n)\n        } else {\n            visitor.visit_str(x)\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_field":["#[inline]\nfn next_field(&mut self) -> Result<&'r str, DeserializeError>{\n        match self.it.next() {\n            Some(field) => {\n                self.field += 1;\n                Ok(field)\n            }\n            None => Err(DeserializeError {\n                field: None,\n                kind: DEK::UnexpectedEndOfRow,\n            }),\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_field_bytes":["#[inline]\nfn next_field_bytes(&mut self) -> Result<&'r [u8], DeserializeError>{\n        self.next_field().map(|s| s.as_bytes())\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_header":["#[inline]\nfn next_header(&mut self) -> Result<Option<&'r str>, DeserializeError>{\n        Ok(self.headers.as_mut().and_then(|it| it.next()))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_header_bytes":["#[inline]\nfn next_header_bytes(\n        &mut self,\n    ) -> Result<Option<&'r [u8]>, DeserializeError>{\n        Ok(self.next_header()?.map(|s| s.as_bytes()))\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::peek_field":["#[inline]\nfn peek_field(&mut self) -> Option<&'r [u8]>{\n        self.it.peek().map(|s| s.as_bytes())\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeserializeError as serde::de::Error>::custom":["fn custom<T: fmt::Display>(msg: T) -> DeserializeError{\n        DeserializeError { field: None, kind: DEK::Message(msg.to_string()) }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeserializeError as std::error::Error>::description":["fn description(&self) -> &str{\n        self.kind.description()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeserializeError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if let Some(field) = self.field {\n            write!(f, \"field {}: {}\", field, self.kind)\n        } else {\n            write!(f, \"{}\", self.kind)\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<deserializer::DeserializeErrorKind as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use self::DeserializeErrorKind::*;\n\n        match *self {\n            Message(ref msg) => write!(f, \"{}\", msg),\n            Unsupported(ref which) => {\n                write!(f, \"unsupported deserializer method: {}\", which)\n            }\n            UnexpectedEndOfRow => write!(f, \"{}\", self.description()),\n            InvalidUtf8(ref err) => err.fmt(f),\n            ParseBool(ref err) => err.fmt(f),\n            ParseInt(ref err) => err.fmt(f),\n            ParseFloat(ref err) => err.fmt(f),\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"<error::Error as std::convert::From<std::io::Error>>::from":["fn from(err: io::Error) -> Error{\n        Error::new(ErrorKind::Io(err))\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::error::Error>::source":["fn source(&self) -> Option<&(dyn StdError + 'static)>{\n        match *self.0 {\n            ErrorKind::Io(ref err) => Some(err),\n            ErrorKind::Utf8 { ref err, .. } => Some(err),\n            ErrorKind::UnequalLengths { .. } => None,\n            ErrorKind::Seek => None,\n            ErrorKind::Serialize(_) => None,\n            ErrorKind::Deserialize { ref err, .. } => Some(err),\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match *self.0 {\n            ErrorKind::Io(ref err) => err.fmt(f),\n            ErrorKind::Utf8 { pos: None, ref err } => {\n                write!(f, \"CSV parse error: field {}: {}\", err.field(), err)\n            }\n            ErrorKind::Utf8 { pos: Some(ref pos), ref err } => write!(\n                f,\n                \"CSV parse error: record {} \\\n                 (line {}, field: {}, byte: {}): {}\",\n                pos.record(),\n                pos.line(),\n                err.field(),\n                pos.byte(),\n                err\n            ),\n            ErrorKind::UnequalLengths { pos: None, expected_len, len } => {\n                write!(\n                    f,\n                    \"CSV error: \\\n                     found record with {} fields, but the previous record \\\n                     has {} fields\",\n                    len, expected_len\n                )\n            }\n            ErrorKind::UnequalLengths {\n                pos: Some(ref pos),\n                expected_len,\n                len,\n            } => write!(\n                f,\n                \"CSV error: record {} (line: {}, byte: {}): \\\n                 found record with {} fields, but the previous record \\\n                 has {} fields\",\n                pos.record(),\n                pos.line(),\n                pos.byte(),\n                len,\n                expected_len\n            ),\n            ErrorKind::Seek => write!(\n                f,\n                \"CSV error: cannot access headers of CSV data \\\n                 when the parser was seeked before the first record \\\n                 could be read\"\n            ),\n            ErrorKind::Serialize(ref err) => {\n                write!(f, \"CSV write error: {}\", err)\n            }\n            ErrorKind::Deserialize { pos: None, ref err } => {\n                write!(f, \"CSV deserialize error: {}\", err)\n            }\n            ErrorKind::Deserialize { pos: Some(ref pos), ref err } => write!(\n                f,\n                \"CSV deserialize error: record {} \\\n                 (line: {}, byte: {}): {}\",\n                pos.record(),\n                pos.line(),\n                pos.byte(),\n                err\n            ),\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::FromUtf8Error as std::error::Error>::source":["fn source(&self) -> Option<&(dyn StdError + 'static)>{\n        Some(&self.err)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::FromUtf8Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.err.fmt(f)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::IntoInnerError<W> as std::error::Error>::source":["fn source(&self) -> Option<&(dyn StdError + 'static)>{\n        self.err.source()\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::IntoInnerError<W> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.err.fmt(f)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::IntoInnerError<W> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.err.fmt(f)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Utf8Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(\n            f,\n            \"invalid utf-8: invalid UTF-8 in field {} near byte index {}\",\n            self.field, self.valid_up_to\n        )\n    }","Real(LocalPath(\"src/error.rs\"))"],"<reader::ByteRecordsIntoIter<R> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Result<ByteRecord>>{\n        match self.rdr.read_byte_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(true) => Some(Ok(self.rec.clone())),\n            Ok(false) => None,\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"<reader::ByteRecordsIter<'r, R> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Result<ByteRecord>>{\n        match self.rdr.read_byte_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(true) => Some(Ok(self.rec.clone())),\n            Ok(false) => None,\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"<reader::DeserializeRecordsIntoIter<R, D> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Result<D>>{\n        match self.rdr.read_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(false) => None,\n            Ok(true) => Some(self.rec.deserialize(self.headers.as_ref())),\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"<reader::DeserializeRecordsIter<'r, R, D> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Result<D>>{\n        match self.rdr.read_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(false) => None,\n            Ok(true) => Some(self.rec.deserialize(self.headers.as_ref())),\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"<reader::ReaderBuilder as std::default::Default>::default":["fn default() -> ReaderBuilder{\n        ReaderBuilder {\n            capacity: 8 * (1 << 10),\n            flexible: false,\n            has_headers: true,\n            trim: Trim::default(),\n            builder: Box::new(CoreReaderBuilder::default()),\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"<reader::StringRecordsIntoIter<R> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Result<StringRecord>>{\n        match self.rdr.read_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(true) => Some(Ok(self.rec.clone())),\n            Ok(false) => None,\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"<reader::StringRecordsIter<'r, R> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Result<StringRecord>>{\n        match self.rdr.read_record(&mut self.rec) {\n            Err(err) => Some(Err(err)),\n            Ok(true) => Some(Ok(self.rec.clone())),\n            Ok(false) => None,\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"<string_record::StringRecord as std::cmp::PartialEq<[T]>>::eq":["fn eq(&self, other: &[T]) -> bool{\n        self.0.iter_eq(other)\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["fn eq(&self, other: &Vec<T>) -> bool{\n        self.0.iter_eq(other)\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecord as std::cmp::PartialEq>::eq":["fn eq(&self, other: &StringRecord) -> bool{\n        self.0.iter_eq(&other.0)\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecord as std::convert::From<&'a [T]>>::from":["#[inline]\nfn from(xs: &'a [T]) -> StringRecord{\n        StringRecord::from_iter(xs)\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecord as std::convert::From<std::vec::Vec<T>>>::from":["#[inline]\nfn from(xs: Vec<T>) -> StringRecord{\n        StringRecord::from_iter(xs.into_iter())\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecord as std::default::Default>::default":["#[inline]\nfn default() -> StringRecord{\n        StringRecord::new()\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecord as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let fields: Vec<&str> = self.iter().collect();\n        write!(f, \"StringRecord({:?})\", fields)\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecord as std::iter::Extend<T>>::extend":["#[inline]\nfn extend<I: IntoIterator<Item = T>>(&mut self, iter: I){\n        for x in iter {\n            self.push_field(x.as_ref());\n        }\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecord as std::iter::FromIterator<T>>::from_iter":["#[inline]\nfn from_iter<I: IntoIterator<Item = T>>(iter: I) -> StringRecord{\n        let mut record = StringRecord::new();\n        record.extend(iter);\n        record\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecord as std::ops::Index<usize>>::index":["#[inline]\nfn index(&self, i: usize) -> &str{\n        self.get(i).unwrap()\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecordIter<'r> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<&'r str>{\n        self.0.next_back().map(|bytes| {\n            debug_assert!(str::from_utf8(bytes).is_ok());\n            // See StringRecord::get for safety argument.\n            unsafe { str::from_utf8_unchecked(bytes) }\n        })\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecordIter<'r> as std::iter::Iterator>::count":["#[inline]\nfn count(self) -> usize{\n        self.0.len()\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecordIter<'r> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'r str>{\n        self.0.next().map(|bytes| {\n            debug_assert!(str::from_utf8(bytes).is_ok());\n            // See StringRecord::get for safety argument.\n            unsafe { str::from_utf8_unchecked(bytes) }\n        })\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<string_record::StringRecordIter<'r> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.0.size_hint()\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"<writer::Writer<W> as std::ops::Drop>::drop":["fn drop(&mut self){\n        if self.wtr.is_some() && !self.state.panicked {\n            let _ = self.flush();\n        }\n    }","Real(LocalPath(\"src/writer.rs\"))"],"<writer::WriterBuilder as std::default::Default>::default":["fn default() -> WriterBuilder{\n        WriterBuilder {\n            builder: CoreWriterBuilder::default(),\n            capacity: 8 * (1 << 10),\n            flexible: false,\n            has_headers: true,\n        }\n    }","Real(LocalPath(\"src/writer.rs\"))"],"QuoteStyle":["/// The quoting style to use when writing CSV data.\npub enum QuoteStyle {\n    /// This puts quotes around every field. Always.\n    Always,\n    /// This puts quotes around fields only when necessary.\n    ///\n    /// They are necessary when fields contain a quote, delimiter or record\n    /// terminator. Quotes are also necessary when writing an empty record\n    /// (which is indistinguishable from a record with one empty field).\n    ///\n    /// This is the default.\n    Necessary,\n    /// This puts quotes around all fields that are non-numeric. Namely, when\n    /// writing a field that does not parse as a valid float or integer, then\n    /// quotes will be used even if they aren't strictly necessary.\n    NonNumeric,\n    /// This *never* writes quotes, even if it would produce invalid CSV data.\n    Never,\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}","Real(LocalPath(\"src/lib.rs\"))"],"QuoteStyle::to_core":["fn to_core(self) -> csv_core::QuoteStyle{\n        match self {\n            QuoteStyle::Always => csv_core::QuoteStyle::Always,\n            QuoteStyle::Necessary => csv_core::QuoteStyle::Necessary,\n            QuoteStyle::NonNumeric => csv_core::QuoteStyle::NonNumeric,\n            QuoteStyle::Never => csv_core::QuoteStyle::Never,\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Terminator":["/// A record terminator.\n///\n/// Use this to specify the record terminator while parsing CSV. The default is\n/// CRLF, which treats `\\r`, `\\n` or `\\r\\n` as a single record terminator.\npub enum Terminator {\n    /// Parses `\\r`, `\\n` or `\\r\\n` as a single record terminator.\n    CRLF,\n    /// Parses the byte given as a record terminator.\n    Any(u8),\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Terminator::to_core":["/// Convert this to the csv_core type of the same name.\nfn to_core(self) -> csv_core::Terminator{\n        match self {\n            Terminator::CRLF => csv_core::Terminator::CRLF,\n            Terminator::Any(b) => csv_core::Terminator::Any(b),\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Trim":["/// The whitespace preservation behaviour when reading CSV data.\npub enum Trim {\n    /// Preserves fields and headers. This is the default.\n    None,\n    /// Trim whitespace from headers.\n    Headers,\n    /// Trim whitespace from fields, but not headers.\n    Fields,\n    /// Trim whitespace from fields and headers.\n    All,\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Trim::should_trim_fields":["fn should_trim_fields(&self) -> bool{\n        self == &Trim::Fields || self == &Trim::All\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Trim::should_trim_headers":["fn should_trim_headers(&self) -> bool{\n        self == &Trim::Headers || self == &Trim::All\n    }","Real(LocalPath(\"src/lib.rs\"))"],"byte_record::Bounds":["/// The bounds of fields in a single record.\nstruct Bounds {\n    /// The ending index of each field.\n    ends: Vec<usize>,\n    /// The number of fields in this record.\n    ///\n    /// Technically, we could drop this field and maintain an invariant that\n    /// `ends.len()` is always the number of fields, but doing that efficiently\n    /// requires attention to safety. We play it safe at essentially no cost.\n    len: usize,\n}","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Bounds::add":["/// Add a new field with the given ending position.\n#[inline]\nfn add(&mut self, pos: usize){\n        if self.len >= self.ends.len() {\n            self.expand();\n        }\n        self.ends[self.len] = pos;\n        self.len += 1;\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Bounds::end":["/// Return the last position of the last field.\n///\n/// If there are no fields, this returns `0`.\n#[inline]\nfn end(&self) -> usize{\n        self.ends().last().map(|&i| i).unwrap_or(0)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Bounds::ends":["/// Returns a slice of ending positions of all fields.\n#[inline]\nfn ends(&self) -> &[usize]{\n        &self.ends[..self.len]\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Bounds::expand":["/// Expand the capacity for storing field ending positions.\n#[inline]\nfn expand(&mut self){\n        let new_len = self.ends.len().checked_mul(2).unwrap();\n        self.ends.resize(cmp::max(4, new_len), 0);\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Bounds::get":["/// Returns the bounds of field `i`.\n#[inline]\nfn get(&self, i: usize) -> Option<Range<usize>>{\n        if i >= self.len {\n            return None;\n        }\n        let end = match self.ends.get(i) {\n            None => return None,\n            Some(&end) => end,\n        };\n        let start = match i.checked_sub(1).and_then(|i| self.ends.get(i)) {\n            None => 0,\n            Some(&start) => start,\n        };\n        Some(ops::Range { start: start, end: end })\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Bounds::len":["/// Returns the number of fields in these bounds.\n#[inline]\nfn len(&self) -> usize{\n        self.len\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Bounds::with_capacity":["/// Create a new set of bounds with the given capacity for storing the\n/// ends of fields.\n#[inline]\nfn with_capacity(capacity: usize) -> Bounds{\n        Bounds { ends: vec![0; capacity], len: 0 }\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord":["/// A single CSV record stored as raw bytes.\n///\n/// A byte record permits reading or writing CSV rows that are not UTF-8.\n/// In general, you should prefer using a\n/// [`StringRecord`](struct.StringRecord.html)\n/// since it is more ergonomic, but a `ByteRecord` is provided in case you need\n/// it.\n///\n/// If you are using the Serde (de)serialization APIs, then you probably never\n/// need to interact with a `ByteRecord` or a `StringRecord`. However, there\n/// are some circumstances in which you might need to use a raw record type\n/// while still using Serde. For example, if you need to deserialize possibly\n/// invalid UTF-8 fields, then you'll need to first read your record into a\n/// `ByteRecord`, and then use `ByteRecord::deserialize` to run Serde. Another\n/// reason for using the raw record deserialization APIs is if you're using\n/// Serde to read into borrowed data such as a `&'a str` or a `&'a [u8]`.\n///\n/// Two `ByteRecord`s are compared on the basis of their field data. Any\n/// position information associated with the records is ignored.\npub struct ByteRecord(Box<ByteRecordInner>);","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::as_parts":["/// Retrieve the underlying parts of a byte record.\n#[inline]\npub(crate) fn as_parts(&mut self) -> (&mut Vec<u8>, &mut Vec<usize>){\n        let inner = &mut *self.0;\n        (&mut inner.fields, &mut inner.bounds.ends)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::as_slice":["/// Return the entire row as a single byte slice. The slice returned stores\n/// all fields contiguously. The boundaries of each field can be determined\n/// via the `range` method.\n///\n/// # Example\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// let record = ByteRecord::from(vec![\"foo\", \"quux\", \"z\"]);\n/// assert_eq!(record.as_slice(), &b\"fooquuxz\"[..]);\n/// ```\n#[inline]\npub fn as_slice(&self) -> &[u8]{\n        &self.0.fields[..self.0.bounds.end()]\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::clear":["/// Clear this record so that it has zero fields.\n///\n/// This is equivalent to calling `truncate(0)`.\n///\n/// Note that it is not necessary to clear the record to reuse it with\n/// the CSV reader.\n///\n/// # Example\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// let mut record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// assert_eq!(record.len(), 3);\n/// record.clear();\n/// assert_eq!(record.len(), 0);\n/// ```\n#[inline]\npub fn clear(&mut self){\n        self.truncate(0);\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::deserialize":["/// Deserialize this record.\n///\n/// The `D` type parameter refers to the type that this record should be\n/// deserialized into. The `'de` lifetime refers to the lifetime of the\n/// `ByteRecord`. The `'de` lifetime permits deserializing into structs\n/// that borrow field data from this record.\n///\n/// An optional `headers` parameter permits deserializing into a struct\n/// based on its field names (corresponding to header values) rather than\n/// the order in which the fields are defined.\n///\n/// # Example: without headers\n///\n/// This shows how to deserialize a single row into a struct based on the\n/// order in which fields occur. This example also shows how to borrow\n/// fields from the `ByteRecord`, which results in zero allocation\n/// deserialization.\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::ByteRecord;\n/// use serde::Deserialize;\n///\n/// #[derive(Deserialize)]\n/// struct Row<'a> {\n///     city: &'a str,\n///     country: &'a str,\n///     population: u64,\n/// }\n///\n/// # fn main() { example().unwrap() }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let record = ByteRecord::from(vec![\n///         \"Boston\", \"United States\", \"4628910\",\n///     ]);\n///\n///     let row: Row = record.deserialize(None)?;\n///     assert_eq!(row.city, \"Boston\");\n///     assert_eq!(row.country, \"United States\");\n///     assert_eq!(row.population, 4628910);\n///     Ok(())\n/// }\n/// ```\n///\n/// # Example: with headers\n///\n/// This example is like the previous one, but shows how to deserialize\n/// into a struct based on the struct's field names. For this to work,\n/// you must provide a header row.\n///\n/// This example also shows that you can deserialize into owned data\n/// types (e.g., `String`) instead of borrowed data types (e.g., `&str`).\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::ByteRecord;\n/// use serde::Deserialize;\n///\n/// #[derive(Deserialize)]\n/// struct Row {\n///     city: String,\n///     country: String,\n///     population: u64,\n/// }\n///\n/// # fn main() { example().unwrap() }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     // Notice that the fields are not in the same order\n///     // as the fields in the struct!\n///     let header = ByteRecord::from(vec![\n///         \"country\", \"city\", \"population\",\n///     ]);\n///     let record = ByteRecord::from(vec![\n///         \"United States\", \"Boston\", \"4628910\",\n///     ]);\n///\n///     let row: Row = record.deserialize(Some(&header))?;\n///     assert_eq!(row.city, \"Boston\");\n///     assert_eq!(row.country, \"United States\");\n///     assert_eq!(row.population, 4628910);\n///     Ok(())\n/// }\n/// ```\npub fn deserialize<'de, D: Deserialize<'de>>(\n        &'de self,\n        headers: Option<&'de ByteRecord>,\n    ) -> Result<D>{\n        deserialize_byte_record(self, headers)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::expand_ends":["/// Expand the capacity for storing field ending positions.\n#[inline]\npub(crate) fn expand_ends(&mut self){\n        self.0.bounds.expand();\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::expand_fields":["/// Expand the capacity for storing fields.\n#[inline]\npub(crate) fn expand_fields(&mut self){\n        let new_len = self.0.fields.len().checked_mul(2).unwrap();\n        self.0.fields.resize(cmp::max(4, new_len), 0);\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::get":["/// Return the field at index `i`.\n///\n/// If no field at index `i` exists, then this returns `None`.\n///\n/// # Example\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// let record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// assert_eq!(record.get(1), Some(&b\"b\"[..]));\n/// assert_eq!(record.get(3), None);\n/// ```\n#[inline]\npub fn get(&self, i: usize) -> Option<&[u8]>{\n        self.0.bounds.get(i).map(|range| &self.0.fields[range])\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::is_empty":["/// Returns true if and only if this record is empty.\n///\n/// # Example\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// assert!(ByteRecord::new().is_empty());\n/// ```\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::iter":["/// Returns an iterator over all fields in this record.\n///\n/// # Example\n///\n/// This example shows how to iterate over each field in a `ByteRecord`.\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// let record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// for field in record.iter() {\n///     assert!(field == b\"a\" || field == b\"b\" || field == b\"c\");\n/// }\n/// ```\n#[inline]\npub fn iter(&self) -> ByteRecordIter{\n        self.into_iter()\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::iter_eq":["/// Compare the given byte record with the iterator of fields for equality.\npub(crate) fn iter_eq<I, T>(&self, other: I) -> bool\n    where\n        I: IntoIterator<Item = T>,\n        T: AsRef<[u8]>,{\n        let mut it_record = self.iter();\n        let mut it_other = other.into_iter();\n        loop {\n            match (it_record.next(), it_other.next()) {\n                (None, None) => return true,\n                (None, Some(_)) | (Some(_), None) => return false,\n                (Some(x), Some(y)) => {\n                    if x != y.as_ref() {\n                        return false;\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::len":["/// Returns the number of fields in this record.\n///\n/// # Example\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// let record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// assert_eq!(record.len(), 3);\n/// ```\n#[inline]\npub fn len(&self) -> usize{\n        self.0.bounds.len()\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::new":["/// Create a new empty `ByteRecord`.\n///\n/// Note that you may find the `ByteRecord::from` constructor more\n/// convenient, which is provided by an impl on the `From` trait.\n///\n/// # Example: create an empty record\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// let record = ByteRecord::new();\n/// assert_eq!(record.len(), 0);\n/// ```\n///\n/// # Example: initialize a record from a `Vec`\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// let record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// assert_eq!(record.len(), 3);\n/// ```\n#[inline]\npub fn new() -> ByteRecord{\n        ByteRecord::with_capacity(0, 0)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::position":["/// Return the position of this record, if available.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::{ByteRecord, ReaderBuilder};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut record = ByteRecord::new();\n///     let mut rdr = ReaderBuilder::new()\n///         .has_headers(false)\n///         .from_reader(\"a,b,c\\nx,y,z\".as_bytes());\n///\n///     assert!(rdr.read_byte_record(&mut record)?);\n///     {\n///         let pos = record.position().expect(\"a record position\");\n///         assert_eq!(pos.byte(), 0);\n///         assert_eq!(pos.line(), 1);\n///         assert_eq!(pos.record(), 0);\n///     }\n///\n///     assert!(rdr.read_byte_record(&mut record)?);\n///     {\n///         let pos = record.position().expect(\"a record position\");\n///         assert_eq!(pos.byte(), 6);\n///         assert_eq!(pos.line(), 2);\n///         assert_eq!(pos.record(), 1);\n///     }\n///\n///     // Finish the CSV reader for good measure.\n///     assert!(!rdr.read_byte_record(&mut record)?);\n///     Ok(())\n/// }\n/// ```\n#[inline]\npub fn position(&self) -> Option<&Position>{\n        self.0.pos.as_ref()\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::push_field":["/// Add a new field to this record.\n///\n/// # Example\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// let mut record = ByteRecord::new();\n/// record.push_field(b\"foo\");\n/// assert_eq!(&record[0], b\"foo\");\n/// ```\n#[inline]\npub fn push_field(&mut self, field: &[u8]){\n        let (s, e) = (self.0.bounds.end(), self.0.bounds.end() + field.len());\n        while e > self.0.fields.len() {\n            self.expand_fields();\n        }\n        self.0.fields[s..e].copy_from_slice(field);\n        self.0.bounds.add(e);\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::range":["/// Return the start and end position of a field in this record.\n///\n/// If no such field exists at the given index, then return `None`.\n///\n/// The range returned can be used with the slice returned by `as_slice`.\n///\n/// # Example\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// let record = ByteRecord::from(vec![\"foo\", \"quux\", \"z\"]);\n/// let range = record.range(1).expect(\"a record range\");\n/// assert_eq!(&record.as_slice()[range], &b\"quux\"[..]);\n/// ```\n#[inline]\npub fn range(&self, i: usize) -> Option<Range<usize>>{\n        self.0.bounds.get(i)\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::set_len":["/// Set the number of fields in the given record record.\n#[inline]\npub(crate) fn set_len(&mut self, len: usize){\n        self.0.bounds.len = len;\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::set_position":["/// Set the position of this record.\n///\n/// # Example\n///\n/// ```\n/// use csv::{ByteRecord, Position};\n///\n/// let mut record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// let mut pos = Position::new();\n/// pos.set_byte(100);\n/// pos.set_line(4);\n/// pos.set_record(2);\n///\n/// record.set_position(Some(pos.clone()));\n/// assert_eq!(record.position(), Some(&pos));\n/// ```\n#[inline]\npub fn set_position(&mut self, pos: Option<Position>){\n        self.0.pos = pos;\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::trim":["/// Trim the fields of this record so that leading and trailing whitespace\n/// is removed.\n///\n/// This method uses the ASCII definition of whitespace. That is, only\n/// bytes in the class `[\\t\\n\\v\\f\\r ]` are trimmed.\n///\n/// # Example\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// let mut record = ByteRecord::from(vec![\n///     \"  \", \"\\tfoo\", \"bar  \", \"b a z\",\n/// ]);\n/// record.trim();\n/// assert_eq!(record, vec![\"\", \"foo\", \"bar\", \"b a z\"]);\n/// ```\npub fn trim(&mut self){\n        let length = self.len();\n        if length == 0 {\n            return;\n        }\n        // TODO: We could likely do this in place, but for now, we allocate.\n        let mut trimmed =\n            ByteRecord::with_capacity(self.as_slice().len(), self.len());\n        trimmed.set_position(self.position().cloned());\n        for field in &*self {\n            trimmed.push_field(field.trim());\n        }\n        *self = trimmed;\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::truncate":["/// Truncate this record to `n` fields.\n///\n/// If `n` is greater than the number of fields in this record, then this\n/// has no effect.\n///\n/// # Example\n///\n/// ```\n/// use csv::ByteRecord;\n///\n/// let mut record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// assert_eq!(record.len(), 3);\n/// record.truncate(1);\n/// assert_eq!(record.len(), 1);\n/// assert_eq!(record, vec![\"a\"]);\n/// ```\n#[inline]\npub fn truncate(&mut self, n: usize){\n        if n <= self.len() {\n            self.0.bounds.len = n;\n        }\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::validate":["/// Validate the given record as UTF-8.\n///\n/// If it's not UTF-8, return an error.\n#[inline]\npub(crate) fn validate(&self) -> result::Result<(), Utf8Error>{\n        // If the entire buffer is ASCII, then we have nothing to fear.\n        if self.0.fields[..self.0.bounds.end()].is_ascii() {\n            return Ok(());\n        }\n        // Otherwise, we must check each field individually to ensure that\n        // it's valid UTF-8.\n        for (i, field) in self.iter().enumerate() {\n            if let Err(err) = field.to_str() {\n                return Err(new_utf8_error(i, err.valid_up_to()));\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecord::with_capacity":["/// Create a new empty `ByteRecord` with the given capacity settings.\n///\n/// `buffer` refers to the capacity of the buffer used to store the\n/// actual row contents. `fields` refers to the number of fields one\n/// might expect to store.\n#[inline]\npub fn with_capacity(buffer: usize, fields: usize) -> ByteRecord{\n        ByteRecord(Box::new(ByteRecordInner {\n            pos: None,\n            fields: vec![0; buffer],\n            bounds: Bounds::with_capacity(fields),\n        }))\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecordInner":["/// The inner portion of a byte record.\n///\n/// We use this memory layout so that moving a `ByteRecord` only requires\n/// moving a single pointer. The optimization is dubious at best, but does\n/// seem to result in slightly better numbers in microbenchmarks. Methinks this\n/// may heavily depend on the underlying allocator.\nstruct ByteRecordInner {\n    /// The position of this byte record.\n    pos: Option<Position>,\n    /// All fields in this record, stored contiguously.\n    fields: Vec<u8>,\n    /// The number of and location of each field in this record.\n    bounds: Bounds,\n}","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::ByteRecordIter":["/// A double-ended iterator over the fields in a byte record.\n///\n/// The `'r` lifetime variable refers to the lifetime of the `ByteRecord` that\n/// is being iterated over.\npub struct ByteRecordIter<'r> {\n    /// The record we are iterating over.\n    r: &'r ByteRecord,\n    /// The starting index of the previous field. (For reverse iteration.)\n    last_start: usize,\n    /// The ending index of the previous field. (For forward iteration.)\n    last_end: usize,\n    /// The index of forward iteration.\n    i_forward: usize,\n    /// The index of reverse iteration.\n    i_reverse: usize,\n}","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Position":["/// A position in CSV data.\n///\n/// A position is used to report errors in CSV data. All positions include the\n/// byte offset, line number and record index at which the error occurred.\n///\n/// Byte offsets and record indices start at `0`. Line numbers start at `1`.\n///\n/// A CSV reader will automatically assign the position of each record.\npub struct Position {\n    byte: u64,\n    line: u64,\n    record: u64,\n}","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Position::byte":["/// The byte offset, starting at `0`, of this position.\n#[inline]\npub fn byte(&self) -> u64{\n        self.byte\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Position::line":["/// The line number, starting at `1`, of this position.\n#[inline]\npub fn line(&self) -> u64{\n        self.line\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Position::new":["/// Returns a new position initialized to the start value.\n#[inline]\npub fn new() -> Position{\n        Position { byte: 0, line: 1, record: 0 }\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Position::record":["/// The record index, starting with the first record at `0`.\n#[inline]\npub fn record(&self) -> u64{\n        self.record\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Position::set_byte":["/// Set the byte offset of this position.\n#[inline]\npub fn set_byte(&mut self, byte: u64) -> &mut Position{\n        self.byte = byte;\n        self\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Position::set_line":["/// Set the line number of this position.\n///\n/// If the line number is less than `1`, then this method panics.\n#[inline]\npub fn set_line(&mut self, line: u64) -> &mut Position{\n        assert!(line > 0);\n        self.line = line;\n        self\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"byte_record::Position::set_record":["/// Set the record index of this position.\n#[inline]\npub fn set_record(&mut self, record: u64) -> &mut Position{\n        self.record = record;\n        self\n    }","Real(LocalPath(\"src/byte_record.rs\"))"],"deserializer::DeByteRecord":["struct DeByteRecord<'r> {\n    it: iter::Peekable<ByteRecordIter<'r>>,\n    headers: Option<ByteRecordIter<'r>>,\n    field: u64,\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::DeRecord":["/// An over-engineered internal trait that permits writing a single Serde\n/// deserializer that works on both ByteRecord and StringRecord.\n///\n/// We *could* implement a single deserializer on `ByteRecord` and simply\n/// convert `StringRecord`s to `ByteRecord`s, but then the implementation\n/// would be required to redo UTF-8 validation checks in certain places.\n///\n/// How does this work? We create a new `DeRecordWrap` type that wraps\n/// either a `StringRecord` or a `ByteRecord`. We then implement\n/// `DeRecord` for `DeRecordWrap<ByteRecord>` and `DeRecordWrap<StringRecord>`.\n/// Finally, we impl `serde::Deserialize` for `DeRecordWrap<T>` where\n/// `T: DeRecord`. That is, the `DeRecord` type corresponds to the differences\n/// between deserializing into a `ByteRecord` and deserializing into a\n/// `StringRecord`.\n///\n/// The lifetime `'r` refers to the lifetime of the underlying record.\ntrait DeRecord<'r> {\n    /// Returns true if and only if this deserialize has access to headers.\n    fn has_headers(&self) -> bool;\n\n    /// Extracts the next string header value from the underlying record.\n    fn next_header(&mut self) -> Result<Option<&'r str>, DeserializeError>;\n\n    /// Extracts the next raw byte header value from the underlying record.\n    fn next_header_bytes(\n        &mut self,\n    ) -> Result<Option<&'r [u8]>, DeserializeError>;\n\n    /// Extracts the next string field from the underlying record.\n    fn next_field(&mut self) -> Result<&'r str, DeserializeError>;\n\n    /// Extracts the next raw byte field from the underlying record.\n    fn next_field_bytes(&mut self) -> Result<&'r [u8], DeserializeError>;\n\n    /// Peeks at the next field from the underlying record.\n    fn peek_field(&mut self) -> Option<&'r [u8]>;\n\n    /// Returns an error corresponding to the most recently extracted field.\n    fn error(&self, kind: DeserializeErrorKind) -> DeserializeError;\n\n    /// Infer the type of the next field and deserialize it.\n    fn infer_deserialize<'de, V: Visitor<'de>>(\n        &mut self,\n        visitor: V,\n    ) -> Result<V::Value, DeserializeError>;\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::DeRecordWrap":["struct DeRecordWrap<T>(T);","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::DeStringRecord":["struct DeStringRecord<'r> {\n    it: iter::Peekable<StringRecordIter<'r>>,\n    headers: Option<StringRecordIter<'r>>,\n    field: u64,\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::DeserializeError":["/// An Serde deserialization error.\npub struct DeserializeError {\n    field: Option<u64>,\n    kind: DeserializeErrorKind,\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::DeserializeError::field":["/// Return the field index (starting at 0) of this error, if available.\npub fn field(&self) -> Option<u64>{\n        self.field\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::DeserializeError::kind":["/// Return the underlying error kind.\npub fn kind(&self) -> &DeserializeErrorKind{\n        &self.kind\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::DeserializeErrorKind":["/// The type of a Serde deserialization error.\npub enum DeserializeErrorKind {\n    /// A generic Serde deserialization error.\n    Message(String),\n    /// A generic Serde unsupported error.\n    Unsupported(String),\n    /// This error occurs when a Rust type expects to decode another field\n    /// from a row, but no more fields exist.\n    UnexpectedEndOfRow,\n    /// This error occurs when UTF-8 validation on a field fails. UTF-8\n    /// validation is only performed when the Rust type requires it (e.g.,\n    /// a `String` or `&str` type).\n    InvalidUtf8(str::Utf8Error),\n    /// This error occurs when a boolean value fails to parse.\n    ParseBool(str::ParseBoolError),\n    /// This error occurs when an integer value fails to parse.\n    ParseInt(num::ParseIntError),\n    /// This error occurs when a float value fails to parse.\n    ParseFloat(num::ParseFloatError),\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::DeserializeErrorKind::description":["#[allow(deprecated)]\nfn description(&self) -> &str{\n        use self::DeserializeErrorKind::*;\n\n        match *self {\n            Message(_) => \"deserialization error\",\n            Unsupported(_) => \"unsupported deserializer method\",\n            UnexpectedEndOfRow => \"expected field, but got end of row\",\n            InvalidUtf8(ref err) => err.description(),\n            ParseBool(ref err) => err.description(),\n            ParseInt(ref err) => err.description(),\n            ParseFloat(ref err) => err.description(),\n        }\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::deserialize_byte_record":["pub fn deserialize_byte_record<'de, D: Deserialize<'de>>(\n    record: &'de ByteRecord,\n    headers: Option<&'de ByteRecord>,\n) -> Result<D, Error>{\n    let mut deser = DeRecordWrap(DeByteRecord {\n        it: record.iter().peekable(),\n        headers: headers.map(|r| r.iter()),\n        field: 0,\n    });\n    D::deserialize(&mut deser).map_err(|err| {\n        Error::new(ErrorKind::Deserialize {\n            pos: record.position().map(Clone::clone),\n            err: err,\n        })\n    })\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::deserialize_string_record":["pub fn deserialize_string_record<'de, D: Deserialize<'de>>(\n    record: &'de StringRecord,\n    headers: Option<&'de StringRecord>,\n) -> Result<D, Error>{\n    let mut deser = DeRecordWrap(DeStringRecord {\n        it: record.iter().peekable(),\n        headers: headers.map(|r| r.iter()),\n        field: 0,\n    });\n    D::deserialize(&mut deser).map_err(|err| {\n        Error::new(ErrorKind::Deserialize {\n            pos: record.position().map(Clone::clone),\n            err: err,\n        })\n    })\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::try_float":["fn try_float(s: &str) -> Option<f64>{\n    s.parse().ok()\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::try_float_bytes":["fn try_float_bytes(s: &[u8]) -> Option<f64>{\n    str::from_utf8(s).ok().and_then(|s| s.parse().ok())\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::try_negative_integer128":["fn try_negative_integer128(s: &str) -> Option<i128>{\n        s.parse().ok()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::try_negative_integer128_bytes":["fn try_negative_integer128_bytes(s: &[u8]) -> Option<i128>{\n        str::from_utf8(s).ok().and_then(|s| s.parse().ok())\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::try_negative_integer64":["fn try_negative_integer64(s: &str) -> Option<i64>{\n    s.parse().ok()\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::try_negative_integer64_bytes":["fn try_negative_integer64_bytes(s: &[u8]) -> Option<i64>{\n    str::from_utf8(s).ok().and_then(|s| s.parse().ok())\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::try_positive_integer128":["fn try_positive_integer128(s: &str) -> Option<u128>{\n        s.parse().ok()\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::try_positive_integer128_bytes":["fn try_positive_integer128_bytes(s: &[u8]) -> Option<u128>{\n        str::from_utf8(s).ok().and_then(|s| s.parse().ok())\n    }","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::try_positive_integer64":["fn try_positive_integer64(s: &str) -> Option<u64>{\n    s.parse().ok()\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"deserializer::try_positive_integer64_bytes":["fn try_positive_integer64_bytes(s: &[u8]) -> Option<u64>{\n    str::from_utf8(s).ok().and_then(|s| s.parse().ok())\n}","Real(LocalPath(\"src/deserializer.rs\"))"],"error::<impl std::convert::From<error::Error> for std::io::Error>::from":["fn from(err: Error) -> io::Error{\n        io::Error::new(io::ErrorKind::Other, err)\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error":["/// An error that can occur when processing CSV data.\n///\n/// This error can happen when writing or reading CSV data.\n///\n/// There are some important scenarios where an error is impossible to occur.\n/// For example, if a CSV reader is used on an in-memory buffer with the\n/// `flexible` option enabled and one is reading records as raw byte strings,\n/// then no error can occur.\npub struct Error(Box<ErrorKind>);","Real(LocalPath(\"src/error.rs\"))"],"error::Error::into_kind":["/// Unwrap this error into its underlying type.\npub fn into_kind(self) -> ErrorKind{\n        *self.0\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::is_io_error":["/// Returns true if this is an I/O error.\n///\n/// If this is true, the underlying `ErrorKind` is guaranteed to be\n/// `ErrorKind::Io`.\npub fn is_io_error(&self) -> bool{\n        match *self.0 {\n            ErrorKind::Io(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::kind":["/// Return the specific type of this error.\npub fn kind(&self) -> &ErrorKind{\n        &self.0\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::new":["/// A crate private constructor for `Error`.\npub(crate) fn new(kind: ErrorKind) -> Error{\n        Error(Box::new(kind))\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::position":["/// Return the position for this error, if one exists.\n///\n/// This is a convenience function that permits callers to easily access\n/// the position on an error without doing case analysis on `ErrorKind`.\npub fn position(&self) -> Option<&Position>{\n        self.0.position()\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::ErrorKind":["/// The specific type of an error.\npub enum ErrorKind {\n    /// An I/O error that occurred while reading CSV data.\n    Io(io::Error),\n    /// A UTF-8 decoding error that occured while reading CSV data into Rust\n    /// `String`s.\n    Utf8 {\n        /// The position of the record in which this error occurred, if\n        /// available.\n        pos: Option<Position>,\n        /// The corresponding UTF-8 error.\n        err: Utf8Error,\n    },\n    /// This error occurs when two records with an unequal number of fields\n    /// are found. This error only occurs when the `flexible` option in a\n    /// CSV reader/writer is disabled.\n    UnequalLengths {\n        /// The position of the first record with an unequal number of fields\n        /// to the previous record, if available.\n        pos: Option<Position>,\n        /// The expected number of fields in a record. This is the number of\n        /// fields in the record read prior to the record indicated by\n        /// `pos`.\n        expected_len: u64,\n        /// The number of fields in the bad record.\n        len: u64,\n    },\n    /// This error occurs when either the `byte_headers` or `headers` methods\n    /// are called on a CSV reader that was asked to `seek` before it parsed\n    /// the first record.\n    Seek,\n    /// An error of this kind occurs only when using the Serde serializer.\n    Serialize(String),\n    /// An error of this kind occurs only when performing automatic\n    /// deserialization with serde.\n    Deserialize {\n        /// The position of this error, if available.\n        pos: Option<Position>,\n        /// The deserialization error.\n        err: DeserializeError,\n    },\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::ErrorKind::position":["/// Return the position for this error, if one exists.\n///\n/// This is a convenience function that permits callers to easily access\n/// the position on an error without doing case analysis on `ErrorKind`.\npub fn position(&self) -> Option<&Position>{\n        match *self {\n            ErrorKind::Utf8 { ref pos, .. } => pos.as_ref(),\n            ErrorKind::UnequalLengths { ref pos, .. } => pos.as_ref(),\n            ErrorKind::Deserialize { ref pos, .. } => pos.as_ref(),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::FromUtf8Error":["/// A UTF-8 validation error during record conversion.\n///\n/// This occurs when attempting to convert a `ByteRecord` into a\n/// `StringRecord`.\npub struct FromUtf8Error {\n    record: ByteRecord,\n    err: Utf8Error,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::FromUtf8Error::into_byte_record":["/// Access the underlying `ByteRecord` that failed UTF-8 validation.\npub fn into_byte_record(self) -> ByteRecord{\n        self.record\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::FromUtf8Error::new":["/// Create a new FromUtf8Error.\npub(crate) fn new(rec: ByteRecord, err: Utf8Error) -> FromUtf8Error{\n        FromUtf8Error { record: rec, err: err }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::FromUtf8Error::utf8_error":["/// Access the underlying UTF-8 validation error.\npub fn utf8_error(&self) -> &Utf8Error{\n        &self.err\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::IntoInnerError":["/// `IntoInnerError` occurs when consuming a `Writer` fails.\n///\n/// Consuming the `Writer` causes a flush to happen. If the flush fails, then\n/// this error is returned, which contains both the original `Writer` and\n/// the error that occurred.\n///\n/// The type parameter `W` is the unconsumed writer.\npub struct IntoInnerError<W> {\n    wtr: W,\n    err: io::Error,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::IntoInnerError::<W>::error":["/// Returns the error which caused the call to `into_inner` to fail.\n///\n/// This error was returned when attempting to flush the internal buffer.\npub fn error(&self) -> &io::Error{\n        &self.err\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::IntoInnerError::<W>::into_inner":["/// Returns the underlying writer which generated the error.\n///\n/// The returned value can be used for error recovery, such as\n/// re-inspecting the buffer.\npub fn into_inner(self) -> W{\n        self.wtr\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::IntoInnerError::<W>::new":["/// Creates a new `IntoInnerError`.\n///\n/// (This is a visibility hack. It's public in this module, but not in the\n/// crate.)\npub(crate) fn new(wtr: W, err: io::Error) -> IntoInnerError<W>{\n        IntoInnerError { wtr: wtr, err: err }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Utf8Error":["/// A UTF-8 validation error.\n///\n/// This occurs when attempting to convert a `ByteRecord` into a\n/// `StringRecord`.\n///\n/// The error includes the index of the field that failed validation, and the\n/// last byte at which valid UTF-8 was verified.\npub struct Utf8Error {\n    /// The field index of a byte record in which UTF-8 validation failed.\n    field: usize,\n    /// The index into the given field up to which valid UTF-8 was verified.\n    valid_up_to: usize,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Utf8Error::field":["/// The field index of a byte record in which UTF-8 validation failed.\npub fn field(&self) -> usize{\n        self.field\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Utf8Error::valid_up_to":["/// The index into the given field up to which valid UTF-8 was verified.\npub fn valid_up_to(&self) -> usize{\n        self.valid_up_to\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::new_utf8_error":["/// Create a new UTF-8 error.\npub fn new_utf8_error(field: usize, valid_up_to: usize) -> Utf8Error{\n    Utf8Error { field: field, valid_up_to: valid_up_to }\n}","Real(LocalPath(\"src/error.rs\"))"],"invalid_option":["/// A custom Serde deserializer for possibly invalid `Option<T>` fields.\n///\n/// When deserializing CSV data, it is sometimes desirable to simply ignore\n/// fields with invalid data. For example, there might be a field that is\n/// usually a number, but will occasionally contain garbage data that causes\n/// number parsing to fail.\n///\n/// You might be inclined to use, say, `Option<i32>` for fields such at this.\n/// By default, however, `Option<i32>` will either capture *empty* fields with\n/// `None` or valid numeric fields with `Some(the_number)`. If the field is\n/// non-empty and not a valid number, then deserialization will return an error\n/// instead of using `None`.\n///\n/// This function allows you to override this default behavior. Namely, if\n/// `Option<T>` is deserialized with non-empty but invalid data, then the value\n/// will be `None` and the error will be ignored.\n///\n/// # Example\n///\n/// This example shows how to parse CSV records with numerical data, even if\n/// some numerical data is absent or invalid. Without the\n/// `serde(deserialize_with = \"...\")` annotations, this example would return\n/// an error.\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::Reader;\n/// use serde::Deserialize;\n///\n/// #[derive(Debug, Deserialize, Eq, PartialEq)]\n/// struct Row {\n///     #[serde(deserialize_with = \"csv::invalid_option\")]\n///     a: Option<i32>,\n///     #[serde(deserialize_with = \"csv::invalid_option\")]\n///     b: Option<i32>,\n///     #[serde(deserialize_with = \"csv::invalid_option\")]\n///     c: Option<i32>,\n/// }\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// a,b,c\n/// 5,\\\"\\\",xyz\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///     if let Some(result) = rdr.deserialize().next() {\n///         let record: Row = result?;\n///         assert_eq!(record, Row { a: Some(5), b: None, c: None });\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn invalid_option<'de, D, T>(de: D) -> result::Result<Option<T>, D::Error>\nwhere\n    D: Deserializer<'de>,\n    Option<T>: Deserialize<'de>,{\n    Option::<T>::deserialize(de).or_else(|_| Ok(None))\n}","Real(LocalPath(\"src/lib.rs\"))"],"reader::ByteRecordsIntoIter":["/// An owned iterator over records as raw bytes.\npub struct ByteRecordsIntoIter<R> {\n    rdr: Reader<R>,\n    rec: ByteRecord,\n}","Real(LocalPath(\"src/reader.rs\"))"],"reader::ByteRecordsIntoIter::<R>::into_reader":["/// Drop this iterator and return the underlying CSV reader.\npub fn into_reader(self) -> Reader<R>{\n        self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ByteRecordsIntoIter::<R>::new":["fn new(rdr: Reader<R>) -> ByteRecordsIntoIter<R>{\n        ByteRecordsIntoIter { rdr: rdr, rec: ByteRecord::new() }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ByteRecordsIntoIter::<R>::reader":["/// Return a reference to the underlying CSV reader.\npub fn reader(&self) -> &Reader<R>{\n        &self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ByteRecordsIntoIter::<R>::reader_mut":["/// Return a mutable reference to the underlying CSV reader.\npub fn reader_mut(&mut self) -> &mut Reader<R>{\n        &mut self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ByteRecordsIter":["/// A borrowed iterator over records as raw bytes.\n///\n/// The lifetime parameter `'r` refers to the lifetime of the underlying\n/// CSV `Reader`.\npub struct ByteRecordsIter<'r, R: 'r> {\n    rdr: &'r mut Reader<R>,\n    rec: ByteRecord,\n}","Real(LocalPath(\"src/reader.rs\"))"],"reader::ByteRecordsIter::<'r, R>::new":["fn new(rdr: &'r mut Reader<R>) -> ByteRecordsIter<'r, R>{\n        ByteRecordsIter { rdr: rdr, rec: ByteRecord::new() }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ByteRecordsIter::<'r, R>::reader":["/// Return a reference to the underlying CSV reader.\npub fn reader(&self) -> &Reader<R>{\n        &self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ByteRecordsIter::<'r, R>::reader_mut":["/// Return a mutable reference to the underlying CSV reader.\npub fn reader_mut(&mut self) -> &mut Reader<R>{\n        &mut self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::DeserializeRecordsIntoIter":["/// An owned iterator over deserialized records.\n///\n/// The type parameter `R` refers to the underlying `io::Read` type, and `D`\n/// refers to the type that this iterator will deserialize a record into.\npub struct DeserializeRecordsIntoIter<R, D> {\n    rdr: Reader<R>,\n    rec: StringRecord,\n    headers: Option<StringRecord>,\n    _priv: PhantomData<D>,\n}","Real(LocalPath(\"src/reader.rs\"))"],"reader::DeserializeRecordsIntoIter::<R, D>::into_reader":["/// Drop this iterator and return the underlying CSV reader.\npub fn into_reader(self) -> Reader<R>{\n        self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::DeserializeRecordsIntoIter::<R, D>::new":["fn new(mut rdr: Reader<R>) -> DeserializeRecordsIntoIter<R, D>{\n        let headers = if !rdr.state.has_headers {\n            None\n        } else {\n            rdr.headers().ok().map(Clone::clone)\n        };\n        DeserializeRecordsIntoIter {\n            rdr: rdr,\n            rec: StringRecord::new(),\n            headers: headers,\n            _priv: PhantomData,\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::DeserializeRecordsIntoIter::<R, D>::reader":["/// Return a reference to the underlying CSV reader.\npub fn reader(&self) -> &Reader<R>{\n        &self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::DeserializeRecordsIntoIter::<R, D>::reader_mut":["/// Return a mutable reference to the underlying CSV reader.\npub fn reader_mut(&mut self) -> &mut Reader<R>{\n        &mut self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::DeserializeRecordsIter":["/// A borrowed iterator over deserialized records.\n///\n/// The lifetime parameter `'r` refers to the lifetime of the underlying\n/// CSV `Reader`. The type parameter `R` refers to the underlying `io::Read`\n/// type, and `D` refers to the type that this iterator will deserialize a\n/// record into.\npub struct DeserializeRecordsIter<'r, R: 'r, D> {\n    rdr: &'r mut Reader<R>,\n    rec: StringRecord,\n    headers: Option<StringRecord>,\n    _priv: PhantomData<D>,\n}","Real(LocalPath(\"src/reader.rs\"))"],"reader::DeserializeRecordsIter::<'r, R, D>::new":["fn new(rdr: &'r mut Reader<R>) -> DeserializeRecordsIter<'r, R, D>{\n        let headers = if !rdr.state.has_headers {\n            None\n        } else {\n            rdr.headers().ok().map(Clone::clone)\n        };\n        DeserializeRecordsIter {\n            rdr: rdr,\n            rec: StringRecord::new(),\n            headers: headers,\n            _priv: PhantomData,\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::DeserializeRecordsIter::<'r, R, D>::reader":["/// Return a reference to the underlying CSV reader.\npub fn reader(&self) -> &Reader<R>{\n        &self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::DeserializeRecordsIter::<'r, R, D>::reader_mut":["/// Return a mutable reference to the underlying CSV reader.\npub fn reader_mut(&mut self) -> &mut Reader<R>{\n        &mut self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Headers":["/// Headers encapsulates any data associated with the headers of CSV data.\n///\n/// The headers always correspond to the first row.\nstruct Headers {\n    /// The header, as raw bytes.\n    byte_record: ByteRecord,\n    /// The header, as valid UTF-8 (or a UTF-8 error).\n    string_record: result::Result<StringRecord, Utf8Error>,\n}","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader":["/// A already configured CSV reader.\n///\n/// A CSV reader takes as input CSV data and transforms that into standard Rust\n/// values. The most flexible way to read CSV data is as a sequence of records,\n/// where a record is a sequence of fields and each field is a string. However,\n/// a reader can also deserialize CSV data into Rust types like `i64` or\n/// `(String, f64, f64, f64)` or even a custom struct automatically using\n/// Serde.\n///\n/// # Configuration\n///\n/// A CSV reader has a couple convenient constructor methods like `from_path`\n/// and `from_reader`. However, if you want to configure the CSV reader to use\n/// a different delimiter or quote character (among many other things), then\n/// you should use a [`ReaderBuilder`](struct.ReaderBuilder.html) to construct\n/// a `Reader`. For example, to change the field delimiter:\n///\n/// ```\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city;country;pop\n/// Boston;United States;4628910\n/// \";\n///     let mut rdr = ReaderBuilder::new()\n///         .delimiter(b';')\n///         .from_reader(data.as_bytes());\n///\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\n///\n/// # Error handling\n///\n/// In general, CSV *parsing* does not ever return an error. That is, there is\n/// no such thing as malformed CSV data. Instead, this reader will prioritize\n/// finding a parse over rejecting CSV data that it does not understand. This\n/// choice was inspired by other popular CSV parsers, but also because it is\n/// pragmatic. CSV data varies wildly, so even if the CSV data is malformed,\n/// it might still be possible to work with the data. In the land of CSV, there\n/// is no \"right\" or \"wrong,\" only \"right\" and \"less right.\"\n///\n/// With that said, a number of errors can occur while reading CSV data:\n///\n/// * By default, all records in CSV data must have the same number of fields.\n///   If a record is found with a different number of fields than a prior\n///   record, then an error is returned. This behavior can be disabled by\n///   enabling flexible parsing via the `flexible` method on\n///   [`ReaderBuilder`](struct.ReaderBuilder.html).\n/// * When reading CSV data from a resource (like a file), it is possible for\n///   reading from the underlying resource to fail. This will return an error.\n/// * When reading CSV data into `String` or `&str` fields (e.g., via a\n///   [`StringRecord`](struct.StringRecord.html)), UTF-8 is strictly\n///   enforced. If CSV data is invalid UTF-8, then an error is returned. If\n///   you want to read invalid UTF-8, then you should use the byte oriented\n///   APIs such as [`ByteRecord`](struct.ByteRecord.html). If you need explicit\n///   support for another encoding entirely, then you'll need to use another\n///   crate to transcode your CSV data to UTF-8 before parsing it.\n/// * When using Serde to deserialize CSV data into Rust types, it is possible\n///   for a number of additional errors to occur. For example, deserializing\n///   a field `xyz` into an `i32` field will result in an error.\n///\n/// For more details on the precise semantics of errors, see the\n/// [`Error`](enum.Error.html) type.\npub struct Reader<R> {\n    /// The underlying CSV parser.\n    ///\n    /// We explicitly put this on the heap because CoreReader embeds an entire\n    /// DFA transition table, which along with other things, tallies up to\n    /// almost 500 bytes on the stack.\n    core: Box<CoreReader>,\n    /// The underlying reader.\n    rdr: io::BufReader<R>,\n    /// Various state tracking.\n    ///\n    /// There is more state embedded in the `CoreReader`.\n    state: ReaderState,\n}","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::byte_headers":["/// Returns a reference to the first row read by this parser as raw bytes.\n///\n/// If no row has been read yet, then this will force parsing of the first\n/// row.\n///\n/// If there was a problem parsing the row then this returns an error.\n///\n/// If the underlying reader emits EOF before any data, then this returns\n/// an empty record.\n///\n/// Note that this method may be used regardless of whether `has_headers`\n/// was enabled (but it is enabled by default).\n///\n/// # Example\n///\n/// This example shows how to get the header row of CSV data. Notice that\n/// the header row does not appear as a record in the iterator!\n///\n/// ```\n/// use std::error::Error;\n/// use csv::Reader;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///\n///     // We can read the headers before iterating.\n///     {\n///         // `headers` borrows from the reader, so we put this in its\n///         // own scope. That way, the borrow ends before we try iterating\n///         // below. Alternatively, we could clone the headers.\n///         let headers = rdr.byte_headers()?;\n///         assert_eq!(headers, vec![\"city\", \"country\", \"pop\"]);\n///     }\n///\n///     if let Some(result) = rdr.byte_records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///     } else {\n///         return Err(From::from(\n///             \"expected at least one record but got none\"))\n///     }\n///\n///     // We can also read the headers after iterating.\n///     let headers = rdr.byte_headers()?;\n///     assert_eq!(headers, vec![\"city\", \"country\", \"pop\"]);\n///     Ok(())\n/// }\n/// ```\npub fn byte_headers(&mut self) -> Result<&ByteRecord>{\n        if self.state.headers.is_none() {\n            let mut record = ByteRecord::new();\n            self.read_byte_record_impl(&mut record)?;\n            self.set_headers_impl(Err(record));\n        }\n        Ok(&self.state.headers.as_ref().unwrap().byte_record)\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::byte_records":["/// Returns a borrowed iterator over all records as raw bytes.\n///\n/// Each item yielded by this iterator is a `Result<ByteRecord, Error>`.\n/// Therefore, in order to access the record, callers must handle the\n/// possibility of error (typically with `try!` or `?`).\n///\n/// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n/// default), then this does not include the first record.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::Reader;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///     let mut iter = rdr.byte_records();\n///\n///     if let Some(result) = iter.next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn byte_records(&mut self) -> ByteRecordsIter<R>{\n        ByteRecordsIter::new(self)\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::deserialize":["/// Returns a borrowed iterator over deserialized records.\n///\n/// Each item yielded by this iterator is a `Result<D, Error>`.\n/// Therefore, in order to access the record, callers must handle the\n/// possibility of error (typically with `try!` or `?`).\n///\n/// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n/// default), then this does not include the first record. Additionally,\n/// if `has_headers` is enabled, then deserializing into a struct will\n/// automatically align the values in each row to the fields of a struct\n/// based on the header row.\n///\n/// # Example\n///\n/// This shows how to deserialize CSV data into normal Rust structs. The\n/// fields of the header row are used to match up the values in each row\n/// to the fields of the struct.\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::Reader;\n/// use serde::Deserialize;\n///\n/// #[derive(Debug, Deserialize, Eq, PartialEq)]\n/// struct Row {\n///     city: String,\n///     country: String,\n///     #[serde(rename = \"popcount\")]\n///     population: u64,\n/// }\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,popcount\n/// Boston,United States,4628910\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///     let mut iter = rdr.deserialize();\n///\n///     if let Some(result) = iter.next() {\n///         let record: Row = result?;\n///         assert_eq!(record, Row {\n///             city: \"Boston\".to_string(),\n///             country: \"United States\".to_string(),\n///             population: 4628910,\n///         });\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\n///\n/// # Rules\n///\n/// For the most part, any Rust type that maps straight-forwardly to a CSV\n/// record is supported. This includes maps, structs, tuples and tuple\n/// structs. Other Rust types, such as `Vec`s, arrays, and enums have\n/// a more complicated story. In general, when working with CSV data, one\n/// should avoid *nested sequences* as much as possible.\n///\n/// Maps, structs, tuples and tuple structs map to CSV records in a simple\n/// way. Tuples and tuple structs decode their fields in the order that\n/// they are defined. Structs will do the same only if `has_headers` has\n/// been disabled using [`ReaderBuilder`](struct.ReaderBuilder.html),\n/// otherwise, structs and maps are deserialized based on the fields\n/// defined in the header row. (If there is no header row, then\n/// deserializing into a map will result in an error.)\n///\n/// Nested sequences are supported in a limited capacity. Namely, they\n/// are flattened. As a result, it's often useful to use a `Vec` to capture\n/// a \"tail\" of fields in a record:\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::ReaderBuilder;\n/// use serde::Deserialize;\n///\n/// #[derive(Debug, Deserialize, Eq, PartialEq)]\n/// struct Row {\n///     label: String,\n///     values: Vec<i32>,\n/// }\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"foo,1,2,3\";\n///     let mut rdr = ReaderBuilder::new()\n///         .has_headers(false)\n///         .from_reader(data.as_bytes());\n///     let mut iter = rdr.deserialize();\n///\n///     if let Some(result) = iter.next() {\n///         let record: Row = result?;\n///         assert_eq!(record, Row {\n///             label: \"foo\".to_string(),\n///             values: vec![1, 2, 3],\n///         });\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\n///\n/// In the above example, adding another field to the `Row` struct after\n/// the `values` field will result in a deserialization error. This is\n/// because the deserializer doesn't know when to stop reading fields\n/// into the `values` vector, so it will consume the rest of the fields in\n/// the record leaving none left over for the additional field.\n///\n/// Finally, simple enums in Rust can be deserialized as well. Namely,\n/// enums must either be variants with no arguments or variants with a\n/// single argument. Variants with no arguments are deserialized based on\n/// which variant name the field matches. Variants with a single argument\n/// are deserialized based on which variant can store the data. The latter\n/// is only supported when using \"untagged\" enum deserialization. The\n/// following example shows both forms in action:\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::Reader;\n/// use serde::Deserialize;\n///\n/// #[derive(Debug, Deserialize, PartialEq)]\n/// struct Row {\n///     label: Label,\n///     value: Number,\n/// }\n///\n/// #[derive(Debug, Deserialize, PartialEq)]\n/// #[serde(rename_all = \"lowercase\")]\n/// enum Label {\n///     Celsius,\n///     Fahrenheit,\n/// }\n///\n/// #[derive(Debug, Deserialize, PartialEq)]\n/// #[serde(untagged)]\n/// enum Number {\n///     Integer(i64),\n///     Float(f64),\n/// }\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// label,value\n/// celsius,22.2222\n/// fahrenheit,72\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///     let mut iter = rdr.deserialize();\n///\n///     // Read the first record.\n///     if let Some(result) = iter.next() {\n///         let record: Row = result?;\n///         assert_eq!(record, Row {\n///             label: Label::Celsius,\n///             value: Number::Float(22.2222),\n///         });\n///     } else {\n///         return Err(From::from(\n///             \"expected at least two records but got none\"));\n///     }\n///\n///     // Read the second record.\n///     if let Some(result) = iter.next() {\n///         let record: Row = result?;\n///         assert_eq!(record, Row {\n///             label: Label::Fahrenheit,\n///             value: Number::Integer(72),\n///         });\n///         Ok(())\n///     } else {\n///         Err(From::from(\n///             \"expected at least two records but got only one\"))\n///     }\n/// }\n/// ```\npub fn deserialize<D>(&mut self) -> DeserializeRecordsIter<R, D>\n    where\n        D: DeserializeOwned,{\n        DeserializeRecordsIter::new(self)\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::from_reader":["/// Create a new CSV parser with a default configuration for the given\n/// reader.\n///\n/// To customize CSV parsing, use a `ReaderBuilder`.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::Reader;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///     for result in rdr.records() {\n///         let record = result?;\n///         println!(\"{:?}\", record);\n///     }\n///     Ok(())\n/// }\n/// ```\npub fn from_reader(rdr: R) -> Reader<R>{\n        ReaderBuilder::new().from_reader(rdr)\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::get_mut":["/// Returns a mutable reference to the underlying reader.\npub fn get_mut(&mut self) -> &mut R{\n        self.rdr.get_mut()\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::get_ref":["/// Returns a reference to the underlying reader.\npub fn get_ref(&self) -> &R{\n        self.rdr.get_ref()\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::has_headers":["/// Returns true if and only if this reader has been configured to\n/// interpret the first record as a header record.\npub fn has_headers(&self) -> bool{\n        self.state.has_headers\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::headers":["/// Returns a reference to the first row read by this parser.\n///\n/// If no row has been read yet, then this will force parsing of the first\n/// row.\n///\n/// If there was a problem parsing the row or if it wasn't valid UTF-8,\n/// then this returns an error.\n///\n/// If the underlying reader emits EOF before any data, then this returns\n/// an empty record.\n///\n/// Note that this method may be used regardless of whether `has_headers`\n/// was enabled (but it is enabled by default).\n///\n/// # Example\n///\n/// This example shows how to get the header row of CSV data. Notice that\n/// the header row does not appear as a record in the iterator!\n///\n/// ```\n/// use std::error::Error;\n/// use csv::Reader;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///\n///     // We can read the headers before iterating.\n///     {\n///         // `headers` borrows from the reader, so we put this in its\n///         // own scope. That way, the borrow ends before we try iterating\n///         // below. Alternatively, we could clone the headers.\n///         let headers = rdr.headers()?;\n///         assert_eq!(headers, vec![\"city\", \"country\", \"pop\"]);\n///     }\n///\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///     } else {\n///         return Err(From::from(\n///             \"expected at least one record but got none\"))\n///     }\n///\n///     // We can also read the headers after iterating.\n///     let headers = rdr.headers()?;\n///     assert_eq!(headers, vec![\"city\", \"country\", \"pop\"]);\n///     Ok(())\n/// }\n/// ```\npub fn headers(&mut self) -> Result<&StringRecord>{\n        if self.state.headers.is_none() {\n            let mut record = ByteRecord::new();\n            self.read_byte_record_impl(&mut record)?;\n            self.set_headers_impl(Err(record));\n        }\n        let headers = self.state.headers.as_ref().unwrap();\n        match headers.string_record {\n            Ok(ref record) => Ok(record),\n            Err(ref err) => Err(Error::new(ErrorKind::Utf8 {\n                pos: headers.byte_record.position().map(Clone::clone),\n                err: err.clone(),\n            })),\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::into_byte_records":["/// Returns an owned iterator over all records as raw bytes.\n///\n/// Each item yielded by this iterator is a `Result<ByteRecord, Error>`.\n/// Therefore, in order to access the record, callers must handle the\n/// possibility of error (typically with `try!` or `?`).\n///\n/// This is mostly useful when you want to return a CSV iterator or store\n/// it somewhere.\n///\n/// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n/// default), then this does not include the first record.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::Reader;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// \";\n///     let rdr = Reader::from_reader(data.as_bytes());\n///     let mut iter = rdr.into_byte_records();\n///\n///     if let Some(result) = iter.next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn into_byte_records(self) -> ByteRecordsIntoIter<R>{\n        ByteRecordsIntoIter::new(self)\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::into_deserialize":["/// Returns an owned iterator over deserialized records.\n///\n/// Each item yielded by this iterator is a `Result<D, Error>`.\n/// Therefore, in order to access the record, callers must handle the\n/// possibility of error (typically with `try!` or `?`).\n///\n/// This is mostly useful when you want to return a CSV iterator or store\n/// it somewhere.\n///\n/// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n/// default), then this does not include the first record. Additionally,\n/// if `has_headers` is enabled, then deserializing into a struct will\n/// automatically align the values in each row to the fields of a struct\n/// based on the header row.\n///\n/// For more detailed deserialization rules, see the documentation on the\n/// `deserialize` method.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::Reader;\n/// use serde::Deserialize;\n///\n/// #[derive(Debug, Deserialize, Eq, PartialEq)]\n/// struct Row {\n///     city: String,\n///     country: String,\n///     #[serde(rename = \"popcount\")]\n///     population: u64,\n/// }\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,popcount\n/// Boston,United States,4628910\n/// \";\n///     let rdr = Reader::from_reader(data.as_bytes());\n///     let mut iter = rdr.into_deserialize();\n///\n///     if let Some(result) = iter.next() {\n///         let record: Row = result?;\n///         assert_eq!(record, Row {\n///             city: \"Boston\".to_string(),\n///             country: \"United States\".to_string(),\n///             population: 4628910,\n///         });\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn into_deserialize<D>(self) -> DeserializeRecordsIntoIter<R, D>\n    where\n        D: DeserializeOwned,{\n        DeserializeRecordsIntoIter::new(self)\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::into_inner":["/// Unwraps this CSV reader, returning the underlying reader.\n///\n/// Note that any leftover data inside this reader's internal buffer is\n/// lost.\npub fn into_inner(self) -> R{\n        self.rdr.into_inner()\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::into_records":["/// Returns an owned iterator over all records as strings.\n///\n/// Each item yielded by this iterator is a `Result<StringRecord, Error>`.\n/// Therefore, in order to access the record, callers must handle the\n/// possibility of error (typically with `try!` or `?`).\n///\n/// This is mostly useful when you want to return a CSV iterator or store\n/// it somewhere.\n///\n/// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n/// default), then this does not include the first record.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::Reader;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// \";\n///     let rdr = Reader::from_reader(data.as_bytes());\n///     let mut iter = rdr.into_records();\n///\n///     if let Some(result) = iter.next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn into_records(self) -> StringRecordsIntoIter<R>{\n        StringRecordsIntoIter::new(self)\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::is_done":["/// Returns true if and only if this reader has been exhausted.\n///\n/// When this returns true, no more records can be read from this reader\n/// (unless it has been seeked to another position).\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use std::io;\n/// use csv::{Reader, Position};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,popcount\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \";\n///     let mut rdr = Reader::from_reader(io::Cursor::new(data));\n///     assert!(!rdr.is_done());\n///     for result in rdr.records() {\n///         let _ = result?;\n///     }\n///     assert!(rdr.is_done());\n///     Ok(())\n/// }\n/// ```\npub fn is_done(&self) -> bool{\n        self.state.eof\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::new":["/// Create a new CSV reader given a builder and a source of underlying\n/// bytes.\nfn new(builder: &ReaderBuilder, rdr: R) -> Reader<R>{\n        Reader {\n            core: Box::new(builder.builder.build()),\n            rdr: io::BufReader::with_capacity(builder.capacity, rdr),\n            state: ReaderState {\n                headers: None,\n                has_headers: builder.has_headers,\n                flexible: builder.flexible,\n                trim: builder.trim,\n                first_field_count: None,\n                cur_pos: Position::new(),\n                first: false,\n                seeked: false,\n                eof: false,\n            },\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::position":["/// Return the current position of this CSV reader.\n///\n/// The byte offset in the position returned can be used to `seek` this\n/// reader. In particular, seeking to a position returned here on the same\n/// data will result in parsing the same subsequent record.\n///\n/// # Example: reading the position\n///\n/// ```\n/// use std::error::Error;\n/// use std::io;\n/// use csv::{Reader, Position};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,popcount\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \";\n///     let rdr = Reader::from_reader(io::Cursor::new(data));\n///     let mut iter = rdr.into_records();\n///     let mut pos = Position::new();\n///     loop {\n///         // Read the position immediately before each record.\n///         let next_pos = iter.reader().position().clone();\n///         if iter.next().is_none() {\n///             break;\n///         }\n///         pos = next_pos;\n///     }\n///\n///     // `pos` should now be the position immediately before the last\n///     // record.\n///     assert_eq!(pos.byte(), 51);\n///     assert_eq!(pos.line(), 3);\n///     assert_eq!(pos.record(), 2);\n///     Ok(())\n/// }\n/// ```\npub fn position(&self) -> &Position{\n        &self.state.cur_pos\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::read_byte_record":["/// Read a single row into the given byte record. Returns false when no\n/// more records could be read.\n///\n/// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n/// default), then this will never read the first record.\n///\n/// This method is useful when you want to read records as fast as\n/// as possible. It's less ergonomic than an iterator, but it permits the\n/// caller to reuse the `ByteRecord` allocation, which usually results\n/// in higher throughput.\n///\n/// Records read via this method are guaranteed to have a position set\n/// on them, even if the reader is at EOF or if an error is returned.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{ByteRecord, Reader};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///     let mut record = ByteRecord::new();\n///\n///     if rdr.read_byte_record(&mut record)? {\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn read_byte_record(\n        &mut self,\n        record: &mut ByteRecord,\n    ) -> Result<bool>{\n        if !self.state.seeked && !self.state.has_headers && !self.state.first {\n            // If the caller indicated \"no headers\" and we haven't yielded the\n            // first record yet, then we should yield our header row if we have\n            // one.\n            if let Some(ref headers) = self.state.headers {\n                self.state.first = true;\n                record.clone_from(&headers.byte_record);\n                if self.state.trim.should_trim_fields() {\n                    record.trim();\n                }\n                return Ok(!record.is_empty());\n            }\n        }\n        let ok = self.read_byte_record_impl(record)?;\n        self.state.first = true;\n        if !self.state.seeked && self.state.headers.is_none() {\n            self.set_headers_impl(Err(record.clone()));\n            // If the end user indicated that we have headers, then we should\n            // never return the first row. Instead, we should attempt to\n            // read and return the next one.\n            if self.state.has_headers {\n                let result = self.read_byte_record_impl(record);\n                if self.state.trim.should_trim_fields() {\n                    record.trim();\n                }\n                return result;\n            }\n        } else if self.state.trim.should_trim_fields() {\n            record.trim();\n        }\n        Ok(ok)\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::read_byte_record_impl":["/// Read a byte record from the underlying CSV reader, without accounting\n/// for headers.\n#[inline(always)]\nfn read_byte_record_impl(\n        &mut self,\n        record: &mut ByteRecord,\n    ) -> Result<bool>{\n        use csv_core::ReadRecordResult::*;\n\n        record.clear();\n        record.set_position(Some(self.state.cur_pos.clone()));\n        if self.state.eof {\n            return Ok(false);\n        }\n        let (mut outlen, mut endlen) = (0, 0);\n        loop {\n            let (res, nin, nout, nend) = {\n                let input = self.rdr.fill_buf()?;\n                let (fields, ends) = record.as_parts();\n                self.core.read_record(\n                    input,\n                    &mut fields[outlen..],\n                    &mut ends[endlen..],\n                )\n            };\n            self.rdr.consume(nin);\n            let byte = self.state.cur_pos.byte();\n            self.state\n                .cur_pos\n                .set_byte(byte + nin as u64)\n                .set_line(self.core.line());\n            outlen += nout;\n            endlen += nend;\n            match res {\n                InputEmpty => continue,\n                OutputFull => {\n                    record.expand_fields();\n                    continue;\n                }\n                OutputEndsFull => {\n                    record.expand_ends();\n                    continue;\n                }\n                Record => {\n                    record.set_len(endlen);\n                    self.state.add_record(record)?;\n                    return Ok(true);\n                }\n                End => {\n                    self.state.eof = true;\n                    return Ok(false);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::read_record":["/// Read a single row into the given record. Returns false when no more\n/// records could be read.\n///\n/// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n/// default), then this will never read the first record.\n///\n/// This method is useful when you want to read records as fast as\n/// as possible. It's less ergonomic than an iterator, but it permits the\n/// caller to reuse the `StringRecord` allocation, which usually results\n/// in higher throughput.\n///\n/// Records read via this method are guaranteed to have a position set\n/// on them, even if the reader is at EOF or if an error is returned.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{Reader, StringRecord};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///     let mut record = StringRecord::new();\n///\n///     if rdr.read_record(&mut record)? {\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn read_record(&mut self, record: &mut StringRecord) -> Result<bool>{\n        let result = record.read(self);\n        // We need to trim again because trimming string records includes\n        // Unicode whitespace. (ByteRecord trimming only includes ASCII\n        // whitespace.)\n        if self.state.trim.should_trim_fields() {\n            record.trim();\n        }\n        result\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::records":["/// Returns a borrowed iterator over all records as strings.\n///\n/// Each item yielded by this iterator is a `Result<StringRecord, Error>`.\n/// Therefore, in order to access the record, callers must handle the\n/// possibility of error (typically with `try!` or `?`).\n///\n/// If `has_headers` was enabled via a `ReaderBuilder` (which is the\n/// default), then this does not include the first record.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::Reader;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///     let mut iter = rdr.records();\n///\n///     if let Some(result) = iter.next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn records(&mut self) -> StringRecordsIter<R>{\n        StringRecordsIter::new(self)\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::seek":["/// Seeks the underlying reader to the position given.\n///\n/// This comes with a few caveats:\n///\n/// * Any internal buffer associated with this reader is cleared.\n/// * If the given position does not correspond to a position immediately\n///   before the start of a record, then the behavior of this reader is\n///   unspecified.\n/// * Any special logic that skips the first record in the CSV reader\n///   when reading or iterating over records is disabled.\n///\n/// If the given position has a byte offset equivalent to the current\n/// position, then no seeking is performed.\n///\n/// If the header row has not already been read, then this will attempt\n/// to read the header row before seeking. Therefore, it is possible that\n/// this returns an error associated with reading CSV data.\n///\n/// Note that seeking is performed based only on the byte offset in the\n/// given position. Namely, the record or line numbers in the position may\n/// be incorrect, but this will cause any future position generated by\n/// this CSV reader to be similarly incorrect.\n///\n/// # Example: seek to parse a record twice\n///\n/// ```\n/// use std::error::Error;\n/// use std::io;\n/// use csv::{Reader, Position};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,popcount\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \";\n///     let rdr = Reader::from_reader(io::Cursor::new(data));\n///     let mut iter = rdr.into_records();\n///     let mut pos = Position::new();\n///     loop {\n///         // Read the position immediately before each record.\n///         let next_pos = iter.reader().position().clone();\n///         if iter.next().is_none() {\n///             break;\n///         }\n///         pos = next_pos;\n///     }\n///\n///     // Now seek the reader back to `pos`. This will let us read the\n///     // last record again.\n///     iter.reader_mut().seek(pos)?;\n///     let mut iter = iter.into_reader().into_records();\n///     if let Some(result) = iter.next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Concord\", \"United States\", \"42695\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn seek(&mut self, pos: Position) -> Result<()>{\n        self.byte_headers()?;\n        self.state.seeked = true;\n        if pos.byte() == self.state.cur_pos.byte() {\n            return Ok(());\n        }\n        self.rdr.seek(io::SeekFrom::Start(pos.byte()))?;\n        self.core.reset();\n        self.core.set_line(pos.line());\n        self.state.cur_pos = pos;\n        self.state.eof = false;\n        Ok(())\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::seek_raw":["/// This is like `seek`, but provides direct control over how the seeking\n/// operation is performed via `io::SeekFrom`.\n///\n/// The `pos` position given *should* correspond the position indicated\n/// by `seek_from`, but there is no requirement. If the `pos` position\n/// given is incorrect, then the position information returned by this\n/// reader will be similarly incorrect.\n///\n/// If the header row has not already been read, then this will attempt\n/// to read the header row before seeking. Therefore, it is possible that\n/// this returns an error associated with reading CSV data.\n///\n/// Unlike `seek`, this will always cause an actual seek to be performed.\npub fn seek_raw(\n        &mut self,\n        seek_from: io::SeekFrom,\n        pos: Position,\n    ) -> Result<()>{\n        self.byte_headers()?;\n        self.state.seeked = true;\n        self.rdr.seek(seek_from)?;\n        self.core.reset();\n        self.core.set_line(pos.line());\n        self.state.cur_pos = pos;\n        self.state.eof = false;\n        Ok(())\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::set_byte_headers":["/// Set the headers of this CSV parser manually as raw bytes.\n///\n/// This overrides any other setting (including `set_headers`). Any\n/// automatic detection of headers is disabled. This may be called at any\n/// time.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{Reader, ByteRecord};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///\n///     assert_eq!(rdr.byte_headers()?, vec![\"city\", \"country\", \"pop\"]);\n///     rdr.set_byte_headers(ByteRecord::from(vec![\"a\", \"b\", \"c\"]));\n///     assert_eq!(rdr.byte_headers()?, vec![\"a\", \"b\", \"c\"]);\n///\n///     Ok(())\n/// }\n/// ```\npub fn set_byte_headers(&mut self, headers: ByteRecord){\n        self.set_headers_impl(Err(headers));\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::set_headers":["/// Set the headers of this CSV parser manually.\n///\n/// This overrides any other setting (including `set_byte_headers`). Any\n/// automatic detection of headers is disabled. This may be called at any\n/// time.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{Reader, StringRecord};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// \";\n///     let mut rdr = Reader::from_reader(data.as_bytes());\n///\n///     assert_eq!(rdr.headers()?, vec![\"city\", \"country\", \"pop\"]);\n///     rdr.set_headers(StringRecord::from(vec![\"a\", \"b\", \"c\"]));\n///     assert_eq!(rdr.headers()?, vec![\"a\", \"b\", \"c\"]);\n///\n///     Ok(())\n/// }\n/// ```\npub fn set_headers(&mut self, headers: StringRecord){\n        self.set_headers_impl(Ok(headers));\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<R>::set_headers_impl":["fn set_headers_impl(\n        &mut self,\n        headers: result::Result<StringRecord, ByteRecord>,\n    ){\n        // If we have string headers, then get byte headers. But if we have\n        // byte headers, then get the string headers (or a UTF-8 error).\n        let (mut str_headers, mut byte_headers) = match headers {\n            Ok(string) => {\n                let bytes = string.clone().into_byte_record();\n                (Ok(string), bytes)\n            }\n            Err(bytes) => {\n                match StringRecord::from_byte_record(bytes.clone()) {\n                    Ok(str_headers) => (Ok(str_headers), bytes),\n                    Err(err) => (Err(err.utf8_error().clone()), bytes),\n                }\n            }\n        };\n        if self.state.trim.should_trim_headers() {\n            if let Ok(ref mut str_headers) = str_headers.as_mut() {\n                str_headers.trim();\n            }\n            byte_headers.trim();\n        }\n        self.state.headers = Some(Headers {\n            byte_record: byte_headers,\n            string_record: str_headers,\n        });\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::Reader::<reader::Reader<std::fs::File>>::from_path":["/// Create a new CSV parser with a default configuration for the given\n/// file path.\n///\n/// To customize CSV parsing, use a `ReaderBuilder`.\n///\n/// # Example\n///\n/// ```no_run\n/// use std::error::Error;\n/// use csv::Reader;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut rdr = Reader::from_path(\"foo.csv\")?;\n///     for result in rdr.records() {\n///         let record = result?;\n///         println!(\"{:?}\", record);\n///     }\n///     Ok(())\n/// }\n/// ```\npub fn from_path<P: AsRef<Path>>(path: P) -> Result<Reader<File>>{\n        ReaderBuilder::new().from_path(path)\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder":["/// Builds a CSV reader with various configuration knobs.\n///\n/// This builder can be used to tweak the field delimiter, record terminator\n/// and more. Once a CSV `Reader` is built, its configuration cannot be\n/// changed.\npub struct ReaderBuilder {\n    capacity: usize,\n    flexible: bool,\n    has_headers: bool,\n    trim: Trim,\n    /// The underlying CSV parser builder.\n    ///\n    /// We explicitly put this on the heap because CoreReaderBuilder embeds an\n    /// entire DFA transition table, which along with other things, tallies up\n    /// to almost 500 bytes on the stack.\n    builder: Box<CoreReaderBuilder>,\n}","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::ascii":["/// A convenience method for specifying a configuration to read ASCII\n/// delimited text.\n///\n/// This sets the delimiter and record terminator to the ASCII unit\n/// separator (`\\x1F`) and record separator (`\\x1E`), respectively.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city\\x1Fcountry\\x1Fpop\\x1EBoston\\x1FUnited States\\x1F4628910\";\n///     let mut rdr = ReaderBuilder::new()\n///         .ascii()\n///         .from_reader(data.as_bytes());\n///\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn ascii(&mut self) -> &mut ReaderBuilder{\n        self.builder.ascii();\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::buffer_capacity":["/// Set the capacity (in bytes) of the buffer used in the CSV reader.\n/// This defaults to a reasonable setting.\npub fn buffer_capacity(&mut self, capacity: usize) -> &mut ReaderBuilder{\n        self.capacity = capacity;\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::comment":["/// The comment character to use when parsing CSV.\n///\n/// If the start of a record begins with the byte given here, then that\n/// line is ignored by the CSV parser.\n///\n/// This is disabled by default.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// #Concord,United States,42695\n/// Boston,United States,4628910\n/// \";\n///     let mut rdr = ReaderBuilder::new()\n///         .comment(Some(b'#'))\n///         .from_reader(data.as_bytes());\n///\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn comment(&mut self, comment: Option<u8>) -> &mut ReaderBuilder{\n        self.builder.comment(comment);\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::delimiter":["/// The field delimiter to use when parsing CSV.\n///\n/// The default is `b','`.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city;country;pop\n/// Boston;United States;4628910\n/// \";\n///     let mut rdr = ReaderBuilder::new()\n///         .delimiter(b';')\n///         .from_reader(data.as_bytes());\n///\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn delimiter(&mut self, delimiter: u8) -> &mut ReaderBuilder{\n        self.builder.delimiter(delimiter);\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::double_quote":["/// Enable double quote escapes.\n///\n/// This is enabled by default, but it may be disabled. When disabled,\n/// doubled quotes are not interpreted as escapes.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,\\\"The \\\"\\\"United\\\"\\\" States\\\",4628910\n/// \";\n///     let mut rdr = ReaderBuilder::new()\n///         .double_quote(false)\n///         .from_reader(data.as_bytes());\n///\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\n///             \"Boston\", \"The \\\"United\\\"\\\" States\\\"\", \"4628910\",\n///         ]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn double_quote(&mut self, yes: bool) -> &mut ReaderBuilder{\n        self.builder.double_quote(yes);\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::escape":["/// The escape character to use when parsing CSV.\n///\n/// In some variants of CSV, quotes are escaped using a special escape\n/// character like `\\` (instead of escaping quotes by doubling them).\n///\n/// By default, recognizing these idiosyncratic escapes is disabled.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,\\\"The \\\\\\\"United\\\\\\\" States\\\",4628910\n/// \";\n///     let mut rdr = ReaderBuilder::new()\n///         .escape(Some(b'\\\\'))\n///         .from_reader(data.as_bytes());\n///\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\n///             \"Boston\", \"The \\\"United\\\" States\", \"4628910\",\n///         ]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn escape(&mut self, escape: Option<u8>) -> &mut ReaderBuilder{\n        self.builder.escape(escape);\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::flexible":["/// Whether the number of fields in records is allowed to change or not.\n///\n/// When disabled (which is the default), parsing CSV data will return an\n/// error if a record is found with a number of fields different from the\n/// number of fields in a previous record.\n///\n/// When enabled, this error checking is turned off.\n///\n/// # Example: flexible records enabled\n///\n/// ```\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     // Notice that the first row is missing the population count.\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States\n/// \";\n///     let mut rdr = ReaderBuilder::new()\n///         .flexible(true)\n///         .from_reader(data.as_bytes());\n///\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\n///\n/// # Example: flexible records disabled\n///\n/// This shows the error that appears when records of unequal length\n/// are found and flexible records have been disabled (which is the\n/// default).\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{ErrorKind, ReaderBuilder};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     // Notice that the first row is missing the population count.\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States\n/// \";\n///     let mut rdr = ReaderBuilder::new()\n///         .flexible(false)\n///         .from_reader(data.as_bytes());\n///\n///     if let Some(Err(err)) = rdr.records().next() {\n///         match *err.kind() {\n///             ErrorKind::UnequalLengths { expected_len, len, .. } => {\n///                 // The header row has 3 fields...\n///                 assert_eq!(expected_len, 3);\n///                 // ... but the first row has only 2 fields.\n///                 assert_eq!(len, 2);\n///                 Ok(())\n///             }\n///             ref wrong => {\n///                 Err(From::from(format!(\n///                     \"expected UnequalLengths error but got {:?}\",\n///                     wrong)))\n///             }\n///         }\n///     } else {\n///         Err(From::from(\n///             \"expected at least one errored record but got none\"))\n///     }\n/// }\n/// ```\npub fn flexible(&mut self, yes: bool) -> &mut ReaderBuilder{\n        self.flexible = yes;\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::from_path":["/// Build a CSV parser from this configuration that reads data from the\n/// given file path.\n///\n/// If there was a problem opening the file at the given path, then this\n/// returns the corresponding error.\n///\n/// # Example\n///\n/// ```no_run\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut rdr = ReaderBuilder::new().from_path(\"foo.csv\")?;\n///     for result in rdr.records() {\n///         let record = result?;\n///         println!(\"{:?}\", record);\n///     }\n///     Ok(())\n/// }\n/// ```\npub fn from_path<P: AsRef<Path>>(&self, path: P) -> Result<Reader<File>>{\n        Ok(Reader::new(self, File::open(path)?))\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::from_reader":["/// Build a CSV parser from this configuration that reads data from `rdr`.\n///\n/// Note that the CSV reader is buffered automatically, so you should not\n/// wrap `rdr` in a buffered reader like `io::BufReader`.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \";\n///     let mut rdr = ReaderBuilder::new().from_reader(data.as_bytes());\n///     for result in rdr.records() {\n///         let record = result?;\n///         println!(\"{:?}\", record);\n///     }\n///     Ok(())\n/// }\n/// ```\npub fn from_reader<R: io::Read>(&self, rdr: R) -> Reader<R>{\n        Reader::new(self, rdr)\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::has_headers":["/// Whether to treat the first row as a special header row.\n///\n/// By default, the first row is treated as a special header row, which\n/// means the header is never returned by any of the record reading methods\n/// or iterators. When this is disabled (`yes` set to `false`), the first\n/// row is not treated specially.\n///\n/// Note that the `headers` and `byte_headers` methods are unaffected by\n/// whether this is set. Those methods always return the first record.\n///\n/// # Example\n///\n/// This example shows what happens when `has_headers` is disabled.\n/// Namely, the first row is treated just like any other row.\n///\n/// ```\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// \";\n///     let mut rdr = ReaderBuilder::new()\n///         .has_headers(false)\n///         .from_reader(data.as_bytes());\n///     let mut iter = rdr.records();\n///\n///     // Read the first record.\n///     if let Some(result) = iter.next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"city\", \"country\", \"pop\"]);\n///     } else {\n///         return Err(From::from(\n///             \"expected at least two records but got none\"));\n///     }\n///\n///     // Read the second record.\n///     if let Some(result) = iter.next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///     } else {\n///         return Err(From::from(\n///             \"expected at least two records but got one\"))\n///     }\n///     Ok(())\n/// }\n/// ```\npub fn has_headers(&mut self, yes: bool) -> &mut ReaderBuilder{\n        self.has_headers = yes;\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::new":["/// Create a new builder for configuring CSV parsing.\n///\n/// To convert a builder into a reader, call one of the methods starting\n/// with `from_`.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{ReaderBuilder, StringRecord};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \";\n///     let mut rdr = ReaderBuilder::new().from_reader(data.as_bytes());\n///\n///     let records = rdr\n///         .records()\n///         .collect::<Result<Vec<StringRecord>, csv::Error>>()?;\n///     assert_eq!(records, vec![\n///         vec![\"Boston\", \"United States\", \"4628910\"],\n///         vec![\"Concord\", \"United States\", \"42695\"],\n///     ]);\n///     Ok(())\n/// }\n/// ```\npub fn new() -> ReaderBuilder{\n        ReaderBuilder::default()\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::nfa":["/// Enable or disable the NFA for parsing CSV.\n///\n/// This is intended to be a debug option. The NFA is always slower than\n/// the DFA.\n#[doc(hidden)]\npub fn nfa(&mut self, yes: bool) -> &mut ReaderBuilder{\n        self.builder.nfa(yes);\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::quote":["/// The quote character to use when parsing CSV.\n///\n/// The default is `b'\"'`.\n///\n/// # Example: single quotes instead of double quotes\n///\n/// ```\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,'United States',4628910\n/// \";\n///     let mut rdr = ReaderBuilder::new()\n///         .quote(b'\\'')\n///         .from_reader(data.as_bytes());\n///\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn quote(&mut self, quote: u8) -> &mut ReaderBuilder{\n        self.builder.quote(quote);\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::quoting":["/// Enable or disable quoting.\n///\n/// This is enabled by default, but it may be disabled. When disabled,\n/// quotes are not treated specially.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::ReaderBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city,country,pop\n/// Boston,\\\"The United States,4628910\n/// \";\n///     let mut rdr = ReaderBuilder::new()\n///         .quoting(false)\n///         .from_reader(data.as_bytes());\n///\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\n///             \"Boston\", \"\\\"The United States\", \"4628910\",\n///         ]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn quoting(&mut self, yes: bool) -> &mut ReaderBuilder{\n        self.builder.quoting(yes);\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::terminator":["/// The record terminator to use when parsing CSV.\n///\n/// A record terminator can be any single byte. The default is a special\n/// value, `Terminator::CRLF`, which treats any occurrence of `\\r`, `\\n`\n/// or `\\r\\n` as a single record terminator.\n///\n/// # Example: `$` as a record terminator\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{ReaderBuilder, Terminator};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"city,country,pop$Boston,United States,4628910\";\n///     let mut rdr = ReaderBuilder::new()\n///         .terminator(Terminator::Any(b'$'))\n///         .from_reader(data.as_bytes());\n///\n///     if let Some(result) = rdr.records().next() {\n///         let record = result?;\n///         assert_eq!(record, vec![\"Boston\", \"United States\", \"4628910\"]);\n///         Ok(())\n///     } else {\n///         Err(From::from(\"expected at least one record but got none\"))\n///     }\n/// }\n/// ```\npub fn terminator(&mut self, term: Terminator) -> &mut ReaderBuilder{\n        self.builder.terminator(term.to_core());\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderBuilder::trim":["/// Whether fields are trimmed of leading and trailing whitespace or not.\n///\n/// By default, no trimming is performed. This method permits one to\n/// override that behavior and choose one of the following options:\n///\n/// 1. `Trim::Headers` trims only header values.\n/// 2. `Trim::Fields` trims only non-header or \"field\" values.\n/// 3. `Trim::All` trims both header and non-header values.\n///\n/// A value is only interpreted as a header value if this CSV reader is\n/// configured to read a header record (which is the default).\n///\n/// When reading string records, characters meeting the definition of\n/// Unicode whitespace are trimmed. When reading byte records, characters\n/// meeting the definition of ASCII whitespace are trimmed. ASCII\n/// whitespace characters correspond to the set `[\\t\\n\\v\\f\\r ]`.\n///\n/// # Example\n///\n/// This example shows what happens when all values are trimmed.\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{ReaderBuilder, StringRecord, Trim};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let data = \"\\\n/// city ,   country ,  pop\n/// Boston,\\\"\n///    United States\\\",4628910\n/// Concord,   United States   ,42695\n/// \";\n///     let mut rdr = ReaderBuilder::new()\n///         .trim(Trim::All)\n///         .from_reader(data.as_bytes());\n///     let records = rdr\n///         .records()\n///         .collect::<Result<Vec<StringRecord>, csv::Error>>()?;\n///     assert_eq!(records, vec![\n///         vec![\"Boston\", \"United States\", \"4628910\"],\n///         vec![\"Concord\", \"United States\", \"42695\"],\n///     ]);\n///     Ok(())\n/// }\n/// ```\npub fn trim(&mut self, trim: Trim) -> &mut ReaderBuilder{\n        self.trim = trim;\n        self\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderState":["struct ReaderState {\n    /// When set, this contains the first row of any parsed CSV data.\n    ///\n    /// This is always populated, regardless of whether `has_headers` is set.\n    headers: Option<Headers>,\n    /// When set, the first row of parsed CSV data is excluded from things\n    /// that read records, like iterators and `read_record`.\n    has_headers: bool,\n    /// When set, there is no restriction on the length of records. When not\n    /// set, every record must have the same number of fields, or else an error\n    /// is reported.\n    flexible: bool,\n    trim: Trim,\n    /// The number of fields in the first record parsed.\n    first_field_count: Option<u64>,\n    /// The current position of the parser.\n    ///\n    /// Note that this position is only observable by callers at the start\n    /// of a record. More granular positions are not supported.\n    cur_pos: Position,\n    /// Whether the first record has been read or not.\n    first: bool,\n    /// Whether the reader has been seeked or not.\n    seeked: bool,\n    /// Whether EOF of the underlying reader has been reached or not.\n    eof: bool,\n}","Real(LocalPath(\"src/reader.rs\"))"],"reader::ReaderState::add_record":["#[inline(always)]\nfn add_record(&mut self, record: &ByteRecord) -> Result<()>{\n        let i = self.cur_pos.record();\n        self.cur_pos.set_record(i.checked_add(1).unwrap());\n        if !self.flexible {\n            match self.first_field_count {\n                None => self.first_field_count = Some(record.len() as u64),\n                Some(expected) => {\n                    if record.len() as u64 != expected {\n                        return Err(Error::new(ErrorKind::UnequalLengths {\n                            pos: record.position().map(Clone::clone),\n                            expected_len: expected,\n                            len: record.len() as u64,\n                        }));\n                    }\n                }\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::StringRecordsIntoIter":["/// An owned iterator over records as strings.\npub struct StringRecordsIntoIter<R> {\n    rdr: Reader<R>,\n    rec: StringRecord,\n}","Real(LocalPath(\"src/reader.rs\"))"],"reader::StringRecordsIntoIter::<R>::into_reader":["/// Drop this iterator and return the underlying CSV reader.\npub fn into_reader(self) -> Reader<R>{\n        self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::StringRecordsIntoIter::<R>::new":["fn new(rdr: Reader<R>) -> StringRecordsIntoIter<R>{\n        StringRecordsIntoIter { rdr: rdr, rec: StringRecord::new() }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::StringRecordsIntoIter::<R>::reader":["/// Return a reference to the underlying CSV reader.\npub fn reader(&self) -> &Reader<R>{\n        &self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::StringRecordsIntoIter::<R>::reader_mut":["/// Return a mutable reference to the underlying CSV reader.\npub fn reader_mut(&mut self) -> &mut Reader<R>{\n        &mut self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::StringRecordsIter":["/// A borrowed iterator over records as strings.\n///\n/// The lifetime parameter `'r` refers to the lifetime of the underlying\n/// CSV `Reader`.\npub struct StringRecordsIter<'r, R: 'r> {\n    rdr: &'r mut Reader<R>,\n    rec: StringRecord,\n}","Real(LocalPath(\"src/reader.rs\"))"],"reader::StringRecordsIter::<'r, R>::new":["fn new(rdr: &'r mut Reader<R>) -> StringRecordsIter<'r, R>{\n        StringRecordsIter { rdr: rdr, rec: StringRecord::new() }\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::StringRecordsIter::<'r, R>::reader":["/// Return a reference to the underlying CSV reader.\npub fn reader(&self) -> &Reader<R>{\n        &self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"reader::StringRecordsIter::<'r, R>::reader_mut":["/// Return a mutable reference to the underlying CSV reader.\npub fn reader_mut(&mut self) -> &mut Reader<R>{\n        &mut self.rdr\n    }","Real(LocalPath(\"src/reader.rs\"))"],"serializer::<impl serde::ser::Error for error::Error>::custom":["fn custom<T: fmt::Display>(msg: T) -> Error{\n        Error::new(ErrorKind::Serialize(msg.to_string()))\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"serializer::HeaderState":["/// State machine for `SeHeader`.\n///\n/// This is a diagram of the transitions in the state machine. Note that only\n/// some serialization events cause a state transition, and only for certain\n/// states. For example, encountering a scalar causes a transition if the state\n/// is `Write` or `EncounteredStructField`, but not if the state is\n/// `ErrorIfWrite(err)` or `InStructField`.\n///\n/// ```text\n///                              +-----+\n///                              |Write|\n///                              +-----+\n///                                 |\n///              /------------------+------------------\\\n///              |                  |                  |\n///          encounter            finish           encounter\n///            scalar               |             struct field\n///              |                  |                  |\n///              v                  v                  v\n///     +-----------------+       Ok(())        +-------------+\n///     |ErrorIfWrite(err)|                     |InStructField|<--------\\\n///     +-----------------+                     +-------------+         |\n///              |                                     |                |\n///       /------+------\\            /-----------------+                |\n///       |             |            |                 |                |\n///   encounter       finish     encounter          finish          encounter\n///  struct field       |        container           field         struct field\n///       |             |            |                 |                |\n///       v             v            v                 v                |\n///   Err(err)       Ok(())        Err(_)   +----------------------+    |\n///                                         |EncounteredStructField|    |\n///                                         +----------------------+    |\n///                                                    |                |\n///                                         /----------+----------------/\n///                                         |          |\n///                                     encounter    finish\n///                                       scalar       |\n///                                         |          |\n///                                         v          v\n///                                       Err(_)    Ok(())\n/// ```\nenum HeaderState {\n    /// Start here. Headers need to be written if the type has field names.\n    Write,\n    /// The serializer still has not encountered a struct field. If one is\n    /// encountered (headers need to be written), return the enclosed error.\n    ErrorIfWrite(Error),\n    /// The serializer encountered one or more struct fields (and wrote their\n    /// names).\n    EncounteredStructField,\n    /// The serializer is currently in a struct field value.\n    InStructField,\n}","Real(LocalPath(\"src/serializer.rs\"))"],"serializer::SeHeader":["struct SeHeader<'w, W: 'w + io::Write> {\n    wtr: &'w mut Writer<W>,\n    state: HeaderState,\n}","Real(LocalPath(\"src/serializer.rs\"))"],"serializer::SeHeader::<'w, W>::handle_container":["fn handle_container<T: fmt::Display>(\n        &mut self,\n        name: T,\n    ) -> Result<&mut Self, Error>{\n        if let HeaderState::InStructField = self.state {\n            Err(error_container_inside_struct(name))\n        } else {\n            Ok(self)\n        }\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"serializer::SeHeader::<'w, W>::handle_scalar":["fn handle_scalar<T: fmt::Display>(\n        &mut self,\n        name: T,\n    ) -> Result<(), Error>{\n        use self::HeaderState::*;\n\n        match self.state {\n            Write => {\n                self.state = ErrorIfWrite(error_scalar_outside_struct(name));\n                Ok(())\n            }\n            ErrorIfWrite(_) | InStructField => Ok(()),\n            EncounteredStructField => Err(error_scalar_outside_struct(name)),\n        }\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"serializer::SeHeader::<'w, W>::new":["fn new(wtr: &'w mut Writer<W>) -> Self{\n        SeHeader { wtr: wtr, state: HeaderState::Write }\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"serializer::SeHeader::<'w, W>::wrote_header":["fn wrote_header(&self) -> bool{\n        use self::HeaderState::*;\n        match self.state {\n            Write | ErrorIfWrite(_) => false,\n            EncounteredStructField | InStructField => true,\n        }\n    }","Real(LocalPath(\"src/serializer.rs\"))"],"serializer::SeRecord":["struct SeRecord<'w, W: 'w + io::Write> {\n    wtr: &'w mut Writer<W>,\n}","Real(LocalPath(\"src/serializer.rs\"))"],"serializer::error_container_inside_struct":["fn error_container_inside_struct<T: fmt::Display>(name: T) -> Error{\n    Error::custom(format!(\n        \"cannot serialize {} container inside struct \\\n         when writing headers from structs\",\n        name\n    ))\n}","Real(LocalPath(\"src/serializer.rs\"))"],"serializer::error_scalar_outside_struct":["fn error_scalar_outside_struct<T: fmt::Display>(name: T) -> Error{\n    Error::custom(format!(\n        \"cannot serialize {} scalar outside struct \\\n         when writing headers from structs\",\n        name\n    ))\n}","Real(LocalPath(\"src/serializer.rs\"))"],"serializer::serialize":["/// Serialize the given value to the given writer, and return an error if\n/// anything went wrong.\npub fn serialize<S: Serialize, W: io::Write>(\n    wtr: &mut Writer<W>,\n    value: S,\n) -> Result<(), Error>{\n    value.serialize(&mut SeRecord { wtr: wtr })\n}","Real(LocalPath(\"src/serializer.rs\"))"],"serializer::serialize_header":["/// Write header names corresponding to the field names of the value (if the\n/// value has field names).\n///\n/// If the type to be serialized has field names (e.g. it's a struct), then\n/// header names are written, and the `Ok` return value is `true`.\n///\n/// If the type to be serialized doesn't have field names, then nothing is\n/// written, and the `Ok` return value is `false`.\npub fn serialize_header<S: Serialize, W: io::Write>(\n    wtr: &mut Writer<W>,\n    value: S,\n) -> Result<bool, Error>{\n    let mut ser = SeHeader::new(wtr);\n    value.serialize(&mut ser).map(|_| ser.wrote_header())\n}","Real(LocalPath(\"src/serializer.rs\"))"],"string_record::StringRecord":["/// A single CSV record stored as valid UTF-8 bytes.\n///\n/// A string record permits reading or writing CSV rows that are valid UTF-8.\n/// If string records are used to read CSV data that is not valid UTF-8, then\n/// the CSV reader will return an invalid UTF-8 error. If you do need to read\n/// possibly invalid UTF-8 data, then you should prefer using a\n/// [`ByteRecord`](struct.ByteRecord.html),\n/// since it makes no assumptions about UTF-8.\n///\n/// If you are using the Serde (de)serialization APIs, then you probably never\n/// need to interact with a `ByteRecord` or a `StringRecord`. However, there\n/// are some circumstances in which you might need to use a raw record type\n/// while still using Serde. For example, if you need to deserialize possibly\n/// invalid UTF-8 fields, then you'll need to first read your record into a\n/// `ByteRecord`, and then use `ByteRecord::deserialize` to run Serde. Another\n/// reason for using the raw record deserialization APIs is if you're using\n/// Serde to read into borrowed data such as a `&'a str` or a `&'a [u8]`.\n///\n/// Two `StringRecord`s are compared on the basis of their field data. Any\n/// position information associated with the records is ignored.\npub struct StringRecord(ByteRecord);","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::as_byte_record":["/// Return a reference to this record's raw\n/// [`ByteRecord`](struct.ByteRecord.html).\n///\n/// # Example\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let str_record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// let byte_record = str_record.as_byte_record();\n/// assert_eq!(&byte_record[2], b\"c\");\n/// ```\n#[inline]\npub fn as_byte_record(&self) -> &ByteRecord{\n        &self.0\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::as_slice":["/// Return the entire row as a single string slice. The slice returned\n/// stores all fields contiguously. The boundaries of each field can be\n/// determined via the `range` method.\n///\n/// # Example\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let record = StringRecord::from(vec![\"foo\", \"quux\", \"z\"]);\n/// assert_eq!(record.as_slice(), \"fooquuxz\");\n/// ```\n#[inline]\npub fn as_slice(&self) -> &str{\n        debug_assert!(str::from_utf8(self.0.as_slice()).is_ok());\n        // This is safe because we guarantee that each field is valid UTF-8.\n        // If each field is valid UTF-8, then the entire buffer (up to the end\n        // of the last field) must also be valid UTF-8.\n        unsafe { str::from_utf8_unchecked(self.0.as_slice()) }\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::clear":["/// Clear this record so that it has zero fields.\n///\n/// Note that it is not necessary to clear the record to reuse it with\n/// the CSV reader.\n///\n/// # Example\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let mut record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// assert_eq!(record.len(), 3);\n/// record.clear();\n/// assert_eq!(record.len(), 0);\n/// ```\n#[inline]\npub fn clear(&mut self){\n        self.0.clear();\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::deserialize":["/// Deserialize this record.\n///\n/// The `D` type parameter refers to the type that this record should be\n/// deserialized into. The `'de` lifetime refers to the lifetime of the\n/// `StringRecord`. The `'de` lifetime permits deserializing into structs\n/// that borrow field data from this record.\n///\n/// An optional `headers` parameter permits deserializing into a struct\n/// based on its field names (corresponding to header values) rather than\n/// the order in which the fields are defined.\n///\n/// # Example: without headers\n///\n/// This shows how to deserialize a single row into a struct based on the\n/// order in which fields occur. This example also shows how to borrow\n/// fields from the `StringRecord`, which results in zero allocation\n/// deserialization.\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::StringRecord;\n/// use serde::Deserialize;\n///\n/// #[derive(Deserialize)]\n/// struct Row<'a> {\n///     city: &'a str,\n///     country: &'a str,\n///     population: u64,\n/// }\n///\n/// # fn main() { example().unwrap() }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let record = StringRecord::from(vec![\n///         \"Boston\", \"United States\", \"4628910\",\n///     ]);\n///\n///     let row: Row = record.deserialize(None)?;\n///     assert_eq!(row.city, \"Boston\");\n///     assert_eq!(row.country, \"United States\");\n///     assert_eq!(row.population, 4628910);\n///     Ok(())\n/// }\n/// ```\n///\n/// # Example: with headers\n///\n/// This example is like the previous one, but shows how to deserialize\n/// into a struct based on the struct's field names. For this to work,\n/// you must provide a header row.\n///\n/// This example also shows that you can deserialize into owned data\n/// types (e.g., `String`) instead of borrowed data types (e.g., `&str`).\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::StringRecord;\n/// use serde::Deserialize;\n///\n/// #[derive(Deserialize)]\n/// struct Row {\n///     city: String,\n///     country: String,\n///     population: u64,\n/// }\n///\n/// # fn main() { example().unwrap() }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     // Notice that the fields are not in the same order\n///     // as the fields in the struct!\n///     let header = StringRecord::from(vec![\n///         \"country\", \"city\", \"population\",\n///     ]);\n///     let record = StringRecord::from(vec![\n///         \"United States\", \"Boston\", \"4628910\",\n///     ]);\n///\n///     let row: Row = record.deserialize(Some(&header))?;\n///     assert_eq!(row.city, \"Boston\");\n///     assert_eq!(row.country, \"United States\");\n///     assert_eq!(row.population, 4628910);\n///     Ok(())\n/// }\n/// ```\npub fn deserialize<'de, D: Deserialize<'de>>(\n        &'de self,\n        headers: Option<&'de StringRecord>,\n    ) -> Result<D>{\n        deserialize_string_record(self, headers)\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::from_byte_record":["/// Create a new `StringRecord` from a `ByteRecord`.\n///\n/// Note that this does UTF-8 validation. If the given `ByteRecord` does\n/// not contain valid UTF-8, then this returns an error. The error includes\n/// the UTF-8 error and the original `ByteRecord`.\n///\n/// # Example: valid UTF-8\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{ByteRecord, StringRecord};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let byte_record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n///     let str_record = StringRecord::from_byte_record(byte_record)?;\n///     assert_eq!(str_record.len(), 3);\n///     Ok(())\n/// }\n/// ```\n///\n/// # Example: invalid UTF-8\n///\n/// ```\n/// use csv::{ByteRecord, StringRecord};\n///\n/// let byte_record = ByteRecord::from(vec![\n///     &b\"quux\"[..], &b\"foo\\xFFbar\"[..], &b\"c\"[..],\n/// ]);\n/// let err = StringRecord::from_byte_record(byte_record).unwrap_err();\n/// assert_eq!(err.utf8_error().field(), 1);\n/// assert_eq!(err.utf8_error().valid_up_to(), 3);\n/// ```\n#[inline]\npub fn from_byte_record(\n        record: ByteRecord,\n    ) -> result::Result<StringRecord, FromUtf8Error>{\n        match record.validate() {\n            Ok(()) => Ok(StringRecord(record)),\n            Err(err) => Err(FromUtf8Error::new(record, err)),\n        }\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::from_byte_record_lossy":["/// Lossily create a new `StringRecord` from a `ByteRecord`.\n///\n/// This is like `StringRecord::from_byte_record`, except all invalid UTF-8\n/// sequences are replaced with the `U+FFFD REPLACEMENT CHARACTER`, which\n/// looks like this: .\n///\n/// # Example: valid UTF-8\n///\n/// ```\n/// use csv::{ByteRecord, StringRecord};\n///\n/// let byte_record = ByteRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// let str_record = StringRecord::from_byte_record_lossy(byte_record);\n/// assert_eq!(str_record.len(), 3);\n/// ```\n///\n/// # Example: invalid UTF-8\n///\n/// ```\n/// use csv::{ByteRecord, StringRecord};\n///\n/// let byte_record = ByteRecord::from(vec![\n///     &b\"quux\"[..], &b\"foo\\xFFbar\"[..], &b\"c\"[..],\n/// ]);\n/// let str_record = StringRecord::from_byte_record_lossy(byte_record);\n/// assert_eq!(&str_record[0], \"quux\");\n/// assert_eq!(&str_record[1], \"foobar\");\n/// assert_eq!(&str_record[2], \"c\");\n/// ```\n#[inline]\npub fn from_byte_record_lossy(record: ByteRecord) -> StringRecord{\n        // If the record is valid UTF-8, then take the easy path.\n        if let Ok(()) = record.validate() {\n            return StringRecord(record);\n        }\n        // TODO: We can be faster here. Not sure if it's worth it.\n        let mut str_record =\n            StringRecord::with_capacity(record.as_slice().len(), record.len());\n        for field in &record {\n            str_record.push_field(&String::from_utf8_lossy(field));\n        }\n        str_record\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::get":["/// Return the field at index `i`.\n///\n/// If no field at index `i` exists, then this returns `None`.\n///\n/// # Example\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// assert_eq!(record.get(1), Some(\"b\"));\n/// assert_eq!(record.get(3), None);\n/// ```\n#[inline]\npub fn get(&self, i: usize) -> Option<&str>{\n        self.0.get(i).map(|bytes| {\n            debug_assert!(str::from_utf8(bytes).is_ok());\n            // This is safe because we guarantee that all string records\n            // have a valid UTF-8 buffer. It's also safe because we\n            // individually check each field for valid UTF-8.\n            unsafe { str::from_utf8_unchecked(bytes) }\n        })\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::into_byte_record":["/// Convert this `StringRecord` into a\n/// [`ByteRecord`](struct.ByteRecord.html).\n///\n/// # Example\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let str_record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// let byte_record = str_record.into_byte_record();\n/// assert_eq!(&byte_record[2], b\"c\");\n/// ```\n///\n/// Note that this can also be achieved using the `From` impl:\n///\n/// ```\n/// use csv::{ByteRecord, StringRecord};\n///\n/// // Using ByteRecord::from...\n/// let str_record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// assert_eq!(ByteRecord::from(str_record).len(), 3);\n///\n/// // Using StringRecord::into...\n/// let str_record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// let byte_record: ByteRecord = str_record.into();\n/// assert_eq!(byte_record.len(), 3);\n/// ```\n#[inline]\npub fn into_byte_record(self) -> ByteRecord{\n        self.0\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::is_empty":["/// Returns true if and only if this record is empty.\n///\n/// # Example\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// assert!(StringRecord::new().is_empty());\n/// ```\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::iter":["/// Returns an iterator over all fields in this record.\n///\n/// # Example\n///\n/// This example shows how to iterate over each field in a `StringRecord`.\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// for field in record.iter() {\n///     assert!(field == \"a\" || field == \"b\" || field == \"c\");\n/// }\n/// ```\n#[inline]\npub fn iter(&self) -> StringRecordIter{\n        self.into_iter()\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::len":["/// Returns the number of fields in this record.\n///\n/// # Example\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// assert_eq!(record.len(), 3);\n/// ```\n#[inline]\npub fn len(&self) -> usize{\n        self.0.len()\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::new":["/// Create a new empty `StringRecord`.\n///\n/// Note that you may find the `StringRecord::from` constructor more\n/// convenient, which is provided by an impl on the `From` trait.\n///\n/// # Example: create an empty record\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let record = StringRecord::new();\n/// assert_eq!(record.len(), 0);\n/// ```\n///\n/// # Example: initialize a record from a `Vec`\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// assert_eq!(record.len(), 3);\n/// ```\n#[inline]\npub fn new() -> StringRecord{\n        StringRecord(ByteRecord::new())\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::position":["/// Return the position of this record, if available.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{StringRecord, ReaderBuilder};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut record = StringRecord::new();\n///     let mut rdr = ReaderBuilder::new()\n///         .has_headers(false)\n///         .from_reader(\"a,b,c\\nx,y,z\".as_bytes());\n///\n///     assert!(rdr.read_record(&mut record)?);\n///     {\n///         let pos = record.position().expect(\"a record position\");\n///         assert_eq!(pos.byte(), 0);\n///         assert_eq!(pos.line(), 1);\n///         assert_eq!(pos.record(), 0);\n///     }\n///\n///     assert!(rdr.read_record(&mut record)?);\n///     {\n///         let pos = record.position().expect(\"a record position\");\n///         assert_eq!(pos.byte(), 6);\n///         assert_eq!(pos.line(), 2);\n///         assert_eq!(pos.record(), 1);\n///     }\n///\n///     // Finish the CSV reader for good measure.\n///     assert!(!rdr.read_record(&mut record)?);\n///     Ok(())\n/// }\n/// ```\n#[inline]\npub fn position(&self) -> Option<&Position>{\n        self.0.position()\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::push_field":["/// Add a new field to this record.\n///\n/// # Example\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let mut record = StringRecord::new();\n/// record.push_field(\"foo\");\n/// assert_eq!(&record[0], \"foo\");\n/// ```\n#[inline]\npub fn push_field(&mut self, field: &str){\n        self.0.push_field(field.as_bytes());\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::range":["/// Return the start and end position of a field in this record.\n///\n/// If no such field exists at the given index, then return `None`.\n///\n/// The range returned can be used with the slice returned by `as_slice`.\n/// Namely, the range returned is guaranteed to start and end at valid\n/// UTF-8 sequence boundaries.\n///\n/// # Example\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let record = StringRecord::from(vec![\"foo\", \"quux\", \"z\"]);\n/// let range = record.range(1).expect(\"a record range\");\n/// assert_eq!(&record.as_slice()[range], \"quux\");\n/// ```\n#[inline]\npub fn range(&self, i: usize) -> Option<Range<usize>>{\n        self.0.range(i)\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::read":["/// A safe function for reading CSV data into a `StringRecord`.\n///\n/// This relies on the internal representation of `StringRecord`.\n#[inline(always)]\npub(crate) fn read<R: io::Read>(\n        &mut self,\n        rdr: &mut Reader<R>,\n    ) -> Result<bool>{\n        // SAFETY: This code is critical to upholding the safety of other code\n        // blocks in this module. Namely, after calling `read_byte_record`,\n        // it is possible for `record` to contain invalid UTF-8. We check for\n        // this in the `validate` method, and if it does have invalid UTF-8, we\n        // clear the record. (It is bad for `record` to contain invalid UTF-8\n        // because other accessor methods, like `get`, assume that every field\n        // is valid UTF-8.)\n        let pos = rdr.position().clone();\n        let read_res = rdr.read_byte_record(&mut self.0);\n        let utf8_res = match self.0.validate() {\n            Ok(()) => Ok(()),\n            Err(err) => {\n                // If this record isn't valid UTF-8, then completely wipe it.\n                self.0.clear();\n                Err(err)\n            }\n        };\n        match (read_res, utf8_res) {\n            (Err(err), _) => Err(err),\n            (Ok(_), Err(err)) => {\n                Err(Error::new(ErrorKind::Utf8 { pos: Some(pos), err: err }))\n            }\n            (Ok(eof), Ok(())) => Ok(eof),\n        }\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::set_position":["/// Set the position of this record.\n///\n/// # Example\n///\n/// ```\n/// use csv::{StringRecord, Position};\n///\n/// let mut record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// let mut pos = Position::new();\n/// pos.set_byte(100);\n/// pos.set_line(4);\n/// pos.set_record(2);\n///\n/// record.set_position(Some(pos.clone()));\n/// assert_eq!(record.position(), Some(&pos));\n/// ```\n#[inline]\npub fn set_position(&mut self, pos: Option<Position>){\n        self.0.set_position(pos);\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::trim":["/// Trim the fields of this record so that leading and trailing whitespace\n/// is removed.\n///\n/// This method uses the Unicode definition of whitespace.\n///\n/// # Example\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let mut record = StringRecord::from(vec![\n///     \"  \", \"\\u{3000}\\tfoo \", \"bar  \", \"b a z\",\n/// ]);\n/// record.trim();\n/// assert_eq!(record, vec![\"\", \"foo\", \"bar\", \"b a z\"]);\n/// ```\npub fn trim(&mut self){\n        let length = self.len();\n        if length == 0 {\n            return;\n        }\n        // TODO: We could likely do this in place, but for now, we allocate.\n        let mut trimmed =\n            StringRecord::with_capacity(self.as_slice().len(), self.len());\n        trimmed.set_position(self.position().cloned());\n        for field in &*self {\n            trimmed.push_field(field.trim());\n        }\n        *self = trimmed;\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::truncate":["/// Truncate this record to `n` fields.\n///\n/// If `n` is greater than the number of fields in this record, then this\n/// has no effect.\n///\n/// # Example\n///\n/// ```\n/// use csv::StringRecord;\n///\n/// let mut record = StringRecord::from(vec![\"a\", \"b\", \"c\"]);\n/// assert_eq!(record.len(), 3);\n/// record.truncate(1);\n/// assert_eq!(record.len(), 1);\n/// assert_eq!(record, vec![\"a\"]);\n/// ```\n#[inline]\npub fn truncate(&mut self, n: usize){\n        self.0.truncate(n);\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecord::with_capacity":["/// Create a new empty `StringRecord` with the given capacity.\n///\n/// `buffer` refers to the capacity of the buffer used to store the\n/// actual row contents. `fields` refers to the number of fields one\n/// might expect to store.\n#[inline]\npub fn with_capacity(buffer: usize, fields: usize) -> StringRecord{\n        StringRecord(ByteRecord::with_capacity(buffer, fields))\n    }","Real(LocalPath(\"src/string_record.rs\"))"],"string_record::StringRecordIter":["/// An iterator over the fields in a string record.\n///\n/// The `'r` lifetime variable refers to the lifetime of the `StringRecord`\n/// that is being iterated over.\npub struct StringRecordIter<'r>(ByteRecordIter<'r>);","Real(LocalPath(\"src/string_record.rs\"))"],"writer::Buffer":["/// A simple internal buffer for buffering writes.\n///\n/// We need this because the `csv_core` APIs want to write into a `&mut [u8]`,\n/// which is not available with the `std::io::BufWriter` API.\nstruct Buffer {\n    /// The contents of the buffer.\n    buf: Vec<u8>,\n    /// The number of bytes written to the buffer.\n    len: usize,\n}","Real(LocalPath(\"src/writer.rs\"))"],"writer::Buffer::clear":["/// Clear the buffer.\n#[inline]\nfn clear(&mut self){\n        self.len = 0;\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Buffer::readable":["/// Returns a slice of the buffer's current contents.\n///\n/// The slice returned may be empty.\n#[inline]\nfn readable(&self) -> &[u8]{\n        &self.buf[..self.len]\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Buffer::writable":["/// Returns a mutable slice of the remaining space in this buffer.\n///\n/// The slice returned may be empty.\n#[inline]\nfn writable(&mut self) -> &mut [u8]{\n        &mut self.buf[self.len..]\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Buffer::written":["/// Indicates that `n` bytes have been written to this buffer.\n#[inline]\nfn written(&mut self, n: usize){\n        self.len += n;\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::HeaderState":["/// HeaderState encodes a small state machine for handling header writes.\nenum HeaderState {\n    /// Indicates that we should attempt to write a header.\n    Write,\n    /// Indicates that writing a header was attempt, and a header was written.\n    DidWrite,\n    /// Indicates that writing a header was attempted, but no headers were\n    /// written or the attempt failed.\n    DidNotWrite,\n    /// This state is used when headers are disabled. It cannot transition\n    /// to any other state.\n    None,\n}","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer":["/// A already configured CSV writer.\n///\n/// A CSV writer takes as input Rust values and writes those values in a valid\n/// CSV format as output.\n///\n/// While CSV writing is considerably easier than parsing CSV, a proper writer\n/// will do a number of things for you:\n///\n/// 1. Quote fields when necessary.\n/// 2. Check that all records have the same number of fields.\n/// 3. Write records with a single empty field correctly.\n/// 4. Automatically serialize normal Rust types to CSV records. When that\n///    type is a struct, a header row is automatically written corresponding\n///    to the fields of that struct.\n/// 5. Use buffering intelligently and otherwise avoid allocation. (This means\n///    that callers should not do their own buffering.)\n///\n/// All of the above can be configured using a\n/// [`WriterBuilder`](struct.WriterBuilder.html).\n/// However, a `Writer` has a couple of convenience constructors (`from_path`\n/// and `from_writer`) that use the default configuration.\n///\n/// Note that the default configuration of a `Writer` uses `\\n` for record\n/// terminators instead of `\\r\\n` as specified by RFC 4180. Use the\n/// `terminator` method on `WriterBuilder` to set the terminator to `\\r\\n` if\n/// it's desired.\npub struct Writer<W: io::Write> {\n    core: CoreWriter,\n    wtr: Option<W>,\n    buf: Buffer,\n    state: WriterState,\n}","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::check_field_count":["fn check_field_count(&mut self) -> Result<()>{\n        if !self.state.flexible {\n            match self.state.first_field_count {\n                None => {\n                    self.state.first_field_count =\n                        Some(self.state.fields_written);\n                }\n                Some(expected) if expected != self.state.fields_written => {\n                    return Err(Error::new(ErrorKind::UnequalLengths {\n                        pos: None,\n                        expected_len: expected,\n                        len: self.state.fields_written,\n                    }))\n                }\n                Some(_) => {}\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::flush":["/// Flush the contents of the internal buffer to the underlying writer.\n///\n/// If there was a problem writing to the underlying writer, then an error\n/// is returned.\n///\n/// Note that this also flushes the underlying writer.\npub fn flush(&mut self) -> io::Result<()>{\n        self.flush_buf()?;\n        self.wtr.as_mut().unwrap().flush()?;\n        Ok(())\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::flush_buf":["/// Flush the contents of the internal buffer to the underlying writer,\n/// without flushing the underlying writer.\nfn flush_buf(&mut self) -> io::Result<()>{\n        self.state.panicked = true;\n        let result = self.wtr.as_mut().unwrap().write_all(self.buf.readable());\n        self.state.panicked = false;\n        result?;\n        self.buf.clear();\n        Ok(())\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::from_writer":["/// Build a CSV writer with a default configuration that writes data to\n/// `wtr`.\n///\n/// Note that the CSV writer is buffered automatically, so you should not\n/// wrap `wtr` in a buffered writer like `io::BufWriter`.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::Writer;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = Writer::from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n///     Ok(())\n/// }\n/// ```\npub fn from_writer(wtr: W) -> Writer<W>{\n        WriterBuilder::new().from_writer(wtr)\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::into_inner":["/// Flush the contents of the internal buffer and return the underlying\n/// writer.\npub fn into_inner(\n        mut self,\n    ) -> result::Result<W, IntoInnerError<Writer<W>>>{\n        match self.flush() {\n            Ok(()) => Ok(self.wtr.take().unwrap()),\n            Err(err) => Err(IntoInnerError::new(self, err)),\n        }\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::new":["fn new(builder: &WriterBuilder, wtr: W) -> Writer<W>{\n        let header_state = if builder.has_headers {\n            HeaderState::Write\n        } else {\n            HeaderState::None\n        };\n        Writer {\n            core: builder.builder.build(),\n            wtr: Some(wtr),\n            buf: Buffer { buf: vec![0; builder.capacity], len: 0 },\n            state: WriterState {\n                header: header_state,\n                flexible: builder.flexible,\n                first_field_count: None,\n                fields_written: 0,\n                panicked: false,\n            },\n        }\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::serialize":["/// Serialize a single record using Serde.\n///\n/// # Example\n///\n/// This shows how to serialize normal Rust structs as CSV records. The\n/// fields of the struct are used to write a header row automatically.\n/// (Writing the header row automatically can be disabled by building the\n/// CSV writer with a [`WriterBuilder`](struct.WriterBuilder.html) and\n/// calling the `has_headers` method.)\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::Writer;\n/// use serde::Serialize;\n///\n/// #[derive(Serialize)]\n/// struct Row<'a> {\n///     city: &'a str,\n///     country: &'a str,\n///     // Serde allows us to name our headers exactly,\n///     // even if they don't match our struct field names.\n///     #[serde(rename = \"popcount\")]\n///     population: u64,\n/// }\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = Writer::from_writer(vec![]);\n///     wtr.serialize(Row {\n///         city: \"Boston\",\n///         country: \"United States\",\n///         population: 4628910,\n///     })?;\n///     wtr.serialize(Row {\n///         city: \"Concord\",\n///         country: \"United States\",\n///         population: 42695,\n///     })?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"\\\n/// city,country,popcount\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \");\n///     Ok(())\n/// }\n/// ```\n///\n/// # Rules\n///\n/// The behavior of `serialize` is fairly simple:\n///\n/// 1. Nested containers (tuples, `Vec`s, structs, etc.) are always\n///    flattened (depth-first order).\n///\n/// 2. If `has_headers` is `true` and the type contains field names, then\n///    a header row is automatically generated.\n///\n/// However, some container types cannot be serialized, and if\n/// `has_headers` is `true`, there are some additional restrictions on the\n/// types that can be serialized. See below for details.\n///\n/// For the purpose of this section, Rust types can be divided into three\n/// categories: scalars, non-struct containers, and structs.\n///\n/// ## Scalars\n///\n/// Single values with no field names are written like the following. Note\n/// that some of the outputs may be quoted, according to the selected\n/// quoting style.\n///\n/// | Name | Example Type | Example Value | Output |\n/// | ---- | ---- | ---- | ---- |\n/// | boolean | `bool` | `true` | `true` |\n/// | integers | `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128` | `5` | `5` |\n/// | floats | `f32`, `f64` | `3.14` | `3.14` |\n/// | character | `char` | `''` | `` |\n/// | string | `&str` | `\"hi\"` | `hi` |\n/// | bytes | `&[u8]` | `b\"hi\"[..]` | `hi` |\n/// | option | `Option` | `None` | *empty* |\n/// | option |          | `Some(5)` | `5` |\n/// | unit | `()` | `()` | *empty* |\n/// | unit struct | `struct Foo;` | `Foo` | `Foo` |\n/// | unit enum variant | `enum E { A, B }` | `E::A` | `A` |\n/// | newtype struct | `struct Foo(u8);` | `Foo(5)` | `5` |\n/// | newtype enum variant | `enum E { A(u8) }` | `E::A(5)` | `5` |\n///\n/// Note that this table includes simple structs and enums. For example, to\n/// serialize a field from either an integer or a float type, one can do\n/// this:\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::Writer;\n/// use serde::Serialize;\n///\n/// #[derive(Serialize)]\n/// struct Row {\n///     label: String,\n///     value: Value,\n/// }\n///\n/// #[derive(Serialize)]\n/// enum Value {\n///     Integer(i64),\n///     Float(f64),\n/// }\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = Writer::from_writer(vec![]);\n///     wtr.serialize(Row {\n///         label: \"foo\".to_string(),\n///         value: Value::Integer(3),\n///     })?;\n///     wtr.serialize(Row {\n///         label: \"bar\".to_string(),\n///         value: Value::Float(3.14),\n///     })?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"\\\n/// label,value\n/// foo,3\n/// bar,3.14\n/// \");\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Non-Struct Containers\n///\n/// Nested containers are flattened to their scalar components, with the\n/// exeption of a few types that are not allowed:\n///\n/// | Name | Example Type | Example Value | Output |\n/// | ---- | ---- | ---- | ---- |\n/// | sequence | `Vec<u8>` | `vec![1, 2, 3]` | `1,2,3` |\n/// | tuple | `(u8, bool)` | `(5, true)` | `5,true` |\n/// | tuple struct | `Foo(u8, bool)` | `Foo(5, true)` | `5,true` |\n/// | tuple enum variant | `enum E { A(u8, bool) }` | `E::A(5, true)` | *error* |\n/// | struct enum variant | `enum E { V { a: u8, b: bool } }` | `E::V { a: 5, b: true }` | *error* |\n/// | map | `BTreeMap<K, V>` | `BTreeMap::new()` | *error* |\n///\n/// ## Structs\n///\n/// Like the other containers, structs are flattened to their scalar\n/// components:\n///\n/// | Name | Example Type | Example Value | Output |\n/// | ---- | ---- | ---- | ---- |\n/// | struct | `struct Foo { a: u8, b: bool }` | `Foo { a: 5, b: true }` | `5,true` |\n///\n/// If `has_headers` is `false`, then there are no additional restrictions;\n/// types can be nested arbitrarily. For example:\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::WriterBuilder;\n/// use serde::Serialize;\n///\n/// #[derive(Serialize)]\n/// struct Row {\n///     label: String,\n///     values: Vec<f64>,\n/// }\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new()\n///         .has_headers(false)\n///         .from_writer(vec![]);\n///     wtr.serialize(Row {\n///         label: \"foo\".to_string(),\n///         values: vec![1.1234, 2.5678, 3.14],\n///     })?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"\\\n/// foo,1.1234,2.5678,3.14\n/// \");\n///     Ok(())\n/// }\n/// ```\n///\n/// However, if `has_headers` were enabled in the above example, then\n/// serialization would return an error. Speficially, when `has_headers` is\n/// `true`, there are two restrictions:\n///\n/// 1. Named field values in structs must be scalars.\n///\n/// 2. All scalars must be named field values in structs.\n///\n/// Other than these two restrictions, types can be nested arbitrarily.\n/// Here are a few examples:\n///\n/// | Value | Header | Record |\n/// | ---- | ---- | ---- |\n/// | `(Foo { x: 5, y: 6 }, Bar { z: true })` | `x,y,z` | `5,6,true` |\n/// | `vec![Foo { x: 5, y: 6 }, Foo { x: 7, y: 8 }]` | `x,y,x,y` | `5,6,7,8` |\n/// | `(Foo { x: 5, y: 6 }, vec![Bar { z: Baz(true) }])` | `x,y,z` | `5,6,true` |\n/// | `Foo { x: 5, y: (6, 7) }` | *error: restriction 1* | `5,6,7` |\n/// | `(5, Foo { x: 6, y: 7 }` | *error: restriction 2* | `5,6,7` |\n/// | `(Foo { x: 5, y: 6 }, true)` | *error: restriction 2* | `5,6,true` |\npub fn serialize<S: Serialize>(&mut self, record: S) -> Result<()>{\n        if let HeaderState::Write = self.state.header {\n            let wrote_header = serialize_header(self, &record)?;\n            if wrote_header {\n                self.write_terminator()?;\n                self.state.header = HeaderState::DidWrite;\n            } else {\n                self.state.header = HeaderState::DidNotWrite;\n            };\n        }\n        serialize(self, &record)?;\n        self.write_terminator()?;\n        Ok(())\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::write_byte_record":["/// Write a single `ByteRecord`.\n///\n/// This method accepts a borrowed `ByteRecord` and writes its contents\n/// to the underlying writer.\n///\n/// This is similar to `write_record` except that it specifically requires\n/// a `ByteRecord`. This permits the writer to possibly write the record\n/// more quickly than the more generic `write_record`.\n///\n/// This may be called with an empty record, which will cause a record\n/// terminator to be written. If no fields had been written, then a single\n/// empty field is written before the terminator.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{ByteRecord, Writer};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = Writer::from_writer(vec![]);\n///     wtr.write_byte_record(&ByteRecord::from(&[\"a\", \"b\", \"c\"][..]))?;\n///     wtr.write_byte_record(&ByteRecord::from(&[\"x\", \"y\", \"z\"][..]))?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n///     Ok(())\n/// }\n/// ```\n#[inline(never)]\npub fn write_byte_record(&mut self, record: &ByteRecord) -> Result<()>{\n        if record.as_slice().is_empty() {\n            return self.write_record(record);\n        }\n        // The idea here is to find a fast path for shuffling our record into\n        // our buffer as quickly as possible. We do this because the underlying\n        // \"core\" CSV writer does a lot of book-keeping to maintain its state\n        // oriented API.\n        //\n        // The fast path occurs when we know our record will fit in whatever\n        // space we have left in our buffer. We can actually quickly compute\n        // the upper bound on the space required:\n        let upper_bound =\n            // The data itself plus the worst case: every byte is a quote.\n            (2 * record.as_slice().len())\n            // The number of field delimiters.\n            + (record.len().saturating_sub(1))\n            // The maximum number of quotes inserted around each field.\n            + (2 * record.len())\n            // The maximum number of bytes for the terminator.\n            + 2;\n        if self.buf.writable().len() < upper_bound {\n            return self.write_record(record);\n        }\n        let mut first = true;\n        for field in record.iter() {\n            if !first {\n                self.buf.writable()[0] = self.core.get_delimiter();\n                self.buf.written(1);\n            }\n            first = false;\n\n            if !self.core.should_quote(field) {\n                self.buf.writable()[..field.len()].copy_from_slice(field);\n                self.buf.written(field.len());\n            } else {\n                self.buf.writable()[0] = self.core.get_quote();\n                self.buf.written(1);\n                let (res, nin, nout) = csv_core::quote(\n                    field,\n                    self.buf.writable(),\n                    self.core.get_quote(),\n                    self.core.get_escape(),\n                    self.core.get_double_quote(),\n                );\n                debug_assert!(res == WriteResult::InputEmpty);\n                debug_assert!(nin == field.len());\n                self.buf.written(nout);\n                self.buf.writable()[0] = self.core.get_quote();\n                self.buf.written(1);\n            }\n        }\n        self.state.fields_written = record.len() as u64;\n        self.write_terminator_into_buffer()\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::write_delimiter":["/// Write a CSV delimiter.\nfn write_delimiter(&mut self) -> Result<()>{\n        loop {\n            let (res, nout) = self.core.delimiter(self.buf.writable());\n            self.buf.written(nout);\n            match res {\n                WriteResult::InputEmpty => return Ok(()),\n                WriteResult::OutputFull => self.flush_buf()?,\n            }\n        }\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::write_field":["/// Write a single field.\n///\n/// One should prefer using `write_record` over this method. It is provided\n/// for cases where writing a field at a time is more convenient than\n/// writing a record at a time.\n///\n/// Note that if this API is used, `write_record` should be called with an\n/// empty iterator to write a record terminator.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::Writer;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = Writer::from_writer(vec![]);\n///     wtr.write_field(\"a\")?;\n///     wtr.write_field(\"b\")?;\n///     wtr.write_field(\"c\")?;\n///     wtr.write_record(None::<&[u8]>)?;\n///     wtr.write_field(\"x\")?;\n///     wtr.write_field(\"y\")?;\n///     wtr.write_field(\"z\")?;\n///     wtr.write_record(None::<&[u8]>)?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n///     Ok(())\n/// }\n/// ```\npub fn write_field<T: AsRef<[u8]>>(&mut self, field: T) -> Result<()>{\n        self.write_field_impl(field)\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::write_field_impl":["/// Implementation of write_field.\n///\n/// This is a separate method so we can force the compiler to inline it\n/// into write_record.\n#[inline(always)]\nfn write_field_impl<T: AsRef<[u8]>>(&mut self, field: T) -> Result<()>{\n        if self.state.fields_written > 0 {\n            self.write_delimiter()?;\n        }\n        let mut field = field.as_ref();\n        loop {\n            let (res, nin, nout) = self.core.field(field, self.buf.writable());\n            field = &field[nin..];\n            self.buf.written(nout);\n            match res {\n                WriteResult::InputEmpty => {\n                    self.state.fields_written += 1;\n                    return Ok(());\n                }\n                WriteResult::OutputFull => self.flush_buf()?,\n            }\n        }\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::write_record":["/// Write a single record.\n///\n/// This method accepts something that can be turned into an iterator that\n/// yields elements that can be represented by a `&[u8]`.\n///\n/// This may be called with an empty iterator, which will cause a record\n/// terminator to be written. If no fields had been written, then a single\n/// empty field is written before the terminator.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::Writer;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = Writer::from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n///     Ok(())\n/// }\n/// ```\npub fn write_record<I, T>(&mut self, record: I) -> Result<()>\n    where\n        I: IntoIterator<Item = T>,\n        T: AsRef<[u8]>,{\n        for field in record.into_iter() {\n            self.write_field_impl(field)?;\n        }\n        self.write_terminator()\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::write_terminator":["/// Write a CSV terminator.\nfn write_terminator(&mut self) -> Result<()>{\n        self.check_field_count()?;\n        loop {\n            let (res, nout) = self.core.terminator(self.buf.writable());\n            self.buf.written(nout);\n            match res {\n                WriteResult::InputEmpty => {\n                    self.state.fields_written = 0;\n                    return Ok(());\n                }\n                WriteResult::OutputFull => self.flush_buf()?,\n            }\n        }\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<W>::write_terminator_into_buffer":["/// Write a CSV terminator that is guaranteed to fit into the current\n/// buffer.\n#[inline(never)]\nfn write_terminator_into_buffer(&mut self) -> Result<()>{\n        self.check_field_count()?;\n        match self.core.get_terminator() {\n            csv_core::Terminator::CRLF => {\n                self.buf.writable()[0] = b'\\r';\n                self.buf.writable()[1] = b'\\n';\n                self.buf.written(2);\n            }\n            csv_core::Terminator::Any(b) => {\n                self.buf.writable()[0] = b;\n                self.buf.written(1);\n            }\n            _ => unreachable!(),\n        }\n        self.state.fields_written = 0;\n        Ok(())\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::Writer::<std::fs::File>::from_path":["/// Build a CSV writer with a default configuration that writes data to the\n/// given file path. The file is truncated if it already exists.\n///\n/// If there was a problem opening the file at the given path, then this\n/// returns the corresponding error.\n///\n/// # Example\n///\n/// ```no_run\n/// use std::error::Error;\n/// use csv::Writer;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = Writer::from_path(\"foo.csv\")?;\n///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n///     wtr.flush()?;\n///     Ok(())\n/// }\n/// ```\npub fn from_path<P: AsRef<Path>>(path: P) -> Result<Writer<File>>{\n        WriterBuilder::new().from_path(path)\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder":["/// Builds a CSV writer with various configuration knobs.\n///\n/// This builder can be used to tweak the field delimiter, record terminator\n/// and more. Once a CSV `Writer` is built, its configuration cannot be\n/// changed.\npub struct WriterBuilder {\n    builder: CoreWriterBuilder,\n    capacity: usize,\n    flexible: bool,\n    has_headers: bool,\n}","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::buffer_capacity":["/// Set the capacity (in bytes) of the internal buffer used in the CSV\n/// writer. This defaults to a reasonable setting.\npub fn buffer_capacity(&mut self, capacity: usize) -> &mut WriterBuilder{\n        self.capacity = capacity;\n        self\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::delimiter":["/// The field delimiter to use when writing CSV.\n///\n/// The default is `b','`.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::WriterBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new()\n///         .delimiter(b';')\n///         .from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a;b;c\\nx;y;z\\n\");\n///     Ok(())\n/// }\n/// ```\npub fn delimiter(&mut self, delimiter: u8) -> &mut WriterBuilder{\n        self.builder.delimiter(delimiter);\n        self\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::double_quote":["/// Enable double quote escapes.\n///\n/// This is enabled by default, but it may be disabled. When disabled,\n/// quotes in field data are escaped instead of doubled.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::WriterBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new()\n///         .double_quote(false)\n///         .from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"foo\\\"bar\", \"c\"])?;\n///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,\\\"foo\\\\\\\"bar\\\",c\\nx,y,z\\n\");\n///     Ok(())\n/// }\n/// ```\npub fn double_quote(&mut self, yes: bool) -> &mut WriterBuilder{\n        self.builder.double_quote(yes);\n        self\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::escape":["/// The escape character to use when writing CSV.\n///\n/// In some variants of CSV, quotes are escaped using a special escape\n/// character like `\\` (instead of escaping quotes by doubling them).\n///\n/// By default, writing these idiosyncratic escapes is disabled, and is\n/// only used when `double_quote` is disabled.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::WriterBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new()\n///         .double_quote(false)\n///         .escape(b'$')\n///         .from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"foo\\\"bar\", \"c\"])?;\n///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,\\\"foo$\\\"bar\\\",c\\nx,y,z\\n\");\n///     Ok(())\n/// }\n/// ```\npub fn escape(&mut self, escape: u8) -> &mut WriterBuilder{\n        self.builder.escape(escape);\n        self\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::flexible":["/// Whether the number of fields in records is allowed to change or not.\n///\n/// When disabled (which is the default), writing CSV data will return an\n/// error if a record is written with a number of fields different from the\n/// number of fields written in a previous record.\n///\n/// When enabled, this error checking is turned off.\n///\n/// # Example: writing flexible records\n///\n/// ```\n/// use std::error::Error;\n/// use csv::WriterBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new()\n///         .flexible(true)\n///         .from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"b\"])?;\n///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,b\\nx,y,z\\n\");\n///     Ok(())\n/// }\n/// ```\n///\n/// # Example: error when `flexible` is disabled\n///\n/// ```\n/// use std::error::Error;\n/// use csv::WriterBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new()\n///         .flexible(false)\n///         .from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"b\"])?;\n///     let err = wtr.write_record(&[\"x\", \"y\", \"z\"]).unwrap_err();\n///     match *err.kind() {\n///         csv::ErrorKind::UnequalLengths { expected_len, len, .. } => {\n///             assert_eq!(expected_len, 2);\n///             assert_eq!(len, 3);\n///         }\n///         ref wrong => {\n///             panic!(\"expected UnequalLengths but got {:?}\", wrong);\n///         }\n///     }\n///     Ok(())\n/// }\n/// ```\npub fn flexible(&mut self, yes: bool) -> &mut WriterBuilder{\n        self.flexible = yes;\n        self\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::from_path":["/// Build a CSV writer from this configuration that writes data to the\n/// given file path. The file is truncated if it already exists.\n///\n/// If there was a problem opening the file at the given path, then this\n/// returns the corresponding error.\n///\n/// # Example\n///\n/// ```no_run\n/// use std::error::Error;\n/// use csv::WriterBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new().from_path(\"foo.csv\")?;\n///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n///     wtr.flush()?;\n///     Ok(())\n/// }\n/// ```\npub fn from_path<P: AsRef<Path>>(&self, path: P) -> Result<Writer<File>>{\n        Ok(Writer::new(self, File::create(path)?))\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::from_writer":["/// Build a CSV writer from this configuration that writes data to `wtr`.\n///\n/// Note that the CSV writer is buffered automatically, so you should not\n/// wrap `wtr` in a buffered writer like `io::BufWriter`.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::WriterBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new().from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n///     Ok(())\n/// }\n/// ```\npub fn from_writer<W: io::Write>(&self, wtr: W) -> Writer<W>{\n        Writer::new(self, wtr)\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::has_headers":["/// Whether to write a header row before writing any other row.\n///\n/// When this is enabled and the `serialize` method is used to write data\n/// with something that contains field names (i.e., a struct), then a\n/// header row is written containing the field names before any other row\n/// is written.\n///\n/// This option has no effect when using other methods to write rows. That\n/// is, if you don't use `serialize`, then you must write your header row\n/// explicitly if you want a header row.\n///\n/// This is enabled by default.\n///\n/// # Example: with headers\n///\n/// This shows how the header will be automatically written from the field\n/// names of a struct.\n///\n/// ```\n/// use std::error::Error;\n///\n/// use csv::WriterBuilder;\n/// use serde::Serialize;\n///\n/// #[derive(Serialize)]\n/// struct Row<'a> {\n///     city: &'a str,\n///     country: &'a str,\n///     // Serde allows us to name our headers exactly,\n///     // even if they don't match our struct field names.\n///     #[serde(rename = \"popcount\")]\n///     population: u64,\n/// }\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new().from_writer(vec![]);\n///     wtr.serialize(Row {\n///         city: \"Boston\",\n///         country: \"United States\",\n///         population: 4628910,\n///     })?;\n///     wtr.serialize(Row {\n///         city: \"Concord\",\n///         country: \"United States\",\n///         population: 42695,\n///     })?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"\\\n/// city,country,popcount\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \");\n///     Ok(())\n/// }\n/// ```\n///\n/// # Example: without headers\n///\n/// This shows that serializing things that aren't structs (in this case,\n/// a tuple struct) won't result in a header row being written. This means\n/// you usually don't need to set `has_headers(false)` unless you\n/// explicitly want to both write custom headers and serialize structs.\n///\n/// ```\n/// use std::error::Error;\n/// use csv::WriterBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new().from_writer(vec![]);\n///     wtr.serialize((\"Boston\", \"United States\", 4628910))?;\n///     wtr.serialize((\"Concord\", \"United States\", 42695))?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"\\\n/// Boston,United States,4628910\n/// Concord,United States,42695\n/// \");\n///     Ok(())\n/// }\n/// ```\npub fn has_headers(&mut self, yes: bool) -> &mut WriterBuilder{\n        self.has_headers = yes;\n        self\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::new":["/// Create a new builder for configuring CSV writing.\n///\n/// To convert a builder into a writer, call one of the methods starting\n/// with `from_`.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::WriterBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new().from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,b,c\\nx,y,z\\n\");\n///     Ok(())\n/// }\n/// ```\npub fn new() -> WriterBuilder{\n        WriterBuilder::default()\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::quote":["/// The quote character to use when writing CSV.\n///\n/// The default is `b'\"'`.\n///\n/// # Example\n///\n/// ```\n/// use std::error::Error;\n/// use csv::WriterBuilder;\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new()\n///         .quote(b'\\'')\n///         .from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"foo\\nbar\", \"c\"])?;\n///     wtr.write_record(&[\"g'h'i\", \"y\\\"y\\\"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,'foo\\nbar',c\\n'g''h''i',y\\\"y\\\"y,z\\n\");\n///     Ok(())\n/// }\n/// ```\npub fn quote(&mut self, quote: u8) -> &mut WriterBuilder{\n        self.builder.quote(quote);\n        self\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::quote_style":["/// The quoting style to use when writing CSV.\n///\n/// By default, this is set to `QuoteStyle::Necessary`, which will only\n/// use quotes when they are necessary to preserve the integrity of data.\n///\n/// Note that unless the quote style is set to `Never`, an empty field is\n/// quoted if it is the only field in a record.\n///\n/// # Example: non-numeric quoting\n///\n/// This shows how to quote non-numeric fields only.\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{QuoteStyle, WriterBuilder};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new()\n///         .quote_style(QuoteStyle::NonNumeric)\n///         .from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"5\", \"c\"])?;\n///     wtr.write_record(&[\"3.14\", \"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"\\\"a\\\",5,\\\"c\\\"\\n3.14,\\\"y\\\",\\\"z\\\"\\n\");\n///     Ok(())\n/// }\n/// ```\n///\n/// # Example: never quote\n///\n/// This shows how the CSV writer can be made to never write quotes, even\n/// if it sacrifices the integrity of the data.\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{QuoteStyle, WriterBuilder};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new()\n///         .quote_style(QuoteStyle::Never)\n///         .from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"foo\\nbar\", \"c\"])?;\n///     wtr.write_record(&[\"g\\\"h\\\"i\", \"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,foo\\nbar,c\\ng\\\"h\\\"i,y,z\\n\");\n///     Ok(())\n/// }\n/// ```\npub fn quote_style(&mut self, style: QuoteStyle) -> &mut WriterBuilder{\n        self.builder.quote_style(style.to_core());\n        self\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterBuilder::terminator":["/// The record terminator to use when writing CSV.\n///\n/// A record terminator can be any single byte. The default is `\\n`.\n///\n/// Note that RFC 4180 specifies that record terminators should be `\\r\\n`.\n/// To use `\\r\\n`, use the special `Terminator::CRLF` value.\n///\n/// # Example: CRLF\n///\n/// This shows how to use RFC 4180 compliant record terminators.\n///\n/// ```\n/// use std::error::Error;\n/// use csv::{Terminator, WriterBuilder};\n///\n/// # fn main() { example().unwrap(); }\n/// fn example() -> Result<(), Box<dyn Error>> {\n///     let mut wtr = WriterBuilder::new()\n///         .terminator(Terminator::CRLF)\n///         .from_writer(vec![]);\n///     wtr.write_record(&[\"a\", \"b\", \"c\"])?;\n///     wtr.write_record(&[\"x\", \"y\", \"z\"])?;\n///\n///     let data = String::from_utf8(wtr.into_inner()?)?;\n///     assert_eq!(data, \"a,b,c\\r\\nx,y,z\\r\\n\");\n///     Ok(())\n/// }\n/// ```\npub fn terminator(&mut self, term: Terminator) -> &mut WriterBuilder{\n        self.builder.terminator(term.to_core());\n        self\n    }","Real(LocalPath(\"src/writer.rs\"))"],"writer::WriterState":["struct WriterState {\n    /// Whether the Serde serializer should attempt to write a header row.\n    header: HeaderState,\n    /// Whether inconsistent record lengths are allowed.\n    flexible: bool,\n    /// The number of fields writtein in the first record. This is compared\n    /// with `fields_written` on all subsequent records to check for\n    /// inconsistent record lengths.\n    first_field_count: Option<u64>,\n    /// The number of fields written in this record. This is used to report\n    /// errors for inconsistent record lengths if `flexible` is disabled.\n    fields_written: u64,\n    /// This is set immediately before flushing the buffer and then unset\n    /// immediately after flushing the buffer. This avoids flushing the buffer\n    /// twice if the inner writer panics.\n    panicked: bool,\n}","Real(LocalPath(\"src/writer.rs\"))"]},"struct_constructor":{"&'r [u8]":["next","next_back","next_field_bytes","next_header_bytes","peek_field"],"&'r str":["next","next_back","next_field","next_header"],"&(dyn std::error::Error + 'static)":["source"],"&[u8]":["as_slice","get","index","readable"],"&[usize]":["ends"],"&byte_record::ByteRecord":["as_byte_record","byte_headers"],"&byte_record::Position":["position"],"&deserializer::DeserializeErrorKind":["kind"],"&error::ErrorKind":["kind"],"&error::Utf8Error":["utf8_error"],"&mut [u8]":["writable"],"&std::io::Error":["error"],"&str":["as_slice","description","get","index"],"&string_record::StringRecord":["headers"],"(&mut std::vec::Vec<u8>, &mut std::vec::Vec<usize>)":["as_parts"],"(<V as serde::de::DeserializeSeed<'de>>::Value, <&'a mut deserializer::DeRecordWrap<T> as serde::de::EnumAccess<'de>>::Variant)":["variant_seed"],"(usize, std::option::Option<usize>)":["size_hint"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::Ok":["serialize_bool","serialize_bytes","serialize_char","serialize_f32","serialize_f64","serialize_i128","serialize_i16","serialize_i32","serialize_i64","serialize_i8","serialize_newtype_struct","serialize_newtype_variant","serialize_none","serialize_some","serialize_str","serialize_u128","serialize_u16","serialize_u32","serialize_u64","serialize_u8","serialize_unit","serialize_unit_struct","serialize_unit_variant"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::SerializeMap":["serialize_map"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::SerializeSeq":["serialize_seq"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::SerializeStruct":["serialize_struct"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::SerializeStructVariant":["serialize_struct_variant"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::SerializeTuple":["serialize_tuple"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::SerializeTupleStruct":["serialize_tuple_struct"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::SerializeTupleVariant":["serialize_tuple_variant"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeMap>::Ok":["end"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeSeq>::Ok":["end"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStruct>::Ok":["end"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStructVariant>::Ok":["end"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTuple>::Ok":["end"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleStruct>::Ok":["end"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleVariant>::Ok":["end"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::Ok":["serialize_bool","serialize_bytes","serialize_char","serialize_f32","serialize_f64","serialize_i128","serialize_i16","serialize_i32","serialize_i64","serialize_i8","serialize_newtype_struct","serialize_newtype_variant","serialize_none","serialize_some","serialize_str","serialize_u128","serialize_u16","serialize_u32","serialize_u64","serialize_u8","serialize_unit","serialize_unit_struct","serialize_unit_variant"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::SerializeMap":["serialize_map"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::SerializeSeq":["serialize_seq"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::SerializeStruct":["serialize_struct"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::SerializeStructVariant":["serialize_struct_variant"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::SerializeTuple":["serialize_tuple"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::SerializeTupleStruct":["serialize_tuple_struct"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::SerializeTupleVariant":["serialize_tuple_variant"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeMap>::Ok":["end"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeSeq>::Ok":["end"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStruct>::Ok":["end"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStructVariant>::Ok":["end"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTuple>::Ok":["end"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleStruct>::Ok":["end"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleVariant>::Ok":["end"],"<K as serde::de::DeserializeSeed<'de>>::Value":["next_key_seed","next_value_seed"],"<U as serde::de::DeserializeSeed<'de>>::Value":["newtype_variant_seed","next_element_seed"],"<V as serde::de::Visitor<'de>>::Value":["deserialize_any","deserialize_bool","deserialize_byte_buf","deserialize_bytes","deserialize_char","deserialize_enum","deserialize_f32","deserialize_f64","deserialize_i128","deserialize_i16","deserialize_i32","deserialize_i64","deserialize_i8","deserialize_identifier","deserialize_ignored_any","deserialize_map","deserialize_newtype_struct","deserialize_option","deserialize_seq","deserialize_str","deserialize_string","deserialize_struct","deserialize_tuple","deserialize_tuple_struct","deserialize_u128","deserialize_u16","deserialize_u32","deserialize_u64","deserialize_u8","deserialize_unit","deserialize_unit_struct","infer_deserialize","struct_variant","tuple_variant"],"QuoteStyle":["clone","default"],"Terminator":["clone","default"],"Trim":["clone","default"],"bool":["eq","has_headers","is_done","is_empty","is_io_error","iter_eq","read","read_byte_record","read_byte_record_impl","read_record","serialize_header","should_trim_fields","should_trim_headers","wrote_header"],"byte_record::Bounds":["clone","default","with_capacity"],"byte_record::ByteRecord":["clone","default","from","from_iter","into_byte_record","new","next","with_capacity"],"byte_record::ByteRecordInner":["clone"],"byte_record::ByteRecordIter":["into_iter","iter"],"byte_record::Position":["clone","new"],"csv_core::QuoteStyle":["to_core"],"csv_core::Terminator":["to_core"],"deserializer::DeserializeError":["clone","custom","error"],"deserializer::DeserializeErrorKind":["clone"],"error::Error":["custom","error_container_inside_struct","error_scalar_outside_struct","from","new"],"error::ErrorKind":["into_kind"],"error::FromUtf8Error":["clone","new"],"error::IntoInnerError":["new"],"error::Utf8Error":["clone","new_utf8_error"],"f64":["try_float","try_float_bytes"],"i128":["try_negative_integer128","try_negative_integer128_bytes"],"i64":["try_negative_integer64","try_negative_integer64_bytes"],"reader::ByteRecordsIntoIter":["into_byte_records","new"],"reader::ByteRecordsIter":["byte_records","new"],"reader::DeserializeRecordsIntoIter":["into_deserialize","new"],"reader::DeserializeRecordsIter":["deserialize","new"],"reader::Reader":["from_path","from_reader","into_reader","new"],"reader::ReaderBuilder":["default","new"],"reader::StringRecordsIntoIter":["into_records","new"],"reader::StringRecordsIter":["new","records"],"serializer::SeHeader":["new"],"std::io::Error":["from"],"std::ops::Range":["get","range"],"string_record::StringRecord":["clone","default","from","from_byte_record","from_byte_record_lossy","from_iter","new","next","with_capacity"],"string_record::StringRecordIter":["into_iter","iter"],"u128":["try_positive_integer128","try_positive_integer128_bytes"],"u64":["byte","field","line","record","try_positive_integer64","try_positive_integer64_bytes"],"usize":["count","end","field","len","valid_up_to"],"writer::Writer":["from_path","from_writer","new"],"writer::WriterBuilder":["default","new"]},"struct_to_trait":{"QuoteStyle":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::marker::Copy"],"Terminator":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::marker::Copy"],"Trim":["std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"byte_record::Bounds":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"byte_record::ByteRecord":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::default::Default","std::fmt::Debug","std::iter::Extend","std::iter::FromIterator","std::marker::StructuralEq","std::ops::Index"],"byte_record::ByteRecordInner":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"byte_record::ByteRecordIter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"byte_record::Position":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"deserializer::DeByteRecord":["deserializer::DeRecord"],"deserializer::DeRecordWrap":["deserializer::DeRecord"],"deserializer::DeStringRecord":["deserializer::DeRecord"],"deserializer::DeserializeError":["serde::de::Error","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"deserializer::DeserializeErrorKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::Error":["serde::ser::Error","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display"],"error::ErrorKind":["std::fmt::Debug"],"error::FromUtf8Error":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::IntoInnerError":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"error::Utf8Error":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"reader::ByteRecordsIntoIter":["std::iter::Iterator"],"reader::ByteRecordsIter":["std::iter::Iterator"],"reader::DeserializeRecordsIntoIter":["std::iter::Iterator"],"reader::DeserializeRecordsIter":["std::iter::Iterator"],"reader::Headers":["std::fmt::Debug"],"reader::Reader":["std::fmt::Debug"],"reader::ReaderBuilder":["std::default::Default","std::fmt::Debug"],"reader::ReaderState":["std::fmt::Debug"],"reader::StringRecordsIntoIter":["std::iter::Iterator"],"reader::StringRecordsIter":["std::iter::Iterator"],"std::io::Error":["std::convert::From"],"string_record::StringRecord":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::default::Default","std::fmt::Debug","std::iter::Extend","std::iter::FromIterator","std::marker::StructuralEq","std::ops::Index"],"string_record::StringRecordIter":["std::iter::DoubleEndedIterator","std::iter::Iterator"],"writer::Buffer":["std::fmt::Debug"],"writer::HeaderState":["std::fmt::Debug"],"writer::Writer":["std::fmt::Debug","std::ops::Drop"],"writer::WriterBuilder":["std::default::Default","std::fmt::Debug"],"writer::WriterState":["std::fmt::Debug"]},"targets":{"<&'a byte_record::ByteRecord as std::cmp::PartialEq<[T]>>::eq":["eq","Real(LocalPath(\"src/byte_record.rs\"))","std::cmp::PartialEq"],"<&'a byte_record::ByteRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["eq","Real(LocalPath(\"src/byte_record.rs\"))","std::cmp::PartialEq"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_any":["deserialize_any","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_char":["deserialize_char","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i128":["deserialize_i128","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_map":["deserialize_map","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_option":["deserialize_option","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_str":["deserialize_str","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_string":["deserialize_string","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u128":["deserialize_u128","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::Deserializer<'de>>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"src/deserializer.rs\"))","serde::Deserializer"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::EnumAccess<'de>>::variant_seed":["variant_seed","Real(LocalPath(\"src/deserializer.rs\"))","serde::de::EnumAccess"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::MapAccess<'de>>::next_key_seed":["next_key_seed","Real(LocalPath(\"src/deserializer.rs\"))","serde::de::MapAccess"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::MapAccess<'de>>::next_value_seed":["next_value_seed","Real(LocalPath(\"src/deserializer.rs\"))","serde::de::MapAccess"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::SeqAccess<'de>>::next_element_seed":["next_element_seed","Real(LocalPath(\"src/deserializer.rs\"))","serde::de::SeqAccess"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["newtype_variant_seed","Real(LocalPath(\"src/deserializer.rs\"))","serde::de::VariantAccess"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::struct_variant":["struct_variant","Real(LocalPath(\"src/deserializer.rs\"))","serde::de::VariantAccess"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::tuple_variant":["tuple_variant","Real(LocalPath(\"src/deserializer.rs\"))","serde::de::VariantAccess"],"<&'a mut deserializer::DeRecordWrap<T> as serde::de::VariantAccess<'de>>::unit_variant":["unit_variant","Real(LocalPath(\"src/deserializer.rs\"))","serde::de::VariantAccess"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_bool":["serialize_bool","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_bytes":["serialize_bytes","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_char":["serialize_char","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_f32":["serialize_f32","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_f64":["serialize_f64","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i128":["serialize_i128","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i16":["serialize_i16","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i32":["serialize_i32","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i64":["serialize_i64","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_i8":["serialize_i8","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_map":["serialize_map","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_newtype_struct":["serialize_newtype_struct","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_newtype_variant":["serialize_newtype_variant","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_none":["serialize_none","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_seq":["serialize_seq","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_some":["serialize_some","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_str":["serialize_str","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_struct":["serialize_struct","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_struct_variant":["serialize_struct_variant","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_tuple":["serialize_tuple","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_tuple_struct":["serialize_tuple_struct","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_tuple_variant":["serialize_tuple_variant","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u128":["serialize_u128","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u16":["serialize_u16","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u32":["serialize_u32","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u64":["serialize_u64","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_u8":["serialize_u8","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_unit":["serialize_unit","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_unit_struct":["serialize_unit_struct","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::Serializer>::serialize_unit_variant":["serialize_unit_variant","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeMap>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeMap"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeMap>::serialize_key":["serialize_key","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeMap"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeMap>::serialize_value":["serialize_value","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeMap"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeSeq>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeSeq"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeSeq>::serialize_element":["serialize_element","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeSeq"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStruct>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeStruct"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStruct>::serialize_field":["serialize_field","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeStruct"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStructVariant>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeStructVariant"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeStructVariant>::serialize_field":["serialize_field","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeStructVariant"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTuple>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTuple"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTuple>::serialize_element":["serialize_element","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTuple"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleStruct>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTupleStruct"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleStruct>::serialize_field":["serialize_field","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTupleStruct"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleVariant>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTupleVariant"],"<&'a mut serializer::SeHeader<'w, W> as serde::ser::SerializeTupleVariant>::serialize_field":["serialize_field","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTupleVariant"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_bool":["serialize_bool","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_bytes":["serialize_bytes","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_char":["serialize_char","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_f32":["serialize_f32","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_f64":["serialize_f64","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i128":["serialize_i128","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i16":["serialize_i16","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i32":["serialize_i32","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i64":["serialize_i64","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_i8":["serialize_i8","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_map":["serialize_map","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_newtype_struct":["serialize_newtype_struct","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_newtype_variant":["serialize_newtype_variant","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_none":["serialize_none","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_seq":["serialize_seq","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_some":["serialize_some","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_str":["serialize_str","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_struct":["serialize_struct","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_struct_variant":["serialize_struct_variant","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_tuple":["serialize_tuple","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_tuple_struct":["serialize_tuple_struct","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_tuple_variant":["serialize_tuple_variant","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u128":["serialize_u128","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u16":["serialize_u16","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u32":["serialize_u32","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u64":["serialize_u64","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_u8":["serialize_u8","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_unit":["serialize_unit","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_unit_struct":["serialize_unit_struct","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::Serializer>::serialize_unit_variant":["serialize_unit_variant","Real(LocalPath(\"src/serializer.rs\"))","serde::Serializer"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeMap>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeMap"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeMap>::serialize_key":["serialize_key","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeMap"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeMap>::serialize_value":["serialize_value","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeMap"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeSeq>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeSeq"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeSeq>::serialize_element":["serialize_element","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeSeq"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStruct>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeStruct"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStruct>::serialize_field":["serialize_field","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeStruct"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStructVariant>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeStructVariant"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeStructVariant>::serialize_field":["serialize_field","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeStructVariant"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTuple>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTuple"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTuple>::serialize_element":["serialize_element","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTuple"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleStruct>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTupleStruct"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleStruct>::serialize_field":["serialize_field","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTupleStruct"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleVariant>::end":["end","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTupleVariant"],"<&'a mut serializer::SeRecord<'w, W> as serde::ser::SerializeTupleVariant>::serialize_field":["serialize_field","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::SerializeTupleVariant"],"<&'a string_record::StringRecord as std::cmp::PartialEq<[T]>>::eq":["eq","Real(LocalPath(\"src/string_record.rs\"))","std::cmp::PartialEq"],"<&'a string_record::StringRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["eq","Real(LocalPath(\"src/string_record.rs\"))","std::cmp::PartialEq"],"<&'a string_record::StringRecord as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/string_record.rs\"))","std::iter::IntoIterator"],"<&'r byte_record::ByteRecord as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/byte_record.rs\"))","std::iter::IntoIterator"],"<QuoteStyle as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<Terminator as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<Trim as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<byte_record::Bounds as std::default::Default>::default":["default","Real(LocalPath(\"src/byte_record.rs\"))","std::default::Default"],"<byte_record::ByteRecord as std::cmp::PartialEq<[T]>>::eq":["eq","Real(LocalPath(\"src/byte_record.rs\"))","std::cmp::PartialEq"],"<byte_record::ByteRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["eq","Real(LocalPath(\"src/byte_record.rs\"))","std::cmp::PartialEq"],"<byte_record::ByteRecord as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/byte_record.rs\"))","std::cmp::PartialEq"],"<byte_record::ByteRecord as std::convert::From<&'a [T]>>::from":["from","Real(LocalPath(\"src/byte_record.rs\"))","std::convert::From"],"<byte_record::ByteRecord as std::convert::From<std::vec::Vec<T>>>::from":["from","Real(LocalPath(\"src/byte_record.rs\"))","std::convert::From"],"<byte_record::ByteRecord as std::convert::From<string_record::StringRecord>>::from":["from","Real(LocalPath(\"src/byte_record.rs\"))","std::convert::From"],"<byte_record::ByteRecord as std::default::Default>::default":["default","Real(LocalPath(\"src/byte_record.rs\"))","std::default::Default"],"<byte_record::ByteRecord as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/byte_record.rs\"))","std::fmt::Debug"],"<byte_record::ByteRecord as std::iter::Extend<T>>::extend":["extend","Real(LocalPath(\"src/byte_record.rs\"))","std::iter::Extend"],"<byte_record::ByteRecord as std::iter::FromIterator<T>>::from_iter":["from_iter","Real(LocalPath(\"src/byte_record.rs\"))","std::iter::FromIterator"],"<byte_record::ByteRecord as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/byte_record.rs\"))","std::ops::Index"],"<byte_record::ByteRecordIter<'r> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/byte_record.rs\"))","std::iter::DoubleEndedIterator"],"<byte_record::ByteRecordIter<'r> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/byte_record.rs\"))","std::iter::Iterator"],"<byte_record::ByteRecordIter<'r> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/byte_record.rs\"))","std::iter::Iterator"],"<byte_record::ByteRecordIter<'r> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/byte_record.rs\"))","std::iter::Iterator"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::error":["error","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::has_headers":["has_headers","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::infer_deserialize":["infer_deserialize","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_field":["next_field","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_field_bytes":["next_field_bytes","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_header":["next_header","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::next_header_bytes":["next_header_bytes","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeByteRecord<'r> as deserializer::DeRecord<'r>>::peek_field":["peek_field","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::error":["error","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::has_headers":["has_headers","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::infer_deserialize":["infer_deserialize","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_field":["next_field","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_field_bytes":["next_field_bytes","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_header":["next_header","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::next_header_bytes":["next_header_bytes","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeRecordWrap<T> as deserializer::DeRecord<'r>>::peek_field":["peek_field","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::error":["error","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::has_headers":["has_headers","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::infer_deserialize":["infer_deserialize","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_field":["next_field","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_field_bytes":["next_field_bytes","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_header":["next_header","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::next_header_bytes":["next_header_bytes","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeStringRecord<'r> as deserializer::DeRecord<'r>>::peek_field":["peek_field","Real(LocalPath(\"src/deserializer.rs\"))","deserializer::DeRecord"],"<deserializer::DeserializeError as serde::de::Error>::custom":["custom","Real(LocalPath(\"src/deserializer.rs\"))","serde::de::Error"],"<deserializer::DeserializeError as std::error::Error>::description":["description","Real(LocalPath(\"src/deserializer.rs\"))","std::error::Error"],"<deserializer::DeserializeError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/deserializer.rs\"))","std::fmt::Display"],"<deserializer::DeserializeErrorKind as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/deserializer.rs\"))","std::fmt::Display"],"<error::Error as std::convert::From<std::io::Error>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::error::Error>::source":["source","Real(LocalPath(\"src/error.rs\"))","std::error::Error"],"<error::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::FromUtf8Error as std::error::Error>::source":["source","Real(LocalPath(\"src/error.rs\"))","std::error::Error"],"<error::FromUtf8Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::IntoInnerError<W> as std::error::Error>::source":["source","Real(LocalPath(\"src/error.rs\"))","std::error::Error"],"<error::IntoInnerError<W> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Debug"],"<error::IntoInnerError<W> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::Utf8Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<reader::ByteRecordsIntoIter<R> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/reader.rs\"))","std::iter::Iterator"],"<reader::ByteRecordsIter<'r, R> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/reader.rs\"))","std::iter::Iterator"],"<reader::DeserializeRecordsIntoIter<R, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/reader.rs\"))","std::iter::Iterator"],"<reader::DeserializeRecordsIter<'r, R, D> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/reader.rs\"))","std::iter::Iterator"],"<reader::ReaderBuilder as std::default::Default>::default":["default","Real(LocalPath(\"src/reader.rs\"))","std::default::Default"],"<reader::StringRecordsIntoIter<R> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/reader.rs\"))","std::iter::Iterator"],"<reader::StringRecordsIter<'r, R> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/reader.rs\"))","std::iter::Iterator"],"<string_record::StringRecord as std::cmp::PartialEq<[T]>>::eq":["eq","Real(LocalPath(\"src/string_record.rs\"))","std::cmp::PartialEq"],"<string_record::StringRecord as std::cmp::PartialEq<std::vec::Vec<T>>>::eq":["eq","Real(LocalPath(\"src/string_record.rs\"))","std::cmp::PartialEq"],"<string_record::StringRecord as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/string_record.rs\"))","std::cmp::PartialEq"],"<string_record::StringRecord as std::convert::From<&'a [T]>>::from":["from","Real(LocalPath(\"src/string_record.rs\"))","std::convert::From"],"<string_record::StringRecord as std::convert::From<std::vec::Vec<T>>>::from":["from","Real(LocalPath(\"src/string_record.rs\"))","std::convert::From"],"<string_record::StringRecord as std::default::Default>::default":["default","Real(LocalPath(\"src/string_record.rs\"))","std::default::Default"],"<string_record::StringRecord as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/string_record.rs\"))","std::fmt::Debug"],"<string_record::StringRecord as std::iter::Extend<T>>::extend":["extend","Real(LocalPath(\"src/string_record.rs\"))","std::iter::Extend"],"<string_record::StringRecord as std::iter::FromIterator<T>>::from_iter":["from_iter","Real(LocalPath(\"src/string_record.rs\"))","std::iter::FromIterator"],"<string_record::StringRecord as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/string_record.rs\"))","std::ops::Index"],"<string_record::StringRecordIter<'r> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/string_record.rs\"))","std::iter::DoubleEndedIterator"],"<string_record::StringRecordIter<'r> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/string_record.rs\"))","std::iter::Iterator"],"<string_record::StringRecordIter<'r> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/string_record.rs\"))","std::iter::Iterator"],"<string_record::StringRecordIter<'r> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/string_record.rs\"))","std::iter::Iterator"],"<writer::Writer<W> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/writer.rs\"))","std::ops::Drop"],"<writer::WriterBuilder as std::default::Default>::default":["default","Real(LocalPath(\"src/writer.rs\"))","std::default::Default"],"QuoteStyle::to_core":["to_core","Real(LocalPath(\"src/lib.rs\"))",""],"Terminator::to_core":["to_core","Real(LocalPath(\"src/lib.rs\"))",""],"Trim::should_trim_fields":["should_trim_fields","Real(LocalPath(\"src/lib.rs\"))",""],"Trim::should_trim_headers":["should_trim_headers","Real(LocalPath(\"src/lib.rs\"))",""],"byte_record::Bounds::add":["add","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Bounds::end":["end","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Bounds::ends":["ends","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Bounds::expand":["expand","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Bounds::get":["get","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Bounds::len":["len","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Bounds::with_capacity":["with_capacity","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::as_parts":["as_parts","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::as_slice":["as_slice","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::clear":["clear","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::deserialize":["deserialize","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::expand_ends":["expand_ends","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::expand_fields":["expand_fields","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::get":["get","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::is_empty":["is_empty","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::iter":["iter","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::iter_eq":["iter_eq","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::len":["len","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::new":["new","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::position":["position","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::push_field":["push_field","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::range":["range","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::set_len":["set_len","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::set_position":["set_position","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::trim":["trim","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::truncate":["truncate","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::validate":["validate","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::ByteRecord::with_capacity":["with_capacity","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Position::byte":["byte","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Position::line":["line","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Position::new":["new","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Position::record":["record","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Position::set_byte":["set_byte","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Position::set_line":["set_line","Real(LocalPath(\"src/byte_record.rs\"))",""],"byte_record::Position::set_record":["set_record","Real(LocalPath(\"src/byte_record.rs\"))",""],"deserializer::DeserializeError::field":["field","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::DeserializeError::kind":["kind","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::DeserializeErrorKind::description":["description","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::deserialize_byte_record":["deserialize_byte_record","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::deserialize_string_record":["deserialize_string_record","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::try_float":["try_float","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::try_float_bytes":["try_float_bytes","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::try_negative_integer128":["try_negative_integer128","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::try_negative_integer128_bytes":["try_negative_integer128_bytes","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::try_negative_integer64":["try_negative_integer64","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::try_negative_integer64_bytes":["try_negative_integer64_bytes","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::try_positive_integer128":["try_positive_integer128","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::try_positive_integer128_bytes":["try_positive_integer128_bytes","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::try_positive_integer64":["try_positive_integer64","Real(LocalPath(\"src/deserializer.rs\"))",""],"deserializer::try_positive_integer64_bytes":["try_positive_integer64_bytes","Real(LocalPath(\"src/deserializer.rs\"))",""],"error::<impl std::convert::From<error::Error> for std::io::Error>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"error::Error::into_kind":["into_kind","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::is_io_error":["is_io_error","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::kind":["kind","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::new":["new","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::position":["position","Real(LocalPath(\"src/error.rs\"))",""],"error::ErrorKind::position":["position","Real(LocalPath(\"src/error.rs\"))",""],"error::FromUtf8Error::into_byte_record":["into_byte_record","Real(LocalPath(\"src/error.rs\"))",""],"error::FromUtf8Error::new":["new","Real(LocalPath(\"src/error.rs\"))",""],"error::FromUtf8Error::utf8_error":["utf8_error","Real(LocalPath(\"src/error.rs\"))",""],"error::IntoInnerError::<W>::error":["error","Real(LocalPath(\"src/error.rs\"))",""],"error::IntoInnerError::<W>::into_inner":["into_inner","Real(LocalPath(\"src/error.rs\"))",""],"error::IntoInnerError::<W>::new":["new","Real(LocalPath(\"src/error.rs\"))",""],"error::Utf8Error::field":["field","Real(LocalPath(\"src/error.rs\"))",""],"error::Utf8Error::valid_up_to":["valid_up_to","Real(LocalPath(\"src/error.rs\"))",""],"error::new_utf8_error":["new_utf8_error","Real(LocalPath(\"src/error.rs\"))",""],"invalid_option":["invalid_option","Real(LocalPath(\"src/lib.rs\"))",""],"reader::ByteRecordsIntoIter::<R>::into_reader":["into_reader","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ByteRecordsIntoIter::<R>::new":["new","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ByteRecordsIntoIter::<R>::reader":["reader","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ByteRecordsIntoIter::<R>::reader_mut":["reader_mut","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ByteRecordsIter::<'r, R>::new":["new","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ByteRecordsIter::<'r, R>::reader":["reader","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ByteRecordsIter::<'r, R>::reader_mut":["reader_mut","Real(LocalPath(\"src/reader.rs\"))",""],"reader::DeserializeRecordsIntoIter::<R, D>::into_reader":["into_reader","Real(LocalPath(\"src/reader.rs\"))",""],"reader::DeserializeRecordsIntoIter::<R, D>::new":["new","Real(LocalPath(\"src/reader.rs\"))",""],"reader::DeserializeRecordsIntoIter::<R, D>::reader":["reader","Real(LocalPath(\"src/reader.rs\"))",""],"reader::DeserializeRecordsIntoIter::<R, D>::reader_mut":["reader_mut","Real(LocalPath(\"src/reader.rs\"))",""],"reader::DeserializeRecordsIter::<'r, R, D>::new":["new","Real(LocalPath(\"src/reader.rs\"))",""],"reader::DeserializeRecordsIter::<'r, R, D>::reader":["reader","Real(LocalPath(\"src/reader.rs\"))",""],"reader::DeserializeRecordsIter::<'r, R, D>::reader_mut":["reader_mut","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::byte_headers":["byte_headers","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::byte_records":["byte_records","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::deserialize":["deserialize","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::from_reader":["from_reader","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::get_mut":["get_mut","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::get_ref":["get_ref","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::has_headers":["has_headers","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::headers":["headers","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::into_byte_records":["into_byte_records","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::into_deserialize":["into_deserialize","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::into_inner":["into_inner","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::into_records":["into_records","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::is_done":["is_done","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::new":["new","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::position":["position","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::read_byte_record":["read_byte_record","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::read_byte_record_impl":["read_byte_record_impl","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::read_record":["read_record","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::records":["records","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::seek":["seek","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::seek_raw":["seek_raw","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::set_byte_headers":["set_byte_headers","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::set_headers":["set_headers","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<R>::set_headers_impl":["set_headers_impl","Real(LocalPath(\"src/reader.rs\"))",""],"reader::Reader::<reader::Reader<std::fs::File>>::from_path":["from_path","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::ascii":["ascii","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::buffer_capacity":["buffer_capacity","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::comment":["comment","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::delimiter":["delimiter","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::double_quote":["double_quote","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::escape":["escape","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::flexible":["flexible","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::from_path":["from_path","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::from_reader":["from_reader","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::has_headers":["has_headers","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::new":["new","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::nfa":["nfa","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::quote":["quote","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::quoting":["quoting","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::terminator":["terminator","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderBuilder::trim":["trim","Real(LocalPath(\"src/reader.rs\"))",""],"reader::ReaderState::add_record":["add_record","Real(LocalPath(\"src/reader.rs\"))",""],"reader::StringRecordsIntoIter::<R>::into_reader":["into_reader","Real(LocalPath(\"src/reader.rs\"))",""],"reader::StringRecordsIntoIter::<R>::new":["new","Real(LocalPath(\"src/reader.rs\"))",""],"reader::StringRecordsIntoIter::<R>::reader":["reader","Real(LocalPath(\"src/reader.rs\"))",""],"reader::StringRecordsIntoIter::<R>::reader_mut":["reader_mut","Real(LocalPath(\"src/reader.rs\"))",""],"reader::StringRecordsIter::<'r, R>::new":["new","Real(LocalPath(\"src/reader.rs\"))",""],"reader::StringRecordsIter::<'r, R>::reader":["reader","Real(LocalPath(\"src/reader.rs\"))",""],"reader::StringRecordsIter::<'r, R>::reader_mut":["reader_mut","Real(LocalPath(\"src/reader.rs\"))",""],"serializer::<impl serde::ser::Error for error::Error>::custom":["custom","Real(LocalPath(\"src/serializer.rs\"))","serde::ser::Error"],"serializer::SeHeader::<'w, W>::handle_container":["handle_container","Real(LocalPath(\"src/serializer.rs\"))",""],"serializer::SeHeader::<'w, W>::handle_scalar":["handle_scalar","Real(LocalPath(\"src/serializer.rs\"))",""],"serializer::SeHeader::<'w, W>::new":["new","Real(LocalPath(\"src/serializer.rs\"))",""],"serializer::SeHeader::<'w, W>::wrote_header":["wrote_header","Real(LocalPath(\"src/serializer.rs\"))",""],"serializer::error_container_inside_struct":["error_container_inside_struct","Real(LocalPath(\"src/serializer.rs\"))",""],"serializer::error_scalar_outside_struct":["error_scalar_outside_struct","Real(LocalPath(\"src/serializer.rs\"))",""],"serializer::serialize":["serialize","Real(LocalPath(\"src/serializer.rs\"))",""],"serializer::serialize_header":["serialize_header","Real(LocalPath(\"src/serializer.rs\"))",""],"string_record::StringRecord::as_byte_record":["as_byte_record","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::as_slice":["as_slice","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::clear":["clear","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::deserialize":["deserialize","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::from_byte_record":["from_byte_record","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::from_byte_record_lossy":["from_byte_record_lossy","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::get":["get","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::into_byte_record":["into_byte_record","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::is_empty":["is_empty","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::iter":["iter","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::len":["len","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::new":["new","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::position":["position","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::push_field":["push_field","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::range":["range","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::read":["read","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::set_position":["set_position","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::trim":["trim","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::truncate":["truncate","Real(LocalPath(\"src/string_record.rs\"))",""],"string_record::StringRecord::with_capacity":["with_capacity","Real(LocalPath(\"src/string_record.rs\"))",""],"writer::Buffer::clear":["clear","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Buffer::readable":["readable","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Buffer::writable":["writable","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Buffer::written":["written","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::check_field_count":["check_field_count","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::flush":["flush","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::flush_buf":["flush_buf","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::from_writer":["from_writer","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::into_inner":["into_inner","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::new":["new","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::serialize":["serialize","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::write_byte_record":["write_byte_record","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::write_delimiter":["write_delimiter","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::write_field":["write_field","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::write_field_impl":["write_field_impl","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::write_record":["write_record","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::write_terminator":["write_terminator","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<W>::write_terminator_into_buffer":["write_terminator_into_buffer","Real(LocalPath(\"src/writer.rs\"))",""],"writer::Writer::<std::fs::File>::from_path":["from_path","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::buffer_capacity":["buffer_capacity","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::delimiter":["delimiter","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::double_quote":["double_quote","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::escape":["escape","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::flexible":["flexible","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::from_path":["from_path","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::from_writer":["from_writer","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::has_headers":["has_headers","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::new":["new","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::quote":["quote","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::quote_style":["quote_style","Real(LocalPath(\"src/writer.rs\"))",""],"writer::WriterBuilder::terminator":["terminator","Real(LocalPath(\"src/writer.rs\"))",""]},"trait_to_struct":{"deserializer::DeRecord":["deserializer::DeByteRecord","deserializer::DeRecordWrap","deserializer::DeStringRecord"],"serde::de::Error":["deserializer::DeserializeError"],"serde::ser::Error":["error::Error"],"std::clone::Clone":["QuoteStyle","Terminator","Trim","byte_record::Bounds","byte_record::ByteRecord","byte_record::ByteRecordInner","byte_record::Position","deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::FromUtf8Error","error::Utf8Error","string_record::StringRecord"],"std::cmp::Eq":["byte_record::Bounds","byte_record::ByteRecord","byte_record::ByteRecordInner","byte_record::Position","deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::FromUtf8Error","error::Utf8Error","string_record::StringRecord"],"std::cmp::PartialEq":["Trim","byte_record::Bounds","byte_record::ByteRecord","byte_record::ByteRecordInner","byte_record::Position","deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::FromUtf8Error","error::Utf8Error","string_record::StringRecord"],"std::convert::From":["byte_record::ByteRecord","error::Error","std::io::Error","string_record::StringRecord"],"std::default::Default":["QuoteStyle","Terminator","Trim","byte_record::Bounds","byte_record::ByteRecord","reader::ReaderBuilder","string_record::StringRecord","writer::WriterBuilder"],"std::error::Error":["deserializer::DeserializeError","error::Error","error::FromUtf8Error","error::IntoInnerError","error::Utf8Error"],"std::fmt::Debug":["QuoteStyle","Terminator","Trim","byte_record::Bounds","byte_record::ByteRecord","byte_record::ByteRecordInner","byte_record::Position","deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::Error","error::ErrorKind","error::FromUtf8Error","error::IntoInnerError","error::Utf8Error","reader::Headers","reader::Reader","reader::ReaderBuilder","reader::ReaderState","string_record::StringRecord","writer::Buffer","writer::HeaderState","writer::Writer","writer::WriterBuilder","writer::WriterState"],"std::fmt::Display":["deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::Error","error::FromUtf8Error","error::IntoInnerError","error::Utf8Error"],"std::iter::DoubleEndedIterator":["byte_record::ByteRecordIter","string_record::StringRecordIter"],"std::iter::ExactSizeIterator":["byte_record::ByteRecordIter"],"std::iter::Extend":["byte_record::ByteRecord","string_record::StringRecord"],"std::iter::FromIterator":["byte_record::ByteRecord","string_record::StringRecord"],"std::iter::Iterator":["byte_record::ByteRecordIter","reader::ByteRecordsIntoIter","reader::ByteRecordsIter","reader::DeserializeRecordsIntoIter","reader::DeserializeRecordsIter","reader::StringRecordsIntoIter","reader::StringRecordsIter","string_record::StringRecordIter"],"std::marker::Copy":["QuoteStyle","Terminator","Trim"],"std::marker::StructuralEq":["byte_record::Bounds","byte_record::ByteRecord","byte_record::ByteRecordInner","byte_record::Position","deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::FromUtf8Error","error::Utf8Error","string_record::StringRecord"],"std::marker::StructuralPartialEq":["Trim","byte_record::Bounds","byte_record::ByteRecordInner","byte_record::Position","deserializer::DeserializeError","deserializer::DeserializeErrorKind","error::FromUtf8Error","error::Utf8Error"],"std::ops::Drop":["writer::Writer"],"std::ops::Index":["byte_record::ByteRecord","string_record::StringRecord"]},"type_to_def_path":{"QuoteStyle":"QuoteStyle","Terminator":"Terminator","Trim":"Trim","byte_record::Bounds":"byte_record::Bounds","byte_record::ByteRecord":"byte_record::ByteRecord","byte_record::ByteRecordInner":"byte_record::ByteRecordInner","byte_record::ByteRecordIter<'r>":"byte_record::ByteRecordIter","byte_record::Position":"byte_record::Position","deserializer::DeByteRecord<'r>":"deserializer::DeByteRecord","deserializer::DeRecordWrap<T>":"deserializer::DeRecordWrap","deserializer::DeStringRecord<'r>":"deserializer::DeStringRecord","deserializer::DeserializeError":"deserializer::DeserializeError","deserializer::DeserializeErrorKind":"deserializer::DeserializeErrorKind","error::Error":"error::Error","error::ErrorKind":"error::ErrorKind","error::FromUtf8Error":"error::FromUtf8Error","error::IntoInnerError<W>":"error::IntoInnerError","error::Utf8Error":"error::Utf8Error","reader::ByteRecordsIntoIter<R>":"reader::ByteRecordsIntoIter","reader::ByteRecordsIter<'r, R>":"reader::ByteRecordsIter","reader::DeserializeRecordsIntoIter<R, D>":"reader::DeserializeRecordsIntoIter","reader::DeserializeRecordsIter<'r, R, D>":"reader::DeserializeRecordsIter","reader::Headers":"reader::Headers","reader::Reader<R>":"reader::Reader","reader::ReaderBuilder":"reader::ReaderBuilder","reader::ReaderState":"reader::ReaderState","reader::StringRecordsIntoIter<R>":"reader::StringRecordsIntoIter","reader::StringRecordsIter<'r, R>":"reader::StringRecordsIter","serializer::HeaderState":"serializer::HeaderState","serializer::SeHeader<'w, W>":"serializer::SeHeader","serializer::SeRecord<'w, W>":"serializer::SeRecord","string_record::StringRecord":"string_record::StringRecord","string_record::StringRecordIter<'r>":"string_record::StringRecordIter","writer::Buffer":"writer::Buffer","writer::HeaderState":"writer::HeaderState","writer::Writer<W>":"writer::Writer","writer::WriterBuilder":"writer::WriterBuilder","writer::WriterState":"writer::WriterState"}}