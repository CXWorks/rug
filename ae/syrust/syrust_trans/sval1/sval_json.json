{"dependencies":{"<End<T> as core::fmt::Debug>::fmt":["End","core::fmt::Formatter","core::marker::Sized","core::result::Result","sval::Error"],"<End<T> as core::fmt::Display>::fmt":["End","core::fmt::Formatter","core::marker::Sized","core::result::Result","sval::Error"],"<fmt::Escape<W> as core::fmt::Write>::write_str":["core::marker::Sized","core::result::Result","fmt::Escape"],"<fmt::Formatter<W> as sval::Stream>::bool":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::char":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::f64":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::fmt":["core::fmt::Arguments","core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::i128":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::map_begin":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::map_end":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::map_key":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::map_value":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::none":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::seq_begin":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::seq_elem":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::seq_end":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::str":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"<fmt::Formatter<W> as sval::Stream>::u128":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"End":["End","core::marker::Sized","sval::Error"],"End::<T>::new":["End","core::marker::Sized","sval::Error"],"fmt::Escape":["core::marker::Sized","fmt::Escape"],"fmt::Formatter":["core::marker::Sized","core::option::Option","fmt::Formatter","sval::stream::Stack"],"fmt::Formatter::<W>::end":["core::marker::Sized","core::option::Option","core::result::Result","fmt::Formatter","sval::stream::Stack"],"fmt::Formatter::<W>::into_inner_unchecked":["core::marker::Sized","core::option::Option","fmt::Formatter","sval::stream::Stack"],"fmt::Formatter::<W>::is_valid":["core::marker::Sized","core::option::Option","fmt::Formatter","sval::stream::Stack"],"fmt::Formatter::<W>::new":["core::marker::Sized","core::option::Option","fmt::Formatter","sval::stream::Stack"],"fmt::Formatter::<W>::next_delim":["core::marker::Sized","core::option::Option","sval::stream::stack::Pos"],"fmt::escape_str":["core::fmt::Write","core::marker::Sized","core::result::Result","fmt::Escape"],"fmt::to_fmt":["core::fmt::Write","core::marker::Sized","core::result::Result","fmt::Escape","sval::Value"]},"glob_path_import":{},"self_to_fn":{"End":["impl<T> End<T> {\n    fn new(err: sval::Error, stream: T) -> Self {\n        End {\n            err,\n            stream,\n            _private: (),\n        }\n    }\n}","impl<T> crate::std::fmt::Debug for End<T> {\n    fn fmt(&self, f: &mut crate::std::fmt::Formatter) -> crate::std::fmt::Result {\n        f.debug_struct(\"End\").field(\"err\", &self.err).finish()\n    }\n}","impl<T> crate::std::fmt::Display for End<T> {\n    fn fmt(&self, f: &mut crate::std::fmt::Formatter) -> crate::std::fmt::Result {\n        write!(\n            f,\n            \"failed to take the inner JSON writer because it is invalid\"\n        )\n    }\n}"],"fmt::Escape":["impl<W> Write for Escape<W>\nwhere\n    W: Write,\n{\n    fn write_str(&mut self, s: &str) -> Result<(), fmt::Error> {\n        escape_str(s, &mut self.0)\n    }\n}"],"fmt::Formatter":["impl<W> Formatter<W>\nwhere\n    W: Write,\n{\n    /**\n    Create a new json stream.\n    */\n    pub fn new(out: W) -> Self {\n        Formatter {\n            stack: Stack::new(),\n            delim: None,\n            out,\n        }\n    }\n\n    /**\n    Whether the stream has seen a complete, valid json structure.\n    */\n    pub fn is_valid(&self) -> bool {\n        self.stack.can_end()\n    }\n\n    /**\n    Complete the stream and return the inner writer.\n\n    If the writer contains incomplete json then this method will fail.\n    The returned error can be used to pull the original stream back out.\n    */\n    pub fn end(mut self) -> Result<W, End<Self>> {\n        match self.stack.end() {\n            Ok(()) => Ok(self.out),\n            Err(e) => Err(End::new(e, self)),\n        }\n    }\n\n    /**\n    Get the inner writer back out of the stream without ensuring it's valid.\n    */\n    pub fn into_inner_unchecked(self) -> W {\n        self.out\n    }\n\n    #[inline]\n    fn next_delim(pos: stack::Pos) -> Option<char> {\n        if pos.is_value() || pos.is_elem() {\n            return Some(',');\n        }\n\n        if pos.is_key() {\n            return Some(':');\n        }\n\n        return None;\n    }\n}","impl<W> Stream for Formatter<W>\nwhere\n    W: Write,\n{\n    #[inline]\n    fn fmt(&mut self, v: stream::Arguments) -> stream::Result {\n        let pos = self.stack.primitive()?;\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_char('\"')?;\n        fmt::write(&mut Escape(&mut self.out), v)?;\n        self.out.write_char('\"')?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn i128(&mut self, v: i128) -> stream::Result {\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_str(itoa::Buffer::new().format(v))?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn u128(&mut self, v: u128) -> stream::Result {\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_str(itoa::Buffer::new().format(v))?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn f64(&mut self, v: f64) -> stream::Result {\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_str(ryu::Buffer::new().format(v))?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn bool(&mut self, v: bool) -> stream::Result {\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_str(if v { \"true\" } else { \"false\" })?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn char(&mut self, v: char) -> stream::Result {\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_char(v)?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn str(&mut self, v: &str) -> stream::Result {\n        let pos = self.stack.primitive()?;\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_char('\"')?;\n        escape_str(&v, &mut self.out)?;\n        self.out.write_char('\"')?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn none(&mut self) -> stream::Result {\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_str(\"null\")?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn seq_begin(&mut self, _: Option<usize>) -> stream::Result {\n        if self.stack.seq_begin()?.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = self.delim.take() {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_char('[')?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn seq_elem(&mut self) -> stream::Result {\n        self.stack.seq_elem()?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn seq_end(&mut self) -> stream::Result {\n        let pos = self.stack.seq_end()?;\n\n        self.delim = Self::next_delim(pos);\n        self.out.write_char(']')?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn map_begin(&mut self, _: Option<usize>) -> stream::Result {\n        if self.stack.map_begin()?.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = self.delim.take() {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_char('{')?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn map_key(&mut self) -> stream::Result {\n        self.stack.map_key()?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn map_value(&mut self) -> stream::Result {\n        self.stack.map_value()?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn map_end(&mut self) -> stream::Result {\n        let pos = self.stack.map_end()?;\n\n        self.delim = Self::next_delim(pos);\n        self.out.write_char('}')?;\n\n        Ok(())\n    }\n}"]},"single_path_import":{"fmt::Formatter":"Formatter","fmt::to_fmt":"to_fmt"},"srcs":{"<End<T> as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut crate::std::fmt::Formatter) -> crate::std::fmt::Result{\n        f.debug_struct(\"End\").field(\"err\", &self.err).finish()\n    }","Real(LocalPath(\"json/src/lib.rs\"))"],"<End<T> as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut crate::std::fmt::Formatter) -> crate::std::fmt::Result{\n        write!(\n            f,\n            \"failed to take the inner JSON writer because it is invalid\"\n        )\n    }","Real(LocalPath(\"json/src/lib.rs\"))"],"<fmt::Escape<W> as core::fmt::Write>::write_str":["fn write_str(&mut self, s: &str) -> Result<(), fmt::Error>{\n        escape_str(s, &mut self.0)\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::bool":["#[inline]\nfn bool(&mut self, v: bool) -> stream::Result{\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_str(if v { \"true\" } else { \"false\" })?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::char":["#[inline]\nfn char(&mut self, v: char) -> stream::Result{\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_char(v)?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::f64":["#[inline]\nfn f64(&mut self, v: f64) -> stream::Result{\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_str(ryu::Buffer::new().format(v))?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::fmt":["#[inline]\nfn fmt(&mut self, v: stream::Arguments) -> stream::Result{\n        let pos = self.stack.primitive()?;\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_char('\"')?;\n        fmt::write(&mut Escape(&mut self.out), v)?;\n        self.out.write_char('\"')?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::i128":["#[inline]\nfn i128(&mut self, v: i128) -> stream::Result{\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_str(itoa::Buffer::new().format(v))?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::map_begin":["#[inline]\nfn map_begin(&mut self, _: Option<usize>) -> stream::Result{\n        if self.stack.map_begin()?.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = self.delim.take() {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_char('{')?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::map_end":["#[inline]\nfn map_end(&mut self) -> stream::Result{\n        let pos = self.stack.map_end()?;\n\n        self.delim = Self::next_delim(pos);\n        self.out.write_char('}')?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::map_key":["#[inline]\nfn map_key(&mut self) -> stream::Result{\n        self.stack.map_key()?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::map_value":["#[inline]\nfn map_value(&mut self) -> stream::Result{\n        self.stack.map_value()?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::none":["#[inline]\nfn none(&mut self) -> stream::Result{\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_str(\"null\")?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::seq_begin":["#[inline]\nfn seq_begin(&mut self, _: Option<usize>) -> stream::Result{\n        if self.stack.seq_begin()?.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = self.delim.take() {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_char('[')?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::seq_elem":["#[inline]\nfn seq_elem(&mut self) -> stream::Result{\n        self.stack.seq_elem()?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::seq_end":["#[inline]\nfn seq_end(&mut self) -> stream::Result{\n        let pos = self.stack.seq_end()?;\n\n        self.delim = Self::next_delim(pos);\n        self.out.write_char(']')?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::str":["#[inline]\nfn str(&mut self, v: &str) -> stream::Result{\n        let pos = self.stack.primitive()?;\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_char('\"')?;\n        escape_str(&v, &mut self.out)?;\n        self.out.write_char('\"')?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"<fmt::Formatter<W> as sval::Stream>::u128":["#[inline]\nfn u128(&mut self, v: u128) -> stream::Result{\n        let pos = self.stack.primitive()?;\n\n        if pos.is_key() {\n            return Err(stream::Error::unsupported(\n                \"only strings are supported as json keys\",\n            ));\n        }\n\n        if let Some(delim) = mem::replace(&mut self.delim, Self::next_delim(pos)) {\n            self.out.write_char(delim)?;\n        }\n\n        self.out.write_str(itoa::Buffer::new().format(v))?;\n\n        Ok(())\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"End":["/**\nAn error attempting to end a JSON stream.\n\nThe original stream can be pulled out, or this type can be treated as a standard error.\n*/\npub struct End<T> {\n    /** The original stream. */\n    pub stream: T,\n    err: sval::Error,\n    _private: (),\n}","Real(LocalPath(\"json/src/lib.rs\"))"],"End::<T>::new":["fn new(err: sval::Error, stream: T) -> Self{\n        End {\n            err,\n            stream,\n            _private: (),\n        }\n    }","Real(LocalPath(\"json/src/lib.rs\"))"],"fmt::Escape":["struct Escape<W>(W);","Real(LocalPath(\"json/src/fmt.rs\"))"],"fmt::Formatter":["/**\nA stream for writing structured data as json.\n\nThe stream internally wraps a [`std::fmt::Write`].\n\n# Examples\n\nCreate an owned json stream:\n\n```\n# #[cfg(not(feature = \"std\"))]\n# fn main() {}\n# #[cfg(feature = \"std\")]\n# fn main() -> Result<(), Box<dyn std::error::Error>> {\nuse sval::stream::OwnedStream;\nuse sval_json::Formatter;\n\nlet mut stream = OwnedStream::new(Formatter::new(String::new()));\nstream.any(42)?;\nlet json = stream.into_inner().end()?;\n\nassert_eq!(\"42\", json);\n# Ok(())\n# }\n```\n*/\npub struct Formatter<W> {\n    stack: Stack,\n    delim: Option<char>,\n    out: W,\n}","Real(LocalPath(\"json/src/fmt.rs\"))"],"fmt::Formatter::<W>::end":["/**\n    Complete the stream and return the inner writer.\n\n    If the writer contains incomplete json then this method will fail.\n    The returned error can be used to pull the original stream back out.\n    */\npub fn end(mut self) -> Result<W, End<Self>>{\n        match self.stack.end() {\n            Ok(()) => Ok(self.out),\n            Err(e) => Err(End::new(e, self)),\n        }\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"fmt::Formatter::<W>::into_inner_unchecked":["/**\n    Get the inner writer back out of the stream without ensuring it's valid.\n    */\npub fn into_inner_unchecked(self) -> W{\n        self.out\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"fmt::Formatter::<W>::is_valid":["/**\n    Whether the stream has seen a complete, valid json structure.\n    */\npub fn is_valid(&self) -> bool{\n        self.stack.can_end()\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"fmt::Formatter::<W>::new":["/**\n    Create a new json stream.\n    */\npub fn new(out: W) -> Self{\n        Formatter {\n            stack: Stack::new(),\n            delim: None,\n            out,\n        }\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"fmt::Formatter::<W>::next_delim":["#[inline]\nfn next_delim(pos: stack::Pos) -> Option<char>{\n        if pos.is_value() || pos.is_elem() {\n            return Some(',');\n        }\n\n        if pos.is_key() {\n            return Some(':');\n        }\n\n        return None;\n    }","Real(LocalPath(\"json/src/fmt.rs\"))"],"fmt::escape_str":["#[inline]\nfn escape_str(value: &str, mut out: impl Write) -> Result<(), fmt::Error>{\n    let bytes = value.as_bytes();\n    let mut start = 0;\n\n    for (i, &byte) in bytes.iter().enumerate() {\n        let escape = ESCAPE[byte as usize];\n        if escape == 0 {\n            continue;\n        }\n\n        if start < i {\n            out.write_str(&value[start..i])?;\n        }\n\n        match escape {\n            self::BB => out.write_str(\"\\\\b\")?,\n            self::TT => out.write_str(\"\\\\t\")?,\n            self::NN => out.write_str(\"\\\\n\")?,\n            self::FF => out.write_str(\"\\\\f\")?,\n            self::RR => out.write_str(\"\\\\r\")?,\n            self::QU => out.write_str(\"\\\\\\\"\")?,\n            self::BS => out.write_str(\"\\\\\\\\\")?,\n            self::U => {\n                static HEX_DIGITS: [u8; 16] = *b\"0123456789abcdef\";\n                out.write_str(\"\\\\u00\")?;\n                out.write_char(HEX_DIGITS[(byte >> 4) as usize] as char)?;\n                out.write_char(HEX_DIGITS[(byte & 0xF) as usize] as char)?;\n            }\n            _ => unreachable!(),\n        }\n\n        start = i + 1;\n    }\n\n    if start != bytes.len() {\n        out.write_str(&value[start..])?;\n    }\n\n    Ok(())\n}","Real(LocalPath(\"json/src/fmt.rs\"))"],"fmt::to_fmt":["/**\nWrite a [`sval::Value`] to a formatter.\n*/\npub fn to_fmt<W>(fmt: W, v: impl sval::Value) -> Result<W, sval::Error>\nwhere\n    W: Write,{\n    let fmt = Formatter::new(fmt);\n\n    sval::stream(fmt, v).map(|fmt| fmt.into_inner_unchecked())\n}","Real(LocalPath(\"json/src/fmt.rs\"))"]},"struct_constructor":{"End":["new"],"bool":["is_valid"],"core::option::Option":["next_delim"],"core::result::Result":["bool","char","end","escape_str","f64","fmt","i128","map_begin","map_end","map_key","map_value","none","seq_begin","seq_elem","seq_end","str","to_fmt","u128","write_str"],"fmt::Formatter":["new"]},"struct_to_trait":{"End":["core::fmt::Debug","core::fmt::Display"],"fmt::Escape":["core::fmt::Write"],"fmt::Formatter":["sval::Stream"]},"targets":{"<End<T> as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"json/src/lib.rs\"))","core::fmt::Debug"],"<End<T> as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"json/src/lib.rs\"))","core::fmt::Display"],"<fmt::Escape<W> as core::fmt::Write>::write_str":["write_str","Real(LocalPath(\"json/src/fmt.rs\"))","core::fmt::Write"],"<fmt::Formatter<W> as sval::Stream>::bool":["bool","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::char":["char","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::f64":["f64","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::fmt":["fmt","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::i128":["i128","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::map_begin":["map_begin","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::map_end":["map_end","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::map_key":["map_key","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::map_value":["map_value","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::none":["none","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::seq_begin":["seq_begin","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::seq_elem":["seq_elem","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::seq_end":["seq_end","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::str":["str","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"<fmt::Formatter<W> as sval::Stream>::u128":["u128","Real(LocalPath(\"json/src/fmt.rs\"))","sval::Stream"],"End::<T>::new":["new","Real(LocalPath(\"json/src/lib.rs\"))",""],"fmt::Formatter::<W>::end":["end","Real(LocalPath(\"json/src/fmt.rs\"))",""],"fmt::Formatter::<W>::into_inner_unchecked":["into_inner_unchecked","Real(LocalPath(\"json/src/fmt.rs\"))",""],"fmt::Formatter::<W>::is_valid":["is_valid","Real(LocalPath(\"json/src/fmt.rs\"))",""],"fmt::Formatter::<W>::new":["new","Real(LocalPath(\"json/src/fmt.rs\"))",""],"fmt::Formatter::<W>::next_delim":["next_delim","Real(LocalPath(\"json/src/fmt.rs\"))",""],"fmt::escape_str":["escape_str","Real(LocalPath(\"json/src/fmt.rs\"))",""],"fmt::to_fmt":["to_fmt","Real(LocalPath(\"json/src/fmt.rs\"))",""]},"trait_to_struct":{"core::fmt::Debug":["End"],"core::fmt::Display":["End"],"core::fmt::Write":["fmt::Escape"],"sval::Stream":["fmt::Formatter"]},"type_to_def_path":{"End<T>":"End","fmt::Escape<W>":"fmt::Escape","fmt::Formatter<W>":"fmt::Formatter"}}