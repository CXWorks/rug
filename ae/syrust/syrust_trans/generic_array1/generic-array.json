{"dependencies":{"<&'a GenericArray<T, N> as core::convert::From<&'a [T]>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<&'a GenericArray<T, N> as core::iter::IntoIterator>::into_iter":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<&'a S as sequence::GenericSequence<T>>::generate":["core::marker::Sized","core::ops::FnMut"],"<&'a mut GenericArray<T, N> as core::convert::From<&'a mut [T]>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<&'a mut GenericArray<T, N> as core::iter::IntoIterator>::into_iter":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<&'a mut S as sequence::GenericSequence<T>>::generate":["core::marker::Sized","core::ops::FnMut"],"<ArrayBuilder<T, N> as core::ops::Drop>::drop":["ArrayBuilder","ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<ArrayConsumer<T, N> as core::ops::Drop>::drop":["ArrayConsumer","ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as core::iter::FromIterator<T>>::from_iter":["ArrayLength","GenericArray","core::default::Default","core::iter::IntoIterator","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as core::ops::Deref>::deref":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as core::ops::DerefMut>::deref_mut":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as functional::FunctionalSequence<T>>::fold":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::ops::FnMut","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as functional::FunctionalSequence<T>>::map":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::ops::FnMut","functional::MappedGenericSequence","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as functional::FunctionalSequence<T>>::zip":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::ops::FnMut","functional::MappedGenericSequence","sequence::GenericSequence","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as sequence::Concat<T, M>>::concat":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as sequence::GenericSequence<T>>::generate":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::ops::FnMut","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as sequence::GenericSequence<T>>::inverted_zip":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::ops::FnMut","functional::MappedGenericSequence","sequence::GenericSequence","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as sequence::GenericSequence<T>>::inverted_zip2":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::ops::FnMut","functional::MappedGenericSequence","sequence::GenericSequence","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as sequence::Lengthen<T>>::append":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as sequence::Lengthen<T>>::prepend":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as sequence::Shorten<T>>::pop_back":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as sequence::Shorten<T>>::pop_front":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArray<T, N> as sequence::Split<T, K>>::split":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<GenericArrayImplEven<T, U> as core::clone::Clone>::clone":["GenericArrayImplEven","core::marker::PhantomData","core::marker::Sized"],"<GenericArrayImplOdd<T, U> as core::clone::Clone>::clone":["GenericArrayImplOdd","core::marker::Sized"],"<iter::GenericArrayIter<T, N> as core::clone::Clone>::clone":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<iter::GenericArrayIter<T, N> as core::fmt::Debug>::fmt":["ArrayLength","GenericArray","core::default::Default","core::fmt::Formatter","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","core::result::Result","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<iter::GenericArrayIter<T, N> as core::iter::DoubleEndedIterator>::next_back":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","core::option::Option","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<iter::GenericArrayIter<T, N> as core::iter::ExactSizeIterator>::len":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::count":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::last":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","core::option::Option","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::next":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","core::option::Option","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::nth":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","core::option::Option","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::size_hint":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","core::option::Option","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"<iter::GenericArrayIter<T, N> as core::ops::Drop>::drop":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"ArrayBuilder":["ArrayBuilder","ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"ArrayBuilder::<T, N>::into_inner":["ArrayBuilder","ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"ArrayBuilder::<T, N>::iter_position":["ArrayBuilder","ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","core::slice::IterMut","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"ArrayBuilder::<T, N>::new":["ArrayBuilder","ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"ArrayConsumer":["ArrayConsumer","ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"ArrayConsumer::<T, N>::iter_position":["ArrayConsumer","ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","core::slice::Iter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"ArrayConsumer::<T, N>::new":["ArrayConsumer","ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"GenericArray":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"GenericArray::<T, N>::as_mut_slice":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"GenericArray::<T, N>::as_slice":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"GenericArray::<T, N>::clone_from_slice":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"GenericArray::<T, N>::from_exact_iter":["ArrayLength","GenericArray","core::default::Default","core::iter::ExactSizeIterator","core::iter::IntoIterator","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","core::option::Option","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"GenericArray::<T, N>::from_mut_slice":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"GenericArray::<T, N>::from_slice":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"GenericArrayImplEven":["GenericArrayImplEven","core::marker::PhantomData","core::marker::Sized"],"GenericArrayImplOdd":["GenericArrayImplOdd","core::marker::Sized"],"from_iter_length_fail":[],"functional::FunctionalSequence::fold":["core::marker::Sized","core::ops::FnMut"],"functional::FunctionalSequence::map":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::ops::FnMut","functional::MappedGenericSequence","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"functional::FunctionalSequence::zip":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::ops::FnMut","functional::MappedGenericSequence","sequence::GenericSequence","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"hex::<impl core::fmt::LowerHex for GenericArray<u8, T>>::fmt":["ArrayLength","GenericArray","core::default::Default","core::fmt::Formatter","core::marker::Copy","core::marker::Sized","core::result::Result","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"hex::<impl core::fmt::UpperHex for GenericArray<u8, T>>::fmt":["ArrayLength","GenericArray","core::default::Default","core::fmt::Formatter","core::marker::Copy","core::marker::Sized","core::result::Result","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::borrow::Borrow<[T]> for GenericArray<T, N>>::borrow":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::borrow::BorrowMut<[T]> for GenericArray<T, N>>::borrow_mut":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::clone::Clone for GenericArray<T, N>>::clone":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::cmp::Ord for GenericArray<T, N>>::cmp":["ArrayLength","GenericArray","core::cmp::Ordering","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::cmp::PartialEq for GenericArray<T, N>>::eq":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::cmp::PartialOrd for GenericArray<T, N>>::partial_cmp":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::option::Option","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::AsMut<[T]> for GenericArray<T, N>>::as_mut":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::AsRef<[T]> for GenericArray<T, N>>::as_ref":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 10]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 11]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 12]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 13]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 14]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 15]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 16]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 17]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 18]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 19]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 1]> for GenericArray<T, typenum::UInt<typenum::UTerm, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 20]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 21]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 22]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 23]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 24]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 25]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 26]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 27]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 28]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 29]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 2]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 30]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 31]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 32]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 3]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 4]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 5]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 6]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 7]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 8]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::convert::From<[T; 9]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>>>::from":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::default::Default for GenericArray<T, N>>::default":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::fmt::Debug for GenericArray<T, N>>::fmt":["ArrayLength","GenericArray","core::default::Default","core::fmt::Formatter","core::marker::Copy","core::marker::Sized","core::result::Result","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"impls::<impl core::hash::Hash for GenericArray<T, N>>::hash":["ArrayLength","GenericArray","core::default::Default","core::hash::Hasher","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"iter::<impl core::iter::IntoIterator for GenericArray<T, N>>::into_iter":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"iter::GenericArrayIter":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"iter::GenericArrayIter::<T, N>::as_mut_slice":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"iter::GenericArrayIter::<T, N>::as_slice":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::mem::ManuallyDrop","iter::GenericArrayIter","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"sequence::Concat::concat":[],"sequence::GenericSequence::generate":["core::marker::Sized","core::ops::FnMut"],"sequence::GenericSequence::inverted_zip":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::ops::FnMut","functional::MappedGenericSequence","sequence::GenericSequence","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"sequence::GenericSequence::inverted_zip2":["ArrayLength","GenericArray","core::default::Default","core::marker::Copy","core::marker::Sized","core::ops::FnMut","functional::MappedGenericSequence","sequence::GenericSequence","typenum::UInt","typenum::Unsigned","typenum::sealed::Sealed"],"sequence::Lengthen::append":[],"sequence::Lengthen::prepend":[],"sequence::Shorten::pop_back":[],"sequence::Shorten::pop_front":[],"sequence::Split::split":[],"transmute":["core::marker::Sized"]},"glob_path_import":{},"self_to_fn":{"<N1 as arr::AddLength<T, N2>>::N1":["impl<T, N1, N2> AddLength<T, N2> for N1\nwhere\n    N1: ArrayLength<T> + Add<N2>,\n    N2: ArrayLength<T>,\n    <N1 as Add<N2>>::Output: ArrayLength<T>,\n{\n    type Output = <N1 as Add<N2>>::Output;\n}"],"ArrayBuilder":["impl<T, N: ArrayLength<T>> ArrayBuilder<T, N> {\n    #[doc(hidden)]\n    #[inline]\n    pub unsafe fn new() -> ArrayBuilder<T, N> {\n        ArrayBuilder {\n            array: ManuallyDrop::new(mem::uninitialized()),\n            position: 0,\n        }\n    }\n\n    /// Creates a mutable iterator for writing to the array using `ptr::write`.\n    ///\n    /// Increment the position value given as a mutable reference as you iterate\n    /// to mark how many elements have been created.\n    #[doc(hidden)]\n    #[inline]\n    pub unsafe fn iter_position(&mut self) -> (slice::IterMut<T>, &mut usize) {\n        (self.array.iter_mut(), &mut self.position)\n    }\n\n    /// When done writing (assuming all elements have been written to),\n    /// get the inner array.\n    #[doc(hidden)]\n    #[inline]\n    pub unsafe fn into_inner(self) -> GenericArray<T, N> {\n        let array = ptr::read(&self.array);\n\n        mem::forget(self);\n\n        ManuallyDrop::into_inner(array)\n    }\n}","impl<T, N: ArrayLength<T>> Drop for ArrayBuilder<T, N> {\n    fn drop(&mut self) {\n        for value in &mut self.array[..self.position] {\n            unsafe {\n                ptr::drop_in_place(value);\n            }\n        }\n    }\n}"],"ArrayConsumer":["impl<T, N: ArrayLength<T>> ArrayConsumer<T, N> {\n    #[doc(hidden)]\n    #[inline]\n    pub unsafe fn new(array: GenericArray<T, N>) -> ArrayConsumer<T, N> {\n        ArrayConsumer {\n            array: ManuallyDrop::new(array),\n            position: 0,\n        }\n    }\n\n    /// Creates an iterator and mutable reference to the internal position\n    /// to keep track of consumed elements.\n    ///\n    /// Increment the position as you iterate to mark off consumed elements\n    #[doc(hidden)]\n    #[inline]\n    pub unsafe fn iter_position(&mut self) -> (slice::Iter<T>, &mut usize) {\n        (self.array.iter(), &mut self.position)\n    }\n}","impl<T, N: ArrayLength<T>> Drop for ArrayConsumer<T, N> {\n    fn drop(&mut self) {\n        for value in &mut self.array[self.position..N::to_usize()] {\n            unsafe {\n                ptr::drop_in_place(value);\n            }\n        }\n    }\n}"],"GenericArray":["impl<T, N> AsMut<[T]> for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn as_mut(&mut self) -> &mut [T] {\n        &mut self[..]\n    }\n}","impl<T, N> AsRef<[T]> for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn as_ref(&self) -> &[T] {\n        &self[..]\n    }\n}","impl<T, N> Borrow<[T]> for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn borrow(&self) -> &[T] {\n        &self[..]\n    }\n}","impl<T, N> BorrowMut<[T]> for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn borrow_mut(&mut self) -> &mut [T] {\n        &mut self[..]\n    }\n}","impl<T, N> Deref for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    type Target = [T];\n\n    fn deref(&self) -> &[T] {\n        unsafe { slice::from_raw_parts(self as *const Self as *const T, N::to_usize()) }\n    }\n}","impl<T, N> DerefMut for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn deref_mut(&mut self) -> &mut [T] {\n        unsafe { slice::from_raw_parts_mut(self as *mut Self as *mut T, N::to_usize()) }\n    }\n}","impl<T, N> FromIterator<T> for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn from_iter<I>(iter: I) -> GenericArray<T, N>\n    where\n        I: IntoIterator<Item = T>,\n    {\n        unsafe {\n            let mut destination = ArrayBuilder::new();\n\n            {\n                let (destination_iter, position) = destination.iter_position();\n\n                for (src, dst) in iter.into_iter().zip(destination_iter) {\n                    ptr::write(dst, src);\n\n                    *position += 1;\n                }\n            }\n\n            if destination.position < N::to_usize() {\n                from_iter_length_fail(destination.position, N::to_usize());\n            }\n\n            destination.into_inner()\n        }\n    }\n}","impl<T, N> GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    /// Creates a new `GenericArray` instance from an iterator with a known exact size.\n    ///\n    /// Returns `None` if the size is not equal to the number of elements in the `GenericArray`.\n    pub fn from_exact_iter<I>(iter: I) -> Option<Self>\n    where\n        I: IntoIterator<Item = T>,\n        <I as IntoIterator>::IntoIter: ExactSizeIterator,\n    {\n        let iter = iter.into_iter();\n\n        if iter.len() == N::to_usize() {\n            unsafe {\n                let mut destination = ArrayBuilder::new();\n\n                {\n                    let (destination_iter, position) = destination.iter_position();\n\n                    for (dst, src) in destination_iter.zip(iter.into_iter()) {\n                        ptr::write(dst, src);\n\n                        *position += 1;\n                    }\n                }\n\n                Some(destination.into_inner())\n            }\n        } else {\n            None\n        }\n    }\n}","impl<T, N> GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    /// Extracts a slice containing the entire array.\n    #[inline]\n    pub fn as_slice(&self) -> &[T] {\n        self.deref()\n    }\n\n    /// Extracts a mutable slice containing the entire array.\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n        self.deref_mut()\n    }\n\n    /// Converts slice to a generic array reference with inferred length;\n    ///\n    /// Length of the slice must be equal to the length of the array.\n    #[inline]\n    pub fn from_slice(slice: &[T]) -> &GenericArray<T, N> {\n        slice.into()\n    }\n\n    /// Converts mutable slice to a mutable generic array reference\n    ///\n    /// Length of the slice must be equal to the length of the array.\n    #[inline]\n    pub fn from_mut_slice(slice: &mut [T]) -> &mut GenericArray<T, N> {\n        slice.into()\n    }\n}","impl<T, N> IntoIterator for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    type Item = T;\n    type IntoIter = GenericArrayIter<T, N>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        GenericArrayIter {\n            array: ManuallyDrop::new(self),\n            index: 0,\n            index_back: N::to_usize(),\n        }\n    }\n}","impl<T: ArrayLength<u8>> fmt::LowerHex for GenericArray<u8, T>\nwhere\n    T: Add<T>,\n    <T as Add<T>>::Output: ArrayLength<u8>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let max_digits = f.precision().unwrap_or_else(|| self.len() * 2);\n        let max_hex = (max_digits >> 1) + (max_digits & 1);\n\n        if T::to_usize() < 1024 {\n            // For small arrays use a stack allocated\n            // buffer of 2x number of bytes\n            let mut res = GenericArray::<u8, Sum<T, T>>::default();\n\n            for (i, c) in self.iter().take(max_hex).enumerate() {\n                res[i * 2] = LOWER_CHARS[(c >> 4) as usize];\n                res[i * 2 + 1] = LOWER_CHARS[(c & 0xF) as usize];\n            }\n            f.write_str(unsafe { str::from_utf8_unchecked(&res[..max_digits]) })?;\n        } else {\n            // For large array use chunks of up to 1024 bytes (2048 hex chars)\n            let mut buf = [0u8; 2048];\n            let mut digits_left = max_digits;\n\n            for chunk in self[..max_hex].chunks(1024) {\n                for (i, c) in chunk.iter().enumerate() {\n                    buf[i * 2] = LOWER_CHARS[(c >> 4) as usize];\n                    buf[i * 2 + 1] = LOWER_CHARS[(c & 0xF) as usize];\n                }\n                let n = min(chunk.len() * 2, digits_left);\n                f.write_str(unsafe { str::from_utf8_unchecked(&buf[..n]) })?;\n                digits_left -= n;\n            }\n        }\n        Ok(())\n    }\n}","impl<T: ArrayLength<u8>> fmt::UpperHex for GenericArray<u8, T>\nwhere\n    T: Add<T>,\n    <T as Add<T>>::Output: ArrayLength<u8>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let max_digits = f.precision().unwrap_or_else(|| self.len() * 2);\n        let max_hex = (max_digits >> 1) + (max_digits & 1);\n\n        if T::to_usize() < 1024 {\n            // For small arrays use a stack allocated\n            // buffer of 2x number of bytes\n            let mut res = GenericArray::<u8, Sum<T, T>>::default();\n\n            for (i, c) in self.iter().take(max_hex).enumerate() {\n                res[i * 2] = UPPER_CHARS[(c >> 4) as usize];\n                res[i * 2 + 1] = UPPER_CHARS[(c & 0xF) as usize];\n            }\n            f.write_str(unsafe { str::from_utf8_unchecked(&res[..max_digits]) })?;\n        } else {\n            // For large array use chunks of up to 1024 bytes (2048 hex chars)\n            let mut buf = [0u8; 2048];\n            let mut digits_left = max_digits;\n\n            for chunk in self[..max_hex].chunks(1024) {\n                for (i, c) in chunk.iter().enumerate() {\n                    buf[i * 2] = UPPER_CHARS[(c >> 4) as usize];\n                    buf[i * 2 + 1] = UPPER_CHARS[(c & 0xF) as usize];\n                }\n                let n = min(chunk.len() * 2, digits_left);\n                f.write_str(unsafe { str::from_utf8_unchecked(&buf[..n]) })?;\n                digits_left -= n;\n            }\n        }\n        Ok(())\n    }\n}","impl<T: Clone, N> Clone for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn clone(&self) -> GenericArray<T, N> {\n        self.map(|x| x.clone())\n    }\n}","impl<T: Clone, N> GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    /// Construct a `GenericArray` from a slice by cloning its content\n    ///\n    /// Length of the slice must be equal to the length of the array\n    #[inline]\n    pub fn clone_from_slice(list: &[T]) -> GenericArray<T, N> {\n        Self::from_exact_iter(list.iter().cloned())\n            .expect(\"Slice must be the same length as the array\")\n    }\n}","impl<T: Copy, N> Copy for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n    N::ArrayType: Copy,\n{\n}","impl<T: Debug, N> Debug for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        self[..].fmt(fmt)\n    }\n}","impl<T: Default, N> Default for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    #[inline]\n    fn default() -> Self {\n        Self::generate(|_| T::default())\n    }\n}","impl<T: Eq, N> Eq for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n}","impl<T: Hash, N> Hash for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        Hash::hash(&self[..], state)\n    }\n}","impl<T: Ord, N> Ord for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn cmp(&self, other: &GenericArray<T, N>) -> Ordering {\n        Ord::cmp(self.as_slice(), other.as_slice())\n    }\n}","impl<T: PartialEq, N> PartialEq for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn eq(&self, other: &Self) -> bool {\n        **self == **other\n    }\n}","impl<T: PartialOrd, N> PartialOrd for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn partial_cmp(&self, other: &GenericArray<T, N>) -> Option<Ordering> {\n        PartialOrd::partial_cmp(self.as_slice(), other.as_slice())\n    }\n}","impl<T> From<[T; $n]> for GenericArray<T, $ty> {\n                fn from(arr: [T; $n]) -> Self {\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }\n            }","unsafe impl<T, N, K> Split<T, K> for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n    K: ArrayLength<T>,\n    N: Sub<K>,\n    Diff<N, K>: ArrayLength<T>,\n{\n    type First = GenericArray<T, K>;\n    type Second = GenericArray<T, Diff<N, K>>;\n\n    fn split(self) -> (Self::First, Self::Second) {\n        let head_ptr = self.as_ptr();\n        let tail_ptr = unsafe { head_ptr.offset(K::to_usize() as isize) };\n\n        let head = unsafe { ptr::read(head_ptr as _) };\n        let tail = unsafe { ptr::read(tail_ptr as _) };\n\n        mem::forget(self);\n\n        (head, tail)\n    }\n}","unsafe impl<T, N, M> Concat<T, M> for GenericArray<T, N>\nwhere\n    N: ArrayLength<T> + Add<M>,\n    M: ArrayLength<T>,\n    Sum<N, M>: ArrayLength<T>,\n{\n    type Rest = GenericArray<T, M>;\n    type Output = GenericArray<T, Sum<N, M>>;\n\n    fn concat(self, rest: Self::Rest) -> Self::Output {\n        let mut output: Self::Output = unsafe { mem::uninitialized() };\n\n        let output_ptr = output.as_mut_ptr();\n\n        unsafe {\n            ptr::write(output_ptr as *mut _, self);\n            ptr::write(output_ptr.offset(N::to_usize() as isize) as *mut _, rest);\n        }\n\n        output\n    }\n}","unsafe impl<T, N: ArrayLength<T>> Lengthen<T> for GenericArray<T, N>\nwhere\n    N: Add<B1>,\n    Add1<N>: ArrayLength<T>,\n    Add1<N>: Sub<B1, Output = N>,\n    Sub1<Add1<N>>: ArrayLength<T>,\n{\n    type Longer = GenericArray<T, Add1<N>>;\n\n    fn append(self, last: T) -> Self::Longer {\n        let mut longer: Self::Longer = unsafe { mem::uninitialized() };\n\n        unsafe {\n            ptr::write(longer.as_mut_ptr() as *mut _, self);\n            ptr::write(&mut longer[N::to_usize()], last);\n        }\n\n        longer\n    }\n\n    fn prepend(self, first: T) -> Self::Longer {\n        let mut longer: Self::Longer = unsafe { mem::uninitialized() };\n\n        let longer_ptr = longer.as_mut_ptr();\n\n        unsafe {\n            ptr::write(longer_ptr as *mut _, first);\n            ptr::write(longer_ptr.offset(1) as *mut _, self);\n        }\n\n        longer\n    }\n}","unsafe impl<T, N: ArrayLength<T>> Shorten<T> for GenericArray<T, N>\nwhere\n    N: Sub<B1>,\n    Sub1<N>: ArrayLength<T>,\n    Sub1<N>: Add<B1, Output = N>,\n    Add1<Sub1<N>>: ArrayLength<T>,\n{\n    type Shorter = GenericArray<T, Sub1<N>>;\n\n    fn pop_back(self) -> (Self::Shorter, T) {\n        let init_ptr = self.as_ptr();\n        let last_ptr = unsafe { init_ptr.offset(Sub1::<N>::to_usize() as isize) };\n\n        let init = unsafe { ptr::read(init_ptr as _) };\n        let last = unsafe { ptr::read(last_ptr as _) };\n\n        mem::forget(self);\n\n        (init, last)\n    }\n\n    fn pop_front(self) -> (T, Self::Shorter) {\n        let head_ptr = self.as_ptr();\n        let tail_ptr = unsafe { head_ptr.offset(1) };\n\n        let head = unsafe { ptr::read(head_ptr as _) };\n        let tail = unsafe { ptr::read(tail_ptr as _) };\n\n        mem::forget(self);\n\n        (head, tail)\n    }\n}","unsafe impl<T, N> FunctionalSequence<T> for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n    Self: GenericSequence<T, Item = T, Length = N>,\n{\n    fn map<U, F>(self, mut f: F) -> MappedSequence<Self, T, U>\n    where\n        Self::Length: ArrayLength<U>,\n        Self: MappedGenericSequence<T, U>,\n        F: FnMut(T) -> U,\n    {\n        unsafe {\n            let mut source = ArrayConsumer::new(self);\n\n            let (array_iter, position) = source.iter_position();\n\n            FromIterator::from_iter(array_iter.map(|src| {\n                let value = ptr::read(src);\n\n                *position += 1;\n\n                f(value)\n            }))\n        }\n    }\n\n    #[inline]\n    fn zip<B, Rhs, U, F>(self, rhs: Rhs, f: F) -> MappedSequence<Self, T, U>\n    where\n        Self: MappedGenericSequence<T, U>,\n        Rhs: MappedGenericSequence<B, U, Mapped = MappedSequence<Self, T, U>>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        Rhs: GenericSequence<B, Length = Self::Length>,\n        F: FnMut(T, Rhs::Item) -> U,\n    {\n        rhs.inverted_zip(self, f)\n    }\n\n    fn fold<U, F>(self, init: U, mut f: F) -> U\n    where\n        F: FnMut(U, T) -> U,\n    {\n        unsafe {\n            let mut source = ArrayConsumer::new(self);\n\n            let (array_iter, position) = source.iter_position();\n\n            array_iter.fold(init, |acc, src| {\n                let value = ptr::read(src);\n\n                *position += 1;\n\n                f(acc, value)\n            })\n        }\n    }\n}","unsafe impl<T, N> GenericSequence<T> for GenericArray<T, N>\nwhere\n    N: ArrayLength<T>,\n    Self: IntoIterator<Item = T>,\n{\n    type Length = N;\n    type Sequence = Self;\n\n    fn generate<F>(mut f: F) -> GenericArray<T, N>\n    where\n        F: FnMut(usize) -> T,\n    {\n        unsafe {\n            let mut destination = ArrayBuilder::new();\n\n            {\n                let (destination_iter, position) = destination.iter_position();\n\n                for (i, dst) in destination_iter.enumerate() {\n                    ptr::write(dst, f(i));\n\n                    *position += 1;\n                }\n            }\n\n            destination.into_inner()\n        }\n    }\n\n    #[doc(hidden)]\n    fn inverted_zip<B, U, F>(\n        self,\n        lhs: GenericArray<B, Self::Length>,\n        mut f: F,\n    ) -> MappedSequence<GenericArray<B, Self::Length>, B, U>\n    where\n        GenericArray<B, Self::Length>:\n            GenericSequence<B, Length = Self::Length> + MappedGenericSequence<B, U>,\n        Self: MappedGenericSequence<T, U>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        F: FnMut(B, Self::Item) -> U,\n    {\n        unsafe {\n            let mut left = ArrayConsumer::new(lhs);\n            let mut right = ArrayConsumer::new(self);\n\n            let (left_array_iter, left_position) = left.iter_position();\n            let (right_array_iter, right_position) = right.iter_position();\n\n            FromIterator::from_iter(left_array_iter.zip(right_array_iter).map(|(l, r)| {\n                let left_value = ptr::read(l);\n                let right_value = ptr::read(r);\n\n                *left_position += 1;\n                *right_position += 1;\n\n                f(left_value, right_value)\n            }))\n        }\n    }\n\n    #[doc(hidden)]\n    fn inverted_zip2<B, Lhs, U, F>(self, lhs: Lhs, mut f: F) -> MappedSequence<Lhs, B, U>\n    where\n        Lhs: GenericSequence<B, Length = Self::Length> + MappedGenericSequence<B, U>,\n        Self: MappedGenericSequence<T, U>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        F: FnMut(Lhs::Item, Self::Item) -> U,\n    {\n        unsafe {\n            let mut right = ArrayConsumer::new(self);\n\n            let (right_array_iter, right_position) = right.iter_position();\n\n            FromIterator::from_iter(\n                lhs.into_iter()\n                    .zip(right_array_iter)\n                    .map(|(left_value, r)| {\n                        let right_value = ptr::read(r);\n\n                        *right_position += 1;\n\n                        f(left_value, right_value)\n                    }),\n            )\n        }\n    }\n}","unsafe impl<T, U, N> MappedGenericSequence<T, U> for GenericArray<T, N>\nwhere\n    N: ArrayLength<T> + ArrayLength<U>,\n    GenericArray<U, N>: GenericSequence<U, Length = N>,\n{\n    type Mapped = GenericArray<U, N>;\n}","unsafe impl<T: Send, N: ArrayLength<T>> Send for GenericArray<T, N> {}","unsafe impl<T: Sync, N: ArrayLength<T>> Sync for GenericArray<T, N> {}"],"GenericArrayImplEven":["impl<T: Clone, U: Clone> Clone for GenericArrayImplEven<T, U> {\n    fn clone(&self) -> GenericArrayImplEven<T, U> {\n        GenericArrayImplEven {\n            parent1: self.parent1.clone(),\n            parent2: self.parent2.clone(),\n            _marker: PhantomData,\n        }\n    }\n}","impl<T: Copy, U: Copy> Copy for GenericArrayImplEven<T, U> {}"],"GenericArrayImplOdd":["impl<T: Clone, U: Clone> Clone for GenericArrayImplOdd<T, U> {\n    fn clone(&self) -> GenericArrayImplOdd<T, U> {\n        GenericArrayImplOdd {\n            parent1: self.parent1.clone(),\n            parent2: self.parent2.clone(),\n            data: self.data.clone(),\n        }\n    }\n}","impl<T: Copy, U: Copy> Copy for GenericArrayImplOdd<T, U> {}"],"iter::GenericArrayIter":["impl<T, N> DoubleEndedIterator for GenericArrayIter<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn next_back(&mut self) -> Option<T> {\n        if self.index < self.index_back {\n            self.index_back -= 1;\n\n            unsafe { Some(ptr::read(self.array.get_unchecked(self.index_back))) }\n        } else {\n            None\n        }\n    }\n}","impl<T, N> Drop for GenericArrayIter<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    #[inline]\n    fn drop(&mut self) {\n        // Drop values that are still alive.\n        for p in self.as_mut_slice() {\n            unsafe {\n                ptr::drop_in_place(p);\n            }\n        }\n    }\n}","impl<T, N> ExactSizeIterator for GenericArrayIter<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn len(&self) -> usize {\n        self.index_back - self.index\n    }\n}","impl<T, N> GenericArrayIter<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    /// Returns the remaining items of this iterator as a slice\n    #[inline]\n    pub fn as_slice(&self) -> &[T] {\n        &self.array.as_slice()[self.index..self.index_back]\n    }\n\n    /// Returns the remaining items of this iterator as a mutable slice\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n        &mut self.array.as_mut_slice()[self.index..self.index_back]\n    }\n}","impl<T, N> Iterator for GenericArrayIter<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        if self.index < self.index_back {\n            let p = unsafe { Some(ptr::read(self.array.get_unchecked(self.index))) };\n\n            self.index += 1;\n\n            p\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.len();\n        (len, Some(len))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    fn nth(&mut self, n: usize) -> Option<T> {\n        // First consume values prior to the nth.\n        let ndrop = cmp::min(n, self.len());\n\n        for p in &mut self.array[self.index..self.index + ndrop] {\n            self.index += 1;\n\n            unsafe {\n                ptr::drop_in_place(p);\n            }\n        }\n\n        self.next()\n    }\n\n    fn last(mut self) -> Option<T> {\n        // Note, everything else will correctly drop first as `self` leaves scope.\n        self.next_back()\n    }\n}","impl<T: Clone, N> Clone for GenericArrayIter<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn clone(&self) -> Self {\n        // This places all cloned elements at the start of the new array iterator,\n        // not at their original indices.\n        unsafe {\n            let mut iter = GenericArrayIter {\n                array: ManuallyDrop::new(mem::uninitialized()),\n                index: 0,\n                index_back: 0,\n            };\n\n            for (dst, src) in iter.array.iter_mut().zip(self.as_slice()) {\n                ptr::write(dst, src.clone());\n\n                iter.index_back += 1;\n            }\n\n            iter\n        }\n    }\n}","impl<T: fmt::Debug, N> fmt::Debug for GenericArrayIter<T, N>\nwhere\n    N: ArrayLength<T>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"GenericArrayIter\")\n            .field(&self.as_slice())\n            .finish()\n    }\n}"],"typenum::UInt":["unsafe impl<T, N: ArrayLength<T>> ArrayLength<T> for UInt<N, B0> {\n    #[doc(hidden)]\n    type ArrayType = GenericArrayImplEven<T, N::ArrayType>;\n}","unsafe impl<T, N: ArrayLength<T>> ArrayLength<T> for UInt<N, B1> {\n    #[doc(hidden)]\n    type ArrayType = GenericArrayImplOdd<T, N::ArrayType>;\n}"],"typenum::UTerm":["unsafe impl<T> ArrayLength<T> for UTerm {\n    #[doc(hidden)]\n    type ArrayType = ();\n}"]},"single_path_import":{"iter::GenericArrayIter":"GenericArrayIter"},"srcs":{"<&'a GenericArray<T, N> as core::convert::From<&'a [T]>>::from":["/// Converts slice to a generic array reference with inferred length;\n///\n/// Length of the slice must be equal to the length of the array.\n#[inline]\nfn from(slice: &[T]) -> &GenericArray<T, N>{\n        assert_eq!(slice.len(), N::to_usize());\n\n        unsafe { &*(slice.as_ptr() as *const GenericArray<T, N>) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a GenericArray<T, N> as core::iter::IntoIterator>::into_iter":["fn into_iter(self: &'a GenericArray<T, N>) -> Self::IntoIter{\n        self.as_slice().iter()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a S as sequence::GenericSequence<T>>::generate":["#[inline]\nfn generate<F>(f: F) -> Self::Sequence\n    where\n        F: FnMut(usize) -> T,{\n        S::generate(f)\n    }","Real(LocalPath(\"src/sequence.rs\"))"],"<&'a mut GenericArray<T, N> as core::convert::From<&'a mut [T]>>::from":["/// Converts mutable slice to a mutable generic array reference\n///\n/// Length of the slice must be equal to the length of the array.\n#[inline]\nfn from(slice: &mut [T]) -> &mut GenericArray<T, N>{\n        assert_eq!(slice.len(), N::to_usize());\n\n        unsafe { &mut *(slice.as_mut_ptr() as *mut GenericArray<T, N>) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a mut GenericArray<T, N> as core::iter::IntoIterator>::into_iter":["fn into_iter(self: &'a mut GenericArray<T, N>) -> Self::IntoIter{\n        self.as_mut_slice().iter_mut()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a mut S as sequence::GenericSequence<T>>::generate":["#[inline]\nfn generate<F>(f: F) -> Self::Sequence\n    where\n        F: FnMut(usize) -> T,{\n        S::generate(f)\n    }","Real(LocalPath(\"src/sequence.rs\"))"],"<ArrayBuilder<T, N> as core::ops::Drop>::drop":["fn drop(&mut self){\n        for value in &mut self.array[..self.position] {\n            unsafe {\n                ptr::drop_in_place(value);\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<ArrayConsumer<T, N> as core::ops::Drop>::drop":["fn drop(&mut self){\n        for value in &mut self.array[self.position..N::to_usize()] {\n            unsafe {\n                ptr::drop_in_place(value);\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GenericArray<T, N> as core::iter::FromIterator<T>>::from_iter":["fn from_iter<I>(iter: I) -> GenericArray<T, N>\n    where\n        I: IntoIterator<Item = T>,{\n        unsafe {\n            let mut destination = ArrayBuilder::new();\n\n            {\n                let (destination_iter, position) = destination.iter_position();\n\n                for (src, dst) in iter.into_iter().zip(destination_iter) {\n                    ptr::write(dst, src);\n\n                    *position += 1;\n                }\n            }\n\n            if destination.position < N::to_usize() {\n                from_iter_length_fail(destination.position, N::to_usize());\n            }\n\n            destination.into_inner()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GenericArray<T, N> as core::ops::Deref>::deref":["fn deref(&self) -> &[T]{\n        unsafe { slice::from_raw_parts(self as *const Self as *const T, N::to_usize()) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GenericArray<T, N> as core::ops::DerefMut>::deref_mut":["fn deref_mut(&mut self) -> &mut [T]{\n        unsafe { slice::from_raw_parts_mut(self as *mut Self as *mut T, N::to_usize()) }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GenericArray<T, N> as functional::FunctionalSequence<T>>::fold":["fn fold<U, F>(self, init: U, mut f: F) -> U\n    where\n        F: FnMut(U, T) -> U,{\n        unsafe {\n            let mut source = ArrayConsumer::new(self);\n\n            let (array_iter, position) = source.iter_position();\n\n            array_iter.fold(init, |acc, src| {\n                let value = ptr::read(src);\n\n                *position += 1;\n\n                f(acc, value)\n            })\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GenericArray<T, N> as functional::FunctionalSequence<T>>::map":["fn map<U, F>(self, mut f: F) -> MappedSequence<Self, T, U>\n    where\n        Self::Length: ArrayLength<U>,\n        Self: MappedGenericSequence<T, U>,\n        F: FnMut(T) -> U,{\n        unsafe {\n            let mut source = ArrayConsumer::new(self);\n\n            let (array_iter, position) = source.iter_position();\n\n            FromIterator::from_iter(array_iter.map(|src| {\n                let value = ptr::read(src);\n\n                *position += 1;\n\n                f(value)\n            }))\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GenericArray<T, N> as functional::FunctionalSequence<T>>::zip":["#[inline]\nfn zip<B, Rhs, U, F>(self, rhs: Rhs, f: F) -> MappedSequence<Self, T, U>\n    where\n        Self: MappedGenericSequence<T, U>,\n        Rhs: MappedGenericSequence<B, U, Mapped = MappedSequence<Self, T, U>>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        Rhs: GenericSequence<B, Length = Self::Length>,\n        F: FnMut(T, Rhs::Item) -> U,{\n        rhs.inverted_zip(self, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GenericArray<T, N> as sequence::Concat<T, M>>::concat":["fn concat(self, rest: Self::Rest) -> Self::Output{\n        let mut output: Self::Output = unsafe { mem::uninitialized() };\n\n        let output_ptr = output.as_mut_ptr();\n\n        unsafe {\n            ptr::write(output_ptr as *mut _, self);\n            ptr::write(output_ptr.offset(N::to_usize() as isize) as *mut _, rest);\n        }\n\n        output\n    }","Real(LocalPath(\"src/sequence.rs\"))"],"<GenericArray<T, N> as sequence::GenericSequence<T>>::generate":["fn generate<F>(mut f: F) -> GenericArray<T, N>\n    where\n        F: FnMut(usize) -> T,{\n        unsafe {\n            let mut destination = ArrayBuilder::new();\n\n            {\n                let (destination_iter, position) = destination.iter_position();\n\n                for (i, dst) in destination_iter.enumerate() {\n                    ptr::write(dst, f(i));\n\n                    *position += 1;\n                }\n            }\n\n            destination.into_inner()\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GenericArray<T, N> as sequence::GenericSequence<T>>::inverted_zip":["#[doc(hidden)]\nfn inverted_zip<B, U, F>(\n        self,\n        lhs: GenericArray<B, Self::Length>,\n        mut f: F,\n    ) -> MappedSequence<GenericArray<B, Self::Length>, B, U>\n    where\n        GenericArray<B, Self::Length>:\n            GenericSequence<B, Length = Self::Length> + MappedGenericSequence<B, U>,\n        Self: MappedGenericSequence<T, U>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        F: FnMut(B, Self::Item) -> U,{\n        unsafe {\n            let mut left = ArrayConsumer::new(lhs);\n            let mut right = ArrayConsumer::new(self);\n\n            let (left_array_iter, left_position) = left.iter_position();\n            let (right_array_iter, right_position) = right.iter_position();\n\n            FromIterator::from_iter(left_array_iter.zip(right_array_iter).map(|(l, r)| {\n                let left_value = ptr::read(l);\n                let right_value = ptr::read(r);\n\n                *left_position += 1;\n                *right_position += 1;\n\n                f(left_value, right_value)\n            }))\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GenericArray<T, N> as sequence::GenericSequence<T>>::inverted_zip2":["#[doc(hidden)]\nfn inverted_zip2<B, Lhs, U, F>(self, lhs: Lhs, mut f: F) -> MappedSequence<Lhs, B, U>\n    where\n        Lhs: GenericSequence<B, Length = Self::Length> + MappedGenericSequence<B, U>,\n        Self: MappedGenericSequence<T, U>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        F: FnMut(Lhs::Item, Self::Item) -> U,{\n        unsafe {\n            let mut right = ArrayConsumer::new(self);\n\n            let (right_array_iter, right_position) = right.iter_position();\n\n            FromIterator::from_iter(\n                lhs.into_iter()\n                    .zip(right_array_iter)\n                    .map(|(left_value, r)| {\n                        let right_value = ptr::read(r);\n\n                        *right_position += 1;\n\n                        f(left_value, right_value)\n                    }),\n            )\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GenericArray<T, N> as sequence::Lengthen<T>>::append":["fn append(self, last: T) -> Self::Longer{\n        let mut longer: Self::Longer = unsafe { mem::uninitialized() };\n\n        unsafe {\n            ptr::write(longer.as_mut_ptr() as *mut _, self);\n            ptr::write(&mut longer[N::to_usize()], last);\n        }\n\n        longer\n    }","Real(LocalPath(\"src/sequence.rs\"))"],"<GenericArray<T, N> as sequence::Lengthen<T>>::prepend":["fn prepend(self, first: T) -> Self::Longer{\n        let mut longer: Self::Longer = unsafe { mem::uninitialized() };\n\n        let longer_ptr = longer.as_mut_ptr();\n\n        unsafe {\n            ptr::write(longer_ptr as *mut _, first);\n            ptr::write(longer_ptr.offset(1) as *mut _, self);\n        }\n\n        longer\n    }","Real(LocalPath(\"src/sequence.rs\"))"],"<GenericArray<T, N> as sequence::Shorten<T>>::pop_back":["fn pop_back(self) -> (Self::Shorter, T){\n        let init_ptr = self.as_ptr();\n        let last_ptr = unsafe { init_ptr.offset(Sub1::<N>::to_usize() as isize) };\n\n        let init = unsafe { ptr::read(init_ptr as _) };\n        let last = unsafe { ptr::read(last_ptr as _) };\n\n        mem::forget(self);\n\n        (init, last)\n    }","Real(LocalPath(\"src/sequence.rs\"))"],"<GenericArray<T, N> as sequence::Shorten<T>>::pop_front":["fn pop_front(self) -> (T, Self::Shorter){\n        let head_ptr = self.as_ptr();\n        let tail_ptr = unsafe { head_ptr.offset(1) };\n\n        let head = unsafe { ptr::read(head_ptr as _) };\n        let tail = unsafe { ptr::read(tail_ptr as _) };\n\n        mem::forget(self);\n\n        (head, tail)\n    }","Real(LocalPath(\"src/sequence.rs\"))"],"<GenericArray<T, N> as sequence::Split<T, K>>::split":["fn split(self) -> (Self::First, Self::Second){\n        let head_ptr = self.as_ptr();\n        let tail_ptr = unsafe { head_ptr.offset(K::to_usize() as isize) };\n\n        let head = unsafe { ptr::read(head_ptr as _) };\n        let tail = unsafe { ptr::read(tail_ptr as _) };\n\n        mem::forget(self);\n\n        (head, tail)\n    }","Real(LocalPath(\"src/sequence.rs\"))"],"<GenericArrayImplEven<T, U> as core::clone::Clone>::clone":["fn clone(&self) -> GenericArrayImplEven<T, U>{\n        GenericArrayImplEven {\n            parent1: self.parent1.clone(),\n            parent2: self.parent2.clone(),\n            _marker: PhantomData,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GenericArrayImplOdd<T, U> as core::clone::Clone>::clone":["fn clone(&self) -> GenericArrayImplOdd<T, U>{\n        GenericArrayImplOdd {\n            parent1: self.parent1.clone(),\n            parent2: self.parent2.clone(),\n            data: self.data.clone(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<iter::GenericArrayIter<T, N> as core::clone::Clone>::clone":["fn clone(&self) -> Self{\n        // This places all cloned elements at the start of the new array iterator,\n        // not at their original indices.\n        unsafe {\n            let mut iter = GenericArrayIter {\n                array: ManuallyDrop::new(mem::uninitialized()),\n                index: 0,\n                index_back: 0,\n            };\n\n            for (dst, src) in iter.array.iter_mut().zip(self.as_slice()) {\n                ptr::write(dst, src.clone());\n\n                iter.index_back += 1;\n            }\n\n            iter\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::GenericArrayIter<T, N> as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_tuple(\"GenericArrayIter\")\n            .field(&self.as_slice())\n            .finish()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::GenericArrayIter<T, N> as core::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<T>{\n        if self.index < self.index_back {\n            self.index_back -= 1;\n\n            unsafe { Some(ptr::read(self.array.get_unchecked(self.index_back))) }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::GenericArrayIter<T, N> as core::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.index_back - self.index\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::count":["#[inline]\nfn count(self) -> usize{\n        self.len()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::last":["fn last(mut self) -> Option<T>{\n        // Note, everything else will correctly drop first as `self` leaves scope.\n        self.next_back()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<T>{\n        if self.index < self.index_back {\n            let p = unsafe { Some(ptr::read(self.array.get_unchecked(self.index))) };\n\n            self.index += 1;\n\n            p\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::nth":["fn nth(&mut self, n: usize) -> Option<T>{\n        // First consume values prior to the nth.\n        let ndrop = cmp::min(n, self.len());\n\n        for p in &mut self.array[self.index..self.index + ndrop] {\n            self.index += 1;\n\n            unsafe {\n                ptr::drop_in_place(p);\n            }\n        }\n\n        self.next()\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        let len = self.len();\n        (len, Some(len))\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<iter::GenericArrayIter<T, N> as core::ops::Drop>::drop":["#[inline]\nfn drop(&mut self){\n        // Drop values that are still alive.\n        for p in self.as_mut_slice() {\n            unsafe {\n                ptr::drop_in_place(p);\n            }\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"ArrayBuilder":["/// Creates an array one element at a time using a mutable iterator\n/// you can write to with `ptr::write`.\n///\n/// Incremenent the position while iterating to mark off created elements,\n/// which will be dropped if `into_inner` is not called.\n#[doc(hidden)]\npub struct ArrayBuilder<T, N: ArrayLength<T>> {\n    array: ManuallyDrop<GenericArray<T, N>>,\n    position: usize,\n}","Real(LocalPath(\"src/lib.rs\"))"],"ArrayBuilder::<T, N>::into_inner":["/// When done writing (assuming all elements have been written to),\n/// get the inner array.\n#[doc(hidden)]\n#[inline]\npub unsafe fn into_inner(self) -> GenericArray<T, N>{\n        let array = ptr::read(&self.array);\n\n        mem::forget(self);\n\n        ManuallyDrop::into_inner(array)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayBuilder::<T, N>::iter_position":["/// Creates a mutable iterator for writing to the array using `ptr::write`.\n///\n/// Increment the position value given as a mutable reference as you iterate\n/// to mark how many elements have been created.\n#[doc(hidden)]\n#[inline]\npub unsafe fn iter_position(&mut self) -> (slice::IterMut<T>, &mut usize){\n        (self.array.iter_mut(), &mut self.position)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayBuilder::<T, N>::new":["#[doc(hidden)]\n#[inline]\npub unsafe fn new() -> ArrayBuilder<T, N>{\n        ArrayBuilder {\n            array: ManuallyDrop::new(mem::uninitialized()),\n            position: 0,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayConsumer":["/// Consumes an array.\n///\n/// Increment the position while iterating and any leftover elements\n/// will be dropped if position does not go to N\n#[doc(hidden)]\npub struct ArrayConsumer<T, N: ArrayLength<T>> {\n    array: ManuallyDrop<GenericArray<T, N>>,\n    position: usize,\n}","Real(LocalPath(\"src/lib.rs\"))"],"ArrayConsumer::<T, N>::iter_position":["/// Creates an iterator and mutable reference to the internal position\n/// to keep track of consumed elements.\n///\n/// Increment the position as you iterate to mark off consumed elements\n#[doc(hidden)]\n#[inline]\npub unsafe fn iter_position(&mut self) -> (slice::Iter<T>, &mut usize){\n        (self.array.iter(), &mut self.position)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayConsumer::<T, N>::new":["#[doc(hidden)]\n#[inline]\npub unsafe fn new(array: GenericArray<T, N>) -> ArrayConsumer<T, N>{\n        ArrayConsumer {\n            array: ManuallyDrop::new(array),\n            position: 0,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ArrayLength":["/// Trait making `GenericArray` work, marking types to be used as length of an array\npub unsafe trait ArrayLength<T>: Unsigned {\n    /// Associated type representing the array type for the number\n    type ArrayType;\n}","Real(LocalPath(\"src/lib.rs\"))"],"GenericArray":["/// Struct representing a generic array - `GenericArray<T, N>` works like [T; N]\n#[allow(dead_code)]\npub struct GenericArray<T, U: ArrayLength<T>> {\n    data: U::ArrayType,\n}","Real(LocalPath(\"src/lib.rs\"))"],"GenericArray::<T, N>::as_mut_slice":["/// Extracts a mutable slice containing the entire array.\n#[inline]\npub fn as_mut_slice(&mut self) -> &mut [T]{\n        self.deref_mut()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GenericArray::<T, N>::as_slice":["/// Extracts a slice containing the entire array.\n#[inline]\npub fn as_slice(&self) -> &[T]{\n        self.deref()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GenericArray::<T, N>::clone_from_slice":["/// Construct a `GenericArray` from a slice by cloning its content\n///\n/// Length of the slice must be equal to the length of the array\n#[inline]\npub fn clone_from_slice(list: &[T]) -> GenericArray<T, N>{\n        Self::from_exact_iter(list.iter().cloned())\n            .expect(\"Slice must be the same length as the array\")\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GenericArray::<T, N>::from_exact_iter":["/// Creates a new `GenericArray` instance from an iterator with a known exact size.\n///\n/// Returns `None` if the size is not equal to the number of elements in the `GenericArray`.\npub fn from_exact_iter<I>(iter: I) -> Option<Self>\n    where\n        I: IntoIterator<Item = T>,\n        <I as IntoIterator>::IntoIter: ExactSizeIterator,{\n        let iter = iter.into_iter();\n\n        if iter.len() == N::to_usize() {\n            unsafe {\n                let mut destination = ArrayBuilder::new();\n\n                {\n                    let (destination_iter, position) = destination.iter_position();\n\n                    for (dst, src) in destination_iter.zip(iter.into_iter()) {\n                        ptr::write(dst, src);\n\n                        *position += 1;\n                    }\n                }\n\n                Some(destination.into_inner())\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GenericArray::<T, N>::from_mut_slice":["/// Converts mutable slice to a mutable generic array reference\n///\n/// Length of the slice must be equal to the length of the array.\n#[inline]\npub fn from_mut_slice(slice: &mut [T]) -> &mut GenericArray<T, N>{\n        slice.into()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GenericArray::<T, N>::from_slice":["/// Converts slice to a generic array reference with inferred length;\n///\n/// Length of the slice must be equal to the length of the array.\n#[inline]\npub fn from_slice(slice: &[T]) -> &GenericArray<T, N>{\n        slice.into()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GenericArrayImplEven":["/// Internal type used to generate a struct of appropriate size\n#[allow(dead_code)]\n#[repr(C)]\n#[doc(hidden)]\npub struct GenericArrayImplEven<T, U> {\n    parent1: U,\n    parent2: U,\n    _marker: PhantomData<T>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"GenericArrayImplOdd":["/// Internal type used to generate a struct of appropriate size\n#[allow(dead_code)]\n#[repr(C)]\n#[doc(hidden)]\npub struct GenericArrayImplOdd<T, U> {\n    parent1: U,\n    parent2: U,\n    data: T,\n}","Real(LocalPath(\"src/lib.rs\"))"],"arr::AddLength":["/// Helper trait for `arr!` macro\npub trait AddLength<T, N: ArrayLength<T>>: ArrayLength<T> {\n    /// Resulting length\n    type Output: ArrayLength<T>;\n}","Real(LocalPath(\"src/arr.rs\"))"],"from_iter_length_fail":["#[inline(never)]\n#[cold]\nfn from_iter_length_fail(length: usize, expected: usize) -> !{\n    panic!(\n        \"GenericArray::from_iter received {} elements but expected {}\",\n        length, expected\n    );\n}","Real(LocalPath(\"src/lib.rs\"))"],"functional::FunctionalSequence":["/// Defines functional programming methods for generic sequences\npub unsafe trait FunctionalSequence<T>: GenericSequence<T> {\n    /// Maps a `GenericSequence` to another `GenericSequence`.\n    ///\n    /// If the mapping function panics, any already initialized elements in the new sequence\n    /// will be dropped, AND any unused elements in the source sequence will also be dropped.\n    fn map<U, F>(self, f: F) -> MappedSequence<Self, T, U>\n    where\n        Self: MappedGenericSequence<T, U>,\n        Self::Length: ArrayLength<U>,\n        F: FnMut(Self::Item) -> U,\n    {\n        FromIterator::from_iter(self.into_iter().map(f))\n    }\n\n    /// Combines two `GenericSequence` instances and iterates through both of them,\n    /// initializing a new `GenericSequence` with the result of the zipped mapping function.\n    ///\n    /// If the mapping function panics, any already initialized elements in the new sequence\n    /// will be dropped, AND any unused elements in the source sequences will also be dropped.\n    #[inline]\n    fn zip<B, Rhs, U, F>(self, rhs: Rhs, f: F) -> MappedSequence<Self, T, U>\n    where\n        Self: MappedGenericSequence<T, U>,\n        Rhs: MappedGenericSequence<B, U, Mapped = MappedSequence<Self, T, U>>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        Rhs: GenericSequence<B, Length = Self::Length>,\n        F: FnMut(Self::Item, Rhs::Item) -> U,\n    {\n        rhs.inverted_zip2(self, f)\n    }\n\n    /// Folds (or reduces) a sequence of data into a single value.\n    ///\n    /// If the fold function panics, any unused elements will be dropped.\n    fn fold<U, F>(self, init: U, f: F) -> U\n    where\n        F: FnMut(U, Self::Item) -> U,\n    {\n        self.into_iter().fold(init, f)\n    }\n}","Real(LocalPath(\"src/functional.rs\"))"],"functional::FunctionalSequence::fold":["/// Folds (or reduces) a sequence of data into a single value.\n///\n/// If the fold function panics, any unused elements will be dropped.\nfn fold<U, F>(self, init: U, f: F) -> U\n    where\n        F: FnMut(U, Self::Item) -> U,{\n        self.into_iter().fold(init, f)\n    }","Real(LocalPath(\"src/functional.rs\"))"],"functional::FunctionalSequence::map":["/// Maps a `GenericSequence` to another `GenericSequence`.\n///\n/// If the mapping function panics, any already initialized elements in the new sequence\n/// will be dropped, AND any unused elements in the source sequence will also be dropped.\nfn map<U, F>(self, f: F) -> MappedSequence<Self, T, U>\n    where\n        Self: MappedGenericSequence<T, U>,\n        Self::Length: ArrayLength<U>,\n        F: FnMut(Self::Item) -> U,{\n        FromIterator::from_iter(self.into_iter().map(f))\n    }","Real(LocalPath(\"src/functional.rs\"))"],"functional::FunctionalSequence::zip":["/// Combines two `GenericSequence` instances and iterates through both of them,\n/// initializing a new `GenericSequence` with the result of the zipped mapping function.\n///\n/// If the mapping function panics, any already initialized elements in the new sequence\n/// will be dropped, AND any unused elements in the source sequences will also be dropped.\n#[inline]\nfn zip<B, Rhs, U, F>(self, rhs: Rhs, f: F) -> MappedSequence<Self, T, U>\n    where\n        Self: MappedGenericSequence<T, U>,\n        Rhs: MappedGenericSequence<B, U, Mapped = MappedSequence<Self, T, U>>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        Rhs: GenericSequence<B, Length = Self::Length>,\n        F: FnMut(Self::Item, Rhs::Item) -> U,{\n        rhs.inverted_zip2(self, f)\n    }","Real(LocalPath(\"src/functional.rs\"))"],"functional::MappedGenericSequence":["/// Defines the relationship between one generic sequence and another,\n/// for operations such as `map` and `zip`.\npub unsafe trait MappedGenericSequence<T, U>: GenericSequence<T>\nwhere\n    Self::Length: ArrayLength<U>,\n{\n    /// Mapped sequence type\n    type Mapped: GenericSequence<U, Length = Self::Length>;\n}","Real(LocalPath(\"src/functional.rs\"))"],"hex::<impl core::fmt::LowerHex for GenericArray<u8, T>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let max_digits = f.precision().unwrap_or_else(|| self.len() * 2);\n        let max_hex = (max_digits >> 1) + (max_digits & 1);\n\n        if T::to_usize() < 1024 {\n            // For small arrays use a stack allocated\n            // buffer of 2x number of bytes\n            let mut res = GenericArray::<u8, Sum<T, T>>::default();\n\n            for (i, c) in self.iter().take(max_hex).enumerate() {\n                res[i * 2] = LOWER_CHARS[(c >> 4) as usize];\n                res[i * 2 + 1] = LOWER_CHARS[(c & 0xF) as usize];\n            }\n            f.write_str(unsafe { str::from_utf8_unchecked(&res[..max_digits]) })?;\n        } else {\n            // For large array use chunks of up to 1024 bytes (2048 hex chars)\n            let mut buf = [0u8; 2048];\n            let mut digits_left = max_digits;\n\n            for chunk in self[..max_hex].chunks(1024) {\n                for (i, c) in chunk.iter().enumerate() {\n                    buf[i * 2] = LOWER_CHARS[(c >> 4) as usize];\n                    buf[i * 2 + 1] = LOWER_CHARS[(c & 0xF) as usize];\n                }\n                let n = min(chunk.len() * 2, digits_left);\n                f.write_str(unsafe { str::from_utf8_unchecked(&buf[..n]) })?;\n                digits_left -= n;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hex.rs\"))"],"hex::<impl core::fmt::UpperHex for GenericArray<u8, T>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let max_digits = f.precision().unwrap_or_else(|| self.len() * 2);\n        let max_hex = (max_digits >> 1) + (max_digits & 1);\n\n        if T::to_usize() < 1024 {\n            // For small arrays use a stack allocated\n            // buffer of 2x number of bytes\n            let mut res = GenericArray::<u8, Sum<T, T>>::default();\n\n            for (i, c) in self.iter().take(max_hex).enumerate() {\n                res[i * 2] = UPPER_CHARS[(c >> 4) as usize];\n                res[i * 2 + 1] = UPPER_CHARS[(c & 0xF) as usize];\n            }\n            f.write_str(unsafe { str::from_utf8_unchecked(&res[..max_digits]) })?;\n        } else {\n            // For large array use chunks of up to 1024 bytes (2048 hex chars)\n            let mut buf = [0u8; 2048];\n            let mut digits_left = max_digits;\n\n            for chunk in self[..max_hex].chunks(1024) {\n                for (i, c) in chunk.iter().enumerate() {\n                    buf[i * 2] = UPPER_CHARS[(c >> 4) as usize];\n                    buf[i * 2 + 1] = UPPER_CHARS[(c & 0xF) as usize];\n                }\n                let n = min(chunk.len() * 2, digits_left);\n                f.write_str(unsafe { str::from_utf8_unchecked(&buf[..n]) })?;\n                digits_left -= n;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hex.rs\"))"],"impls::<impl core::borrow::Borrow<[T]> for GenericArray<T, N>>::borrow":["fn borrow(&self) -> &[T]{\n        &self[..]\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::borrow::BorrowMut<[T]> for GenericArray<T, N>>::borrow_mut":["fn borrow_mut(&mut self) -> &mut [T]{\n        &mut self[..]\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::clone::Clone for GenericArray<T, N>>::clone":["fn clone(&self) -> GenericArray<T, N>{\n        self.map(|x| x.clone())\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::cmp::Ord for GenericArray<T, N>>::cmp":["fn cmp(&self, other: &GenericArray<T, N>) -> Ordering{\n        Ord::cmp(self.as_slice(), other.as_slice())\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::cmp::PartialEq for GenericArray<T, N>>::eq":["fn eq(&self, other: &Self) -> bool{\n        **self == **other\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::cmp::PartialOrd for GenericArray<T, N>>::partial_cmp":["fn partial_cmp(&self, other: &GenericArray<T, N>) -> Option<Ordering>{\n        PartialOrd::partial_cmp(self.as_slice(), other.as_slice())\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::AsMut<[T]> for GenericArray<T, N>>::as_mut":["fn as_mut(&mut self) -> &mut [T]{\n        &mut self[..]\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::AsRef<[T]> for GenericArray<T, N>>::as_ref":["fn as_ref(&self) -> &[T]{\n        &self[..]\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 10]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 11]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 12]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 13]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 14]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 15]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 16]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 17]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 18]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 19]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 1]> for GenericArray<T, typenum::UInt<typenum::UTerm, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 20]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 21]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 22]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 23]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 24]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 25]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 26]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 27]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 28]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 29]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 2]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 30]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 31]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 32]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 3]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 4]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 5]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 6]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 7]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 8]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::convert::From<[T; 9]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>>>::from":["fn from(arr: [T; $n]) -> Self{\n                    use core::mem::{forget, transmute_copy};\n                    let x = unsafe { transmute_copy(&arr) };\n                    forget(arr);\n                    x\n                }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::default::Default for GenericArray<T, N>>::default":["#[inline]\nfn default() -> Self{\n        Self::generate(|_| T::default())\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::fmt::Debug for GenericArray<T, N>>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        self[..].fmt(fmt)\n    }","Real(LocalPath(\"src/impls.rs\"))"],"impls::<impl core::hash::Hash for GenericArray<T, N>>::hash":["fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,{\n        Hash::hash(&self[..], state)\n    }","Real(LocalPath(\"src/impls.rs\"))"],"iter::<impl core::iter::IntoIterator for GenericArray<T, N>>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        GenericArrayIter {\n            array: ManuallyDrop::new(self),\n            index: 0,\n            index_back: N::to_usize(),\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"iter::GenericArrayIter":["/// An iterator that moves out of a `GenericArray`\npub struct GenericArrayIter<T, N: ArrayLength<T>> {\n    // Invariants: index <= index_back <= N\n    // Only values in array[index..index_back] are alive at any given time.\n    // Values from array[..index] and array[index_back..] are already moved/dropped.\n    array: ManuallyDrop<GenericArray<T, N>>,\n    index: usize,\n    index_back: usize,\n}","Real(LocalPath(\"src/iter.rs\"))"],"iter::GenericArrayIter::<T, N>::as_mut_slice":["/// Returns the remaining items of this iterator as a mutable slice\n#[inline]\npub fn as_mut_slice(&mut self) -> &mut [T]{\n        &mut self.array.as_mut_slice()[self.index..self.index_back]\n    }","Real(LocalPath(\"src/iter.rs\"))"],"iter::GenericArrayIter::<T, N>::as_slice":["/// Returns the remaining items of this iterator as a slice\n#[inline]\npub fn as_slice(&self) -> &[T]{\n        &self.array.as_slice()[self.index..self.index_back]\n    }","Real(LocalPath(\"src/iter.rs\"))"],"sequence::Concat":["/// Defines `GenericSequence`s which can be joined together, forming a larger array.\npub unsafe trait Concat<T, M>: GenericSequence<T>\nwhere\n    M: ArrayLength<T>,\n{\n    /// Sequence to be concatenated with `self`\n    type Rest: GenericSequence<T, Length = M>;\n\n    /// Resulting sequence formed by the concatenation.\n    type Output: GenericSequence<T>;\n\n    /// Concatenate, or join, two sequences.\n    fn concat(self, rest: Self::Rest) -> Self::Output;\n}","Real(LocalPath(\"src/sequence.rs\"))"],"sequence::GenericSequence":["/// Defines some sequence with an associated length and iteration capabilities.\n///\n/// This is useful for passing N-length generic arrays as generics.\npub unsafe trait GenericSequence<T>: Sized + IntoIterator {\n    /// `GenericArray` associated length\n    type Length: ArrayLength<T>;\n\n    /// Concrete sequence type used in conjuction with reference implementations of `GenericSequence`\n    type Sequence: GenericSequence<T, Length = Self::Length> + FromIterator<T>;\n\n    /// Initializes a new sequence instance using the given function.\n    ///\n    /// If the generator function panics while initializing the sequence,\n    /// any already initialized elements will be dropped.\n    fn generate<F>(f: F) -> Self::Sequence\n    where\n        F: FnMut(usize) -> T;\n\n    #[doc(hidden)]\n    fn inverted_zip<B, U, F>(\n        self,\n        lhs: GenericArray<B, Self::Length>,\n        mut f: F,\n    ) -> MappedSequence<GenericArray<B, Self::Length>, B, U>\n    where\n        GenericArray<B, Self::Length>: GenericSequence<B, Length = Self::Length>\n            + MappedGenericSequence<B, U>,\n        Self: MappedGenericSequence<T, U>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        F: FnMut(B, Self::Item) -> U,\n    {\n        unsafe {\n            let mut left = ArrayConsumer::new(lhs);\n\n            let (left_array_iter, left_position) = left.iter_position();\n\n            FromIterator::from_iter(\n                left_array_iter\n                    .zip(self.into_iter())\n                    .map(|(l, right_value)| {\n                        let left_value = ptr::read(l);\n\n                        *left_position += 1;\n\n                        f(left_value, right_value)\n                    })\n            )\n        }\n    }\n\n    #[doc(hidden)]\n    fn inverted_zip2<B, Lhs, U, F>(self, lhs: Lhs, mut f: F) -> MappedSequence<Lhs, B, U>\n    where\n        Lhs: GenericSequence<B, Length = Self::Length> + MappedGenericSequence<B, U>,\n        Self: MappedGenericSequence<T, U>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        F: FnMut(Lhs::Item, Self::Item) -> U,\n    {\n        FromIterator::from_iter(lhs.into_iter().zip(self.into_iter()).map(|(l, r)| f(l, r)))\n    }\n}","Real(LocalPath(\"src/sequence.rs\"))"],"sequence::GenericSequence::inverted_zip":["#[doc(hidden)]\nfn inverted_zip<B, U, F>(\n        self,\n        lhs: GenericArray<B, Self::Length>,\n        mut f: F,\n    ) -> MappedSequence<GenericArray<B, Self::Length>, B, U>\n    where\n        GenericArray<B, Self::Length>: GenericSequence<B, Length = Self::Length>\n            + MappedGenericSequence<B, U>,\n        Self: MappedGenericSequence<T, U>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        F: FnMut(B, Self::Item) -> U,{\n        unsafe {\n            let mut left = ArrayConsumer::new(lhs);\n\n            let (left_array_iter, left_position) = left.iter_position();\n\n            FromIterator::from_iter(\n                left_array_iter\n                    .zip(self.into_iter())\n                    .map(|(l, right_value)| {\n                        let left_value = ptr::read(l);\n\n                        *left_position += 1;\n\n                        f(left_value, right_value)\n                    })\n            )\n        }\n    }","Real(LocalPath(\"src/sequence.rs\"))"],"sequence::GenericSequence::inverted_zip2":["#[doc(hidden)]\nfn inverted_zip2<B, Lhs, U, F>(self, lhs: Lhs, mut f: F) -> MappedSequence<Lhs, B, U>\n    where\n        Lhs: GenericSequence<B, Length = Self::Length> + MappedGenericSequence<B, U>,\n        Self: MappedGenericSequence<T, U>,\n        Self::Length: ArrayLength<B> + ArrayLength<U>,\n        F: FnMut(Lhs::Item, Self::Item) -> U,{\n        FromIterator::from_iter(lhs.into_iter().zip(self.into_iter()).map(|(l, r)| f(l, r)))\n    }","Real(LocalPath(\"src/sequence.rs\"))"],"sequence::Lengthen":["/// Defines any `GenericSequence` which can be lengthened or extended by appending\n/// or prepending an element to it.\n///\n/// Any lengthened sequence can be shortened back to the original using `pop_front` or `pop_back`\npub unsafe trait Lengthen<T>: Sized + GenericSequence<T> {\n    /// `GenericSequence` that has one more element than `Self`\n    type Longer: Shorten<T, Shorter = Self>;\n\n    /// Returns a new array with the given element appended to the end of it.\n    ///\n    /// Example:\n    ///\n    /// ```ignore\n    /// let a = arr![i32; 1, 2, 3];\n    ///\n    /// let b = a.append(4);\n    ///\n    /// assert_eq!(b, arr![i32; 1, 2, 3, 4]);\n    /// ```\n    fn append(self, last: T) -> Self::Longer;\n\n    /// Returns a new array with the given element prepended to the front of it.\n    ///\n    /// Example:\n    ///\n    /// ```ignore\n    /// let a = arr![i32; 1, 2, 3];\n    ///\n    /// let b = a.prepend(4);\n    ///\n    /// assert_eq!(b, arr![i32; 4, 1, 2, 3]);\n    /// ```\n    fn prepend(self, first: T) -> Self::Longer;\n}","Real(LocalPath(\"src/sequence.rs\"))"],"sequence::Shorten":["/// Defines a `GenericSequence` which can be shortened by removing the first or last element from it.\n///\n/// Additionally, any shortened sequence can be lengthened by\n/// appending or prepending an element to it.\npub unsafe trait Shorten<T>: Sized + GenericSequence<T> {\n    /// `GenericSequence` that has one less element than `Self`\n    type Shorter: Lengthen<T, Longer = Self>;\n\n    /// Returns a new array without the last element, and the last element.\n    ///\n    /// Example:\n    ///\n    /// ```ignore\n    /// let a = arr![i32; 1, 2, 3, 4];\n    ///\n    /// let (init, last) = a.pop_back();\n    ///\n    /// assert_eq!(init, arr![i32; 1, 2, 3]);\n    /// assert_eq!(last, 4);\n    /// ```\n    fn pop_back(self) -> (Self::Shorter, T);\n\n    /// Returns a new array without the first element, and the first element.\n    /// Example:\n    ///\n    /// ```ignore\n    /// let a = arr![i32; 1, 2, 3, 4];\n    ///\n    /// let (head, tail) = a.pop_front();\n    ///\n    /// assert_eq!(head, 1);\n    /// assert_eq!(tail, arr![i32; 2, 3, 4]);\n    /// ```\n    fn pop_front(self) -> (T, Self::Shorter);\n}","Real(LocalPath(\"src/sequence.rs\"))"],"sequence::Split":["/// Defines a `GenericSequence` that can be split into two parts at a given pivot index.\npub unsafe trait Split<T, K>: GenericSequence<T>\nwhere\n    K: ArrayLength<T>,\n{\n    /// First part of the resulting split array\n    type First: GenericSequence<T>;\n    /// Second part of the resulting split array\n    type Second: GenericSequence<T>;\n\n    /// Splits an array at the given index, returning the separate parts of the array.\n    fn split(self) -> (Self::First, Self::Second);\n}","Real(LocalPath(\"src/sequence.rs\"))"],"transmute":["/// A reimplementation of the `transmute` function, avoiding problems\n/// when the compiler can't prove equal sizes.\n#[inline]\n#[doc(hidden)]\npub unsafe fn transmute<A, B>(a: A) -> B{\n    let b = ::core::ptr::read(&a as *const A as *const B);\n    ::core::mem::forget(a);\n    b\n}","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"!":["from_iter_length_fail"],"&[T]":["as_ref","as_slice","borrow","deref"],"&mut [T]":["as_mut","as_mut_slice","borrow_mut","deref_mut"],"(<GenericArray<T, N> as sequence::Shorten<T>>::Shorter, T)":["pop_back"],"(<GenericArray<T, N> as sequence::Split<T, K>>::First, <GenericArray<T, N> as sequence::Split<T, K>>::Second)":["split"],"(<Self as sequence::Shorten<T>>::Shorter, T)":["pop_back"],"(<Self as sequence::Split<T, K>>::First, <Self as sequence::Split<T, K>>::Second)":["split"],"(T, <GenericArray<T, N> as sequence::Shorten<T>>::Shorter)":["pop_front"],"(T, <Self as sequence::Shorten<T>>::Shorter)":["pop_front"],"(core::slice::Iter<'_, T>, &mut usize)":["iter_position"],"(core::slice::IterMut<'_, T>, &mut usize)":["iter_position"],"(usize, core::option::Option<usize>)":["size_hint"],"<&'a GenericArray<T, N> as core::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a S as sequence::GenericSequence<T>>::Sequence":["generate"],"<&'a mut GenericArray<T, N> as core::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a mut S as sequence::GenericSequence<T>>::Sequence":["generate"],"<<GenericArray<B, <GenericArray<T, N> as sequence::GenericSequence<T>>::Length> as functional::MappedGenericSequence<B, U>>::Mapped as sequence::GenericSequence<U>>::Sequence":["inverted_zip"],"<<GenericArray<B, <Self as sequence::GenericSequence<T>>::Length> as functional::MappedGenericSequence<B, U>>::Mapped as sequence::GenericSequence<U>>::Sequence":["inverted_zip"],"<<GenericArray<T, N> as functional::MappedGenericSequence<T, U>>::Mapped as sequence::GenericSequence<U>>::Sequence":["map","zip"],"<<Lhs as functional::MappedGenericSequence<B, U>>::Mapped as sequence::GenericSequence<U>>::Sequence":["inverted_zip2"],"<<Self as functional::MappedGenericSequence<T, U>>::Mapped as sequence::GenericSequence<U>>::Sequence":["map","zip"],"<GenericArray<T, N> as core::iter::IntoIterator>::IntoIter":["into_iter"],"<GenericArray<T, N> as sequence::Concat<T, M>>::Output":["concat"],"<GenericArray<T, N> as sequence::Lengthen<T>>::Longer":["append","prepend"],"<Self as sequence::Concat<T, M>>::Output":["concat"],"<Self as sequence::GenericSequence<T>>::Sequence":["generate"],"<Self as sequence::Lengthen<T>>::Longer":["append","prepend"],"ArrayBuilder":["new"],"ArrayConsumer":["new"],"GenericArray":["clone","clone_from_slice","default","from","from_iter","generate","into_inner"],"GenericArrayImplEven":["clone"],"GenericArrayImplOdd":["clone"],"bool":["eq"],"core::cmp::Ordering":["cmp"],"core::option::Option":["from_exact_iter","last","next","next_back","nth","partial_cmp"],"core::result::Result":["fmt"],"iter::GenericArrayIter":["clone"],"usize":["count","len"]},"struct_to_trait":{"<N1 as arr::AddLength<T, N2>>::N1":["arr::AddLength"],"ArrayBuilder":["core::ops::Drop"],"ArrayConsumer":["core::ops::Drop"],"GenericArray":["core::borrow::Borrow","core::borrow::BorrowMut","core::clone::Clone","core::cmp::Eq","core::cmp::Ord","core::cmp::PartialEq","core::cmp::PartialOrd","core::convert::AsMut","core::convert::AsRef","core::convert::From","core::default::Default","core::fmt::Debug","core::fmt::LowerHex","core::fmt::UpperHex","core::hash::Hash","core::iter::FromIterator","core::iter::IntoIterator","core::marker::Copy","core::marker::Send","core::marker::Sync","core::ops::Deref","core::ops::DerefMut","functional::FunctionalSequence","functional::MappedGenericSequence","sequence::Concat","sequence::GenericSequence","sequence::Lengthen","sequence::Shorten","sequence::Split"],"GenericArrayImplEven":["core::clone::Clone","core::marker::Copy"],"GenericArrayImplOdd":["core::clone::Clone","core::marker::Copy"],"iter::GenericArrayIter":["core::clone::Clone","core::fmt::Debug","core::iter::DoubleEndedIterator","core::iter::ExactSizeIterator","core::iter::Iterator","core::ops::Drop"],"typenum::UInt":["ArrayLength"],"typenum::UTerm":["ArrayLength"]},"targets":{"<&'a GenericArray<T, N> as core::convert::From<&'a [T]>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","core::convert::From"],"<&'a GenericArray<T, N> as core::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","core::iter::IntoIterator"],"<&'a S as sequence::GenericSequence<T>>::generate":["generate","Real(LocalPath(\"src/sequence.rs\"))","sequence::GenericSequence"],"<&'a mut GenericArray<T, N> as core::convert::From<&'a mut [T]>>::from":["from","Real(LocalPath(\"src/lib.rs\"))","core::convert::From"],"<&'a mut GenericArray<T, N> as core::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","core::iter::IntoIterator"],"<&'a mut S as sequence::GenericSequence<T>>::generate":["generate","Real(LocalPath(\"src/sequence.rs\"))","sequence::GenericSequence"],"<ArrayBuilder<T, N> as core::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","core::ops::Drop"],"<ArrayConsumer<T, N> as core::ops::Drop>::drop":["drop","Real(LocalPath(\"src/lib.rs\"))","core::ops::Drop"],"<GenericArray<T, N> as core::iter::FromIterator<T>>::from_iter":["from_iter","Real(LocalPath(\"src/lib.rs\"))","core::iter::FromIterator"],"<GenericArray<T, N> as core::ops::Deref>::deref":["deref","Real(LocalPath(\"src/lib.rs\"))","core::ops::Deref"],"<GenericArray<T, N> as core::ops::DerefMut>::deref_mut":["deref_mut","Real(LocalPath(\"src/lib.rs\"))","core::ops::DerefMut"],"<GenericArray<T, N> as functional::FunctionalSequence<T>>::fold":["fold","Real(LocalPath(\"src/lib.rs\"))","functional::FunctionalSequence"],"<GenericArray<T, N> as functional::FunctionalSequence<T>>::map":["map","Real(LocalPath(\"src/lib.rs\"))","functional::FunctionalSequence"],"<GenericArray<T, N> as functional::FunctionalSequence<T>>::zip":["zip","Real(LocalPath(\"src/lib.rs\"))","functional::FunctionalSequence"],"<GenericArray<T, N> as sequence::Concat<T, M>>::concat":["concat","Real(LocalPath(\"src/sequence.rs\"))","sequence::Concat"],"<GenericArray<T, N> as sequence::GenericSequence<T>>::generate":["generate","Real(LocalPath(\"src/lib.rs\"))","sequence::GenericSequence"],"<GenericArray<T, N> as sequence::GenericSequence<T>>::inverted_zip":["inverted_zip","Real(LocalPath(\"src/lib.rs\"))","sequence::GenericSequence"],"<GenericArray<T, N> as sequence::GenericSequence<T>>::inverted_zip2":["inverted_zip2","Real(LocalPath(\"src/lib.rs\"))","sequence::GenericSequence"],"<GenericArray<T, N> as sequence::Lengthen<T>>::append":["append","Real(LocalPath(\"src/sequence.rs\"))","sequence::Lengthen"],"<GenericArray<T, N> as sequence::Lengthen<T>>::prepend":["prepend","Real(LocalPath(\"src/sequence.rs\"))","sequence::Lengthen"],"<GenericArray<T, N> as sequence::Shorten<T>>::pop_back":["pop_back","Real(LocalPath(\"src/sequence.rs\"))","sequence::Shorten"],"<GenericArray<T, N> as sequence::Shorten<T>>::pop_front":["pop_front","Real(LocalPath(\"src/sequence.rs\"))","sequence::Shorten"],"<GenericArray<T, N> as sequence::Split<T, K>>::split":["split","Real(LocalPath(\"src/sequence.rs\"))","sequence::Split"],"<GenericArrayImplEven<T, U> as core::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","core::clone::Clone"],"<GenericArrayImplOdd<T, U> as core::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","core::clone::Clone"],"<iter::GenericArrayIter<T, N> as core::clone::Clone>::clone":["clone","Real(LocalPath(\"src/iter.rs\"))","core::clone::Clone"],"<iter::GenericArrayIter<T, N> as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/iter.rs\"))","core::fmt::Debug"],"<iter::GenericArrayIter<T, N> as core::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/iter.rs\"))","core::iter::DoubleEndedIterator"],"<iter::GenericArrayIter<T, N> as core::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/iter.rs\"))","core::iter::ExactSizeIterator"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::count":["count","Real(LocalPath(\"src/iter.rs\"))","core::iter::Iterator"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::last":["last","Real(LocalPath(\"src/iter.rs\"))","core::iter::Iterator"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::next":["next","Real(LocalPath(\"src/iter.rs\"))","core::iter::Iterator"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::nth":["nth","Real(LocalPath(\"src/iter.rs\"))","core::iter::Iterator"],"<iter::GenericArrayIter<T, N> as core::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/iter.rs\"))","core::iter::Iterator"],"<iter::GenericArrayIter<T, N> as core::ops::Drop>::drop":["drop","Real(LocalPath(\"src/iter.rs\"))","core::ops::Drop"],"ArrayBuilder::<T, N>::into_inner":["into_inner","Real(LocalPath(\"src/lib.rs\"))",""],"ArrayBuilder::<T, N>::iter_position":["iter_position","Real(LocalPath(\"src/lib.rs\"))",""],"ArrayBuilder::<T, N>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"ArrayConsumer::<T, N>::iter_position":["iter_position","Real(LocalPath(\"src/lib.rs\"))",""],"ArrayConsumer::<T, N>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"GenericArray::<T, N>::as_mut_slice":["as_mut_slice","Real(LocalPath(\"src/lib.rs\"))",""],"GenericArray::<T, N>::as_slice":["as_slice","Real(LocalPath(\"src/lib.rs\"))",""],"GenericArray::<T, N>::clone_from_slice":["clone_from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"GenericArray::<T, N>::from_exact_iter":["from_exact_iter","Real(LocalPath(\"src/lib.rs\"))",""],"GenericArray::<T, N>::from_mut_slice":["from_mut_slice","Real(LocalPath(\"src/lib.rs\"))",""],"GenericArray::<T, N>::from_slice":["from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"from_iter_length_fail":["from_iter_length_fail","Real(LocalPath(\"src/lib.rs\"))",""],"functional::FunctionalSequence::fold":["fold","Real(LocalPath(\"src/functional.rs\"))",""],"functional::FunctionalSequence::map":["map","Real(LocalPath(\"src/functional.rs\"))",""],"functional::FunctionalSequence::zip":["zip","Real(LocalPath(\"src/functional.rs\"))",""],"hex::<impl core::fmt::LowerHex for GenericArray<u8, T>>::fmt":["fmt","Real(LocalPath(\"src/hex.rs\"))","core::fmt::LowerHex"],"hex::<impl core::fmt::UpperHex for GenericArray<u8, T>>::fmt":["fmt","Real(LocalPath(\"src/hex.rs\"))","core::fmt::UpperHex"],"impls::<impl core::borrow::Borrow<[T]> for GenericArray<T, N>>::borrow":["borrow","Real(LocalPath(\"src/impls.rs\"))","core::borrow::Borrow"],"impls::<impl core::borrow::BorrowMut<[T]> for GenericArray<T, N>>::borrow_mut":["borrow_mut","Real(LocalPath(\"src/impls.rs\"))","core::borrow::BorrowMut"],"impls::<impl core::clone::Clone for GenericArray<T, N>>::clone":["clone","Real(LocalPath(\"src/impls.rs\"))","core::clone::Clone"],"impls::<impl core::cmp::Ord for GenericArray<T, N>>::cmp":["cmp","Real(LocalPath(\"src/impls.rs\"))","core::cmp::Ord"],"impls::<impl core::cmp::PartialEq for GenericArray<T, N>>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","core::cmp::PartialEq"],"impls::<impl core::cmp::PartialOrd for GenericArray<T, N>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","core::cmp::PartialOrd"],"impls::<impl core::convert::AsMut<[T]> for GenericArray<T, N>>::as_mut":["as_mut","Real(LocalPath(\"src/impls.rs\"))","core::convert::AsMut"],"impls::<impl core::convert::AsRef<[T]> for GenericArray<T, N>>::as_ref":["as_ref","Real(LocalPath(\"src/impls.rs\"))","core::convert::AsRef"],"impls::<impl core::convert::From<[T; 10]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 11]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 12]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 13]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 14]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 15]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 16]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 17]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 18]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 19]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 1]> for GenericArray<T, typenum::UInt<typenum::UTerm, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 20]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 21]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 22]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 23]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 24]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 25]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 26]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 27]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 28]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 29]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 2]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 30]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 31]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 32]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 3]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 4]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 5]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 6]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 7]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B1>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 8]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B0>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::convert::From<[T; 9]> for GenericArray<T, typenum::UInt<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B0>, typenum::B1>>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","core::convert::From"],"impls::<impl core::default::Default for GenericArray<T, N>>::default":["default","Real(LocalPath(\"src/impls.rs\"))","core::default::Default"],"impls::<impl core::fmt::Debug for GenericArray<T, N>>::fmt":["fmt","Real(LocalPath(\"src/impls.rs\"))","core::fmt::Debug"],"impls::<impl core::hash::Hash for GenericArray<T, N>>::hash":["hash","Real(LocalPath(\"src/impls.rs\"))","core::hash::Hash"],"iter::<impl core::iter::IntoIterator for GenericArray<T, N>>::into_iter":["into_iter","Real(LocalPath(\"src/iter.rs\"))","core::iter::IntoIterator"],"iter::GenericArrayIter::<T, N>::as_mut_slice":["as_mut_slice","Real(LocalPath(\"src/iter.rs\"))",""],"iter::GenericArrayIter::<T, N>::as_slice":["as_slice","Real(LocalPath(\"src/iter.rs\"))",""],"sequence::GenericSequence::inverted_zip":["inverted_zip","Real(LocalPath(\"src/sequence.rs\"))",""],"sequence::GenericSequence::inverted_zip2":["inverted_zip2","Real(LocalPath(\"src/sequence.rs\"))",""],"transmute":["transmute","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"ArrayLength":["typenum::UInt","typenum::UTerm"],"arr::AddLength":["<N1 as arr::AddLength<T, N2>>::N1"],"core::borrow::Borrow":["GenericArray"],"core::borrow::BorrowMut":["GenericArray"],"core::clone::Clone":["GenericArray","GenericArrayImplEven","GenericArrayImplOdd","iter::GenericArrayIter"],"core::cmp::Eq":["GenericArray"],"core::cmp::Ord":["GenericArray"],"core::cmp::PartialEq":["GenericArray"],"core::cmp::PartialOrd":["GenericArray"],"core::convert::AsMut":["GenericArray"],"core::convert::AsRef":["GenericArray"],"core::convert::From":["GenericArray"],"core::default::Default":["GenericArray"],"core::fmt::Debug":["GenericArray","iter::GenericArrayIter"],"core::fmt::LowerHex":["GenericArray"],"core::fmt::UpperHex":["GenericArray"],"core::hash::Hash":["GenericArray"],"core::iter::DoubleEndedIterator":["iter::GenericArrayIter"],"core::iter::ExactSizeIterator":["iter::GenericArrayIter"],"core::iter::FromIterator":["GenericArray"],"core::iter::IntoIterator":["GenericArray"],"core::iter::Iterator":["iter::GenericArrayIter"],"core::marker::Copy":["GenericArray","GenericArrayImplEven","GenericArrayImplOdd"],"core::marker::Send":["GenericArray"],"core::marker::Sync":["GenericArray"],"core::ops::Deref":["GenericArray"],"core::ops::DerefMut":["GenericArray"],"core::ops::Drop":["ArrayBuilder","ArrayConsumer","iter::GenericArrayIter"],"functional::FunctionalSequence":["GenericArray"],"functional::MappedGenericSequence":["GenericArray"],"sequence::Concat":["GenericArray"],"sequence::GenericSequence":["GenericArray"],"sequence::Lengthen":["GenericArray"],"sequence::Shorten":["GenericArray"],"sequence::Split":["GenericArray"]},"type_to_def_path":{"ArrayBuilder<T, N>":"ArrayBuilder","ArrayConsumer<T, N>":"ArrayConsumer","GenericArray<T, U>":"GenericArray","GenericArrayImplEven<T, U>":"GenericArrayImplEven","GenericArrayImplOdd<T, U>":"GenericArrayImplOdd","iter::GenericArrayIter<T, N>":"iter::GenericArrayIter"}}