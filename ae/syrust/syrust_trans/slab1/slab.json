{"dependencies":{"<&'a Slab<T> as std::iter::IntoIterator>::into_iter":["Iter","Slab","std::alloc::Allocator","std::marker::Sized","std::slice::Iter","std::vec::Vec"],"<&'a mut Slab<T> as std::iter::IntoIterator>::into_iter":["IterMut","Slab","std::alloc::Allocator","std::marker::Sized","std::slice::IterMut","std::vec::Vec"],"<Drain<'a, T> as std::fmt::Debug>::fmt":["Drain","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Drain"],"<Drain<'a, T> as std::iter::Iterator>::next":["Drain","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Drain"],"<Entry<T> as std::clone::Clone>::clone":["Entry","std::marker::Sized"],"<Iter<'a, T> as std::fmt::Debug>::fmt":["Iter","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::slice::Iter"],"<Iter<'a, T> as std::iter::Iterator>::next":["Iter","std::marker::Sized","std::option::Option","std::slice::Iter"],"<IterMut<'a, T> as std::fmt::Debug>::fmt":["IterMut","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::slice::IterMut"],"<IterMut<'a, T> as std::iter::Iterator>::next":["IterMut","std::marker::Sized","std::option::Option","std::slice::IterMut"],"<Slab<T> as std::clone::Clone>::clone":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<Slab<T> as std::default::Default>::default":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<Slab<T> as std::fmt::Debug>::fmt":["Slab","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<Slab<T> as std::ops::Index<usize>>::index":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<Slab<T> as std::ops::IndexMut<usize>>::index_mut":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<VacantEntry<'a, T> as std::fmt::Debug>::fmt":["Slab","VacantEntry","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"Drain":["Drain","std::alloc::Allocator","std::marker::Sized","std::vec::Drain"],"Entry":["Entry","std::marker::Sized"],"Iter":["Iter","std::marker::Sized","std::slice::Iter"],"IterMut":["IterMut","std::marker::Sized","std::slice::IterMut"],"Slab":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::capacity":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::clear":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::contains":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::drain":["Drain","Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Drain","std::vec::Vec"],"Slab::<T>::get":["Slab","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"Slab::<T>::get_mut":["Slab","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"Slab::<T>::get_unchecked":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::get_unchecked_mut":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::insert":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::insert_at":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::is_empty":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::iter":["Iter","Slab","std::alloc::Allocator","std::marker::Sized","std::slice::Iter","std::vec::Vec"],"Slab::<T>::iter_mut":["IterMut","Slab","std::alloc::Allocator","std::marker::Sized","std::slice::IterMut","std::vec::Vec"],"Slab::<T>::len":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::new":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::remove":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::reserve":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::reserve_exact":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::retain":["Slab","std::alloc::Allocator","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"Slab::<T>::shrink_to_fit":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::vacant_entry":["Slab","VacantEntry","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"Slab::<T>::with_capacity":["Slab","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"VacantEntry":["Slab","VacantEntry","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"VacantEntry::<'a, T>::insert":["Slab","VacantEntry","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"VacantEntry::<'a, T>::key":["Slab","VacantEntry","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"]},"glob_path_import":{},"self_to_fn":{"Drain":["impl<'a, T: 'a> fmt::Debug for Drain<'a, T> {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_struct(\"Drain\").finish()\n    }\n}","impl<'a, T> Iterator for Drain<'a, T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        while let Some(entry) = self.0.next() {\n            if let Entry::Occupied(v) = entry {\n                return Some(v);\n            }\n        }\n\n        None\n    }\n}"],"Entry":["Clone"],"Iter":["impl<'a, T: 'a> fmt::Debug for Iter<'a, T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_struct(\"Iter\")\n            .field(\"curr\", &self.curr)\n            .field(\"remaining\", &self.entries.len())\n            .finish()\n    }\n}","impl<'a, T> Iterator for Iter<'a, T> {\n    type Item = (usize, &'a T);\n\n    fn next(&mut self) -> Option<(usize, &'a T)> {\n        while let Some(entry) = self.entries.next() {\n            let curr = self.curr;\n            self.curr += 1;\n\n            if let Entry::Occupied(ref v) = *entry {\n                return Some((curr, v));\n            }\n        }\n\n        None\n    }\n}"],"IterMut":["impl<'a, T: 'a> fmt::Debug for IterMut<'a, T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        fmt.debug_struct(\"IterMut\")\n            .field(\"curr\", &self.curr)\n            .field(\"remaining\", &self.entries.len())\n            .finish()\n    }\n}","impl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = (usize, &'a mut T);\n\n    fn next(&mut self) -> Option<(usize, &'a mut T)> {\n        while let Some(entry) = self.entries.next() {\n            let curr = self.curr;\n            self.curr += 1;\n\n            if let Entry::Occupied(ref mut v) = *entry {\n                return Some((curr, v));\n            }\n        }\n\n        None\n    }\n}"],"Slab":["Clone","impl<T> Default for Slab<T> {\n    fn default() -> Self {\n        Slab::new()\n    }\n}","impl<T> Slab<T> {\n    /// Construct a new, empty `Slab`.\n    ///\n    /// The function does not allocate and the returned slab will have no\n    /// capacity until `insert` is called or capacity is explicitly reserved.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let slab: Slab<i32> = Slab::new();\n    /// ```\n    pub fn new() -> Slab<T> {\n        Slab::with_capacity(0)\n    }\n\n    /// Construct a new, empty `Slab` with the specified capacity.\n    ///\n    /// The returned slab will be able to store exactly `capacity` without\n    /// reallocating. If `capacity` is 0, the slab will not allocate.\n    ///\n    /// It is important to note that this function does not specify the *length*\n    /// of the returned slab, but only the capacity. For an explanation of the\n    /// difference between length and capacity, see [Capacity and\n    /// reallocation](index.html#capacity-and-reallocation).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::with_capacity(10);\n    ///\n    /// // The slab contains no values, even though it has capacity for more\n    /// assert_eq!(slab.len(), 0);\n    ///\n    /// // These are all done without reallocating...\n    /// for i in 0..10 {\n    ///     slab.insert(i);\n    /// }\n    ///\n    /// // ...but this may make the slab reallocate\n    /// slab.insert(11);\n    /// ```\n    pub fn with_capacity(capacity: usize) -> Slab<T> {\n        Slab {\n            entries: Vec::with_capacity(capacity),\n            next: 0,\n            len: 0,\n        }\n    }\n\n    /// Return the number of values the slab can store without reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let slab: Slab<i32> = Slab::with_capacity(10);\n    /// assert_eq!(slab.capacity(), 10);\n    /// ```\n    pub fn capacity(&self) -> usize {\n        self.entries.capacity()\n    }\n\n    /// Reserve capacity for at least `additional` more values to be stored\n    /// without allocating.\n    ///\n    /// `reserve` does nothing if the slab already has sufficient capacity for\n    /// `additional` more values. If more capacity is required, a new segment of\n    /// memory will be allocated and all existing values will be copied into it.\n    /// As such, if the slab is already very large, a call to `reserve` can end\n    /// up being expensive.\n    ///\n    /// The slab may reserve more than `additional` extra space in order to\n    /// avoid frequent reallocations. Use `reserve_exact` instead to guarantee\n    /// that only the requested space is allocated.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    /// slab.insert(\"hello\");\n    /// slab.reserve(10);\n    /// assert!(slab.capacity() >= 11);\n    /// ```\n    pub fn reserve(&mut self, additional: usize) {\n        if self.capacity() - self.len >= additional {\n            return;\n        }\n        let need_add = self.len + additional - self.entries.len();\n        self.entries.reserve(need_add);\n    }\n\n    /// Reserve the minimum capacity required to store exactly `additional`\n    /// more values.\n    ///\n    /// `reserve_exact` does nothing if the slab already has sufficient capacity\n    /// for `additional` more valus. If more capacity is required, a new segment\n    /// of memory will be allocated and all existing values will be copied into\n    /// it.  As such, if the slab is already very large, a call to `reserve` can\n    /// end up being expensive.\n    ///\n    /// Note that the allocator may give the slab more space than it requests.\n    /// Therefore capacity can not be relied upon to be precisely minimal.\n    /// Prefer `reserve` if future insertions are expected.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    /// slab.insert(\"hello\");\n    /// slab.reserve_exact(10);\n    /// assert!(slab.capacity() >= 11);\n    /// ```\n    pub fn reserve_exact(&mut self, additional: usize) {\n        if self.capacity() - self.len >= additional {\n            return;\n        }\n        let need_add = self.len + additional - self.entries.len();\n        self.entries.reserve_exact(need_add);\n    }\n\n    /// Shrink the capacity of the slab as much as possible.\n    ///\n    /// It will drop down as close as possible to the length but the allocator\n    /// may still inform the vector that there is space for a few more elements.\n    /// Also, since values are not moved, the slab cannot shrink past any stored\n    /// values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::with_capacity(10);\n    ///\n    /// for i in 0..3 {\n    ///     slab.insert(i);\n    /// }\n    ///\n    /// assert_eq!(slab.capacity(), 10);\n    /// slab.shrink_to_fit();\n    /// assert!(slab.capacity() >= 3);\n    /// ```\n    ///\n    /// In this case, even though two values are removed, the slab cannot shrink\n    /// past the last value.\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::with_capacity(10);\n    ///\n    /// for i in 0..3 {\n    ///     slab.insert(i);\n    /// }\n    ///\n    /// slab.remove(0);\n    /// slab.remove(1);\n    ///\n    /// assert_eq!(slab.capacity(), 10);\n    /// slab.shrink_to_fit();\n    /// assert!(slab.capacity() >= 3);\n    /// ```\n    pub fn shrink_to_fit(&mut self) {\n        self.entries.shrink_to_fit();\n    }\n\n    /// Clear the slab of all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    ///\n    /// for i in 0..3 {\n    ///     slab.insert(i);\n    /// }\n    ///\n    /// slab.clear();\n    /// assert!(slab.is_empty());\n    /// ```\n    pub fn clear(&mut self) {\n        self.entries.clear();\n        self.len = 0;\n        self.next = 0;\n    }\n\n    /// Return the number of stored values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    ///\n    /// for i in 0..3 {\n    ///     slab.insert(i);\n    /// }\n    ///\n    /// assert_eq!(3, slab.len());\n    /// ```\n    pub fn len(&self) -> usize {\n        self.len\n    }\n\n    /// Return `true` if there are no values stored in the slab.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    /// assert!(slab.is_empty());\n    ///\n    /// slab.insert(1);\n    /// assert!(!slab.is_empty());\n    /// ```\n    pub fn is_empty(&self) -> bool {\n        self.len == 0\n    }\n\n    /// Return an iterator over the slab.\n    ///\n    /// This function should generally be **avoided** as it is not efficient.\n    /// Iterators must iterate over every slot in the slab even if it is\n    /// vacant. As such, a slab with a capacity of 1 million but only one\n    /// stored value must still iterate the million slots.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    ///\n    /// for i in 0..3 {\n    ///     slab.insert(i);\n    /// }\n    ///\n    /// let mut iterator = slab.iter();\n    ///\n    /// assert_eq!(iterator.next(), Some((0, &0)));\n    /// assert_eq!(iterator.next(), Some((1, &1)));\n    /// assert_eq!(iterator.next(), Some((2, &2)));\n    /// assert_eq!(iterator.next(), None);\n    /// ```\n    pub fn iter(&self) -> Iter<T> {\n        Iter {\n            entries: self.entries.iter(),\n            curr: 0,\n        }\n    }\n\n    /// Return an iterator that allows modifying each value.\n    ///\n    /// This function should generally be **avoided** as it is not efficient.\n    /// Iterators must iterate over every slot in the slab even if it is\n    /// vacant. As such, a slab with a capacity of 1 million but only one\n    /// stored value must still iterate the million slots.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    ///\n    /// let key1 = slab.insert(0);\n    /// let key2 = slab.insert(1);\n    ///\n    /// for (key, val) in slab.iter_mut() {\n    ///     if key == key1 {\n    ///         *val += 2;\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(slab[key1], 2);\n    /// assert_eq!(slab[key2], 1);\n    /// ```\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut {\n            entries: self.entries.iter_mut(),\n            curr: 0,\n        }\n    }\n\n    /// Return a reference to the value associated with the given key.\n    ///\n    /// If the given key is not associated with a value, then `None` is\n    /// returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    /// let key = slab.insert(\"hello\");\n    ///\n    /// assert_eq!(slab.get(key), Some(&\"hello\"));\n    /// assert_eq!(slab.get(123), None);\n    /// ```\n    pub fn get(&self, key: usize) -> Option<&T> {\n        match self.entries.get(key) {\n            Some(&Entry::Occupied(ref val)) => Some(val),\n            _ => None,\n        }\n    }\n\n    /// Return a mutable reference to the value associated with the given key.\n    ///\n    /// If the given key is not associated with a value, then `None` is\n    /// returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    /// let key = slab.insert(\"hello\");\n    ///\n    /// *slab.get_mut(key).unwrap() = \"world\";\n    ///\n    /// assert_eq!(slab[key], \"world\");\n    /// assert_eq!(slab.get_mut(123), None);\n    /// ```\n    pub fn get_mut(&mut self, key: usize) -> Option<&mut T> {\n        match self.entries.get_mut(key) {\n            Some(&mut Entry::Occupied(ref mut val)) => Some(val),\n            _ => None,\n        }\n    }\n\n    /// Return a reference to the value associated with the given key without\n    /// performing bounds checking.\n    ///\n    /// This function should be used with care.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    /// let key = slab.insert(2);\n    ///\n    /// unsafe {\n    ///     assert_eq!(slab.get_unchecked(key), &2);\n    /// }\n    /// ```\n    pub unsafe fn get_unchecked(&self, key: usize) -> &T {\n        match *self.entries.get_unchecked(key) {\n            Entry::Occupied(ref val) => val,\n            _ => unreachable!(),\n        }\n    }\n\n    /// Return a mutable reference to the value associated with the given key\n    /// without performing bounds checking.\n    ///\n    /// This function should be used with care.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    /// let key = slab.insert(2);\n    ///\n    /// unsafe {\n    ///     let val = slab.get_unchecked_mut(key);\n    ///     *val = 13;\n    /// }\n    ///\n    /// assert_eq!(slab[key], 13);\n    /// ```\n    pub unsafe fn get_unchecked_mut(&mut self, key: usize) -> &mut T {\n        match *self.entries.get_unchecked_mut(key) {\n            Entry::Occupied(ref mut val) => val,\n            _ => unreachable!(),\n        }\n    }\n\n    /// Insert a value in the slab, returning key assigned to the value.\n    ///\n    /// The returned key can later be used to retrieve or remove the value using indexed\n    /// lookup and `remove`. Additional capacity is allocated if needed. See\n    /// [Capacity and reallocation](index.html#capacity-and-reallocation).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the number of elements in the vector overflows a `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    /// let key = slab.insert(\"hello\");\n    /// assert_eq!(slab[key], \"hello\");\n    /// ```\n    pub fn insert(&mut self, val: T) -> usize {\n        let key = self.next;\n\n        self.insert_at(key, val);\n\n        key\n    }\n\n    /// Return a handle to a vacant entry allowing for further manipulation.\n    ///\n    /// This function is useful when creating values that must contain their\n    /// slab key. The returned `VacantEntry` reserves a slot in the slab and is\n    /// able to query the associated key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    ///\n    /// let hello = {\n    ///     let entry = slab.vacant_entry();\n    ///     let key = entry.key();\n    ///\n    ///     entry.insert((key, \"hello\"));\n    ///     key\n    /// };\n    ///\n    /// assert_eq!(hello, slab[hello].0);\n    /// assert_eq!(\"hello\", slab[hello].1);\n    /// ```\n    pub fn vacant_entry(&mut self) -> VacantEntry<T> {\n        VacantEntry {\n            key: self.next,\n            slab: self,\n        }\n    }\n\n    fn insert_at(&mut self, key: usize, val: T) {\n        self.len += 1;\n\n        if key == self.entries.len() {\n            self.entries.push(Entry::Occupied(val));\n            self.next = key + 1;\n        } else {\n            let prev = mem::replace(&mut self.entries[key], Entry::Occupied(val));\n\n            match prev {\n                Entry::Vacant(next) => {\n                    self.next = next;\n                }\n                _ => unreachable!(),\n            }\n        }\n    }\n\n    /// Remove and return the value associated with the given key.\n    ///\n    /// The key is then released and may be associated with future stored\n    /// values.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `key` is not associated with a value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    ///\n    /// let hello = slab.insert(\"hello\");\n    ///\n    /// assert_eq!(slab.remove(hello), \"hello\");\n    /// assert!(!slab.contains(hello));\n    /// ```\n    pub fn remove(&mut self, key: usize) -> T {\n        // Swap the entry at the provided value\n        let prev = mem::replace(&mut self.entries[key], Entry::Vacant(self.next));\n\n        match prev {\n            Entry::Occupied(val) => {\n                self.len -= 1;\n                self.next = key;\n                val\n            }\n            _ => {\n                // Woops, the entry is actually vacant, restore the state\n                self.entries[key] = prev;\n                panic!(\"invalid key\");\n            }\n        }\n    }\n\n    /// Return `true` if a value is associated with the given key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    ///\n    /// let hello = slab.insert(\"hello\");\n    /// assert!(slab.contains(hello));\n    ///\n    /// slab.remove(hello);\n    ///\n    /// assert!(!slab.contains(hello));\n    /// ```\n    pub fn contains(&self, key: usize) -> bool {\n        self.entries\n            .get(key)\n            .map(|e| match *e {\n                Entry::Occupied(_) => true,\n                _ => false,\n            })\n            .unwrap_or(false)\n    }\n\n    /// Retain only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(usize, &mut e)`\n    /// returns false. This method operates in place and preserves the key\n    /// associated with the retained values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    ///\n    /// let k1 = slab.insert(0);\n    /// let k2 = slab.insert(1);\n    /// let k3 = slab.insert(2);\n    ///\n    /// slab.retain(|key, val| key == k1 || *val == 1);\n    ///\n    /// assert!(slab.contains(k1));\n    /// assert!(slab.contains(k2));\n    /// assert!(!slab.contains(k3));\n    ///\n    /// assert_eq!(2, slab.len());\n    /// ```\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(usize, &mut T) -> bool,\n    {\n        for i in 0..self.entries.len() {\n            let keep = match self.entries[i] {\n                Entry::Occupied(ref mut v) => f(i, v),\n                _ => true,\n            };\n\n            if !keep {\n                self.remove(i);\n            }\n        }\n    }\n\n    /// Return a draining iterator that removes all elements from the slab and\n    /// yields the removed items.\n    ///\n    /// Note: Elements are removed even if the iterator is only partially\n    /// consumed or not consumed at all.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    ///\n    /// let _ = slab.insert(0);\n    /// let _ = slab.insert(1);\n    /// let _ = slab.insert(2);\n    ///\n    /// {\n    ///     let mut drain = slab.drain();\n    ///\n    ///     assert_eq!(Some(0), drain.next());\n    ///     assert_eq!(Some(1), drain.next());\n    ///     assert_eq!(Some(2), drain.next());\n    ///     assert_eq!(None, drain.next());\n    /// }\n    ///\n    /// assert!(slab.is_empty());\n    /// ```\n    pub fn drain(&mut self) -> Drain<T> {\n        self.len = 0;\n        self.next = 0;\n        Drain(self.entries.drain(..))\n    }\n}","impl<T> fmt::Debug for Slab<T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            fmt,\n            \"Slab {{ len: {}, cap: {} }}\",\n            self.len,\n            self.capacity()\n        )\n    }\n}","impl<T> ops::Index<usize> for Slab<T> {\n    type Output = T;\n\n    fn index(&self, key: usize) -> &T {\n        match self.entries[key] {\n            Entry::Occupied(ref v) => v,\n            _ => panic!(\"invalid key\"),\n        }\n    }\n}","impl<T> ops::IndexMut<usize> for Slab<T> {\n    fn index_mut(&mut self, key: usize) -> &mut T {\n        match self.entries[key] {\n            Entry::Occupied(ref mut v) => v,\n            _ => panic!(\"invalid key\"),\n        }\n    }\n}"],"VacantEntry":["Debug","impl<'a, T> VacantEntry<'a, T> {\n    /// Insert a value in the entry, returning a mutable reference to the value.\n    ///\n    /// To get the key associated with the value, use `key` prior to calling\n    /// `insert`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    ///\n    /// let hello = {\n    ///     let entry = slab.vacant_entry();\n    ///     let key = entry.key();\n    ///\n    ///     entry.insert((key, \"hello\"));\n    ///     key\n    /// };\n    ///\n    /// assert_eq!(hello, slab[hello].0);\n    /// assert_eq!(\"hello\", slab[hello].1);\n    /// ```\n    pub fn insert(self, val: T) -> &'a mut T {\n        self.slab.insert_at(self.key, val);\n\n        match self.slab.entries[self.key] {\n            Entry::Occupied(ref mut v) => v,\n            _ => unreachable!(),\n        }\n    }\n\n    /// Return the key associated with this entry.\n    ///\n    /// A value stored in this entry will be associated with this key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use slab::*;\n    /// let mut slab = Slab::new();\n    ///\n    /// let hello = {\n    ///     let entry = slab.vacant_entry();\n    ///     let key = entry.key();\n    ///\n    ///     entry.insert((key, \"hello\"));\n    ///     key\n    /// };\n    ///\n    /// assert_eq!(hello, slab[hello].0);\n    /// assert_eq!(\"hello\", slab[hello].1);\n    /// ```\n    pub fn key(&self) -> usize {\n        self.key\n    }\n}"]},"single_path_import":{},"srcs":{"<&'a Slab<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Iter<'a, T>{\n        self.iter()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a mut Slab<T> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> IterMut<'a, T>{\n        self.iter_mut()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        fmt.debug_struct(\"Drain\").finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Drain<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<T>{\n        while let Some(entry) = self.0.next() {\n            if let Entry::Occupied(v) = entry {\n                return Some(v);\n            }\n        }\n\n        None\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Iter<'a, T> as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        fmt.debug_struct(\"Iter\")\n            .field(\"curr\", &self.curr)\n            .field(\"remaining\", &self.entries.len())\n            .finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Iter<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<(usize, &'a T)>{\n        while let Some(entry) = self.entries.next() {\n            let curr = self.curr;\n            self.curr += 1;\n\n            if let Entry::Occupied(ref v) = *entry {\n                return Some((curr, v));\n            }\n        }\n\n        None\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IterMut<'a, T> as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        fmt.debug_struct(\"IterMut\")\n            .field(\"curr\", &self.curr)\n            .field(\"remaining\", &self.entries.len())\n            .finish()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<IterMut<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<(usize, &'a mut T)>{\n        while let Some(entry) = self.entries.next() {\n            let curr = self.curr;\n            self.curr += 1;\n\n            if let Entry::Occupied(ref mut v) = *entry {\n                return Some((curr, v));\n            }\n        }\n\n        None\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Slab<T> as std::default::Default>::default":["fn default() -> Self{\n        Slab::new()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Slab<T> as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        write!(\n            fmt,\n            \"Slab {{ len: {}, cap: {} }}\",\n            self.len,\n            self.capacity()\n        )\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Slab<T> as std::ops::Index<usize>>::index":["fn index(&self, key: usize) -> &T{\n        match self.entries[key] {\n            Entry::Occupied(ref v) => v,\n            _ => panic!(\"invalid key\"),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Slab<T> as std::ops::IndexMut<usize>>::index_mut":["fn index_mut(&mut self, key: usize) -> &mut T{\n        match self.entries[key] {\n            Entry::Occupied(ref mut v) => v,\n            _ => panic!(\"invalid key\"),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Drain":["/// A draining iterator for `Slab`\npub struct Drain<'a, T: 'a>(vec::Drain<'a, Entry<T>>);","Real(LocalPath(\"src/lib.rs\"))"],"Entry":["enum Entry<T> {\n    Vacant(usize),\n    Occupied(T),\n}","Real(LocalPath(\"src/lib.rs\"))"],"Iter":["/// An iterator over the values stored in the `Slab`\npub struct Iter<'a, T: 'a> {\n    entries: std::slice::Iter<'a, Entry<T>>,\n    curr: usize,\n}","Real(LocalPath(\"src/lib.rs\"))"],"IterMut":["/// A mutable iterator over the values stored in the `Slab`\npub struct IterMut<'a, T: 'a> {\n    entries: std::slice::IterMut<'a, Entry<T>>,\n    curr: usize,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Slab":["/// Pre-allocated storage for a uniform data type\n///\n/// See the [module documentation] for more details.\n///\n/// [module documentation]: index.html\npub struct Slab<T> {\n    // Chunk of memory\n    entries: Vec<Entry<T>>,\n\n    // Number of Filled elements currently in the slab\n    len: usize,\n\n    // Offset of the next available slot in the slab. Set to the slab's\n    // capacity when the slab is full.\n    next: usize,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::capacity":["/// Return the number of values the slab can store without reallocating.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let slab: Slab<i32> = Slab::with_capacity(10);\n/// assert_eq!(slab.capacity(), 10);\n/// ```\npub fn capacity(&self) -> usize{\n        self.entries.capacity()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::clear":["/// Clear the slab of all values.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// for i in 0..3 {\n///     slab.insert(i);\n/// }\n///\n/// slab.clear();\n/// assert!(slab.is_empty());\n/// ```\npub fn clear(&mut self){\n        self.entries.clear();\n        self.len = 0;\n        self.next = 0;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::contains":["/// Return `true` if a value is associated with the given key.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// let hello = slab.insert(\"hello\");\n/// assert!(slab.contains(hello));\n///\n/// slab.remove(hello);\n///\n/// assert!(!slab.contains(hello));\n/// ```\npub fn contains(&self, key: usize) -> bool{\n        self.entries\n            .get(key)\n            .map(|e| match *e {\n                Entry::Occupied(_) => true,\n                _ => false,\n            })\n            .unwrap_or(false)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::drain":["/// Return a draining iterator that removes all elements from the slab and\n/// yields the removed items.\n///\n/// Note: Elements are removed even if the iterator is only partially\n/// consumed or not consumed at all.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// let _ = slab.insert(0);\n/// let _ = slab.insert(1);\n/// let _ = slab.insert(2);\n///\n/// {\n///     let mut drain = slab.drain();\n///\n///     assert_eq!(Some(0), drain.next());\n///     assert_eq!(Some(1), drain.next());\n///     assert_eq!(Some(2), drain.next());\n///     assert_eq!(None, drain.next());\n/// }\n///\n/// assert!(slab.is_empty());\n/// ```\npub fn drain(&mut self) -> Drain<T>{\n        self.len = 0;\n        self.next = 0;\n        Drain(self.entries.drain(..))\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::get":["/// Return a reference to the value associated with the given key.\n///\n/// If the given key is not associated with a value, then `None` is\n/// returned.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n/// let key = slab.insert(\"hello\");\n///\n/// assert_eq!(slab.get(key), Some(&\"hello\"));\n/// assert_eq!(slab.get(123), None);\n/// ```\npub fn get(&self, key: usize) -> Option<&T>{\n        match self.entries.get(key) {\n            Some(&Entry::Occupied(ref val)) => Some(val),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::get_mut":["/// Return a mutable reference to the value associated with the given key.\n///\n/// If the given key is not associated with a value, then `None` is\n/// returned.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n/// let key = slab.insert(\"hello\");\n///\n/// *slab.get_mut(key).unwrap() = \"world\";\n///\n/// assert_eq!(slab[key], \"world\");\n/// assert_eq!(slab.get_mut(123), None);\n/// ```\npub fn get_mut(&mut self, key: usize) -> Option<&mut T>{\n        match self.entries.get_mut(key) {\n            Some(&mut Entry::Occupied(ref mut val)) => Some(val),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::get_unchecked":["/// Return a reference to the value associated with the given key without\n/// performing bounds checking.\n///\n/// This function should be used with care.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n/// let key = slab.insert(2);\n///\n/// unsafe {\n///     assert_eq!(slab.get_unchecked(key), &2);\n/// }\n/// ```\npub unsafe fn get_unchecked(&self, key: usize) -> &T{\n        match *self.entries.get_unchecked(key) {\n            Entry::Occupied(ref val) => val,\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::get_unchecked_mut":["/// Return a mutable reference to the value associated with the given key\n/// without performing bounds checking.\n///\n/// This function should be used with care.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n/// let key = slab.insert(2);\n///\n/// unsafe {\n///     let val = slab.get_unchecked_mut(key);\n///     *val = 13;\n/// }\n///\n/// assert_eq!(slab[key], 13);\n/// ```\npub unsafe fn get_unchecked_mut(&mut self, key: usize) -> &mut T{\n        match *self.entries.get_unchecked_mut(key) {\n            Entry::Occupied(ref mut val) => val,\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::insert":["/// Insert a value in the slab, returning key assigned to the value.\n///\n/// The returned key can later be used to retrieve or remove the value using indexed\n/// lookup and `remove`. Additional capacity is allocated if needed. See\n/// [Capacity and reallocation](index.html#capacity-and-reallocation).\n///\n/// # Panics\n///\n/// Panics if the number of elements in the vector overflows a `usize`.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n/// let key = slab.insert(\"hello\");\n/// assert_eq!(slab[key], \"hello\");\n/// ```\npub fn insert(&mut self, val: T) -> usize{\n        let key = self.next;\n\n        self.insert_at(key, val);\n\n        key\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::insert_at":["fn insert_at(&mut self, key: usize, val: T){\n        self.len += 1;\n\n        if key == self.entries.len() {\n            self.entries.push(Entry::Occupied(val));\n            self.next = key + 1;\n        } else {\n            let prev = mem::replace(&mut self.entries[key], Entry::Occupied(val));\n\n            match prev {\n                Entry::Vacant(next) => {\n                    self.next = next;\n                }\n                _ => unreachable!(),\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::is_empty":["/// Return `true` if there are no values stored in the slab.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n/// assert!(slab.is_empty());\n///\n/// slab.insert(1);\n/// assert!(!slab.is_empty());\n/// ```\npub fn is_empty(&self) -> bool{\n        self.len == 0\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::iter":["/// Return an iterator over the slab.\n///\n/// This function should generally be **avoided** as it is not efficient.\n/// Iterators must iterate over every slot in the slab even if it is\n/// vacant. As such, a slab with a capacity of 1 million but only one\n/// stored value must still iterate the million slots.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// for i in 0..3 {\n///     slab.insert(i);\n/// }\n///\n/// let mut iterator = slab.iter();\n///\n/// assert_eq!(iterator.next(), Some((0, &0)));\n/// assert_eq!(iterator.next(), Some((1, &1)));\n/// assert_eq!(iterator.next(), Some((2, &2)));\n/// assert_eq!(iterator.next(), None);\n/// ```\npub fn iter(&self) -> Iter<T>{\n        Iter {\n            entries: self.entries.iter(),\n            curr: 0,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::iter_mut":["/// Return an iterator that allows modifying each value.\n///\n/// This function should generally be **avoided** as it is not efficient.\n/// Iterators must iterate over every slot in the slab even if it is\n/// vacant. As such, a slab with a capacity of 1 million but only one\n/// stored value must still iterate the million slots.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// let key1 = slab.insert(0);\n/// let key2 = slab.insert(1);\n///\n/// for (key, val) in slab.iter_mut() {\n///     if key == key1 {\n///         *val += 2;\n///     }\n/// }\n///\n/// assert_eq!(slab[key1], 2);\n/// assert_eq!(slab[key2], 1);\n/// ```\npub fn iter_mut(&mut self) -> IterMut<T>{\n        IterMut {\n            entries: self.entries.iter_mut(),\n            curr: 0,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::len":["/// Return the number of stored values.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// for i in 0..3 {\n///     slab.insert(i);\n/// }\n///\n/// assert_eq!(3, slab.len());\n/// ```\npub fn len(&self) -> usize{\n        self.len\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::new":["/// Construct a new, empty `Slab`.\n///\n/// The function does not allocate and the returned slab will have no\n/// capacity until `insert` is called or capacity is explicitly reserved.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let slab: Slab<i32> = Slab::new();\n/// ```\npub fn new() -> Slab<T>{\n        Slab::with_capacity(0)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::remove":["/// Remove and return the value associated with the given key.\n///\n/// The key is then released and may be associated with future stored\n/// values.\n///\n/// # Panics\n///\n/// Panics if `key` is not associated with a value.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// let hello = slab.insert(\"hello\");\n///\n/// assert_eq!(slab.remove(hello), \"hello\");\n/// assert!(!slab.contains(hello));\n/// ```\npub fn remove(&mut self, key: usize) -> T{\n        // Swap the entry at the provided value\n        let prev = mem::replace(&mut self.entries[key], Entry::Vacant(self.next));\n\n        match prev {\n            Entry::Occupied(val) => {\n                self.len -= 1;\n                self.next = key;\n                val\n            }\n            _ => {\n                // Woops, the entry is actually vacant, restore the state\n                self.entries[key] = prev;\n                panic!(\"invalid key\");\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::reserve":["/// Reserve capacity for at least `additional` more values to be stored\n/// without allocating.\n///\n/// `reserve` does nothing if the slab already has sufficient capacity for\n/// `additional` more values. If more capacity is required, a new segment of\n/// memory will be allocated and all existing values will be copied into it.\n/// As such, if the slab is already very large, a call to `reserve` can end\n/// up being expensive.\n///\n/// The slab may reserve more than `additional` extra space in order to\n/// avoid frequent reallocations. Use `reserve_exact` instead to guarantee\n/// that only the requested space is allocated.\n///\n/// # Panics\n///\n/// Panics if the new capacity overflows `usize`.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n/// slab.insert(\"hello\");\n/// slab.reserve(10);\n/// assert!(slab.capacity() >= 11);\n/// ```\npub fn reserve(&mut self, additional: usize){\n        if self.capacity() - self.len >= additional {\n            return;\n        }\n        let need_add = self.len + additional - self.entries.len();\n        self.entries.reserve(need_add);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::reserve_exact":["/// Reserve the minimum capacity required to store exactly `additional`\n/// more values.\n///\n/// `reserve_exact` does nothing if the slab already has sufficient capacity\n/// for `additional` more valus. If more capacity is required, a new segment\n/// of memory will be allocated and all existing values will be copied into\n/// it.  As such, if the slab is already very large, a call to `reserve` can\n/// end up being expensive.\n///\n/// Note that the allocator may give the slab more space than it requests.\n/// Therefore capacity can not be relied upon to be precisely minimal.\n/// Prefer `reserve` if future insertions are expected.\n///\n/// # Panics\n///\n/// Panics if the new capacity overflows `usize`.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n/// slab.insert(\"hello\");\n/// slab.reserve_exact(10);\n/// assert!(slab.capacity() >= 11);\n/// ```\npub fn reserve_exact(&mut self, additional: usize){\n        if self.capacity() - self.len >= additional {\n            return;\n        }\n        let need_add = self.len + additional - self.entries.len();\n        self.entries.reserve_exact(need_add);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::retain":["/// Retain only the elements specified by the predicate.\n///\n/// In other words, remove all elements `e` such that `f(usize, &mut e)`\n/// returns false. This method operates in place and preserves the key\n/// associated with the retained values.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// let k1 = slab.insert(0);\n/// let k2 = slab.insert(1);\n/// let k3 = slab.insert(2);\n///\n/// slab.retain(|key, val| key == k1 || *val == 1);\n///\n/// assert!(slab.contains(k1));\n/// assert!(slab.contains(k2));\n/// assert!(!slab.contains(k3));\n///\n/// assert_eq!(2, slab.len());\n/// ```\npub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(usize, &mut T) -> bool,{\n        for i in 0..self.entries.len() {\n            let keep = match self.entries[i] {\n                Entry::Occupied(ref mut v) => f(i, v),\n                _ => true,\n            };\n\n            if !keep {\n                self.remove(i);\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::shrink_to_fit":["/// Shrink the capacity of the slab as much as possible.\n///\n/// It will drop down as close as possible to the length but the allocator\n/// may still inform the vector that there is space for a few more elements.\n/// Also, since values are not moved, the slab cannot shrink past any stored\n/// values.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::with_capacity(10);\n///\n/// for i in 0..3 {\n///     slab.insert(i);\n/// }\n///\n/// assert_eq!(slab.capacity(), 10);\n/// slab.shrink_to_fit();\n/// assert!(slab.capacity() >= 3);\n/// ```\n///\n/// In this case, even though two values are removed, the slab cannot shrink\n/// past the last value.\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::with_capacity(10);\n///\n/// for i in 0..3 {\n///     slab.insert(i);\n/// }\n///\n/// slab.remove(0);\n/// slab.remove(1);\n///\n/// assert_eq!(slab.capacity(), 10);\n/// slab.shrink_to_fit();\n/// assert!(slab.capacity() >= 3);\n/// ```\npub fn shrink_to_fit(&mut self){\n        self.entries.shrink_to_fit();\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::vacant_entry":["/// Return a handle to a vacant entry allowing for further manipulation.\n///\n/// This function is useful when creating values that must contain their\n/// slab key. The returned `VacantEntry` reserves a slot in the slab and is\n/// able to query the associated key.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// let hello = {\n///     let entry = slab.vacant_entry();\n///     let key = entry.key();\n///\n///     entry.insert((key, \"hello\"));\n///     key\n/// };\n///\n/// assert_eq!(hello, slab[hello].0);\n/// assert_eq!(\"hello\", slab[hello].1);\n/// ```\npub fn vacant_entry(&mut self) -> VacantEntry<T>{\n        VacantEntry {\n            key: self.next,\n            slab: self,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Slab::<T>::with_capacity":["/// Construct a new, empty `Slab` with the specified capacity.\n///\n/// The returned slab will be able to store exactly `capacity` without\n/// reallocating. If `capacity` is 0, the slab will not allocate.\n///\n/// It is important to note that this function does not specify the *length*\n/// of the returned slab, but only the capacity. For an explanation of the\n/// difference between length and capacity, see [Capacity and\n/// reallocation](index.html#capacity-and-reallocation).\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::with_capacity(10);\n///\n/// // The slab contains no values, even though it has capacity for more\n/// assert_eq!(slab.len(), 0);\n///\n/// // These are all done without reallocating...\n/// for i in 0..10 {\n///     slab.insert(i);\n/// }\n///\n/// // ...but this may make the slab reallocate\n/// slab.insert(11);\n/// ```\npub fn with_capacity(capacity: usize) -> Slab<T>{\n        Slab {\n            entries: Vec::with_capacity(capacity),\n            next: 0,\n            len: 0,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"VacantEntry":["/// A handle to a vacant entry in a `Slab`.\n///\n/// `VacantEntry` allows constructing values with the key that they will be\n/// assigned to.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// let hello = {\n///     let entry = slab.vacant_entry();\n///     let key = entry.key();\n///\n///     entry.insert((key, \"hello\"));\n///     key\n/// };\n///\n/// assert_eq!(hello, slab[hello].0);\n/// assert_eq!(\"hello\", slab[hello].1);\n/// ```\npub struct VacantEntry<'a, T: 'a> {\n    slab: &'a mut Slab<T>,\n    key: usize,\n}","Real(LocalPath(\"src/lib.rs\"))"],"VacantEntry::<'a, T>::insert":["/// Insert a value in the entry, returning a mutable reference to the value.\n///\n/// To get the key associated with the value, use `key` prior to calling\n/// `insert`.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// let hello = {\n///     let entry = slab.vacant_entry();\n///     let key = entry.key();\n///\n///     entry.insert((key, \"hello\"));\n///     key\n/// };\n///\n/// assert_eq!(hello, slab[hello].0);\n/// assert_eq!(\"hello\", slab[hello].1);\n/// ```\npub fn insert(self, val: T) -> &'a mut T{\n        self.slab.insert_at(self.key, val);\n\n        match self.slab.entries[self.key] {\n            Entry::Occupied(ref mut v) => v,\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"VacantEntry::<'a, T>::key":["/// Return the key associated with this entry.\n///\n/// A value stored in this entry will be associated with this key.\n///\n/// # Examples\n///\n/// ```\n/// # use slab::*;\n/// let mut slab = Slab::new();\n///\n/// let hello = {\n///     let entry = slab.vacant_entry();\n///     let key = entry.key();\n///\n///     entry.insert((key, \"hello\"));\n///     key\n/// };\n///\n/// assert_eq!(hello, slab[hello].0);\n/// assert_eq!(\"hello\", slab[hello].1);\n/// ```\npub fn key(&self) -> usize{\n        self.key\n    }","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"(usize, &'a T)":["next"],"(usize, &'a mut T)":["next"],"Drain":["drain"],"Entry":["clone"],"Iter":["into_iter","iter"],"IterMut":["into_iter","iter_mut"],"Slab":["clone","default","new","with_capacity"],"VacantEntry":["vacant_entry"],"bool":["contains","is_empty"],"usize":["capacity","insert","key","len"]},"struct_to_trait":{"Drain":["std::fmt::Debug","std::iter::Iterator"],"Entry":["std::clone::Clone"],"Iter":["std::fmt::Debug","std::iter::Iterator"],"IterMut":["std::fmt::Debug","std::iter::Iterator"],"Slab":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::ops::Index","std::ops::IndexMut"],"VacantEntry":["std::fmt::Debug"]},"targets":{"<&'a Slab<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<&'a mut Slab<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<Drain<'a, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<Drain<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Iter<'a, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<Iter<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<IterMut<'a, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<IterMut<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/lib.rs\"))","std::iter::Iterator"],"<Slab<T> as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<Slab<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<Slab<T> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/lib.rs\"))","std::ops::Index"],"<Slab<T> as std::ops::IndexMut<usize>>::index_mut":["index_mut","Real(LocalPath(\"src/lib.rs\"))","std::ops::IndexMut"],"Slab::<T>::capacity":["capacity","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::clear":["clear","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::contains":["contains","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::drain":["drain","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::get":["get","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::get_mut":["get_mut","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::get_unchecked":["get_unchecked","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::get_unchecked_mut":["get_unchecked_mut","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::insert":["insert","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::insert_at":["insert_at","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::is_empty":["is_empty","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::iter":["iter","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::iter_mut":["iter_mut","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::len":["len","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::remove":["remove","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::reserve":["reserve","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::reserve_exact":["reserve_exact","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::retain":["retain","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::shrink_to_fit":["shrink_to_fit","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::vacant_entry":["vacant_entry","Real(LocalPath(\"src/lib.rs\"))",""],"Slab::<T>::with_capacity":["with_capacity","Real(LocalPath(\"src/lib.rs\"))",""],"VacantEntry::<'a, T>::insert":["insert","Real(LocalPath(\"src/lib.rs\"))",""],"VacantEntry::<'a, T>::key":["key","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["Entry","Slab"],"std::default::Default":["Slab"],"std::fmt::Debug":["Drain","Iter","IterMut","Slab","VacantEntry"],"std::iter::Iterator":["Drain","Iter","IterMut"],"std::ops::Index":["Slab"],"std::ops::IndexMut":["Slab"]},"type_to_def_path":{"Drain<'a, T>":"Drain","Entry<T>":"Entry","Iter<'a, T>":"Iter","IterMut<'a, T>":"IterMut","Slab<T>":"Slab","VacantEntry<'a, T>":"VacantEntry"}}