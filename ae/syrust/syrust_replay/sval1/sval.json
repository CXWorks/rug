{"dependencies":{"<&'a T as value::Value>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<&'a mut S as collect::Collect>::map_key_collect":["collect::value::Value","core::marker::Sized","core::result::Result"],"<&'a mut S as collect::Collect>::map_value_collect":["collect::value::Value","core::marker::Sized","core::result::Result"],"<&'a mut S as collect::Collect>::seq_elem_collect":["collect::value::Value","core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::bool":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::char":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::f64":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::fmt":["core::fmt::Arguments","core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::i128":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::i64":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::map_begin":["core::marker::Sized","core::option::Option","core::result::Result"],"<&'a mut T as stream::Stream>::map_end":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::map_key":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::map_value":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::none":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::seq_begin":["core::marker::Sized","core::option::Option","core::result::Result"],"<&'a mut T as stream::Stream>::seq_elem":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::seq_end":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::str":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::u128":["core::marker::Sized","core::result::Result"],"<&'a mut T as stream::Stream>::u64":["core::marker::Sized","core::result::Result"],"<collect::Default<S> as collect::Collect>::map_key_collect":["collect::Default","collect::value::Value","core::marker::Sized","core::result::Result"],"<collect::Default<S> as collect::Collect>::map_value_collect":["collect::Default","collect::value::Value","core::marker::Sized","core::result::Result"],"<collect::Default<S> as collect::Collect>::seq_elem_collect":["collect::Default","collect::value::Value","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::bool":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::char":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::f64":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::fmt":["collect::Default","core::fmt::Arguments","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::i128":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::i64":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::map_begin":["collect::Default","core::marker::Sized","core::option::Option","core::result::Result"],"<collect::Default<S> as stream::Stream>::map_end":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::map_key":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::map_value":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::none":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::seq_begin":["collect::Default","core::marker::Sized","core::option::Option","core::result::Result"],"<collect::Default<S> as stream::Stream>::seq_elem":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::seq_end":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::str":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::u128":["collect::Default","core::marker::Sized","core::result::Result"],"<collect::Default<S> as stream::Stream>::u64":["collect::Default","core::marker::Sized","core::result::Result"],"<error::Error as core::clone::Clone>::clone":["error::Error","error::ErrorInner"],"<error::Error as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","error::Error","error::ErrorInner"],"<error::Error as core::fmt::Display>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","error::Error","error::ErrorInner"],"<error::ErrorInner as core::clone::Clone>::clone":["error::ErrorInner"],"<error::ErrorInner as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","error::ErrorInner"],"<error::ErrorInner as core::fmt::Display>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","error::ErrorInner"],"<stream::owned::OwnedStream<S> as stream::Stream>::bool":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::char":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::f64":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::fmt":["collect::owned::OwnedCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::i128":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::i64":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::option::Option","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_end":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_key":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_value":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::none":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::seq_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::option::Option","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::seq_elem":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::seq_end":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::str":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::u128":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::OwnedStream<S> as stream::Stream>::u64":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::bool":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::char":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::f64":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::fmt":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::i128":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::i64":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::option::Option","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_end":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_key":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_value":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::none":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::seq_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::option::Option","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::seq_elem":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::seq_end":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::str":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::u128":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::u64":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"<stream::stack::Depth as core::clone::Clone>::clone":["stream::stack::Depth"],"<stream::stack::Depth as core::cmp::Eq>::assert_receiver_is_total_eq":["stream::stack::Depth"],"<stream::stack::Depth as core::cmp::Ord>::cmp":["core::cmp::Ordering","stream::stack::Depth"],"<stream::stack::Depth as core::cmp::PartialEq>::eq":["stream::stack::Depth"],"<stream::stack::Depth as core::cmp::PartialOrd>::partial_cmp":["core::marker::Sized","core::option::Option","stream::stack::Depth"],"<stream::stack::Expecting as core::fmt::Display>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","stream::stack::Expecting"],"<stream::stack::Pos as core::clone::Clone>::clone":["stream::stack::Pos"],"<stream::stack::Slot as core::clone::Clone>::clone":["stream::stack::Slot"],"<stream::stack::Stack as core::clone::Clone>::clone":["stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as core::default::Default>::default":["stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::bool":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::char":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::f64":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::fmt":["core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::i128":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::i64":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::map_begin":["core::marker::Sized","core::option::Option","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::map_end":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::map_key":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::map_value":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::none":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::seq_begin":["core::marker::Sized","core::option::Option","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::seq_elem":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::seq_end":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::str":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::u128":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::Stack as stream::Stream>::u64":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"<stream::stack::inner::Stack as core::clone::Clone>::clone":["stream::stack::Slot","stream::stack::inner::Stack"],"collect::Collect::map_key_collect":["collect::value::Value","core::marker::Sized","core::result::Result"],"collect::Collect::map_value_collect":["collect::value::Value","core::marker::Sized","core::result::Result"],"collect::Collect::seq_elem_collect":["collect::value::Value","core::marker::Sized","core::result::Result"],"collect::Default":["collect::Default","core::marker::Sized"],"collect::owned::OwnedCollect":["collect::owned::OwnedCollect","core::marker::Sized"],"collect::owned::OwnedCollect::<TStream>::any":["collect::owned::OwnedCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","value::Value"],"collect::owned::OwnedCollect::<TStream>::bool":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::borrow_mut":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized"],"collect::owned::OwnedCollect::<TStream>::char":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::f64":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::fmt":["collect::owned::OwnedCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::i128":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::i64":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::into_inner":["collect::owned::OwnedCollect","core::marker::Sized"],"collect::owned::OwnedCollect::<TStream>::map_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::option::Option","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::map_end":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::map_key":["collect::owned::OwnedCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","value::Value"],"collect::owned::OwnedCollect::<TStream>::map_key_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::map_value":["collect::owned::OwnedCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","value::Value"],"collect::owned::OwnedCollect::<TStream>::map_value_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::new":["collect::owned::OwnedCollect","core::marker::Sized"],"collect::owned::OwnedCollect::<TStream>::none":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::seq_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::option::Option","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::seq_elem":["collect::owned::OwnedCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","value::Value"],"collect::owned::OwnedCollect::<TStream>::seq_elem_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::seq_end":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::str":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::u128":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::OwnedCollect::<TStream>::u64":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized"],"collect::owned::RefMutCollect::<'a>::any":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","value::Value"],"collect::owned::RefMutCollect::<'a>::bool":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::char":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::f64":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::fmt":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::i128":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::i64":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::map_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::option::Option","core::result::Result"],"collect::owned::RefMutCollect::<'a>::map_end":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::map_key":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","value::Value"],"collect::owned::RefMutCollect::<'a>::map_key_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::map_value":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","value::Value"],"collect::owned::RefMutCollect::<'a>::map_value_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::none":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::seq_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::option::Option","core::result::Result"],"collect::owned::RefMutCollect::<'a>::seq_elem":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","value::Value"],"collect::owned::RefMutCollect::<'a>::seq_elem_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::seq_end":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::str":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::u128":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::owned::RefMutCollect::<'a>::u64":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result"],"collect::value::Value":["collect::value::Value"],"collect::value::Value::<'a>::new":["collect::value::Value","core::fmt::Arguments","core::marker::Sized","value::Value"],"collect::value::Value::<'a>::stream":["collect::Collect","collect::Default","collect::value::Value","core::marker::Sized","core::result::Result"],"error::<impl core::convert::From<error::Error> for core::fmt::Error>::from":["core::fmt::Error","error::Error","error::ErrorInner"],"error::Error":["error::Error","error::ErrorInner"],"error::Error::default_unsupported":["error::Error","error::ErrorInner"],"error::Error::is_default_unsupported":["error::Error","error::ErrorInner"],"error::Error::is_unsupported":["error::Error","error::ErrorInner"],"error::Error::msg":["error::Error","error::ErrorInner"],"error::Error::unsupported":["error::Error","error::ErrorInner"],"error::ErrorInner":["error::ErrorInner"],"error::no_alloc_support::<impl error::Error>::custom":["error::Error","error::ErrorInner"],"error::no_std_support::<impl core::convert::From<core::fmt::Error> for error::Error>::from":["core::fmt::Error","error::Error","error::ErrorInner"],"stream":["collect::Default","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::Stream","value::Value"],"stream::Stream::bool":["core::marker::Sized","core::result::Result"],"stream::Stream::char":["core::marker::Sized","core::result::Result"],"stream::Stream::f64":["core::marker::Sized","core::result::Result"],"stream::Stream::fmt":["core::fmt::Arguments","core::marker::Sized","core::result::Result"],"stream::Stream::i128":["core::marker::Sized","core::result::Result"],"stream::Stream::i64":["core::marker::Sized","core::result::Result"],"stream::Stream::map_begin":["core::marker::Sized","core::option::Option","core::result::Result"],"stream::Stream::map_end":["core::marker::Sized","core::result::Result"],"stream::Stream::map_key":["core::marker::Sized","core::result::Result"],"stream::Stream::map_value":["core::marker::Sized","core::result::Result"],"stream::Stream::none":["core::marker::Sized","core::result::Result"],"stream::Stream::seq_begin":["core::marker::Sized","core::option::Option","core::result::Result"],"stream::Stream::seq_elem":["core::marker::Sized","core::result::Result"],"stream::Stream::seq_end":["core::marker::Sized","core::result::Result"],"stream::Stream::str":["core::marker::Sized","core::result::Result"],"stream::Stream::u128":["core::marker::Sized","core::result::Result"],"stream::Stream::u64":["core::marker::Sized","core::result::Result"],"stream::owned::OwnedStream":["collect::owned::OwnedCollect","core::marker::Sized","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::any":["collect::owned::OwnedCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::OwnedStream","value::Value"],"stream::owned::OwnedStream::<S>::bool":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::borrow_mut":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","stream::owned::OwnedStream","stream::owned::RefMutStream"],"stream::owned::OwnedStream::<S>::char":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::f64":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::fmt":["collect::owned::OwnedCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::i128":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::i64":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::into_inner":["collect::owned::OwnedCollect","core::marker::Sized","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::map_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::option::Option","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::map_end":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::map_key":["collect::owned::OwnedCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::OwnedStream","value::Value"],"stream::owned::OwnedStream::<S>::map_key_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::map_value":["collect::owned::OwnedCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::OwnedStream","value::Value"],"stream::owned::OwnedStream::<S>::map_value_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::new":["collect::owned::OwnedCollect","core::marker::Sized","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::none":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::seq_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::option::Option","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::seq_elem":["collect::owned::OwnedCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::OwnedStream","value::Value"],"stream::owned::OwnedStream::<S>::seq_elem_begin":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::seq_end":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::str":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::stream":["core::fmt::Arguments","core::marker::Sized","core::result::Result","value::Value"],"stream::owned::OwnedStream::<S>::u128":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::OwnedStream::<S>::u64":["collect::owned::OwnedCollect","core::marker::Sized","core::result::Result","stream::owned::OwnedStream"],"stream::owned::RefMutStream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::any":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::RefMutStream","value::Value"],"stream::owned::RefMutStream::<'a>::bool":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::char":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::f64":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::fmt":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::i128":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::i64":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::map_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::option::Option","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::map_end":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::map_key":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::RefMutStream","value::Value"],"stream::owned::RefMutStream::<'a>::map_key_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::map_value":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::RefMutStream","value::Value"],"stream::owned::RefMutStream::<'a>::map_value_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::new":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::none":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::seq_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::option::Option","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::seq_elem":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::RefMutStream","value::Value"],"stream::owned::RefMutStream::<'a>::seq_elem_begin":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::seq_end":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::str":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::u128":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::owned::RefMutStream::<'a>::u64":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"stream::stack::Depth":["stream::stack::Depth"],"stream::stack::Expecting":["stream::stack::Expecting"],"stream::stack::Pos":["stream::stack::Pos"],"stream::stack::Pos::depth":["stream::stack::Depth","stream::stack::Pos"],"stream::stack::Pos::is_elem":["stream::stack::Pos"],"stream::stack::Pos::is_empty_map":["stream::stack::Pos"],"stream::stack::Pos::is_empty_seq":["stream::stack::Pos"],"stream::stack::Pos::is_key":["stream::stack::Pos"],"stream::stack::Pos::is_value":["stream::stack::Pos"],"stream::stack::Slot":["stream::stack::Slot"],"stream::stack::Slot::pos":["stream::stack::Pos","stream::stack::Slot"],"stream::stack::Slot::root":["stream::stack::Slot"],"stream::stack::Stack":["stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::can_end":["stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::clear":["stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::current":["stream::stack::Pos","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::end":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::map_begin":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::map_begin::expecting":["stream::stack::Slot"],"stream::stack::Stack::map_end":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::map_end::expecting":["stream::stack::Slot"],"stream::stack::Stack::map_key":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::map_key::expecting":["stream::stack::Slot"],"stream::stack::Stack::map_value":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::map_value::expecting":["stream::stack::Slot"],"stream::stack::Stack::new":["stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::primitive":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::primitive::expecting":["stream::stack::Slot"],"stream::stack::Stack::seq_begin":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::seq_begin::expecting":["stream::stack::Slot"],"stream::stack::Stack::seq_elem":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::seq_elem::expecting":["stream::stack::Slot"],"stream::stack::Stack::seq_end":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"stream::stack::Stack::seq_end::expecting":["stream::stack::Slot"],"stream::stack::inner::Stack":["stream::stack::Slot","stream::stack::inner::Stack"],"stream::stack::inner::Stack::clear":["stream::stack::Slot","stream::stack::inner::Stack"],"stream::stack::inner::Stack::current":["stream::stack::Slot","stream::stack::inner::Stack"],"stream::stack::inner::Stack::current_mut":["stream::stack::Slot","stream::stack::inner::Stack"],"stream::stack::inner::Stack::depth":["stream::stack::Slot","stream::stack::inner::Stack"],"stream::stack::inner::Stack::new":["stream::stack::Slot","stream::stack::inner::Stack"],"stream::stack::inner::Stack::pop_depth":["stream::stack::Slot","stream::stack::inner::Stack"],"stream::stack::inner::Stack::push_depth":["core::marker::Sized","core::result::Result","stream::stack::Slot","stream::stack::inner::Stack"],"value::Value::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for ()>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for (T, U)>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for [T]>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for bool>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for char>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for core::fmt::Arguments<'a>>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::fmt::Arguments","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for core::option::Option<T>>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::option::Option","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for f32>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for f64>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for i128>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for i16>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for i32>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for i64>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for i8>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for str>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for u128>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for u16>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for u32>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for u64>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"],"value::impls::<impl value::Value for u8>::stream":["collect::owned::OwnedCollect","collect::owned::RefMutCollect","core::marker::Sized","core::result::Result","stream::owned::RefMutStream"]},"glob_path_import":{},"self_to_fn":{"collect::Default":["impl<S> Collect for Default<S>\nwhere\n    S: Stream,\n{\n    #[inline]\n    fn map_key_collect(&mut self, k: Value) -> Result {\n        Stream::map_key(self)?;\n        k.stream(self)\n    }\n\n    #[inline]\n    fn map_value_collect(&mut self, v: Value) -> Result {\n        Stream::map_value(self)?;\n        v.stream(self)\n    }\n\n    #[inline]\n    fn seq_elem_collect(&mut self, v: Value) -> Result {\n        Stream::seq_elem(self)?;\n        v.stream(self)\n    }\n}","impl<S> Stream for Default<S>\nwhere\n    S: Stream,\n{\n    #[inline]\n    fn fmt(&mut self, args: stream::Arguments) -> Result {\n        self.0.fmt(args)\n    }\n\n    #[inline]\n    fn i64(&mut self, v: i64) -> Result {\n        self.0.i64(v)\n    }\n\n    #[inline]\n    fn u64(&mut self, v: u64) -> Result {\n        self.0.u64(v)\n    }\n\n    #[inline]\n    fn i128(&mut self, v: i128) -> Result {\n        self.0.i128(v)\n    }\n\n    #[inline]\n    fn u128(&mut self, v: u128) -> Result {\n        self.0.u128(v)\n    }\n\n    #[inline]\n    fn f64(&mut self, v: f64) -> Result {\n        self.0.f64(v)\n    }\n\n    #[inline]\n    fn bool(&mut self, v: bool) -> Result {\n        self.0.bool(v)\n    }\n\n    #[inline]\n    fn char(&mut self, v: char) -> Result {\n        self.0.char(v)\n    }\n\n    #[inline]\n    fn str(&mut self, v: &str) -> Result {\n        self.0.str(v)\n    }\n\n    #[inline]\n    fn none(&mut self) -> Result {\n        self.0.none()\n    }\n\n    #[inline]\n    fn map_begin(&mut self, len: Option<usize>) -> Result {\n        self.0.map_begin(len)\n    }\n\n    #[inline]\n    fn map_key(&mut self) -> Result {\n        self.0.map_key()\n    }\n\n    #[inline]\n    fn map_value(&mut self) -> Result {\n        self.0.map_value()\n    }\n\n    #[inline]\n    fn map_end(&mut self) -> Result {\n        self.0.map_end()\n    }\n\n    #[inline]\n    fn seq_begin(&mut self, len: Option<usize>) -> Result {\n        self.0.seq_begin(len)\n    }\n\n    #[inline]\n    fn seq_elem(&mut self) -> Result {\n        self.0.seq_elem()\n    }\n\n    #[inline]\n    fn seq_end(&mut self) -> Result {\n        self.0.seq_end()\n    }\n}"],"collect::owned::OwnedCollect":["impl<TStream> OwnedCollect<TStream>\nwhere\n    TStream: Collect,\n{\n    #[inline]\n    pub(crate) fn new(stream: TStream) -> Self {\n        OwnedCollect { stream }\n    }\n\n    #[inline]\n    pub(crate) fn into_inner(self) -> TStream {\n        self.stream\n    }\n\n    #[inline]\n    pub(crate) fn borrow_mut(&mut self) -> RefMutCollect {\n        RefMutCollect(OwnedCollect::new(&mut self.stream))\n    }\n\n    #[inline]\n    pub fn any(&mut self, v: impl value::Value) -> collect::Result {\n        v.stream(&mut value::Stream::new(self.borrow_mut()))\n    }\n\n    #[inline]\n    pub fn fmt(&mut self, f: Arguments) -> collect::Result {\n        self.stream.fmt(f)\n    }\n\n    #[inline]\n    pub fn i64(&mut self, v: i64) -> collect::Result {\n        self.stream.i64(v)\n    }\n\n    #[inline]\n    pub fn u64(&mut self, v: u64) -> collect::Result {\n        self.stream.u64(v)\n    }\n\n    #[inline]\n    pub fn i128(&mut self, v: i128) -> collect::Result {\n        self.stream.i128(v)\n    }\n\n    #[inline]\n    pub fn u128(&mut self, v: u128) -> collect::Result {\n        self.stream.u128(v)\n    }\n\n    #[inline]\n    pub fn f64(&mut self, v: f64) -> collect::Result {\n        self.stream.f64(v)\n    }\n\n    #[inline]\n    pub fn bool(&mut self, v: bool) -> collect::Result {\n        self.stream.bool(v)\n    }\n\n    #[inline]\n    pub fn char(&mut self, v: char) -> collect::Result {\n        self.stream.char(v)\n    }\n\n    #[inline]\n    pub fn str(&mut self, v: &str) -> collect::Result {\n        self.stream.str(v)\n    }\n\n    #[inline]\n    pub fn none(&mut self) -> collect::Result {\n        self.stream.none()\n    }\n\n    #[inline]\n    pub fn map_begin(&mut self, len: Option<usize>) -> collect::Result {\n        self.stream.map_begin(len)\n    }\n\n    #[inline]\n    pub fn map_key(&mut self, k: impl value::Value) -> collect::Result {\n        self.stream.map_key_collect(Value::new(&k))\n    }\n\n    #[inline]\n    pub fn map_value(&mut self, v: impl value::Value) -> collect::Result {\n        self.stream.map_value_collect(Value::new(&v))\n    }\n\n    #[inline]\n    pub fn map_end(&mut self) -> collect::Result {\n        self.stream.map_end()\n    }\n\n    #[inline]\n    pub fn seq_begin(&mut self, len: Option<usize>) -> collect::Result {\n        self.stream.seq_begin(len)\n    }\n\n    #[inline]\n    pub fn seq_elem(&mut self, v: impl value::Value) -> collect::Result {\n        self.stream.seq_elem_collect(Value::new(&v))\n    }\n\n    #[inline]\n    pub fn seq_end(&mut self) -> collect::Result {\n        self.stream.seq_end()\n    }\n\n    #[inline]\n    pub fn map_key_begin(&mut self) -> Result<&mut Self, Error> {\n        self.stream.map_key()?;\n\n        Ok(self)\n    }\n\n    #[inline]\n    pub fn map_value_begin(&mut self) -> Result<&mut Self, Error> {\n        self.stream.map_value()?;\n\n        Ok(self)\n    }\n\n    #[inline]\n    pub fn seq_elem_begin(&mut self) -> Result<&mut Self, Error> {\n        self.stream.seq_elem()?;\n\n        Ok(self)\n    }\n}"],"collect::owned::RefMutCollect":["impl<'a> RefMutCollect<'a> {\n    #[inline]\n    pub fn fmt(&mut self, f: Arguments) -> value::Result {\n        self.0.fmt(f)\n    }\n\n    #[inline]\n    pub fn any(&mut self, v: impl value::Value) -> collect::Result {\n        self.0.any(v)\n    }\n\n    #[inline]\n    pub fn i64(&mut self, v: i64) -> value::Result {\n        self.0.i64(v)\n    }\n\n    #[inline]\n    pub fn u64(&mut self, v: u64) -> value::Result {\n        self.0.u64(v)\n    }\n\n    #[inline]\n    pub fn i128(&mut self, v: i128) -> value::Result {\n        self.0.i128(v)\n    }\n\n    #[inline]\n    pub fn u128(&mut self, v: u128) -> value::Result {\n        self.0.u128(v)\n    }\n\n    #[inline]\n    pub fn f64(&mut self, v: f64) -> value::Result {\n        self.0.f64(v)\n    }\n\n    #[inline]\n    pub fn bool(&mut self, v: bool) -> value::Result {\n        self.0.bool(v)\n    }\n\n    #[inline]\n    pub fn char(&mut self, v: char) -> value::Result {\n        self.0.char(v)\n    }\n\n    #[inline]\n    pub fn str(&mut self, v: &str) -> value::Result {\n        self.0.str(v)\n    }\n\n    #[inline]\n    pub fn none(&mut self) -> value::Result {\n        self.0.none()\n    }\n\n    #[inline]\n    pub fn map_begin(&mut self, len: Option<usize>) -> value::Result {\n        self.0.map_begin(len)\n    }\n\n    #[inline]\n    pub fn map_key(&mut self, k: impl value::Value) -> value::Result {\n        self.0.map_key(k)\n    }\n\n    #[inline]\n    pub fn map_value(&mut self, v: impl value::Value) -> value::Result {\n        self.0.map_value(v)\n    }\n\n    #[inline]\n    pub fn map_end(&mut self) -> value::Result {\n        self.0.map_end()\n    }\n\n    #[inline]\n    pub fn seq_begin(&mut self, len: Option<usize>) -> value::Result {\n        self.0.seq_begin(len)\n    }\n\n    #[inline]\n    pub fn seq_elem(&mut self, v: impl value::Value) -> value::Result {\n        self.0.seq_elem(v)\n    }\n\n    #[inline]\n    pub fn seq_end(&mut self) -> value::Result {\n        self.0.seq_end()\n    }\n}","impl<'a> RefMutCollect<'a> {\n    #[inline]\n    pub fn map_key_begin(&mut self) -> Result<&mut Self, Error> {\n        self.0.map_key_begin()?;\n\n        Ok(self)\n    }\n\n    #[inline]\n    pub fn map_value_begin(&mut self) -> Result<&mut Self, Error> {\n        self.0.map_value_begin()?;\n\n        Ok(self)\n    }\n\n    #[inline]\n    pub fn seq_elem_begin(&mut self) -> Result<&mut Self, Error> {\n        self.0.seq_elem_begin()?;\n\n        Ok(self)\n    }\n}"],"collect::value::Value":["impl<'a> Value<'a> {\n    #[inline]\n    pub(crate) fn new(value: &'a impl value::Value) -> Self {\n        Value { value }\n    }\n\n    #[inline]\n    pub(crate) fn stream(self, stream: impl Collect) -> collect::Result {\n        let mut stream = OwnedCollect::new(stream);\n\n        self.value\n            .stream(&mut value::Stream::new(stream.borrow_mut()))?;\n\n        Ok(())\n    }\n}"],"core::fmt::Arguments":["impl<'a> Value for fmt::Arguments<'a> {\n    #[inline]\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        stream.fmt(*self)\n    }\n}"],"core::fmt::Error":["impl From<Error> for fmt::Error {\n    fn from(_: Error) -> fmt::Error {\n        fmt::Error\n    }\n}"],"core::option::Option":["impl<T> Value for Option<T>\nwhere\n    T: Value,\n{\n    #[inline]\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        match self {\n            Some(v) => stream.any(v),\n            None => stream.none(),\n        }\n    }\n}"],"error::Error":["Clone","impl Error {\n        // NOTE: This method is not public because we already\n        // have a method called `custom` when `alloc` is available.\n        // It's strictly more general than this one, but could\n        // be confusing to users to have bounds change depending\n        // on cargo features\n        pub(crate) fn custom(err: &'static dyn fmt::Display) -> Self {\n            Error(ErrorInner::Custom(err))\n        }\n    }","impl Error {\n    /** Capture a static message as an error. */\n    #[inline]\n    pub fn msg(msg: &'static str) -> Self {\n        Error(ErrorInner::Static(msg))\n    }\n\n    /** Declare some structure as unsupported. */\n    #[inline]\n    pub fn unsupported(operation: &'static str) -> Self {\n        Error(ErrorInner::Unsupported {\n            msg: operation,\n            default: false,\n        })\n    }\n\n    /** Whether or not an error is because some operation was unsupported. */\n    pub fn is_unsupported(&self) -> bool {\n        if let ErrorInner::Unsupported { .. } = self.0 {\n            true\n        } else {\n            false\n        }\n    }\n\n    #[allow(dead_code)]\n    pub(crate) fn default_unsupported(operation: &'static str) -> Self {\n        Error(ErrorInner::Unsupported {\n            msg: operation,\n            default: true,\n        })\n    }\n\n    #[allow(dead_code)]\n    pub(crate) fn is_default_unsupported(&self) -> bool {\n        if let ErrorInner::Unsupported { default: true, .. } = self.0 {\n            true\n        } else {\n            false\n        }\n    }\n}","impl From<fmt::Error> for Error {\n        fn from(_: fmt::Error) -> Self {\n            Error::msg(\"writing format failed\")\n        }\n    }","impl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}"],"error::ErrorInner":["Clone","impl fmt::Debug for ErrorInner {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            ErrorInner::Unsupported { msg: op, .. } => {\n                write!(f, \"unsupported stream operation: {}\", op)\n            }\n            ErrorInner::Static(msg) => msg.fmt(f),\n            #[cfg(not(feature = \"alloc\"))]\n            ErrorInner::Custom(ref err) => err.fmt(f),\n            #[cfg(feature = \"alloc\")]\n            ErrorInner::Owned(ref msg) => msg.fmt(f),\n        }\n    }\n}","impl fmt::Display for ErrorInner {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            ErrorInner::Unsupported { msg: op, .. } => {\n                write!(f, \"unsupported stream operation: {}\", op)\n            }\n            ErrorInner::Static(msg) => msg.fmt(f),\n            #[cfg(not(feature = \"alloc\"))]\n            ErrorInner::Custom(ref err) => err.fmt(f),\n            #[cfg(feature = \"alloc\")]\n            ErrorInner::Owned(ref msg) => msg.fmt(f),\n        }\n    }\n}"],"stream::owned::OwnedStream":["impl<S> OwnedStream<S>\nwhere\n    S: Stream,\n{\n    /**\n    Begin a map key.\n    */\n    #[inline]\n    pub fn map_key_begin(&mut self) -> Result<&mut Self, Error> {\n        self.0.map_key_begin()?;\n\n        Ok(self)\n    }\n\n    /**\n    Begin a map value.\n    */\n    #[inline]\n    pub fn map_value_begin(&mut self) -> Result<&mut Self, Error> {\n        self.0.map_value_begin()?;\n\n        Ok(self)\n    }\n\n    /**\n    Begin a sequence element.\n    */\n    #[inline]\n    pub fn seq_elem_begin(&mut self) -> Result<&mut Self, Error> {\n        self.0.seq_elem_begin()?;\n\n        Ok(self)\n    }\n}","impl<S> OwnedStream<S>\nwhere\n    S: Stream,\n{\n    /**\n    Stream a value.\n    */\n    #[inline]\n    pub fn stream(stream: S, value: impl Value) -> Result<S, Error> {\n        let mut stream = Self::new(stream);\n        stream.any(value)?;\n        Ok(stream.into_inner())\n    }\n\n    /**\n    Begin an owned stream.\n    */\n    #[inline]\n    pub fn new(stream: S) -> Self {\n        OwnedStream(OwnedCollect::new(collect::Default(stream)))\n    }\n\n    /**\n    Unwrap the inner stream.\n    */\n    #[inline]\n    pub fn into_inner(self) -> S {\n        self.0.into_inner().0\n    }\n\n    /**\n    Get a reference to the stream that can be used by a value.\n    */\n    #[inline]\n    pub fn borrow_mut(&mut self) -> RefMutStream {\n        RefMutStream(self.0.borrow_mut())\n    }\n\n    /**\n    Stream a value.\n    */\n    #[inline]\n    pub fn any(&mut self, v: impl Value) -> stream::Result {\n        self.0.any(v)\n    }\n\n    /**\n    Stream a format.\n    */\n    #[inline]\n    pub fn fmt(&mut self, f: Arguments) -> stream::Result {\n        self.0.fmt(f)\n    }\n\n    /**\n    Stream a signed integer.\n    */\n    #[inline]\n    pub fn i64(&mut self, v: i64) -> stream::Result {\n        self.0.i64(v)\n    }\n\n    /**\n    Stream an unsigned integer.\n    */\n    #[inline]\n    pub fn u64(&mut self, v: u64) -> stream::Result {\n        self.0.u64(v)\n    }\n\n    /**\n    Stream a 128-bit signed integer.\n    */\n    #[inline]\n    pub fn i128(&mut self, v: i128) -> stream::Result {\n        self.0.i128(v)\n    }\n\n    /**\n    Stream a 128-bit unsigned integer.\n    */\n    #[inline]\n    pub fn u128(&mut self, v: u128) -> stream::Result {\n        self.0.u128(v)\n    }\n\n    /**\n    Stream a floating point value.\n    */\n    #[inline]\n    pub fn f64(&mut self, v: f64) -> stream::Result {\n        self.0.f64(v)\n    }\n\n    /**\n    Stream a boolean.\n    */\n    #[inline]\n    pub fn bool(&mut self, v: bool) -> stream::Result {\n        self.0.bool(v)\n    }\n\n    /**\n    Stream a unicode character.\n    */\n    #[inline]\n    pub fn char(&mut self, v: char) -> stream::Result {\n        self.0.char(v)\n    }\n\n    /**\n    Stream a UTF8 string.\n    */\n    #[inline]\n    pub fn str(&mut self, v: &str) -> stream::Result {\n        self.0.str(v)\n    }\n\n    /**\n    Stream an empty value.\n    */\n    #[inline]\n    pub fn none(&mut self) -> stream::Result {\n        self.0.none()\n    }\n\n    /**\n    Begin a map.\n    */\n    #[inline]\n    pub fn map_begin(&mut self, len: Option<usize>) -> stream::Result {\n        self.0.map_begin(len)\n    }\n\n    /**\n    Stream a map key.\n    */\n    #[inline]\n    pub fn map_key(&mut self, k: impl Value) -> stream::Result {\n        self.0.map_key(k)\n    }\n\n    /**\n    Stream a map value.\n    */\n    #[inline]\n    pub fn map_value(&mut self, v: impl Value) -> stream::Result {\n        self.0.map_value(v)\n    }\n\n    /**\n    End a map.\n    */\n    #[inline]\n    pub fn map_end(&mut self) -> stream::Result {\n        self.0.map_end()\n    }\n\n    /**\n    Begin a sequence.\n    */\n    #[inline]\n    pub fn seq_begin(&mut self, len: Option<usize>) -> stream::Result {\n        self.0.seq_begin(len)\n    }\n\n    /**\n    Stream a sequence element.\n    */\n    #[inline]\n    pub fn seq_elem(&mut self, v: impl Value) -> stream::Result {\n        self.0.seq_elem(v)\n    }\n\n    /**\n    End a sequence.\n    */\n    #[inline]\n    pub fn seq_end(&mut self) -> stream::Result {\n        self.0.seq_end()\n    }\n}","impl<S> Stream for OwnedStream<S>\nwhere\n    S: Stream,\n{\n    #[inline]\n    fn fmt(&mut self, args: Arguments) -> stream::Result {\n        self.fmt(args)\n    }\n\n    #[inline]\n    fn i64(&mut self, v: i64) -> stream::Result {\n        self.i64(v)\n    }\n\n    #[inline]\n    fn u64(&mut self, v: u64) -> stream::Result {\n        self.u64(v)\n    }\n\n    #[inline]\n    fn i128(&mut self, v: i128) -> stream::Result {\n        self.i128(v)\n    }\n\n    #[inline]\n    fn u128(&mut self, v: u128) -> stream::Result {\n        self.u128(v)\n    }\n\n    #[inline]\n    fn f64(&mut self, v: f64) -> stream::Result {\n        self.f64(v)\n    }\n\n    #[inline]\n    fn bool(&mut self, v: bool) -> stream::Result {\n        self.bool(v)\n    }\n\n    #[inline]\n    fn char(&mut self, v: char) -> stream::Result {\n        self.char(v)\n    }\n\n    #[inline]\n    fn str(&mut self, v: &str) -> stream::Result {\n        self.str(v)\n    }\n\n    #[inline]\n    fn none(&mut self) -> stream::Result {\n        self.none()\n    }\n\n    #[inline]\n    fn map_begin(&mut self, len: Option<usize>) -> stream::Result {\n        self.map_begin(len)\n    }\n\n    #[inline]\n    fn map_key(&mut self) -> stream::Result {\n        self.map_key_begin().map(|_| ())\n    }\n\n    #[inline]\n    fn map_value(&mut self) -> stream::Result {\n        self.map_value_begin().map(|_| ())\n    }\n\n    #[inline]\n    fn map_end(&mut self) -> stream::Result {\n        self.map_end()\n    }\n\n    #[inline]\n    fn seq_begin(&mut self, len: Option<usize>) -> stream::Result {\n        self.seq_begin(len)\n    }\n\n    #[inline]\n    fn seq_elem(&mut self) -> stream::Result {\n        self.seq_elem_begin().map(|_| ())\n    }\n\n    #[inline]\n    fn seq_end(&mut self) -> stream::Result {\n        self.seq_end()\n    }\n}"],"stream::owned::RefMutStream":["impl<'a> RefMutStream<'a> {\n    #[inline]\n    pub(crate) fn new(collect: RefMutCollect<'a>) -> Self {\n        RefMutStream(collect)\n    }\n\n    /**\n    Stream a value.\n    */\n    #[inline]\n    pub fn any(&mut self, v: impl Value) -> stream::Result {\n        self.0.any(v)\n    }\n\n    /**\n    Stream a format.\n    */\n    #[inline]\n    pub fn fmt(&mut self, f: Arguments) -> stream::Result {\n        self.0.fmt(f)\n    }\n\n    /**\n    Stream a signed integer.\n    */\n    #[inline]\n    pub fn i64(&mut self, v: i64) -> stream::Result {\n        self.0.i64(v)\n    }\n\n    /**\n    Stream an unsigned integer.\n    */\n    #[inline]\n    pub fn u64(&mut self, v: u64) -> stream::Result {\n        self.0.u64(v)\n    }\n\n    /**\n    Stream a 128-bit signed integer.\n    */\n    #[inline]\n    pub fn i128(&mut self, v: i128) -> stream::Result {\n        self.0.i128(v)\n    }\n\n    /**\n    Stream a 128-bit unsigned integer.\n    */\n    #[inline]\n    pub fn u128(&mut self, v: u128) -> stream::Result {\n        self.0.u128(v)\n    }\n\n    /**\n    Stream a floating point value.\n    */\n    #[inline]\n    pub fn f64(&mut self, v: f64) -> stream::Result {\n        self.0.f64(v)\n    }\n\n    /**\n    Stream a boolean.\n    */\n    #[inline]\n    pub fn bool(&mut self, v: bool) -> stream::Result {\n        self.0.bool(v)\n    }\n\n    /**\n    Stream a unicode character.\n    */\n    #[inline]\n    pub fn char(&mut self, v: char) -> stream::Result {\n        self.0.char(v)\n    }\n\n    /**\n    Stream a UTF8 string.\n    */\n    #[inline]\n    pub fn str(&mut self, v: &str) -> stream::Result {\n        self.0.str(v)\n    }\n\n    /**\n    Stream an empty value.\n    */\n    #[inline]\n    pub fn none(&mut self) -> stream::Result {\n        self.0.none()\n    }\n\n    /**\n    Begin a map.\n    */\n    #[inline]\n    pub fn map_begin(&mut self, len: Option<usize>) -> stream::Result {\n        self.0.map_begin(len)\n    }\n\n    /**\n    Stream a map key.\n    */\n    #[inline]\n    pub fn map_key(&mut self, k: impl Value) -> stream::Result {\n        self.0.map_key(k)\n    }\n\n    /**\n    Stream a map value.\n    */\n    #[inline]\n    pub fn map_value(&mut self, v: impl Value) -> stream::Result {\n        self.0.map_value(v)\n    }\n\n    /**\n    End a map.\n    */\n    #[inline]\n    pub fn map_end(&mut self) -> stream::Result {\n        self.0.map_end()\n    }\n\n    /**\n    Begin a sequence.\n    */\n    #[inline]\n    pub fn seq_begin(&mut self, len: Option<usize>) -> stream::Result {\n        self.0.seq_begin(len)\n    }\n\n    /**\n    Stream a sequence element.\n    */\n    #[inline]\n    pub fn seq_elem(&mut self, v: impl Value) -> stream::Result {\n        self.0.seq_elem(v)\n    }\n\n    /**\n    End a sequence.\n    */\n    #[inline]\n    pub fn seq_end(&mut self) -> stream::Result {\n        self.0.seq_end()\n    }\n}","impl<'a> RefMutStream<'a> {\n    /**\n    Begin a map key.\n    */\n    #[inline]\n    pub fn map_key_begin(&mut self) -> Result<&mut Self, Error> {\n        self.0.map_key_begin()?;\n\n        Ok(self)\n    }\n\n    /**\n    Begin a map value.\n    */\n    #[inline]\n    pub fn map_value_begin(&mut self) -> Result<&mut Self, Error> {\n        self.0.map_value_begin()?;\n\n        Ok(self)\n    }\n\n    /**\n    Begin a sequence element.\n    */\n    #[inline]\n    pub fn seq_elem_begin(&mut self) -> Result<&mut Self, Error> {\n        self.0.seq_elem_begin()?;\n\n        Ok(self)\n    }\n}","impl<'a> Stream for RefMutStream<'a> {\n    #[inline]\n    fn fmt(&mut self, args: Arguments) -> stream::Result {\n        self.fmt(args)\n    }\n\n    #[inline]\n    fn i64(&mut self, v: i64) -> stream::Result {\n        self.i64(v)\n    }\n\n    #[inline]\n    fn u64(&mut self, v: u64) -> stream::Result {\n        self.u64(v)\n    }\n\n    #[inline]\n    fn i128(&mut self, v: i128) -> stream::Result {\n        self.i128(v)\n    }\n\n    #[inline]\n    fn u128(&mut self, v: u128) -> stream::Result {\n        self.u128(v)\n    }\n\n    #[inline]\n    fn f64(&mut self, v: f64) -> stream::Result {\n        self.f64(v)\n    }\n\n    #[inline]\n    fn bool(&mut self, v: bool) -> stream::Result {\n        self.bool(v)\n    }\n\n    #[inline]\n    fn char(&mut self, v: char) -> stream::Result {\n        self.char(v)\n    }\n\n    #[inline]\n    fn str(&mut self, v: &str) -> stream::Result {\n        self.str(v)\n    }\n\n    #[inline]\n    fn none(&mut self) -> stream::Result {\n        self.none()\n    }\n\n    #[inline]\n    fn map_begin(&mut self, len: Option<usize>) -> stream::Result {\n        self.map_begin(len)\n    }\n\n    #[inline]\n    fn map_key(&mut self) -> stream::Result {\n        self.map_key_begin().map(|_| ())\n    }\n\n    #[inline]\n    fn map_value(&mut self) -> stream::Result {\n        self.map_value_begin().map(|_| ())\n    }\n\n    #[inline]\n    fn map_end(&mut self) -> stream::Result {\n        self.map_end()\n    }\n\n    #[inline]\n    fn seq_begin(&mut self, len: Option<usize>) -> stream::Result {\n        self.seq_begin(len)\n    }\n\n    #[inline]\n    fn seq_elem(&mut self) -> stream::Result {\n        self.seq_elem_begin().map(|_| ())\n    }\n\n    #[inline]\n    fn seq_end(&mut self) -> stream::Result {\n        self.seq_end()\n    }\n}"],"stream::stack::Depth":["Clone","Eq","Ord","PartialEq","PartialOrd"],"stream::stack::Expecting":["impl fmt::Display for Expecting {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"invalid {}, expecting {}\", self.got, self.expecting)\n    }\n}"],"stream::stack::Pos":["Clone","impl Pos {\n    /**\n    Whether the current position is a map key.\n    */\n    #[inline]\n    pub fn is_key(&self) -> bool {\n        self.slot & Slot::MASK_POS == Slot::KEY\n    }\n\n    /**\n    Whether the current position is a map value.\n    */\n    #[inline]\n    pub fn is_value(&self) -> bool {\n        self.slot & Slot::MASK_POS == Slot::VAL\n    }\n\n    /**\n    Whether the current position is a sequence element.\n    */\n    #[inline]\n    pub fn is_elem(&self) -> bool {\n        self.slot & Slot::MASK_POS == Slot::ELEM\n    }\n\n    /**\n    Whether the current position is an empty map.\n    */\n    #[inline]\n    pub fn is_empty_map(&self) -> bool {\n        self.slot == Slot::MAP_DONE\n    }\n\n    /**\n    Whether the current position is an empty sequence.\n    */\n    #[inline]\n    pub fn is_empty_seq(&self) -> bool {\n        self.slot == Slot::SEQ_DONE\n    }\n\n    /**\n    The depth of this position.\n    */\n    #[inline]\n    pub fn depth(&self) -> Depth {\n        Depth(self.depth)\n    }\n}"],"stream::stack::Slot":["Clone","Copy","impl Slot {\n    const EMPTY: u8 = 0b0000_0000;\n\n    const DONE: u8 = 0b0000_0001;\n\n    const ROOT: u8 = 0b1000_0000;\n    const MAP: u8 = 0b0100_0000;\n    const SEQ: u8 = 0b0010_0000;\n\n    const KEY: u8 = 0b0001_0000;\n    const VAL: u8 = 0b0000_1000;\n    const ELEM: u8 = 0b0000_0100;\n\n    const MASK_POS: u8 = Self::ROOT | Self::KEY | Self::VAL | Self::ELEM;\n\n    const MAP_DONE: u8 = Self::MAP | Self::DONE;\n\n    const MAP_KEY: u8 = Self::MAP | Self::KEY;\n    const MAP_KEY_DONE: u8 = Self::MAP_KEY | Self::DONE;\n\n    const MAP_VAL: u8 = Self::MAP | Self::VAL;\n    const MAP_VAL_DONE: u8 = Self::MAP_VAL | Self::DONE;\n\n    const SEQ_DONE: u8 = Self::SEQ | Self::DONE;\n\n    const SEQ_ELEM: u8 = Self::SEQ | Self::ELEM;\n    const SEQ_ELEM_DONE: u8 = Self::SEQ_ELEM | Self::DONE;\n\n    #[inline]\n    fn root() -> Self {\n        Slot(Slot::ROOT)\n    }\n\n    #[inline]\n    fn pos(self, depth: usize) -> Pos {\n        Pos {\n            slot: self.0,\n            depth,\n        }\n    }\n}"],"stream::stack::Stack":["Clone","impl Default for Stack {\n    fn default() -> Self {\n        Self::new()\n    }\n}","impl Stack {\n    /**\n    Create a new stack.\n    */\n    #[inline]\n    pub fn new() -> Self {\n        Stack {\n            inner: inner::Stack::new(),\n        }\n    }\n\n    /**\n    Clear the stack so that it can be re-used.\n\n    Any state it currently contains will be lost.\n    */\n    #[inline]\n    pub fn clear(&mut self) {\n        self.inner.clear();\n    }\n\n    /**\n    Get the current position in the stack.\n    */\n    #[inline]\n    pub fn current(&self) -> Pos {\n        self.inner.current().pos(self.inner.depth())\n    }\n\n    /**\n    Push a primitive.\n\n    A primitive is a simple value that isn't a map or sequence.\n    That includes:\n\n    - [`Arguments`](struct.Arguments.html)\n    - `u64`, `i64`, `u128`, `i128`\n    - `f64`\n    - `bool`\n    - `char`, `&str`\n    - `Option<T>`.\n    */\n    #[inline]\n    pub fn primitive(&mut self) -> Result<Pos, Error> {\n        let mut curr = self.inner.current_mut();\n\n        // The current slot must:\n        // - not be done\n\n        match curr.0 & Slot::DONE {\n            Slot::EMPTY => {\n                curr.0 |= Slot::DONE;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(*curr, \"primitive\"))),\n        }\n    }\n\n    /**\n    Begin a new map.\n\n    The map must be completed by calling `map_end`.\n    */\n    #[inline]\n    pub fn map_begin(&mut self) -> Result<Pos, Error> {\n        let curr = self.inner.current();\n\n        // The current slot must:\n        // - not be done and\n        // - be the root or\n        // - be a map key or\n        // - be a map value or\n        // - be a seq element\n\n        match curr.0 {\n            Slot::ROOT | Slot::MAP_KEY | Slot::MAP_VAL | Slot::SEQ_ELEM => {\n                self.inner.push_depth()?;\n                self.inner.current_mut().0 = Slot::MAP_DONE;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(curr, \"map begin\"))),\n        }\n    }\n\n    /**\n    Begin a map key.\n\n    The key will be implicitly completed by the value\n    that follows it.\n    */\n    #[inline]\n    pub fn map_key(&mut self) -> Result<Pos, Error> {\n        let mut curr = self.inner.current_mut();\n\n        // The current slot must:\n        // - be a fresh map (with no key or value) or\n        // - be a map with a done value\n\n        match curr.0 {\n            Slot::MAP_DONE | Slot::MAP_VAL_DONE => {\n                curr.0 = Slot::MAP_KEY;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(*curr, \"map key\"))),\n        }\n    }\n\n    /**\n    Begin a map value.\n\n    The value will be implicitly completed by the value\n    that follows it.\n    */\n    #[inline]\n    pub fn map_value(&mut self) -> Result<Pos, Error> {\n        let mut curr = self.inner.current_mut();\n\n        // The current slot must:\n        // - be a map with a done key\n\n        match curr.0 {\n            Slot::MAP_KEY_DONE => {\n                curr.0 = Slot::MAP_VAL;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(*curr, \"map value\"))),\n        }\n    }\n\n    /**\n    Complete the current map.\n    */\n    #[inline]\n    pub fn map_end(&mut self) -> Result<Pos, Error> {\n        let curr = self.inner.current();\n\n        // The current slot must:\n        // - be a fresh map or\n        // - be a map with a done value\n\n        match curr.0 {\n            Slot::MAP_DONE | Slot::MAP_VAL_DONE => {\n                // The fact that the slot is not `Slot::ROOT`\n                // guarantees that `depth > 0` and so this\n                // will not overflow\n                unsafe {\n                    self.inner.pop_depth();\n                }\n\n                let mut curr = self.inner.current_mut();\n                curr.0 |= Slot::DONE;\n\n                Ok(curr.pos(self.inner.depth() + 1))\n            }\n            _ => Err(Error::custom(expecting!(curr, \"map end\"))),\n        }\n    }\n\n    /**\n    Begin a new sequence.\n\n    the sequence must be completed by calling `seq_end`.\n    */\n    #[inline]\n    pub fn seq_begin(&mut self) -> Result<Pos, Error> {\n        let curr = self.inner.current();\n\n        // The current slot must:\n        // - not be done and\n        // - be the root or\n        // - be a map key or\n        // - be a map value or\n        // - be a seq element\n\n        match curr.0 {\n            Slot::ROOT | Slot::MAP_KEY | Slot::MAP_VAL | Slot::SEQ_ELEM => {\n                self.inner.push_depth()?;\n                self.inner.current_mut().0 = Slot::SEQ_DONE;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(curr, \"seq begin\"))),\n        }\n    }\n\n    /**\n    Begin a sequence element.\n\n    The element will be implicitly completed by the value\n    that follows it.\n    */\n    #[inline]\n    pub fn seq_elem(&mut self) -> Result<Pos, Error> {\n        let mut curr = self.inner.current_mut();\n\n        // The current slot must:\n        // - be a fresh sequence (with no element) or\n        // - be a sequence with a done element\n\n        match curr.0 {\n            Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => {\n                curr.0 = Slot::SEQ_ELEM;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(*curr, \"seq elem\"))),\n        }\n    }\n\n    /**\n    Complete the current sequence.\n    */\n    #[inline]\n    pub fn seq_end(&mut self) -> Result<Pos, Error> {\n        let curr = self.inner.current();\n\n        // The current slot must:\n        // - be a fresh sequence or\n        // - be a sequence with a done element\n\n        match curr.0 {\n            Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => {\n                // The fact that the slot is not `Slot::ROOT`\n                // guarantees that `depth > 0` and so this\n                // will not overflow\n                unsafe {\n                    self.inner.pop_depth();\n                }\n\n                let mut curr = self.inner.current_mut();\n                curr.0 |= Slot::DONE;\n\n                Ok(curr.pos(self.inner.depth() + 1))\n            }\n            _ => Err(Error::custom(expecting!(curr, \"seq end\"))),\n        }\n    }\n\n    /**\n    Whether or not the stack has seen a complete and valid stream.\n    */\n    #[inline]\n    pub fn can_end(&self) -> bool {\n        self.inner.depth() == 0\n    }\n\n    /**\n    Complete the stack.\n\n    This stack may be re-used after being completed\n    by calling `begin`.\n    */\n    #[inline]\n    pub fn end(&mut self) -> Result<(), Error> {\n        // The stack must be on the root slot\n        // It doesn't matter if the slot is\n        // marked as done or not\n\n        if self.inner.depth() == 0 {\n            // Set the slot to done so it\n            // can't be re-used without calling begin\n            self.inner.current_mut().0 |= Slot::DONE;\n\n            Ok(())\n        } else {\n            Err(Error::msg(\"stack is not empty\"))\n        }\n    }\n}","impl Stream for Stack {\n    #[inline]\n    fn fmt(&mut self, _: stream::Arguments) -> stream::Result {\n        self.primitive().map(|_| ())\n    }\n\n    #[inline]\n    fn i64(&mut self, _: i64) -> stream::Result {\n        self.primitive().map(|_| ())\n    }\n\n    #[inline]\n    fn u64(&mut self, _: u64) -> stream::Result {\n        self.primitive().map(|_| ())\n    }\n\n    #[inline]\n    fn i128(&mut self, _: i128) -> stream::Result {\n        self.primitive().map(|_| ())\n    }\n\n    #[inline]\n    fn u128(&mut self, _: u128) -> stream::Result {\n        self.primitive().map(|_| ())\n    }\n\n    #[inline]\n    fn f64(&mut self, _: f64) -> stream::Result {\n        self.primitive().map(|_| ())\n    }\n\n    #[inline]\n    fn bool(&mut self, _: bool) -> stream::Result {\n        self.primitive().map(|_| ())\n    }\n\n    #[inline]\n    fn char(&mut self, _: char) -> stream::Result {\n        self.primitive().map(|_| ())\n    }\n\n    #[inline]\n    fn str(&mut self, _: &str) -> stream::Result {\n        self.primitive().map(|_| ())\n    }\n\n    #[inline]\n    fn none(&mut self) -> stream::Result {\n        self.primitive().map(|_| ())\n    }\n\n    #[inline]\n    fn map_begin(&mut self, _: Option<usize>) -> stream::Result {\n        self.map_begin().map(|_| ())\n    }\n\n    #[inline]\n    fn map_key(&mut self) -> stream::Result {\n        self.map_key().map(|_| ())\n    }\n\n    #[inline]\n    fn map_value(&mut self) -> stream::Result {\n        self.map_value().map(|_| ())\n    }\n\n    #[inline]\n    fn map_end(&mut self) -> stream::Result {\n        self.map_end().map(|_| ())\n    }\n\n    #[inline]\n    fn seq_begin(&mut self, _: Option<usize>) -> stream::Result {\n        self.seq_begin().map(|_| ())\n    }\n\n    #[inline]\n    fn seq_elem(&mut self) -> stream::Result {\n        self.seq_elem().map(|_| ())\n    }\n\n    #[inline]\n    fn seq_end(&mut self) -> stream::Result {\n        self.seq_end().map(|_| ())\n    }\n}"],"stream::stack::inner::Stack":["Clone","impl Stack {\n        const SLOTS: usize = 16;\n        const MAX_DEPTH: usize = Self::SLOTS - 1;\n\n        #[inline]\n        pub(super) fn new() -> Self {\n            Stack {\n                slots: [Slot::root(); Self::SLOTS],\n                depth: 0,\n            }\n        }\n\n        #[inline]\n        pub(super) fn clear(&mut self) {\n            *self = Stack {\n                slots: [Slot::root(); Self::SLOTS],\n                depth: 0,\n            }\n        }\n\n        #[inline]\n        pub(super) fn depth(&self) -> usize {\n            self.depth\n        }\n\n        #[inline]\n        pub(super) fn push_depth(&mut self) -> Result<(), Error> {\n            if self.depth >= Self::MAX_DEPTH {\n                return Err(Error::msg(\"nesting limit reached\"));\n            }\n\n            self.depth += 1;\n\n            Ok(())\n        }\n\n        // Callers must ensure `self.depth() > 0`\n        #[inline]\n        pub(super) unsafe fn pop_depth(&mut self) {\n            self.depth -= 1;\n        }\n\n        #[inline]\n        pub(super) fn current_mut(&mut self) -> &mut Slot {\n            #[cfg(debug_assertions)]\n            {\n                self.slots.get_mut(self.depth).expect(\"depth out of bounds\")\n            }\n            #[cfg(not(debug_assertions))]\n            {\n                // The depth is guaranteed to be in-bounds\n                // and pointing to initialized memory\n                unsafe { self.slots.get_unchecked_mut(self.depth) }\n            }\n        }\n\n        #[inline]\n        pub(super) fn current(&self) -> Slot {\n            #[cfg(debug_assertions)]\n            {\n                *self.slots.get(self.depth).expect(\"depth out of bounds\")\n            }\n            #[cfg(not(debug_assertions))]\n            {\n                // The depth is guaranteed to be in-bounds\n                // and pointing to initialized memory\n                unsafe { *self.slots.get_unchecked(self.depth) }\n            }\n        }\n    }"]},"single_path_import":{"core::fmt::Arguments":"stream::Arguments","error::Error":"Error","stream::Stream":"Stream","stream::owned::OwnedStream":"stream::OwnedStream","stream::owned::RefMutStream":"value::RefMutStream","stream::stack::Stack":"stream::Stack","value::Value":"Value"},"srcs":{"<&'a T as value::Value>::stream":["#[inline]\nfn stream(&self, stream: &mut Stream) -> Result{\n        (**self).stream(stream)\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"<&'a mut S as collect::Collect>::map_key_collect":["#[inline]\nfn map_key_collect(&mut self, k: Value) -> Result{\n        (**self).map_key_collect(k)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<&'a mut S as collect::Collect>::map_value_collect":["#[inline]\nfn map_value_collect(&mut self, v: Value) -> Result{\n        (**self).map_value_collect(v)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<&'a mut S as collect::Collect>::seq_elem_collect":["#[inline]\nfn seq_elem_collect(&mut self, v: Value) -> Result{\n        (**self).seq_elem_collect(v)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<&'a mut T as stream::Stream>::bool":["#[inline]\nfn bool(&mut self, v: bool) -> Result{\n        (**self).bool(v)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::char":["#[inline]\nfn char(&mut self, v: char) -> Result{\n        (**self).char(v)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::f64":["#[inline]\nfn f64(&mut self, v: f64) -> Result{\n        (**self).f64(v)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::fmt":["#[inline]\nfn fmt(&mut self, args: Arguments) -> Result{\n        (**self).fmt(args)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::i128":["#[inline]\nfn i128(&mut self, v: i128) -> Result{\n        (**self).i128(v)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::i64":["#[inline]\nfn i64(&mut self, v: i64) -> Result{\n        (**self).i64(v)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::map_begin":["#[inline]\nfn map_begin(&mut self, len: Option<usize>) -> Result{\n        (**self).map_begin(len)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::map_end":["#[inline]\nfn map_end(&mut self) -> Result{\n        (**self).map_end()\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::map_key":["#[inline]\nfn map_key(&mut self) -> Result{\n        (**self).map_key()\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::map_value":["#[inline]\nfn map_value(&mut self) -> Result{\n        (**self).map_value()\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::none":["#[inline]\nfn none(&mut self) -> Result{\n        (**self).none()\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::seq_begin":["#[inline]\nfn seq_begin(&mut self, len: Option<usize>) -> Result{\n        (**self).seq_begin(len)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::seq_elem":["#[inline]\nfn seq_elem(&mut self) -> Result{\n        (**self).seq_elem()\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::seq_end":["#[inline]\nfn seq_end(&mut self) -> Result{\n        (**self).seq_end()\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::str":["#[inline]\nfn str(&mut self, v: &str) -> Result{\n        (**self).str(v)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::u128":["#[inline]\nfn u128(&mut self, v: u128) -> Result{\n        (**self).u128(v)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<&'a mut T as stream::Stream>::u64":["#[inline]\nfn u64(&mut self, v: u64) -> Result{\n        (**self).u64(v)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"<collect::Default<S> as collect::Collect>::map_key_collect":["#[inline]\nfn map_key_collect(&mut self, k: Value) -> Result{\n        Stream::map_key(self)?;\n        k.stream(self)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as collect::Collect>::map_value_collect":["#[inline]\nfn map_value_collect(&mut self, v: Value) -> Result{\n        Stream::map_value(self)?;\n        v.stream(self)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as collect::Collect>::seq_elem_collect":["#[inline]\nfn seq_elem_collect(&mut self, v: Value) -> Result{\n        Stream::seq_elem(self)?;\n        v.stream(self)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::bool":["#[inline]\nfn bool(&mut self, v: bool) -> Result{\n        self.0.bool(v)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::char":["#[inline]\nfn char(&mut self, v: char) -> Result{\n        self.0.char(v)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::f64":["#[inline]\nfn f64(&mut self, v: f64) -> Result{\n        self.0.f64(v)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::fmt":["#[inline]\nfn fmt(&mut self, args: stream::Arguments) -> Result{\n        self.0.fmt(args)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::i128":["#[inline]\nfn i128(&mut self, v: i128) -> Result{\n        self.0.i128(v)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::i64":["#[inline]\nfn i64(&mut self, v: i64) -> Result{\n        self.0.i64(v)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::map_begin":["#[inline]\nfn map_begin(&mut self, len: Option<usize>) -> Result{\n        self.0.map_begin(len)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::map_end":["#[inline]\nfn map_end(&mut self) -> Result{\n        self.0.map_end()\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::map_key":["#[inline]\nfn map_key(&mut self) -> Result{\n        self.0.map_key()\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::map_value":["#[inline]\nfn map_value(&mut self) -> Result{\n        self.0.map_value()\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::none":["#[inline]\nfn none(&mut self) -> Result{\n        self.0.none()\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::seq_begin":["#[inline]\nfn seq_begin(&mut self, len: Option<usize>) -> Result{\n        self.0.seq_begin(len)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::seq_elem":["#[inline]\nfn seq_elem(&mut self) -> Result{\n        self.0.seq_elem()\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::seq_end":["#[inline]\nfn seq_end(&mut self) -> Result{\n        self.0.seq_end()\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::str":["#[inline]\nfn str(&mut self, v: &str) -> Result{\n        self.0.str(v)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::u128":["#[inline]\nfn u128(&mut self, v: u128) -> Result{\n        self.0.u128(v)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<collect::Default<S> as stream::Stream>::u64":["#[inline]\nfn u64(&mut self, v: u64) -> Result{\n        self.0.u64(v)\n    }","Real(LocalPath(\"src/collect/mod.rs\"))"],"<error::Error as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::ErrorInner as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            ErrorInner::Unsupported { msg: op, .. } => {\n                write!(f, \"unsupported stream operation: {}\", op)\n            }\n            ErrorInner::Static(msg) => msg.fmt(f),\n            #[cfg(not(feature = \"alloc\"))]\n            ErrorInner::Custom(ref err) => err.fmt(f),\n            #[cfg(feature = \"alloc\")]\n            ErrorInner::Owned(ref msg) => msg.fmt(f),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::ErrorInner as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            ErrorInner::Unsupported { msg: op, .. } => {\n                write!(f, \"unsupported stream operation: {}\", op)\n            }\n            ErrorInner::Static(msg) => msg.fmt(f),\n            #[cfg(not(feature = \"alloc\"))]\n            ErrorInner::Custom(ref err) => err.fmt(f),\n            #[cfg(feature = \"alloc\")]\n            ErrorInner::Owned(ref msg) => msg.fmt(f),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::bool":["#[inline]\nfn bool(&mut self, v: bool) -> stream::Result{\n        self.bool(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::char":["#[inline]\nfn char(&mut self, v: char) -> stream::Result{\n        self.char(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::f64":["#[inline]\nfn f64(&mut self, v: f64) -> stream::Result{\n        self.f64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::fmt":["#[inline]\nfn fmt(&mut self, args: Arguments) -> stream::Result{\n        self.fmt(args)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::i128":["#[inline]\nfn i128(&mut self, v: i128) -> stream::Result{\n        self.i128(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::i64":["#[inline]\nfn i64(&mut self, v: i64) -> stream::Result{\n        self.i64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_begin":["#[inline]\nfn map_begin(&mut self, len: Option<usize>) -> stream::Result{\n        self.map_begin(len)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_end":["#[inline]\nfn map_end(&mut self) -> stream::Result{\n        self.map_end()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_key":["#[inline]\nfn map_key(&mut self) -> stream::Result{\n        self.map_key_begin().map(|_| ())\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_value":["#[inline]\nfn map_value(&mut self) -> stream::Result{\n        self.map_value_begin().map(|_| ())\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::none":["#[inline]\nfn none(&mut self) -> stream::Result{\n        self.none()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::seq_begin":["#[inline]\nfn seq_begin(&mut self, len: Option<usize>) -> stream::Result{\n        self.seq_begin(len)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::seq_elem":["#[inline]\nfn seq_elem(&mut self) -> stream::Result{\n        self.seq_elem_begin().map(|_| ())\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::seq_end":["#[inline]\nfn seq_end(&mut self) -> stream::Result{\n        self.seq_end()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::str":["#[inline]\nfn str(&mut self, v: &str) -> stream::Result{\n        self.str(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::u128":["#[inline]\nfn u128(&mut self, v: u128) -> stream::Result{\n        self.u128(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::OwnedStream<S> as stream::Stream>::u64":["#[inline]\nfn u64(&mut self, v: u64) -> stream::Result{\n        self.u64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::bool":["#[inline]\nfn bool(&mut self, v: bool) -> stream::Result{\n        self.bool(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::char":["#[inline]\nfn char(&mut self, v: char) -> stream::Result{\n        self.char(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::f64":["#[inline]\nfn f64(&mut self, v: f64) -> stream::Result{\n        self.f64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::fmt":["#[inline]\nfn fmt(&mut self, args: Arguments) -> stream::Result{\n        self.fmt(args)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::i128":["#[inline]\nfn i128(&mut self, v: i128) -> stream::Result{\n        self.i128(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::i64":["#[inline]\nfn i64(&mut self, v: i64) -> stream::Result{\n        self.i64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_begin":["#[inline]\nfn map_begin(&mut self, len: Option<usize>) -> stream::Result{\n        self.map_begin(len)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_end":["#[inline]\nfn map_end(&mut self) -> stream::Result{\n        self.map_end()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_key":["#[inline]\nfn map_key(&mut self) -> stream::Result{\n        self.map_key_begin().map(|_| ())\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_value":["#[inline]\nfn map_value(&mut self) -> stream::Result{\n        self.map_value_begin().map(|_| ())\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::none":["#[inline]\nfn none(&mut self) -> stream::Result{\n        self.none()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::seq_begin":["#[inline]\nfn seq_begin(&mut self, len: Option<usize>) -> stream::Result{\n        self.seq_begin(len)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::seq_elem":["#[inline]\nfn seq_elem(&mut self) -> stream::Result{\n        self.seq_elem_begin().map(|_| ())\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::seq_end":["#[inline]\nfn seq_end(&mut self) -> stream::Result{\n        self.seq_end()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::str":["#[inline]\nfn str(&mut self, v: &str) -> stream::Result{\n        self.str(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::u128":["#[inline]\nfn u128(&mut self, v: u128) -> stream::Result{\n        self.u128(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::owned::RefMutStream<'a> as stream::Stream>::u64":["#[inline]\nfn u64(&mut self, v: u64) -> stream::Result{\n        self.u64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"<stream::stack::Expecting as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"invalid {}, expecting {}\", self.got, self.expecting)\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as core::default::Default>::default":["fn default() -> Self{\n        Self::new()\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::bool":["#[inline]\nfn bool(&mut self, _: bool) -> stream::Result{\n        self.primitive().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::char":["#[inline]\nfn char(&mut self, _: char) -> stream::Result{\n        self.primitive().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::f64":["#[inline]\nfn f64(&mut self, _: f64) -> stream::Result{\n        self.primitive().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::fmt":["#[inline]\nfn fmt(&mut self, _: stream::Arguments) -> stream::Result{\n        self.primitive().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::i128":["#[inline]\nfn i128(&mut self, _: i128) -> stream::Result{\n        self.primitive().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::i64":["#[inline]\nfn i64(&mut self, _: i64) -> stream::Result{\n        self.primitive().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::map_begin":["#[inline]\nfn map_begin(&mut self, _: Option<usize>) -> stream::Result{\n        self.map_begin().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::map_end":["#[inline]\nfn map_end(&mut self) -> stream::Result{\n        self.map_end().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::map_key":["#[inline]\nfn map_key(&mut self) -> stream::Result{\n        self.map_key().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::map_value":["#[inline]\nfn map_value(&mut self) -> stream::Result{\n        self.map_value().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::none":["#[inline]\nfn none(&mut self) -> stream::Result{\n        self.primitive().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::seq_begin":["#[inline]\nfn seq_begin(&mut self, _: Option<usize>) -> stream::Result{\n        self.seq_begin().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::seq_elem":["#[inline]\nfn seq_elem(&mut self) -> stream::Result{\n        self.seq_elem().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::seq_end":["#[inline]\nfn seq_end(&mut self) -> stream::Result{\n        self.seq_end().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::str":["#[inline]\nfn str(&mut self, _: &str) -> stream::Result{\n        self.primitive().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::u128":["#[inline]\nfn u128(&mut self, _: u128) -> stream::Result{\n        self.primitive().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"<stream::stack::Stack as stream::Stream>::u64":["#[inline]\nfn u64(&mut self, _: u64) -> stream::Result{\n        self.primitive().map(|_| ())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"collect::Collect":["/**\nAn extension to `Stream` for items that are known upfront.\n*/\npub(crate) trait Collect: Stream {\n    fn map_key_collect(&mut self, k: Value) -> Result;\n\n    fn map_value_collect(&mut self, v: Value) -> Result;\n\n    fn seq_elem_collect(&mut self, v: Value) -> Result;\n}","Real(LocalPath(\"src/collect/mod.rs\"))"],"collect::Default":["/**\nDefault implementations for stream extensions.\n*/\npub(crate) struct Default<S>(pub(crate) S);","Real(LocalPath(\"src/collect/mod.rs\"))"],"collect::owned::OwnedCollect":["pub(crate) struct OwnedCollect<TStream> {\n    stream: TStream,\n}","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::any":["#[inline]\npub fn any(&mut self, v: impl value::Value) -> collect::Result{\n        v.stream(&mut value::Stream::new(self.borrow_mut()))\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::bool":["#[inline]\npub fn bool(&mut self, v: bool) -> collect::Result{\n        self.stream.bool(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::borrow_mut":["#[inline]\npub(crate) fn borrow_mut(&mut self) -> RefMutCollect{\n        RefMutCollect(OwnedCollect::new(&mut self.stream))\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::char":["#[inline]\npub fn char(&mut self, v: char) -> collect::Result{\n        self.stream.char(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::f64":["#[inline]\npub fn f64(&mut self, v: f64) -> collect::Result{\n        self.stream.f64(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::fmt":["#[inline]\npub fn fmt(&mut self, f: Arguments) -> collect::Result{\n        self.stream.fmt(f)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::i128":["#[inline]\npub fn i128(&mut self, v: i128) -> collect::Result{\n        self.stream.i128(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::i64":["#[inline]\npub fn i64(&mut self, v: i64) -> collect::Result{\n        self.stream.i64(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::into_inner":["#[inline]\npub(crate) fn into_inner(self) -> TStream{\n        self.stream\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::map_begin":["#[inline]\npub fn map_begin(&mut self, len: Option<usize>) -> collect::Result{\n        self.stream.map_begin(len)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::map_end":["#[inline]\npub fn map_end(&mut self) -> collect::Result{\n        self.stream.map_end()\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::map_key":["#[inline]\npub fn map_key(&mut self, k: impl value::Value) -> collect::Result{\n        self.stream.map_key_collect(Value::new(&k))\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::map_key_begin":["#[inline]\npub fn map_key_begin(&mut self) -> Result<&mut Self, Error>{\n        self.stream.map_key()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::map_value":["#[inline]\npub fn map_value(&mut self, v: impl value::Value) -> collect::Result{\n        self.stream.map_value_collect(Value::new(&v))\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::map_value_begin":["#[inline]\npub fn map_value_begin(&mut self) -> Result<&mut Self, Error>{\n        self.stream.map_value()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::new":["#[inline]\npub(crate) fn new(stream: TStream) -> Self{\n        OwnedCollect { stream }\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::none":["#[inline]\npub fn none(&mut self) -> collect::Result{\n        self.stream.none()\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::seq_begin":["#[inline]\npub fn seq_begin(&mut self, len: Option<usize>) -> collect::Result{\n        self.stream.seq_begin(len)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::seq_elem":["#[inline]\npub fn seq_elem(&mut self, v: impl value::Value) -> collect::Result{\n        self.stream.seq_elem_collect(Value::new(&v))\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::seq_elem_begin":["#[inline]\npub fn seq_elem_begin(&mut self) -> Result<&mut Self, Error>{\n        self.stream.seq_elem()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::seq_end":["#[inline]\npub fn seq_end(&mut self) -> collect::Result{\n        self.stream.seq_end()\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::str":["#[inline]\npub fn str(&mut self, v: &str) -> collect::Result{\n        self.stream.str(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::u128":["#[inline]\npub fn u128(&mut self, v: u128) -> collect::Result{\n        self.stream.u128(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::OwnedCollect::<TStream>::u64":["#[inline]\npub fn u64(&mut self, v: u64) -> collect::Result{\n        self.stream.u64(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect":["pub(crate) struct RefMutCollect<'a>(OwnedCollect<&'a mut dyn Collect>);","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::any":["#[inline]\npub fn any(&mut self, v: impl value::Value) -> collect::Result{\n        self.0.any(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::bool":["#[inline]\npub fn bool(&mut self, v: bool) -> value::Result{\n        self.0.bool(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::char":["#[inline]\npub fn char(&mut self, v: char) -> value::Result{\n        self.0.char(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::f64":["#[inline]\npub fn f64(&mut self, v: f64) -> value::Result{\n        self.0.f64(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::fmt":["#[inline]\npub fn fmt(&mut self, f: Arguments) -> value::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::i128":["#[inline]\npub fn i128(&mut self, v: i128) -> value::Result{\n        self.0.i128(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::i64":["#[inline]\npub fn i64(&mut self, v: i64) -> value::Result{\n        self.0.i64(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::map_begin":["#[inline]\npub fn map_begin(&mut self, len: Option<usize>) -> value::Result{\n        self.0.map_begin(len)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::map_end":["#[inline]\npub fn map_end(&mut self) -> value::Result{\n        self.0.map_end()\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::map_key":["#[inline]\npub fn map_key(&mut self, k: impl value::Value) -> value::Result{\n        self.0.map_key(k)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::map_key_begin":["#[inline]\npub fn map_key_begin(&mut self) -> Result<&mut Self, Error>{\n        self.0.map_key_begin()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::map_value":["#[inline]\npub fn map_value(&mut self, v: impl value::Value) -> value::Result{\n        self.0.map_value(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::map_value_begin":["#[inline]\npub fn map_value_begin(&mut self) -> Result<&mut Self, Error>{\n        self.0.map_value_begin()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::none":["#[inline]\npub fn none(&mut self) -> value::Result{\n        self.0.none()\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::seq_begin":["#[inline]\npub fn seq_begin(&mut self, len: Option<usize>) -> value::Result{\n        self.0.seq_begin(len)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::seq_elem":["#[inline]\npub fn seq_elem(&mut self, v: impl value::Value) -> value::Result{\n        self.0.seq_elem(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::seq_elem_begin":["#[inline]\npub fn seq_elem_begin(&mut self) -> Result<&mut Self, Error>{\n        self.0.seq_elem_begin()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::seq_end":["#[inline]\npub fn seq_end(&mut self) -> value::Result{\n        self.0.seq_end()\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::str":["#[inline]\npub fn str(&mut self, v: &str) -> value::Result{\n        self.0.str(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::u128":["#[inline]\npub fn u128(&mut self, v: u128) -> value::Result{\n        self.0.u128(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::owned::RefMutCollect::<'a>::u64":["#[inline]\npub fn u64(&mut self, v: u64) -> value::Result{\n        self.0.u64(v)\n    }","Real(LocalPath(\"src/collect/owned.rs\"))"],"collect::value::Value":["pub(crate) struct Value<'a> {\n    value: &'a dyn value::Value,\n}","Real(LocalPath(\"src/collect/value.rs\"))"],"collect::value::Value::<'a>::new":["#[inline]\npub(crate) fn new(value: &'a impl value::Value) -> Self{\n        Value { value }\n    }","Real(LocalPath(\"src/collect/value.rs\"))"],"collect::value::Value::<'a>::stream":["#[inline]\npub(crate) fn stream(self, stream: impl Collect) -> collect::Result{\n        let mut stream = OwnedCollect::new(stream);\n\n        self.value\n            .stream(&mut value::Stream::new(stream.borrow_mut()))?;\n\n        Ok(())\n    }","Real(LocalPath(\"src/collect/value.rs\"))"],"error::<impl core::convert::From<error::Error> for core::fmt::Error>::from":["fn from(_: Error) -> fmt::Error{\n        fmt::Error\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error":["/**\nAn error encountered while visiting a value.\n\n# Converting an `Error` into a standard error\n\nThe `Error` type doesn't implement the `std::error::Error` trait directly.\nWhen `std` is available, the `into_error` method will convert an\n`Error` into a value that implements `std::error::Error`.\n*/\npub struct Error(ErrorInner);","Real(LocalPath(\"src/error.rs\"))"],"error::Error::default_unsupported":["#[allow(dead_code)]\npub(crate) fn default_unsupported(operation: &'static str) -> Self{\n        Error(ErrorInner::Unsupported {\n            msg: operation,\n            default: true,\n        })\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::is_default_unsupported":["#[allow(dead_code)]\npub(crate) fn is_default_unsupported(&self) -> bool{\n        if let ErrorInner::Unsupported { default: true, .. } = self.0 {\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::is_unsupported":["/** Whether or not an error is because some operation was unsupported. */\npub fn is_unsupported(&self) -> bool{\n        if let ErrorInner::Unsupported { .. } = self.0 {\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::msg":["/** Capture a static message as an error. */\n#[inline]\npub fn msg(msg: &'static str) -> Self{\n        Error(ErrorInner::Static(msg))\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::unsupported":["/** Declare some structure as unsupported. */\n#[inline]\npub fn unsupported(operation: &'static str) -> Self{\n        Error(ErrorInner::Unsupported {\n            msg: operation,\n            default: false,\n        })\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::ErrorInner":["enum ErrorInner {\n    Unsupported {\n        msg: &'static str,\n        default: bool,\n    },\n    Static(&'static str),\n    #[cfg(not(feature = \"alloc\"))]\n    Custom(&'static dyn fmt::Display),\n    #[cfg(feature = \"alloc\")]\n    Owned(String),\n}","Real(LocalPath(\"src/error.rs\"))"],"error::no_alloc_support::<impl error::Error>::custom":["pub(crate) fn custom(err: &'static dyn fmt::Display) -> Self{\n            Error(ErrorInner::Custom(err))\n        }","Real(LocalPath(\"src/error.rs\"))"],"error::no_std_support::<impl core::convert::From<core::fmt::Error> for error::Error>::from":["fn from(_: fmt::Error) -> Self{\n            Error::msg(\"writing format failed\")\n        }","Real(LocalPath(\"src/error.rs\"))"],"stream":["/**\nStream the structure of a [`Value`] using the given [`Stream`].\n\nThis method is a convenient way of calling [`OwnedStream::stream`](stream/struct.OwnedStream.html#method.stream).\n*/\npub fn stream<S>(stream: S, value: impl Value) -> Result<S, Error>\nwhere\n    S: Stream,{\n    crate::stream::OwnedStream::stream(stream, value)\n}","Real(LocalPath(\"src/lib.rs\"))"],"stream::Stream":["/**\nA receiver for the structure of a value.\n\nThe `Stream` trait has a flat, stateless structure, but it may need to work with\nnested values. Implementations can use a [`Stack`] to track state for them.\n\nThe [`OwnedStream`] type is an ergonomic wrapper over a raw `Stream` that adds\nthe concept of [`Value`](../value/trait.Value.html)s.\n\n# Implementing `Stream`\n\nA stream may choose what kinds of structures it supports by selectively\nimplementing methods on the trait. Other methods default to returning\n[`Error::unsupported`]. Implementations may also choose to return\n`Error::unsupported` for other reasons.\n\n## Supporting primitives\n\nThe following stream can support any primitive value:\n\n```\n# struct MyStream;\nuse sval::{stream, Stream};\n\nimpl Stream for MyStream {\n    fn fmt(&mut self, args: stream::Arguments) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn i128(&mut self, v: i128) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn u128(&mut self, v: u128) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn f64(&mut self, v: f64) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn bool(&mut self, v: bool) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn str(&mut self, v: &str) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn none(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n}\n```\n\n## Supporting maps\n\nIn addition to the [methods needed for streaming primitives](#supporting-primitives),\na stream that supports maps needs to implement a few additional methods:\n\n```\n# struct MyStream;\nuse sval::{stream, Stream};\n\nimpl Stream for MyStream {\n    fn map_begin(&mut self, len: Option<usize>) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn map_key(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn map_value(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn map_end(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n}\n```\n\n## Supporting sequences\n\nIn addition to the [methods needed for streaming primitives](#supporting-primitives),\na stream that supports sequences needs to implement a few additional methods:\n\n```\n# struct MyStream;\nuse sval::{stream, Stream};\n\nimpl Stream for MyStream {\n    fn seq_begin(&mut self, len: Option<usize>) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn seq_elem(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn seq_end(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n}\n```\n\n## Supporting all structure\n\n```\n# struct MyStream;\nuse sval::{stream, Stream};\n\nimpl Stream for MyStream {\n    fn fmt(&mut self, args: stream::Arguments) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn i128(&mut self, v: i128) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn u128(&mut self, v: u128) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn f64(&mut self, v: f64) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn bool(&mut self, v: bool) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn str(&mut self, v: &str) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn none(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn map_begin(&mut self, len: Option<usize>) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn map_key(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn map_value(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn map_end(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn seq_begin(&mut self, len: Option<usize>) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn seq_elem(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n\n    fn seq_end(&mut self) -> stream::Result {\n#       /*\n        ..\n#       */\n\n        Ok(())\n    }\n}\n```\n\n[`Value`]: ../trait.Value.html\n[`Error::unsupported`]: struct.Error.html#method.unsupported\n*/\npub trait Stream {\n    /**\n    Stream a format.\n    */\n    #[cfg(not(test))]\n    fn fmt(&mut self, args: Arguments) -> Result {\n        let _ = args;\n        Err(Error::default_unsupported(\"Stream::fmt\"))\n    }\n    #[cfg(test)]\n    fn fmt(&mut self, args: Arguments) -> Result;\n\n    /**\n    Stream a signed integer.\n    */\n    #[cfg(not(test))]\n    fn i64(&mut self, v: i64) -> Result {\n        self.i128(v as i128)\n    }\n    #[cfg(test)]\n    fn i64(&mut self, v: i64) -> Result;\n\n    /**\n    Stream an unsigned integer.\n    */\n    #[cfg(not(test))]\n    fn u64(&mut self, v: u64) -> Result {\n        self.u128(v as u128)\n    }\n    #[cfg(test)]\n    fn u64(&mut self, v: u64) -> Result;\n\n    /**\n    Stream a 128bit signed integer.\n    */\n    #[cfg(not(test))]\n    fn i128(&mut self, v: i128) -> Result {\n        let _ = v;\n        Err(Error::default_unsupported(\"Stream::i128\"))\n    }\n    #[cfg(test)]\n    fn i128(&mut self, v: i128) -> Result;\n\n    /**\n    Stream a 128bit unsigned integer.\n    */\n    #[cfg(not(test))]\n    fn u128(&mut self, v: u128) -> Result {\n        let _ = v;\n        Err(Error::default_unsupported(\"Stream::u128\"))\n    }\n    #[cfg(test)]\n    fn u128(&mut self, v: u128) -> Result;\n\n    /**\n    Stream a floating point value.\n    */\n    #[cfg(not(test))]\n    fn f64(&mut self, v: f64) -> Result {\n        let _ = v;\n        Err(Error::default_unsupported(\"Stream::f64\"))\n    }\n    #[cfg(test)]\n    fn f64(&mut self, v: f64) -> Result;\n\n    /**\n    Stream a boolean.\n    */\n    #[cfg(not(test))]\n    fn bool(&mut self, v: bool) -> Result {\n        let _ = v;\n        Err(Error::default_unsupported(\"Stream::bool\"))\n    }\n    #[cfg(test)]\n    fn bool(&mut self, v: bool) -> Result;\n\n    /**\n    Stream a unicode character.\n    */\n    #[cfg(not(test))]\n    fn char(&mut self, v: char) -> Result {\n        let mut b = [0; 4];\n        self.str(&*v.encode_utf8(&mut b))\n    }\n    #[cfg(test)]\n    fn char(&mut self, v: char) -> Result;\n\n    /**\n    Stream a UTF-8 string slice.\n    */\n    #[cfg(not(test))]\n    fn str(&mut self, v: &str) -> Result {\n        let _ = v;\n        Err(Error::default_unsupported(\"Stream::str\"))\n    }\n    #[cfg(test)]\n    fn str(&mut self, v: &str) -> Result;\n\n    /**\n    Stream an empty value.\n    */\n    #[cfg(not(test))]\n    fn none(&mut self) -> Result {\n        Err(Error::default_unsupported(\"Stream::none\"))\n    }\n    #[cfg(test)]\n    fn none(&mut self) -> Result;\n\n    /**\n    Begin a map.\n    */\n    #[cfg(not(test))]\n    fn map_begin(&mut self, len: Option<usize>) -> Result {\n        let _ = len;\n        Err(Error::default_unsupported(\"Stream::map_begin\"))\n    }\n    #[cfg(test)]\n    fn map_begin(&mut self, len: Option<usize>) -> Result;\n\n    /**\n    Begin a map key.\n\n    The key will be implicitly ended by the stream methods that follow it.\n    */\n    #[cfg(not(test))]\n    fn map_key(&mut self) -> Result {\n        Err(Error::default_unsupported(\"Stream::map_key\"))\n    }\n    #[cfg(test)]\n    fn map_key(&mut self) -> Result;\n\n    /**\n    Begin a map value.\n\n    The value will be implicitly ended by the stream methods that follow it.\n    */\n    #[cfg(not(test))]\n    fn map_value(&mut self) -> Result {\n        Err(Error::default_unsupported(\"Stream::map_value\"))\n    }\n    #[cfg(test)]\n    fn map_value(&mut self) -> Result;\n\n    /**\n    End a map.\n    */\n    #[cfg(not(test))]\n    fn map_end(&mut self) -> Result {\n        Err(Error::default_unsupported(\"Stream::map_end\"))\n    }\n    #[cfg(test)]\n    fn map_end(&mut self) -> Result;\n\n    /**\n    Begin a sequence.\n    */\n    #[cfg(not(test))]\n    fn seq_begin(&mut self, len: Option<usize>) -> Result {\n        let _ = len;\n        Err(Error::default_unsupported(\"Stream::seq_begin\"))\n    }\n    #[cfg(test)]\n    fn seq_begin(&mut self, len: Option<usize>) -> Result;\n\n    /**\n    Begin a sequence element.\n\n    The element will be implicitly ended by the stream methods that follow it.\n    */\n    #[cfg(not(test))]\n    fn seq_elem(&mut self) -> Result {\n        Err(Error::default_unsupported(\"Stream::seq_elem\"))\n    }\n    #[cfg(test)]\n    fn seq_elem(&mut self) -> Result;\n\n    /**\n    End a sequence.\n    */\n    #[cfg(not(test))]\n    fn seq_end(&mut self) -> Result {\n        Err(Error::default_unsupported(\"Stream::seq_end\"))\n    }\n    #[cfg(test)]\n    fn seq_end(&mut self) -> Result;\n}","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::bool":["/**\n    Stream a boolean.\n    */\n#[cfg(not(test))]\nfn bool(&mut self, v: bool) -> Result{\n        let _ = v;\n        Err(Error::default_unsupported(\"Stream::bool\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::char":["/**\n    Stream a unicode character.\n    */\n#[cfg(not(test))]\nfn char(&mut self, v: char) -> Result{\n        let mut b = [0; 4];\n        self.str(&*v.encode_utf8(&mut b))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::f64":["/**\n    Stream a floating point value.\n    */\n#[cfg(not(test))]\nfn f64(&mut self, v: f64) -> Result{\n        let _ = v;\n        Err(Error::default_unsupported(\"Stream::f64\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::fmt":["/**\n    Stream a format.\n    */\n#[cfg(not(test))]\nfn fmt(&mut self, args: Arguments) -> Result{\n        let _ = args;\n        Err(Error::default_unsupported(\"Stream::fmt\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::i128":["/**\n    Stream a 128bit signed integer.\n    */\n#[cfg(not(test))]\nfn i128(&mut self, v: i128) -> Result{\n        let _ = v;\n        Err(Error::default_unsupported(\"Stream::i128\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::i64":["/**\n    Stream a signed integer.\n    */\n#[cfg(not(test))]\nfn i64(&mut self, v: i64) -> Result{\n        self.i128(v as i128)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::map_begin":["/**\n    Begin a map.\n    */\n#[cfg(not(test))]\nfn map_begin(&mut self, len: Option<usize>) -> Result{\n        let _ = len;\n        Err(Error::default_unsupported(\"Stream::map_begin\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::map_end":["/**\n    End a map.\n    */\n#[cfg(not(test))]\nfn map_end(&mut self) -> Result{\n        Err(Error::default_unsupported(\"Stream::map_end\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::map_key":["/**\n    Begin a map key.\n\n    The key will be implicitly ended by the stream methods that follow it.\n    */\n#[cfg(not(test))]\nfn map_key(&mut self) -> Result{\n        Err(Error::default_unsupported(\"Stream::map_key\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::map_value":["/**\n    Begin a map value.\n\n    The value will be implicitly ended by the stream methods that follow it.\n    */\n#[cfg(not(test))]\nfn map_value(&mut self) -> Result{\n        Err(Error::default_unsupported(\"Stream::map_value\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::none":["/**\n    Stream an empty value.\n    */\n#[cfg(not(test))]\nfn none(&mut self) -> Result{\n        Err(Error::default_unsupported(\"Stream::none\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::seq_begin":["/**\n    Begin a sequence.\n    */\n#[cfg(not(test))]\nfn seq_begin(&mut self, len: Option<usize>) -> Result{\n        let _ = len;\n        Err(Error::default_unsupported(\"Stream::seq_begin\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::seq_elem":["/**\n    Begin a sequence element.\n\n    The element will be implicitly ended by the stream methods that follow it.\n    */\n#[cfg(not(test))]\nfn seq_elem(&mut self) -> Result{\n        Err(Error::default_unsupported(\"Stream::seq_elem\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::seq_end":["/**\n    End a sequence.\n    */\n#[cfg(not(test))]\nfn seq_end(&mut self) -> Result{\n        Err(Error::default_unsupported(\"Stream::seq_end\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::str":["/**\n    Stream a UTF-8 string slice.\n    */\n#[cfg(not(test))]\nfn str(&mut self, v: &str) -> Result{\n        let _ = v;\n        Err(Error::default_unsupported(\"Stream::str\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::u128":["/**\n    Stream a 128bit unsigned integer.\n    */\n#[cfg(not(test))]\nfn u128(&mut self, v: u128) -> Result{\n        let _ = v;\n        Err(Error::default_unsupported(\"Stream::u128\"))\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::Stream::u64":["/**\n    Stream an unsigned integer.\n    */\n#[cfg(not(test))]\nfn u64(&mut self, v: u64) -> Result{\n        self.u128(v as u128)\n    }","Real(LocalPath(\"src/stream/mod.rs\"))"],"stream::owned::OwnedStream":["/**\nAn owned stream wrapper.\n\n`OwnedStream` is an ergonomic wrapper over a raw [`Stream`] that makes it\neasier to stream complex types.\n*/\npub struct OwnedStream<S>(OwnedCollect<collect::Default<S>>);","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::any":["/**\n    Stream a value.\n    */\n#[inline]\npub fn any(&mut self, v: impl Value) -> stream::Result{\n        self.0.any(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::bool":["/**\n    Stream a boolean.\n    */\n#[inline]\npub fn bool(&mut self, v: bool) -> stream::Result{\n        self.0.bool(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::borrow_mut":["/**\n    Get a reference to the stream that can be used by a value.\n    */\n#[inline]\npub fn borrow_mut(&mut self) -> RefMutStream{\n        RefMutStream(self.0.borrow_mut())\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::char":["/**\n    Stream a unicode character.\n    */\n#[inline]\npub fn char(&mut self, v: char) -> stream::Result{\n        self.0.char(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::f64":["/**\n    Stream a floating point value.\n    */\n#[inline]\npub fn f64(&mut self, v: f64) -> stream::Result{\n        self.0.f64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::fmt":["/**\n    Stream a format.\n    */\n#[inline]\npub fn fmt(&mut self, f: Arguments) -> stream::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::i128":["/**\n    Stream a 128-bit signed integer.\n    */\n#[inline]\npub fn i128(&mut self, v: i128) -> stream::Result{\n        self.0.i128(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::i64":["/**\n    Stream a signed integer.\n    */\n#[inline]\npub fn i64(&mut self, v: i64) -> stream::Result{\n        self.0.i64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::into_inner":["/**\n    Unwrap the inner stream.\n    */\n#[inline]\npub fn into_inner(self) -> S{\n        self.0.into_inner().0\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::map_begin":["/**\n    Begin a map.\n    */\n#[inline]\npub fn map_begin(&mut self, len: Option<usize>) -> stream::Result{\n        self.0.map_begin(len)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::map_end":["/**\n    End a map.\n    */\n#[inline]\npub fn map_end(&mut self) -> stream::Result{\n        self.0.map_end()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::map_key":["/**\n    Stream a map key.\n    */\n#[inline]\npub fn map_key(&mut self, k: impl Value) -> stream::Result{\n        self.0.map_key(k)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::map_key_begin":["/**\n    Begin a map key.\n    */\n#[inline]\npub fn map_key_begin(&mut self) -> Result<&mut Self, Error>{\n        self.0.map_key_begin()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::map_value":["/**\n    Stream a map value.\n    */\n#[inline]\npub fn map_value(&mut self, v: impl Value) -> stream::Result{\n        self.0.map_value(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::map_value_begin":["/**\n    Begin a map value.\n    */\n#[inline]\npub fn map_value_begin(&mut self) -> Result<&mut Self, Error>{\n        self.0.map_value_begin()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::new":["/**\n    Begin an owned stream.\n    */\n#[inline]\npub fn new(stream: S) -> Self{\n        OwnedStream(OwnedCollect::new(collect::Default(stream)))\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::none":["/**\n    Stream an empty value.\n    */\n#[inline]\npub fn none(&mut self) -> stream::Result{\n        self.0.none()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::seq_begin":["/**\n    Begin a sequence.\n    */\n#[inline]\npub fn seq_begin(&mut self, len: Option<usize>) -> stream::Result{\n        self.0.seq_begin(len)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::seq_elem":["/**\n    Stream a sequence element.\n    */\n#[inline]\npub fn seq_elem(&mut self, v: impl Value) -> stream::Result{\n        self.0.seq_elem(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::seq_elem_begin":["/**\n    Begin a sequence element.\n    */\n#[inline]\npub fn seq_elem_begin(&mut self) -> Result<&mut Self, Error>{\n        self.0.seq_elem_begin()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::seq_end":["/**\n    End a sequence.\n    */\n#[inline]\npub fn seq_end(&mut self) -> stream::Result{\n        self.0.seq_end()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::str":["/**\n    Stream a UTF8 string.\n    */\n#[inline]\npub fn str(&mut self, v: &str) -> stream::Result{\n        self.0.str(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::stream":["/**\n    Stream a value.\n    */\n#[inline]\npub fn stream(stream: S, value: impl Value) -> Result<S, Error>{\n        let mut stream = Self::new(stream);\n        stream.any(value)?;\n        Ok(stream.into_inner())\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::u128":["/**\n    Stream a 128-bit unsigned integer.\n    */\n#[inline]\npub fn u128(&mut self, v: u128) -> stream::Result{\n        self.0.u128(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::OwnedStream::<S>::u64":["/**\n    Stream an unsigned integer.\n    */\n#[inline]\npub fn u64(&mut self, v: u64) -> stream::Result{\n        self.0.u64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream":["/**\nA borrowed stream wrapper.\n\nThis is the result of calling `OwnedStream.borrow_mut`.\n*/\npub struct RefMutStream<'a>(RefMutCollect<'a>);","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::any":["/**\n    Stream a value.\n    */\n#[inline]\npub fn any(&mut self, v: impl Value) -> stream::Result{\n        self.0.any(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::bool":["/**\n    Stream a boolean.\n    */\n#[inline]\npub fn bool(&mut self, v: bool) -> stream::Result{\n        self.0.bool(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::char":["/**\n    Stream a unicode character.\n    */\n#[inline]\npub fn char(&mut self, v: char) -> stream::Result{\n        self.0.char(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::f64":["/**\n    Stream a floating point value.\n    */\n#[inline]\npub fn f64(&mut self, v: f64) -> stream::Result{\n        self.0.f64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::fmt":["/**\n    Stream a format.\n    */\n#[inline]\npub fn fmt(&mut self, f: Arguments) -> stream::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::i128":["/**\n    Stream a 128-bit signed integer.\n    */\n#[inline]\npub fn i128(&mut self, v: i128) -> stream::Result{\n        self.0.i128(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::i64":["/**\n    Stream a signed integer.\n    */\n#[inline]\npub fn i64(&mut self, v: i64) -> stream::Result{\n        self.0.i64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::map_begin":["/**\n    Begin a map.\n    */\n#[inline]\npub fn map_begin(&mut self, len: Option<usize>) -> stream::Result{\n        self.0.map_begin(len)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::map_end":["/**\n    End a map.\n    */\n#[inline]\npub fn map_end(&mut self) -> stream::Result{\n        self.0.map_end()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::map_key":["/**\n    Stream a map key.\n    */\n#[inline]\npub fn map_key(&mut self, k: impl Value) -> stream::Result{\n        self.0.map_key(k)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::map_key_begin":["/**\n    Begin a map key.\n    */\n#[inline]\npub fn map_key_begin(&mut self) -> Result<&mut Self, Error>{\n        self.0.map_key_begin()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::map_value":["/**\n    Stream a map value.\n    */\n#[inline]\npub fn map_value(&mut self, v: impl Value) -> stream::Result{\n        self.0.map_value(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::map_value_begin":["/**\n    Begin a map value.\n    */\n#[inline]\npub fn map_value_begin(&mut self) -> Result<&mut Self, Error>{\n        self.0.map_value_begin()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::new":["#[inline]\npub(crate) fn new(collect: RefMutCollect<'a>) -> Self{\n        RefMutStream(collect)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::none":["/**\n    Stream an empty value.\n    */\n#[inline]\npub fn none(&mut self) -> stream::Result{\n        self.0.none()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::seq_begin":["/**\n    Begin a sequence.\n    */\n#[inline]\npub fn seq_begin(&mut self, len: Option<usize>) -> stream::Result{\n        self.0.seq_begin(len)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::seq_elem":["/**\n    Stream a sequence element.\n    */\n#[inline]\npub fn seq_elem(&mut self, v: impl Value) -> stream::Result{\n        self.0.seq_elem(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::seq_elem_begin":["/**\n    Begin a sequence element.\n    */\n#[inline]\npub fn seq_elem_begin(&mut self) -> Result<&mut Self, Error>{\n        self.0.seq_elem_begin()?;\n\n        Ok(self)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::seq_end":["/**\n    End a sequence.\n    */\n#[inline]\npub fn seq_end(&mut self) -> stream::Result{\n        self.0.seq_end()\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::str":["/**\n    Stream a UTF8 string.\n    */\n#[inline]\npub fn str(&mut self, v: &str) -> stream::Result{\n        self.0.str(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::u128":["/**\n    Stream a 128-bit unsigned integer.\n    */\n#[inline]\npub fn u128(&mut self, v: u128) -> stream::Result{\n        self.0.u128(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::owned::RefMutStream::<'a>::u64":["/**\n    Stream an unsigned integer.\n    */\n#[inline]\npub fn u64(&mut self, v: u64) -> stream::Result{\n        self.0.u64(v)\n    }","Real(LocalPath(\"src/stream/owned.rs\"))"],"stream::stack::Depth":["/**\nThe depth of a position.\n\nAll positions within a map or sequence are guaranteed\nto have the same depth or greater.\n*/\npub struct Depth(usize);","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Expecting":["/**\nA container for an unmatched expectation.\n*/\nstruct Expecting {\n    got: &'static str,\n    expecting: &'static str,\n}","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Pos":["/**\nThe expected position in the stream.\n*/\npub struct Pos {\n    slot: u8,\n    depth: usize,\n}","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Pos::depth":["/**\n    The depth of this position.\n    */\n#[inline]\npub fn depth(&self) -> Depth{\n        Depth(self.depth)\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Pos::is_elem":["/**\n    Whether the current position is a sequence element.\n    */\n#[inline]\npub fn is_elem(&self) -> bool{\n        self.slot & Slot::MASK_POS == Slot::ELEM\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Pos::is_empty_map":["/**\n    Whether the current position is an empty map.\n    */\n#[inline]\npub fn is_empty_map(&self) -> bool{\n        self.slot == Slot::MAP_DONE\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Pos::is_empty_seq":["/**\n    Whether the current position is an empty sequence.\n    */\n#[inline]\npub fn is_empty_seq(&self) -> bool{\n        self.slot == Slot::SEQ_DONE\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Pos::is_key":["/**\n    Whether the current position is a map key.\n    */\n#[inline]\npub fn is_key(&self) -> bool{\n        self.slot & Slot::MASK_POS == Slot::KEY\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Pos::is_value":["/**\n    Whether the current position is a map value.\n    */\n#[inline]\npub fn is_value(&self) -> bool{\n        self.slot & Slot::MASK_POS == Slot::VAL\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Slot":["struct Slot(u8);","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Slot::pos":["#[inline]\nfn pos(self, depth: usize) -> Pos{\n        Pos {\n            slot: self.0,\n            depth,\n        }\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Slot::root":["#[inline]\nfn root() -> Self{\n        Slot(Slot::ROOT)\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack":["/**\nA container for the stream state.\n\nImplementations of the [`Stream`](../trait.Stream.html) trait are encouraged to use a\nstack for validating their input.\n\nThe stack is stateful, and keeps track of open maps and sequences.\n\n# Validation\n\nA stack uses its state to validate the structure given to a stream and\nas a way for a flat, stateless stream to know what it's currently\nlooking at. The stack enforces:\n\n- Only a single root primitive, map or sequence is received.\n- Map keys and values are only received within a map.\n- Map keys are always received before map values, and every key has a corresponding value.\n- Sequence elements are only received within a sequence.\n- Every map and sequence is ended, and in the right order.\n- Every map key, map value, and sequence element is followed by valid data.\n\n# Depth\n\nBy default, stacks have a fixed depth (currently ~16, but this may change) so they can\nwork in no-std environments. Each call to `map_begin` or `seq_begin` will increase the\ncurrent depth. If this depth is exceeded then calls to `map_begin` or `seq_begin` will fail.\n\nThe fixed-depth limit can be removed by adding the `arbitrary-depth` feature to your `Cargo.toml`\n(this also requires the standard library):\n\n```toml,no_run\n[dependencies.sval]\nfeatures = [\"arbitrary-depth\"]\n```\n*/\npub struct Stack {\n    inner: inner::Stack,\n}","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::can_end":["/**\n    Whether or not the stack has seen a complete and valid stream.\n    */\n#[inline]\npub fn can_end(&self) -> bool{\n        self.inner.depth() == 0\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::clear":["/**\n    Clear the stack so that it can be re-used.\n\n    Any state it currently contains will be lost.\n    */\n#[inline]\npub fn clear(&mut self){\n        self.inner.clear();\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::current":["/**\n    Get the current position in the stack.\n    */\n#[inline]\npub fn current(&self) -> Pos{\n        self.inner.current().pos(self.inner.depth())\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::end":["/**\n    Complete the stack.\n\n    This stack may be re-used after being completed\n    by calling `begin`.\n    */\n#[inline]\npub fn end(&mut self) -> Result<(), Error>{\n        // The stack must be on the root slot\n        // It doesn't matter if the slot is\n        // marked as done or not\n\n        if self.inner.depth() == 0 {\n            // Set the slot to done so it\n            // can't be re-used without calling begin\n            self.inner.current_mut().0 |= Slot::DONE;\n\n            Ok(())\n        } else {\n            Err(Error::msg(\"stack is not empty\"))\n        }\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::map_begin":["/**\n    Begin a new map.\n\n    The map must be completed by calling `map_end`.\n    */\n#[inline]\npub fn map_begin(&mut self) -> Result<Pos, Error>{\n        let curr = self.inner.current();\n\n        // The current slot must:\n        // - not be done and\n        // - be the root or\n        // - be a map key or\n        // - be a map value or\n        // - be a seq element\n\n        match curr.0 {\n            Slot::ROOT | Slot::MAP_KEY | Slot::MAP_VAL | Slot::SEQ_ELEM => {\n                self.inner.push_depth()?;\n                self.inner.current_mut().0 = Slot::MAP_DONE;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(curr, \"map begin\"))),\n        }\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::map_begin::expecting":["fn expecting(slot: Slot) -> &'static dyn fmt::Display{\n            match slot.0 {\n                Slot::ROOT | Slot::SEQ_ELEM | Slot::MAP_KEY | Slot::MAP_VAL => &Expecting {\n                    got: $got,\n                    expecting: \"a primitive, map begin or seq begin\",\n                },\n                Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a seq elem or seq end\",\n                },\n                Slot::MAP_DONE | Slot::MAP_VAL_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map key or map done\",\n                },\n                Slot::MAP_KEY_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map value\",\n                },\n                slot if slot & Slot::DONE == Slot::DONE => &Expecting {\n                    got: $got,\n                    expecting: \"nothing\",\n                },\n                _ => unreachable!(),\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::map_end":["/**\n    Complete the current map.\n    */\n#[inline]\npub fn map_end(&mut self) -> Result<Pos, Error>{\n        let curr = self.inner.current();\n\n        // The current slot must:\n        // - be a fresh map or\n        // - be a map with a done value\n\n        match curr.0 {\n            Slot::MAP_DONE | Slot::MAP_VAL_DONE => {\n                // The fact that the slot is not `Slot::ROOT`\n                // guarantees that `depth > 0` and so this\n                // will not overflow\n                unsafe {\n                    self.inner.pop_depth();\n                }\n\n                let mut curr = self.inner.current_mut();\n                curr.0 |= Slot::DONE;\n\n                Ok(curr.pos(self.inner.depth() + 1))\n            }\n            _ => Err(Error::custom(expecting!(curr, \"map end\"))),\n        }\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::map_end::expecting":["fn expecting(slot: Slot) -> &'static dyn fmt::Display{\n            match slot.0 {\n                Slot::ROOT | Slot::SEQ_ELEM | Slot::MAP_KEY | Slot::MAP_VAL => &Expecting {\n                    got: $got,\n                    expecting: \"a primitive, map begin or seq begin\",\n                },\n                Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a seq elem or seq end\",\n                },\n                Slot::MAP_DONE | Slot::MAP_VAL_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map key or map done\",\n                },\n                Slot::MAP_KEY_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map value\",\n                },\n                slot if slot & Slot::DONE == Slot::DONE => &Expecting {\n                    got: $got,\n                    expecting: \"nothing\",\n                },\n                _ => unreachable!(),\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::map_key":["/**\n    Begin a map key.\n\n    The key will be implicitly completed by the value\n    that follows it.\n    */\n#[inline]\npub fn map_key(&mut self) -> Result<Pos, Error>{\n        let mut curr = self.inner.current_mut();\n\n        // The current slot must:\n        // - be a fresh map (with no key or value) or\n        // - be a map with a done value\n\n        match curr.0 {\n            Slot::MAP_DONE | Slot::MAP_VAL_DONE => {\n                curr.0 = Slot::MAP_KEY;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(*curr, \"map key\"))),\n        }\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::map_key::expecting":["fn expecting(slot: Slot) -> &'static dyn fmt::Display{\n            match slot.0 {\n                Slot::ROOT | Slot::SEQ_ELEM | Slot::MAP_KEY | Slot::MAP_VAL => &Expecting {\n                    got: $got,\n                    expecting: \"a primitive, map begin or seq begin\",\n                },\n                Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a seq elem or seq end\",\n                },\n                Slot::MAP_DONE | Slot::MAP_VAL_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map key or map done\",\n                },\n                Slot::MAP_KEY_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map value\",\n                },\n                slot if slot & Slot::DONE == Slot::DONE => &Expecting {\n                    got: $got,\n                    expecting: \"nothing\",\n                },\n                _ => unreachable!(),\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::map_value":["/**\n    Begin a map value.\n\n    The value will be implicitly completed by the value\n    that follows it.\n    */\n#[inline]\npub fn map_value(&mut self) -> Result<Pos, Error>{\n        let mut curr = self.inner.current_mut();\n\n        // The current slot must:\n        // - be a map with a done key\n\n        match curr.0 {\n            Slot::MAP_KEY_DONE => {\n                curr.0 = Slot::MAP_VAL;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(*curr, \"map value\"))),\n        }\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::map_value::expecting":["fn expecting(slot: Slot) -> &'static dyn fmt::Display{\n            match slot.0 {\n                Slot::ROOT | Slot::SEQ_ELEM | Slot::MAP_KEY | Slot::MAP_VAL => &Expecting {\n                    got: $got,\n                    expecting: \"a primitive, map begin or seq begin\",\n                },\n                Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a seq elem or seq end\",\n                },\n                Slot::MAP_DONE | Slot::MAP_VAL_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map key or map done\",\n                },\n                Slot::MAP_KEY_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map value\",\n                },\n                slot if slot & Slot::DONE == Slot::DONE => &Expecting {\n                    got: $got,\n                    expecting: \"nothing\",\n                },\n                _ => unreachable!(),\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::new":["/**\n    Create a new stack.\n    */\n#[inline]\npub fn new() -> Self{\n        Stack {\n            inner: inner::Stack::new(),\n        }\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::primitive":["/**\n    Push a primitive.\n\n    A primitive is a simple value that isn't a map or sequence.\n    That includes:\n\n    - [`Arguments`](struct.Arguments.html)\n    - `u64`, `i64`, `u128`, `i128`\n    - `f64`\n    - `bool`\n    - `char`, `&str`\n    - `Option<T>`.\n    */\n#[inline]\npub fn primitive(&mut self) -> Result<Pos, Error>{\n        let mut curr = self.inner.current_mut();\n\n        // The current slot must:\n        // - not be done\n\n        match curr.0 & Slot::DONE {\n            Slot::EMPTY => {\n                curr.0 |= Slot::DONE;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(*curr, \"primitive\"))),\n        }\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::primitive::expecting":["fn expecting(slot: Slot) -> &'static dyn fmt::Display{\n            match slot.0 {\n                Slot::ROOT | Slot::SEQ_ELEM | Slot::MAP_KEY | Slot::MAP_VAL => &Expecting {\n                    got: $got,\n                    expecting: \"a primitive, map begin or seq begin\",\n                },\n                Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a seq elem or seq end\",\n                },\n                Slot::MAP_DONE | Slot::MAP_VAL_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map key or map done\",\n                },\n                Slot::MAP_KEY_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map value\",\n                },\n                slot if slot & Slot::DONE == Slot::DONE => &Expecting {\n                    got: $got,\n                    expecting: \"nothing\",\n                },\n                _ => unreachable!(),\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::seq_begin":["/**\n    Begin a new sequence.\n\n    the sequence must be completed by calling `seq_end`.\n    */\n#[inline]\npub fn seq_begin(&mut self) -> Result<Pos, Error>{\n        let curr = self.inner.current();\n\n        // The current slot must:\n        // - not be done and\n        // - be the root or\n        // - be a map key or\n        // - be a map value or\n        // - be a seq element\n\n        match curr.0 {\n            Slot::ROOT | Slot::MAP_KEY | Slot::MAP_VAL | Slot::SEQ_ELEM => {\n                self.inner.push_depth()?;\n                self.inner.current_mut().0 = Slot::SEQ_DONE;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(curr, \"seq begin\"))),\n        }\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::seq_begin::expecting":["fn expecting(slot: Slot) -> &'static dyn fmt::Display{\n            match slot.0 {\n                Slot::ROOT | Slot::SEQ_ELEM | Slot::MAP_KEY | Slot::MAP_VAL => &Expecting {\n                    got: $got,\n                    expecting: \"a primitive, map begin or seq begin\",\n                },\n                Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a seq elem or seq end\",\n                },\n                Slot::MAP_DONE | Slot::MAP_VAL_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map key or map done\",\n                },\n                Slot::MAP_KEY_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map value\",\n                },\n                slot if slot & Slot::DONE == Slot::DONE => &Expecting {\n                    got: $got,\n                    expecting: \"nothing\",\n                },\n                _ => unreachable!(),\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::seq_elem":["/**\n    Begin a sequence element.\n\n    The element will be implicitly completed by the value\n    that follows it.\n    */\n#[inline]\npub fn seq_elem(&mut self) -> Result<Pos, Error>{\n        let mut curr = self.inner.current_mut();\n\n        // The current slot must:\n        // - be a fresh sequence (with no element) or\n        // - be a sequence with a done element\n\n        match curr.0 {\n            Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => {\n                curr.0 = Slot::SEQ_ELEM;\n\n                Ok(curr.pos(self.inner.depth()))\n            }\n            _ => Err(Error::custom(expecting!(*curr, \"seq elem\"))),\n        }\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::seq_elem::expecting":["fn expecting(slot: Slot) -> &'static dyn fmt::Display{\n            match slot.0 {\n                Slot::ROOT | Slot::SEQ_ELEM | Slot::MAP_KEY | Slot::MAP_VAL => &Expecting {\n                    got: $got,\n                    expecting: \"a primitive, map begin or seq begin\",\n                },\n                Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a seq elem or seq end\",\n                },\n                Slot::MAP_DONE | Slot::MAP_VAL_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map key or map done\",\n                },\n                Slot::MAP_KEY_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map value\",\n                },\n                slot if slot & Slot::DONE == Slot::DONE => &Expecting {\n                    got: $got,\n                    expecting: \"nothing\",\n                },\n                _ => unreachable!(),\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::seq_end":["/**\n    Complete the current sequence.\n    */\n#[inline]\npub fn seq_end(&mut self) -> Result<Pos, Error>{\n        let curr = self.inner.current();\n\n        // The current slot must:\n        // - be a fresh sequence or\n        // - be a sequence with a done element\n\n        match curr.0 {\n            Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => {\n                // The fact that the slot is not `Slot::ROOT`\n                // guarantees that `depth > 0` and so this\n                // will not overflow\n                unsafe {\n                    self.inner.pop_depth();\n                }\n\n                let mut curr = self.inner.current_mut();\n                curr.0 |= Slot::DONE;\n\n                Ok(curr.pos(self.inner.depth() + 1))\n            }\n            _ => Err(Error::custom(expecting!(curr, \"seq end\"))),\n        }\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::Stack::seq_end::expecting":["fn expecting(slot: Slot) -> &'static dyn fmt::Display{\n            match slot.0 {\n                Slot::ROOT | Slot::SEQ_ELEM | Slot::MAP_KEY | Slot::MAP_VAL => &Expecting {\n                    got: $got,\n                    expecting: \"a primitive, map begin or seq begin\",\n                },\n                Slot::SEQ_DONE | Slot::SEQ_ELEM_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a seq elem or seq end\",\n                },\n                Slot::MAP_DONE | Slot::MAP_VAL_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map key or map done\",\n                },\n                Slot::MAP_KEY_DONE => &Expecting {\n                    got: $got,\n                    expecting: \"a map value\",\n                },\n                slot if slot & Slot::DONE == Slot::DONE => &Expecting {\n                    got: $got,\n                    expecting: \"nothing\",\n                },\n                _ => unreachable!(),\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::inner::Stack":["pub(super) struct Stack {\n        slots: [Slot; Stack::SLOTS],\n        depth: usize,\n    }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::inner::Stack::clear":["#[inline]\npub(super) fn clear(&mut self){\n            *self = Stack {\n                slots: [Slot::root(); Self::SLOTS],\n                depth: 0,\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::inner::Stack::current":["#[inline]\npub(super) fn current(&self) -> Slot{\n            #[cfg(debug_assertions)]\n            {\n                *self.slots.get(self.depth).expect(\"depth out of bounds\")\n            }\n            #[cfg(not(debug_assertions))]\n            {\n                // The depth is guaranteed to be in-bounds\n                // and pointing to initialized memory\n                unsafe { *self.slots.get_unchecked(self.depth) }\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::inner::Stack::current_mut":["#[inline]\npub(super) fn current_mut(&mut self) -> &mut Slot{\n            #[cfg(debug_assertions)]\n            {\n                self.slots.get_mut(self.depth).expect(\"depth out of bounds\")\n            }\n            #[cfg(not(debug_assertions))]\n            {\n                // The depth is guaranteed to be in-bounds\n                // and pointing to initialized memory\n                unsafe { self.slots.get_unchecked_mut(self.depth) }\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::inner::Stack::depth":["#[inline]\npub(super) fn depth(&self) -> usize{\n            self.depth\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::inner::Stack::new":["#[inline]\npub(super) fn new() -> Self{\n            Stack {\n                slots: [Slot::root(); Self::SLOTS],\n                depth: 0,\n            }\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::inner::Stack::pop_depth":["#[inline]\npub(super) unsafe fn pop_depth(&mut self){\n            self.depth -= 1;\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"stream::stack::inner::Stack::push_depth":["#[inline]\npub(super) fn push_depth(&mut self) -> Result<(), Error>{\n            if self.depth >= Self::MAX_DEPTH {\n                return Err(Error::msg(\"nesting limit reached\"));\n            }\n\n            self.depth += 1;\n\n            Ok(())\n        }","Real(LocalPath(\"src/stream/stack.rs\"))"],"value::Value":["/**\nA value with a streamable structure.\n\n# Implementing `Value`\n\nImplementations of `Value` are expected to conform to the following\nmodel:\n\n## Only a single primitive, map or sequence is streamed\n\nThe following `Value` is valid:\n\n```\n# use sval::value::{self, Value};\n# struct MyValue;\nimpl Value for MyValue {\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        // VALID: The stream can take the primitive\n        // value 42\n        stream.any(42)\n    }\n}\n```\n\nThe following `Value` is not valid:\n\n```\n# use sval::value::{self, Value};\n# struct MyValue;\nimpl Value for MyValue {\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        stream.any(42)?;\n\n        // INVALID: The stream already received the\n        // primitive value 42\n        stream.any(43)\n    }\n}\n```\n\n## All maps and sequences are completed, and in the right order\n\nThe following `Value` is valid:\n\n```\n# use sval::value::{self, Value};\n# struct MyValue;\nimpl Value for MyValue {\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        stream.map_begin(None)?;\n        stream.map_key(\"a\")?;\n        stream.map_value_begin()?.seq_begin(None)?;\n\n        // VALID: The sequence is completed, then the map is completed\n        stream.seq_end()?;\n        stream.map_end()\n    }\n}\n```\n\nThe following `Value` is not valid:\n\n```\n# use sval::value::{self, Value};\n# struct MyValue;\nimpl Value for MyValue {\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        stream.map_begin(None)?;\n        stream.map_key(\"a\")?;\n        stream.map_value_begin()?.seq_begin(None)?;\n\n        // INVALID: The map is completed before the sequence,\n        // even though the sequence was started last.\n        stream.map_end()?;\n        stream.seq_end()\n    }\n}\n```\n\nThe following `Value` is not valid:\n\n```\n# use sval::value::{self, Value};\n# struct MyValue;\nimpl Value for MyValue {\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        stream.map_begin(None)?;\n\n        // INVALID: The map is never completed\n        Ok(())\n    }\n}\n```\n\n## Map keys and values are received before their corresponding structure\n\nThe following `Value` is valid:\n\n```\n# use sval::value::{self, Value};\n# struct MyValue;\nimpl Value for MyValue {\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        stream.map_begin(None)?;\n\n        // VALID: The `map_key` and `map_value` methods\n        // always call the underlying stream correctly\n        stream.map_key(\"a\")?;\n        stream.map_value(\"b\")?;\n\n        // VALID: `map_key` and `map_value` are called before\n        // their actual values are given\n        stream.map_key_begin()?.any(\"c\")?;\n        stream.map_value_begin()?.any(\"d\")?;\n\n        stream.map_end()\n    }\n}\n```\n\nThe following `Value` is not valid:\n\n```\n# use sval::value::{self, Value};\n# struct MyValue;\nimpl Value for MyValue {\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        stream.map_begin(None)?;\n\n        // INVALID: The underlying `map_key` and `map_value` methods\n        // aren't being called before their actual values are given\n        stream.any(\"a\")?;\n        stream.any(\"b\")?;\n\n        stream.map_end()\n    }\n}\n```\n\n## Map keys are received before values\n\nThe following `Value` is valid:\n\n```\n# use sval::value::{self, Value};\n# struct MyValue;\nimpl Value for MyValue {\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        stream.map_begin(None)?;\n\n        // VALID: The key is streamed before the value\n        stream.map_key(\"a\")?;\n        stream.map_value(\"b\")?;\n\n        stream.map_end()\n    }\n}\n```\n\nThe following `Value` is not valid:\n\n```\n# use sval::value::{self, Value};\n# struct MyValue;\nimpl Value for MyValue {\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        stream.map_begin(None)?;\n\n        // INVALID: The value is streamed before the key\n        stream.map_value(\"b\")?;\n        stream.map_key(\"a\")?;\n\n        stream.map_end()\n    }\n}\n```\n\n## Sequence elements are received before their corresponding structure\n\nThe following `Value` is valid:\n\n```\n# use sval::value::{self, Value};\n# struct MyValue;\nimpl Value for MyValue {\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        stream.seq_begin(None)?;\n\n        // VALID: The `seq_elem` method\n        // always calls the underlying stream correctly\n        stream.seq_elem(\"a\")?;\n\n        // VALID: `seq_elem` is called before\n        // their actual values are given\n        stream.seq_elem_begin()?.any(\"b\")?;\n\n        stream.seq_end()\n    }\n}\n```\n\nThe following `Value` is not valid:\n\n```\n# use sval::value::{self, Value};\n# struct MyValue;\nimpl Value for MyValue {\n    fn stream(&self, stream: &mut value::Stream) -> value::Result {\n        stream.seq_begin(None)?;\n\n        // INVALID: The underlying `seq_elem` method\n        // isn't being called before the actual value is given\n        stream.any(\"a\")?;\n\n        stream.seq_end()\n    }\n}\n```\n*/\npub trait Value {\n    /**\n    Stream this value.\n\n    # Examples\n\n    Use a [`stream::OwnedStream`] to stream a value:\n\n    ```no_run\n    # #[cfg(not(feature = \"std\"))]\n    # fn main() {}\n    # #[cfg(feature = \"std\")]\n    # fn main() -> Result<(), Box<dyn std::error::Error>> {\n    use sval::stream::OwnedStream;\n\n    let mut stream = OwnedStream::new(MyStream);\n    stream.any(42)?;\n    # Ok(())\n    # }\n    # use sval::stream::{self, Stream};\n    # struct MyStream;\n    # impl Stream for MyStream {\n    #     fn fmt(&mut self, _: stream::Arguments) -> stream::Result { unimplemented!() }\n    # }\n    ```\n\n    It's less convenient, but the `stream` method can be called directly\n    instead of using `OwnedStream.any`:\n\n    ```no_run\n    # #[cfg(not(feature = \"std\"))]\n    # fn main() {}\n    # #[cfg(feature = \"std\")]\n    # fn main() -> Result<(), Box<dyn std::error::Error>> {\n    use sval::{\n        stream::OwnedStream,\n        Value,\n    };\n\n    let mut stream = OwnedStream::new(MyStream);\n    42.stream(&mut stream.borrow_mut())?;\n    # Ok(())\n    # }\n    # use sval::stream::{self, Stream};\n    # struct MyStream;\n    # impl Stream for MyStream {\n    #     fn fmt(&mut self, _: stream::Arguments) -> stream::Result { unimplemented!() }\n    # }\n    ```\n\n    [`sval::stream`]: ../fn.stream.html\n    [`stream::OwnedStream`]: ../stream/struct.OwnedStream.html\n    */\n    fn stream(&self, stream: &mut Stream) -> Result;\n}","Real(LocalPath(\"src/value/mod.rs\"))"],"value::impls::<impl value::Value for ()>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.none()\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for (T, U)>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.seq_begin(Some(2))?;\n\n        stream.seq_elem(&self.0)?;\n        stream.seq_elem(&self.1)?;\n\n        stream.seq_end()\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for [T]>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.seq_begin(Some(self.len()))?;\n\n        for v in self {\n            stream.seq_elem(v)?;\n        }\n\n        stream.seq_end()\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for bool>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.bool(*self)\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for char>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.char(*self)\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for core::fmt::Arguments<'a>>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.fmt(*self)\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for core::option::Option<T>>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        match self {\n            Some(v) => stream.any(v),\n            None => stream.none(),\n        }\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for f32>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.f64(f64::from(*self))\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for f64>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.f64(*self)\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for i128>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.i128(*self)\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for i16>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.i64(i64::from(*self))\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for i32>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.i64(i64::from(*self))\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for i64>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.i64(*self)\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for i8>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.i64(i64::from(*self))\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for str>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.str(self)\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for u128>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.u128(*self)\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for u16>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.u64(u64::from(*self))\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for u32>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.u64(u64::from(*self))\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for u64>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.u64(*self)\n    }","Real(LocalPath(\"src/value/impls.rs\"))"],"value::impls::<impl value::Value for u8>::stream":["#[inline]\nfn stream(&self, stream: &mut value::Stream) -> value::Result{\n        stream.u64(u64::from(*self))\n    }","Real(LocalPath(\"src/value/impls.rs\"))"]},"struct_constructor":{"&'static (dyn core::fmt::Display + 'static)":["expecting"],"&mut stream::stack::Slot":["current_mut"],"bool":["can_end","eq","is_default_unsupported","is_elem","is_empty_map","is_empty_seq","is_key","is_unsupported","is_value"],"collect::owned::OwnedCollect":["new"],"collect::owned::RefMutCollect":["borrow_mut"],"collect::value::Value":["new"],"core::cmp::Ordering":["cmp"],"core::fmt::Error":["from"],"core::option::Option":["partial_cmp"],"core::result::Result":["any","bool","char","end","f64","fmt","i128","i64","map_begin","map_end","map_key","map_key_begin","map_key_collect","map_value","map_value_begin","map_value_collect","none","primitive","push_depth","seq_begin","seq_elem","seq_elem_begin","seq_elem_collect","seq_end","str","stream","u128","u64"],"error::Error":["clone","custom","default_unsupported","from","msg","unsupported"],"error::ErrorInner":["clone"],"stream::owned::OwnedStream":["new"],"stream::owned::RefMutStream":["borrow_mut","new"],"stream::stack::Depth":["clone","depth"],"stream::stack::Pos":["clone","current","pos"],"stream::stack::Slot":["clone","current","root"],"stream::stack::Stack":["clone","default","new"],"stream::stack::inner::Stack":["clone","new"],"usize":["depth"]},"struct_to_trait":{"collect::Default":["collect::Collect","stream::Stream"],"core::fmt::Arguments":["value::Value"],"core::fmt::Error":["core::convert::From"],"core::option::Option":["value::Value"],"error::Error":["core::clone::Clone","core::convert::From","core::fmt::Debug","core::fmt::Display"],"error::ErrorInner":["core::clone::Clone","core::fmt::Debug","core::fmt::Display"],"stream::owned::OwnedStream":["stream::Stream"],"stream::owned::RefMutStream":["stream::Stream"],"stream::stack::Depth":["core::clone::Clone","core::cmp::Eq","core::cmp::Ord","core::cmp::PartialEq","core::cmp::PartialOrd","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"stream::stack::Expecting":["core::fmt::Display"],"stream::stack::Pos":["core::clone::Clone"],"stream::stack::Slot":["core::clone::Clone","core::marker::Copy"],"stream::stack::Stack":["core::clone::Clone","core::default::Default","stream::Stream"],"stream::stack::inner::Stack":["core::clone::Clone"]},"targets":{"<&'a T as value::Value>::stream":["stream","Real(LocalPath(\"src/value/mod.rs\"))","value::Value"],"<&'a mut S as collect::Collect>::map_key_collect":["map_key_collect","Real(LocalPath(\"src/collect/mod.rs\"))","collect::Collect"],"<&'a mut S as collect::Collect>::map_value_collect":["map_value_collect","Real(LocalPath(\"src/collect/mod.rs\"))","collect::Collect"],"<&'a mut S as collect::Collect>::seq_elem_collect":["seq_elem_collect","Real(LocalPath(\"src/collect/mod.rs\"))","collect::Collect"],"<&'a mut T as stream::Stream>::bool":["bool","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::char":["char","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::f64":["f64","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::fmt":["fmt","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::i128":["i128","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::i64":["i64","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::map_begin":["map_begin","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::map_end":["map_end","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::map_key":["map_key","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::map_value":["map_value","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::none":["none","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::seq_begin":["seq_begin","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::seq_elem":["seq_elem","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::seq_end":["seq_end","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::str":["str","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::u128":["u128","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<&'a mut T as stream::Stream>::u64":["u64","Real(LocalPath(\"src/stream/mod.rs\"))","stream::Stream"],"<collect::Default<S> as collect::Collect>::map_key_collect":["map_key_collect","Real(LocalPath(\"src/collect/mod.rs\"))","collect::Collect"],"<collect::Default<S> as collect::Collect>::map_value_collect":["map_value_collect","Real(LocalPath(\"src/collect/mod.rs\"))","collect::Collect"],"<collect::Default<S> as collect::Collect>::seq_elem_collect":["seq_elem_collect","Real(LocalPath(\"src/collect/mod.rs\"))","collect::Collect"],"<collect::Default<S> as stream::Stream>::bool":["bool","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::char":["char","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::f64":["f64","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::fmt":["fmt","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::i128":["i128","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::i64":["i64","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::map_begin":["map_begin","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::map_end":["map_end","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::map_key":["map_key","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::map_value":["map_value","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::none":["none","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::seq_begin":["seq_begin","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::seq_elem":["seq_elem","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::seq_end":["seq_end","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::str":["str","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::u128":["u128","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<collect::Default<S> as stream::Stream>::u64":["u64","Real(LocalPath(\"src/collect/mod.rs\"))","stream::Stream"],"<error::Error as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","core::fmt::Debug"],"<error::Error as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","core::fmt::Display"],"<error::ErrorInner as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","core::fmt::Debug"],"<error::ErrorInner as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","core::fmt::Display"],"<stream::owned::OwnedStream<S> as stream::Stream>::bool":["bool","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::char":["char","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::f64":["f64","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::fmt":["fmt","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::i128":["i128","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::i64":["i64","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_begin":["map_begin","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_end":["map_end","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_key":["map_key","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::map_value":["map_value","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::none":["none","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::seq_begin":["seq_begin","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::seq_elem":["seq_elem","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::seq_end":["seq_end","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::str":["str","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::u128":["u128","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::OwnedStream<S> as stream::Stream>::u64":["u64","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::bool":["bool","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::char":["char","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::f64":["f64","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::fmt":["fmt","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::i128":["i128","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::i64":["i64","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_begin":["map_begin","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_end":["map_end","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_key":["map_key","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::map_value":["map_value","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::none":["none","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::seq_begin":["seq_begin","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::seq_elem":["seq_elem","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::seq_end":["seq_end","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::str":["str","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::u128":["u128","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::owned::RefMutStream<'a> as stream::Stream>::u64":["u64","Real(LocalPath(\"src/stream/owned.rs\"))","stream::Stream"],"<stream::stack::Expecting as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/stream/stack.rs\"))","core::fmt::Display"],"<stream::stack::Stack as core::default::Default>::default":["default","Real(LocalPath(\"src/stream/stack.rs\"))","core::default::Default"],"<stream::stack::Stack as stream::Stream>::bool":["bool","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::char":["char","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::f64":["f64","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::fmt":["fmt","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::i128":["i128","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::i64":["i64","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::map_begin":["map_begin","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::map_end":["map_end","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::map_key":["map_key","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::map_value":["map_value","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::none":["none","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::seq_begin":["seq_begin","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::seq_elem":["seq_elem","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::seq_end":["seq_end","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::str":["str","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::u128":["u128","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"<stream::stack::Stack as stream::Stream>::u64":["u64","Real(LocalPath(\"src/stream/stack.rs\"))","stream::Stream"],"collect::owned::OwnedCollect::<TStream>::any":["any","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::bool":["bool","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::borrow_mut":["borrow_mut","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::char":["char","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::f64":["f64","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::fmt":["fmt","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::i128":["i128","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::i64":["i64","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::into_inner":["into_inner","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::map_begin":["map_begin","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::map_end":["map_end","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::map_key":["map_key","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::map_key_begin":["map_key_begin","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::map_value":["map_value","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::map_value_begin":["map_value_begin","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::new":["new","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::none":["none","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::seq_begin":["seq_begin","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::seq_elem":["seq_elem","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::seq_elem_begin":["seq_elem_begin","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::seq_end":["seq_end","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::str":["str","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::u128":["u128","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::OwnedCollect::<TStream>::u64":["u64","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::any":["any","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::bool":["bool","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::char":["char","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::f64":["f64","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::fmt":["fmt","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::i128":["i128","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::i64":["i64","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::map_begin":["map_begin","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::map_end":["map_end","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::map_key":["map_key","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::map_key_begin":["map_key_begin","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::map_value":["map_value","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::map_value_begin":["map_value_begin","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::none":["none","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::seq_begin":["seq_begin","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::seq_elem":["seq_elem","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::seq_elem_begin":["seq_elem_begin","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::seq_end":["seq_end","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::str":["str","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::u128":["u128","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::owned::RefMutCollect::<'a>::u64":["u64","Real(LocalPath(\"src/collect/owned.rs\"))",""],"collect::value::Value::<'a>::new":["new","Real(LocalPath(\"src/collect/value.rs\"))",""],"collect::value::Value::<'a>::stream":["stream","Real(LocalPath(\"src/collect/value.rs\"))",""],"error::<impl core::convert::From<error::Error> for core::fmt::Error>::from":["from","Real(LocalPath(\"src/error.rs\"))","core::convert::From"],"error::Error::default_unsupported":["default_unsupported","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::is_default_unsupported":["is_default_unsupported","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::is_unsupported":["is_unsupported","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::msg":["msg","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::unsupported":["unsupported","Real(LocalPath(\"src/error.rs\"))",""],"error::no_alloc_support::<impl error::Error>::custom":["custom","Real(LocalPath(\"src/error.rs\"))",""],"error::no_std_support::<impl core::convert::From<core::fmt::Error> for error::Error>::from":["from","Real(LocalPath(\"src/error.rs\"))","core::convert::From"],"stream":["stream","Real(LocalPath(\"src/lib.rs\"))",""],"stream::Stream::bool":["bool","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::char":["char","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::f64":["f64","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::fmt":["fmt","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::i128":["i128","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::i64":["i64","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::map_begin":["map_begin","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::map_end":["map_end","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::map_key":["map_key","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::map_value":["map_value","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::none":["none","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::seq_begin":["seq_begin","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::seq_elem":["seq_elem","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::seq_end":["seq_end","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::str":["str","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::u128":["u128","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::Stream::u64":["u64","Real(LocalPath(\"src/stream/mod.rs\"))",""],"stream::owned::OwnedStream::<S>::any":["any","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::bool":["bool","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::borrow_mut":["borrow_mut","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::char":["char","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::f64":["f64","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::fmt":["fmt","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::i128":["i128","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::i64":["i64","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::into_inner":["into_inner","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::map_begin":["map_begin","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::map_end":["map_end","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::map_key":["map_key","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::map_key_begin":["map_key_begin","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::map_value":["map_value","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::map_value_begin":["map_value_begin","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::new":["new","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::none":["none","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::seq_begin":["seq_begin","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::seq_elem":["seq_elem","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::seq_elem_begin":["seq_elem_begin","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::seq_end":["seq_end","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::str":["str","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::stream":["stream","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::u128":["u128","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::OwnedStream::<S>::u64":["u64","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::any":["any","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::bool":["bool","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::char":["char","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::f64":["f64","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::fmt":["fmt","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::i128":["i128","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::i64":["i64","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::map_begin":["map_begin","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::map_end":["map_end","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::map_key":["map_key","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::map_key_begin":["map_key_begin","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::map_value":["map_value","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::map_value_begin":["map_value_begin","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::new":["new","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::none":["none","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::seq_begin":["seq_begin","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::seq_elem":["seq_elem","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::seq_elem_begin":["seq_elem_begin","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::seq_end":["seq_end","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::str":["str","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::u128":["u128","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::owned::RefMutStream::<'a>::u64":["u64","Real(LocalPath(\"src/stream/owned.rs\"))",""],"stream::stack::Pos::depth":["depth","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Pos::is_elem":["is_elem","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Pos::is_empty_map":["is_empty_map","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Pos::is_empty_seq":["is_empty_seq","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Pos::is_key":["is_key","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Pos::is_value":["is_value","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Slot::pos":["pos","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Slot::root":["root","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::can_end":["can_end","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::clear":["clear","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::current":["current","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::end":["end","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::map_begin":["map_begin","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::map_begin::expecting":["expecting","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::map_end":["map_end","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::map_end::expecting":["expecting","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::map_key":["map_key","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::map_key::expecting":["expecting","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::map_value":["map_value","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::map_value::expecting":["expecting","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::new":["new","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::primitive":["primitive","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::primitive::expecting":["expecting","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::seq_begin":["seq_begin","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::seq_begin::expecting":["expecting","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::seq_elem":["seq_elem","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::seq_elem::expecting":["expecting","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::seq_end":["seq_end","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::Stack::seq_end::expecting":["expecting","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::inner::Stack::clear":["clear","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::inner::Stack::current":["current","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::inner::Stack::current_mut":["current_mut","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::inner::Stack::depth":["depth","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::inner::Stack::new":["new","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::inner::Stack::pop_depth":["pop_depth","Real(LocalPath(\"src/stream/stack.rs\"))",""],"stream::stack::inner::Stack::push_depth":["push_depth","Real(LocalPath(\"src/stream/stack.rs\"))",""],"value::impls::<impl value::Value for ()>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for (T, U)>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for [T]>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for bool>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for char>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for core::fmt::Arguments<'a>>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for core::option::Option<T>>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for f32>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for f64>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for i128>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for i16>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for i32>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for i64>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for i8>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for str>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for u128>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for u16>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for u32>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for u64>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"],"value::impls::<impl value::Value for u8>::stream":["stream","Real(LocalPath(\"src/value/impls.rs\"))","value::Value"]},"trait_to_struct":{"collect::Collect":["collect::Default"],"core::clone::Clone":["error::Error","error::ErrorInner","stream::stack::Depth","stream::stack::Pos","stream::stack::Slot","stream::stack::Stack","stream::stack::inner::Stack"],"core::cmp::Eq":["stream::stack::Depth"],"core::cmp::Ord":["stream::stack::Depth"],"core::cmp::PartialEq":["stream::stack::Depth"],"core::cmp::PartialOrd":["stream::stack::Depth"],"core::convert::From":["core::fmt::Error","error::Error"],"core::default::Default":["stream::stack::Stack"],"core::fmt::Debug":["error::Error","error::ErrorInner"],"core::fmt::Display":["error::Error","error::ErrorInner","stream::stack::Expecting"],"core::marker::Copy":["stream::stack::Slot"],"core::marker::StructuralEq":["stream::stack::Depth"],"core::marker::StructuralPartialEq":["stream::stack::Depth"],"stream::Stream":["collect::Default","stream::owned::OwnedStream","stream::owned::RefMutStream","stream::stack::Stack"],"value::Value":["core::fmt::Arguments","core::option::Option"]},"type_to_def_path":{"collect::Default<S>":"collect::Default","collect::owned::OwnedCollect<TStream>":"collect::owned::OwnedCollect","collect::owned::RefMutCollect<'a>":"collect::owned::RefMutCollect","collect::value::Value<'a>":"collect::value::Value","error::Error":"error::Error","error::ErrorInner":"error::ErrorInner","stream::owned::OwnedStream<S>":"stream::owned::OwnedStream","stream::owned::RefMutStream<'a>":"stream::owned::RefMutStream","stream::stack::Depth":"stream::stack::Depth","stream::stack::Expecting":"stream::stack::Expecting","stream::stack::Pos":"stream::stack::Pos","stream::stack::Slot":"stream::stack::Slot","stream::stack::Stack":"stream::stack::Stack","stream::stack::inner::Stack":"stream::stack::inner::Stack"}}