{"dependencies":{"<&'a (Ix, Ix) as IntoWeightedEdge<E>>::into_weighted_edge":[],"<&'a (Ix, Ix, E) as IntoWeightedEdge<E>>::into_weighted_edge":[],"<&'a G as data::DataMap>::edge_weight":["std::marker::Sized","std::option::Option"],"<&'a G as data::DataMap>::node_weight":["std::marker::Sized","std::option::Option"],"<&'a G as visit::GetAdjacencyMatrix>::adjacency_matrix":[],"<&'a G as visit::GetAdjacencyMatrix>::is_adjacent":[],"<&'a G as visit::IntoEdgeReferences>::edge_references":[],"<&'a G as visit::IntoEdges>::edges":[],"<&'a G as visit::IntoEdgesDirected>::edges_directed":["Direction"],"<&'a G as visit::IntoNeighbors>::neighbors":[],"<&'a G as visit::IntoNeighborsDirected>::neighbors_directed":["Direction"],"<&'a G as visit::IntoNodeIdentifiers>::node_identifiers":[],"<&'a G as visit::IntoNodeReferences>::node_references":[],"<&'a G as visit::NodeCount>::node_count":[],"<&'a G as visit::NodeIndexable>::from_index":[],"<&'a G as visit::NodeIndexable>::node_bound":[],"<&'a G as visit::NodeIndexable>::to_index":[],"<&'a G as visit::Visitable>::reset_map":[],"<&'a G as visit::Visitable>::visit_map":[],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoEdgeReferences>::edge_references":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoEdges>::edges":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoNeighbors>::neighbors":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdgeReferences>::edge_references":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdges>::edges":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdgesDirected>::edges_directed":["Direction","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNeighbors>::neighbors":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::Neighbors","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNeighborsDirected>::neighbors_directed":["Direction","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::Neighbors","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["graph_impl::Graph","graph_impl::NodeIndices","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::vec::Vec"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNodeReferences>::node_references":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdgeReferences>::edge_references":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdges>::edges":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdgesDirected>::edges_directed":["Direction","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNeighbors>::neighbors":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNeighborsDirected>::neighbors_directed":["Direction","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNodeReferences>::node_references":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoEdgeReferences>::edge_references":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoEdges>::edges":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNeighbors>::neighbors":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNeighborsDirected>::neighbors_directed":["Direction","graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNodeIdentifiers>::node_identifiers":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNodeReferences>::node_references":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<&'a matrix_graph::MatrixGraph<N, E, Directed, Null, Ix> as visit::IntoNeighborsDirected>::neighbors_directed":["Direction","algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoEdgeReferences>::edge_references":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoEdges>::edges":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNeighbors>::neighbors":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNodeReferences>::node_references":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<&'a mut G as data::DataMap>::edge_weight":["std::marker::Sized","std::option::Option"],"<&'a mut G as data::DataMap>::node_weight":["std::marker::Sized","std::option::Option"],"<&'a mut G as data::DataMapMut>::edge_weight_mut":["std::marker::Sized","std::option::Option"],"<&'a mut G as data::DataMapMut>::node_weight_mut":["std::marker::Sized","std::option::Option"],"<&'a mut W as visit::traversal::Walker<C>>::walk_next":["std::marker::Sized","std::option::Option"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoEdgeReferences>::edge_references":["std::marker::Sized","visit::filter::EdgeFiltered"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoEdges>::edges":["std::marker::Sized","visit::filter::EdgeFiltered"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNeighbors>::neighbors":["std::marker::Sized","visit::filter::EdgeFiltered"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNeighborsDirected>::neighbors_directed":["Direction","std::marker::Sized","visit::filter::EdgeFiltered"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNodeIdentifiers>::node_identifiers":["std::marker::Sized","visit::filter::EdgeFiltered"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNodeReferences>::node_references":["std::marker::Sized","visit::filter::EdgeFiltered"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoEdgeReferences>::edge_references":["std::marker::Sized","visit::filter::NodeFiltered"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoEdges>::edges":["std::marker::Sized","visit::filter::NodeFiltered"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNeighbors>::neighbors":["std::marker::Sized","visit::filter::NodeFiltered"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNeighborsDirected>::neighbors_directed":["Direction","std::marker::Sized","visit::filter::NodeFiltered"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNodeIdentifiers>::node_identifiers":["std::marker::Sized","visit::filter::NodeFiltered"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNodeReferences>::node_references":["std::marker::Sized","visit::filter::NodeFiltered"],"<&fixedbitset::FixedBitSet as visit::filter::FilterNode<N>>::include_node":["fixedbitset::FixedBitSet"],"<&std::collections::HashSet<N, S> as visit::filter::FilterNode<N>>::include_node":["std::collections::HashSet","std::marker::Sized"],"<() as visit::dfsvisit::ControlFlow>::continuing":[],"<() as visit::dfsvisit::ControlFlow>::should_break":[],"<() as visit::dfsvisit::ControlFlow>::should_prune":[],"<(Id, &'a W) as visit::NodeRef>::id":[],"<(Id, &'a W) as visit::NodeRef>::weight":[],"<(Id, ()) as visit::NodeRef>::id":[],"<(Id, ()) as visit::NodeRef>::weight":[],"<(Ix, Ix) as IntoWeightedEdge<E>>::into_weighted_edge":[],"<(Ix, Ix, &'a E) as IntoWeightedEdge<E>>::into_weighted_edge":[],"<(Ix, Ix, E) as IntoWeightedEdge<E>>::into_weighted_edge":[],"<(N, N, &'a E) as visit::EdgeRef>::id":[],"<(N, N, &'a E) as visit::EdgeRef>::source":[],"<(N, N, &'a E) as visit::EdgeRef>::target":[],"<(N, N, &'a E) as visit::EdgeRef>::weight":[],"<Directed as EdgeType>::is_directed":[],"<Directed as std::clone::Clone>::clone":["Directed"],"<Directed as std::fmt::Debug>::fmt":["Directed","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<Direction as std::clone::Clone>::clone":["Direction"],"<Direction as std::cmp::Eq>::assert_receiver_is_total_eq":["Direction"],"<Direction as std::cmp::Ord>::cmp":["Direction","std::cmp::Ordering"],"<Direction as std::cmp::PartialEq>::eq":["Direction"],"<Direction as std::cmp::PartialOrd>::partial_cmp":["Direction","std::marker::Sized","std::option::Option"],"<Direction as std::fmt::Debug>::fmt":["Direction","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<Direction as std::hash::Hash>::hash":["Direction","std::hash::Hasher","std::marker::Sized"],"<F as isomorphism::SemanticMatcher<T>>::enabled":[],"<F as isomorphism::SemanticMatcher<T>>::eq":[],"<F as visit::filter::FilterEdge<N>>::include_edge":[],"<F as visit::filter::FilterNode<N>>::include_node":[],"<Undirected as EdgeType>::is_directed":[],"<Undirected as std::clone::Clone>::clone":["Undirected"],"<Undirected as std::fmt::Debug>::fmt":["Undirected","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<algo::Cycle<N> as std::clone::Clone>::clone":["algo::Cycle","std::marker::Sized"],"<algo::Cycle<N> as std::cmp::PartialEq>::eq":["algo::Cycle","std::marker::Sized"],"<algo::Cycle<N> as std::fmt::Debug>::fmt":["algo::Cycle","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<algo::DfsSpace<N, VM> as std::clone::Clone>::clone":["algo::DfsSpace","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<algo::DfsSpace<N, VM> as std::default::Default>::default":["algo::DfsSpace","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<algo::DfsSpace<N, VM> as std::fmt::Debug>::fmt":["algo::DfsSpace","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","visit::traversal::Dfs"],"<algo::MinSpanningTree<G> as std::iter::Iterator>::next":["Directed","algo::MinSpanningTree","csr::Csr","std::alloc::Allocator","std::clone::Clone","std::collections::BinaryHeap","std::collections::HashMap","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","unionfind::UnionFind","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoNodeIdentifiers","visit::IntoNodeReferences","visit::reversed::Reversed"],"<algo::NegativeCycle as std::clone::Clone>::clone":["algo::NegativeCycle"],"<algo::NegativeCycle as std::cmp::PartialEq>::eq":["algo::NegativeCycle"],"<algo::NegativeCycle as std::fmt::Debug>::fmt":["algo::NegativeCycle","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<algo::dominators::Dominators<N> as std::clone::Clone>::clone":["Directed","Direction","algo::dominators::Dominators","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::Copy","std::marker::Sized"],"<algo::dominators::Dominators<N> as std::fmt::Debug>::fmt":["Directed","Direction","algo::dominators::Dominators","std::cmp::Eq","std::collections::HashMap","std::fmt::Formatter","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::result::Result"],"<algo::dominators::DominatorsIter<'a, N> as std::iter::Iterator>::next":["Directed","Direction","algo::dominators::Dominators","algo::dominators::DominatorsIter","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::option::Option"],"<algo::tarjan_scc::Data<'a, G> as std::fmt::Debug>::fmt":["algo::tarjan_scc::Data","csr::Csr","std::alloc::Allocator","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::vec::Vec","visit::GraphBase","visit::NodeIndexable"],"<algo::tarjan_scc::NodeData as std::clone::Clone>::clone":["algo::tarjan_scc::NodeData","std::marker::Sized","std::option::Option"],"<algo::tarjan_scc::NodeData as std::fmt::Debug>::fmt":["algo::tarjan_scc::NodeData","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<csr::Csr<N, E, Ty, Ix> as std::clone::Clone>::clone":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<csr::Csr<N, E, Ty, Ix> as std::default::Default>::default":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<csr::Csr<N, E, Ty, Ix> as std::fmt::Debug>::fmt":["csr::Csr","std::alloc::Allocator","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::vec::Vec"],"<csr::Csr<N, E, Ty, Ix> as std::ops::Index<Ix>>::index":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<csr::Csr<N, E, Ty, Ix> as std::ops::IndexMut<Ix>>::index_mut":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeCount>::node_count":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeIndexable>::from_index":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeIndexable>::node_bound":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeIndexable>::to_index":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<csr::Csr<N, E, Ty, Ix> as visit::Visitable>::reset_map":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<csr::Csr<N, E, Ty, Ix> as visit::Visitable>::visit_map":["csr::Csr","fixedbitset::FixedBitSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<csr::EdgeReference<'a, E, Ty, Ix> as std::clone::Clone>::clone":["csr::EdgeReference","std::marker::PhantomData","std::marker::Sized"],"<csr::EdgeReference<'a, E, Ty, Ix> as std::fmt::Debug>::fmt":["csr::EdgeReference","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::id":["csr::EdgeReference","std::marker::PhantomData","std::marker::Sized"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::source":["csr::EdgeReference","std::marker::PhantomData","std::marker::Sized"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::target":["csr::EdgeReference","std::marker::PhantomData","std::marker::Sized"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::weight":["csr::EdgeReference","std::marker::PhantomData","std::marker::Sized"],"<csr::EdgeReferences<'a, E, Ty, Ix> as std::iter::Iterator>::next":["csr::EdgeReferences","std::iter::Enumerate","std::iter::Zip","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<csr::Edges<'a, E, Ty, Ix> as std::clone::Clone>::clone":["csr::Edges","std::iter::Zip","std::marker::PhantomData","std::marker::Sized"],"<csr::Edges<'a, E, Ty, Ix> as std::fmt::Debug>::fmt":["csr::Edges","std::fmt::Formatter","std::iter::Zip","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<csr::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::next":["csr::Edges","std::iter::Zip","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<csr::EdgesNotSorted as std::clone::Clone>::clone":["csr::EdgesNotSorted"],"<csr::EdgesNotSorted as std::fmt::Debug>::fmt":["csr::EdgesNotSorted","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<csr::Neighbors<'a, Ix> as std::clone::Clone>::clone":["csr::Neighbors","std::marker::Sized","std::slice::Iter"],"<csr::Neighbors<'a, Ix> as std::fmt::Debug>::fmt":["csr::Neighbors","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::slice::Iter"],"<csr::Neighbors<'a, Ix> as std::iter::Iterator>::next":["csr::Neighbors","std::marker::Sized","std::option::Option","std::slice::Iter"],"<csr::Neighbors<'a, Ix> as std::iter::Iterator>::size_hint":["csr::Neighbors","std::marker::Sized","std::option::Option","std::slice::Iter"],"<csr::NodeIdentifiers<Ix> as std::iter::Iterator>::next":["csr::NodeIdentifiers","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option"],"<csr::NodeIdentifiers<Ix> as std::iter::Iterator>::size_hint":["csr::NodeIdentifiers","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option"],"<data::Element<N, E> as std::clone::Clone>::clone":["data::Element","std::marker::Sized"],"<data::Element<N, E> as std::cmp::Eq>::assert_receiver_is_total_eq":["data::Element","std::marker::Sized"],"<data::Element<N, E> as std::cmp::PartialEq>::eq":["data::Element","std::marker::Sized"],"<data::Element<N, E> as std::fmt::Debug>::fmt":["data::Element","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<data::FilterElements<I, F> as std::iter::Iterator>::next":["data::FilterElements","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<dot::Config as std::cmp::Eq>::assert_receiver_is_total_eq":["dot::Config"],"<dot::Config as std::cmp::PartialEq>::eq":["dot::Config"],"<dot::Config as std::fmt::Debug>::fmt":["dot::Config","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dot::DebugFmt<T> as std::fmt::Display>::fmt":["dot::DebugFmt","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dot::Dot<'a, G> as std::fmt::Debug>::fmt":["Directed","csr::Csr","dot::Config","dot::Dot","std::alloc::Allocator","std::clone::Clone","std::fmt::Formatter","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::vec::Vec","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoNodeIdentifiers","visit::IntoNodeReferences","visit::reversed::Reversed"],"<dot::Dot<'a, G> as std::fmt::Display>::fmt":["Directed","csr::Csr","dot::Config","dot::Dot","std::alloc::Allocator","std::clone::Clone","std::fmt::Formatter","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::vec::Vec","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoNodeIdentifiers","visit::IntoNodeReferences","visit::reversed::Reversed"],"<dot::Escaped<T> as std::fmt::Display>::fmt":["dot::Escaped","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dot::Escaper<W> as std::fmt::Write>::write_char":["dot::Escaper","std::marker::Sized","std::result::Result"],"<dot::Escaper<W> as std::fmt::Write>::write_str":["dot::Escaper","std::marker::Sized","std::result::Result"],"<f32 as algo::FloatMeasure>::infinite":[],"<f32 as algo::FloatMeasure>::zero":[],"<f32 as matrix_graph::Zero>::is_zero":[],"<f32 as matrix_graph::Zero>::zero":[],"<f64 as algo::FloatMeasure>::infinite":[],"<f64 as algo::FloatMeasure>::zero":[],"<f64 as matrix_graph::Zero>::is_zero":[],"<f64 as matrix_graph::Zero>::zero":[],"<fixedbitset::FixedBitSet as visit::VisitMap<Ix>>::is_visited":["fixedbitset::FixedBitSet"],"<fixedbitset::FixedBitSet as visit::VisitMap<Ix>>::visit":["fixedbitset::FixedBitSet"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::EdgeIndex<Ix>>>::is_visited":["fixedbitset::FixedBitSet","graph_impl::EdgeIndex","std::marker::Sized"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::EdgeIndex<Ix>>>::visit":["fixedbitset::FixedBitSet","graph_impl::EdgeIndex","std::marker::Sized"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::NodeIndex<Ix>>>::is_visited":["fixedbitset::FixedBitSet","graph_impl::NodeIndex","std::marker::Sized"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::NodeIndex<Ix>>>::visit":["fixedbitset::FixedBitSet","graph_impl::NodeIndex","std::marker::Sized"],"<fixedbitset::FixedBitSet as visit::filter::FilterNode<N>>::include_node":["fixedbitset::FixedBitSet"],"<graph_impl::Edge<E, Ix> as std::clone::Clone>::clone":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::Edge<E, Ix> as std::fmt::Debug>::fmt":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::NodeIndex","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<graph_impl::EdgeIndex<Ix> as graph_impl::GraphIndex>::index":["graph_impl::EdgeIndex","std::marker::Sized"],"<graph_impl::EdgeIndex<Ix> as graph_impl::GraphIndex>::is_node_index":[],"<graph_impl::EdgeIndex<Ix> as std::clone::Clone>::clone":["graph_impl::EdgeIndex","std::marker::Sized"],"<graph_impl::EdgeIndex<Ix> as std::cmp::Eq>::assert_receiver_is_total_eq":["graph_impl::EdgeIndex","std::marker::Sized"],"<graph_impl::EdgeIndex<Ix> as std::cmp::Ord>::cmp":["graph_impl::EdgeIndex","std::cmp::Ordering","std::marker::Sized"],"<graph_impl::EdgeIndex<Ix> as std::cmp::PartialEq>::eq":["graph_impl::EdgeIndex","std::marker::Sized"],"<graph_impl::EdgeIndex<Ix> as std::cmp::PartialOrd>::partial_cmp":["graph_impl::EdgeIndex","std::marker::Sized","std::option::Option"],"<graph_impl::EdgeIndex<Ix> as std::convert::From<Ix>>::from":["graph_impl::EdgeIndex","std::marker::Sized"],"<graph_impl::EdgeIndex<Ix> as std::default::Default>::default":["graph_impl::EdgeIndex","std::marker::Sized"],"<graph_impl::EdgeIndex<Ix> as std::fmt::Debug>::fmt":["graph_impl::EdgeIndex","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<graph_impl::EdgeIndex<Ix> as std::hash::Hash>::hash":["graph_impl::EdgeIndex","std::hash::Hasher","std::marker::Sized"],"<graph_impl::EdgeIndices<Ix> as std::clone::Clone>::clone":["graph_impl::EdgeIndices","std::marker::PhantomData","std::marker::Sized","std::ops::Range"],"<graph_impl::EdgeIndices<Ix> as std::fmt::Debug>::fmt":["graph_impl::EdgeIndices","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::result::Result"],"<graph_impl::EdgeIndices<Ix> as std::iter::DoubleEndedIterator>::next_back":["graph_impl::EdgeIndices","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option"],"<graph_impl::EdgeIndices<Ix> as std::iter::Iterator>::next":["graph_impl::EdgeIndices","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option"],"<graph_impl::EdgeIndices<Ix> as std::iter::Iterator>::size_hint":["graph_impl::EdgeIndices","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option"],"<graph_impl::EdgeReference<'a, E, Ix> as std::clone::Clone>::clone":["graph_impl::EdgeIndex","graph_impl::EdgeReference","graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::EdgeReference<'a, E, Ix> as std::cmp::PartialEq>::eq":["graph_impl::EdgeIndex","graph_impl::EdgeReference","graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::EdgeReference<'a, E, Ix> as std::fmt::Debug>::fmt":["graph_impl::EdgeIndex","graph_impl::EdgeReference","graph_impl::NodeIndex","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::id":["graph_impl::EdgeIndex","graph_impl::EdgeReference","graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::source":["graph_impl::EdgeIndex","graph_impl::EdgeReference","graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::target":["graph_impl::EdgeIndex","graph_impl::EdgeReference","graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::weight":["graph_impl::EdgeIndex","graph_impl::EdgeReference","graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::EdgeReferences<'a, E, Ix> as std::iter::DoubleEndedIterator>::next_back":["Directed","Direction","algo::DfsSpace","graph_impl::EdgeReferences","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::EdgeReferences<'a, E, Ix> as std::iter::Iterator>::next":["Directed","Direction","algo::DfsSpace","graph_impl::EdgeReferences","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::EdgeReferences<'a, E, Ix> as std::iter::Iterator>::size_hint":["Directed","Direction","algo::DfsSpace","graph_impl::EdgeReferences","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::EdgeWeightsMut<'a, E, Ix> as std::iter::Iterator>::next":["Directed","Direction","algo::DfsSpace","graph_impl::EdgeWeightsMut","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::option::Option","std::slice::IterMut","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::EdgeWeightsMut<'a, E, Ix> as std::iter::Iterator>::size_hint":["Directed","Direction","algo::DfsSpace","graph_impl::EdgeWeightsMut","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::option::Option","std::slice::IterMut","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::Edges<'a, E, Ty, Ix> as std::clone::Clone>::clone":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Edges","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::next":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Edges","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::EdgesConnecting<'a, E, Ty, Ix> as std::iter::Iterator>::next":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Edges","graph_impl::EdgesConnecting","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::Externals<'a, N, Ty, Ix> as std::iter::Iterator>::next":["Directed","Direction","algo::DfsSpace","graph_impl::Externals","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Build>::add_edge":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Build>::add_node":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Build>::update_edge":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Create>::with_capacity":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMap>::edge_weight":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMap>::node_weight":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMapMut>::edge_weight_mut":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMapMut>::node_weight_mut":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as data::FromElements>::from_elements":["graph_impl::Graph","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as std::clone::Clone>::clone":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as std::clone::Clone>::clone_from":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as std::default::Default>::default":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as std::fmt::Debug>::fmt":["graph_impl::Graph","std::alloc::Allocator","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::Index<graph_impl::EdgeIndex<Ix>>>::index":["graph_impl::EdgeIndex","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::Index<graph_impl::NodeIndex<Ix>>>::index":["graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::EdgeIndex<Ix>>>::index_mut":["graph_impl::EdgeIndex","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::NodeIndex<Ix>>>::index_mut":["graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeCount>::node_count":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeIndexable>::from_index":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeIndexable>::node_bound":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeIndexable>::to_index":["graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::Visitable>::reset_map":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::Visitable>::visit_map":["fixedbitset::FixedBitSet","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::Neighbors<'a, E, Ix> as std::clone::Clone>::clone":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Neighbors","graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::Neighbors<'a, E, Ix> as std::iter::Iterator>::next":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Neighbors","graph_impl::NodeIndex","std::marker::Sized","std::option::Option"],"<graph_impl::Node<E, Ix> as std::clone::Clone>::clone":["graph_impl::EdgeIndex","graph_impl::Node","std::marker::Sized"],"<graph_impl::Node<N, Ix> as std::fmt::Debug>::fmt":["graph_impl::EdgeIndex","graph_impl::Node","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<graph_impl::NodeIndex<Ix> as graph_impl::GraphIndex>::index":["graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::NodeIndex<Ix> as graph_impl::GraphIndex>::is_node_index":[],"<graph_impl::NodeIndex<Ix> as std::clone::Clone>::clone":["graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::NodeIndex<Ix> as std::cmp::Eq>::assert_receiver_is_total_eq":["graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::NodeIndex<Ix> as std::cmp::Ord>::cmp":["graph_impl::NodeIndex","std::cmp::Ordering","std::marker::Sized"],"<graph_impl::NodeIndex<Ix> as std::cmp::PartialEq>::eq":["graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::NodeIndex<Ix> as std::cmp::PartialOrd>::partial_cmp":["graph_impl::NodeIndex","std::marker::Sized","std::option::Option"],"<graph_impl::NodeIndex<Ix> as std::convert::From<Ix>>::from":["graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::NodeIndex<Ix> as std::default::Default>::default":["graph_impl::NodeIndex","std::marker::Sized"],"<graph_impl::NodeIndex<Ix> as std::fmt::Debug>::fmt":["graph_impl::NodeIndex","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<graph_impl::NodeIndex<Ix> as std::hash::Hash>::hash":["graph_impl::NodeIndex","std::hash::Hasher","std::marker::Sized"],"<graph_impl::NodeIndices<Ix> as std::clone::Clone>::clone":["graph_impl::NodeIndices","std::marker::PhantomData","std::marker::Sized","std::ops::Range"],"<graph_impl::NodeIndices<Ix> as std::fmt::Debug>::fmt":["graph_impl::NodeIndices","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::result::Result"],"<graph_impl::NodeIndices<Ix> as std::iter::DoubleEndedIterator>::next_back":["graph_impl::NodeIndices","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option"],"<graph_impl::NodeIndices<Ix> as std::iter::Iterator>::next":["graph_impl::NodeIndices","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option"],"<graph_impl::NodeIndices<Ix> as std::iter::Iterator>::size_hint":["graph_impl::NodeIndices","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option"],"<graph_impl::NodeReferences<'a, N, Ix> as std::iter::DoubleEndedIterator>::next_back":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::NodeReferences","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::NodeReferences<'a, N, Ix> as std::iter::Iterator>::next":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::NodeReferences","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::NodeReferences<'a, N, Ix> as std::iter::Iterator>::size_hint":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::NodeReferences","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::NodeWeightsMut<'a, N, Ix> as std::iter::Iterator>::next":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::NodeWeightsMut","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::option::Option","std::slice::IterMut","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::NodeWeightsMut<'a, N, Ix> as std::iter::Iterator>::size_hint":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::NodeWeightsMut","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::option::Option","std::slice::IterMut","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::WalkNeighbors<Ix> as std::clone::Clone>::clone":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::WalkNeighbors","std::marker::Sized"],"<graph_impl::stable_graph::EdgeIndices<'a, E, Ix> as std::iter::DoubleEndedIterator>::next_back":["graph_impl::stable_graph::EdgeIndices","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<graph_impl::stable_graph::EdgeIndices<'a, E, Ix> as std::iter::Iterator>::next":["graph_impl::stable_graph::EdgeIndices","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<graph_impl::stable_graph::EdgeIndices<'a, E, Ix> as std::iter::Iterator>::size_hint":["graph_impl::stable_graph::EdgeIndices","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as std::clone::Clone>::clone":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeReference","std::marker::Sized"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as std::cmp::PartialEq>::eq":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeReference","std::marker::Sized"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as std::fmt::Debug>::fmt":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeReference","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::id":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeReference","std::marker::Sized"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::source":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeReference","std::marker::Sized"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::target":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeReference","std::marker::Sized"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::weight":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeReference","std::marker::Sized"],"<graph_impl::stable_graph::EdgeReferences<'a, E, Ix> as std::iter::DoubleEndedIterator>::next_back":["graph_impl::stable_graph::EdgeReferences","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<graph_impl::stable_graph::EdgeReferences<'a, E, Ix> as std::iter::Iterator>::next":["graph_impl::stable_graph::EdgeReferences","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<graph_impl::stable_graph::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::next":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::IndexType","graph_impl::NodeIndex","graph_impl::stable_graph::Edges","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::stable_graph::Externals<'a, N, Ty, Ix> as std::iter::Iterator>::next":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::stable_graph::Externals","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::stable_graph::Neighbors<'a, E, Ix> as std::iter::Iterator>::next":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::stable_graph::Neighbors","std::marker::Sized","std::option::Option"],"<graph_impl::stable_graph::NodeIndices<'a, N, Ix> as std::iter::DoubleEndedIterator>::next_back":["graph_impl::stable_graph::NodeIndices","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<graph_impl::stable_graph::NodeIndices<'a, N, Ix> as std::iter::Iterator>::next":["graph_impl::stable_graph::NodeIndices","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<graph_impl::stable_graph::NodeIndices<'a, N, Ix> as std::iter::Iterator>::size_hint":["graph_impl::stable_graph::NodeIndices","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<graph_impl::stable_graph::NodeReferences<'a, N, Ix> as std::iter::DoubleEndedIterator>::next_back":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::stable_graph::NodeReferences","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::stable_graph::NodeReferences<'a, N, Ix> as std::iter::Iterator>::next":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::stable_graph::NodeReferences","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::stable_graph::NodeReferences<'a, N, Ix> as std::iter::Iterator>::size_hint":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::stable_graph::NodeReferences","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Build>::add_edge":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Build>::add_node":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Build>::update_edge":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Create>::with_capacity":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMap>::edge_weight":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMap>::node_weight":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMapMut>::edge_weight_mut":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMapMut>::node_weight_mut":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::FromElements>::from_elements":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::clone::Clone>::clone":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::clone::Clone>::clone_from":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::convert::From<graph_impl::Graph<N, E, Ty, Ix>>>::from":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::default::Default>::default":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::fmt::Debug>::fmt":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::Index<graph_impl::EdgeIndex<Ix>>>::index":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::Index<graph_impl::NodeIndex<Ix>>>::index":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::EdgeIndex<Ix>>>::index_mut":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::NodeIndex<Ix>>>::index_mut":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeCount>::node_count":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeIndexable>::from_index":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeIndexable>::node_bound":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeIndexable>::to_index":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::Visitable>::reset_map":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::Visitable>::visit_map":["fixedbitset::FixedBitSet","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<graph_impl::stable_graph::WalkNeighbors<Ix> as std::clone::Clone>::clone":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::WalkNeighbors","graph_impl::stable_graph::WalkNeighbors","std::marker::Sized"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::DoubleEndedIterator>::next_back":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdges","graphmap::NodeTrait","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::count":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdges","graphmap::NodeTrait","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::last":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdges","graphmap::NodeTrait","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::next":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdges","graphmap::NodeTrait","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::nth":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdges","graphmap::NodeTrait","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::size_hint":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdges","graphmap::NodeTrait","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::DoubleEndedIterator>::next_back":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdgesMut","graphmap::NodeTrait","indexmap::map::IterMut","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::count":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdgesMut","graphmap::NodeTrait","indexmap::map::IterMut","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::last":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdgesMut","graphmap::NodeTrait","indexmap::map::IterMut","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::next":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdgesMut","graphmap::NodeTrait","indexmap::map::IterMut","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::nth":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdgesMut","graphmap::NodeTrait","indexmap::map::IterMut","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::size_hint":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdgesMut","graphmap::NodeTrait","indexmap::map::IterMut","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::CompactDirection as std::clone::Clone>::clone":["graphmap::CompactDirection"],"<graphmap::CompactDirection as std::cmp::PartialEq<Direction>>::eq":["Direction","graphmap::CompactDirection"],"<graphmap::CompactDirection as std::cmp::PartialEq>::eq":["graphmap::CompactDirection"],"<graphmap::CompactDirection as std::convert::From<Direction>>::from":["Direction","graphmap::CompactDirection"],"<graphmap::CompactDirection as std::fmt::Debug>::fmt":["graphmap::CompactDirection","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<graphmap::Edges<'a, N, E, Ty> as std::iter::Iterator>::next":["<N as graphmap::NodeTrait>::N","Directed","Direction","EdgeType","graphmap::Edges","graphmap::Neighbors","graphmap::NodeTrait","indexmap::IndexMap","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::slice::Iter"],"<graphmap::GraphMap<N, E, Ty> as data::Build>::add_edge":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::GraphMap<N, E, Ty> as data::Build>::add_node":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as data::Build>::update_edge":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as data::Create>::with_capacity":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as data::FromElements>::from_elements":["graphmap::GraphMap","indexmap::IndexMap","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as std::clone::Clone>::clone":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as std::default::Default>::default":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as std::fmt::Debug>::fmt":["graphmap::GraphMap","indexmap::IndexMap","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<graphmap::GraphMap<N, E, Ty> as std::iter::Extend<Item>>::extend":["graphmap::GraphMap","indexmap::IndexMap","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as std::iter::FromIterator<Item>>::from_iter":["graphmap::GraphMap","indexmap::IndexMap","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as std::ops::Index<(N, N)>>::index":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as std::ops::IndexMut<(N, N)>>::index_mut":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as visit::GetAdjacencyMatrix>::adjacency_matrix":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as visit::GetAdjacencyMatrix>::is_adjacent":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeCount>::node_count":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeIndexable>::from_index":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeIndexable>::node_bound":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeIndexable>::to_index":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as visit::Visitable>::reset_map":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"<graphmap::GraphMap<N, E, Ty> as visit::Visitable>::visit_map":["graphmap::GraphMap","indexmap::IndexMap","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized"],"<graphmap::Neighbors<'a, N, Ty> as std::iter::Iterator>::next":["Directed","EdgeType","graphmap::Neighbors","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::slice::Iter"],"<graphmap::NeighborsDirected<'a, N, Ty> as std::iter::Iterator>::next":["Directed","Direction","EdgeType","graphmap::NeighborsDirected","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::slice::Iter"],"<graphmap::NodeIdentifiers<'a, N, E, Ty> as std::iter::Iterator>::next":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::NodeIdentifiers","graphmap::NodeTrait","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::NodeReferences<'a, N, E, Ty> as std::iter::Iterator>::next":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::NodeReferences","graphmap::NodeTrait","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<graphmap::Nodes<'a, N> as std::iter::Iterator>::next":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::NodeTrait","graphmap::Nodes","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::iter::Cloned","std::marker::Copy","std::marker::Sized","std::option::Option"],"<graphmap::Nodes<'a, N> as std::iter::Iterator>::size_hint":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::NodeTrait","graphmap::Nodes","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::iter::Cloned","std::marker::Copy","std::marker::Sized","std::option::Option"],"<graphmap::Ptr<'b, T> as std::clone::Clone>::clone":["graphmap::Ptr","std::marker::Sized"],"<graphmap::Ptr<'b, T> as std::cmp::Ord>::cmp":["graphmap::Ptr","std::cmp::Ordering","std::marker::Sized"],"<graphmap::Ptr<'b, T> as std::cmp::PartialEq>::eq":["graphmap::Ptr","std::marker::Sized"],"<graphmap::Ptr<'b, T> as std::cmp::PartialOrd>::partial_cmp":["graphmap::Ptr","std::marker::Sized","std::option::Option"],"<graphmap::Ptr<'b, T> as std::fmt::Debug>::fmt":["graphmap::Ptr","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<graphmap::Ptr<'b, T> as std::hash::Hash>::hash":["graphmap::Ptr","std::hash::Hasher","std::marker::Sized"],"<graphmap::Ptr<'b, T> as std::ops::Deref>::deref":["graphmap::Ptr","std::marker::Sized"],"<i16 as matrix_graph::Zero>::is_zero":[],"<i16 as matrix_graph::Zero>::zero":[],"<i32 as matrix_graph::Zero>::is_zero":[],"<i32 as matrix_graph::Zero>::zero":[],"<i64 as matrix_graph::Zero>::is_zero":[],"<i64 as matrix_graph::Zero>::zero":[],"<i8 as matrix_graph::Zero>::is_zero":[],"<i8 as matrix_graph::Zero>::zero":[],"<isize as matrix_graph::Zero>::is_zero":[],"<isize as matrix_graph::Zero>::zero":[],"<isomorphism::NoSemanticMatch as isomorphism::SemanticMatcher<T>>::enabled":[],"<isomorphism::NoSemanticMatch as isomorphism::SemanticMatcher<T>>::eq":["isomorphism::NoSemanticMatch"],"<isomorphism::Vf2State<Ty, Ix> as std::fmt::Debug>::fmt":["fixedbitset::FixedBitSet","isomorphism::Vf2State","std::alloc::Allocator","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::vec::Vec"],"<isomorphism::try_match::Frame<N> as std::clone::Clone>::clone":["Directed","isomorphism::try_match::Frame","isomorphism::try_match::OpenList","std::marker::Copy","std::marker::Sized"],"<isomorphism::try_match::Frame<N> as std::cmp::PartialEq>::eq":["Directed","isomorphism::try_match::Frame","isomorphism::try_match::OpenList","std::marker::Copy","std::marker::Sized"],"<isomorphism::try_match::Frame<N> as std::fmt::Debug>::fmt":["Directed","isomorphism::try_match::Frame","isomorphism::try_match::OpenList","std::fmt::Formatter","std::marker::Copy","std::marker::Sized","std::result::Result"],"<isomorphism::try_match::OpenList as std::clone::Clone>::clone":["isomorphism::try_match::OpenList"],"<isomorphism::try_match::OpenList as std::cmp::PartialEq>::eq":["isomorphism::try_match::OpenList"],"<isomorphism::try_match::OpenList as std::fmt::Debug>::fmt":["isomorphism::try_match::OpenList","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<iter_format::DebugMap<F> as std::fmt::Debug>::fmt":["iter_format::DebugMap","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<iter_format::Format<'a, I> as std::clone::Clone>::clone":["iter_format::Format","std::cell::RefCell","std::marker::Sized"],"<iter_format::Format<'a, I> as std::fmt::Debug>::fmt":["iter_format::Format","std::cell::RefCell","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<iter_format::NoPretty<T> as std::fmt::Debug>::fmt":["iter_format::NoPretty","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<matrix_graph::EdgeReferences<'a, Ty, Null, Ix> as std::iter::Iterator>::next":["Directed","EdgeType","algo::DfsSpace","matrix_graph::EdgeReferences","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::Edges<'a, Ty, Null, Ix> as std::iter::Iterator>::next":["Directed","EdgeType","algo::DfsSpace","matrix_graph::Edges","matrix_graph::NeighborIterDirection","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::IdIterator<'a> as std::iter::Iterator>::next":["indexmap::IndexSet","matrix_graph::IdIterator","std::marker::Sized","std::option::Option"],"<matrix_graph::IdStorage<T> as std::clone::Clone>::clone":["indexmap::IndexSet","matrix_graph::IdStorage","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<matrix_graph::IdStorage<T> as std::ops::Index<usize>>::index":["indexmap::IndexSet","matrix_graph::IdStorage","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<matrix_graph::IdStorage<T> as std::ops::IndexMut<usize>>::index_mut":["indexmap::IndexSet","matrix_graph::IdStorage","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as data::Build>::add_edge":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as data::Build>::add_node":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as data::Build>::update_edge":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::clone::Clone>::clone":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::default::Default>::default":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::Index<(graph_impl::NodeIndex<Ix>, graph_impl::NodeIndex<Ix>)>>::index":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::Index<graph_impl::NodeIndex<Ix>>>::index":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::IndexMut<(graph_impl::NodeIndex<Ix>, graph_impl::NodeIndex<Ix>)>>::index_mut":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::IndexMut<graph_impl::NodeIndex<Ix>>>::index_mut":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::GetAdjacencyMatrix>::adjacency_matrix":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::GetAdjacencyMatrix>::is_adjacent":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeCount>::node_count":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeIndexable>::from_index":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeIndexable>::node_bound":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeIndexable>::to_index":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::Visitable>::reset_map":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::Visitable>::visit_map":["algo::DfsSpace","fixedbitset::FixedBitSet","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::Neighbors<'a, Ty, Null, Ix> as std::iter::Iterator>::next":["Directed","EdgeType","algo::DfsSpace","matrix_graph::Edges","matrix_graph::NeighborIterDirection","matrix_graph::Neighbors","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<matrix_graph::NodeIdentifiers<'a, Ix> as std::iter::Iterator>::next":["indexmap::IndexSet","matrix_graph::IdIterator","matrix_graph::NodeIdentifiers","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"<matrix_graph::NodeReferences<'a, N, Ix> as std::iter::Iterator>::next":["indexmap::IndexSet","matrix_graph::IdIterator","matrix_graph::IdStorage","matrix_graph::NodeReferences","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::as_mut":["matrix_graph::NotZero","std::marker::Sized","std::option::Option"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::as_ref":["matrix_graph::NotZero","std::marker::Sized","std::option::Option"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::is_null":["matrix_graph::NotZero","std::marker::Sized"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::new":["matrix_graph::NotZero","std::marker::Sized"],"<matrix_graph::NotZero<T> as std::convert::Into<std::option::Option<T>>>::into":["matrix_graph::NotZero","std::marker::Sized","std::option::Option"],"<matrix_graph::NotZero<T> as std::default::Default>::default":["matrix_graph::NotZero","std::marker::Sized"],"<scored::MinScored<K, T> as std::clone::Clone>::clone":["scored::MinScored","std::marker::Sized"],"<scored::MinScored<K, T> as std::cmp::Ord>::cmp":["scored::MinScored","std::cmp::Ordering","std::marker::Sized"],"<scored::MinScored<K, T> as std::cmp::PartialEq>::eq":["scored::MinScored","std::marker::Sized"],"<scored::MinScored<K, T> as std::cmp::PartialOrd>::partial_cmp":["scored::MinScored","std::marker::Sized","std::option::Option"],"<scored::MinScored<K, T> as std::fmt::Debug>::fmt":["scored::MinScored","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<std::collections::HashSet<N, S> as visit::VisitMap<N>>::is_visited":["std::collections::HashSet","std::marker::Sized"],"<std::collections::HashSet<N, S> as visit::VisitMap<N>>::visit":["std::collections::HashSet","std::marker::Sized"],"<std::collections::HashSet<N, S> as visit::filter::FilterNode<N>>::include_node":["std::collections::HashSet","std::marker::Sized"],"<std::option::Option<T> as matrix_graph::Nullable>::as_mut":["std::marker::Sized","std::option::Option"],"<std::option::Option<T> as matrix_graph::Nullable>::as_ref":["std::marker::Sized","std::option::Option"],"<std::option::Option<T> as matrix_graph::Nullable>::new":["std::marker::Sized","std::option::Option"],"<std::result::Result<C, E> as visit::dfsvisit::ControlFlow>::continuing":["std::marker::Sized","std::result::Result"],"<std::result::Result<C, E> as visit::dfsvisit::ControlFlow>::should_break":["std::marker::Sized","std::result::Result"],"<std::result::Result<C, E> as visit::dfsvisit::ControlFlow>::should_prune":["std::marker::Sized","std::result::Result"],"<u16 as graph_impl::IndexType>::index":[],"<u16 as graph_impl::IndexType>::max":[],"<u16 as graph_impl::IndexType>::new":[],"<u16 as matrix_graph::Zero>::is_zero":[],"<u16 as matrix_graph::Zero>::zero":[],"<u32 as graph_impl::IndexType>::index":[],"<u32 as graph_impl::IndexType>::max":[],"<u32 as graph_impl::IndexType>::new":[],"<u32 as matrix_graph::Zero>::is_zero":[],"<u32 as matrix_graph::Zero>::zero":[],"<u64 as matrix_graph::Zero>::is_zero":[],"<u64 as matrix_graph::Zero>::zero":[],"<u8 as graph_impl::IndexType>::index":[],"<u8 as graph_impl::IndexType>::max":[],"<u8 as graph_impl::IndexType>::new":[],"<u8 as matrix_graph::Zero>::is_zero":[],"<u8 as matrix_graph::Zero>::zero":[],"<unionfind::UnionFind<K> as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","unionfind::UnionFind"],"<unionfind::UnionFind<K> as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","unionfind::UnionFind"],"<usize as graph_impl::IndexType>::index":[],"<usize as graph_impl::IndexType>::max":[],"<usize as graph_impl::IndexType>::new":[],"<usize as matrix_graph::Zero>::is_zero":[],"<usize as matrix_graph::Zero>::zero":[],"<visit::dfsvisit::Control<B> as std::clone::Clone>::clone":["std::marker::Sized","visit::dfsvisit::Control"],"<visit::dfsvisit::Control<B> as std::default::Default>::default":["std::marker::Sized","visit::dfsvisit::Control"],"<visit::dfsvisit::Control<B> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","visit::dfsvisit::Control"],"<visit::dfsvisit::Control<B> as visit::dfsvisit::ControlFlow>::continuing":["std::marker::Sized","visit::dfsvisit::Control"],"<visit::dfsvisit::Control<B> as visit::dfsvisit::ControlFlow>::should_break":["std::marker::Sized","visit::dfsvisit::Control"],"<visit::dfsvisit::Control<B> as visit::dfsvisit::ControlFlow>::should_prune":["std::marker::Sized","visit::dfsvisit::Control"],"<visit::dfsvisit::DfsEvent<N> as std::clone::Clone>::clone":["std::marker::Sized","visit::dfsvisit::DfsEvent","visit::dfsvisit::Time"],"<visit::dfsvisit::DfsEvent<N> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","visit::dfsvisit::DfsEvent","visit::dfsvisit::Time"],"<visit::dfsvisit::Time as std::clone::Clone>::clone":["visit::dfsvisit::Time"],"<visit::dfsvisit::Time as std::cmp::Eq>::assert_receiver_is_total_eq":["visit::dfsvisit::Time"],"<visit::dfsvisit::Time as std::cmp::Ord>::cmp":["std::cmp::Ordering","visit::dfsvisit::Time"],"<visit::dfsvisit::Time as std::cmp::PartialEq>::eq":["visit::dfsvisit::Time"],"<visit::dfsvisit::Time as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","visit::dfsvisit::Time"],"<visit::dfsvisit::Time as std::default::Default>::default":["visit::dfsvisit::Time"],"<visit::dfsvisit::Time as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","visit::dfsvisit::Time"],"<visit::dfsvisit::Time as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","visit::dfsvisit::Time"],"<visit::filter::EdgeFiltered<G, F> as std::clone::Clone>::clone":["std::marker::Sized","visit::filter::EdgeFiltered"],"<visit::filter::EdgeFiltered<G, F> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","visit::filter::EdgeFiltered"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeCount>::node_count":["std::marker::Sized","visit::filter::EdgeFiltered"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeIndexable>::from_index":["std::marker::Sized","visit::filter::EdgeFiltered"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeIndexable>::node_bound":["std::marker::Sized","visit::filter::EdgeFiltered"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeIndexable>::to_index":["std::marker::Sized","visit::filter::EdgeFiltered"],"<visit::filter::EdgeFiltered<G, F> as visit::Visitable>::reset_map":["std::marker::Sized","visit::filter::EdgeFiltered"],"<visit::filter::EdgeFiltered<G, F> as visit::Visitable>::visit_map":["std::marker::Sized","visit::filter::EdgeFiltered"],"<visit::filter::EdgeFilteredEdges<'a, G, I, F> as std::iter::Iterator>::next":["std::marker::PhantomData","std::marker::Sized","std::option::Option","visit::filter::EdgeFilteredEdges"],"<visit::filter::EdgeFilteredNeighbors<'a, G, F> as std::iter::Iterator>::next":["Directed","csr::Csr","std::alloc::Allocator","std::clone::Clone","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoEdges","visit::IntoNeighbors","visit::filter::EdgeFilteredNeighbors","visit::reversed::Reversed"],"<visit::filter::EdgeFilteredNeighborsDirected<'a, G, F> as std::iter::Iterator>::next":["Directed","csr::Csr","std::alloc::Allocator","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoEdges","visit::IntoEdgesDirected","visit::IntoNeighbors","visit::IntoNeighborsDirected","visit::filter::EdgeFilteredNeighborsDirected","visit::reversed::Reversed"],"<visit::filter::NodeFiltered<G, F> as data::DataMap>::edge_weight":["std::marker::Sized","std::option::Option","visit::filter::NodeFiltered"],"<visit::filter::NodeFiltered<G, F> as data::DataMap>::node_weight":["std::marker::Sized","std::option::Option","visit::filter::NodeFiltered"],"<visit::filter::NodeFiltered<G, F> as std::clone::Clone>::clone":["std::marker::Sized","visit::filter::NodeFiltered"],"<visit::filter::NodeFiltered<G, F> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","visit::filter::NodeFiltered"],"<visit::filter::NodeFiltered<G, F> as visit::NodeIndexable>::from_index":["std::marker::Sized","visit::filter::NodeFiltered"],"<visit::filter::NodeFiltered<G, F> as visit::NodeIndexable>::node_bound":["std::marker::Sized","visit::filter::NodeFiltered"],"<visit::filter::NodeFiltered<G, F> as visit::NodeIndexable>::to_index":["std::marker::Sized","visit::filter::NodeFiltered"],"<visit::filter::NodeFiltered<G, F> as visit::Visitable>::reset_map":["std::marker::Sized","visit::filter::NodeFiltered"],"<visit::filter::NodeFiltered<G, F> as visit::Visitable>::visit_map":["std::marker::Sized","visit::filter::NodeFiltered"],"<visit::filter::NodeFilteredEdgeReferences<'a, G, I, F> as std::iter::Iterator>::next":["std::marker::PhantomData","std::marker::Sized","std::option::Option","visit::filter::NodeFilteredEdgeReferences"],"<visit::filter::NodeFilteredEdges<'a, G, I, F> as std::iter::Iterator>::next":["std::marker::PhantomData","std::marker::Sized","std::option::Option","visit::filter::NodeFilteredEdges"],"<visit::filter::NodeFilteredNeighbors<'a, I, F> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","visit::filter::NodeFilteredNeighbors"],"<visit::filter::NodeFilteredNodes<'a, I, F> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","visit::filter::NodeFilteredNodes"],"<visit::reversed::Reversed<G> as data::DataMap>::edge_weight":["std::marker::Sized","std::option::Option","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as data::DataMap>::node_weight":["std::marker::Sized","std::option::Option","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as data::DataMapMut>::edge_weight_mut":["std::marker::Sized","std::option::Option","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as data::DataMapMut>::node_weight_mut":["std::marker::Sized","std::option::Option","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as std::clone::Clone>::clone":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::IntoEdgeReferences>::edge_references":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::IntoEdges>::edges":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::IntoEdgesDirected>::edges_directed":["Direction","std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::IntoNeighbors>::neighbors":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::IntoNeighborsDirected>::neighbors_directed":["Direction","std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::IntoNodeIdentifiers>::node_identifiers":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::IntoNodeReferences>::node_references":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::NodeCount>::node_count":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::NodeIndexable>::from_index":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::NodeIndexable>::node_bound":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::NodeIndexable>::to_index":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::Visitable>::reset_map":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::Reversed<G> as visit::Visitable>::visit_map":["std::marker::Sized","visit::reversed::Reversed"],"<visit::reversed::ReversedEdgeReference<R> as std::clone::Clone>::clone":["std::marker::Sized","visit::reversed::ReversedEdgeReference"],"<visit::reversed::ReversedEdgeReference<R> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","visit::reversed::ReversedEdgeReference"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::id":["std::marker::Sized","visit::reversed::ReversedEdgeReference"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::source":["std::marker::Sized","visit::reversed::ReversedEdgeReference"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::target":["std::marker::Sized","visit::reversed::ReversedEdgeReference"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::weight":["std::marker::Sized","visit::reversed::ReversedEdgeReference"],"<visit::reversed::ReversedEdgeReferences<I> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","visit::reversed::ReversedEdgeReferences"],"<visit::reversed::ReversedEdges<I> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","visit::reversed::ReversedEdges"],"<visit::traversal::Bfs<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option","visit::traversal::Bfs"],"<visit::traversal::Bfs<N, VM> as std::clone::Clone>::clone":["std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","visit::traversal::Bfs"],"<visit::traversal::Bfs<N, VM> as std::default::Default>::default":["std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","visit::traversal::Bfs"],"<visit::traversal::Dfs<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"<visit::traversal::Dfs<N, VM> as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<visit::traversal::Dfs<N, VM> as std::default::Default>::default":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"<visit::traversal::Dfs<N, VM> as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","visit::traversal::Dfs"],"<visit::traversal::DfsPostOrder<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::DfsPostOrder"],"<visit::traversal::DfsPostOrder<N, VM> as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::DfsPostOrder"],"<visit::traversal::DfsPostOrder<N, VM> as std::default::Default>::default":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::DfsPostOrder"],"<visit::traversal::DfsPostOrder<N, VM> as std::fmt::Debug>::fmt":["std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","visit::traversal::DfsPostOrder"],"<visit::traversal::Topo<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Topo"],"<visit::traversal::Topo<N, VM> as std::clone::Clone>::clone":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::Topo"],"<visit::traversal::Topo<N, VM> as std::default::Default>::default":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::Topo"],"<visit::traversal::WalkerIter<W, C> as std::clone::Clone>::clone":["std::marker::Sized","visit::traversal::WalkerIter"],"<visit::traversal::WalkerIter<W, C> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","visit::traversal::WalkerIter"],"<visit::traversal::WalkerIter<W, C> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","visit::traversal::WalkerIter"],"Directed":["Directed"],"Direction":["Direction"],"Direction::index":["Direction"],"Direction::opposite":["Direction"],"EdgeType::is_directed":[],"IntoWeightedEdge::into_weighted_edge":[],"Undirected":["Undirected"],"algo::Cycle":["algo::Cycle","std::marker::Sized"],"algo::Cycle::<N>::node_id":["Directed","algo::Cycle","std::marker::Copy","std::marker::Sized"],"algo::DfsSpace":["algo::DfsSpace","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"algo::DfsSpace::<N, VM>::new":["algo::DfsSpace","csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphRef","visit::Visitable","visit::reversed::Reversed","visit::traversal::Dfs"],"algo::FloatMeasure::infinite":[],"algo::FloatMeasure::zero":[],"algo::MinSpanningTree":["Directed","algo::MinSpanningTree","csr::Csr","std::alloc::Allocator","std::clone::Clone","std::collections::BinaryHeap","std::collections::HashMap","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","unionfind::UnionFind","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoNodeIdentifiers","visit::IntoNodeReferences","visit::reversed::Reversed"],"algo::NegativeCycle":["algo::NegativeCycle"],"algo::bellman_ford":["algo::FloatMeasure","csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::vec::Vec","visit::IntoEdges","visit::IntoNodeIdentifiers","visit::NodeCount","visit::NodeIndexable","visit::reversed::Reversed"],"algo::condensation":["Directed","EdgeType","graph_impl::Graph","graph_impl::IndexType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"algo::connected_components":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::IntoEdgeReferences","visit::NodeCompactIndexable","visit::reversed::Reversed"],"algo::dominators::Dominators":["Directed","Direction","algo::dominators::Dominators","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::Copy","std::marker::Sized"],"algo::dominators::Dominators::<N>::dominators":["Directed","Direction","algo::dominators::Dominators","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::option::Option"],"algo::dominators::Dominators::<N>::immediate_dominator":["Directed","Direction","algo::dominators::Dominators","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::option::Option"],"algo::dominators::Dominators::<N>::root":["Directed","Direction","algo::dominators::Dominators","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::Copy","std::marker::Sized"],"algo::dominators::Dominators::<N>::strict_dominators":["Directed","Direction","algo::dominators::Dominators","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::option::Option"],"algo::dominators::DominatorsIter":["Directed","Direction","algo::dominators::Dominators","algo::dominators::DominatorsIter","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::option::Option"],"algo::dominators::intersect":[],"algo::dominators::predecessor_sets_to_idx_vecs":["Directed","Direction","std::alloc::Allocator","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::vec::Vec"],"algo::dominators::simple_fast":["Directed","Direction","algo::dominators::Dominators","csr::Csr","std::alloc::Allocator","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::IntoNeighbors","visit::Visitable","visit::reversed::Reversed"],"algo::dominators::simple_fast_post_order":["Direction","csr::Csr","std::alloc::Allocator","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::IntoNeighbors","visit::Visitable","visit::reversed::Reversed"],"algo::has_path_connecting":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::IntoNeighbors","visit::Visitable","visit::reversed::Reversed"],"algo::is_bipartite_undirected":["Directed","Direction","csr::Csr","fixedbitset::FixedBitSet","std::alloc::Allocator","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphRef","visit::IntoNeighbors","visit::VisitMap","visit::Visitable","visit::reversed::Reversed"],"algo::is_cyclic_directed":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::IntoNeighbors","visit::IntoNodeIdentifiers","visit::Visitable","visit::reversed::Reversed"],"algo::is_cyclic_undirected":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::IntoEdgeReferences","visit::NodeIndexable","visit::reversed::Reversed"],"algo::kosaraju_scc":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::IntoNeighborsDirected","visit::IntoNodeIdentifiers","visit::Visitable","visit::reversed::Reversed"],"algo::min_spanning_tree":["Directed","Direction","algo::MinSpanningTree","csr::Csr","std::alloc::Allocator","std::clone::Clone","std::cmp::PartialOrd","std::collections::BinaryHeap","std::collections::HashMap","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","unionfind::UnionFind","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoNodeIdentifiers","visit::IntoNodeReferences","visit::NodeIndexable","visit::reversed::Reversed"],"algo::scc":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::IntoNeighborsDirected","visit::IntoNodeIdentifiers","visit::Visitable","visit::reversed::Reversed"],"algo::tarjan_scc":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::IntoNeighbors","visit::IntoNodeIdentifiers","visit::NodeIndexable","visit::reversed::Reversed"],"algo::tarjan_scc::Data":["algo::tarjan_scc::Data","csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphBase","visit::NodeIndexable"],"algo::tarjan_scc::NodeData":["algo::tarjan_scc::NodeData","std::marker::Sized","std::option::Option"],"algo::tarjan_scc::scc_visit":["algo::tarjan_scc::Data","csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphBase","visit::IntoNeighbors","visit::NodeIndexable","visit::reversed::Reversed"],"algo::toposort":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","visit::IntoNeighborsDirected","visit::IntoNodeIdentifiers","visit::Visitable","visit::reversed::Reversed"],"algo::with_dfs":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::option::Option","std::vec::Vec","visit::GraphRef","visit::Visitable","visit::reversed::Reversed"],"astar::PathTracker":["Direction","astar::PathTracker","csr::Csr","std::alloc::Allocator","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphBase"],"astar::PathTracker::<G>::new":["Direction","astar::PathTracker","csr::Csr","std::alloc::Allocator","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphBase"],"astar::PathTracker::<G>::reconstruct_path_to":["Direction","astar::PathTracker","csr::Csr","std::alloc::Allocator","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphBase"],"astar::PathTracker::<G>::set_predecessor":["Direction","astar::PathTracker","csr::Csr","std::alloc::Allocator","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphBase"],"astar::astar":["<M as algo::Measure>::M","Directed","Direction","algo::Measure","csr::Csr","std::alloc::Allocator","std::cmp::Eq","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::option::Option","std::vec::Vec","visit::IntoEdges","visit::Visitable","visit::reversed::Reversed"],"csr::Csr":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Directed, Ix>::from_sorted_edges":["Directed","IntoWeightedEdge","algo::DfsSpace","std::alloc::Allocator","std::clone::Clone","std::default::Default","std::marker::Sized","std::result::Result","std::vec::Vec","visit::traversal::Dfs"],"csr::Csr::<N, E, Ty, Ix>::add_edge":["Directed","csr::Csr","std::alloc::Allocator","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::add_edge_":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::add_node":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::clear_edges":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::contains_edge":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::edge_count":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::edges":["csr::Csr","csr::Edges","std::alloc::Allocator","std::iter::Zip","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::edges_slice":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::find_edge_pos":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::is_directed":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::neighbors_of":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::neighbors_range":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::neighbors_slice":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::new":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::node_count":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::out_degree":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"csr::Csr::<N, E, Ty, Ix>::with_nodes":["algo::DfsSpace","csr::Csr","std::alloc::Allocator","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"csr::EdgeReference":["csr::EdgeReference","std::marker::PhantomData","std::marker::Sized"],"csr::EdgeReference::<'a, E, Ty, Ix>::weight":["csr::EdgeReference","std::marker::PhantomData","std::marker::Sized"],"csr::EdgeReferences":["csr::EdgeReferences","std::iter::Enumerate","std::iter::Zip","std::marker::PhantomData","std::marker::Sized"],"csr::Edges":["csr::Edges","std::iter::Zip","std::marker::PhantomData","std::marker::Sized"],"csr::EdgesNotSorted":["csr::EdgesNotSorted"],"csr::Neighbors":["csr::Neighbors","std::marker::Sized","std::slice::Iter"],"csr::NodeIdentifiers":["csr::NodeIdentifiers","std::marker::PhantomData","std::marker::Sized","std::ops::Range"],"data::Build::add_edge":["std::marker::Sized","std::option::Option"],"data::Build::add_node":[],"data::Build::update_edge":[],"data::Create::with_capacity":[],"data::DataMap::edge_weight":["std::marker::Sized","std::option::Option"],"data::DataMap::node_weight":["std::marker::Sized","std::option::Option"],"data::DataMapMut::edge_weight_mut":["std::marker::Sized","std::option::Option"],"data::DataMapMut::node_weight_mut":["std::marker::Sized","std::option::Option"],"data::Element":["data::Element","std::marker::Sized"],"data::ElementIterator::filter_elements":["data::FilterElements","std::alloc::Allocator","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"data::FilterElements":["data::FilterElements","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"data::FromElements::from_elements":["std::iter::IntoIterator","std::marker::Sized"],"data::from_elements_indexable":["csr::Csr","data::Create","graph_impl::Graph","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::NodeIndexable"],"dijkstra::dijkstra":["<M as algo::Measure>::M","Directed","Direction","algo::Measure","csr::Csr","std::alloc::Allocator","std::cmp::Eq","std::collections::HashMap","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::option::Option","std::vec::Vec","visit::IntoEdges","visit::Visitable","visit::reversed::Reversed"],"dot::Config":["dot::Config"],"dot::DebugFmt":["dot::DebugFmt","std::marker::Sized"],"dot::Dot":["Directed","csr::Csr","dot::Config","dot::Dot","std::alloc::Allocator","std::clone::Clone","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoNodeIdentifiers","visit::IntoNodeReferences","visit::reversed::Reversed"],"dot::Dot::<'a, G>::graph_fmt":["Directed","csr::Csr","dot::Config","dot::Dot","std::alloc::Allocator","std::clone::Clone","std::fmt::Formatter","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::result::Result","std::vec::Vec","visit::Data","visit::GraphBase","visit::GraphProp","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoNodeIdentifiers","visit::IntoNodeReferences","visit::NodeIndexable","visit::reversed::Reversed"],"dot::Dot::<'a, G>::new":["Directed","csr::Csr","dot::Config","dot::Dot","std::alloc::Allocator","std::clone::Clone","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoNodeIdentifiers","visit::IntoNodeReferences","visit::reversed::Reversed"],"dot::Dot::<'a, G>::with_attr_getters":["Directed","csr::Csr","dot::Config","dot::Dot","std::alloc::Allocator","std::clone::Clone","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoNodeIdentifiers","visit::IntoNodeReferences","visit::reversed::Reversed"],"dot::Dot::<'a, G>::with_config":["Directed","csr::Csr","dot::Config","dot::Dot","std::alloc::Allocator","std::clone::Clone","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoNodeIdentifiers","visit::IntoNodeReferences","visit::reversed::Reversed"],"dot::Escaped":["dot::Escaped","std::marker::Sized"],"dot::Escaper":["dot::Escaper","std::marker::Sized"],"graph_impl::Edge":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::Edge::<E, Ix>::next_edge":["Direction","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::Edge::<E, Ix>::source":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::Edge::<E, Ix>::target":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::EdgeIndex":["graph_impl::EdgeIndex","std::marker::Sized"],"graph_impl::EdgeIndex::<Ix>::_into_node":["graph_impl::EdgeIndex","graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::EdgeIndex::<Ix>::end":["graph_impl::EdgeIndex","std::marker::Sized"],"graph_impl::EdgeIndex::<Ix>::index":["graph_impl::EdgeIndex","std::marker::Sized"],"graph_impl::EdgeIndex::<Ix>::new":["graph_impl::EdgeIndex","std::marker::Sized"],"graph_impl::EdgeIndices":["graph_impl::EdgeIndices","std::marker::PhantomData","std::marker::Sized","std::ops::Range"],"graph_impl::EdgeReference":["graph_impl::EdgeIndex","graph_impl::EdgeReference","graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::EdgeReference::<'a, E, Ix>::weight":["graph_impl::EdgeIndex","graph_impl::EdgeReference","graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::EdgeReferences":["Directed","Direction","algo::DfsSpace","graph_impl::EdgeReferences","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::EdgeWeightsMut":["Directed","Direction","algo::DfsSpace","graph_impl::EdgeWeightsMut","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::slice::IterMut","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Edges":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Edges","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::EdgesConnecting":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Edges","graph_impl::EdgesConnecting","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::EdgesWalkerMut":["Directed","Direction","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::EdgesWalkerMut","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::EdgesWalkerMut::<'a, E, Ix>::next":["Directed","Direction","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::EdgesWalkerMut","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::EdgesWalkerMut::<'a, E, Ix>::next_edge":["Directed","Direction","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::EdgesWalkerMut","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Externals":["Directed","Direction","algo::DfsSpace","graph_impl::Externals","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Frozen":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::Graph":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::add_edge":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::add_node":["graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::capacity":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::change_edge_links":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::clear":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::clear_edges":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::contains_edge":["graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_count":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_endpoints":["graph_impl::EdgeIndex","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_indices":["graph_impl::EdgeIndices","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_references":["Directed","Direction","algo::DfsSpace","graph_impl::EdgeReferences","graph_impl::Graph","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_weight":["graph_impl::EdgeIndex","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_weight_mut":["graph_impl::EdgeIndex","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_weights_mut":["Directed","Direction","algo::DfsSpace","graph_impl::EdgeWeightsMut","graph_impl::Graph","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::slice::IterMut","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Graph::<N, E, Ty, Ix>::edges":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Edges","graph_impl::Graph","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Graph::<N, E, Ty, Ix>::edges_connecting":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Edges","graph_impl::EdgesConnecting","graph_impl::Graph","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Graph::<N, E, Ty, Ix>::edges_directed":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Edges","graph_impl::Graph","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Graph::<N, E, Ty, Ix>::extend_with_edges":["IntoWeightedEdge","algo::DfsSpace","graph_impl::Graph","matrix_graph::NotZero","std::alloc::Allocator","std::convert::Into","std::default::Default","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Graph::<N, E, Ty, Ix>::externals":["Directed","Direction","algo::DfsSpace","graph_impl::Externals","graph_impl::Graph","graph_impl::IndexType","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Graph::<N, E, Ty, Ix>::filter_map":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge":["graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge_directed_from_node":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::Node","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge_undirected":["graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge_undirected_from_node":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::Node","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::first_edge":["Direction","graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::from_edges":["IntoWeightedEdge","algo::DfsSpace","graph_impl::Graph","matrix_graph::NotZero","std::alloc::Allocator","std::convert::Into","std::default::Default","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Graph::<N, E, Ty, Ix>::index_twice_mut":["csr::Csr","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::GraphIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::IndexMut","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::into_edge_type":["Directed","EdgeType","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::into_nodes_edges":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::is_directed":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::map":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::neighbors":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::Neighbors","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::neighbors_directed":["Direction","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::Neighbors","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::neighbors_undirected":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::Neighbors","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::next_edge":["Direction","graph_impl::EdgeIndex","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::node_count":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::node_indices":["graph_impl::Graph","graph_impl::NodeIndices","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::node_weight":["graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::node_weight_mut":["graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::node_weights_mut":["Directed","Direction","algo::DfsSpace","graph_impl::Graph","graph_impl::IndexType","graph_impl::NodeWeightsMut","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::slice::IterMut","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Graph::<N, E, Ty, Ix>::raw_edges":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::raw_nodes":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::Node","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::remove_edge":["graph_impl::EdgeIndex","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::remove_edge_adjust_indices":["graph_impl::EdgeIndex","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::remove_node":["graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_edges":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_exact_edges":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_exact_nodes":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_nodes":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::retain_edges":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::retain_nodes":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::reverse":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::shrink_to_fit":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::shrink_to_fit_edges":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::shrink_to_fit_nodes":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::update_edge":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Ty, Ix>::with_capacity":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E, Undirected>::new_undirected":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::Graph::<N, E>::new":["graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::GraphIndex::index":[],"graph_impl::GraphIndex::is_node_index":[],"graph_impl::IndexType::index":[],"graph_impl::IndexType::max":[],"graph_impl::IndexType::new":[],"graph_impl::Neighbors":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Neighbors","graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::Neighbors::<'a, E, Ix>::detach":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Neighbors","graph_impl::NodeIndex","graph_impl::WalkNeighbors","std::marker::Sized"],"graph_impl::Node":["graph_impl::EdgeIndex","graph_impl::Node","std::marker::Sized"],"graph_impl::Node::<N, Ix>::next_edge":["Direction","graph_impl::EdgeIndex","graph_impl::Node","std::marker::Sized"],"graph_impl::NodeIndex":["graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::NodeIndex::<Ix>::_into_edge":["graph_impl::EdgeIndex","graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::NodeIndex::<Ix>::end":["graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::NodeIndex::<Ix>::index":["graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::NodeIndex::<Ix>::new":["graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::NodeIndices":["graph_impl::NodeIndices","std::marker::PhantomData","std::marker::Sized","std::ops::Range"],"graph_impl::NodeReferences":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::NodeReferences","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::NodeWeightsMut":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::NodeWeightsMut","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::slice::IterMut","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::Pair":["graph_impl::Pair","std::marker::Sized"],"graph_impl::WalkNeighbors":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::WalkNeighbors","std::marker::Sized"],"graph_impl::WalkNeighbors::<Ix>::next":["Directed","EdgeType","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::WalkNeighbors","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::WalkNeighbors::<Ix>::next_edge":["Directed","EdgeType","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::WalkNeighbors","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::WalkNeighbors::<Ix>::next_node":["Directed","EdgeType","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::WalkNeighbors","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::edge_index":["graph_impl::EdgeIndex","graph_impl::IndexType","std::marker::Sized"],"graph_impl::edges_walker_mut":["Directed","Direction","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::EdgesWalkerMut","graph_impl::IndexType","graph_impl::NodeIndex","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::frozen::<impl data::DataMap for graph_impl::Frozen<'a, G>>::edge_weight":["graph_impl::Frozen","std::marker::Sized","std::option::Option"],"graph_impl::frozen::<impl data::DataMap for graph_impl::Frozen<'a, G>>::node_weight":["graph_impl::Frozen","std::marker::Sized","std::option::Option"],"graph_impl::frozen::<impl data::DataMapMut for graph_impl::Frozen<'a, G>>::edge_weight_mut":["graph_impl::Frozen","std::marker::Sized","std::option::Option"],"graph_impl::frozen::<impl data::DataMapMut for graph_impl::Frozen<'a, G>>::node_weight_mut":["graph_impl::Frozen","std::marker::Sized","std::option::Option"],"graph_impl::frozen::<impl graph_impl::Frozen<'a, G>>::new":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl graph_impl::Frozen<'a, graph_impl::Graph<N, E, Ty, Ix>>>::index_twice_mut":["csr::Csr","graph_impl::EdgeIndex","graph_impl::Frozen","graph_impl::GraphIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::IndexMut","std::vec::Vec"],"graph_impl::frozen::<impl std::ops::Deref for graph_impl::Frozen<'a, G>>::deref":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl std::ops::Index<I> for graph_impl::Frozen<'a, G>>::index":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl std::ops::IndexMut<I> for graph_impl::Frozen<'a, G>>::index_mut":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::GetAdjacencyMatrix for graph_impl::Frozen<'a, G>>::adjacency_matrix":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::GetAdjacencyMatrix for graph_impl::Frozen<'a, G>>::is_adjacent":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::IntoEdgeReferences for &'b graph_impl::Frozen<'a, G>>::edge_references":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::IntoEdges for &'b graph_impl::Frozen<'a, G>>::edges":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::IntoEdgesDirected for &'b graph_impl::Frozen<'a, G>>::edges_directed":["Direction","graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::IntoNeighbors for &'b graph_impl::Frozen<'a, G>>::neighbors":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::IntoNeighborsDirected for &'b graph_impl::Frozen<'a, G>>::neighbors_directed":["Direction","graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::IntoNodeIdentifiers for &'b graph_impl::Frozen<'a, G>>::node_identifiers":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::IntoNodeReferences for &'b graph_impl::Frozen<'a, G>>::node_references":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::NodeCount for graph_impl::Frozen<'a, G>>::node_count":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::NodeIndexable for graph_impl::Frozen<'a, G>>::from_index":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::NodeIndexable for graph_impl::Frozen<'a, G>>::node_bound":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::NodeIndexable for graph_impl::Frozen<'a, G>>::to_index":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::Visitable for graph_impl::Frozen<'a, G>>::reset_map":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::frozen::<impl visit::Visitable for graph_impl::Frozen<'a, G>>::visit_map":["graph_impl::Frozen","std::marker::Sized"],"graph_impl::index_twice":["graph_impl::Pair","std::marker::Sized"],"graph_impl::node_index":["graph_impl::IndexType","graph_impl::NodeIndex","std::marker::Sized"],"graph_impl::stable_graph::<impl std::convert::From<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix>> for graph_impl::Graph<N, E, Ty, Ix>>::from":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::EdgeIndices":["graph_impl::stable_graph::EdgeIndices","std::iter::Enumerate","std::marker::Sized"],"graph_impl::stable_graph::EdgeReference":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeReference","std::marker::Sized"],"graph_impl::stable_graph::EdgeReference::<'a, E, Ix>::weight":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeReference","std::marker::Sized"],"graph_impl::stable_graph::EdgeReferences":["graph_impl::stable_graph::EdgeReferences","std::iter::Enumerate","std::marker::Sized"],"graph_impl::stable_graph::Edges":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::IndexType","graph_impl::NodeIndex","graph_impl::stable_graph::Edges","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::stable_graph::Externals":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::stable_graph::Externals","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::stable_graph::Neighbors":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::stable_graph::Neighbors","std::marker::Sized"],"graph_impl::stable_graph::Neighbors::<'a, E, Ix>::detach":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::WalkNeighbors","graph_impl::stable_graph::Neighbors","graph_impl::stable_graph::WalkNeighbors","std::marker::Sized"],"graph_impl::stable_graph::NodeIndices":["graph_impl::stable_graph::NodeIndices","std::iter::Enumerate","std::marker::Sized"],"graph_impl::stable_graph::NodeReferences":["Directed","Direction","algo::DfsSpace","graph_impl::IndexType","graph_impl::stable_graph::NodeReferences","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::stable_graph::StableGraph":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_edge":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_node":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_vacant_edge":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_vacant_node":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::capacity":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::check_free_lists":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::clear":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::clear_edges":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::contains_edge":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::contains_node":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_bound":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_count":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_endpoints":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_indices":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeIndices","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::iter::Enumerate","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_weight":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_weight_mut":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_weights_mut":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edges":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::IndexType","graph_impl::NodeIndex","graph_impl::stable_graph::Edges","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edges_directed":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::IndexType","graph_impl::NodeIndex","graph_impl::stable_graph::Edges","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::extend_with_edges":["IntoWeightedEdge","algo::DfsSpace","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","matrix_graph::NotZero","std::alloc::Allocator","std::convert::Into","std::default::Default","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::externals":["Directed","Direction","algo::DfsSpace","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::IndexType","graph_impl::NodeIndex","graph_impl::stable_graph::Externals","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Enumerate","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::filter_map":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::find_edge":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::find_edge_undirected":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::from_edges":["IntoWeightedEdge","algo::DfsSpace","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","matrix_graph::NotZero","std::alloc::Allocator","std::convert::Into","std::default::Default","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::get_node":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::index_twice_mut":["csr::Csr","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::GraphIndex","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::IndexMut","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::is_directed":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::map":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::neighbors":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::Neighbors","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::neighbors_directed":["Direction","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::Neighbors","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::neighbors_undirected":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::Neighbors","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_count":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_indices":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::NodeIndices","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::iter::Enumerate","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_weight":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_weight_mut":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_weights_mut":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::raw_edges":["graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::raw_nodes":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::Node","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::remove_edge":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::remove_node":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::retain_edges":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::retain_nodes":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::update_edge":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::with_capacity":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::StableGraph::<N, E>::new":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graph_impl::stable_graph::WalkNeighbors":["graph_impl::EdgeIndex","graph_impl::NodeIndex","graph_impl::WalkNeighbors","graph_impl::stable_graph::WalkNeighbors","std::marker::Sized"],"graph_impl::stable_graph::WalkNeighbors::<Ix>::next":["Directed","EdgeType","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::WalkNeighbors","graph_impl::stable_graph::StableGraph","graph_impl::stable_graph::WalkNeighbors","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::WalkNeighbors::<Ix>::next_edge":["Directed","EdgeType","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::WalkNeighbors","graph_impl::stable_graph::StableGraph","graph_impl::stable_graph::WalkNeighbors","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::WalkNeighbors::<Ix>::next_node":["Directed","EdgeType","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::WalkNeighbors","graph_impl::stable_graph::StableGraph","graph_impl::stable_graph::WalkNeighbors","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"graph_impl::stable_graph::swap_pair":["std::marker::Sized"],"graph_impl::swap_pair":["std::marker::Sized"],"graphmap::AllEdges":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdges","graphmap::NodeTrait","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"graphmap::AllEdgesMut":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdgesMut","graphmap::NodeTrait","indexmap::map::IterMut","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"graphmap::CompactDirection":["graphmap::CompactDirection"],"graphmap::Edges":["<N as graphmap::NodeTrait>::N","Directed","Direction","EdgeType","graphmap::Edges","graphmap::Neighbors","graphmap::NodeTrait","indexmap::IndexMap","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::slice::Iter"],"graphmap::GraphMap":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::add_edge":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"graphmap::GraphMap::<N, E, Ty>::add_node":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::all_edges":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdges","graphmap::GraphMap","graphmap::NodeTrait","indexmap::IndexMap","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::all_edges_mut":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::AllEdgesMut","graphmap::GraphMap","graphmap::NodeTrait","indexmap::IndexMap","indexmap::map::IterMut","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::capacity":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::clear":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::contains_edge":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::contains_node":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::edge_count":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::edge_key":[],"graphmap::GraphMap::<N, E, Ty>::edge_weight":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"graphmap::GraphMap::<N, E, Ty>::edge_weight_mut":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"graphmap::GraphMap::<N, E, Ty>::edges":["<N as graphmap::NodeTrait>::N","Directed","Direction","EdgeType","graphmap::Edges","graphmap::GraphMap","graphmap::Neighbors","graphmap::NodeTrait","indexmap::IndexMap","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::slice::Iter"],"graphmap::GraphMap::<N, E, Ty>::from_edges":["IntoWeightedEdge","graphmap::GraphMap","indexmap::IndexMap","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::into_graph":["graph_impl::Graph","graph_impl::IndexType","graphmap::GraphMap","indexmap::IndexMap","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"graphmap::GraphMap::<N, E, Ty>::is_directed":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::neighbors":["Directed","EdgeType","graphmap::GraphMap","graphmap::Neighbors","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized","std::slice::Iter"],"graphmap::GraphMap::<N, E, Ty>::neighbors_directed":["Directed","Direction","EdgeType","graphmap::GraphMap","graphmap::NeighborsDirected","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized","std::slice::Iter"],"graphmap::GraphMap::<N, E, Ty>::new":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::node_count":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::nodes":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::GraphMap","graphmap::NodeTrait","graphmap::Nodes","indexmap::IndexMap","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::iter::Cloned","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::remove_edge":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"graphmap::GraphMap::<N, E, Ty>::remove_node":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::remove_single_edge":["Direction","graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::GraphMap::<N, E, Ty>::with_capacity":["graphmap::GraphMap","indexmap::IndexMap","std::marker::PhantomData","std::marker::Sized"],"graphmap::Neighbors":["Directed","EdgeType","graphmap::Neighbors","std::marker::PhantomData","std::marker::Sized","std::slice::Iter"],"graphmap::NeighborsDirected":["Directed","Direction","EdgeType","graphmap::NeighborsDirected","std::marker::PhantomData","std::marker::Sized","std::slice::Iter"],"graphmap::NodeIdentifiers":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::NodeIdentifiers","graphmap::NodeTrait","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"graphmap::NodeReferences":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::NodeReferences","graphmap::NodeTrait","indexmap::map::Iter","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::PhantomData","std::marker::Sized"],"graphmap::Nodes":["<N as graphmap::NodeTrait>::N","Directed","Direction","graphmap::NodeTrait","graphmap::Nodes","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialOrd","std::hash::Hash","std::iter::Cloned","std::marker::Copy","std::marker::Sized"],"graphmap::Ptr":["graphmap::Ptr","std::marker::Sized"],"graphmap::ptr_eq":["std::marker::Sized"],"isomorphism::NoSemanticMatch":["isomorphism::NoSemanticMatch"],"isomorphism::SemanticMatcher::enabled":[],"isomorphism::SemanticMatcher::eq":[],"isomorphism::Vf2State":["fixedbitset::FixedBitSet","isomorphism::Vf2State","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"isomorphism::Vf2State::<Ty, Ix>::is_complete":["fixedbitset::FixedBitSet","isomorphism::Vf2State","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"isomorphism::Vf2State::<Ty, Ix>::new":["fixedbitset::FixedBitSet","graph_impl::Graph","isomorphism::Vf2State","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"isomorphism::Vf2State::<Ty, Ix>::next_in_index":["fixedbitset::FixedBitSet","isomorphism::Vf2State","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"isomorphism::Vf2State::<Ty, Ix>::next_out_index":["fixedbitset::FixedBitSet","isomorphism::Vf2State","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"isomorphism::Vf2State::<Ty, Ix>::next_rest_index":["fixedbitset::FixedBitSet","isomorphism::Vf2State","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"isomorphism::Vf2State::<Ty, Ix>::pop_mapping":["fixedbitset::FixedBitSet","graph_impl::Graph","graph_impl::NodeIndex","isomorphism::Vf2State","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"isomorphism::Vf2State::<Ty, Ix>::push_mapping":["fixedbitset::FixedBitSet","graph_impl::Graph","graph_impl::NodeIndex","isomorphism::Vf2State","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"isomorphism::is_isomorphic":["Directed","EdgeType","graph_impl::Graph","graph_impl::IndexType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"isomorphism::is_isomorphic_matching":["Directed","EdgeType","graph_impl::Graph","graph_impl::IndexType","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::vec::Vec"],"isomorphism::try_match":["<F as isomorphism::SemanticMatcher<T>>::F","Directed","EdgeType","fixedbitset::FixedBitSet","graph_impl::Graph","graph_impl::IndexType","isomorphism::SemanticMatcher","isomorphism::Vf2State","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"isomorphism::try_match::Frame":["Directed","isomorphism::try_match::Frame","isomorphism::try_match::OpenList","std::marker::Copy","std::marker::Sized"],"isomorphism::try_match::OpenList":["isomorphism::try_match::OpenList"],"iter_format::DebugMap":["iter_format::DebugMap","std::marker::Sized"],"iter_format::Format":["iter_format::Format","std::cell::RefCell","std::marker::Sized"],"iter_format::Format::<'a, I>::format":["iter_format::Format","std::cell::RefCell","std::fmt::Formatter","std::marker::Sized","std::ops::FnMut","std::result::Result"],"iter_format::IterFormatExt::format":["iter_format::Format","std::cell::RefCell","std::marker::Sized"],"iter_format::NoPretty":["iter_format::NoPretty","std::marker::Sized"],"iter_utils::IterUtilsExt::ex_find_map":["std::marker::Sized","std::ops::FnMut","std::option::Option"],"iter_utils::IterUtilsExt::ex_rfind_map":["graph_impl::EdgeIndices","std::iter::DoubleEndedIterator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ops::Range","std::option::Option"],"matrix_graph::EdgeReferences":["Directed","EdgeType","algo::DfsSpace","matrix_graph::EdgeReferences","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::EdgeReferences::<'a, Ty, Null, Ix>::new":["Directed","EdgeType","algo::DfsSpace","matrix_graph::EdgeReferences","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::Edges":["Directed","EdgeType","algo::DfsSpace","matrix_graph::Edges","matrix_graph::NeighborIterDirection","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::Edges::<'a, Ty, Null, Ix>::on_columns":["Directed","EdgeType","algo::DfsSpace","matrix_graph::Edges","matrix_graph::NeighborIterDirection","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::Edges::<'a, Ty, Null, Ix>::on_rows":["Directed","EdgeType","algo::DfsSpace","matrix_graph::Edges","matrix_graph::NeighborIterDirection","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::IdIterator":["indexmap::IndexSet","matrix_graph::IdIterator","std::marker::Sized","std::option::Option"],"matrix_graph::IdStorage":["indexmap::IndexSet","matrix_graph::IdStorage","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"matrix_graph::IdStorage::<T>::add":["indexmap::IndexSet","matrix_graph::IdStorage","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"matrix_graph::IdStorage::<T>::clear":["indexmap::IndexSet","matrix_graph::IdStorage","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"matrix_graph::IdStorage::<T>::iter_ids":["indexmap::IndexSet","matrix_graph::IdIterator","matrix_graph::IdStorage","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"matrix_graph::IdStorage::<T>::len":["indexmap::IndexSet","matrix_graph::IdStorage","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"matrix_graph::IdStorage::<T>::remove":["indexmap::IndexSet","matrix_graph::IdStorage","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"matrix_graph::IdStorage::<T>::with_capacity":["indexmap::IndexSet","matrix_graph::IdStorage","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"matrix_graph::MatrixGraph":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Directed, Null, Ix>::edges_directed":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::Edges","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NeighborIterDirection","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Directed, Null, Ix>::neighbors_directed":["Directed","Direction","EdgeType","algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::Edges","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NeighborIterDirection","matrix_graph::Neighbors","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::add_edge":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::add_node":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::clear":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edge_count":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edge_weight":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edge_weight_mut":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edges":["Directed","EdgeType","algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::Edges","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NeighborIterDirection","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::extend_capacity_for_edge":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::extend_capacity_for_node":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::extend_with_edges":["IntoWeightedEdge","algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::from_edges":["IntoWeightedEdge","algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::has_edge":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::is_directed":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::neighbors":["Directed","EdgeType","algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::Edges","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NeighborIterDirection","matrix_graph::Neighbors","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::node_count":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::node_weight":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::node_weight_mut":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::remove_edge":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::remove_node":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::to_edge_position":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::update_edge":["algo::DfsSpace","graph_impl::NodeIndex","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::with_capacity":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E, Undirected>::new_undirected":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::MatrixGraph::<N, E>::new":["algo::DfsSpace","indexmap::IndexSet","matrix_graph::IdStorage","matrix_graph::MatrixGraph","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::NeighborIterDirection":["matrix_graph::NeighborIterDirection"],"matrix_graph::Neighbors":["Directed","EdgeType","algo::DfsSpace","matrix_graph::Edges","matrix_graph::NeighborIterDirection","matrix_graph::Neighbors","matrix_graph::NotZero","matrix_graph::Nullable","matrix_graph::private::Sealed","std::alloc::Allocator","std::convert::Into","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::NodeIdentifiers":["indexmap::IndexSet","matrix_graph::IdIterator","matrix_graph::NodeIdentifiers","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"matrix_graph::NodeIdentifiers::<'a, Ix>::new":["indexmap::IndexSet","matrix_graph::IdIterator","matrix_graph::NodeIdentifiers","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"matrix_graph::NodeReferences":["indexmap::IndexSet","matrix_graph::IdIterator","matrix_graph::IdStorage","matrix_graph::NodeReferences","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"matrix_graph::NodeReferences::<'a, N, Ix>::new":["indexmap::IndexSet","matrix_graph::IdIterator","matrix_graph::IdStorage","matrix_graph::NodeReferences","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"matrix_graph::NotZero":["matrix_graph::NotZero","std::marker::Sized"],"matrix_graph::Nullable::as_mut":["std::marker::Sized","std::option::Option"],"matrix_graph::Nullable::as_ref":["std::marker::Sized","std::option::Option"],"matrix_graph::Nullable::is_null":[],"matrix_graph::Nullable::new":[],"matrix_graph::Zero::is_zero":[],"matrix_graph::Zero::zero":[],"matrix_graph::ensure_len":["algo::DfsSpace","std::alloc::Allocator","std::default::Default","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::extend_flat_square_matrix":["algo::DfsSpace","std::alloc::Allocator","std::default::Default","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::extend_linearized_matrix":["Directed","EdgeType","algo::DfsSpace","std::alloc::Allocator","std::default::Default","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::extend_lower_triangular_matrix":["algo::DfsSpace","std::alloc::Allocator","std::default::Default","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"matrix_graph::node_index":["graph_impl::NodeIndex","std::marker::Sized"],"matrix_graph::to_flat_square_matrix_position":[],"matrix_graph::to_linearized_matrix_position":["Directed","EdgeType","std::marker::Sized"],"matrix_graph::to_lower_triangular_matrix_position":[],"scored::MinScored":["scored::MinScored","std::marker::Sized"],"simple_paths::all_simple_paths":["Direction","csr::Csr","graphmap::GraphMap","indexmap::IndexMap","std::alloc::Allocator","std::cmp::Eq","std::hash::Hash","std::iter::FromIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::IntoNeighborsDirected","visit::NodeCount","visit::reversed::Reversed"],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::Graph<N, E, Ty, Ix>>::adjacency_matrix":["fixedbitset::FixedBitSet","graph_impl::Graph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::Graph<N, E, Ty, Ix>>::is_adjacent":["fixedbitset::FixedBitSet","graph_impl::Graph","graph_impl::NodeIndex","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::stable_graph::StableGraph<N, E, Ty, Ix>>::adjacency_matrix":["fixedbitset::FixedBitSet","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::stable_graph::StableGraph<N, E, Ty, Ix>>::is_adjacent":["fixedbitset::FixedBitSet","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"unionfind::UnionFind":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","unionfind::UnionFind"],"unionfind::UnionFind::<K>::equiv":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","unionfind::UnionFind"],"unionfind::UnionFind::<K>::find":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","unionfind::UnionFind"],"unionfind::UnionFind::<K>::find_mut":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","unionfind::UnionFind"],"unionfind::UnionFind::<K>::find_mut_recursive":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","unionfind::UnionFind"],"unionfind::UnionFind::<K>::into_labeling":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","unionfind::UnionFind"],"unionfind::UnionFind::<K>::new":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","unionfind::UnionFind"],"unionfind::UnionFind::<K>::union":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","unionfind::UnionFind"],"unionfind::get_unchecked":["std::marker::Sized"],"unionfind::get_unchecked_mut":["std::marker::Sized"],"util::enumerate":["std::iter::Enumerate","std::iter::IntoIterator","std::marker::Sized"],"util::zip":["std::iter::IntoIterator","std::iter::Zip","std::marker::Sized"],"visit::EdgeRef::id":[],"visit::EdgeRef::source":[],"visit::EdgeRef::target":[],"visit::EdgeRef::weight":[],"visit::GetAdjacencyMatrix::adjacency_matrix":[],"visit::GetAdjacencyMatrix::is_adjacent":[],"visit::GraphProp::is_directed":[],"visit::IntoEdgeReferences::edge_references":[],"visit::IntoEdges::edges":[],"visit::IntoEdgesDirected::edges_directed":["Direction"],"visit::IntoNeighbors::neighbors":[],"visit::IntoNeighborsDirected::neighbors_directed":["Direction"],"visit::IntoNodeIdentifiers::node_identifiers":[],"visit::IntoNodeReferences::node_references":[],"visit::NodeCount::node_count":[],"visit::NodeIndexable::from_index":[],"visit::NodeIndexable::node_bound":[],"visit::NodeIndexable::to_index":[],"visit::NodeRef::id":[],"visit::NodeRef::weight":[],"visit::VisitMap::is_visited":[],"visit::VisitMap::visit":[],"visit::Visitable::reset_map":[],"visit::Visitable::visit_map":[],"visit::dfsvisit::Control":["std::marker::Sized","visit::dfsvisit::Control"],"visit::dfsvisit::Control::<B>::break_value":["std::marker::Sized","std::option::Option","visit::dfsvisit::Control"],"visit::dfsvisit::Control::<B>::breaking":["std::marker::Sized","visit::dfsvisit::Control"],"visit::dfsvisit::ControlFlow::continuing":[],"visit::dfsvisit::ControlFlow::should_break":[],"visit::dfsvisit::ControlFlow::should_prune":[],"visit::dfsvisit::DfsEvent":["std::marker::Sized","visit::dfsvisit::DfsEvent","visit::dfsvisit::Time"],"visit::dfsvisit::Time":["visit::dfsvisit::Time"],"visit::dfsvisit::depth_first_search":["csr::Csr","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::result::Result","std::vec::Vec","visit::IntoNeighbors","visit::Visitable","visit::dfsvisit::ControlFlow","visit::reversed::Reversed"],"visit::dfsvisit::dfs_visitor":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::result::Result","std::vec::Vec","visit::IntoNeighbors","visit::Visitable","visit::dfsvisit::ControlFlow","visit::dfsvisit::Time","visit::reversed::Reversed"],"visit::dfsvisit::time_post_inc":["visit::dfsvisit::Time"],"visit::filter::EdgeFiltered":["std::marker::Sized","visit::filter::EdgeFiltered"],"visit::filter::EdgeFiltered::<G, F>::from_fn":["std::marker::Sized","visit::filter::EdgeFiltered"],"visit::filter::EdgeFilteredEdges":["std::marker::PhantomData","std::marker::Sized","visit::filter::EdgeFilteredEdges"],"visit::filter::EdgeFilteredNeighbors":["Directed","csr::Csr","std::alloc::Allocator","std::clone::Clone","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoEdges","visit::IntoNeighbors","visit::filter::EdgeFilteredNeighbors","visit::reversed::Reversed"],"visit::filter::EdgeFilteredNeighborsDirected":["Directed","csr::Csr","std::alloc::Allocator","std::marker::Copy","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::Data","visit::GraphBase","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoEdges","visit::IntoEdgesDirected","visit::IntoNeighbors","visit::IntoNeighborsDirected","visit::filter::EdgeFilteredNeighborsDirected","visit::reversed::Reversed"],"visit::filter::FilterEdge::include_edge":[],"visit::filter::FilterNode::include_node":[],"visit::filter::NodeFiltered":["std::marker::Sized","visit::filter::NodeFiltered"],"visit::filter::NodeFiltered::<G, F>::from_fn":["std::marker::Sized","visit::filter::NodeFiltered"],"visit::filter::NodeFilteredEdgeReferences":["std::marker::PhantomData","std::marker::Sized","visit::filter::NodeFilteredEdgeReferences"],"visit::filter::NodeFilteredEdges":["std::marker::PhantomData","std::marker::Sized","visit::filter::NodeFilteredEdges"],"visit::filter::NodeFilteredNeighbors":["std::marker::Sized","visit::filter::NodeFilteredNeighbors"],"visit::filter::NodeFilteredNodes":["std::marker::Sized","visit::filter::NodeFilteredNodes"],"visit::reversed::Reversed":["std::marker::Sized","visit::reversed::Reversed"],"visit::reversed::ReversedEdgeReference":["std::marker::Sized","visit::reversed::ReversedEdgeReference"],"visit::reversed::ReversedEdgeReference::<R>::as_unreversed":["std::marker::Sized","visit::reversed::ReversedEdgeReference"],"visit::reversed::ReversedEdgeReference::<R>::into_unreversed":["std::marker::Sized","visit::reversed::ReversedEdgeReference"],"visit::reversed::ReversedEdgeReferences":["std::marker::Sized","visit::reversed::ReversedEdgeReferences"],"visit::reversed::ReversedEdges":["std::marker::Sized","visit::reversed::ReversedEdges"],"visit::traversal::Bfs":["std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","visit::traversal::Bfs"],"visit::traversal::Bfs::<N, VM>::new":["csr::Csr","std::alloc::Allocator","std::collections::VecDeque","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphRef","visit::Visitable","visit::reversed::Reversed","visit::traversal::Bfs"],"visit::traversal::Bfs::<N, VM>::next":["std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option","visit::IntoNeighbors","visit::reversed::Reversed","visit::traversal::Bfs"],"visit::traversal::Dfs":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"visit::traversal::Dfs::<N, VM>::empty":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphRef","visit::Visitable","visit::reversed::Reversed","visit::traversal::Dfs"],"visit::traversal::Dfs::<N, VM>::from_parts":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"visit::traversal::Dfs::<N, VM>::move_to":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::Dfs"],"visit::traversal::Dfs::<N, VM>::new":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphRef","visit::Visitable","visit::reversed::Reversed","visit::traversal::Dfs"],"visit::traversal::Dfs::<N, VM>::next":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","visit::IntoNeighbors","visit::reversed::Reversed","visit::traversal::Dfs"],"visit::traversal::Dfs::<N, VM>::reset":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphRef","visit::Visitable","visit::reversed::Reversed","visit::traversal::Dfs"],"visit::traversal::DfsPostOrder":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::DfsPostOrder"],"visit::traversal::DfsPostOrder::<N, VM>::empty":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphRef","visit::Visitable","visit::reversed::Reversed","visit::traversal::DfsPostOrder"],"visit::traversal::DfsPostOrder::<N, VM>::move_to":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::DfsPostOrder"],"visit::traversal::DfsPostOrder::<N, VM>::new":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphRef","visit::Visitable","visit::reversed::Reversed","visit::traversal::DfsPostOrder"],"visit::traversal::DfsPostOrder::<N, VM>::next":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","visit::IntoNeighbors","visit::reversed::Reversed","visit::traversal::DfsPostOrder"],"visit::traversal::DfsPostOrder::<N, VM>::reset":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphRef","visit::Visitable","visit::reversed::Reversed","visit::traversal::DfsPostOrder"],"visit::traversal::Topo":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::traversal::Topo"],"visit::traversal::Topo::<N, VM>::empty":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::GraphRef","visit::Visitable","visit::reversed::Reversed","visit::traversal::Topo"],"visit::traversal::Topo::<N, VM>::extend_with_initials":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","visit::IntoNeighborsDirected","visit::IntoNodeIdentifiers","visit::reversed::Reversed","visit::traversal::Topo"],"visit::traversal::Topo::<N, VM>::new":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::IntoNeighborsDirected","visit::IntoNodeIdentifiers","visit::Visitable","visit::reversed::Reversed","visit::traversal::Topo"],"visit::traversal::Topo::<N, VM>::next":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec","visit::IntoNeighborsDirected","visit::Visitable","visit::reversed::Reversed","visit::traversal::Topo"],"visit::traversal::Topo::<N, VM>::reset":["csr::Csr","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec","visit::IntoNeighborsDirected","visit::IntoNodeIdentifiers","visit::Visitable","visit::reversed::Reversed","visit::traversal::Topo"],"visit::traversal::Walker::iter":["Directed","std::clone::Clone","std::marker::Sized","visit::traversal::WalkerIter"],"visit::traversal::Walker::walk_next":["std::marker::Sized","std::option::Option"],"visit::traversal::WalkerIter":["std::marker::Sized","visit::traversal::WalkerIter"],"visit::traversal::WalkerIter::<W, C>::context":["std::marker::Sized","visit::traversal::WalkerIter"],"visit::traversal::WalkerIter::<W, C>::inner_mut":["std::marker::Sized","visit::traversal::WalkerIter"],"visit::traversal::WalkerIter::<W, C>::inner_ref":["std::marker::Sized","visit::traversal::WalkerIter"]},"glob_path_import":{"visit::dfsvisit":"visit::","visit::filter":"visit::","visit::reversed":"visit::","visit::traversal":"visit::"},"self_to_fn":{"<F as isomorphism::SemanticMatcher<T>>::F":["impl<T, F> SemanticMatcher<T> for F\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    #[inline]\n    fn enabled() -> bool {\n        true\n    }\n    #[inline]\n    fn eq(&mut self, a: &T, b: &T) -> bool {\n        self(a, b)\n    }\n}"],"<F as visit::filter::FilterEdge<N>>::F":["impl<F, N> FilterEdge<N> for F\nwhere\n    F: Fn(N) -> bool,\n{\n    fn include_edge(&self, n: N) -> bool {\n        (*self)(n)\n    }\n}"],"<F as visit::filter::FilterNode<N>>::F":["impl<F, N> FilterNode<N> for F\nwhere\n    F: Fn(N) -> bool,\n{\n    fn include_node(&self, n: N) -> bool {\n        (*self)(n)\n    }\n}"],"<I as data::ElementIterator<N, E>>::I":["impl<N, E, I: ?Sized> ElementIterator<N, E> for I where I: Iterator<Item = Element<N, E>> {}"],"<I as iter_format::IterFormatExt>::I":["impl<I> IterFormatExt for I where I: Iterator {}"],"<I as iter_utils::IterUtilsExt>::I":["impl<I> IterUtilsExt for I where I: Iterator {}"],"<M as algo::Measure>::M":["impl<M> Measure for M where M: Debug + PartialOrd + Add<M, Output = M> + Default + Clone {}"],"<N as graphmap::NodeTrait>::N":["impl<N> NodeTrait for N where N: Copy + Ord + Hash {}"],"Directed":["Copy","Debug","impl Clone for $name {\n            #[inline]\n            fn clone(&self) -> Self {\n                *self\n            }\n        }","impl EdgeType for Directed {\n    #[inline]\n    fn is_directed() -> bool {\n        true\n    }\n}"],"Direction":["Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Clone for $name {\n            #[inline]\n            fn clone(&self) -> Self {\n                *self\n            }\n        }","impl Direction {\n    /// Return the opposite `Direction`.\n    #[inline]\n    pub fn opposite(self) -> Direction {\n        match self {\n            Outgoing => Incoming,\n            Incoming => Outgoing,\n        }\n    }\n\n    /// Return `0` for `Outgoing` and `1` for `Incoming`.\n    #[inline]\n    pub fn index(self) -> usize {\n        (self as usize) & 0x1\n    }\n}"],"Undirected":["Copy","Debug","impl Clone for $name {\n            #[inline]\n            fn clone(&self) -> Self {\n                *self\n            }\n        }","impl EdgeType for Undirected {\n    #[inline]\n    fn is_directed() -> bool {\n        false\n    }\n}"],"algo::Cycle":["Clone","Debug","PartialEq","impl<N> Cycle<N> {\n    /// Return a node id that participates in the cycle\n    pub fn node_id(&self) -> N\n    where\n        N: Copy,\n    {\n        self.0\n    }\n}"],"algo::DfsSpace":["Clone","Debug","impl<N, VM> Default for DfsSpace<N, VM>\nwhere\n    VM: VisitMap<N> + Default,\n{\n    fn default() -> Self {\n        DfsSpace {\n            dfs: Dfs {\n                stack: <_>::default(),\n                discovered: <_>::default(),\n            },\n        }\n    }\n}","impl<N, VM> DfsSpace<N, VM>\nwhere\n    N: Copy + PartialEq,\n    VM: VisitMap<N>,\n{\n    pub fn new<G>(g: G) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,\n    {\n        DfsSpace { dfs: Dfs::empty(g) }\n    }\n}"],"algo::MinSpanningTree":["impl<G> Iterator for MinSpanningTree<G>\nwhere\n    G: IntoNodeReferences + NodeIndexable,\n    G::NodeWeight: Clone,\n    G::EdgeWeight: PartialOrd,\n{\n    type Item = Element<G::NodeWeight, G::EdgeWeight>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let g = self.graph;\n        if let Some(ref mut iter) = self.node_ids {\n            if let Some(node) = iter.next() {\n                self.node_map.insert(g.to_index(node.id()), self.node_count);\n                self.node_count += 1;\n                return Some(Element::Node {\n                    weight: node.weight().clone(),\n                });\n            }\n        }\n        self.node_ids = None;\n\n        // Kruskal's algorithm.\n        // Algorithm is this:\n        //\n        // 1. Create a pre-MST with all the vertices and no edges.\n        // 2. Repeat:\n        //\n        //  a. Remove the shortest edge from the original graph.\n        //  b. If the edge connects two disjoint trees in the pre-MST,\n        //     add the edge.\n        while let Some(MinScored(score, (a, b))) = self.sort_edges.pop() {\n            // check if the edge would connect two disjoint parts\n            let (a_index, b_index) = (g.to_index(a), g.to_index(b));\n            if self.subgraphs.union(a_index, b_index) {\n                let (&a_order, &b_order) =\n                    match (self.node_map.get(&a_index), self.node_map.get(&b_index)) {\n                        (Some(a_id), Some(b_id)) => (a_id, b_id),\n                        _ => panic!(\"Edge references unknown node\"),\n                    };\n                return Some(Element::Edge {\n                    source: a_order,\n                    target: b_order,\n                    weight: score,\n                });\n            }\n        }\n        None\n    }\n}"],"algo::NegativeCycle":["Clone","Debug","PartialEq"],"algo::dominators::Dominators":["Clone","Debug","impl<N> Dominators<N>\nwhere\n    N: Copy + Eq + Hash,\n{\n    /// Get the root node used to construct these dominance relations.\n    pub fn root(&self) -> N {\n        self.root\n    }\n\n    /// Get the immediate dominator of the given node.\n    ///\n    /// Returns `None` for any node that is not reachable from the root, and for\n    /// the root itself.\n    pub fn immediate_dominator(&self, node: N) -> Option<N> {\n        if node == self.root {\n            None\n        } else {\n            self.dominators.get(&node).cloned()\n        }\n    }\n\n    /// Iterate over the given node's strict dominators.\n    ///\n    /// If the given node is not reachable from the root, then `None` is\n    /// returned.\n    pub fn strict_dominators(&self, node: N) -> Option<DominatorsIter<N>> {\n        if self.dominators.contains_key(&node) {\n            Some(DominatorsIter {\n                dominators: self,\n                node: self.immediate_dominator(node),\n            })\n        } else {\n            None\n        }\n    }\n\n    /// Iterate over all of the given node's dominators (including the given\n    /// node itself).\n    ///\n    /// If the given node is not reachable from the root, then `None` is\n    /// returned.\n    pub fn dominators(&self, node: N) -> Option<DominatorsIter<N>> {\n        if self.dominators.contains_key(&node) {\n            Some(DominatorsIter {\n                dominators: self,\n                node: Some(node),\n            })\n        } else {\n            None\n        }\n    }\n}"],"algo::dominators::DominatorsIter":["impl<'a, N> Iterator for DominatorsIter<'a, N>\nwhere\n    N: 'a + Copy + Eq + Hash,\n{\n    type Item = N;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let next = self.node.take();\n        if let Some(next) = next {\n            self.node = self.dominators.immediate_dominator(next);\n        }\n        next\n    }\n}"],"algo::tarjan_scc::Data":["Debug"],"algo::tarjan_scc::NodeData":["Clone","Copy","Debug"],"astar::PathTracker":["impl<G> PathTracker<G>\nwhere\n    G: GraphBase,\n    G::NodeId: Eq + Hash,\n{\n    fn new() -> PathTracker<G> {\n        PathTracker {\n            came_from: HashMap::new(),\n        }\n    }\n\n    fn set_predecessor(&mut self, node: G::NodeId, previous: G::NodeId) {\n        self.came_from.insert(node, previous);\n    }\n\n    fn reconstruct_path_to(&self, last: G::NodeId) -> Vec<G::NodeId> {\n        let mut path = vec![last];\n\n        let mut current = last;\n        while let Some(&previous) = self.came_from.get(&current) {\n            path.push(previous);\n            current = previous;\n        }\n\n        path.reverse();\n\n        path\n    }\n}"],"csr::Csr":["Debug","impl<N, E, Ix> Csr<N, E, Directed, Ix>\nwhere\n    Ix: IndexType,\n{\n    /// Create a new `Csr` from a sorted sequence of edges\n    ///\n    /// Edges **must** be sorted and unique, where the sort order is the default\n    /// order for the pair *(u, v)* in Rust (*u* has priority).\n    ///\n    /// Computes in **O(|E| + |V|)** time.\n    /// # Example\n    /// ```rust\n    /// use petgraph::csr::Csr;\n    /// use petgraph::prelude::*;\n    ///\n    /// let graph = Csr::<(),()>::from_sorted_edges(&[\n    ///                     (0, 1), (0, 2),\n    ///                     (1, 0), (1, 2), (1, 3),\n    ///                     (2, 0),\n    ///                     (3, 1),\n    /// ]);\n    /// ```\n    pub fn from_sorted_edges<Edge>(edges: &[Edge]) -> Result<Self, EdgesNotSorted>\n    where\n        Edge: Clone + IntoWeightedEdge<E, NodeId = NodeIndex<Ix>>,\n        N: Default,\n    {\n        let max_node_id = match edges\n            .iter()\n            .map(|edge| {\n                let (x, y, _) = edge.clone().into_weighted_edge();\n                max(x.index(), y.index())\n            })\n            .max()\n        {\n            None => return Ok(Self::with_nodes(0)),\n            Some(x) => x,\n        };\n        let mut self_ = Self::with_nodes(max_node_id + 1);\n        let mut iter = edges.iter().cloned().peekable();\n        {\n            let mut rows = self_.row.iter_mut();\n\n            let mut node = 0;\n            let mut rstart = 0;\n            let mut last_target;\n            'outer: for r in &mut rows {\n                *r = rstart;\n                last_target = None;\n                'inner: loop {\n                    if let Some(edge) = iter.peek() {\n                        let (n, m, weight) = edge.clone().into_weighted_edge();\n                        // check that the edges are in increasing sequence\n                        if node > n.index() {\n                            return Err(EdgesNotSorted {\n                                first_error: (n.index(), m.index()),\n                            });\n                        }\n                        /*\n                        debug_assert!(node <= n.index(),\n                                      concat!(\"edges are not sorted, \",\n                                              \"failed assertion source {:?} <= {:?} \",\n                                              \"for edge {:?}\"),\n                                      node, n, (n, m));\n                                      */\n                        if n.index() != node {\n                            break 'inner;\n                        }\n                        // check that the edges are in increasing sequence\n                        /*\n                        debug_assert!(last_target.map_or(true, |x| m > x),\n                                      \"edges are not sorted, failed assertion {:?} < {:?}\",\n                                      last_target, m);\n                                      */\n                        if !last_target.map_or(true, |x| m > x) {\n                            return Err(EdgesNotSorted {\n                                first_error: (n.index(), m.index()),\n                            });\n                        }\n                        last_target = Some(m);\n                        self_.column.push(m);\n                        self_.edges.push(weight);\n                        rstart += 1;\n                    } else {\n                        break 'outer;\n                    }\n                    iter.next();\n                }\n                node += 1;\n            }\n            for r in rows {\n                *r = rstart;\n            }\n        }\n\n        Ok(self_)\n    }\n}","impl<N, E, Ty, Ix> Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    /// Create an empty `Csr`.\n    pub fn new() -> Self {\n        Csr {\n            column: vec![],\n            edges: vec![],\n            row: vec![0; 1],\n            node_weights: vec![],\n            edge_count: 0,\n            ty: PhantomData,\n        }\n    }\n\n    /// Create a new [`Csr`] with `n` nodes. `N` must implement [`Default`] for the weight of each node.\n    ///\n    /// [`Default`]: https://doc.rust-lang.org/nightly/core/default/trait.Default.html\n    /// [`Csr`]: #struct.Csr.html\n    ///\n    /// # Example\n    /// ```rust\n    /// use petgraph::csr::Csr;\n    /// use petgraph::prelude::*;\n    ///\n    /// let graph = Csr::<u8,()>::with_nodes(5);\n    /// assert_eq!(graph.node_count(),5);\n    /// assert_eq!(graph.edge_count(),0);\n    ///\n    /// assert_eq!(graph[0],0);\n    /// assert_eq!(graph[4],0);\n    /// ```\n    pub fn with_nodes(n: usize) -> Self\n    where\n        N: Default,\n    {\n        Csr {\n            column: Vec::new(),\n            edges: Vec::new(),\n            row: vec![0; n + 1],\n            node_weights: (0..n).map(|_| N::default()).collect(),\n            edge_count: 0,\n            ty: PhantomData,\n        }\n    }\n}","impl<N, E, Ty, Ix> Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    pub fn node_count(&self) -> usize {\n        self.row.len() - 1\n    }\n\n    pub fn edge_count(&self) -> usize {\n        if self.is_directed() {\n            self.column.len()\n        } else {\n            self.edge_count\n        }\n    }\n\n    pub fn is_directed(&self) -> bool {\n        Ty::is_directed()\n    }\n\n    /// Remove all edges\n    pub fn clear_edges(&mut self) {\n        self.column.clear();\n        self.edges.clear();\n        for r in &mut self.row {\n            *r = 0;\n        }\n        if !self.is_directed() {\n            self.edge_count = 0;\n        }\n    }\n\n    /// Adds a new node with the given weight, returning the corresponding node index.\n    pub fn add_node(&mut self, weight: N) -> NodeIndex<Ix> {\n        let i = self.row.len() - 1;\n        self.row.insert(i, self.column.len());\n        self.node_weights.insert(i, weight);\n        Ix::new(i)\n    }\n\n    /// Return `true` if the edge was added\n    ///\n    /// If you add all edges in row-major order, the time complexity\n    /// is **O(|V|·|E|)** for the whole operation.\n    ///\n    /// **Panics** if `a` or `b` are out of bounds.\n    pub fn add_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> bool\n    where\n        E: Clone,\n    {\n        let ret = self.add_edge_(a, b, weight.clone());\n        if ret && !self.is_directed() {\n            self.edge_count += 1;\n        }\n        if ret && !self.is_directed() && a != b {\n            let _ret2 = self.add_edge_(b, a, weight);\n            debug_assert_eq!(ret, _ret2);\n        }\n        ret\n    }\n\n    // Return false if the edge already exists\n    fn add_edge_(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> bool {\n        assert!(a.index() < self.node_count() && b.index() < self.node_count());\n        // a x b is at (a, b) in the matrix\n\n        // find current range of edges from a\n        let pos = match self.find_edge_pos(a, b) {\n            Ok(_) => return false, /* already exists */\n            Err(i) => i,\n        };\n        self.column.insert(pos, b);\n        self.edges.insert(pos, weight);\n        // update row vector\n        for r in &mut self.row[a.index() + 1..] {\n            *r += 1;\n        }\n        true\n    }\n\n    fn find_edge_pos(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> Result<usize, usize> {\n        let (index, neighbors) = self.neighbors_of(a);\n        if neighbors.len() < BINARY_SEARCH_CUTOFF {\n            for (i, elt) in neighbors.iter().enumerate() {\n                match elt.cmp(&b) {\n                    Ordering::Equal => return Ok(i + index),\n                    Ordering::Greater => return Err(i + index),\n                    Ordering::Less => {}\n                }\n            }\n            Err(neighbors.len() + index)\n        } else {\n            match neighbors.binary_search(&b) {\n                Ok(i) => Ok(i + index),\n                Err(i) => Err(i + index),\n            }\n        }\n    }\n\n    /// Computes in **O(log |V|)** time.\n    ///\n    /// **Panics** if the node `a` does not exist.\n    pub fn contains_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool {\n        self.find_edge_pos(a, b).is_ok()\n    }\n\n    fn neighbors_range(&self, a: NodeIndex<Ix>) -> Range<usize> {\n        let index = self.row[a.index()];\n        let end = self\n            .row\n            .get(a.index() + 1)\n            .cloned()\n            .unwrap_or_else(|| self.column.len());\n        index..end\n    }\n\n    fn neighbors_of(&self, a: NodeIndex<Ix>) -> (usize, &[Ix]) {\n        let r = self.neighbors_range(a);\n        (r.start, &self.column[r])\n    }\n\n    /// Computes in **O(1)** time.\n    ///\n    /// **Panics** if the node `a` does not exist.\n    pub fn out_degree(&self, a: NodeIndex<Ix>) -> usize {\n        let r = self.neighbors_range(a);\n        r.end - r.start\n    }\n\n    /// Computes in **O(1)** time.\n    ///\n    /// **Panics** if the node `a` does not exist.\n    pub fn neighbors_slice(&self, a: NodeIndex<Ix>) -> &[NodeIndex<Ix>] {\n        self.neighbors_of(a).1\n    }\n\n    /// Computes in **O(1)** time.\n    ///\n    /// **Panics** if the node `a` does not exist.\n    pub fn edges_slice(&self, a: NodeIndex<Ix>) -> &[E] {\n        &self.edges[self.neighbors_range(a)]\n    }\n\n    /// Return an iterator of all edges of `a`.\n    ///\n    /// - `Directed`: Outgoing edges from `a`.\n    /// - `Undirected`: All edges connected to `a`.\n    ///\n    /// **Panics** if the node `a` does not exist.<br>\n    /// Iterator element type is `EdgeReference<E, Ty, Ix>`.\n    pub fn edges(&self, a: NodeIndex<Ix>) -> Edges<E, Ty, Ix> {\n        let r = self.neighbors_range(a);\n        Edges {\n            index: r.start,\n            source: a,\n            iter: zip(&self.column[r.clone()], &self.edges[r]),\n            ty: self.ty,\n        }\n    }\n}","impl<N, E, Ty, Ix> Data for Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type NodeWeight = N;\n    type EdgeWeight = E;\n}","impl<N, E, Ty, Ix> Default for Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn default() -> Self {\n        Self::new()\n    }\n}","impl<N, E, Ty, Ix> GraphBase for Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type NodeId = NodeIndex<Ix>;\n    type EdgeId = EdgeIndex; // index into edges vector\n}","impl<N, E, Ty, Ix> GraphProp for Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type EdgeType = Ty;\n}","impl<N, E, Ty, Ix> Index<NodeIndex<Ix>> for Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Output = N;\n\n    fn index(&self, ix: NodeIndex<Ix>) -> &N {\n        &self.node_weights[ix.index()]\n    }\n}","impl<N, E, Ty, Ix> IndexMut<NodeIndex<Ix>> for Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn index_mut(&mut self, ix: NodeIndex<Ix>) -> &mut N {\n        &mut self.node_weights[ix.index()]\n    }\n}","impl<N, E, Ty, Ix> NodeCompactIndexable for Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n}","impl<N, E, Ty, Ix> NodeCount for Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn node_count(&self) -> usize {\n        (*self).node_count()\n    }\n}","impl<N, E, Ty, Ix> NodeIndexable for Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn node_bound(&self) -> usize {\n        self.node_count()\n    }\n    fn to_index(&self, a: Self::NodeId) -> usize {\n        a.index()\n    }\n    fn from_index(&self, ix: usize) -> Self::NodeId {\n        Ix::new(ix)\n    }\n}","impl<N, E, Ty, Ix> Visitable for Csr<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Map = FixedBitSet;\n    fn visit_map(&self) -> FixedBitSet {\n        FixedBitSet::with_capacity(self.node_count())\n    }\n    fn reset_map(&self, map: &mut Self::Map) {\n        map.clear();\n        map.grow(self.node_count());\n    }\n}","impl<N: Clone, E: Clone, Ty, Ix: Clone> Clone for Csr<N, E, Ty, Ix> {\n    fn clone(&self) -> Self {\n        Csr {\n            column: self.column.clone(),\n            edges: self.edges.clone(),\n            row: self.row.clone(),\n            node_weights: self.node_weights.clone(),\n            edge_count: self.edge_count,\n            ty: self.ty,\n        }\n    }\n}"],"csr::EdgeReference":["Debug","impl<'a, E, Ty, Ix: Copy> Clone for EdgeReference<'a, E, Ty, Ix> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}","impl<'a, E, Ty, Ix: Copy> Copy for EdgeReference<'a, E, Ty, Ix> {}","impl<'a, E, Ty, Ix> EdgeRef for EdgeReference<'a, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type NodeId = NodeIndex<Ix>;\n    type EdgeId = EdgeIndex;\n    type Weight = E;\n\n    fn source(&self) -> Self::NodeId {\n        self.source\n    }\n    fn target(&self) -> Self::NodeId {\n        self.target\n    }\n    fn weight(&self) -> &E {\n        self.weight\n    }\n    fn id(&self) -> Self::EdgeId {\n        self.index\n    }\n}","impl<'a, Ty, E, Ix> EdgeReference<'a, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n{\n    /// Access the edge’s weight.\n    ///\n    /// **NOTE** that this method offers a longer lifetime\n    /// than the trait (unfortunately they don't match yet).\n    pub fn weight(&self) -> &'a E {\n        self.weight\n    }\n}"],"csr::EdgeReferences":["impl<'a, E, Ty, Ix> Iterator for EdgeReferences<'a, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Item = EdgeReference<'a, E, Ty, Ix>;\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            if let Some((&j, w)) = self.iter.next() {\n                let index = self.index;\n                self.index += 1;\n                return Some(EdgeReference {\n                    index,\n                    source: self.source_index,\n                    target: j,\n                    weight: w,\n                    ty: PhantomData,\n                });\n            }\n            if let Some((i, w)) = self.edge_ranges.next() {\n                let a = w[0];\n                let b = w[1];\n                self.iter = zip(&self.column[a..b], &self.edges[a..b]);\n                self.source_index = Ix::new(i);\n            } else {\n                return None;\n            }\n        }\n    }\n}"],"csr::Edges":["Clone","Debug","impl<'a, E, Ty, Ix> Iterator for Edges<'a, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Item = EdgeReference<'a, E, Ty, Ix>;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(move |(&j, w)| {\n            let index = self.index;\n            self.index += 1;\n            EdgeReference {\n                index,\n                source: self.source,\n                target: j,\n                weight: w,\n                ty: PhantomData,\n            }\n        })\n    }\n}"],"csr::EdgesNotSorted":["Clone","Debug"],"csr::Neighbors":["Clone","Debug","impl<'a, Ix> Iterator for Neighbors<'a, Ix>\nwhere\n    Ix: IndexType,\n{\n    type Item = NodeIndex<Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().cloned()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}"],"csr::NodeIdentifiers":["impl<Ix> Iterator for NodeIdentifiers<Ix>\nwhere\n    Ix: IndexType,\n{\n    type Item = NodeIndex<Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.r.next().map(Ix::new)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.r.size_hint()\n    }\n}"],"data::Element":["Clone","Debug","Eq","PartialEq"],"data::FilterElements":["impl<I, F, N, E> Iterator for FilterElements<I, F>\nwhere\n    I: Iterator<Item = Element<N, E>>,\n    F: FnMut(Element<&mut N, &mut E>) -> bool,\n{\n    type Item = Element<N, E>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            let mut elt = match self.iter.next() {\n                None => return None,\n                Some(elt) => elt,\n            };\n            let keep = (self.f)(match elt {\n                Element::Node { ref mut weight } => Element::Node { weight },\n                Element::Edge {\n                    source,\n                    target,\n                    ref mut weight,\n                } => Element::Edge {\n                    source,\n                    target,\n                    weight,\n                },\n            });\n            let is_node = if let Element::Node { .. } = elt {\n                true\n            } else {\n                false\n            };\n            if !keep && is_node {\n                self.map.push(self.node_index);\n            }\n            if is_node {\n                self.node_index += 1;\n            }\n            if !keep {\n                continue;\n            }\n\n            // map edge parts\n            match elt {\n                Element::Edge {\n                    ref mut source,\n                    ref mut target,\n                    ..\n                } => {\n                    // Find the node indices in the map of removed ones.\n                    // If a node was removed, the edge is as well.\n                    // Otherwise the counts are adjusted by the number of nodes\n                    // removed.\n                    // Example: map: [1, 3, 4, 6]\n                    // binary search for 2, result is Err(1). One node has been\n                    // removed before 2.\n                    match self.map.binary_search(source) {\n                        Ok(_) => continue,\n                        Err(i) => *source -= i,\n                    }\n                    match self.map.binary_search(target) {\n                        Ok(_) => continue,\n                        Err(i) => *target -= i,\n                    }\n                }\n                Element::Node { .. } => {}\n            }\n            return Some(elt);\n        }\n    }\n}"],"dot::Config":["Debug","Eq","PartialEq"],"dot::DebugFmt":["impl<T> fmt::Display for DebugFmt<T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}"],"dot::Dot":["impl<'a, G> Dot<'a, G>\nwhere\n    G: GraphBase + IntoNodeReferences + IntoEdgeReferences,\n{\n    fn graph_fmt<NF, EF, NW, EW>(\n        &self,\n        g: G,\n        f: &mut fmt::Formatter,\n        mut node_fmt: NF,\n        mut edge_fmt: EF,\n    ) -> fmt::Result\n    where\n        G: NodeIndexable + IntoNodeReferences + IntoEdgeReferences,\n        G: GraphProp + GraphBase,\n        G: Data<NodeWeight = NW, EdgeWeight = EW>,\n        NF: FnMut(&NW, &mut dyn FnMut(&dyn Display) -> fmt::Result) -> fmt::Result,\n        EF: FnMut(&EW, &mut dyn FnMut(&dyn Display) -> fmt::Result) -> fmt::Result,\n    {\n        if !self.config.contains(&Config::GraphContentOnly) {\n            writeln!(f, \"{} {{\", TYPE[g.is_directed() as usize])?;\n        }\n\n        // output all labels\n        for node in g.node_references() {\n            write!(f, \"{}{} [ \", INDENT, g.to_index(node.id()),)?;\n            if !self.config.contains(&Config::NodeNoLabel) {\n                write!(f, \"label = \\\"\")?;\n                if self.config.contains(&Config::NodeIndexLabel) {\n                    write!(f, \"{}\", g.to_index(node.id()))?;\n                } else {\n                    node_fmt(node.weight(), &mut |d| Escaped(d).fmt(f))?;\n                }\n                write!(f, \"\\\" \")?;\n            }\n            writeln!(f, \"{}]\", (self.get_node_attributes)(g, node))?;\n        }\n        // output all edges\n        for (i, edge) in g.edge_references().enumerate() {\n            write!(\n                f,\n                \"{}{} {} {} [ \",\n                INDENT,\n                g.to_index(edge.source()),\n                EDGE[g.is_directed() as usize],\n                g.to_index(edge.target()),\n            )?;\n            if !self.config.contains(&Config::EdgeNoLabel) {\n                write!(f, \"label = \\\"\")?;\n                if self.config.contains(&Config::EdgeIndexLabel) {\n                    write!(f, \"{}\", i)?;\n                } else {\n                    edge_fmt(edge.weight(), &mut |d| Escaped(d).fmt(f))?;\n                }\n                write!(f, \"\\\" \")?;\n            }\n            writeln!(f, \"{}]\", (self.get_edge_attributes)(g, edge))?;\n        }\n\n        if !self.config.contains(&Config::GraphContentOnly) {\n            writeln!(f, \"}}\")?;\n        }\n        Ok(())\n    }\n}","impl<'a, G> Dot<'a, G>\nwhere\n    G: GraphRef + IntoEdgeReferences + IntoNodeReferences,\n{\n    /// Create a `Dot` formatting wrapper with default configuration.\n    pub fn new(graph: G) -> Self {\n        Self::with_config(graph, &[])\n    }\n\n    /// Create a `Dot` formatting wrapper with custom configuration.\n    pub fn with_config(graph: G, config: &'a [Config]) -> Self {\n        Self::with_attr_getters(graph, config, &|_, _| \"\".to_string(), &|_, _| {\n            \"\".to_string()\n        })\n    }\n\n    pub fn with_attr_getters(\n        graph: G,\n        config: &'a [Config],\n        get_edge_attributes: &'a dyn Fn(G, G::EdgeRef) -> String,\n        get_node_attributes: &'a dyn Fn(G, G::NodeRef) -> String,\n    ) -> Self {\n        Dot {\n            graph,\n            config,\n            get_edge_attributes,\n            get_node_attributes,\n        }\n    }\n}","impl<'a, G> fmt::Debug for Dot<'a, G>\nwhere\n    G: IntoEdgeReferences + IntoNodeReferences + NodeIndexable + GraphProp,\n    G::EdgeWeight: fmt::Debug,\n    G::NodeWeight: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.graph_fmt(\n            self.graph,\n            f,\n            |n, cb| cb(&DebugFmt(n)),\n            |e, cb| cb(&DebugFmt(e)),\n        )\n    }\n}","impl<'a, G> fmt::Display for Dot<'a, G>\nwhere\n    G: IntoEdgeReferences + IntoNodeReferences + NodeIndexable + GraphProp,\n    G::EdgeWeight: fmt::Display,\n    G::NodeWeight: fmt::Display,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.graph_fmt(self.graph, f, |n, cb| cb(n), |e, cb| cb(e))\n    }\n}"],"dot::Escaped":["impl<T> fmt::Display for Escaped<T>\nwhere\n    T: fmt::Display,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if f.alternate() {\n            writeln!(&mut Escaper(f), \"{:#}\", &self.0)\n        } else {\n            write!(&mut Escaper(f), \"{}\", &self.0)\n        }\n    }\n}"],"dot::Escaper":["impl<W> fmt::Write for Escaper<W>\nwhere\n    W: fmt::Write,\n{\n    fn write_str(&mut self, s: &str) -> fmt::Result {\n        for c in s.chars() {\n            self.write_char(c)?;\n        }\n        Ok(())\n    }\n\n    fn write_char(&mut self, c: char) -> fmt::Result {\n        match c {\n            '\"' | '\\\\' => self.0.write_char('\\\\')?,\n            // \\l is for left justified linebreak\n            '\\n' => return self.0.write_str(\"\\\\l\"),\n            _ => {}\n        }\n        self.0.write_char(c)\n    }\n}"],"fixedbitset::FixedBitSet":["impl<Ix> VisitMap<Ix> for FixedBitSet\nwhere\n    Ix: IndexType,\n{\n    fn visit(&mut self, x: Ix) -> bool {\n        !self.put(x.index())\n    }\n    fn is_visited(&self, x: &Ix) -> bool {\n        self.contains(x.index())\n    }\n}","impl<Ix> VisitMap<graph::EdgeIndex<Ix>> for FixedBitSet\nwhere\n    Ix: IndexType,\n{\n    fn visit(&mut self, x: graph::EdgeIndex<Ix>) -> bool {\n        !self.put(x.index())\n    }\n    fn is_visited(&self, x: &graph::EdgeIndex<Ix>) -> bool {\n        self.contains(x.index())\n    }\n}","impl<Ix> VisitMap<graph::NodeIndex<Ix>> for FixedBitSet\nwhere\n    Ix: IndexType,\n{\n    fn visit(&mut self, x: graph::NodeIndex<Ix>) -> bool {\n        !self.put(x.index())\n    }\n    fn is_visited(&self, x: &graph::NodeIndex<Ix>) -> bool {\n        self.contains(x.index())\n    }\n}","impl<N> FilterNode<N> for FixedBitSet\nwhere\n    FixedBitSet: VisitMap<N>,\n{\n    fn include_node(&self, n: N) -> bool {\n        self.is_visited(&n)\n    }\n}"],"graph_impl::Edge":["Debug","impl<E, Ix: IndexType> Edge<E, Ix> {\n    /// Accessor for data structure internals: the next edge for the given direction.\n    pub fn next_edge(&self, dir: Direction) -> EdgeIndex<Ix> {\n        self.next[dir.index()]\n    }\n\n    /// Return the source node index.\n    pub fn source(&self) -> NodeIndex<Ix> {\n        self.node[0]\n    }\n\n    /// Return the target node index.\n    pub fn target(&self) -> NodeIndex<Ix> {\n        self.node[1]\n    }\n}","impl<E, Ix> Clone for Edge<E, Ix>\nwhere\n    E: Clone,\n    Ix: Copy,\n{\n    clone_fields!(Edge, weight, next, node,);\n}"],"graph_impl::EdgeIndex":["Clone","Copy","Default","Eq","Hash","Ord","PartialEq","PartialOrd","impl<Ix: IndexType> EdgeIndex<Ix> {\n    #[inline]\n    pub fn new(x: usize) -> Self {\n        EdgeIndex(IndexType::new(x))\n    }\n\n    #[inline]\n    pub fn index(self) -> usize {\n        self.0.index()\n    }\n\n    /// An invalid `EdgeIndex` used to denote absence of an edge, for example\n    /// to end an adjacency list.\n    #[inline]\n    pub fn end() -> Self {\n        EdgeIndex(IndexType::max())\n    }\n\n    fn _into_node(self) -> NodeIndex<Ix> {\n        NodeIndex(self.0)\n    }\n}","impl<Ix: IndexType> From<Ix> for EdgeIndex<Ix> {\n    fn from(ix: Ix) -> Self {\n        EdgeIndex(ix)\n    }\n}","impl<Ix: IndexType> GraphIndex for EdgeIndex<Ix> {\n    #[inline]\n    fn index(&self) -> usize {\n        EdgeIndex::index(*self)\n    }\n    #[inline]\n    fn is_node_index() -> bool {\n        false\n    }\n}","impl<Ix: fmt::Debug> fmt::Debug for EdgeIndex<Ix> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"EdgeIndex({:?})\", self.0)\n    }\n}"],"graph_impl::EdgeIndices":["Clone","Debug","impl<Ix: IndexType> DoubleEndedIterator for EdgeIndices<Ix> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.r.next_back().map(edge_index)\n    }\n}","impl<Ix: IndexType> ExactSizeIterator for EdgeIndices<Ix> {}","impl<Ix: IndexType> Iterator for EdgeIndices<Ix> {\n    type Item = EdgeIndex<Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.r.next().map(edge_index)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.r.size_hint()\n    }\n}"],"graph_impl::EdgeReference":["Debug","impl<'a, E, Ix: IndexType> Clone for EdgeReference<'a, E, Ix> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}","impl<'a, E, Ix: IndexType> Copy for EdgeReference<'a, E, Ix> {}","impl<'a, E, Ix: IndexType> PartialEq for EdgeReference<'a, E, Ix>\nwhere\n    E: PartialEq,\n{\n    fn eq(&self, rhs: &Self) -> bool {\n        self.index == rhs.index && self.weight == rhs.weight\n    }\n}","impl<'a, Ix, E> EdgeRef for EdgeReference<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    type NodeId = NodeIndex<Ix>;\n    type EdgeId = EdgeIndex<Ix>;\n    type Weight = E;\n\n    fn source(&self) -> Self::NodeId {\n        self.node[0]\n    }\n    fn target(&self) -> Self::NodeId {\n        self.node[1]\n    }\n    fn weight(&self) -> &E {\n        self.weight\n    }\n    fn id(&self) -> Self::EdgeId {\n        self.index\n    }\n}","impl<'a, Ix, E> EdgeReference<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    /// Access the edge’s weight.\n    ///\n    /// **NOTE** that this method offers a longer lifetime\n    /// than the trait (unfortunately they don't match yet).\n    pub fn weight(&self) -> &'a E {\n        self.weight\n    }\n}"],"graph_impl::EdgeReferences":["impl<'a, E, Ix> DoubleEndedIterator for EdgeReferences<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.next_back().map(|(i, edge)| EdgeReference {\n            index: edge_index(i),\n            node: edge.node,\n            weight: &edge.weight,\n        })\n    }\n}","impl<'a, E, Ix> ExactSizeIterator for EdgeReferences<'a, E, Ix> where Ix: IndexType {}","impl<'a, E, Ix> Iterator for EdgeReferences<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    type Item = EdgeReference<'a, E, Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|(i, edge)| EdgeReference {\n            index: edge_index(i),\n            node: edge.node,\n            weight: &edge.weight,\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}"],"graph_impl::EdgeWeightsMut":["impl<'a, E, Ix> Iterator for EdgeWeightsMut<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    type Item = &'a mut E;\n\n    fn next(&mut self) -> Option<&'a mut E> {\n        self.edges.next().map(|edge| &mut edge.weight)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.edges.size_hint()\n    }\n}"],"graph_impl::Edges":["impl<'a, E, Ty, Ix> Clone for Edges<'a, E, Ty, Ix>\nwhere\n    Ix: IndexType,\n    Ty: EdgeType,\n{\n    fn clone(&self) -> Self {\n        Edges {\n            skip_start: self.skip_start,\n            edges: self.edges,\n            next: self.next,\n            direction: self.direction,\n            ty: self.ty,\n        }\n    }\n}","impl<'a, E, Ty, Ix> Iterator for Edges<'a, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Item = EdgeReference<'a, E, Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        //      type        direction    |    iterate over    reverse\n        //                               |\n        //    Directed      Outgoing     |      outgoing        no\n        //    Directed      Incoming     |      incoming        no\n        //   Undirected     Outgoing     |        both       incoming\n        //   Undirected     Incoming     |        both       outgoing\n\n        // For iterate_over, \"both\" is represented as None.\n        // For reverse, \"no\" is represented as None.\n        let (iterate_over, reverse) = if Ty::is_directed() {\n            (Some(self.direction), None)\n        } else {\n            (None, Some(self.direction.opposite()))\n        };\n\n        if iterate_over.unwrap_or(Outgoing) == Outgoing {\n            let i = self.next[0].index();\n            if let Some(Edge { node, weight, next }) = self.edges.get(i) {\n                self.next[0] = next[0];\n                return Some(EdgeReference {\n                    index: edge_index(i),\n                    node: if reverse == Some(Outgoing) {\n                        swap_pair(*node)\n                    } else {\n                        *node\n                    },\n                    weight,\n                });\n            }\n        }\n\n        if iterate_over.unwrap_or(Incoming) == Incoming {\n            while let Some(Edge { node, weight, next }) = self.edges.get(self.next[1].index()) {\n                let edge_index = self.next[1];\n                self.next[1] = next[1];\n                // In any of the \"both\" situations, self-loops would be iterated over twice.\n                // Skip them here.\n                if iterate_over.is_none() && node[0] == self.skip_start {\n                    continue;\n                }\n\n                return Some(EdgeReference {\n                    index: edge_index,\n                    node: if reverse == Some(Incoming) {\n                        swap_pair(*node)\n                    } else {\n                        *node\n                    },\n                    weight,\n                });\n            }\n        }\n\n        None\n    }\n}"],"graph_impl::EdgesConnecting":["impl<'a, E, Ty, Ix> Iterator for EdgesConnecting<'a, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Item = EdgeReference<'a, E, Ix>;\n\n    fn next(&mut self) -> Option<EdgeReference<'a, E, Ix>> {\n        while let Some(edge) = self.edges.next() {\n            if edge.node[1] == self.target_node {\n                return Some(edge);\n            }\n        }\n\n        None\n    }\n}"],"graph_impl::EdgesWalkerMut":["impl<'a, E, Ix> EdgesWalkerMut<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    fn next_edge(&mut self) -> Option<&mut Edge<E, Ix>> {\n        self.next().map(|t| t.1)\n    }\n\n    fn next(&mut self) -> Option<(EdgeIndex<Ix>, &mut Edge<E, Ix>)> {\n        let this_index = self.next;\n        let k = self.dir.index();\n        match self.edges.get_mut(self.next.index()) {\n            None => None,\n            Some(edge) => {\n                self.next = edge.next[k];\n                Some((this_index, edge))\n            }\n        }\n    }\n}"],"graph_impl::Externals":["impl<'a, N: 'a, Ty, Ix> Iterator for Externals<'a, N, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Item = NodeIndex<Ix>;\n    fn next(&mut self) -> Option<NodeIndex<Ix>> {\n        let k = self.dir.index();\n        loop {\n            match self.iter.next() {\n                None => return None,\n                Some((index, node)) => {\n                    if node.next[k] == EdgeIndex::end()\n                        && (Ty::is_directed() || node.next[1 - k] == EdgeIndex::end())\n                    {\n                        return Some(NodeIndex::new(index));\n                    } else {\n                        continue;\n                    }\n                }\n            }\n        }\n    }\n}"],"graph_impl::Frozen":["impl<$($param)*> $name for $self_wrap where $self_type: $name {\n            $(\n            $(\n                type $assoc_name = $self_type::$assoc_name;\n            )*\n            )*\n            $(\n                type $assoc_name_ext = $self_type::$assoc_name_ext;\n            )*\n            $(\n            $(\n                fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret)? {\n                    $self_map!(self).$method_name($($marg),*)\n                }\n            )*\n            )*\n        }","impl<'a, G, I> Index<I> for Frozen<'a, G>\nwhere\n    G: Index<I>,\n{\n    type Output = G::Output;\n    fn index(&self, i: I) -> &G::Output {\n        self.0.index(i)\n    }\n}","impl<'a, G, I> IndexMut<I> for Frozen<'a, G>\nwhere\n    G: IndexMut<I>,\n{\n    fn index_mut(&mut self, i: I) -> &mut G::Output {\n        self.0.index_mut(i)\n    }\n}","impl<'a, G> Deref for Frozen<'a, G> {\n    type Target = G;\n    fn deref(&self) -> &G {\n        self.0\n    }\n}","impl<'a, G> Frozen<'a, G> {\n    /// Create a new `Frozen` from a mutable reference to a graph.\n    pub fn new(gr: &'a mut G) -> Self {\n        Frozen(gr)\n    }\n}","impl<'a, G> GraphBase for Frozen<'a, G>\nwhere\n    G: GraphBase,\n{\n    type NodeId = G::NodeId;\n    type EdgeId = G::EdgeId;\n}","impl<'a, N, E, Ty, Ix> Frozen<'a, Graph<N, E, Ty, Ix>>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    /// Index the `Graph` by two indices, any combination of\n    /// node or edge indices is fine.\n    ///\n    /// **Panics** if the indices are equal or if they are out of bounds.\n    pub fn index_twice_mut<T, U>(\n        &mut self,\n        i: T,\n        j: U,\n    ) -> (\n        &mut <Graph<N, E, Ty, Ix> as Index<T>>::Output,\n        &mut <Graph<N, E, Ty, Ix> as Index<U>>::Output,\n    )\n    where\n        Graph<N, E, Ty, Ix>: IndexMut<T> + IndexMut<U>,\n        T: GraphIndex,\n        U: GraphIndex,\n    {\n        self.0.index_twice_mut(i, j)\n    }\n}"],"graph_impl::Graph":["impl<N, E, Ty, Ix: IndexType> Clone for Graph<N, E, Ty, Ix>\nwhere\n    N: Clone,\n    E: Clone,\n{\n    fn clone(&self) -> Self {\n        Graph {\n            nodes: self.nodes.clone(),\n            edges: self.edges.clone(),\n            ty: self.ty,\n        }\n    }\n\n    fn clone_from(&mut self, rhs: &Self) {\n        self.nodes.clone_from(&rhs.nodes);\n        self.edges.clone_from(&rhs.edges);\n        self.ty = rhs.ty;\n    }\n}","impl<N, E, Ty, Ix> Build for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn add_node(&mut self, weight: Self::NodeWeight) -> Self::NodeId {\n        self.add_node(weight)\n    }\n    fn add_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Option<Self::EdgeId> {\n        Some(self.add_edge(a, b, weight))\n    }\n    fn update_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Self::EdgeId {\n        self.update_edge(a, b, weight)\n    }\n}","impl<N, E, Ty, Ix> Create for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn with_capacity(nodes: usize, edges: usize) -> Self {\n        Self::with_capacity(nodes, edges)\n    }\n}","impl<N, E, Ty, Ix> Data for Graph<N, E, Ty, Ix>\nwhere\n    Ix: IndexType,\n{\n    type NodeWeight = N;\n    type EdgeWeight = E;\n}","impl<N, E, Ty, Ix> DataMap for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn node_weight(&self, id: Self::NodeId) -> Option<&Self::NodeWeight> {\n        self.node_weight(id)\n    }\n    fn edge_weight(&self, id: Self::EdgeId) -> Option<&Self::EdgeWeight> {\n        self.edge_weight(id)\n    }\n}","impl<N, E, Ty, Ix> DataMapMut for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn node_weight_mut(&mut self, id: Self::NodeId) -> Option<&mut Self::NodeWeight> {\n        self.node_weight_mut(id)\n    }\n    fn edge_weight_mut(&mut self, id: Self::EdgeId) -> Option<&mut Self::EdgeWeight> {\n        self.edge_weight_mut(id)\n    }\n}","impl<N, E, Ty, Ix> Default for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn default() -> Self {\n        Self::with_capacity(0, 0)\n    }\n}","impl<N, E, Ty, Ix> From<StableGraph<N, E, Ty, Ix>> for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn from(graph: StableGraph<N, E, Ty, Ix>) -> Self {\n        let mut result_g = Graph::with_capacity(graph.node_count(), graph.edge_count());\n        // mapping from old node index to new node index\n        let mut node_index_map = vec![NodeIndex::end(); graph.node_bound()];\n\n        for (i, node) in enumerate(graph.g.nodes) {\n            if let Some(nw) = node.weight {\n                node_index_map[i] = result_g.add_node(nw);\n            }\n        }\n        for edge in graph.g.edges {\n            let source_index = edge.source().index();\n            let target_index = edge.target().index();\n            if let Some(ew) = edge.weight {\n                let source = node_index_map[source_index];\n                let target = node_index_map[target_index];\n                debug_assert!(source != NodeIndex::end());\n                debug_assert!(target != NodeIndex::end());\n                result_g.add_edge(source, target, ew);\n            }\n        }\n        result_g\n    }\n}","impl<N, E, Ty, Ix> FromElements for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn from_elements<I>(iterable: I) -> Self\n    where\n        Self: Sized,\n        I: IntoIterator<Item = Element<Self::NodeWeight, Self::EdgeWeight>>,\n    {\n        from_elements_indexable(iterable)\n    }\n}","impl<N, E, Ty, Ix> GetAdjacencyMatrix for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type AdjMatrix = FixedBitSet;\n\n    fn adjacency_matrix(&self) -> FixedBitSet {\n        let n = self.node_count();\n        let mut matrix = FixedBitSet::with_capacity(n * n);\n        for edge in self.edge_references() {\n            let i = edge.source().index() * n + edge.target().index();\n            matrix.put(i);\n            if !self.is_directed() {\n                let j = edge.source().index() + n * edge.target().index();\n                matrix.put(j);\n            }\n        }\n        matrix\n    }\n\n    fn is_adjacent(&self, matrix: &FixedBitSet, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool {\n        let n = self.node_count();\n        let index = n * a.index() + b.index();\n        matrix.contains(index)\n    }\n}","impl<N, E, Ty, Ix> Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    /// Create a new `Graph` with estimated capacity.\n    pub fn with_capacity(nodes: usize, edges: usize) -> Self {\n        Graph {\n            nodes: Vec::with_capacity(nodes),\n            edges: Vec::with_capacity(edges),\n            ty: PhantomData,\n        }\n    }\n\n    /// Return the number of nodes (vertices) in the graph.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn node_count(&self) -> usize {\n        self.nodes.len()\n    }\n\n    /// Return the number of edges in the graph.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn edge_count(&self) -> usize {\n        self.edges.len()\n    }\n\n    /// Whether the graph has directed edges or not.\n    #[inline]\n    pub fn is_directed(&self) -> bool {\n        Ty::is_directed()\n    }\n\n    /// Add a node (also called vertex) with associated data `weight` to the graph.\n    ///\n    /// Computes in **O(1)** time.\n    ///\n    /// Return the index of the new node.\n    ///\n    /// **Panics** if the Graph is at the maximum number of nodes for its index\n    /// type (N/A if usize).\n    pub fn add_node(&mut self, weight: N) -> NodeIndex<Ix> {\n        let node = Node {\n            weight,\n            next: [EdgeIndex::end(), EdgeIndex::end()],\n        };\n        let node_idx = NodeIndex::new(self.nodes.len());\n        // check for max capacity, except if we use usize\n        assert!(<Ix as IndexType>::max().index() == !0 || NodeIndex::end() != node_idx);\n        self.nodes.push(node);\n        node_idx\n    }\n\n    /// Access the weight for node `a`.\n    ///\n    /// Also available with indexing syntax: `&graph[a]`.\n    pub fn node_weight(&self, a: NodeIndex<Ix>) -> Option<&N> {\n        self.nodes.get(a.index()).map(|n| &n.weight)\n    }\n\n    /// Access the weight for node `a`, mutably.\n    ///\n    /// Also available with indexing syntax: `&mut graph[a]`.\n    pub fn node_weight_mut(&mut self, a: NodeIndex<Ix>) -> Option<&mut N> {\n        self.nodes.get_mut(a.index()).map(|n| &mut n.weight)\n    }\n\n    /// Add an edge from `a` to `b` to the graph, with its associated\n    /// data `weight`.\n    ///\n    /// Return the index of the new edge.\n    ///\n    /// Computes in **O(1)** time.\n    ///\n    /// **Panics** if any of the nodes don't exist.<br>\n    /// **Panics** if the Graph is at the maximum number of edges for its index\n    /// type (N/A if usize).\n    ///\n    /// **Note:** `Graph` allows adding parallel (“duplicate”) edges. If you want\n    /// to avoid this, use [`.update_edge(a, b, weight)`](#method.update_edge) instead.\n    pub fn add_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> EdgeIndex<Ix> {\n        let edge_idx = EdgeIndex::new(self.edges.len());\n        assert!(<Ix as IndexType>::max().index() == !0 || EdgeIndex::end() != edge_idx);\n        let mut edge = Edge {\n            weight,\n            node: [a, b],\n            next: [EdgeIndex::end(); 2],\n        };\n        match index_twice(&mut self.nodes, a.index(), b.index()) {\n            Pair::None => panic!(\"Graph::add_edge: node indices out of bounds\"),\n            Pair::One(an) => {\n                edge.next = an.next;\n                an.next[0] = edge_idx;\n                an.next[1] = edge_idx;\n            }\n            Pair::Both(an, bn) => {\n                // a and b are different indices\n                edge.next = [an.next[0], bn.next[1]];\n                an.next[0] = edge_idx;\n                bn.next[1] = edge_idx;\n            }\n        }\n        self.edges.push(edge);\n        edge_idx\n    }\n\n    /// Add or update an edge from `a` to `b`.\n    /// If the edge already exists, its weight is updated.\n    ///\n    /// Return the index of the affected edge.\n    ///\n    /// Computes in **O(e')** time, where **e'** is the number of edges\n    /// connected to `a` (and `b`, if the graph edges are undirected).\n    ///\n    /// **Panics** if any of the nodes don't exist.\n    pub fn update_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> EdgeIndex<Ix> {\n        if let Some(ix) = self.find_edge(a, b) {\n            if let Some(ed) = self.edge_weight_mut(ix) {\n                *ed = weight;\n                return ix;\n            }\n        }\n        self.add_edge(a, b, weight)\n    }\n\n    /// Access the weight for edge `e`.\n    ///\n    /// Also available with indexing syntax: `&graph[e]`.\n    pub fn edge_weight(&self, e: EdgeIndex<Ix>) -> Option<&E> {\n        self.edges.get(e.index()).map(|ed| &ed.weight)\n    }\n\n    /// Access the weight for edge `e`, mutably.\n    ///\n    /// Also available with indexing syntax: `&mut graph[e]`.\n    pub fn edge_weight_mut(&mut self, e: EdgeIndex<Ix>) -> Option<&mut E> {\n        self.edges.get_mut(e.index()).map(|ed| &mut ed.weight)\n    }\n\n    /// Access the source and target nodes for `e`.\n    pub fn edge_endpoints(&self, e: EdgeIndex<Ix>) -> Option<(NodeIndex<Ix>, NodeIndex<Ix>)> {\n        self.edges\n            .get(e.index())\n            .map(|ed| (ed.source(), ed.target()))\n    }\n\n    /// Remove `a` from the graph if it exists, and return its weight.\n    /// If it doesn't exist in the graph, return `None`.\n    ///\n    /// Apart from `a`, this invalidates the last node index in the graph\n    /// (that node will adopt the removed node index). Edge indices are\n    /// invalidated as they would be following the removal of each edge\n    /// with an endpoint in `a`.\n    ///\n    /// Computes in **O(e')** time, where **e'** is the number of affected\n    /// edges, including *n* calls to `.remove_edge()` where *n* is the number\n    /// of edges with an endpoint in `a`, and including the edges with an\n    /// endpoint in the displaced node.\n    pub fn remove_node(&mut self, a: NodeIndex<Ix>) -> Option<N> {\n        self.nodes.get(a.index())?;\n        for d in &DIRECTIONS {\n            let k = d.index();\n\n            // Remove all edges from and to this node.\n            loop {\n                let next = self.nodes[a.index()].next[k];\n                if next == EdgeIndex::end() {\n                    break;\n                }\n                let ret = self.remove_edge(next);\n                debug_assert!(ret.is_some());\n                let _ = ret;\n            }\n        }\n\n        // Use swap_remove -- only the swapped-in node is going to change\n        // NodeIndex<Ix>, so we only have to walk its edges and update them.\n\n        let node = self.nodes.swap_remove(a.index());\n\n        // Find the edge lists of the node that had to relocate.\n        // It may be that no node had to relocate, then we are done already.\n        let swap_edges = match self.nodes.get(a.index()) {\n            None => return Some(node.weight),\n            Some(ed) => ed.next,\n        };\n\n        // The swapped element's old index\n        let old_index = NodeIndex::new(self.nodes.len());\n        let new_index = a;\n\n        // Adjust the starts of the out edges, and ends of the in edges.\n        for &d in &DIRECTIONS {\n            let k = d.index();\n            let mut edges = edges_walker_mut(&mut self.edges, swap_edges[k], d);\n            while let Some(curedge) = edges.next_edge() {\n                debug_assert!(curedge.node[k] == old_index);\n                curedge.node[k] = new_index;\n            }\n        }\n        Some(node.weight)\n    }\n\n    /// For edge `e` with endpoints `edge_node`, replace links to it,\n    /// with links to `edge_next`.\n    fn change_edge_links(\n        &mut self,\n        edge_node: [NodeIndex<Ix>; 2],\n        e: EdgeIndex<Ix>,\n        edge_next: [EdgeIndex<Ix>; 2],\n    ) {\n        for &d in &DIRECTIONS {\n            let k = d.index();\n            let node = match self.nodes.get_mut(edge_node[k].index()) {\n                Some(r) => r,\n                None => {\n                    debug_assert!(\n                        false,\n                        \"Edge's endpoint dir={:?} index={:?} not found\",\n                        d, edge_node[k]\n                    );\n                    return;\n                }\n            };\n            let fst = node.next[k];\n            if fst == e {\n                //println!(\"Updating first edge 0 for node {}, set to {}\", edge_node[0], edge_next[0]);\n                node.next[k] = edge_next[k];\n            } else {\n                let mut edges = edges_walker_mut(&mut self.edges, fst, d);\n                while let Some(curedge) = edges.next_edge() {\n                    if curedge.next[k] == e {\n                        curedge.next[k] = edge_next[k];\n                        break; // the edge can only be present once in the list.\n                    }\n                }\n            }\n        }\n    }\n\n    /// Remove an edge and return its edge weight, or `None` if it didn't exist.\n    ///\n    /// Apart from `e`, this invalidates the last edge index in the graph\n    /// (that edge will adopt the removed edge index).\n    ///\n    /// Computes in **O(e')** time, where **e'** is the size of four particular edge lists, for\n    /// the vertices of `e` and the vertices of another affected edge.\n    pub fn remove_edge(&mut self, e: EdgeIndex<Ix>) -> Option<E> {\n        // every edge is part of two lists,\n        // outgoing and incoming edges.\n        // Remove it from both\n        let (edge_node, edge_next) = match self.edges.get(e.index()) {\n            None => return None,\n            Some(x) => (x.node, x.next),\n        };\n        // Remove the edge from its in and out lists by replacing it with\n        // a link to the next in the list.\n        self.change_edge_links(edge_node, e, edge_next);\n        self.remove_edge_adjust_indices(e)\n    }\n\n    fn remove_edge_adjust_indices(&mut self, e: EdgeIndex<Ix>) -> Option<E> {\n        // swap_remove the edge -- only the removed edge\n        // and the edge swapped into place are affected and need updating\n        // indices.\n        let edge = self.edges.swap_remove(e.index());\n        let swap = match self.edges.get(e.index()) {\n            // no elment needed to be swapped.\n            None => return Some(edge.weight),\n            Some(ed) => ed.node,\n        };\n        let swapped_e = EdgeIndex::new(self.edges.len());\n\n        // Update the edge lists by replacing links to the old index by references to the new\n        // edge index.\n        self.change_edge_links(swap, swapped_e, [e, e]);\n        Some(edge.weight)\n    }\n\n    /// Return an iterator of all nodes with an edge starting from `a`.\n    ///\n    /// - `Directed`: Outgoing edges from `a`.\n    /// - `Undirected`: All edges from or to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is `NodeIndex<Ix>`.\n    ///\n    /// Use [`.neighbors(a).detach()`][1] to get a neighbor walker that does\n    /// not borrow from the graph.\n    ///\n    /// [1]: struct.Neighbors.html#method.detach\n    pub fn neighbors(&self, a: NodeIndex<Ix>) -> Neighbors<E, Ix> {\n        self.neighbors_directed(a, Outgoing)\n    }\n\n    /// Return an iterator of all neighbors that have an edge between them and\n    /// `a`, in the specified direction.\n    /// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n    ///\n    /// - `Directed`, `Outgoing`: All edges from `a`.\n    /// - `Directed`, `Incoming`: All edges to `a`.\n    /// - `Undirected`: All edges from or to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is `NodeIndex<Ix>`.\n    ///\n    /// For a `Directed` graph, neighbors are listed in reverse order of their\n    /// addition to the graph, so the most recently added edge's neighbor is\n    /// listed first. The order in an `Undirected` graph is arbitrary.\n    ///\n    /// Use [`.neighbors_directed(a, dir).detach()`][1] to get a neighbor walker that does\n    /// not borrow from the graph.\n    ///\n    /// [1]: struct.Neighbors.html#method.detach\n    pub fn neighbors_directed(&self, a: NodeIndex<Ix>, dir: Direction) -> Neighbors<E, Ix> {\n        let mut iter = self.neighbors_undirected(a);\n        if self.is_directed() {\n            let k = dir.index();\n            iter.next[1 - k] = EdgeIndex::end();\n            iter.skip_start = NodeIndex::end();\n        }\n        iter\n    }\n\n    /// Return an iterator of all neighbors that have an edge between them and\n    /// `a`, in either direction.\n    /// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n    ///\n    /// - `Directed` and `Undirected`: All edges from or to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is `NodeIndex<Ix>`.\n    ///\n    /// Use [`.neighbors_undirected(a).detach()`][1] to get a neighbor walker that does\n    /// not borrow from the graph.\n    ///\n    /// [1]: struct.Neighbors.html#method.detach\n    ///\n    pub fn neighbors_undirected(&self, a: NodeIndex<Ix>) -> Neighbors<E, Ix> {\n        Neighbors {\n            skip_start: a,\n            edges: &self.edges,\n            next: match self.nodes.get(a.index()) {\n                None => [EdgeIndex::end(), EdgeIndex::end()],\n                Some(n) => n.next,\n            },\n        }\n    }\n\n    /// Return an iterator of all edges of `a`.\n    ///\n    /// - `Directed`: Outgoing edges from `a`.\n    /// - `Undirected`: All edges connected to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is `EdgeReference<E, Ix>`.\n    pub fn edges(&self, a: NodeIndex<Ix>) -> Edges<E, Ty, Ix> {\n        self.edges_directed(a, Outgoing)\n    }\n\n    /// Return an iterator of all edges of `a`, in the specified direction.\n    ///\n    /// - `Directed`, `Outgoing`: All edges from `a`.\n    /// - `Directed`, `Incoming`: All edges to `a`.\n    /// - `Undirected`, `Outgoing`: All edges connected to `a`, with `a` being the source of each\n    ///   edge.\n    /// - `Undirected`, `Incoming`: All edges connected to `a`, with `a` being the target of each\n    ///   edge.\n    ///\n    /// Produces an empty iterator if the node `a` doesn't exist.<br>\n    /// Iterator element type is `EdgeReference<E, Ix>`.\n    pub fn edges_directed(&self, a: NodeIndex<Ix>, dir: Direction) -> Edges<E, Ty, Ix> {\n        Edges {\n            skip_start: a,\n            edges: &self.edges,\n            direction: dir,\n            next: match self.nodes.get(a.index()) {\n                None => [EdgeIndex::end(), EdgeIndex::end()],\n                Some(n) => n.next,\n            },\n            ty: PhantomData,\n        }\n    }\n\n    /// Return an iterator over all the edges connecting `a` and `b`.\n    ///\n    /// - `Directed`: Outgoing edges from `a`.\n    /// - `Undirected`: All edges connected to `a`.\n    ///\n    /// Iterator element type is `EdgeReference<E, Ix>`.\n    pub fn edges_connecting(\n        &self,\n        a: NodeIndex<Ix>,\n        b: NodeIndex<Ix>,\n    ) -> EdgesConnecting<E, Ty, Ix> {\n        EdgesConnecting {\n            target_node: b,\n            edges: self.edges_directed(a, Direction::Outgoing),\n            ty: PhantomData,\n        }\n    }\n\n    /// Lookup if there is an edge from `a` to `b`.\n    ///\n    /// Computes in **O(e')** time, where **e'** is the number of edges\n    /// connected to `a` (and `b`, if the graph edges are undirected).\n    pub fn contains_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool {\n        self.find_edge(a, b).is_some()\n    }\n\n    /// Lookup an edge from `a` to `b`.\n    ///\n    /// Computes in **O(e')** time, where **e'** is the number of edges\n    /// connected to `a` (and `b`, if the graph edges are undirected).\n    pub fn find_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> Option<EdgeIndex<Ix>> {\n        if !self.is_directed() {\n            self.find_edge_undirected(a, b).map(|(ix, _)| ix)\n        } else {\n            match self.nodes.get(a.index()) {\n                None => None,\n                Some(node) => self.find_edge_directed_from_node(node, b),\n            }\n        }\n    }\n\n    fn find_edge_directed_from_node(\n        &self,\n        node: &Node<N, Ix>,\n        b: NodeIndex<Ix>,\n    ) -> Option<EdgeIndex<Ix>> {\n        let mut edix = node.next[0];\n        while let Some(edge) = self.edges.get(edix.index()) {\n            if edge.node[1] == b {\n                return Some(edix);\n            }\n            edix = edge.next[0];\n        }\n        None\n    }\n\n    /// Lookup an edge between `a` and `b`, in either direction.\n    ///\n    /// If the graph is undirected, then this is equivalent to `.find_edge()`.\n    ///\n    /// Return the edge index and its directionality, with `Outgoing` meaning\n    /// from `a` to `b` and `Incoming` the reverse,\n    /// or `None` if the edge does not exist.\n    pub fn find_edge_undirected(\n        &self,\n        a: NodeIndex<Ix>,\n        b: NodeIndex<Ix>,\n    ) -> Option<(EdgeIndex<Ix>, Direction)> {\n        match self.nodes.get(a.index()) {\n            None => None,\n            Some(node) => self.find_edge_undirected_from_node(node, b),\n        }\n    }\n\n    fn find_edge_undirected_from_node(\n        &self,\n        node: &Node<N, Ix>,\n        b: NodeIndex<Ix>,\n    ) -> Option<(EdgeIndex<Ix>, Direction)> {\n        for &d in &DIRECTIONS {\n            let k = d.index();\n            let mut edix = node.next[k];\n            while let Some(edge) = self.edges.get(edix.index()) {\n                if edge.node[1 - k] == b {\n                    return Some((edix, d));\n                }\n                edix = edge.next[k];\n            }\n        }\n        None\n    }\n\n    /// Return an iterator over either the nodes without edges to them\n    /// (`Incoming`) or from them (`Outgoing`).\n    ///\n    /// An *internal* node has both incoming and outgoing edges.\n    /// The nodes in `.externals(Incoming)` are the source nodes and\n    /// `.externals(Outgoing)` are the sinks of the graph.\n    ///\n    /// For a graph with undirected edges, both the sinks and the sources are\n    /// just the nodes without edges.\n    ///\n    /// The whole iteration computes in **O(|V|)** time.\n    pub fn externals(&self, dir: Direction) -> Externals<N, Ty, Ix> {\n        Externals {\n            iter: self.nodes.iter().enumerate(),\n            dir,\n            ty: PhantomData,\n        }\n    }\n\n    /// Return an iterator over the node indices of the graph.\n    ///\n    /// For example, in a rare case where a graph algorithm were not applicable,\n    /// the following code will iterate through all nodes to find a\n    /// specific index:\n    ///\n    /// ```\n    /// # use petgraph::Graph;\n    /// # let mut g = Graph::<&str, i32>::new();\n    /// # g.add_node(\"book\");\n    /// let index = g.node_indices().find(|i| g[*i] == \"book\").unwrap();\n    /// ```\n    pub fn node_indices(&self) -> NodeIndices<Ix> {\n        NodeIndices {\n            r: 0..self.node_count(),\n            ty: PhantomData,\n        }\n    }\n\n    /// Return an iterator yielding mutable access to all node weights.\n    ///\n    /// The order in which weights are yielded matches the order of their\n    /// node indices.\n    pub fn node_weights_mut(&mut self) -> NodeWeightsMut<N, Ix> {\n        NodeWeightsMut {\n            nodes: self.nodes.iter_mut(),\n        }\n    }\n\n    /// Return an iterator over the edge indices of the graph\n    pub fn edge_indices(&self) -> EdgeIndices<Ix> {\n        EdgeIndices {\n            r: 0..self.edge_count(),\n            ty: PhantomData,\n        }\n    }\n\n    /// Create an iterator over all edges, in indexed order.\n    ///\n    /// Iterator element type is `EdgeReference<E, Ix>`.\n    pub fn edge_references(&self) -> EdgeReferences<E, Ix> {\n        EdgeReferences {\n            iter: self.edges.iter().enumerate(),\n        }\n    }\n\n    /// Return an iterator yielding mutable access to all edge weights.\n    ///\n    /// The order in which weights are yielded matches the order of their\n    /// edge indices.\n    pub fn edge_weights_mut(&mut self) -> EdgeWeightsMut<E, Ix> {\n        EdgeWeightsMut {\n            edges: self.edges.iter_mut(),\n        }\n    }\n\n    // Remaining methods are of the more internal flavour, read-only access to\n    // the data structure's internals.\n\n    /// Access the internal node array.\n    pub fn raw_nodes(&self) -> &[Node<N, Ix>] {\n        &self.nodes\n    }\n\n    /// Access the internal edge array.\n    pub fn raw_edges(&self) -> &[Edge<E, Ix>] {\n        &self.edges\n    }\n\n    /// Convert the graph into a vector of Nodes and a vector of Edges\n    pub fn into_nodes_edges(self) -> (Vec<Node<N, Ix>>, Vec<Edge<E, Ix>>) {\n        (self.nodes, self.edges)\n    }\n\n    /// Accessor for data structure internals: the first edge in the given direction.\n    pub fn first_edge(&self, a: NodeIndex<Ix>, dir: Direction) -> Option<EdgeIndex<Ix>> {\n        match self.nodes.get(a.index()) {\n            None => None,\n            Some(node) => {\n                let edix = node.next[dir.index()];\n                if edix == EdgeIndex::end() {\n                    None\n                } else {\n                    Some(edix)\n                }\n            }\n        }\n    }\n\n    /// Accessor for data structure internals: the next edge for the given direction.\n    pub fn next_edge(&self, e: EdgeIndex<Ix>, dir: Direction) -> Option<EdgeIndex<Ix>> {\n        match self.edges.get(e.index()) {\n            None => None,\n            Some(node) => {\n                let edix = node.next[dir.index()];\n                if edix == EdgeIndex::end() {\n                    None\n                } else {\n                    Some(edix)\n                }\n            }\n        }\n    }\n\n    /// Index the `Graph` by two indices, any combination of\n    /// node or edge indices is fine.\n    ///\n    /// **Panics** if the indices are equal or if they are out of bounds.\n    ///\n    /// ```\n    /// use petgraph::{Graph, Incoming};\n    /// use petgraph::visit::Dfs;\n    ///\n    /// let mut gr = Graph::new();\n    /// let a = gr.add_node(0.);\n    /// let b = gr.add_node(0.);\n    /// let c = gr.add_node(0.);\n    /// gr.add_edge(a, b, 3.);\n    /// gr.add_edge(b, c, 2.);\n    /// gr.add_edge(c, b, 1.);\n    ///\n    /// // walk the graph and sum incoming edges into the node weight\n    /// let mut dfs = Dfs::new(&gr, a);\n    /// while let Some(node) = dfs.next(&gr) {\n    ///     // use a walker -- a detached neighbors iterator\n    ///     let mut edges = gr.neighbors_directed(node, Incoming).detach();\n    ///     while let Some(edge) = edges.next_edge(&gr) {\n    ///         let (nw, ew) = gr.index_twice_mut(node, edge);\n    ///         *nw += *ew;\n    ///     }\n    /// }\n    ///\n    /// // check the result\n    /// assert_eq!(gr[a], 0.);\n    /// assert_eq!(gr[b], 4.);\n    /// assert_eq!(gr[c], 2.);\n    /// ```\n    pub fn index_twice_mut<T, U>(\n        &mut self,\n        i: T,\n        j: U,\n    ) -> (\n        &mut <Self as Index<T>>::Output,\n        &mut <Self as Index<U>>::Output,\n    )\n    where\n        Self: IndexMut<T> + IndexMut<U>,\n        T: GraphIndex,\n        U: GraphIndex,\n    {\n        assert!(T::is_node_index() != U::is_node_index() || i.index() != j.index());\n\n        // Allow two mutable indexes here -- they are nonoverlapping\n        unsafe {\n            let self_mut = self as *mut _;\n            (\n                <Self as IndexMut<T>>::index_mut(&mut *self_mut, i),\n                <Self as IndexMut<U>>::index_mut(&mut *self_mut, j),\n            )\n        }\n    }\n\n    /// Reverse the direction of all edges\n    pub fn reverse(&mut self) {\n        // swap edge endpoints,\n        // edge incoming / outgoing lists,\n        // node incoming / outgoing lists\n        for edge in &mut self.edges {\n            edge.node.swap(0, 1);\n            edge.next.swap(0, 1);\n        }\n        for node in &mut self.nodes {\n            node.next.swap(0, 1);\n        }\n    }\n\n    /// Remove all nodes and edges\n    pub fn clear(&mut self) {\n        self.nodes.clear();\n        self.edges.clear();\n    }\n\n    /// Remove all edges\n    pub fn clear_edges(&mut self) {\n        self.edges.clear();\n        for node in &mut self.nodes {\n            node.next = [EdgeIndex::end(), EdgeIndex::end()];\n        }\n    }\n\n    /// Return the current node and edge capacity of the graph.\n    pub fn capacity(&self) -> (usize, usize) {\n        (self.nodes.capacity(), self.edges.capacity())\n    }\n\n    /// Reserves capacity for at least `additional` more nodes to be inserted in\n    /// the graph. Graph may reserve more space to avoid frequent reallocations.\n    ///\n    /// **Panics** if the new capacity overflows `usize`.\n    pub fn reserve_nodes(&mut self, additional: usize) {\n        self.nodes.reserve(additional);\n    }\n\n    /// Reserves capacity for at least `additional` more edges to be inserted in\n    /// the graph. Graph may reserve more space to avoid frequent reallocations.\n    ///\n    /// **Panics** if the new capacity overflows `usize`.\n    pub fn reserve_edges(&mut self, additional: usize) {\n        self.edges.reserve(additional);\n    }\n\n    /// Reserves the minimum capacity for exactly `additional` more nodes to be\n    /// inserted in the graph. Does nothing if the capacity is already\n    /// sufficient.\n    ///\n    /// Prefer `reserve_nodes` if future insertions are expected.\n    ///\n    /// **Panics** if the new capacity overflows `usize`.\n    pub fn reserve_exact_nodes(&mut self, additional: usize) {\n        self.nodes.reserve_exact(additional);\n    }\n\n    /// Reserves the minimum capacity for exactly `additional` more edges to be\n    /// inserted in the graph.\n    /// Does nothing if the capacity is already sufficient.\n    ///\n    /// Prefer `reserve_edges` if future insertions are expected.\n    ///\n    /// **Panics** if the new capacity overflows `usize`.\n    pub fn reserve_exact_edges(&mut self, additional: usize) {\n        self.edges.reserve_exact(additional);\n    }\n\n    /// Shrinks the capacity of the underlying nodes collection as much as possible.\n    pub fn shrink_to_fit_nodes(&mut self) {\n        self.nodes.shrink_to_fit();\n    }\n\n    /// Shrinks the capacity of the underlying edges collection as much as possible.\n    pub fn shrink_to_fit_edges(&mut self) {\n        self.edges.shrink_to_fit();\n    }\n\n    /// Shrinks the capacity of the graph as much as possible.\n    pub fn shrink_to_fit(&mut self) {\n        self.nodes.shrink_to_fit();\n        self.edges.shrink_to_fit();\n    }\n\n    /// Keep all nodes that return `true` from the `visit` closure,\n    /// remove the others.\n    ///\n    /// `visit` is provided a proxy reference to the graph, so that\n    /// the graph can be walked and associated data modified.\n    ///\n    /// The order nodes are visited is not specified.\n    pub fn retain_nodes<F>(&mut self, mut visit: F)\n    where\n        F: FnMut(Frozen<Self>, NodeIndex<Ix>) -> bool,\n    {\n        for index in self.node_indices().rev() {\n            if !visit(Frozen(self), index) {\n                let ret = self.remove_node(index);\n                debug_assert!(ret.is_some());\n                let _ = ret;\n            }\n        }\n    }\n\n    /// Keep all edges that return `true` from the `visit` closure,\n    /// remove the others.\n    ///\n    /// `visit` is provided a proxy reference to the graph, so that\n    /// the graph can be walked and associated data modified.\n    ///\n    /// The order edges are visited is not specified.\n    pub fn retain_edges<F>(&mut self, mut visit: F)\n    where\n        F: FnMut(Frozen<Self>, EdgeIndex<Ix>) -> bool,\n    {\n        for index in self.edge_indices().rev() {\n            if !visit(Frozen(self), index) {\n                let ret = self.remove_edge(index);\n                debug_assert!(ret.is_some());\n                let _ = ret;\n            }\n        }\n    }\n\n    /// Create a new `Graph` from an iterable of edges.\n    ///\n    /// Node weights `N` are set to default values.\n    /// Edge weights `E` may either be specified in the list,\n    /// or they are filled with default values.\n    ///\n    /// Nodes are inserted automatically to match the edges.\n    ///\n    /// ```\n    /// use petgraph::Graph;\n    ///\n    /// let gr = Graph::<(), i32>::from_edges(&[\n    ///     (0, 1), (0, 2), (0, 3),\n    ///     (1, 2), (1, 3),\n    ///     (2, 3),\n    /// ]);\n    /// ```\n    pub fn from_edges<I>(iterable: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,\n    {\n        let mut g = Self::with_capacity(0, 0);\n        g.extend_with_edges(iterable);\n        g\n    }\n\n    /// Extend the graph from an iterable of edges.\n    ///\n    /// Node weights `N` are set to default values.\n    /// Edge weights `E` may either be specified in the list,\n    /// or they are filled with default values.\n    ///\n    /// Nodes are inserted automatically to match the edges.\n    pub fn extend_with_edges<I>(&mut self, iterable: I)\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,\n    {\n        let iter = iterable.into_iter();\n        let (low, _) = iter.size_hint();\n        self.edges.reserve(low);\n\n        for elt in iter {\n            let (source, target, weight) = elt.into_weighted_edge();\n            let (source, target) = (source.into(), target.into());\n            let nx = cmp::max(source, target);\n            while nx.index() >= self.node_count() {\n                self.add_node(N::default());\n            }\n            self.add_edge(source, target, weight);\n        }\n    }\n\n    /// Create a new `Graph` by mapping node and\n    /// edge weights to new values.\n    ///\n    /// The resulting graph has the same structure and the same\n    /// graph indices as `self`.\n    pub fn map<'a, F, G, N2, E2>(\n        &'a self,\n        mut node_map: F,\n        mut edge_map: G,\n    ) -> Graph<N2, E2, Ty, Ix>\n    where\n        F: FnMut(NodeIndex<Ix>, &'a N) -> N2,\n        G: FnMut(EdgeIndex<Ix>, &'a E) -> E2,\n    {\n        let mut g = Graph::with_capacity(self.node_count(), self.edge_count());\n        g.nodes.extend(enumerate(&self.nodes).map(|(i, node)| Node {\n            weight: node_map(NodeIndex::new(i), &node.weight),\n            next: node.next,\n        }));\n        g.edges.extend(enumerate(&self.edges).map(|(i, edge)| Edge {\n            weight: edge_map(EdgeIndex::new(i), &edge.weight),\n            next: edge.next,\n            node: edge.node,\n        }));\n        g\n    }\n\n    /// Create a new `Graph` by mapping nodes and edges.\n    /// A node or edge may be mapped to `None` to exclude it from\n    /// the resulting graph.\n    ///\n    /// Nodes are mapped first with the `node_map` closure, then\n    /// `edge_map` is called for the edges that have not had any endpoint\n    /// removed.\n    ///\n    /// The resulting graph has the structure of a subgraph of the original graph.\n    /// If no nodes are removed, the resulting graph has compatible node\n    /// indices; if neither nodes nor edges are removed, the result has\n    /// the same graph indices as `self`.\n    pub fn filter_map<'a, F, G, N2, E2>(\n        &'a self,\n        mut node_map: F,\n        mut edge_map: G,\n    ) -> Graph<N2, E2, Ty, Ix>\n    where\n        F: FnMut(NodeIndex<Ix>, &'a N) -> Option<N2>,\n        G: FnMut(EdgeIndex<Ix>, &'a E) -> Option<E2>,\n    {\n        let mut g = Graph::with_capacity(0, 0);\n        // mapping from old node index to new node index, end represents removed.\n        let mut node_index_map = vec![NodeIndex::end(); self.node_count()];\n        for (i, node) in enumerate(&self.nodes) {\n            if let Some(nw) = node_map(NodeIndex::new(i), &node.weight) {\n                node_index_map[i] = g.add_node(nw);\n            }\n        }\n        for (i, edge) in enumerate(&self.edges) {\n            // skip edge if any endpoint was removed\n            let source = node_index_map[edge.source().index()];\n            let target = node_index_map[edge.target().index()];\n            if source != NodeIndex::end() && target != NodeIndex::end() {\n                if let Some(ew) = edge_map(EdgeIndex::new(i), &edge.weight) {\n                    g.add_edge(source, target, ew);\n                }\n            }\n        }\n        g\n    }\n\n    /// Convert the graph into either undirected or directed. No edge adjustments\n    /// are done, so you may want to go over the result to remove or add edges.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn into_edge_type<NewTy>(self) -> Graph<N, E, NewTy, Ix>\n    where\n        NewTy: EdgeType,\n    {\n        Graph {\n            nodes: self.nodes,\n            edges: self.edges,\n            ty: PhantomData,\n        }\n    }\n\n    //\n    // internal methods\n    //\n    #[cfg(feature = \"serde-1\")]\n    /// Fix up node and edge links after deserialization\n    fn link_edges(&mut self) -> Result<(), NodeIndex<Ix>> {\n        for (edge_index, edge) in enumerate(&mut self.edges) {\n            let a = edge.source();\n            let b = edge.target();\n            let edge_idx = EdgeIndex::new(edge_index);\n            match index_twice(&mut self.nodes, a.index(), b.index()) {\n                Pair::None => return Err(if a > b { a } else { b }),\n                Pair::One(an) => {\n                    edge.next = an.next;\n                    an.next[0] = edge_idx;\n                    an.next[1] = edge_idx;\n                }\n                Pair::Both(an, bn) => {\n                    // a and b are different indices\n                    edge.next = [an.next[0], bn.next[1]];\n                    an.next[0] = edge_idx;\n                    bn.next[1] = edge_idx;\n                }\n            }\n        }\n        Ok(())\n    }\n}","impl<N, E, Ty, Ix> GraphBase for Graph<N, E, Ty, Ix>\nwhere\n    Ix: IndexType,\n{\n    type NodeId = graph::NodeIndex<Ix>;\n    type EdgeId = graph::EdgeIndex<Ix>;\n}","impl<N, E, Ty, Ix> GraphProp for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type EdgeType = Ty;\n}","impl<N, E, Ty, Ix> Index<EdgeIndex<Ix>> for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Output = E;\n    fn index(&self, index: EdgeIndex<Ix>) -> &E {\n        &self.edges[index.index()].weight\n    }\n}","impl<N, E, Ty, Ix> Index<NodeIndex<Ix>> for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Output = N;\n    fn index(&self, index: NodeIndex<Ix>) -> &N {\n        &self.nodes[index.index()].weight\n    }\n}","impl<N, E, Ty, Ix> IndexMut<EdgeIndex<Ix>> for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn index_mut(&mut self, index: EdgeIndex<Ix>) -> &mut E {\n        &mut self.edges[index.index()].weight\n    }\n}","impl<N, E, Ty, Ix> IndexMut<NodeIndex<Ix>> for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn index_mut(&mut self, index: NodeIndex<Ix>) -> &mut N {\n        &mut self.nodes[index.index()].weight\n    }\n}","impl<N, E, Ty, Ix> NodeCompactIndexable for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n}","impl<N, E, Ty, Ix> NodeCount for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn node_count(&self) -> usize {\n        self.node_count()\n    }\n}","impl<N, E, Ty, Ix> NodeIndexable for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn node_bound(&self) -> usize {\n        self.node_count()\n    }\n    fn to_index(&self, ix: NodeIndex<Ix>) -> usize {\n        ix.index()\n    }\n    fn from_index(&self, ix: usize) -> Self::NodeId {\n        NodeIndex::new(ix)\n    }\n}","impl<N, E, Ty, Ix> Visitable for Graph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Map = FixedBitSet;\n    fn visit_map(&self) -> FixedBitSet {\n        FixedBitSet::with_capacity(self.node_count())\n    }\n\n    fn reset_map(&self, map: &mut Self::Map) {\n        map.clear();\n        map.grow(self.node_count());\n    }\n}","impl<N, E, Ty, Ix> fmt::Debug for Graph<N, E, Ty, Ix>\nwhere\n    N: fmt::Debug,\n    E: fmt::Debug,\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let etype = if self.is_directed() {\n            \"Directed\"\n        } else {\n            \"Undirected\"\n        };\n        let mut fmt_struct = f.debug_struct(\"Graph\");\n        fmt_struct.field(\"Ty\", &etype);\n        fmt_struct.field(\"node_count\", &self.node_count());\n        fmt_struct.field(\"edge_count\", &self.edge_count());\n        if self.edge_count() > 0 {\n            fmt_struct.field(\n                \"edges\",\n                &self\n                    .edges\n                    .iter()\n                    .map(|e| NoPretty((e.source().index(), e.target().index())))\n                    .format(\", \"),\n            );\n        }\n        // skip weights if they are ZST!\n        if size_of::<N>() != 0 {\n            fmt_struct.field(\n                \"node weights\",\n                &DebugMap(|| self.nodes.iter().map(|n| &n.weight).enumerate()),\n            );\n        }\n        if size_of::<E>() != 0 {\n            fmt_struct.field(\n                \"edge weights\",\n                &DebugMap(|| self.edges.iter().map(|n| &n.weight).enumerate()),\n            );\n        }\n        fmt_struct.finish()\n    }\n}","impl<N, E> Graph<N, E, Directed> {\n    /// Create a new `Graph` with directed edges.\n    ///\n    /// This is a convenience method. Use `Graph::with_capacity` or `Graph::default` for\n    /// a constructor that is generic in all the type parameters of `Graph`.\n    pub fn new() -> Self {\n        Graph {\n            nodes: Vec::new(),\n            edges: Vec::new(),\n            ty: PhantomData,\n        }\n    }\n}","impl<N, E> Graph<N, E, Undirected> {\n    /// Create a new `Graph` with undirected edges.\n    ///\n    /// This is a convenience method. Use `Graph::with_capacity` or `Graph::default` for\n    /// a constructor that is generic in all the type parameters of `Graph`.\n    pub fn new_undirected() -> Self {\n        Graph {\n            nodes: Vec::new(),\n            edges: Vec::new(),\n            ty: PhantomData,\n        }\n    }\n}"],"graph_impl::Neighbors":["impl<'a, E, Ix> Clone for Neighbors<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    clone_fields!(Neighbors, skip_start, edges, next,);\n}","impl<'a, E, Ix> Iterator for Neighbors<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    type Item = NodeIndex<Ix>;\n\n    fn next(&mut self) -> Option<NodeIndex<Ix>> {\n        // First any outgoing edges\n        match self.edges.get(self.next[0].index()) {\n            None => {}\n            Some(edge) => {\n                self.next[0] = edge.next[0];\n                return Some(edge.node[1]);\n            }\n        }\n        // Then incoming edges\n        // For an \"undirected\" iterator (traverse both incoming\n        // and outgoing edge lists), make sure we don't double\n        // count selfloops by skipping them in the incoming list.\n        while let Some(edge) = self.edges.get(self.next[1].index()) {\n            self.next[1] = edge.next[1];\n            if edge.node[0] != self.skip_start {\n                return Some(edge.node[0]);\n            }\n        }\n        None\n    }\n}","impl<'a, E, Ix> Neighbors<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    /// Return a “walker” object that can be used to step through the\n    /// neighbors and edges from the origin node.\n    ///\n    /// Note: The walker does not borrow from the graph, this is to allow mixing\n    /// edge walking with mutating the graph's weights.\n    pub fn detach(&self) -> WalkNeighbors<Ix> {\n        WalkNeighbors {\n            skip_start: self.skip_start,\n            next: self.next,\n        }\n    }\n}"],"graph_impl::Node":["Debug","impl<E, Ix> Clone for Node<E, Ix>\nwhere\n    E: Clone,\n    Ix: Copy,\n{\n    clone_fields!(Node, weight, next,);\n}","impl<N, Ix: IndexType> Node<N, Ix> {\n    /// Accessor for data structure internals: the first edge in the given direction.\n    pub fn next_edge(&self, dir: Direction) -> EdgeIndex<Ix> {\n        self.next[dir.index()]\n    }\n}"],"graph_impl::NodeIndex":["Clone","Copy","Default","Eq","Hash","Ord","PartialEq","PartialOrd","impl<Ix: IndexType> From<Ix> for NodeIndex<Ix> {\n    fn from(ix: Ix) -> Self {\n        NodeIndex(ix)\n    }\n}","impl<Ix: IndexType> GraphIndex for NodeIndex<Ix> {\n    #[inline]\n    fn index(&self) -> usize {\n        NodeIndex::index(*self)\n    }\n    #[inline]\n    fn is_node_index() -> bool {\n        true\n    }\n}","impl<Ix: IndexType> NodeIndex<Ix> {\n    #[inline]\n    pub fn new(x: usize) -> Self {\n        NodeIndex(IndexType::new(x))\n    }\n\n    #[inline]\n    pub fn index(self) -> usize {\n        self.0.index()\n    }\n\n    #[inline]\n    pub fn end() -> Self {\n        NodeIndex(IndexType::max())\n    }\n\n    fn _into_edge(self) -> EdgeIndex<Ix> {\n        EdgeIndex(self.0)\n    }\n}","impl<Ix: fmt::Debug> fmt::Debug for NodeIndex<Ix> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"NodeIndex({:?})\", self.0)\n    }\n}"],"graph_impl::NodeIndices":["Clone","Debug","impl<Ix: IndexType> DoubleEndedIterator for NodeIndices<Ix> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.r.next_back().map(node_index)\n    }\n}","impl<Ix: IndexType> ExactSizeIterator for NodeIndices<Ix> {}","impl<Ix: IndexType> Iterator for NodeIndices<Ix> {\n    type Item = NodeIndex<Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.r.next().map(node_index)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.r.size_hint()\n    }\n}"],"graph_impl::NodeReferences":["impl<'a, N, Ix> DoubleEndedIterator for NodeReferences<'a, N, Ix>\nwhere\n    Ix: IndexType,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next_back()\n            .map(|(i, node)| (node_index(i), &node.weight))\n    }\n}","impl<'a, N, Ix> ExactSizeIterator for NodeReferences<'a, N, Ix> where Ix: IndexType {}","impl<'a, N, Ix> Iterator for NodeReferences<'a, N, Ix>\nwhere\n    Ix: IndexType,\n{\n    type Item = (NodeIndex<Ix>, &'a N);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next()\n            .map(|(i, node)| (node_index(i), &node.weight))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}"],"graph_impl::NodeWeightsMut":["impl<'a, N, Ix> Iterator for NodeWeightsMut<'a, N, Ix>\nwhere\n    Ix: IndexType,\n{\n    type Item = &'a mut N;\n\n    fn next(&mut self) -> Option<&'a mut N> {\n        self.nodes.next().map(|node| &mut node.weight)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.nodes.size_hint()\n    }\n}"],"graph_impl::WalkNeighbors":["impl<Ix: IndexType> WalkNeighbors<Ix> {\n    /// Step to the next edge and its endpoint node in the walk for graph `g`.\n    ///\n    /// The next node indices are always the others than the starting point\n    /// where the `WalkNeighbors` value was created.\n    /// For an `Outgoing` walk, the target nodes,\n    /// for an `Incoming` walk, the source nodes of the edge.\n    pub fn next<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &Graph<N, E, Ty, Ix>,\n    ) -> Option<(EdgeIndex<Ix>, NodeIndex<Ix>)> {\n        // First any outgoing edges\n        match g.edges.get(self.next[0].index()) {\n            None => {}\n            Some(edge) => {\n                let ed = self.next[0];\n                self.next[0] = edge.next[0];\n                return Some((ed, edge.node[1]));\n            }\n        }\n        // Then incoming edges\n        // For an \"undirected\" iterator (traverse both incoming\n        // and outgoing edge lists), make sure we don't double\n        // count selfloops by skipping them in the incoming list.\n        while let Some(edge) = g.edges.get(self.next[1].index()) {\n            let ed = self.next[1];\n            self.next[1] = edge.next[1];\n            if edge.node[0] != self.skip_start {\n                return Some((ed, edge.node[0]));\n            }\n        }\n        None\n    }\n\n    pub fn next_node<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &Graph<N, E, Ty, Ix>,\n    ) -> Option<NodeIndex<Ix>> {\n        self.next(g).map(|t| t.1)\n    }\n\n    pub fn next_edge<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &Graph<N, E, Ty, Ix>,\n    ) -> Option<EdgeIndex<Ix>> {\n        self.next(g).map(|t| t.0)\n    }\n}","impl<Ix> Clone for WalkNeighbors<Ix>\nwhere\n    Ix: IndexType,\n{\n    fn clone(&self) -> Self {\n        WalkNeighbors {\n            skip_start: self.skip_start,\n            next: self.next,\n        }\n    }\n}"],"graph_impl::stable_graph::EdgeIndices":["impl<'a, E, Ix: IndexType> DoubleEndedIterator for EdgeIndices<'a, E, Ix> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.ex_rfind_map(|(i, node)| {\n            if node.weight.is_some() {\n                Some(edge_index(i))\n            } else {\n                None\n            }\n        })\n    }\n}","impl<'a, E, Ix: IndexType> Iterator for EdgeIndices<'a, E, Ix> {\n    type Item = EdgeIndex<Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.ex_find_map(|(i, node)| {\n            if node.weight.is_some() {\n                Some(edge_index(i))\n            } else {\n                None\n            }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}"],"graph_impl::stable_graph::EdgeReference":["Debug","impl<'a, E, Ix: IndexType> Clone for EdgeReference<'a, E, Ix> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}","impl<'a, E, Ix: IndexType> Copy for EdgeReference<'a, E, Ix> {}","impl<'a, E, Ix: IndexType> PartialEq for EdgeReference<'a, E, Ix>\nwhere\n    E: PartialEq,\n{\n    fn eq(&self, rhs: &Self) -> bool {\n        self.index == rhs.index && self.weight == rhs.weight\n    }\n}","impl<'a, Ix, E> EdgeRef for EdgeReference<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    type NodeId = NodeIndex<Ix>;\n    type EdgeId = EdgeIndex<Ix>;\n    type Weight = E;\n\n    fn source(&self) -> Self::NodeId {\n        self.node[0]\n    }\n    fn target(&self) -> Self::NodeId {\n        self.node[1]\n    }\n    fn weight(&self) -> &E {\n        self.weight\n    }\n    fn id(&self) -> Self::EdgeId {\n        self.index\n    }\n}","impl<'a, Ix, E> EdgeReference<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    /// Access the edge’s weight.\n    ///\n    /// **NOTE** that this method offers a longer lifetime\n    /// than the trait (unfortunately they don't match yet).\n    pub fn weight(&self) -> &'a E {\n        self.weight\n    }\n}"],"graph_impl::stable_graph::EdgeReferences":["impl<'a, E, Ix> DoubleEndedIterator for EdgeReferences<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.ex_rfind_map(|(i, edge)| {\n            edge.weight.as_ref().map(move |weight| EdgeReference {\n                index: edge_index(i),\n                node: edge.node,\n                weight,\n            })\n        })\n    }\n}","impl<'a, E, Ix> Iterator for EdgeReferences<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    type Item = EdgeReference<'a, E, Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.ex_find_map(|(i, edge)| {\n            edge.weight.as_ref().map(move |weight| EdgeReference {\n                index: edge_index(i),\n                node: edge.node,\n                weight,\n            })\n        })\n    }\n}"],"graph_impl::stable_graph::Edges":["impl<'a, E, Ty, Ix> Iterator for Edges<'a, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Item = EdgeReference<'a, E, Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        //      type        direction    |    iterate over    reverse\n        //                               |\n        //    Directed      Outgoing     |      outgoing        no\n        //    Directed      Incoming     |      incoming        no\n        //   Undirected     Outgoing     |        both       incoming\n        //   Undirected     Incoming     |        both       outgoing\n\n        // For iterate_over, \"both\" is represented as None.\n        // For reverse, \"no\" is represented as None.\n        let (iterate_over, reverse) = if Ty::is_directed() {\n            (Some(self.direction), None)\n        } else {\n            (None, Some(self.direction.opposite()))\n        };\n\n        if iterate_over.unwrap_or(Outgoing) == Outgoing {\n            let i = self.next[0].index();\n            if let Some(Edge {\n                node,\n                weight: Some(weight),\n                next,\n            }) = self.edges.get(i)\n            {\n                self.next[0] = next[0];\n                return Some(EdgeReference {\n                    index: edge_index(i),\n                    node: if reverse == Some(Outgoing) {\n                        swap_pair(*node)\n                    } else {\n                        *node\n                    },\n                    weight,\n                });\n            }\n        }\n\n        if iterate_over.unwrap_or(Incoming) == Incoming {\n            while let Some(Edge { node, weight, next }) = self.edges.get(self.next[1].index()) {\n                debug_assert!(weight.is_some());\n                let edge_index = self.next[1];\n                self.next[1] = next[1];\n                // In any of the \"both\" situations, self-loops would be iterated over twice.\n                // Skip them here.\n                if iterate_over.is_none() && node[0] == self.skip_start {\n                    continue;\n                }\n\n                return Some(EdgeReference {\n                    index: edge_index,\n                    node: if reverse == Some(Incoming) {\n                        swap_pair(*node)\n                    } else {\n                        *node\n                    },\n                    weight: weight.as_ref().unwrap(),\n                });\n            }\n        }\n\n        None\n    }\n}"],"graph_impl::stable_graph::Externals":["impl<'a, N: 'a, Ty, Ix> Iterator for Externals<'a, N, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Item = NodeIndex<Ix>;\n    fn next(&mut self) -> Option<NodeIndex<Ix>> {\n        let k = self.dir.index();\n        loop {\n            match self.iter.next() {\n                None => return None,\n                Some((index, node)) => {\n                    if node.weight.is_some()\n                        && node.next[k] == EdgeIndex::end()\n                        && (Ty::is_directed() || node.next[1 - k] == EdgeIndex::end())\n                    {\n                        return Some(NodeIndex::new(index));\n                    } else {\n                        continue;\n                    }\n                }\n            }\n        }\n    }\n}"],"graph_impl::stable_graph::Neighbors":["impl<'a, E, Ix> Iterator for Neighbors<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    type Item = NodeIndex<Ix>;\n\n    fn next(&mut self) -> Option<NodeIndex<Ix>> {\n        // First any outgoing edges\n        match self.edges.get(self.next[0].index()) {\n            None => {}\n            Some(edge) => {\n                debug_assert!(edge.weight.is_some());\n                self.next[0] = edge.next[0];\n                return Some(edge.node[1]);\n            }\n        }\n        // Then incoming edges\n        // For an \"undirected\" iterator (traverse both incoming\n        // and outgoing edge lists), make sure we don't double\n        // count selfloops by skipping them in the incoming list.\n        while let Some(edge) = self.edges.get(self.next[1].index()) {\n            debug_assert!(edge.weight.is_some());\n            self.next[1] = edge.next[1];\n            if edge.node[0] != self.skip_start {\n                return Some(edge.node[0]);\n            }\n        }\n        None\n    }\n}","impl<'a, E, Ix> Neighbors<'a, E, Ix>\nwhere\n    Ix: IndexType,\n{\n    /// Return a “walker” object that can be used to step through the\n    /// neighbors and edges from the origin node.\n    ///\n    /// Note: The walker does not borrow from the graph, this is to allow mixing\n    /// edge walking with mutating the graph's weights.\n    pub fn detach(&self) -> WalkNeighbors<Ix> {\n        WalkNeighbors {\n            inner: super::WalkNeighbors {\n                skip_start: self.skip_start,\n                next: self.next,\n            },\n        }\n    }\n}"],"graph_impl::stable_graph::NodeIndices":["impl<'a, N, Ix: IndexType> DoubleEndedIterator for NodeIndices<'a, N, Ix> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.ex_rfind_map(|(i, node)| {\n            if node.weight.is_some() {\n                Some(node_index(i))\n            } else {\n                None\n            }\n        })\n    }\n}","impl<'a, N, Ix: IndexType> Iterator for NodeIndices<'a, N, Ix> {\n    type Item = NodeIndex<Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.ex_find_map(|(i, node)| {\n            if node.weight.is_some() {\n                Some(node_index(i))\n            } else {\n                None\n            }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}"],"graph_impl::stable_graph::NodeReferences":["impl<'a, N, Ix> DoubleEndedIterator for NodeReferences<'a, N, Ix>\nwhere\n    Ix: IndexType,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter\n            .ex_rfind_map(|(i, node)| node.weight.as_ref().map(move |w| (node_index(i), w)))\n    }\n}","impl<'a, N, Ix> Iterator for NodeReferences<'a, N, Ix>\nwhere\n    Ix: IndexType,\n{\n    type Item = (NodeIndex<Ix>, &'a N);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter\n            .ex_find_map(|(i, node)| node.weight.as_ref().map(move |w| (node_index(i), w)))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }\n}"],"graph_impl::stable_graph::StableGraph":["impl<N, E, Ty, Ix: IndexType> Clone for StableGraph<N, E, Ty, Ix>\nwhere\n    N: Clone,\n    E: Clone,\n{\n    fn clone(&self) -> Self {\n        StableGraph {\n            g: self.g.clone(),\n            node_count: self.node_count,\n            edge_count: self.edge_count,\n            free_node: self.free_node,\n            free_edge: self.free_edge,\n        }\n    }\n\n    fn clone_from(&mut self, rhs: &Self) {\n        self.g.clone_from(&rhs.g);\n        self.node_count = rhs.node_count;\n        self.edge_count = rhs.edge_count;\n        self.free_node = rhs.free_node;\n        self.free_edge = rhs.free_edge;\n    }\n}","impl<N, E, Ty, Ix> Build for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn add_node(&mut self, weight: Self::NodeWeight) -> Self::NodeId {\n        self.add_node(weight)\n    }\n    fn add_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Option<Self::EdgeId> {\n        Some(self.add_edge(a, b, weight))\n    }\n    fn update_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Self::EdgeId {\n        self.update_edge(a, b, weight)\n    }\n}","impl<N, E, Ty, Ix> Create for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn with_capacity(nodes: usize, edges: usize) -> Self {\n        Self::with_capacity(nodes, edges)\n    }\n}","impl<N, E, Ty, Ix> Data for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type NodeWeight = N;\n    type EdgeWeight = E;\n}","impl<N, E, Ty, Ix> DataMap for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn node_weight(&self, id: Self::NodeId) -> Option<&Self::NodeWeight> {\n        self.node_weight(id)\n    }\n    fn edge_weight(&self, id: Self::EdgeId) -> Option<&Self::EdgeWeight> {\n        self.edge_weight(id)\n    }\n}","impl<N, E, Ty, Ix> DataMapMut for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn node_weight_mut(&mut self, id: Self::NodeId) -> Option<&mut Self::NodeWeight> {\n        self.node_weight_mut(id)\n    }\n    fn edge_weight_mut(&mut self, id: Self::EdgeId) -> Option<&mut Self::EdgeWeight> {\n        self.edge_weight_mut(id)\n    }\n}","impl<N, E, Ty, Ix> Default for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn default() -> Self {\n        Self::with_capacity(0, 0)\n    }\n}","impl<N, E, Ty, Ix> From<Graph<N, E, Ty, Ix>> for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn from(g: Graph<N, E, Ty, Ix>) -> Self {\n        let nodes = g.nodes.into_iter().map(|e| Node {\n            weight: Some(e.weight),\n            next: e.next,\n        });\n        let edges = g.edges.into_iter().map(|e| Edge {\n            weight: Some(e.weight),\n            node: e.node,\n            next: e.next,\n        });\n        StableGraph {\n            node_count: nodes.len(),\n            edge_count: edges.len(),\n            g: Graph {\n                edges: edges.collect(),\n                nodes: nodes.collect(),\n                ty: g.ty,\n            },\n            free_node: NodeIndex::end(),\n            free_edge: EdgeIndex::end(),\n        }\n    }\n}","impl<N, E, Ty, Ix> FromElements for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn from_elements<I>(iterable: I) -> Self\n    where\n        Self: Sized,\n        I: IntoIterator<Item = Element<Self::NodeWeight, Self::EdgeWeight>>,\n    {\n        from_elements_indexable(iterable)\n    }\n}","impl<N, E, Ty, Ix> GetAdjacencyMatrix for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type AdjMatrix = FixedBitSet;\n\n    fn adjacency_matrix(&self) -> FixedBitSet {\n        let n = self.node_bound();\n        let mut matrix = FixedBitSet::with_capacity(n * n);\n        for edge in self.edge_references() {\n            let i = edge.source().index() * n + edge.target().index();\n            matrix.put(i);\n            if !self.is_directed() {\n                let j = edge.source().index() + n * edge.target().index();\n                matrix.put(j);\n            }\n        }\n        matrix\n    }\n\n    fn is_adjacent(&self, matrix: &FixedBitSet, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool {\n        let n = self.node_count();\n        let index = n * a.index() + b.index();\n        matrix.contains(index)\n    }\n}","impl<N, E, Ty, Ix> GraphBase for StableGraph<N, E, Ty, Ix>\nwhere\n    Ix: IndexType,\n{\n    type NodeId = graph::NodeIndex<Ix>;\n    type EdgeId = graph::EdgeIndex<Ix>;\n}","impl<N, E, Ty, Ix> GraphProp for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type EdgeType = Ty;\n}","impl<N, E, Ty, Ix> Index<EdgeIndex<Ix>> for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Output = E;\n    fn index(&self, index: EdgeIndex<Ix>) -> &E {\n        self.edge_weight(index).unwrap()\n    }\n}","impl<N, E, Ty, Ix> Index<NodeIndex<Ix>> for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Output = N;\n    fn index(&self, index: NodeIndex<Ix>) -> &N {\n        self.node_weight(index).unwrap()\n    }\n}","impl<N, E, Ty, Ix> IndexMut<EdgeIndex<Ix>> for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn index_mut(&mut self, index: EdgeIndex<Ix>) -> &mut E {\n        self.edge_weight_mut(index).unwrap()\n    }\n}","impl<N, E, Ty, Ix> IndexMut<NodeIndex<Ix>> for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn index_mut(&mut self, index: NodeIndex<Ix>) -> &mut N {\n        self.node_weight_mut(index).unwrap()\n    }\n}","impl<N, E, Ty, Ix> NodeCount for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn node_count(&self) -> usize {\n        self.node_count()\n    }\n}","impl<N, E, Ty, Ix> NodeIndexable for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    /// Return an upper bound of the node indices in the graph\n    fn node_bound(&self) -> usize {\n        self.node_indices().next_back().map_or(0, |i| i.index() + 1)\n    }\n    fn to_index(&self, ix: NodeIndex<Ix>) -> usize {\n        ix.index()\n    }\n    fn from_index(&self, ix: usize) -> Self::NodeId {\n        NodeIndex::new(ix)\n    }\n}","impl<N, E, Ty, Ix> StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    /// Create a new `StableGraph` with estimated capacity.\n    pub fn with_capacity(nodes: usize, edges: usize) -> Self {\n        StableGraph {\n            g: Graph::with_capacity(nodes, edges),\n            node_count: 0,\n            edge_count: 0,\n            free_node: NodeIndex::end(),\n            free_edge: EdgeIndex::end(),\n        }\n    }\n\n    /// Return the current node and edge capacity of the graph.\n    pub fn capacity(&self) -> (usize, usize) {\n        self.g.capacity()\n    }\n\n    /// Remove all nodes and edges\n    pub fn clear(&mut self) {\n        self.node_count = 0;\n        self.edge_count = 0;\n        self.free_node = NodeIndex::end();\n        self.free_edge = EdgeIndex::end();\n        self.g.clear();\n    }\n\n    /// Remove all edges\n    pub fn clear_edges(&mut self) {\n        self.edge_count = 0;\n        self.free_edge = EdgeIndex::end();\n        self.g.edges.clear();\n        // clear edges without touching the free list\n        for node in &mut self.g.nodes {\n            if node.weight.is_some() {\n                node.next = [EdgeIndex::end(), EdgeIndex::end()];\n            }\n        }\n    }\n\n    /// Return the number of nodes (vertices) in the graph.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn node_count(&self) -> usize {\n        self.node_count\n    }\n\n    /// Return the number of edges in the graph.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn edge_count(&self) -> usize {\n        self.edge_count\n    }\n\n    /// Whether the graph has directed edges or not.\n    #[inline]\n    pub fn is_directed(&self) -> bool {\n        Ty::is_directed()\n    }\n\n    /// Add a node (also called vertex) with associated data `weight` to the graph.\n    ///\n    /// Computes in **O(1)** time.\n    ///\n    /// Return the index of the new node.\n    ///\n    /// **Panics** if the `StableGraph` is at the maximum number of nodes for\n    /// its index type.\n    pub fn add_node(&mut self, weight: N) -> NodeIndex<Ix> {\n        let index = if self.free_node != NodeIndex::end() {\n            let node_idx = self.free_node;\n            let node_slot = &mut self.g.nodes[node_idx.index()];\n            let _old = replace(&mut node_slot.weight, Some(weight));\n            debug_assert!(_old.is_none());\n            self.free_node = node_slot.next[0]._into_node();\n            node_slot.next[0] = EdgeIndex::end();\n            node_idx\n        } else {\n            self.g.add_node(Some(weight))\n        };\n        self.node_count += 1;\n        index\n    }\n\n    /// free_node: Which free list to update for the vacancy\n    fn add_vacant_node(&mut self, free_node: &mut NodeIndex<Ix>) {\n        let node_idx = self.g.add_node(None);\n        // link the free list\n        let node_slot = &mut self.g.nodes[node_idx.index()];\n        node_slot.next[0] = free_node._into_edge();\n        *free_node = node_idx;\n    }\n\n    /// Remove `a` from the graph if it exists, and return its weight.\n    /// If it doesn't exist in the graph, return `None`.\n    ///\n    /// The node index `a` is invalidated, but none other.\n    /// Edge indices are invalidated as they would be following the removal of\n    /// each edge with an endpoint in `a`.\n    ///\n    /// Computes in **O(e')** time, where **e'** is the number of affected\n    /// edges, including *n* calls to `.remove_edge()` where *n* is the number\n    /// of edges with an endpoint in `a`.\n    pub fn remove_node(&mut self, a: NodeIndex<Ix>) -> Option<N> {\n        let node_weight = self.g.nodes.get_mut(a.index())?.weight.take()?;\n        for d in &DIRECTIONS {\n            let k = d.index();\n\n            // Remove all edges from and to this node.\n            loop {\n                let next = self.g.nodes[a.index()].next[k];\n                if next == EdgeIndex::end() {\n                    break;\n                }\n                let ret = self.remove_edge(next);\n                debug_assert!(ret.is_some());\n                let _ = ret;\n            }\n        }\n\n        let node_slot = &mut self.g.nodes[a.index()];\n        //let node_weight = replace(&mut self.g.nodes[a.index()].weight, Entry::Empty(self.free_node));\n        //self.g.nodes[a.index()].next = [EdgeIndex::end(), EdgeIndex::end()];\n        node_slot.next = [self.free_node._into_edge(), EdgeIndex::end()];\n        self.free_node = a;\n        self.node_count -= 1;\n\n        Some(node_weight)\n    }\n\n    pub fn contains_node(&self, a: NodeIndex<Ix>) -> bool {\n        self.get_node(a).is_some()\n    }\n\n    // Return the Node if it is not vacant (non-None weight)\n    fn get_node(&self, a: NodeIndex<Ix>) -> Option<&Node<Option<N>, Ix>> {\n        self.g\n            .nodes\n            .get(a.index())\n            .and_then(|node| node.weight.as_ref().map(move |_| node))\n    }\n\n    /// Add an edge from `a` to `b` to the graph, with its associated\n    /// data `weight`.\n    ///\n    /// Return the index of the new edge.\n    ///\n    /// Computes in **O(1)** time.\n    ///\n    /// **Panics** if any of the nodes don't exist.<br>\n    /// **Panics** if the `StableGraph` is at the maximum number of edges for\n    /// its index type.\n    ///\n    /// **Note:** `StableGraph` allows adding parallel (“duplicate”) edges.\n    pub fn add_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> EdgeIndex<Ix> {\n        let edge_idx;\n        let mut new_edge = None::<Edge<_, _>>;\n        {\n            let edge: &mut Edge<_, _>;\n\n            if self.free_edge != EdgeIndex::end() {\n                edge_idx = self.free_edge;\n                edge = &mut self.g.edges[edge_idx.index()];\n                let _old = replace(&mut edge.weight, Some(weight));\n                debug_assert!(_old.is_none());\n                self.free_edge = edge.next[0];\n                edge.node = [a, b];\n            } else {\n                edge_idx = EdgeIndex::new(self.g.edges.len());\n                assert!(<Ix as IndexType>::max().index() == !0 || EdgeIndex::end() != edge_idx);\n                new_edge = Some(Edge {\n                    weight: Some(weight),\n                    node: [a, b],\n                    next: [EdgeIndex::end(); 2],\n                });\n                edge = new_edge.as_mut().unwrap();\n            }\n\n            let wrong_index = match index_twice(&mut self.g.nodes, a.index(), b.index()) {\n                Pair::None => Some(cmp::max(a.index(), b.index())),\n                Pair::One(an) => {\n                    if an.weight.is_none() {\n                        Some(a.index())\n                    } else {\n                        edge.next = an.next;\n                        an.next[0] = edge_idx;\n                        an.next[1] = edge_idx;\n                        None\n                    }\n                }\n                Pair::Both(an, bn) => {\n                    // a and b are different indices\n                    if an.weight.is_none() {\n                        Some(a.index())\n                    } else if bn.weight.is_none() {\n                        Some(b.index())\n                    } else {\n                        edge.next = [an.next[0], bn.next[1]];\n                        an.next[0] = edge_idx;\n                        bn.next[1] = edge_idx;\n                        None\n                    }\n                }\n            };\n            if let Some(i) = wrong_index {\n                panic!(\n                    \"StableGraph::add_edge: node index {} is not a node in the graph\",\n                    i\n                );\n            }\n            self.edge_count += 1;\n        }\n        if let Some(edge) = new_edge {\n            self.g.edges.push(edge);\n        }\n        edge_idx\n    }\n\n    /// free_edge: Which free list to update for the vacancy\n    fn add_vacant_edge(&mut self, free_edge: &mut EdgeIndex<Ix>) {\n        let edge_idx = EdgeIndex::new(self.g.edges.len());\n        debug_assert!(edge_idx != EdgeIndex::end());\n        let mut edge = Edge {\n            weight: None,\n            node: [NodeIndex::end(); 2],\n            next: [EdgeIndex::end(); 2],\n        };\n        edge.next[0] = *free_edge;\n        *free_edge = edge_idx;\n        self.g.edges.push(edge);\n    }\n\n    /// Add or update an edge from `a` to `b`.\n    /// If the edge already exists, its weight is updated.\n    ///\n    /// Return the index of the affected edge.\n    ///\n    /// Computes in **O(e')** time, where **e'** is the number of edges\n    /// connected to `a` (and `b`, if the graph edges are undirected).\n    ///\n    /// **Panics** if any of the nodes don't exist.\n    pub fn update_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> EdgeIndex<Ix> {\n        if let Some(ix) = self.find_edge(a, b) {\n            self[ix] = weight;\n            return ix;\n        }\n        self.add_edge(a, b, weight)\n    }\n\n    /// Remove an edge and return its edge weight, or `None` if it didn't exist.\n    ///\n    /// Invalidates the edge index `e` but no other.\n    ///\n    /// Computes in **O(e')** time, where **e'** is the number of edges\n    /// connected to the same endpoints as `e`.\n    pub fn remove_edge(&mut self, e: EdgeIndex<Ix>) -> Option<E> {\n        // every edge is part of two lists,\n        // outgoing and incoming edges.\n        // Remove it from both\n        let (is_edge, edge_node, edge_next) = match self.g.edges.get(e.index()) {\n            None => return None,\n            Some(x) => (x.weight.is_some(), x.node, x.next),\n        };\n        if !is_edge {\n            return None;\n        }\n\n        // Remove the edge from its in and out lists by replacing it with\n        // a link to the next in the list.\n        self.g.change_edge_links(edge_node, e, edge_next);\n\n        // Clear the edge and put it in the free list\n        let edge = &mut self.g.edges[e.index()];\n        edge.next = [self.free_edge, EdgeIndex::end()];\n        edge.node = [NodeIndex::end(), NodeIndex::end()];\n        self.free_edge = e;\n        self.edge_count -= 1;\n        edge.weight.take()\n    }\n\n    /// Access the weight for node `a`.\n    ///\n    /// Also available with indexing syntax: `&graph[a]`.\n    pub fn node_weight(&self, a: NodeIndex<Ix>) -> Option<&N> {\n        match self.g.nodes.get(a.index()) {\n            Some(no) => no.weight.as_ref(),\n            None => None,\n        }\n    }\n\n    /// Access the weight for node `a`, mutably.\n    ///\n    /// Also available with indexing syntax: `&mut graph[a]`.\n    pub fn node_weight_mut(&mut self, a: NodeIndex<Ix>) -> Option<&mut N> {\n        match self.g.nodes.get_mut(a.index()) {\n            Some(no) => no.weight.as_mut(),\n            None => None,\n        }\n    }\n\n    /// Return an iterator yielding mutable access to all node weights.\n    ///\n    /// The order in which weights are yielded matches the order of their node\n    /// indices.\n    pub fn node_weights_mut(&mut self) -> impl Iterator<Item = &mut N> {\n        self.g\n            .node_weights_mut()\n            .flat_map(|maybe_node| maybe_node.iter_mut())\n    }\n\n    /// Return an iterator over the node indices of the graph\n    pub fn node_indices(&self) -> NodeIndices<N, Ix> {\n        NodeIndices {\n            iter: enumerate(self.raw_nodes()),\n        }\n    }\n\n    /// Access the weight for edge `e`.\n    ///\n    /// Also available with indexing syntax: `&graph[e]`.\n    pub fn edge_weight(&self, e: EdgeIndex<Ix>) -> Option<&E> {\n        match self.g.edges.get(e.index()) {\n            Some(ed) => ed.weight.as_ref(),\n            None => None,\n        }\n    }\n\n    /// Access the weight for edge `e`, mutably\n    ///\n    /// Also available with indexing syntax: `&mut graph[e]`.\n    pub fn edge_weight_mut(&mut self, e: EdgeIndex<Ix>) -> Option<&mut E> {\n        match self.g.edges.get_mut(e.index()) {\n            Some(ed) => ed.weight.as_mut(),\n            None => None,\n        }\n    }\n\n    /// Return an iterator yielding mutable access to all edge weights.\n    ///\n    /// The order in which weights are yielded matches the order of their edge\n    /// indices.\n    pub fn edge_weights_mut(&mut self) -> impl Iterator<Item = &mut E> {\n        self.g\n            .edge_weights_mut()\n            .flat_map(|maybe_edge| maybe_edge.iter_mut())\n    }\n\n    /// Access the source and target nodes for `e`.\n    pub fn edge_endpoints(&self, e: EdgeIndex<Ix>) -> Option<(NodeIndex<Ix>, NodeIndex<Ix>)> {\n        match self.g.edges.get(e.index()) {\n            Some(ed) if ed.weight.is_some() => Some((ed.source(), ed.target())),\n            _otherwise => None,\n        }\n    }\n\n    /// Return an iterator over the edge indices of the graph\n    pub fn edge_indices(&self) -> EdgeIndices<E, Ix> {\n        EdgeIndices {\n            iter: enumerate(self.raw_edges()),\n        }\n    }\n\n    /// Lookup if there is an edge from `a` to `b`.\n    ///\n    /// Computes in **O(e')** time, where **e'** is the number of edges\n    /// connected to `a` (and `b`, if the graph edges are undirected).\n    pub fn contains_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool {\n        self.find_edge(a, b).is_some()\n    }\n\n    /// Lookup an edge from `a` to `b`.\n    ///\n    /// Computes in **O(e')** time, where **e'** is the number of edges\n    /// connected to `a` (and `b`, if the graph edges are undirected).\n    pub fn find_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> Option<EdgeIndex<Ix>> {\n        if !self.is_directed() {\n            self.find_edge_undirected(a, b).map(|(ix, _)| ix)\n        } else {\n            match self.get_node(a) {\n                None => None,\n                Some(node) => self.g.find_edge_directed_from_node(node, b),\n            }\n        }\n    }\n\n    /// Lookup an edge between `a` and `b`, in either direction.\n    ///\n    /// If the graph is undirected, then this is equivalent to `.find_edge()`.\n    ///\n    /// Return the edge index and its directionality, with `Outgoing` meaning\n    /// from `a` to `b` and `Incoming` the reverse,\n    /// or `None` if the edge does not exist.\n    pub fn find_edge_undirected(\n        &self,\n        a: NodeIndex<Ix>,\n        b: NodeIndex<Ix>,\n    ) -> Option<(EdgeIndex<Ix>, Direction)> {\n        match self.get_node(a) {\n            None => None,\n            Some(node) => self.g.find_edge_undirected_from_node(node, b),\n        }\n    }\n\n    /// Return an iterator of all nodes with an edge starting from `a`.\n    ///\n    /// - `Directed`: Outgoing edges from `a`.\n    /// - `Undirected`: All edges connected to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is `NodeIndex<Ix>`.\n    ///\n    /// Use [`.neighbors(a).detach()`][1] to get a neighbor walker that does\n    /// not borrow from the graph.\n    ///\n    /// [1]: struct.Neighbors.html#method.detach\n    pub fn neighbors(&self, a: NodeIndex<Ix>) -> Neighbors<E, Ix> {\n        self.neighbors_directed(a, Outgoing)\n    }\n\n    /// Return an iterator of all neighbors that have an edge between them and `a`,\n    /// in the specified direction.\n    /// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n    ///\n    /// - `Directed`, `Outgoing`: All edges from `a`.\n    /// - `Directed`, `Incoming`: All edges to `a`.\n    /// - `Undirected`: All edges connected to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is `NodeIndex<Ix>`.\n    ///\n    /// Use [`.neighbors_directed(a, dir).detach()`][1] to get a neighbor walker that does\n    /// not borrow from the graph.\n    ///\n    /// [1]: struct.Neighbors.html#method.detach\n    pub fn neighbors_directed(&self, a: NodeIndex<Ix>, dir: Direction) -> Neighbors<E, Ix> {\n        let mut iter = self.neighbors_undirected(a);\n        if self.is_directed() {\n            let k = dir.index();\n            iter.next[1 - k] = EdgeIndex::end();\n            iter.skip_start = NodeIndex::end();\n        }\n        iter\n    }\n\n    /// Return an iterator of all neighbors that have an edge between them and `a`,\n    /// in either direction.\n    /// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n    ///\n    /// - `Directed` and `Undirected`: All edges connected to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is `NodeIndex<Ix>`.\n    ///\n    /// Use [`.neighbors_undirected(a).detach()`][1] to get a neighbor walker that does\n    /// not borrow from the graph.\n    ///\n    /// [1]: struct.Neighbors.html#method.detach\n    pub fn neighbors_undirected(&self, a: NodeIndex<Ix>) -> Neighbors<E, Ix> {\n        Neighbors {\n            skip_start: a,\n            edges: &self.g.edges,\n            next: match self.get_node(a) {\n                None => [EdgeIndex::end(), EdgeIndex::end()],\n                Some(n) => n.next,\n            },\n        }\n    }\n\n    /// Return an iterator of all edges of `a`.\n    ///\n    /// - `Directed`: Outgoing edges from `a`.\n    /// - `Undirected`: All edges connected to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is `EdgeReference<E, Ix>`.\n    pub fn edges(&self, a: NodeIndex<Ix>) -> Edges<E, Ty, Ix> {\n        self.edges_directed(a, Outgoing)\n    }\n\n    /// Return an iterator of all edges of `a`, in the specified direction.\n    ///\n    /// - `Directed`, `Outgoing`: All edges from `a`.\n    /// - `Directed`, `Incoming`: All edges to `a`.\n    /// - `Undirected`, `Outgoing`: All edges connected to `a`, with `a` being the source of each\n    ///   edge.\n    /// - `Undirected`, `Incoming`: All edges connected to `a`, with `a` being the target of each\n    ///   edge.\n    ///\n    /// Produces an empty iterator if the node `a` doesn't exist.<br>\n    /// Iterator element type is `EdgeReference<E, Ix>`.\n    pub fn edges_directed(&self, a: NodeIndex<Ix>, dir: Direction) -> Edges<E, Ty, Ix> {\n        Edges {\n            skip_start: a,\n            edges: &self.g.edges,\n            direction: dir,\n            next: match self.get_node(a) {\n                None => [EdgeIndex::end(), EdgeIndex::end()],\n                Some(n) => n.next,\n            },\n            ty: PhantomData,\n        }\n    }\n\n    /// Return an iterator over either the nodes without edges to them\n    /// (`Incoming`) or from them (`Outgoing`).\n    ///\n    /// An *internal* node has both incoming and outgoing edges.\n    /// The nodes in `.externals(Incoming)` are the source nodes and\n    /// `.externals(Outgoing)` are the sinks of the graph.\n    ///\n    /// For a graph with undirected edges, both the sinks and the sources are\n    /// just the nodes without edges.\n    ///\n    /// The whole iteration computes in **O(|V|)** time.\n    pub fn externals(&self, dir: Direction) -> Externals<N, Ty, Ix> {\n        Externals {\n            iter: self.raw_nodes().iter().enumerate(),\n            dir,\n            ty: PhantomData,\n        }\n    }\n\n    /// Index the `StableGraph` by two indices, any combination of\n    /// node or edge indices is fine.\n    ///\n    /// **Panics** if the indices are equal or if they are out of bounds.\n    pub fn index_twice_mut<T, U>(\n        &mut self,\n        i: T,\n        j: U,\n    ) -> (\n        &mut <Self as Index<T>>::Output,\n        &mut <Self as Index<U>>::Output,\n    )\n    where\n        Self: IndexMut<T> + IndexMut<U>,\n        T: GraphIndex,\n        U: GraphIndex,\n    {\n        assert!(T::is_node_index() != U::is_node_index() || i.index() != j.index());\n\n        // Allow two mutable indexes here -- they are nonoverlapping\n        unsafe {\n            let self_mut = self as *mut _;\n            (\n                <Self as IndexMut<T>>::index_mut(&mut *self_mut, i),\n                <Self as IndexMut<U>>::index_mut(&mut *self_mut, j),\n            )\n        }\n    }\n\n    /// Keep all nodes that return `true` from the `visit` closure,\n    /// remove the others.\n    ///\n    /// `visit` is provided a proxy reference to the graph, so that\n    /// the graph can be walked and associated data modified.\n    ///\n    /// The order nodes are visited is not specified.\n    ///\n    /// The node indices of the removed nodes are invalidated, but none other.\n    /// Edge indices are invalidated as they would be following the removal of\n    /// each edge with an endpoint in a removed node.\n    ///\n    /// Computes in **O(n + e')** time, where **n** is the number of node indices and\n    ///  **e'** is the number of affected edges, including *n* calls to `.remove_edge()`\n    /// where *n* is the number of edges with an endpoint in a removed node.\n    pub fn retain_nodes<F>(&mut self, mut visit: F)\n    where\n        F: FnMut(Frozen<Self>, NodeIndex<Ix>) -> bool,\n    {\n        for i in 0..self.node_bound() {\n            let ix = node_index(i);\n            if self.contains_node(ix) && !visit(Frozen(self), ix) {\n                self.remove_node(ix);\n            }\n        }\n        self.check_free_lists();\n    }\n\n    /// Keep all edges that return `true` from the `visit` closure,\n    /// remove the others.\n    ///\n    /// `visit` is provided a proxy reference to the graph, so that\n    /// the graph can be walked and associated data modified.\n    ///\n    /// The order edges are visited is not specified.\n    ///\n    /// The edge indices of the removed edes are invalidated, but none other.\n    ///\n    /// Computes in **O(e'')** time, **e'** is the number of affected edges,\n    /// including the calls to `.remove_edge()` for each removed edge.\n    pub fn retain_edges<F>(&mut self, mut visit: F)\n    where\n        F: FnMut(Frozen<Self>, EdgeIndex<Ix>) -> bool,\n    {\n        for i in 0..self.edge_bound() {\n            let ix = edge_index(i);\n            if self.edge_weight(ix).is_some() && !visit(Frozen(self), ix) {\n                self.remove_edge(ix);\n            }\n        }\n        self.check_free_lists();\n    }\n\n    /// Create a new `StableGraph` from an iterable of edges.\n    ///\n    /// Node weights `N` are set to default values.\n    /// Edge weights `E` may either be specified in the list,\n    /// or they are filled with default values.\n    ///\n    /// Nodes are inserted automatically to match the edges.\n    ///\n    /// ```\n    /// use petgraph::stable_graph::StableGraph;\n    ///\n    /// let gr = StableGraph::<(), i32>::from_edges(&[\n    ///     (0, 1), (0, 2), (0, 3),\n    ///     (1, 2), (1, 3),\n    ///     (2, 3),\n    /// ]);\n    /// ```\n    pub fn from_edges<I>(iterable: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,\n    {\n        let mut g = Self::with_capacity(0, 0);\n        g.extend_with_edges(iterable);\n        g\n    }\n\n    /// Create a new `StableGraph` by mapping node and\n    /// edge weights to new values.\n    ///\n    /// The resulting graph has the same structure and the same\n    /// graph indices as `self`.\n    pub fn map<'a, F, G, N2, E2>(\n        &'a self,\n        mut node_map: F,\n        mut edge_map: G,\n    ) -> StableGraph<N2, E2, Ty, Ix>\n    where\n        F: FnMut(NodeIndex<Ix>, &'a N) -> N2,\n        G: FnMut(EdgeIndex<Ix>, &'a E) -> E2,\n    {\n        let g = self.g.map(\n            move |i, w| w.as_ref().map(|w| node_map(i, w)),\n            move |i, w| w.as_ref().map(|w| edge_map(i, w)),\n        );\n        StableGraph {\n            g,\n            node_count: self.node_count,\n            edge_count: self.edge_count,\n            free_node: self.free_node,\n            free_edge: self.free_edge,\n        }\n    }\n\n    /// Create a new `StableGraph` by mapping nodes and edges.\n    /// A node or edge may be mapped to `None` to exclude it from\n    /// the resulting graph.\n    ///\n    /// Nodes are mapped first with the `node_map` closure, then\n    /// `edge_map` is called for the edges that have not had any endpoint\n    /// removed.\n    ///\n    /// The resulting graph has the structure of a subgraph of the original graph.\n    /// Nodes and edges that are not removed maintain their old node or edge\n    /// indices.\n    pub fn filter_map<'a, F, G, N2, E2>(\n        &'a self,\n        mut node_map: F,\n        mut edge_map: G,\n    ) -> StableGraph<N2, E2, Ty, Ix>\n    where\n        F: FnMut(NodeIndex<Ix>, &'a N) -> Option<N2>,\n        G: FnMut(EdgeIndex<Ix>, &'a E) -> Option<E2>,\n    {\n        let node_bound = self.node_bound();\n        let edge_bound = self.edge_bound();\n        let mut result_g = StableGraph::with_capacity(node_bound, edge_bound);\n        // use separate free lists so that\n        // add_node / add_edge below do not reuse the tombstones\n        let mut free_node = NodeIndex::end();\n        let mut free_edge = EdgeIndex::end();\n\n        // the stable graph keeps the node map itself\n\n        for (i, node) in enumerate(self.raw_nodes()) {\n            if i >= node_bound {\n                break;\n            }\n            if let Some(node_weight) = node.weight.as_ref() {\n                if let Some(new_weight) = node_map(NodeIndex::new(i), node_weight) {\n                    result_g.add_node(new_weight);\n                    continue;\n                }\n            }\n            result_g.add_vacant_node(&mut free_node);\n        }\n        for (i, edge) in enumerate(self.raw_edges()) {\n            if i >= edge_bound {\n                break;\n            }\n            let source = edge.source();\n            let target = edge.target();\n            if let Some(edge_weight) = edge.weight.as_ref() {\n                if result_g.contains_node(source) && result_g.contains_node(target) {\n                    if let Some(new_weight) = edge_map(EdgeIndex::new(i), edge_weight) {\n                        result_g.add_edge(source, target, new_weight);\n                        continue;\n                    }\n                }\n            }\n            result_g.add_vacant_edge(&mut free_edge);\n        }\n        result_g.free_node = free_node;\n        result_g.free_edge = free_edge;\n        result_g.check_free_lists();\n        result_g\n    }\n\n    /// Extend the graph from an iterable of edges.\n    ///\n    /// Node weights `N` are set to default values.\n    /// Edge weights `E` may either be specified in the list,\n    /// or they are filled with default values.\n    ///\n    /// Nodes are inserted automatically to match the edges.\n    pub fn extend_with_edges<I>(&mut self, iterable: I)\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,\n    {\n        let iter = iterable.into_iter();\n\n        for elt in iter {\n            let (source, target, weight) = elt.into_weighted_edge();\n            let (source, target) = (source.into(), target.into());\n            let nx = cmp::max(source, target);\n            while nx.index() >= self.node_count() {\n                self.add_node(N::default());\n            }\n            self.add_edge(source, target, weight);\n        }\n    }\n\n    //\n    // internal methods\n    //\n    fn raw_nodes(&self) -> &[Node<Option<N>, Ix>] {\n        self.g.raw_nodes()\n    }\n\n    fn raw_edges(&self) -> &[Edge<Option<E>, Ix>] {\n        self.g.raw_edges()\n    }\n\n    fn edge_bound(&self) -> usize {\n        self.edge_references()\n            .next_back()\n            .map_or(0, |edge| edge.id().index() + 1)\n    }\n\n    #[cfg(feature = \"serde-1\")]\n    /// Fix up node and edge links after deserialization\n    fn link_edges(&mut self) -> Result<(), NodeIndex<Ix>> {\n        // set up free node list\n        self.node_count = 0;\n        self.edge_count = 0;\n        let mut free_node = NodeIndex::end();\n        for (node_index, node) in enumerate(&mut self.g.nodes) {\n            if node.weight.is_some() {\n                self.node_count += 1;\n            } else {\n                // free node\n                node.next = [free_node._into_edge(), EdgeIndex::end()];\n                free_node = NodeIndex::new(node_index);\n            }\n        }\n        self.free_node = free_node;\n\n        let mut free_edge = EdgeIndex::end();\n        for (edge_index, edge) in enumerate(&mut self.g.edges) {\n            if edge.weight.is_none() {\n                // free edge\n                edge.next = [free_edge, EdgeIndex::end()];\n                free_edge = EdgeIndex::new(edge_index);\n                continue;\n            }\n            let a = edge.source();\n            let b = edge.target();\n            let edge_idx = EdgeIndex::new(edge_index);\n            match index_twice(&mut self.g.nodes, a.index(), b.index()) {\n                Pair::None => return Err(if a > b { a } else { b }),\n                Pair::One(an) => {\n                    edge.next = an.next;\n                    an.next[0] = edge_idx;\n                    an.next[1] = edge_idx;\n                }\n                Pair::Both(an, bn) => {\n                    // a and b are different indices\n                    edge.next = [an.next[0], bn.next[1]];\n                    an.next[0] = edge_idx;\n                    bn.next[1] = edge_idx;\n                }\n            }\n            self.edge_count += 1;\n        }\n        self.free_edge = free_edge;\n        Ok(())\n    }\n\n    #[cfg(not(debug_assertions))]\n    fn check_free_lists(&self) {}\n    #[cfg(debug_assertions)]\n    // internal method to debug check the free lists (linked lists)\n    fn check_free_lists(&self) {\n        let mut free_node = self.free_node;\n        let mut free_node_len = 0;\n        while free_node != NodeIndex::end() {\n            if let Some(n) = self.g.nodes.get(free_node.index()) {\n                if n.weight.is_none() {\n                    free_node = n.next[0]._into_node();\n                    free_node_len += 1;\n                    continue;\n                }\n                debug_assert!(\n                    false,\n                    \"Corrupt free list: pointing to existing {:?}\",\n                    free_node.index()\n                );\n            }\n            debug_assert!(false, \"Corrupt free list: missing {:?}\", free_node.index());\n        }\n        debug_assert_eq!(self.node_count(), self.raw_nodes().len() - free_node_len);\n\n        let mut free_edge_len = 0;\n        let mut free_edge = self.free_edge;\n        while free_edge != EdgeIndex::end() {\n            if let Some(n) = self.g.edges.get(free_edge.index()) {\n                if n.weight.is_none() {\n                    free_edge = n.next[0];\n                    free_edge_len += 1;\n                    continue;\n                }\n                debug_assert!(\n                    false,\n                    \"Corrupt free list: pointing to existing {:?}\",\n                    free_node.index()\n                );\n            }\n            debug_assert!(false, \"Corrupt free list: missing {:?}\", free_edge.index());\n        }\n        debug_assert_eq!(self.edge_count(), self.raw_edges().len() - free_edge_len);\n    }\n}","impl<N, E, Ty, Ix> Visitable for StableGraph<N, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    type Map = FixedBitSet;\n    fn visit_map(&self) -> FixedBitSet {\n        FixedBitSet::with_capacity(self.node_bound())\n    }\n    fn reset_map(&self, map: &mut Self::Map) {\n        map.clear();\n        map.grow(self.node_bound());\n    }\n}","impl<N, E, Ty, Ix> fmt::Debug for StableGraph<N, E, Ty, Ix>\nwhere\n    N: fmt::Debug,\n    E: fmt::Debug,\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let etype = if self.is_directed() {\n            \"Directed\"\n        } else {\n            \"Undirected\"\n        };\n        let mut fmt_struct = f.debug_struct(\"StableGraph\");\n        fmt_struct.field(\"Ty\", &etype);\n        fmt_struct.field(\"node_count\", &self.node_count);\n        fmt_struct.field(\"edge_count\", &self.edge_count);\n        if self.g.edges.iter().any(|e| e.weight.is_some()) {\n            fmt_struct.field(\n                \"edges\",\n                &self\n                    .g\n                    .edges\n                    .iter()\n                    .filter(|e| e.weight.is_some())\n                    .map(|e| NoPretty((e.source().index(), e.target().index())))\n                    .format(\", \"),\n            );\n        }\n        // skip weights if they are ZST!\n        if size_of::<N>() != 0 {\n            fmt_struct.field(\n                \"node weights\",\n                &DebugMap(|| {\n                    self.g\n                        .nodes\n                        .iter()\n                        .map(|n| n.weight.as_ref())\n                        .enumerate()\n                        .filter_map(|(i, wo)| wo.map(move |w| (i, w)))\n                }),\n            );\n        }\n        if size_of::<E>() != 0 {\n            fmt_struct.field(\n                \"edge weights\",\n                &DebugMap(|| {\n                    self.g\n                        .edges\n                        .iter()\n                        .map(|n| n.weight.as_ref())\n                        .enumerate()\n                        .filter_map(|(i, wo)| wo.map(move |w| (i, w)))\n                }),\n            );\n        }\n        fmt_struct.field(\"free_node\", &self.free_node);\n        fmt_struct.field(\"free_edge\", &self.free_edge);\n        fmt_struct.finish()\n    }\n}","impl<N, E> StableGraph<N, E, Directed> {\n    /// Create a new `StableGraph` with directed edges.\n    ///\n    /// This is a convenience method. See `StableGraph::with_capacity`\n    /// or `StableGraph::default` for a constructor that is generic in all the\n    /// type parameters of `StableGraph`.\n    pub fn new() -> Self {\n        Self::with_capacity(0, 0)\n    }\n}"],"graph_impl::stable_graph::WalkNeighbors":["impl<Ix: IndexType> Clone for WalkNeighbors<Ix> {\n    clone_fields!(WalkNeighbors, inner);\n}","impl<Ix: IndexType> WalkNeighbors<Ix> {\n    /// Step to the next edge and its endpoint node in the walk for graph `g`.\n    ///\n    /// The next node indices are always the others than the starting point\n    /// where the `WalkNeighbors` value was created.\n    /// For an `Outgoing` walk, the target nodes,\n    /// for an `Incoming` walk, the source nodes of the edge.\n    pub fn next<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &StableGraph<N, E, Ty, Ix>,\n    ) -> Option<(EdgeIndex<Ix>, NodeIndex<Ix>)> {\n        self.inner.next(&g.g)\n    }\n\n    pub fn next_node<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &StableGraph<N, E, Ty, Ix>,\n    ) -> Option<NodeIndex<Ix>> {\n        self.next(g).map(|t| t.1)\n    }\n\n    pub fn next_edge<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &StableGraph<N, E, Ty, Ix>,\n    ) -> Option<EdgeIndex<Ix>> {\n        self.next(g).map(|t| t.0)\n    }\n}"],"graphmap::AllEdges":["impl<'a, N, E, Ty> DoubleEndedIterator for AllEdges<'a, N, E, Ty>\nwhere\n    N: 'a + NodeTrait,\n    E: 'a,\n    Ty: EdgeType,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.inner\n            .next_back()\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }\n}","impl<'a, N, E, Ty> Iterator for AllEdges<'a, N, E, Ty>\nwhere\n    N: 'a + NodeTrait,\n    E: 'a,\n    Ty: EdgeType,\n{\n    type Item = (N, N, &'a E);\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.inner.next() {\n            None => None,\n            Some((&(a, b), v)) => Some((a, b, v)),\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n\n    fn count(self) -> usize {\n        self.inner.count()\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        self.inner\n            .nth(n)\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        self.inner\n            .last()\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }\n}"],"graphmap::AllEdgesMut":["impl<'a, N, E, Ty> DoubleEndedIterator for AllEdgesMut<'a, N, E, Ty>\nwhere\n    N: 'a + NodeTrait,\n    E: 'a,\n    Ty: EdgeType,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.inner\n            .next_back()\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }\n}","impl<'a, N, E, Ty> Iterator for AllEdgesMut<'a, N, E, Ty>\nwhere\n    N: 'a + NodeTrait,\n    E: 'a,\n    Ty: EdgeType,\n{\n    type Item = (N, N, &'a mut E);\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner\n            .next()\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n\n    fn count(self) -> usize {\n        self.inner.count()\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        self.inner\n            .nth(n)\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        self.inner\n            .last()\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }\n}"],"graphmap::CompactDirection":["Clone","Copy","Debug","PartialEq","impl From<Direction> for CompactDirection {\n    fn from(d: Direction) -> Self {\n        match d {\n            Outgoing => CompactDirection::Outgoing,\n            Incoming => CompactDirection::Incoming,\n        }\n    }\n}","impl PartialEq<Direction> for CompactDirection {\n    fn eq(&self, rhs: &Direction) -> bool {\n        (*self as usize) == (*rhs as usize)\n    }\n}"],"graphmap::Edges":["impl<'a, N, E, Ty> Iterator for Edges<'a, N, E, Ty>\nwhere\n    N: 'a + NodeTrait,\n    E: 'a,\n    Ty: EdgeType,\n{\n    type Item = (N, N, &'a E);\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.iter.next() {\n            None => None,\n            Some(b) => {\n                let a = self.from;\n                match self.edges.get(&GraphMap::<N, E, Ty>::edge_key(a, b)) {\n                    None => unreachable!(),\n                    Some(edge) => Some((a, b, edge)),\n                }\n            }\n        }\n    }\n}"],"graphmap::GraphMap":["Clone","impl<N, E, Ty, Item> Extend<Item> for GraphMap<N, E, Ty>\nwhere\n    Item: IntoWeightedEdge<E, NodeId = N>,\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n    fn extend<I>(&mut self, iterable: I)\n    where\n        I: IntoIterator<Item = Item>,\n    {\n        let iter = iterable.into_iter();\n        let (low, _) = iter.size_hint();\n        self.edges.reserve(low);\n\n        for elt in iter {\n            let (source, target, weight) = elt.into_weighted_edge();\n            self.add_edge(source, target, weight);\n        }\n    }\n}","impl<N, E, Ty, Item> FromIterator<Item> for GraphMap<N, E, Ty>\nwhere\n    Item: IntoWeightedEdge<E, NodeId = N>,\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n    fn from_iter<I>(iterable: I) -> Self\n    where\n        I: IntoIterator<Item = Item>,\n    {\n        let iter = iterable.into_iter();\n        let (low, _) = iter.size_hint();\n        let mut g = Self::with_capacity(0, low);\n        g.extend(iter);\n        g\n    }\n}","impl<N, E, Ty> Build for GraphMap<N, E, Ty>\nwhere\n    Ty: EdgeType,\n    N: NodeTrait,\n{\n    fn add_node(&mut self, weight: Self::NodeWeight) -> Self::NodeId {\n        self.add_node(weight)\n    }\n    fn add_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Option<Self::EdgeId> {\n        if self.contains_edge(a, b) {\n            None\n        } else {\n            let r = self.add_edge(a, b, weight);\n            debug_assert!(r.is_none());\n            Some((a, b))\n        }\n    }\n    fn update_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Self::EdgeId {\n        self.add_edge(a, b, weight);\n        (a, b)\n    }\n}","impl<N, E, Ty> Create for GraphMap<N, E, Ty>\nwhere\n    Ty: EdgeType,\n    N: NodeTrait,\n{\n    fn with_capacity(nodes: usize, edges: usize) -> Self {\n        Self::with_capacity(nodes, edges)\n    }\n}","impl<N, E, Ty> Data for GraphMap<N, E, Ty>\nwhere\n    N: Copy + PartialEq,\n    Ty: EdgeType,\n{\n    type NodeWeight = N;\n    type EdgeWeight = E;\n}","impl<N, E, Ty> Default for GraphMap<N, E, Ty>\nwhere\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n    fn default() -> Self {\n        GraphMap::with_capacity(0, 0)\n    }\n}","impl<N, E, Ty> FromElements for GraphMap<N, E, Ty>\nwhere\n    Ty: EdgeType,\n    N: NodeTrait,\n{\n    fn from_elements<I>(iterable: I) -> Self\n    where\n        Self: Sized,\n        I: IntoIterator<Item = Element<Self::NodeWeight, Self::EdgeWeight>>,\n    {\n        from_elements_indexable(iterable)\n    }\n}","impl<N, E, Ty> GetAdjacencyMatrix for GraphMap<N, E, Ty>\nwhere\n    N: Copy + Ord + Hash,\n    Ty: EdgeType,\n{\n    type AdjMatrix = ();\n    #[inline]\n    fn adjacency_matrix(&self) {}\n    #[inline]\n    fn is_adjacent(&self, _: &(), a: N, b: N) -> bool {\n        self.contains_edge(a, b)\n    }\n}","impl<N, E, Ty> GraphBase for GraphMap<N, E, Ty>\nwhere\n    N: Copy + PartialEq,\n{\n    type NodeId = N;\n    type EdgeId = (N, N);\n}","impl<N, E, Ty> GraphMap<N, E, Ty>\nwhere\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n    /// Create a new `GraphMap`\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Create a new `GraphMap` with estimated capacity.\n    pub fn with_capacity(nodes: usize, edges: usize) -> Self {\n        GraphMap {\n            nodes: IndexMap::with_capacity(nodes),\n            edges: IndexMap::with_capacity(edges),\n            ty: PhantomData,\n        }\n    }\n\n    /// Return the current node and edge capacity of the graph.\n    pub fn capacity(&self) -> (usize, usize) {\n        (self.nodes.capacity(), self.edges.capacity())\n    }\n\n    /// Use their natural order to map the node pair (a, b) to a canonical edge id.\n    #[inline]\n    fn edge_key(a: N, b: N) -> (N, N) {\n        if Ty::is_directed() || a <= b {\n            (a, b)\n        } else {\n            (b, a)\n        }\n    }\n\n    /// Whether the graph has directed edges.\n    pub fn is_directed(&self) -> bool {\n        Ty::is_directed()\n    }\n\n    /// Create a new `GraphMap` from an iterable of edges.\n    ///\n    /// Node values are taken directly from the list.\n    /// Edge weights `E` may either be specified in the list,\n    /// or they are filled with default values.\n    ///\n    /// Nodes are inserted automatically to match the edges.\n    ///\n    /// ```\n    /// use petgraph::graphmap::UnGraphMap;\n    ///\n    /// // Create a new undirected GraphMap.\n    /// // Use a type hint to have `()` be the edge weight type.\n    /// let gr = UnGraphMap::<_, ()>::from_edges(&[\n    ///     (0, 1), (0, 2), (0, 3),\n    ///     (1, 2), (1, 3),\n    ///     (2, 3),\n    /// ]);\n    /// ```\n    pub fn from_edges<I>(iterable: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E, NodeId = N>,\n    {\n        Self::from_iter(iterable)\n    }\n\n    /// Return the number of nodes in the graph.\n    pub fn node_count(&self) -> usize {\n        self.nodes.len()\n    }\n\n    /// Return the number of edges in the graph.\n    pub fn edge_count(&self) -> usize {\n        self.edges.len()\n    }\n\n    /// Remove all nodes and edges\n    pub fn clear(&mut self) {\n        self.nodes.clear();\n        self.edges.clear();\n    }\n\n    /// Add node `n` to the graph.\n    pub fn add_node(&mut self, n: N) -> N {\n        self.nodes.entry(n).or_insert(Vec::new());\n        n\n    }\n\n    /// Return `true` if node `n` was removed.\n    ///\n    /// Computes in **O(V)** time, due to the removal of edges with other nodes.\n    pub fn remove_node(&mut self, n: N) -> bool {\n        let links = match self.nodes.swap_remove(&n) {\n            None => return false,\n            Some(sus) => sus,\n        };\n        for (succ, _) in links {\n            // remove all successor links\n            self.remove_single_edge(&succ, &n, Incoming);\n            // Remove all edge values\n            self.edges.swap_remove(&Self::edge_key(n, succ));\n        }\n        true\n    }\n\n    /// Return `true` if the node is contained in the graph.\n    pub fn contains_node(&self, n: N) -> bool {\n        self.nodes.contains_key(&n)\n    }\n\n    /// Add an edge connecting `a` and `b` to the graph, with associated\n    /// data `weight`. For a directed graph, the edge is directed from `a`\n    /// to `b`.\n    ///\n    /// Inserts nodes `a` and/or `b` if they aren't already part of the graph.\n    ///\n    /// Return `None` if the edge did not previously exist, otherwise,\n    /// the associated data is updated and the old value is returned\n    /// as `Some(old_weight)`.\n    ///\n    /// ```\n    /// // Create a GraphMap with directed edges, and add one edge to it\n    /// use petgraph::graphmap::DiGraphMap;\n    ///\n    /// let mut g = DiGraphMap::new();\n    /// g.add_edge(\"x\", \"y\", -1);\n    /// assert_eq!(g.node_count(), 2);\n    /// assert_eq!(g.edge_count(), 1);\n    /// assert!(g.contains_edge(\"x\", \"y\"));\n    /// assert!(!g.contains_edge(\"y\", \"x\"));\n    /// ```\n    pub fn add_edge(&mut self, a: N, b: N, weight: E) -> Option<E> {\n        if let old @ Some(_) = self.edges.insert(Self::edge_key(a, b), weight) {\n            old\n        } else {\n            // insert in the adjacency list if it's a new edge\n            self.nodes\n                .entry(a)\n                .or_insert_with(|| Vec::with_capacity(1))\n                .push((b, CompactDirection::Outgoing));\n            if a != b {\n                // self loops don't have the Incoming entry\n                self.nodes\n                    .entry(b)\n                    .or_insert_with(|| Vec::with_capacity(1))\n                    .push((a, CompactDirection::Incoming));\n            }\n            None\n        }\n    }\n\n    /// Remove edge relation from a to b\n    ///\n    /// Return `true` if it did exist.\n    fn remove_single_edge(&mut self, a: &N, b: &N, dir: Direction) -> bool {\n        match self.nodes.get_mut(a) {\n            None => false,\n            Some(sus) => {\n                if Ty::is_directed() {\n                    match sus\n                        .iter()\n                        .position(|elt| elt == &(*b, CompactDirection::from(dir)))\n                    {\n                        Some(index) => {\n                            sus.swap_remove(index);\n                            true\n                        }\n                        None => false,\n                    }\n                } else {\n                    match sus.iter().position(|elt| &elt.0 == b) {\n                        Some(index) => {\n                            sus.swap_remove(index);\n                            true\n                        }\n                        None => false,\n                    }\n                }\n            }\n        }\n    }\n\n    /// Remove edge from `a` to `b` from the graph and return the edge weight.\n    ///\n    /// Return `None` if the edge didn't exist.\n    ///\n    /// ```\n    /// // Create a GraphMap with undirected edges, and add and remove an edge.\n    /// use petgraph::graphmap::UnGraphMap;\n    ///\n    /// let mut g = UnGraphMap::new();\n    /// g.add_edge(\"x\", \"y\", -1);\n    ///\n    /// let edge_data = g.remove_edge(\"y\", \"x\");\n    /// assert_eq!(edge_data, Some(-1));\n    /// assert_eq!(g.edge_count(), 0);\n    /// ```\n    pub fn remove_edge(&mut self, a: N, b: N) -> Option<E> {\n        let exist1 = self.remove_single_edge(&a, &b, Outgoing);\n        let exist2 = if a != b {\n            self.remove_single_edge(&b, &a, Incoming)\n        } else {\n            exist1\n        };\n        let weight = self.edges.remove(&Self::edge_key(a, b));\n        debug_assert!(exist1 == exist2 && exist1 == weight.is_some());\n        weight\n    }\n\n    /// Return `true` if the edge connecting `a` with `b` is contained in the graph.\n    pub fn contains_edge(&self, a: N, b: N) -> bool {\n        self.edges.contains_key(&Self::edge_key(a, b))\n    }\n\n    /// Return an iterator over the nodes of the graph.\n    ///\n    /// Iterator element type is `N`.\n    pub fn nodes(&self) -> Nodes<N> {\n        Nodes {\n            iter: self.nodes.keys().cloned(),\n        }\n    }\n\n    /// Return an iterator of all nodes with an edge starting from `a`.\n    ///\n    /// - `Directed`: Outgoing edges from `a`.\n    /// - `Undirected`: All edges from or to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is `N`.\n    pub fn neighbors(&self, a: N) -> Neighbors<N, Ty> {\n        Neighbors {\n            iter: match self.nodes.get(&a) {\n                Some(neigh) => neigh.iter(),\n                None => [].iter(),\n            },\n            ty: self.ty,\n        }\n    }\n\n    /// Return an iterator of all neighbors that have an edge between them and\n    /// `a`, in the specified direction.\n    /// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n    ///\n    /// - `Directed`, `Outgoing`: All edges from `a`.\n    /// - `Directed`, `Incoming`: All edges to `a`.\n    /// - `Undirected`: All edges from or to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is `N`.\n    pub fn neighbors_directed(&self, a: N, dir: Direction) -> NeighborsDirected<N, Ty> {\n        NeighborsDirected {\n            iter: match self.nodes.get(&a) {\n                Some(neigh) => neigh.iter(),\n                None => [].iter(),\n            },\n            start_node: a,\n            dir,\n            ty: self.ty,\n        }\n    }\n\n    /// Return an iterator of target nodes with an edge starting from `a`,\n    /// paired with their respective edge weights.\n    ///\n    /// - `Directed`: Outgoing edges from `a`.\n    /// - `Undirected`: All edges from or to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is `(N, &E)`.\n    pub fn edges(&self, from: N) -> Edges<N, E, Ty> {\n        Edges {\n            from,\n            iter: self.neighbors(from),\n            edges: &self.edges,\n        }\n    }\n\n    /// Return a reference to the edge weight connecting `a` with `b`, or\n    /// `None` if the edge does not exist in the graph.\n    pub fn edge_weight(&self, a: N, b: N) -> Option<&E> {\n        self.edges.get(&Self::edge_key(a, b))\n    }\n\n    /// Return a mutable reference to the edge weight connecting `a` with `b`, or\n    /// `None` if the edge does not exist in the graph.\n    pub fn edge_weight_mut(&mut self, a: N, b: N) -> Option<&mut E> {\n        self.edges.get_mut(&Self::edge_key(a, b))\n    }\n\n    /// Return an iterator over all edges of the graph with their weight in arbitrary order.\n    ///\n    /// Iterator element type is `(N, N, &E)`\n    pub fn all_edges(&self) -> AllEdges<N, E, Ty> {\n        AllEdges {\n            inner: self.edges.iter(),\n            ty: self.ty,\n        }\n    }\n\n    /// Return an iterator over all edges of the graph in arbitrary order, with a mutable reference\n    /// to their weight.\n    ///\n    /// Iterator element type is `(N, N, &mut E)`\n    pub fn all_edges_mut(&mut self) -> AllEdgesMut<N, E, Ty> {\n        AllEdgesMut {\n            inner: self.edges.iter_mut(),\n            ty: self.ty,\n        }\n    }\n\n    /// Return a `Graph` that corresponds to this `GraphMap`.\n    ///\n    /// 1. Note that node and edge indices in the `Graph` have nothing in common\n    ///    with the `GraphMap`s node weights `N`. The node weights `N` are used as\n    ///    node weights in the resulting `Graph`, too.\n    /// 2. Note that the index type is user-chosen.\n    ///\n    /// Computes in **O(|V| + |E|)** time (average).\n    ///\n    /// **Panics** if the number of nodes or edges does not fit with\n    /// the resulting graph's index type.\n    pub fn into_graph<Ix>(self) -> Graph<N, E, Ty, Ix>\n    where\n        Ix: crate::graph::IndexType,\n    {\n        // assuming two successive iterations of the same hashmap produce the same order\n        let mut gr = Graph::with_capacity(self.node_count(), self.edge_count());\n        for (&node, _) in &self.nodes {\n            gr.add_node(node);\n        }\n        for ((a, b), edge_weight) in self.edges {\n            let (ai, _, _) = self.nodes.get_full(&a).unwrap();\n            let (bi, _, _) = self.nodes.get_full(&b).unwrap();\n            gr.add_edge(node_index(ai), node_index(bi), edge_weight);\n        }\n        gr\n    }\n}","impl<N, E, Ty> GraphProp for GraphMap<N, E, Ty>\nwhere\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n    type EdgeType = Ty;\n}","impl<N, E, Ty> Index<(N, N)> for GraphMap<N, E, Ty>\nwhere\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n    type Output = E;\n    fn index(&self, index: (N, N)) -> &E {\n        let index = Self::edge_key(index.0, index.1);\n        self.edge_weight(index.0, index.1)\n            .expect(\"GraphMap::index: no such edge\")\n    }\n}","impl<N, E, Ty> IndexMut<(N, N)> for GraphMap<N, E, Ty>\nwhere\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n    fn index_mut(&mut self, index: (N, N)) -> &mut E {\n        let index = Self::edge_key(index.0, index.1);\n        self.edge_weight_mut(index.0, index.1)\n            .expect(\"GraphMap::index: no such edge\")\n    }\n}","impl<N, E, Ty> NodeCompactIndexable for GraphMap<N, E, Ty>\nwhere\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n}","impl<N, E, Ty> NodeCount for GraphMap<N, E, Ty>\nwhere\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n    fn node_count(&self) -> usize {\n        (*self).node_count()\n    }\n}","impl<N, E, Ty> NodeIndexable for GraphMap<N, E, Ty>\nwhere\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n    fn node_bound(&self) -> usize {\n        self.node_count()\n    }\n    fn to_index(&self, ix: Self::NodeId) -> usize {\n        let (i, _, _) = self.nodes.get_full(&ix).unwrap();\n        i\n    }\n    fn from_index(&self, ix: usize) -> Self::NodeId {\n        let (&key, _) = self.nodes.get_index(ix).unwrap();\n        key\n    }\n}","impl<N, E, Ty> Visitable for GraphMap<N, E, Ty>\nwhere\n    N: Copy + Ord + Hash,\n    Ty: EdgeType,\n{\n    type Map = HashSet<N>;\n    fn visit_map(&self) -> HashSet<N> {\n        HashSet::with_capacity(self.node_count())\n    }\n    fn reset_map(&self, map: &mut Self::Map) {\n        map.clear();\n    }\n}","impl<N: Eq + Hash + fmt::Debug, E: fmt::Debug, Ty: EdgeType> fmt::Debug for GraphMap<N, E, Ty> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.nodes.fmt(f)\n    }\n}"],"graphmap::Neighbors":["impl<'a, N, Ty> Iterator for Neighbors<'a, N, Ty>\nwhere\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n    type Item = N;\n    fn next(&mut self) -> Option<N> {\n        if Ty::is_directed() {\n            (&mut self.iter)\n                .filter_map(|&(n, dir)| if dir == Outgoing { Some(n) } else { None })\n                .next()\n        } else {\n            self.iter.next().map(|&(n, _)| n)\n        }\n    }\n}"],"graphmap::NeighborsDirected":["impl<'a, N, Ty> Iterator for NeighborsDirected<'a, N, Ty>\nwhere\n    N: NodeTrait,\n    Ty: EdgeType,\n{\n    type Item = N;\n    fn next(&mut self) -> Option<N> {\n        if Ty::is_directed() {\n            let self_dir = self.dir;\n            let start_node = self.start_node;\n            (&mut self.iter)\n                .filter_map(move |&(n, dir)| {\n                    if dir == self_dir || n == start_node {\n                        Some(n)\n                    } else {\n                        None\n                    }\n                })\n                .next()\n        } else {\n            self.iter.next().map(|&(n, _)| n)\n        }\n    }\n}"],"graphmap::NodeIdentifiers":["impl<'a, N, E, Ty> Iterator for NodeIdentifiers<'a, N, E, Ty>\nwhere\n    N: 'a + NodeTrait,\n    E: 'a,\n    Ty: EdgeType,\n{\n    type Item = N;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|(&n, _)| n)\n    }\n}"],"graphmap::NodeReferences":["impl<'a, N, E, Ty> Iterator for NodeReferences<'a, N, E, Ty>\nwhere\n    N: 'a + NodeTrait,\n    E: 'a,\n    Ty: EdgeType,\n{\n    type Item = (N, &'a N);\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|(n, _)| (*n, n))\n    }\n}"],"graphmap::Nodes":["impl<$($typarm),*> Iterator for $name <$($typarm),*>\n            where $($bounds)*\n        {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"graphmap::Ptr":["impl<'b, T: fmt::Debug> fmt::Debug for Ptr<'b, T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}","impl<'b, T> Clone for Ptr<'b, T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}","impl<'b, T> Copy for Ptr<'b, T> {}","impl<'b, T> Deref for Ptr<'b, T> {\n    type Target = T;\n    fn deref(&self) -> &T {\n        self.0\n    }\n}","impl<'b, T> Eq for Ptr<'b, T> {}","impl<'b, T> Hash for Ptr<'b, T> {\n    fn hash<H: hash::Hasher>(&self, st: &mut H) {\n        let ptr = (self.0) as *const T;\n        ptr.hash(st)\n    }\n}","impl<'b, T> Ord for Ptr<'b, T> {\n    /// Ptr is ordered by pointer value, i.e. an arbitrary but stable and total order.\n    fn cmp(&self, other: &Ptr<'b, T>) -> Ordering {\n        let a: *const T = self.0;\n        let b: *const T = other.0;\n        a.cmp(&b)\n    }\n}","impl<'b, T> PartialEq for Ptr<'b, T> {\n    /// Ptr compares by pointer equality, i.e if they point to the same value\n    fn eq(&self, other: &Ptr<'b, T>) -> bool {\n        ptr_eq(self.0, other.0)\n    }\n}","impl<'b, T> PartialOrd for Ptr<'b, T> {\n    fn partial_cmp(&self, other: &Ptr<'b, T>) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}"],"isomorphism::NoSemanticMatch":["impl<T> SemanticMatcher<T> for NoSemanticMatch {\n    #[inline]\n    fn enabled() -> bool {\n        false\n    }\n    #[inline]\n    fn eq(&mut self, _: &T, _: &T) -> bool {\n        true\n    }\n}"],"isomorphism::Vf2State":["Debug","impl<Ty, Ix> Vf2State<Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    pub fn new<N, E>(g: &Graph<N, E, Ty, Ix>) -> Self {\n        let c0 = g.node_count();\n        let mut state = Vf2State {\n            mapping: Vec::with_capacity(c0),\n            out: Vec::with_capacity(c0),\n            ins: Vec::with_capacity(c0 * (g.is_directed() as usize)),\n            out_size: 0,\n            ins_size: 0,\n            adjacency_matrix: g.adjacency_matrix(),\n            generation: 0,\n            _etype: marker::PhantomData,\n        };\n        for _ in 0..c0 {\n            state.mapping.push(NodeIndex::end());\n            state.out.push(0);\n            if Ty::is_directed() {\n                state.ins.push(0);\n            }\n        }\n        state\n    }\n\n    /// Return **true** if we have a complete mapping\n    pub fn is_complete(&self) -> bool {\n        self.generation == self.mapping.len()\n    }\n\n    /// Add mapping **from** <-> **to** to the state.\n    pub fn push_mapping<N, E>(\n        &mut self,\n        from: NodeIndex<Ix>,\n        to: NodeIndex<Ix>,\n        g: &Graph<N, E, Ty, Ix>,\n    ) {\n        self.generation += 1;\n        let s = self.generation;\n        self.mapping[from.index()] = to;\n        // update T0 & T1 ins/outs\n        // T0out: Node in G0 not in M0 but successor of a node in M0.\n        // st.out[0]: Node either in M0 or successor of M0\n        for ix in g.neighbors(from) {\n            if self.out[ix.index()] == 0 {\n                self.out[ix.index()] = s;\n                self.out_size += 1;\n            }\n        }\n        if g.is_directed() {\n            for ix in g.neighbors_directed(from, Incoming) {\n                if self.ins[ix.index()] == 0 {\n                    self.ins[ix.index()] = s;\n                    self.ins_size += 1;\n                }\n            }\n        }\n    }\n\n    /// Restore the state to before the last added mapping\n    pub fn pop_mapping<N, E>(&mut self, from: NodeIndex<Ix>, g: &Graph<N, E, Ty, Ix>) {\n        let s = self.generation;\n        self.generation -= 1;\n\n        // undo (n, m) mapping\n        self.mapping[from.index()] = NodeIndex::end();\n\n        // unmark in ins and outs\n        for ix in g.neighbors(from) {\n            if self.out[ix.index()] == s {\n                self.out[ix.index()] = 0;\n                self.out_size -= 1;\n            }\n        }\n        if g.is_directed() {\n            for ix in g.neighbors_directed(from, Incoming) {\n                if self.ins[ix.index()] == s {\n                    self.ins[ix.index()] = 0;\n                    self.ins_size -= 1;\n                }\n            }\n        }\n    }\n\n    /// Find the next (least) node in the Tout set.\n    pub fn next_out_index(&self, from_index: usize) -> Option<usize> {\n        self.out[from_index..]\n            .iter()\n            .enumerate()\n            .find(move |&(index, elt)| {\n                *elt > 0 && self.mapping[from_index + index] == NodeIndex::end()\n            })\n            .map(|(index, _)| index)\n    }\n\n    /// Find the next (least) node in the Tin set.\n    pub fn next_in_index(&self, from_index: usize) -> Option<usize> {\n        if !Ty::is_directed() {\n            return None;\n        }\n        self.ins[from_index..]\n            .iter()\n            .enumerate()\n            .find(move |&(index, elt)| {\n                *elt > 0 && self.mapping[from_index + index] == NodeIndex::end()\n            })\n            .map(|(index, _)| index)\n    }\n\n    /// Find the next (least) node in the N - M set.\n    pub fn next_rest_index(&self, from_index: usize) -> Option<usize> {\n        self.mapping[from_index..]\n            .iter()\n            .enumerate()\n            .find(|&(_, elt)| *elt == NodeIndex::end())\n            .map(|(index, _)| index)\n    }\n}"],"isomorphism::try_match::Frame":["Clone","Debug","PartialEq"],"isomorphism::try_match::OpenList":["Clone","Copy","Debug","PartialEq"],"iter_format::DebugMap":["impl<'a, F, I, K, V> fmt::Debug for DebugMap<F>\nwhere\n    F: Fn() -> I,\n    I: IntoIterator<Item = (K, V)>,\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_map().entries((self.0)()).finish()\n    }\n}"],"iter_format::Format":["Clone","impl<'a, I> Format<'a, I>\nwhere\n    I: Iterator,\n{\n    fn format<F>(&self, f: &mut fmt::Formatter, mut cb: F) -> fmt::Result\n    where\n        F: FnMut(&I::Item, &mut fmt::Formatter) -> fmt::Result,\n    {\n        let mut iter = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"Format: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            cb(&fst, f)?;\n            for elt in iter {\n                if !self.sep.is_empty() {\n                    f.write_str(self.sep)?;\n                }\n                cb(&elt, f)?;\n            }\n        }\n        Ok(())\n    }\n}","impl<'a, I> fmt::$fmt_trait for Format<'a, I>\n                where I: Iterator,\n                      I::Item: fmt::$fmt_trait,\n            {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.format(f, fmt::$fmt_trait::fmt)\n                }\n            }"],"iter_format::NoPretty":["impl<T> fmt::Debug for NoPretty<T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{:?}\", self.0)\n    }\n}"],"matrix_graph::EdgeReferences":["impl<'a, Ty: EdgeType, Null: 'a + Nullable, Ix> EdgeReferences<'a, Ty, Null, Ix> {\n    fn new(node_adjacencies: &'a [Null], node_capacity: usize) -> Self {\n        EdgeReferences {\n            row: 0,\n            column: 0,\n            node_adjacencies,\n            node_capacity,\n            ty: PhantomData,\n            ix: PhantomData,\n        }\n    }\n}","impl<'a, Ty: EdgeType, Null: Nullable, Ix: IndexType> Iterator\n    for EdgeReferences<'a, Ty, Null, Ix>\n{\n    type Item = (NodeIndex<Ix>, NodeIndex<Ix>, &'a Null::Wrapped);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            let (row, column) = (self.row, self.column);\n            if row >= self.node_capacity {\n                return None;\n            }\n\n            // By default, advance the column. Reset and advance the row if the column overflows.\n            //\n            // Note that for undirected graphs, we don't want to yield the same edge twice,\n            // therefore the maximum column length should be the index new after the row index.\n            self.column += 1;\n            let max_column_len = if !Ty::is_directed() {\n                row + 1\n            } else {\n                self.node_capacity\n            };\n            if self.column >= max_column_len {\n                self.column = 0;\n                self.row += 1;\n            }\n\n            let p = to_linearized_matrix_position::<Ty>(row, column, self.node_capacity);\n            if let Some(e) = self.node_adjacencies[p].as_ref() {\n                return Some((NodeIndex::new(row), NodeIndex::new(column), e));\n            }\n        }\n    }\n}"],"matrix_graph::Edges":["impl<'a, Ty: EdgeType, Null: 'a + Nullable, Ix> Edges<'a, Ty, Null, Ix> {\n    fn on_columns(row: usize, node_adjacencies: &'a [Null], node_capacity: usize) -> Self {\n        Edges {\n            iter_direction: NeighborIterDirection::Columns,\n            node_adjacencies,\n            node_capacity,\n            row,\n            column: 0,\n            ty: PhantomData,\n            ix: PhantomData,\n        }\n    }\n\n    fn on_rows(column: usize, node_adjacencies: &'a [Null], node_capacity: usize) -> Self {\n        Edges {\n            iter_direction: NeighborIterDirection::Rows,\n            node_adjacencies,\n            node_capacity,\n            row: 0,\n            column,\n            ty: PhantomData,\n            ix: PhantomData,\n        }\n    }\n}","impl<'a, Ty: EdgeType, Null: Nullable, Ix: IndexType> Iterator for Edges<'a, Ty, Null, Ix> {\n    type Item = (NodeIndex<Ix>, NodeIndex<Ix>, &'a Null::Wrapped);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use self::NeighborIterDirection::*;\n\n        loop {\n            let (row, column) = (self.row, self.column);\n            if row >= self.node_capacity || column >= self.node_capacity {\n                return None;\n            }\n\n            match self.iter_direction {\n                Rows => self.row += 1,\n                Columns => self.column += 1,\n            }\n\n            let p = to_linearized_matrix_position::<Ty>(row, column, self.node_capacity);\n            if let Some(e) = self.node_adjacencies[p].as_ref() {\n                let (a, b) = match self.iter_direction {\n                    Rows => (column, row),\n                    Columns => (row, column),\n                };\n\n                return Some((NodeIndex::new(a), NodeIndex::new(b), e));\n            }\n        }\n    }\n}"],"matrix_graph::IdIterator":["impl<'a> Iterator for IdIterator<'a> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        // initialize / advance\n        let current = {\n            if self.current.is_none() {\n                self.current = Some(0);\n                self.current.as_mut().unwrap()\n            } else {\n                let current = self.current.as_mut().unwrap();\n                *current += 1;\n                current\n            }\n        };\n\n        // skip removed ids\n        while self.removed_ids.contains(current) && *current < self.upper_bound {\n            *current += 1;\n        }\n\n        if *current < self.upper_bound {\n            Some(*current)\n        } else {\n            None\n        }\n    }\n}"],"matrix_graph::IdStorage":["Clone","impl<T> IdStorage<T> {\n    fn with_capacity(capacity: usize) -> Self {\n        IdStorage {\n            elements: Vec::with_capacity(capacity),\n            upper_bound: 0,\n            removed_ids: IndexSet::new(),\n        }\n    }\n\n    fn add(&mut self, element: T) -> usize {\n        let id = if let Some(id) = self.removed_ids.pop() {\n            id\n        } else {\n            let id = self.upper_bound;\n            self.upper_bound += 1;\n\n            ensure_len(&mut self.elements, id + 1);\n\n            id\n        };\n\n        self.elements[id] = Some(element);\n\n        id\n    }\n\n    fn remove(&mut self, id: usize) -> T {\n        let data = self.elements[id].take().unwrap();\n        if self.upper_bound - id == 1 {\n            self.upper_bound -= 1;\n        } else {\n            self.removed_ids.insert(id);\n        }\n        data\n    }\n\n    fn clear(&mut self) {\n        self.upper_bound = 0;\n        self.elements.clear();\n        self.removed_ids.clear();\n    }\n\n    #[inline]\n    fn len(&self) -> usize {\n        self.upper_bound - self.removed_ids.len()\n    }\n\n    fn iter_ids(&self) -> IdIterator {\n        IdIterator {\n            upper_bound: self.upper_bound,\n            removed_ids: &self.removed_ids,\n            current: None,\n        }\n    }\n}","impl<T> Index<usize> for IdStorage<T> {\n    type Output = T;\n    fn index(&self, index: usize) -> &T {\n        self.elements[index].as_ref().unwrap()\n    }\n}","impl<T> IndexMut<usize> for IdStorage<T> {\n    fn index_mut(&mut self, index: usize) -> &mut T {\n        self.elements[index].as_mut().unwrap()\n    }\n}"],"matrix_graph::MatrixGraph":["Clone","impl<N, E, Null: Nullable<Wrapped = E>, Ix: IndexType> MatrixGraph<N, E, Directed, Null, Ix> {\n    /// Return an iterator of all neighbors that have an edge between them and\n    /// `a`, in the specified direction.\n    /// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n    ///\n    /// - `Outgoing`: All edges from `a`.\n    /// - `Incoming`: All edges to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is [`NodeIndex<Ix>`](../graph/struct.NodeIndex.html).\n    pub fn neighbors_directed(\n        &self,\n        a: NodeIndex<Ix>,\n        d: Direction,\n    ) -> Neighbors<Directed, Null, Ix> {\n        if d == Outgoing {\n            self.neighbors(a)\n        } else {\n            Neighbors(Edges::on_rows(\n                a.index(),\n                &self.node_adjacencies,\n                self.node_capacity,\n            ))\n        }\n    }\n\n    /// Return an iterator of all edges of `a`, in the specified direction.\n    ///\n    /// - `Outgoing`: All edges from `a`.\n    /// - `Incoming`: All edges to `a`.\n    ///\n    /// Produces an empty iterator if the node `a` doesn't exist.<br>\n    /// Iterator element type is [`EdgeReference<E, Ix>`](../graph/struct.EdgeReference.html).\n    pub fn edges_directed(&self, a: NodeIndex<Ix>, d: Direction) -> Edges<Directed, Null, Ix> {\n        if d == Outgoing {\n            self.edges(a)\n        } else {\n            Edges::on_rows(a.index(), &self.node_adjacencies, self.node_capacity)\n        }\n    }\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType>\n    Index<(NodeIndex<Ix>, NodeIndex<Ix>)> for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    type Output = E;\n\n    fn index(&self, (ax, bx): (NodeIndex<Ix>, NodeIndex<Ix>)) -> &E {\n        self.edge_weight(ax, bx)\n    }\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType>\n    IndexMut<(NodeIndex<Ix>, NodeIndex<Ix>)> for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    fn index_mut(&mut self, (ax, bx): (NodeIndex<Ix>, NodeIndex<Ix>)) -> &mut E {\n        self.edge_weight_mut(ax, bx)\n    }\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType>\n    MatrixGraph<N, E, Ty, Null, Ix>\n{\n    /// Create a new `MatrixGraph` with estimated capacity for nodes.\n    pub fn with_capacity(node_capacity: usize) -> Self {\n        let mut m = Self {\n            node_adjacencies: vec![],\n            node_capacity: 0,\n            nodes: IdStorage::with_capacity(node_capacity),\n            nb_edges: 0,\n            ty: PhantomData,\n            ix: PhantomData,\n        };\n\n        debug_assert!(node_capacity <= <Ix as IndexType>::max().index());\n        m.extend_capacity_for_node(NodeIndex::new(node_capacity));\n\n        m\n    }\n\n    #[inline]\n    fn to_edge_position(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> usize {\n        to_linearized_matrix_position::<Ty>(a.index(), b.index(), self.node_capacity)\n    }\n\n    /// Remove all nodes and edges.\n    pub fn clear(&mut self) {\n        for edge in self.node_adjacencies.iter_mut() {\n            *edge = Default::default();\n        }\n        self.nodes.clear();\n        self.nb_edges = 0;\n    }\n\n    /// Return the number of nodes (vertices) in the graph.\n    ///\n    /// Computes in **O(1)** time.\n    #[inline]\n    pub fn node_count(&self) -> usize {\n        self.nodes.len()\n    }\n\n    /// Return the number of edges in the graph.\n    ///\n    /// Computes in **O(1)** time.\n    #[inline]\n    pub fn edge_count(&self) -> usize {\n        self.nb_edges\n    }\n\n    /// Return whether the graph has directed edges or not.\n    #[inline]\n    pub fn is_directed(&self) -> bool {\n        Ty::is_directed()\n    }\n\n    /// Add a node (also called vertex) with associated data `weight` to the graph.\n    ///\n    /// Computes in **O(1)** time.\n    ///\n    /// Return the index of the new node.\n    ///\n    /// **Panics** if the MatrixGraph is at the maximum number of nodes for its index type.\n    pub fn add_node(&mut self, weight: N) -> NodeIndex<Ix> {\n        NodeIndex::new(self.nodes.add(weight))\n    }\n\n    /// Remove `a` from the graph.\n    ///\n    /// Computes in **O(V)** time, due to the removal of edges with other nodes.\n    ///\n    /// **Panics** if the node `a` does not exist.\n    pub fn remove_node(&mut self, a: NodeIndex<Ix>) -> N {\n        for id in self.nodes.iter_ids() {\n            let position = self.to_edge_position(a, NodeIndex::new(id));\n            self.node_adjacencies[position] = Default::default();\n\n            if Ty::is_directed() {\n                let position = self.to_edge_position(NodeIndex::new(id), a);\n                self.node_adjacencies[position] = Default::default();\n            }\n        }\n\n        self.nodes.remove(a.index())\n    }\n\n    #[inline]\n    fn extend_capacity_for_node(&mut self, min_node: NodeIndex<Ix>) {\n        self.node_capacity = extend_linearized_matrix::<Ty, _>(\n            &mut self.node_adjacencies,\n            self.node_capacity,\n            min_node.index(),\n        );\n    }\n\n    #[inline]\n    fn extend_capacity_for_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) {\n        let min_node = cmp::max(a, b);\n        if min_node.index() >= self.node_capacity {\n            self.extend_capacity_for_node(min_node);\n        }\n    }\n\n    /// Update the edge from `a` to `b` to the graph, with its associated data `weight`.\n    ///\n    /// Return the previous data, if any.\n    ///\n    /// Computes in **O(1)** time, best case.\n    /// Computes in **O(|V|^2)** time, worst case (matrix needs to be re-allocated).\n    ///\n    /// **Panics** if any of the nodes don't exist.\n    pub fn update_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> Option<E> {\n        self.extend_capacity_for_edge(a, b);\n\n        let p = self.to_edge_position(a, b);\n        let old_weight = mem::replace(&mut self.node_adjacencies[p], Null::new(weight));\n        if old_weight.is_null() {\n            self.nb_edges += 1;\n        }\n        old_weight.into()\n    }\n\n    /// Add an edge from `a` to `b` to the graph, with its associated\n    /// data `weight`.\n    ///\n    /// Return the index of the new edge.\n    ///\n    /// Computes in **O(1)** time, best case.\n    /// Computes in **O(|V|^2)** time, worst case (matrix needs to be re-allocated).\n    ///\n    /// **Panics** if any of the nodes don't exist.\n    /// **Panics** if an edge already exists from `a` to `b`.\n    ///\n    /// **Note:** `MatrixGraph` does not allow adding parallel (“duplicate”) edges. If you want to avoid\n    /// this, use [`.update_edge(a, b, weight)`](#method.update_edge) instead.\n    pub fn add_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) {\n        let old_edge_id = self.update_edge(a, b, weight);\n        assert!(old_edge_id.is_none());\n    }\n\n    /// Remove the edge from `a` to `b` to the graph.\n    ///\n    /// **Panics** if any of the nodes don't exist.\n    /// **Panics** if no edge exists between `a` and `b`.\n    pub fn remove_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> E {\n        let p = self.to_edge_position(a, b);\n        let old_weight = mem::replace(&mut self.node_adjacencies[p], Default::default())\n            .into()\n            .unwrap();\n        let old_weight: Option<_> = old_weight.into();\n        self.nb_edges -= 1;\n        old_weight.unwrap()\n    }\n\n    /// Return true if there is an edge between `a` and `b`.\n    ///\n    /// **Panics** if any of the nodes don't exist.\n    pub fn has_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool {\n        let p = self.to_edge_position(a, b);\n        !self.node_adjacencies[p].is_null()\n    }\n\n    /// Access the weight for node `a`.\n    ///\n    /// Also available with indexing syntax: `&graph[a]`.\n    ///\n    /// **Panics** if the node doesn't exist.\n    pub fn node_weight(&self, a: NodeIndex<Ix>) -> &N {\n        &self.nodes[a.index()]\n    }\n\n    /// Access the weight for node `a`, mutably.\n    ///\n    /// Also available with indexing syntax: `&mut graph[a]`.\n    ///\n    /// **Panics** if the node doesn't exist.\n    pub fn node_weight_mut(&mut self, a: NodeIndex<Ix>) -> &mut N {\n        &mut self.nodes[a.index()]\n    }\n\n    /// Access the weight for edge `e`.\n    ///\n    /// Also available with indexing syntax: `&graph[e]`.\n    ///\n    /// **Panics** if no edge exists between `a` and `b`.\n    pub fn edge_weight(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> &E {\n        let p = self.to_edge_position(a, b);\n        self.node_adjacencies[p].as_ref().unwrap()\n    }\n\n    /// Access the weight for edge `e`, mutably.\n    ///\n    /// Also available with indexing syntax: `&mut graph[e]`.\n    ///\n    /// **Panics** if no edge exists between `a` and `b`.\n    pub fn edge_weight_mut(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> &mut E {\n        let p = self.to_edge_position(a, b);\n        self.node_adjacencies[p].as_mut().unwrap()\n    }\n\n    /// Return an iterator of all nodes with an edge starting from `a`.\n    ///\n    /// - `Directed`: Outgoing edges from `a`.\n    /// - `Undirected`: All edges from or to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is [`NodeIndex<Ix>`](../graph/struct.NodeIndex.html).\n    pub fn neighbors(&self, a: NodeIndex<Ix>) -> Neighbors<Ty, Null, Ix> {\n        Neighbors(Edges::on_columns(\n            a.index(),\n            &self.node_adjacencies,\n            self.node_capacity,\n        ))\n    }\n\n    /// Return an iterator of all edges of `a`.\n    ///\n    /// - `Directed`: Outgoing edges from `a`.\n    /// - `Undirected`: All edges connected to `a`.\n    ///\n    /// Produces an empty iterator if the node doesn't exist.<br>\n    /// Iterator element type is [`Edges<E, Ix>`](../graph/struct.Edges.html).\n    pub fn edges(&self, a: NodeIndex<Ix>) -> Edges<Ty, Null, Ix> {\n        Edges::on_columns(a.index(), &self.node_adjacencies, self.node_capacity)\n    }\n\n    /// Create a new `MatrixGraph` from an iterable of edges.\n    ///\n    /// Node weights `N` are set to default values.\n    /// Edge weights `E` may either be specified in the list,\n    /// or they are filled with default values.\n    ///\n    /// Nodes are inserted automatically to match the edges.\n    ///\n    /// ```\n    /// use petgraph::matrix_graph::MatrixGraph;\n    ///\n    /// let gr = MatrixGraph::<(), i32>::from_edges(&[\n    ///     (0, 1), (0, 2), (0, 3),\n    ///     (1, 2), (1, 3),\n    ///     (2, 3),\n    /// ]);\n    /// ```\n    pub fn from_edges<I>(iterable: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,\n    {\n        let mut g = Self::default();\n        g.extend_with_edges(iterable);\n        g\n    }\n\n    /// Extend the graph from an iterable of edges.\n    ///\n    /// Node weights `N` are set to default values.\n    /// Edge weights `E` may either be specified in the list,\n    /// or they are filled with default values.\n    ///\n    /// Nodes are inserted automatically to match the edges.\n    pub fn extend_with_edges<I>(&mut self, iterable: I)\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,\n    {\n        for elt in iterable {\n            let (source, target, weight) = elt.into_weighted_edge();\n            let (source, target) = (source.into(), target.into());\n            let nx = cmp::max(source, target);\n            while nx.index() >= self.node_count() {\n                self.add_node(N::default());\n            }\n            self.add_edge(source, target, weight);\n        }\n    }\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> Build\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    fn add_node(&mut self, weight: Self::NodeWeight) -> Self::NodeId {\n        self.add_node(weight)\n    }\n\n    fn add_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Option<Self::EdgeId> {\n        if !self.has_edge(a, b) {\n            MatrixGraph::update_edge(self, a, b, weight);\n            Some((a, b))\n        } else {\n            None\n        }\n    }\n\n    fn update_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Self::EdgeId {\n        MatrixGraph::update_edge(self, a, b, weight);\n        (a, b)\n    }\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> Data\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    type NodeWeight = N;\n    type EdgeWeight = E;\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> Default\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    fn default() -> Self {\n        Self::with_capacity(0)\n    }\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> GetAdjacencyMatrix\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    type AdjMatrix = ();\n\n    fn adjacency_matrix(&self) -> Self::AdjMatrix {}\n\n    fn is_adjacent(&self, _: &Self::AdjMatrix, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool {\n        MatrixGraph::has_edge(self, a, b)\n    }\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> GraphBase\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    type NodeId = NodeIndex<Ix>;\n    type EdgeId = (NodeIndex<Ix>, NodeIndex<Ix>);\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> GraphProp\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    type EdgeType = Ty;\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> Index<NodeIndex<Ix>>\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    type Output = N;\n\n    fn index(&self, ax: NodeIndex<Ix>) -> &N {\n        self.node_weight(ax)\n    }\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> IndexMut<NodeIndex<Ix>>\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    fn index_mut(&mut self, ax: NodeIndex<Ix>) -> &mut N {\n        self.node_weight_mut(ax)\n    }\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> NodeCompactIndexable\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> NodeCount\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    fn node_count(&self) -> usize {\n        MatrixGraph::node_count(self)\n    }\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> NodeIndexable\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    fn node_bound(&self) -> usize {\n        self.node_count()\n    }\n\n    fn to_index(&self, ix: NodeIndex<Ix>) -> usize {\n        ix.index()\n    }\n\n    fn from_index(&self, ix: usize) -> Self::NodeId {\n        NodeIndex::new(ix)\n    }\n}","impl<N, E, Ty: EdgeType, Null: Nullable<Wrapped = E>, Ix: IndexType> Visitable\n    for MatrixGraph<N, E, Ty, Null, Ix>\n{\n    type Map = FixedBitSet;\n\n    fn visit_map(&self) -> FixedBitSet {\n        FixedBitSet::with_capacity(self.node_count())\n    }\n\n    fn reset_map(&self, map: &mut Self::Map) {\n        map.clear();\n        map.grow(self.node_count());\n    }\n}","impl<N, E> MatrixGraph<N, E, Directed> {\n    /// Create a new `MatrixGraph` with directed edges.\n    ///\n    /// This is a convenience method. Use `MatrixGraph::with_capacity` or `MatrixGraph::default` for\n    /// a constructor that is generic in all the type parameters of `MatrixGraph`.\n    pub fn new() -> Self {\n        MatrixGraph::default()\n    }\n}","impl<N, E> MatrixGraph<N, E, Undirected> {\n    /// Create a new `MatrixGraph` with undirected edges.\n    ///\n    /// This is a convenience method. Use `MatrixGraph::with_capacity` or `MatrixGraph::default` for\n    /// a constructor that is generic in all the type parameters of `MatrixGraph`.\n    pub fn new_undirected() -> Self {\n        MatrixGraph::default()\n    }\n}"],"matrix_graph::Neighbors":["impl<'a, Ty: EdgeType, Null: Nullable, Ix: IndexType> Iterator for Neighbors<'a, Ty, Null, Ix> {\n    type Item = NodeIndex<Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().map(|(_, b, _)| b)\n    }\n}"],"matrix_graph::NodeIdentifiers":["impl<'a, Ix: IndexType> Iterator for NodeIdentifiers<'a, Ix> {\n    type Item = NodeIndex<Ix>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(NodeIndex::new)\n    }\n}","impl<'a, Ix: IndexType> NodeIdentifiers<'a, Ix> {\n    fn new(iter: IdIterator<'a>) -> Self {\n        Self {\n            iter,\n            ix: PhantomData,\n        }\n    }\n}"],"matrix_graph::NodeReferences":["impl<'a, N: 'a, Ix: IndexType> Iterator for NodeReferences<'a, N, Ix> {\n    type Item = (NodeIndex<Ix>, &'a N);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter\n            .next()\n            .map(|i| (NodeIndex::new(i), &self.nodes[i]))\n    }\n}","impl<'a, N: 'a, Ix> NodeReferences<'a, N, Ix> {\n    fn new(nodes: &'a IdStorage<N>) -> Self {\n        NodeReferences {\n            nodes,\n            iter: nodes.iter_ids(),\n            ix: PhantomData,\n        }\n    }\n}"],"matrix_graph::NotZero":["impl<T: Zero> Default for NotZero<T> {\n    fn default() -> Self {\n        NotZero(T::zero())\n    }\n}","impl<T: Zero> Into<Option<T>> for NotZero<T> {\n    fn into(self) -> Option<T> {\n        if !self.is_null() {\n            Some(self.0)\n        } else {\n            None\n        }\n    }\n}","impl<T: Zero> Nullable for NotZero<T> {\n    type Wrapped = T;\n\n    fn new(value: T) -> Self {\n        assert!(!value.is_zero());\n        NotZero(value)\n    }\n\n    // implemented here for optimization purposes\n    fn is_null(&self) -> bool {\n        self.0.is_zero()\n    }\n\n    fn as_ref(&self) -> Option<&Self::Wrapped> {\n        if !self.is_null() {\n            Some(&self.0)\n        } else {\n            None\n        }\n    }\n\n    fn as_mut(&mut self) -> Option<&mut Self::Wrapped> {\n        if !self.is_null() {\n            Some(&mut self.0)\n        } else {\n            None\n        }\n    }\n}","impl<T> Sealed for super::NotZero<T> {}"],"scored::MinScored":["Clone","Copy","Debug","impl<K: PartialOrd, T> Eq for MinScored<K, T> {}","impl<K: PartialOrd, T> Ord for MinScored<K, T> {\n    #[inline]\n    fn cmp(&self, other: &MinScored<K, T>) -> Ordering {\n        let a = &self.0;\n        let b = &other.0;\n        if a == b {\n            Ordering::Equal\n        } else if a < b {\n            Ordering::Greater\n        } else if a > b {\n            Ordering::Less\n        } else if a.ne(a) && b.ne(b) {\n            // these are the NaN cases\n            Ordering::Equal\n        } else if a.ne(a) {\n            // Order NaN less, so that it is last in the MinScore order\n            Ordering::Less\n        } else {\n            Ordering::Greater\n        }\n    }\n}","impl<K: PartialOrd, T> PartialEq for MinScored<K, T> {\n    #[inline]\n    fn eq(&self, other: &MinScored<K, T>) -> bool {\n        self.cmp(other) == Ordering::Equal\n    }\n}","impl<K: PartialOrd, T> PartialOrd for MinScored<K, T> {\n    #[inline]\n    fn partial_cmp(&self, other: &MinScored<K, T>) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}"],"std::collections::HashSet":["impl<N, S> FilterNode<N> for HashSet<N, S>\nwhere\n    HashSet<N, S>: VisitMap<N>,\n{\n    fn include_node(&self, n: N) -> bool {\n        self.is_visited(&n)\n    }\n}","impl<N, S> VisitMap<N> for HashSet<N, S>\nwhere\n    N: Hash + Eq,\n    S: BuildHasher,\n{\n    fn visit(&mut self, x: N) -> bool {\n        self.insert(x)\n    }\n    fn is_visited(&self, x: &N) -> bool {\n        self.contains(x)\n    }\n}"],"std::option::Option":["impl<T> Nullable for Option<T> {\n    type Wrapped = T;\n\n    fn new(value: T) -> Self {\n        Some(value)\n    }\n\n    fn as_ref(&self) -> Option<&Self::Wrapped> {\n        self.as_ref()\n    }\n\n    fn as_mut(&mut self) -> Option<&mut Self::Wrapped> {\n        self.as_mut()\n    }\n}","impl<T> Sealed for Option<T> {}"],"std::result::Result":["impl<C: ControlFlow, E> ControlFlow for Result<C, E> {\n    fn continuing() -> Self {\n        Ok(C::continuing())\n    }\n    fn should_break(&self) -> bool {\n        if let Ok(ref c) = *self {\n            c.should_break()\n        } else {\n            true\n        }\n    }\n    fn should_prune(&self) -> bool {\n        if let Ok(ref c) = *self {\n            c.should_prune()\n        } else {\n            false\n        }\n    }\n}"],"unionfind::UnionFind":["Clone","Debug","impl<K> UnionFind<K>\nwhere\n    K: IndexType,\n{\n    /// Create a new `UnionFind` of `n` disjoint sets.\n    pub fn new(n: usize) -> Self {\n        let rank = vec![0; n];\n        let parent = (0..n).map(K::new).collect::<Vec<K>>();\n\n        UnionFind { parent, rank }\n    }\n\n    /// Return the representative for `x`.\n    ///\n    /// **Panics** if `x` is out of bounds.\n    pub fn find(&self, x: K) -> K {\n        assert!(x.index() < self.parent.len());\n        unsafe {\n            let mut x = x;\n            loop {\n                // Use unchecked indexing because we can trust the internal set ids.\n                let xparent = *get_unchecked(&self.parent, x.index());\n                if xparent == x {\n                    break;\n                }\n                x = xparent;\n            }\n            x\n        }\n    }\n\n    /// Return the representative for `x`.\n    ///\n    /// Write back the found representative, flattening the internal\n    /// datastructure in the process and quicken future lookups.\n    ///\n    /// **Panics** if `x` is out of bounds.\n    pub fn find_mut(&mut self, x: K) -> K {\n        assert!(x.index() < self.parent.len());\n        unsafe { self.find_mut_recursive(x) }\n    }\n\n    unsafe fn find_mut_recursive(&mut self, mut x: K) -> K {\n        let mut parent = *get_unchecked(&self.parent, x.index());\n        while parent != x {\n            let grandparent = *get_unchecked(&self.parent, parent.index());\n            *get_unchecked_mut(&mut self.parent, x.index()) = grandparent;\n            x = parent;\n            parent = grandparent;\n        }\n        x\n    }\n\n    /// Returns `true` if the given elements belong to the same set, and returns\n    /// `false` otherwise.\n    pub fn equiv(&self, x: K, y: K) -> bool {\n        self.find(x) == self.find(y)\n    }\n\n    /// Unify the two sets containing `x` and `y`.\n    ///\n    /// Return `false` if the sets were already the same, `true` if they were unified.\n    ///\n    /// **Panics** if `x` or `y` is out of bounds.\n    pub fn union(&mut self, x: K, y: K) -> bool {\n        if x == y {\n            return false;\n        }\n        let xrep = self.find_mut(x);\n        let yrep = self.find_mut(y);\n\n        if xrep == yrep {\n            return false;\n        }\n\n        let xrepu = xrep.index();\n        let yrepu = yrep.index();\n        let xrank = self.rank[xrepu];\n        let yrank = self.rank[yrepu];\n\n        // The rank corresponds roughly to the depth of the treeset, so put the\n        // smaller set below the larger\n        match xrank.cmp(&yrank) {\n            Ordering::Less => self.parent[xrepu] = yrep,\n            Ordering::Greater => self.parent[yrepu] = xrep,\n            Ordering::Equal => {\n                self.parent[yrepu] = xrep;\n                self.rank[xrepu] += 1;\n            }\n        }\n        true\n    }\n\n    /// Return a vector mapping each element to its representative.\n    pub fn into_labeling(mut self) -> Vec<K> {\n        // write in the labeling of each element\n        unsafe {\n            for ix in 0..self.parent.len() {\n                let k = *get_unchecked(&self.parent, ix);\n                let xrep = self.find_mut_recursive(k);\n                *self.parent.get_unchecked_mut(ix) = xrep;\n            }\n        }\n        self.parent\n    }\n}"],"visit::dfsvisit::Control":["Clone","Copy","Debug","impl<B> Control<B> {\n    pub fn breaking() -> Control<()> {\n        Control::Break(())\n    }\n    /// Get the value in `Control::Break(_)`, if present.\n    pub fn break_value(self) -> Option<B> {\n        match self {\n            Control::Continue | Control::Prune => None,\n            Control::Break(b) => Some(b),\n        }\n    }\n}","impl<B> ControlFlow for Control<B> {\n    fn continuing() -> Self {\n        Control::Continue\n    }\n    fn should_break(&self) -> bool {\n        if let Control::Break(_) = *self {\n            true\n        } else {\n            false\n        }\n    }\n    fn should_prune(&self) -> bool {\n        match *self {\n            Control::Prune => true,\n            Control::Continue | Control::Break(_) => false,\n        }\n    }\n}","impl<B> Default for Control<B> {\n    fn default() -> Self {\n        Control::Continue\n    }\n}"],"visit::dfsvisit::DfsEvent":["Clone","Copy","Debug"],"visit::dfsvisit::Time":["Clone","Copy","Debug","Default","Eq","Hash","Ord","PartialEq","PartialOrd"],"visit::filter::EdgeFiltered":["Clone","Copy","Debug","impl<$($param)*> $name for $self_wrap where $self_type: $name {\n            $(\n            $(\n                type $assoc_name = $self_type::$assoc_name;\n            )*\n            )*\n            $(\n                type $assoc_name_ext = $self_type::$assoc_name_ext;\n            )*\n            $(\n            $(\n                fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret)? {\n                    $self_map!(self).$method_name($($marg),*)\n                }\n            )*\n            )*\n        }","impl<F, G> EdgeFiltered<G, F>\nwhere\n    G: IntoEdgeReferences,\n    F: Fn(G::EdgeRef) -> bool,\n{\n    /// Create an `EdgeFiltered` adaptor from the closure `filter`.\n    pub fn from_fn(graph: G, filter: F) -> Self {\n        EdgeFiltered(graph, filter)\n    }\n}","impl<G, F> GraphBase for EdgeFiltered<G, F>\nwhere\n    G: GraphBase,\n{\n    type NodeId = G::NodeId;\n    type EdgeId = G::EdgeId;\n}"],"visit::filter::EdgeFilteredEdges":["impl<'a, G, I, F> Iterator for EdgeFilteredEdges<'a, G, I, F>\nwhere\n    F: FilterEdge<G::EdgeRef>,\n    G: IntoEdgeReferences,\n    I: Iterator<Item = G::EdgeRef>,\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        let f = self.f;\n        self.iter.find(move |&edge| f.include_edge(edge))\n    }\n}"],"visit::filter::EdgeFilteredNeighbors":["impl<'a, G, F> Iterator for EdgeFilteredNeighbors<'a, G, F>\nwhere\n    F: FilterEdge<G::EdgeRef>,\n    G: IntoEdges,\n{\n    type Item = G::NodeId;\n    fn next(&mut self) -> Option<Self::Item> {\n        let f = self.f;\n        (&mut self.iter)\n            .filter_map(move |edge| {\n                if f.include_edge(edge) {\n                    Some(edge.target())\n                } else {\n                    None\n                }\n            })\n            .next()\n    }\n}"],"visit::filter::EdgeFilteredNeighborsDirected":["impl<'a, G, F> Iterator for EdgeFilteredNeighborsDirected<'a, G, F>\nwhere\n    F: FilterEdge<G::EdgeRef>,\n    G: IntoEdgesDirected,\n{\n    type Item = G::NodeId;\n    fn next(&mut self) -> Option<Self::Item> {\n        let f = self.f;\n        let from = self.from;\n        (&mut self.iter)\n            .filter_map(move |edge| {\n                if f.include_edge(edge) {\n                    if edge.source() != from {\n                        Some(edge.source())\n                    } else {\n                        Some(edge.target()) // includes case where from == source == target\n                    }\n                } else {\n                    None\n                }\n            })\n            .next()\n    }\n}"],"visit::filter::NodeFiltered":["Clone","Copy","Debug","impl<$($param)*> $name for $self_wrap where $self_type: $name {\n            $(\n            $(\n                type $assoc_name = $self_type::$assoc_name;\n            )*\n            )*\n            $(\n                type $assoc_name_ext = $self_type::$assoc_name_ext;\n            )*\n            $(\n            $(\n                fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret)? {\n                    $self_map!(self).$method_name($($marg),*)\n                }\n            )*\n            )*\n        }","impl<F, G> NodeFiltered<G, F>\nwhere\n    G: GraphBase,\n    F: Fn(G::NodeId) -> bool,\n{\n    /// Create an `NodeFiltered` adaptor from the closure `filter`.\n    pub fn from_fn(graph: G, filter: F) -> Self {\n        NodeFiltered(graph, filter)\n    }\n}","impl<G, F> DataMap for NodeFiltered<G, F>\nwhere\n    G: DataMap,\n    F: FilterNode<G::NodeId>,\n{\n    fn node_weight(&self, id: Self::NodeId) -> Option<&Self::NodeWeight> {\n        if self.1.include_node(id) {\n            self.0.node_weight(id)\n        } else {\n            None\n        }\n    }\n\n    fn edge_weight(&self, id: Self::EdgeId) -> Option<&Self::EdgeWeight> {\n        self.0.edge_weight(id)\n    }\n}","impl<G, F> GraphBase for NodeFiltered<G, F>\nwhere\n    G: GraphBase,\n{\n    type NodeId = G::NodeId;\n    type EdgeId = G::EdgeId;\n}"],"visit::filter::NodeFilteredEdgeReferences":["impl<'a, G, I, F> Iterator for NodeFilteredEdgeReferences<'a, G, I, F>\nwhere\n    F: FilterNode<G::NodeId>,\n    G: IntoEdgeReferences,\n    I: Iterator<Item = G::EdgeRef>,\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        let f = self.f;\n        self.iter\n            .find(move |&edge| f.include_node(edge.source()) && f.include_node(edge.target()))\n    }\n}"],"visit::filter::NodeFilteredEdges":["impl<'a, G, I, F> Iterator for NodeFilteredEdges<'a, G, I, F>\nwhere\n    F: FilterNode<G::NodeId>,\n    G: IntoEdges,\n    I: Iterator<Item = G::EdgeRef>,\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        if !self.include_source {\n            None\n        } else {\n            let f = self.f;\n            self.iter.find(move |&edge| f.include_node(edge.target()))\n        }\n    }\n}"],"visit::filter::NodeFilteredNeighbors":["impl<'a, I, F> Iterator for NodeFilteredNeighbors<'a, I, F>\nwhere\n    I: Iterator,\n    I::Item: Copy,\n    F: FilterNode<I::Item>,\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        let f = self.f;\n        if !self.include_source {\n            None\n        } else {\n            self.iter.find(move |&target| f.include_node(target))\n        }\n    }\n}"],"visit::filter::NodeFilteredNodes":["impl<'a, I, F> Iterator for NodeFilteredNodes<'a, I, F>\nwhere\n    I: Iterator,\n    I::Item: Copy + NodeRef,\n    F: FilterNode<<I::Item as NodeRef>::NodeId>,\n{\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        let f = self.f;\n        if !self.include_source {\n            None\n        } else {\n            self.iter.find(move |&target| f.include_node(target.id()))\n        }\n    }\n}"],"visit::reversed::Reversed":["Clone","Copy","Debug","impl<$($param)*> $name for $self_wrap where $self_type: $name {\n            $(\n            $(\n                type $assoc_name = $self_type::$assoc_name;\n            )*\n            )*\n            $(\n                type $assoc_name_ext = $self_type::$assoc_name_ext;\n            )*\n            $(\n            $(\n                fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret)? {\n                    $self_map!(self).$method_name($($marg),*)\n                }\n            )*\n            )*\n        }","impl<G: GraphBase> GraphBase for Reversed<G> {\n    type NodeId = G::NodeId;\n    type EdgeId = G::EdgeId;\n}","impl<G: GraphRef> GraphRef for Reversed<G> {}","impl<G: Visitable> Visitable for Reversed<G> {\n    type Map = G::Map;\n    fn visit_map(&self) -> G::Map {\n        self.0.visit_map()\n    }\n    fn reset_map(&self, map: &mut Self::Map) {\n        self.0.reset_map(map);\n    }\n}","impl<G> IntoEdgeReferences for Reversed<G>\nwhere\n    G: IntoEdgeReferences,\n{\n    type EdgeRef = ReversedEdgeReference<G::EdgeRef>;\n    type EdgeReferences = ReversedEdgeReferences<G::EdgeReferences>;\n    fn edge_references(self) -> Self::EdgeReferences {\n        ReversedEdgeReferences {\n            iter: self.0.edge_references(),\n        }\n    }\n}","impl<G> IntoEdges for Reversed<G>\nwhere\n    G: IntoEdgesDirected,\n{\n    type Edges = ReversedEdges<G::EdgesDirected>;\n    fn edges(self, a: Self::NodeId) -> Self::Edges {\n        ReversedEdges {\n            iter: self.0.edges_directed(a, Incoming),\n        }\n    }\n}","impl<G> IntoEdgesDirected for Reversed<G>\nwhere\n    G: IntoEdgesDirected,\n{\n    type EdgesDirected = ReversedEdges<G::EdgesDirected>;\n    fn edges_directed(self, a: Self::NodeId, dir: Direction) -> Self::Edges {\n        ReversedEdges {\n            iter: self.0.edges_directed(a, dir.opposite()),\n        }\n    }\n}","impl<G> IntoNeighbors for Reversed<G>\nwhere\n    G: IntoNeighborsDirected,\n{\n    type Neighbors = G::NeighborsDirected;\n    fn neighbors(self, n: G::NodeId) -> G::NeighborsDirected {\n        self.0.neighbors_directed(n, Incoming)\n    }\n}","impl<G> IntoNeighborsDirected for Reversed<G>\nwhere\n    G: IntoNeighborsDirected,\n{\n    type NeighborsDirected = G::NeighborsDirected;\n    fn neighbors_directed(self, n: G::NodeId, d: Direction) -> G::NeighborsDirected {\n        self.0.neighbors_directed(n, d.opposite())\n    }\n}"],"visit::reversed::ReversedEdgeReference":["Clone","Copy","Debug","impl<R> EdgeRef for ReversedEdgeReference<R>\nwhere\n    R: EdgeRef,\n{\n    type NodeId = R::NodeId;\n    type EdgeId = R::EdgeId;\n    type Weight = R::Weight;\n    fn source(&self) -> Self::NodeId {\n        self.0.target()\n    }\n    fn target(&self) -> Self::NodeId {\n        self.0.source()\n    }\n    fn weight(&self) -> &Self::Weight {\n        self.0.weight()\n    }\n    fn id(&self) -> Self::EdgeId {\n        self.0.id()\n    }\n}","impl<R> ReversedEdgeReference<R> {\n    /// Return the original, unreversed edge reference.\n    pub fn as_unreversed(&self) -> &R { &self.0 }\n\n    /// Consume `self` and return the original, unreversed edge reference.\n    pub fn into_unreversed(self) -> R {\n        self.0\n    }\n}"],"visit::reversed::ReversedEdgeReferences":["impl<I> Iterator for ReversedEdgeReferences<I>\nwhere\n    I: Iterator,\n    I::Item: EdgeRef,\n{\n    type Item = ReversedEdgeReference<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(ReversedEdgeReference)\n    }\n}"],"visit::reversed::ReversedEdges":["impl<I> Iterator for ReversedEdges<I>\nwhere\n    I: Iterator,\n    I::Item: EdgeRef,\n{\n    type Item = ReversedEdgeReference<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(ReversedEdgeReference)\n    }\n}"],"visit::traversal::Bfs":["Clone","impl<G> Walker<G> for Bfs<G::NodeId, G::Map>\nwhere\n    G: IntoNeighbors + Visitable,\n{\n    type Item = G::NodeId;\n    fn walk_next(&mut self, context: G) -> Option<Self::Item> {\n        self.next(context)\n    }\n}","impl<N, VM> Bfs<N, VM>\nwhere\n    N: Copy + PartialEq,\n    VM: VisitMap<N>,\n{\n    /// Create a new **Bfs**, using the graph's visitor map, and put **start**\n    /// in the stack of nodes to visit.\n    pub fn new<G>(graph: G, start: N) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,\n    {\n        let mut discovered = graph.visit_map();\n        discovered.visit(start);\n        let mut stack = VecDeque::new();\n        stack.push_front(start);\n        Bfs { stack, discovered }\n    }\n\n    /// Return the next node in the bfs, or **None** if the traversal is done.\n    pub fn next<G>(&mut self, graph: G) -> Option<N>\n    where\n        G: IntoNeighbors<NodeId = N>,\n    {\n        if let Some(node) = self.stack.pop_front() {\n            for succ in graph.neighbors(node) {\n                if self.discovered.visit(succ) {\n                    self.stack.push_back(succ);\n                }\n            }\n\n            return Some(node);\n        }\n        None\n    }\n}","impl<N, VM> Default for Bfs<N, VM>\nwhere\n    VM: Default,\n{\n    fn default() -> Self {\n        Bfs {\n            stack: VecDeque::new(),\n            discovered: VM::default(),\n        }\n    }\n}"],"visit::traversal::Dfs":["Clone","Debug","impl<G> Walker<G> for Dfs<G::NodeId, G::Map>\nwhere\n    G: IntoNeighbors + Visitable,\n{\n    type Item = G::NodeId;\n    fn walk_next(&mut self, context: G) -> Option<Self::Item> {\n        self.next(context)\n    }\n}","impl<N, VM> Default for Dfs<N, VM>\nwhere\n    VM: Default,\n{\n    fn default() -> Self {\n        Dfs {\n            stack: Vec::new(),\n            discovered: VM::default(),\n        }\n    }\n}","impl<N, VM> Dfs<N, VM>\nwhere\n    N: Copy + PartialEq,\n    VM: VisitMap<N>,\n{\n    /// Create a new **Dfs**, using the graph's visitor map, and put **start**\n    /// in the stack of nodes to visit.\n    pub fn new<G>(graph: G, start: N) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,\n    {\n        let mut dfs = Dfs::empty(graph);\n        dfs.move_to(start);\n        dfs\n    }\n\n    /// Create a `Dfs` from a vector and a visit map\n    pub fn from_parts(stack: Vec<N>, discovered: VM) -> Self {\n        Dfs { stack, discovered }\n    }\n\n    /// Clear the visit state\n    pub fn reset<G>(&mut self, graph: G)\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,\n    {\n        graph.reset_map(&mut self.discovered);\n        self.stack.clear();\n    }\n\n    /// Create a new **Dfs** using the graph's visitor map, and no stack.\n    pub fn empty<G>(graph: G) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,\n    {\n        Dfs {\n            stack: Vec::new(),\n            discovered: graph.visit_map(),\n        }\n    }\n\n    /// Keep the discovered map, but clear the visit stack and restart\n    /// the dfs from a particular node.\n    pub fn move_to(&mut self, start: N) {\n        self.stack.clear();\n        self.stack.push(start);\n    }\n\n    /// Return the next node in the dfs, or **None** if the traversal is done.\n    pub fn next<G>(&mut self, graph: G) -> Option<N>\n    where\n        G: IntoNeighbors<NodeId = N>,\n    {\n        while let Some(node) = self.stack.pop() {\n            if self.discovered.visit(node) {\n                for succ in graph.neighbors(node) {\n                    if !self.discovered.is_visited(&succ) {\n                        self.stack.push(succ);\n                    }\n                }\n                return Some(node);\n            }\n        }\n        None\n    }\n}"],"visit::traversal::DfsPostOrder":["Clone","Debug","impl<G> Walker<G> for DfsPostOrder<G::NodeId, G::Map>\nwhere\n    G: IntoNeighbors + Visitable,\n{\n    type Item = G::NodeId;\n    fn walk_next(&mut self, context: G) -> Option<Self::Item> {\n        self.next(context)\n    }\n}","impl<N, VM> Default for DfsPostOrder<N, VM>\nwhere\n    VM: Default,\n{\n    fn default() -> Self {\n        DfsPostOrder {\n            stack: Vec::new(),\n            discovered: VM::default(),\n            finished: VM::default(),\n        }\n    }\n}","impl<N, VM> DfsPostOrder<N, VM>\nwhere\n    N: Copy + PartialEq,\n    VM: VisitMap<N>,\n{\n    /// Create a new `DfsPostOrder` using the graph's visitor map, and put\n    /// `start` in the stack of nodes to visit.\n    pub fn new<G>(graph: G, start: N) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,\n    {\n        let mut dfs = Self::empty(graph);\n        dfs.move_to(start);\n        dfs\n    }\n\n    /// Create a new `DfsPostOrder` using the graph's visitor map, and no stack.\n    pub fn empty<G>(graph: G) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,\n    {\n        DfsPostOrder {\n            stack: Vec::new(),\n            discovered: graph.visit_map(),\n            finished: graph.visit_map(),\n        }\n    }\n\n    /// Clear the visit state\n    pub fn reset<G>(&mut self, graph: G)\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,\n    {\n        graph.reset_map(&mut self.discovered);\n        graph.reset_map(&mut self.finished);\n        self.stack.clear();\n    }\n\n    /// Keep the discovered and finished map, but clear the visit stack and restart\n    /// the dfs from a particular node.\n    pub fn move_to(&mut self, start: N) {\n        self.stack.clear();\n        self.stack.push(start);\n    }\n\n    /// Return the next node in the traversal, or `None` if the traversal is done.\n    pub fn next<G>(&mut self, graph: G) -> Option<N>\n    where\n        G: IntoNeighbors<NodeId = N>,\n    {\n        while let Some(&nx) = self.stack.last() {\n            if self.discovered.visit(nx) {\n                // First time visiting `nx`: Push neighbors, don't pop `nx`\n                for succ in graph.neighbors(nx) {\n                    if !self.discovered.is_visited(&succ) {\n                        self.stack.push(succ);\n                    }\n                }\n            } else {\n                self.stack.pop();\n                if self.finished.visit(nx) {\n                    // Second time: All reachable nodes must have been finished\n                    return Some(nx);\n                }\n            }\n        }\n        None\n    }\n}"],"visit::traversal::Topo":["Clone","impl<G> Walker<G> for Topo<G::NodeId, G::Map>\nwhere\n    G: IntoNeighborsDirected + Visitable,\n{\n    type Item = G::NodeId;\n    fn walk_next(&mut self, context: G) -> Option<Self::Item> {\n        self.next(context)\n    }\n}","impl<N, VM> Default for Topo<N, VM>\nwhere\n    VM: Default,\n{\n    fn default() -> Self {\n        Topo {\n            tovisit: Vec::new(),\n            ordered: VM::default(),\n        }\n    }\n}","impl<N, VM> Topo<N, VM>\nwhere\n    N: Copy + PartialEq,\n    VM: VisitMap<N>,\n{\n    /// Create a new `Topo`, using the graph's visitor map, and put all\n    /// initial nodes in the to visit list.\n    pub fn new<G>(graph: G) -> Self\n    where\n        G: IntoNodeIdentifiers + IntoNeighborsDirected + Visitable<NodeId = N, Map = VM>,\n    {\n        let mut topo = Self::empty(graph);\n        topo.extend_with_initials(graph);\n        topo\n    }\n\n    fn extend_with_initials<G>(&mut self, g: G)\n    where\n        G: IntoNodeIdentifiers + IntoNeighborsDirected<NodeId = N>,\n    {\n        // find all initial nodes (nodes without incoming edges)\n        self.tovisit.extend(\n            g.node_identifiers()\n                .filter(move |&a| g.neighbors_directed(a, Incoming).next().is_none()),\n        );\n    }\n\n    /* Private until it has a use */\n    /// Create a new `Topo`, using the graph's visitor map with *no* starting\n    /// index specified.\n    fn empty<G>(graph: G) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,\n    {\n        Topo {\n            ordered: graph.visit_map(),\n            tovisit: Vec::new(),\n        }\n    }\n\n    /// Clear visited state, and put all initial nodes in the to visit list.\n    pub fn reset<G>(&mut self, graph: G)\n    where\n        G: IntoNodeIdentifiers + IntoNeighborsDirected + Visitable<NodeId = N, Map = VM>,\n    {\n        graph.reset_map(&mut self.ordered);\n        self.tovisit.clear();\n        self.extend_with_initials(graph);\n    }\n\n    /// Return the next node in the current topological order traversal, or\n    /// `None` if the traversal is at the end.\n    ///\n    /// *Note:* The graph may not have a complete topological order, and the only\n    /// way to know is to run the whole traversal and make sure it visits every node.\n    pub fn next<G>(&mut self, g: G) -> Option<N>\n    where\n        G: IntoNeighborsDirected + Visitable<NodeId = N, Map = VM>,\n    {\n        // Take an unvisited element and find which of its neighbors are next\n        while let Some(nix) = self.tovisit.pop() {\n            if self.ordered.is_visited(&nix) {\n                continue;\n            }\n            self.ordered.visit(nix);\n            for neigh in g.neighbors(nix) {\n                // Look at each neighbor, and those that only have incoming edges\n                // from the already ordered list, they are the next to visit.\n                if Reversed(g)\n                    .neighbors(neigh)\n                    .all(|b| self.ordered.is_visited(&b))\n                {\n                    self.tovisit.push(neigh);\n                }\n            }\n            return Some(nix);\n        }\n        None\n    }\n}"],"visit::traversal::WalkerIter":["Clone","Debug","impl<W, C> Iterator for WalkerIter<W, C>\nwhere\n    W: Walker<C>,\n    C: Clone,\n{\n    type Item = W::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.walker.walk_next(self.context.clone())\n    }\n}","impl<W, C> WalkerIter<W, C>\nwhere\n    W: Walker<C>,\n    C: Clone,\n{\n    pub fn context(&self) -> C {\n        self.context.clone()\n    }\n\n    pub fn inner_ref(&self) -> &W {\n        &self.walker\n    }\n\n    pub fn inner_mut(&mut self) -> &mut W {\n        &mut self.walker\n    }\n}"]},"single_path_import":{"Directed":"prelude::Directed","Direction":"Direction","Direction::Incoming":"prelude::Incoming","Direction::Outgoing":"prelude::Outgoing","Undirected":"prelude::Undirected","astar::astar":"algo::astar","dijkstra::dijkstra":"algo::dijkstra","graph_impl::DefaultIx":"graph::DefaultIx","graph_impl::DiGraph":"graph::DiGraph","graph_impl::Edge":"graph::Edge","graph_impl::EdgeIndex":"graph::EdgeIndex","graph_impl::EdgeIndices":"graph::EdgeIndices","graph_impl::EdgeReference":"graph::EdgeReference","graph_impl::EdgeReferences":"graph::EdgeReferences","graph_impl::EdgeWeightsMut":"graph::EdgeWeightsMut","graph_impl::Edges":"graph::Edges","graph_impl::EdgesConnecting":"graph::EdgesConnecting","graph_impl::Externals":"graph::Externals","graph_impl::Frozen":"graph::Frozen","graph_impl::Graph":"graph::Graph","graph_impl::GraphIndex":"graph::GraphIndex","graph_impl::IndexType":"graph::IndexType","graph_impl::Neighbors":"graph::Neighbors","graph_impl::Node":"graph::Node","graph_impl::NodeIndex":"graph::NodeIndex","graph_impl::NodeIndices":"graph::NodeIndices","graph_impl::NodeReferences":"graph::NodeReferences","graph_impl::NodeWeightsMut":"graph::NodeWeightsMut","graph_impl::UnGraph":"graph::UnGraph","graph_impl::WalkNeighbors":"graph::WalkNeighbors","graph_impl::edge_index":"graph::edge_index","graph_impl::node_index":"graph::node_index","graph_impl::stable_graph":"stable_graph","graph_impl::stable_graph::StableDiGraph":"prelude::StableDiGraph","graph_impl::stable_graph::StableGraph":"prelude::StableGraph","graph_impl::stable_graph::StableUnGraph":"prelude::StableUnGraph","graphmap::DiGraphMap":"prelude::DiGraphMap","graphmap::GraphMap":"prelude::GraphMap","graphmap::UnGraphMap":"prelude::UnGraphMap","isomorphism::is_isomorphic":"algo::is_isomorphic","isomorphism::is_isomorphic_matching":"algo::is_isomorphic_matching","simple_paths::all_simple_paths":"algo::all_simple_paths","visit::EdgeRef":"prelude::EdgeRef","visit::traversal::Bfs":"prelude::Bfs","visit::traversal::Dfs":"prelude::Dfs","visit::traversal::DfsPostOrder":"prelude::DfsPostOrder"},"srcs":{"<&'a (Ix, Ix) as IntoWeightedEdge<E>>::into_weighted_edge":["fn into_weighted_edge(self) -> (Ix, Ix, E){\n        let (s, t) = *self;\n        (s, t, E::default())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a (Ix, Ix, E) as IntoWeightedEdge<E>>::into_weighted_edge":["fn into_weighted_edge(self) -> (Ix, Ix, E){\n        self.clone()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<&'a G as data::DataMap>::edge_weight":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as data::DataMap>::node_weight":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::GetAdjacencyMatrix>::adjacency_matrix":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::GetAdjacencyMatrix>::is_adjacent":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::IntoEdgeReferences>::edge_references":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::IntoEdges>::edges":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::IntoEdgesDirected>::edges_directed":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::IntoNeighbors>::neighbors":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::IntoNeighborsDirected>::neighbors_directed":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::IntoNodeIdentifiers>::node_identifiers":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::IntoNodeReferences>::node_references":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::NodeCount>::node_count":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::NodeIndexable>::from_index":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::NodeIndexable>::node_bound":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::NodeIndexable>::to_index":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::Visitable>::reset_map":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*){\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a G as visit::Visitable>::visit_map":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoEdgeReferences>::edge_references":["fn edge_references(self) -> Self::EdgeReferences{\n        EdgeReferences {\n            index: 0,\n            source_index: Ix::new(0),\n            edge_ranges: self.row.windows(2).enumerate(),\n            column: &self.column,\n            edges: &self.edges,\n            iter: zip(&[], &[]),\n            ty: self.ty,\n        }\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoEdges>::edges":["fn edges(self, a: Self::NodeId) -> Self::Edges{\n        self.edges(a)\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoNeighbors>::neighbors":["/// Return an iterator of all neighbors of `a`.\n///\n/// - `Directed`: Targets of outgoing edges from `a`.\n/// - `Undirected`: Opposing endpoints of all edges connected to `a`.\n///\n/// **Panics** if the node `a` does not exist.<br>\n/// Iterator element type is `NodeIndex<Ix>`.\nfn neighbors(self, a: Self::NodeId) -> Self::Neighbors{\n        Neighbors {\n            iter: self.neighbors_slice(a).iter(),\n        }\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["fn node_identifiers(self) -> Self::NodeIdentifiers{\n        NodeIdentifiers {\n            r: 0..self.node_count(),\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdgeReferences>::edge_references":["fn edge_references(self) -> Self::EdgeReferences{\n        (*self).edge_references()\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdges>::edges":["fn edges(self, a: Self::NodeId) -> Self::Edges{\n        self.edges(a)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdgesDirected>::edges_directed":["fn edges_directed(self, a: Self::NodeId, dir: Direction) -> Self::EdgesDirected{\n        self.edges_directed(a, dir)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNeighbors>::neighbors":["fn neighbors(self, n: graph::NodeIndex<Ix>) -> graph::Neighbors<'a, E, Ix>{\n        Graph::neighbors(self, n)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNeighborsDirected>::neighbors_directed":["fn neighbors_directed(\n        self,\n        n: graph::NodeIndex<Ix>,\n        d: Direction,\n    ) -> graph::Neighbors<'a, E, Ix>{\n        Graph::neighbors_directed(self, n, d)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["fn node_identifiers(self) -> graph::NodeIndices<Ix>{\n        Graph::node_indices(self)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNodeReferences>::node_references":["fn node_references(self) -> Self::NodeReferences{\n        NodeReferences {\n            iter: self.nodes.iter().enumerate(),\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdgeReferences>::edge_references":["/// Create an iterator over all edges in the graph, in indexed order.\n///\n/// Iterator element type is `EdgeReference<E, Ix>`.\nfn edge_references(self) -> Self::EdgeReferences{\n        EdgeReferences {\n            iter: self.g.edges.iter().enumerate(),\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdges>::edges":["fn edges(self, a: Self::NodeId) -> Self::Edges{\n        self.edges(a)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdgesDirected>::edges_directed":["fn edges_directed(self, a: Self::NodeId, dir: Direction) -> Self::EdgesDirected{\n        self.edges_directed(a, dir)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNeighbors>::neighbors":["fn neighbors(self, n: Self::NodeId) -> Self::Neighbors{\n        (*self).neighbors(n)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNeighborsDirected>::neighbors_directed":["fn neighbors_directed(self, n: graph::NodeIndex<Ix>, d: Direction) -> Self::NeighborsDirected{\n        StableGraph::neighbors_directed(self, n, d)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["fn node_identifiers(self) -> Self::NodeIdentifiers{\n        StableGraph::node_indices(self)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNodeReferences>::node_references":["fn node_references(self) -> Self::NodeReferences{\n        NodeReferences {\n            iter: enumerate(self.raw_nodes()),\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoEdgeReferences>::edge_references":["fn edge_references(self) -> Self::EdgeReferences{\n        self.all_edges()\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoEdges>::edges":["fn edges(self, a: Self::NodeId) -> Self::Edges{\n        self.edges(a)\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNeighbors>::neighbors":["fn neighbors(self, n: Self::NodeId) -> Self::Neighbors{\n        self.neighbors(n)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNeighborsDirected>::neighbors_directed":["fn neighbors_directed(self, n: N, dir: Direction) -> Self::NeighborsDirected{\n        self.neighbors_directed(n, dir)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNodeIdentifiers>::node_identifiers":["fn node_identifiers(self) -> Self::NodeIdentifiers{\n        NodeIdentifiers {\n            iter: self.nodes.iter(),\n            ty: self.ty,\n            edge_ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNodeReferences>::node_references":["fn node_references(self) -> Self::NodeReferences{\n        NodeReferences {\n            iter: self.nodes.iter(),\n            ty: self.ty,\n            edge_ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<&'a matrix_graph::MatrixGraph<N, E, Directed, Null, Ix> as visit::IntoNeighborsDirected>::neighbors_directed":["fn neighbors_directed(self, a: NodeIndex<Ix>, d: Direction) -> Self::NeighborsDirected{\n        MatrixGraph::neighbors_directed(self, a, d)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoEdgeReferences>::edge_references":["fn edge_references(self) -> Self::EdgeReferences{\n        EdgeReferences::new(&self.node_adjacencies, self.node_capacity)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoEdges>::edges":["fn edges(self, a: Self::NodeId) -> Self::Edges{\n        MatrixGraph::edges(self, a)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNeighbors>::neighbors":["fn neighbors(self, a: NodeIndex<Ix>) -> Self::Neighbors{\n        MatrixGraph::neighbors(self, a)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["fn node_identifiers(self) -> Self::NodeIdentifiers{\n        NodeIdentifiers::new(self.nodes.iter_ids())\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNodeReferences>::node_references":["fn node_references(self) -> Self::NodeReferences{\n        NodeReferences::new(&self.nodes)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<&'a mut G as data::DataMap>::edge_weight":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a mut G as data::DataMap>::node_weight":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a mut G as data::DataMapMut>::edge_weight_mut":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a mut G as data::DataMapMut>::node_weight_mut":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a mut W as visit::traversal::Walker<C>>::walk_next":["fn walk_next(&mut self, context: C) -> Option<Self::Item>{\n        (**self).walk_next(context)\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoEdgeReferences>::edge_references":["fn edge_references(self) -> Self::EdgeReferences{\n        EdgeFilteredEdges {\n            graph: PhantomData,\n            iter: self.0.edge_references(),\n            f: &self.1,\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoEdges>::edges":["fn edges(self, n: G::NodeId) -> Self::Edges{\n        EdgeFilteredEdges {\n            graph: PhantomData,\n            iter: self.0.edges(n),\n            f: &self.1,\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNeighbors>::neighbors":["fn neighbors(self, n: G::NodeId) -> Self::Neighbors{\n        EdgeFilteredNeighbors {\n            iter: self.0.edges(n),\n            f: &self.1,\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNeighborsDirected>::neighbors_directed":["fn neighbors_directed(self, n: G::NodeId, dir: Direction) -> Self::NeighborsDirected{\n        EdgeFilteredNeighborsDirected {\n            iter: self.0.edges_directed(n, dir),\n            f: &self.1,\n            from: n,\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNodeIdentifiers>::node_identifiers":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNodeReferences>::node_references":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoEdgeReferences>::edge_references":["fn edge_references(self) -> Self::EdgeReferences{\n        NodeFilteredEdgeReferences {\n            graph: PhantomData,\n            iter: self.0.edge_references(),\n            f: &self.1,\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoEdges>::edges":["fn edges(self, a: G::NodeId) -> Self::Edges{\n        NodeFilteredEdges {\n            graph: PhantomData,\n            include_source: self.1.include_node(a),\n            iter: self.0.edges(a),\n            f: &self.1,\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNeighbors>::neighbors":["fn neighbors(self, n: G::NodeId) -> Self::Neighbors{\n        NodeFilteredNeighbors {\n            include_source: self.1.include_node(n),\n            iter: self.0.neighbors(n),\n            f: &self.1,\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNeighborsDirected>::neighbors_directed":["fn neighbors_directed(self, n: G::NodeId, dir: Direction) -> Self::NeighborsDirected{\n        NodeFilteredNeighbors {\n            include_source: self.1.include_node(n),\n            iter: self.0.neighbors_directed(n, dir),\n            f: &self.1,\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNodeIdentifiers>::node_identifiers":["fn node_identifiers(self) -> Self::NodeIdentifiers{\n        NodeFilteredNeighbors {\n            include_source: true,\n            iter: self.0.node_identifiers(),\n            f: &self.1,\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNodeReferences>::node_references":["fn node_references(self) -> Self::NodeReferences{\n        NodeFilteredNodes {\n            include_source: true,\n            iter: self.0.node_references(),\n            f: &self.1,\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<&fixedbitset::FixedBitSet as visit::filter::FilterNode<N>>::include_node":["fn include_node(&self, n: N) -> bool{\n        self.is_visited(&n)\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<&std::collections::HashSet<N, S> as visit::filter::FilterNode<N>>::include_node":["fn include_node(&self, n: N) -> bool{\n        self.is_visited(&n)\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<() as visit::dfsvisit::ControlFlow>::continuing":["fn continuing(){}","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"<() as visit::dfsvisit::ControlFlow>::should_break":["#[inline]\nfn should_break(&self) -> bool{\n        false\n    }","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"<() as visit::dfsvisit::ControlFlow>::should_prune":["#[inline]\nfn should_prune(&self) -> bool{\n        false\n    }","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"<(Id, &'a W) as visit::NodeRef>::id":["fn id(&self) -> Self::NodeId{\n        self.0\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<(Id, &'a W) as visit::NodeRef>::weight":["fn weight(&self) -> &Self::Weight{\n        self.1\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<(Id, ()) as visit::NodeRef>::id":["fn id(&self) -> Self::NodeId{\n        self.0\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<(Id, ()) as visit::NodeRef>::weight":["fn weight(&self) -> &Self::Weight{\n        static DUMMY: () = ();\n        &DUMMY\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<(Ix, Ix) as IntoWeightedEdge<E>>::into_weighted_edge":["fn into_weighted_edge(self) -> (Ix, Ix, E){\n        let (s, t) = self;\n        (s, t, E::default())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<(Ix, Ix, &'a E) as IntoWeightedEdge<E>>::into_weighted_edge":["fn into_weighted_edge(self) -> (Ix, Ix, E){\n        let (a, b, c) = self;\n        (a, b, c.clone())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<(Ix, Ix, E) as IntoWeightedEdge<E>>::into_weighted_edge":["fn into_weighted_edge(self) -> (Ix, Ix, E){\n        self\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<(N, N, &'a E) as visit::EdgeRef>::id":["fn id(&self) -> (N, N){\n        (self.0, self.1)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<(N, N, &'a E) as visit::EdgeRef>::source":["fn source(&self) -> N{\n        self.0\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<(N, N, &'a E) as visit::EdgeRef>::target":["fn target(&self) -> N{\n        self.1\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<(N, N, &'a E) as visit::EdgeRef>::weight":["fn weight(&self) -> &E{\n        self.2\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<Directed as EdgeType>::is_directed":["#[inline]\nfn is_directed() -> bool{\n        true\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Directed as std::clone::Clone>::clone":["#[inline]\nfn clone(&self) -> Self{\n                *self\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<Direction as std::clone::Clone>::clone":["#[inline]\nfn clone(&self) -> Self{\n                *self\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<F as isomorphism::SemanticMatcher<T>>::enabled":["#[inline]\nfn enabled() -> bool{\n        true\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"<F as isomorphism::SemanticMatcher<T>>::eq":["#[inline]\nfn eq(&mut self, a: &T, b: &T) -> bool{\n        self(a, b)\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"<F as visit::filter::FilterEdge<N>>::include_edge":["fn include_edge(&self, n: N) -> bool{\n        (*self)(n)\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<F as visit::filter::FilterNode<N>>::include_node":["fn include_node(&self, n: N) -> bool{\n        (*self)(n)\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<Undirected as EdgeType>::is_directed":["#[inline]\nfn is_directed() -> bool{\n        false\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Undirected as std::clone::Clone>::clone":["#[inline]\nfn clone(&self) -> Self{\n                *self\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<algo::DfsSpace<N, VM> as std::default::Default>::default":["fn default() -> Self{\n        DfsSpace {\n            dfs: Dfs {\n                stack: <_>::default(),\n                discovered: <_>::default(),\n            },\n        }\n    }","Real(LocalPath(\"src/algo/mod.rs\"))"],"<algo::MinSpanningTree<G> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let g = self.graph;\n        if let Some(ref mut iter) = self.node_ids {\n            if let Some(node) = iter.next() {\n                self.node_map.insert(g.to_index(node.id()), self.node_count);\n                self.node_count += 1;\n                return Some(Element::Node {\n                    weight: node.weight().clone(),\n                });\n            }\n        }\n        self.node_ids = None;\n\n        // Kruskal's algorithm.\n        // Algorithm is this:\n        //\n        // 1. Create a pre-MST with all the vertices and no edges.\n        // 2. Repeat:\n        //\n        //  a. Remove the shortest edge from the original graph.\n        //  b. If the edge connects two disjoint trees in the pre-MST,\n        //     add the edge.\n        while let Some(MinScored(score, (a, b))) = self.sort_edges.pop() {\n            // check if the edge would connect two disjoint parts\n            let (a_index, b_index) = (g.to_index(a), g.to_index(b));\n            if self.subgraphs.union(a_index, b_index) {\n                let (&a_order, &b_order) =\n                    match (self.node_map.get(&a_index), self.node_map.get(&b_index)) {\n                        (Some(a_id), Some(b_id)) => (a_id, b_id),\n                        _ => panic!(\"Edge references unknown node\"),\n                    };\n                return Some(Element::Edge {\n                    source: a_order,\n                    target: b_order,\n                    weight: score,\n                });\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/algo/mod.rs\"))"],"<algo::dominators::DominatorsIter<'a, N> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let next = self.node.take();\n        if let Some(next) = next {\n            self.node = self.dominators.immediate_dominator(next);\n        }\n        next\n    }","Real(LocalPath(\"src/algo/dominators.rs\"))"],"<csr::Csr<N, E, Ty, Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        Csr {\n            column: self.column.clone(),\n            edges: self.edges.clone(),\n            row: self.row.clone(),\n            node_weights: self.node_weights.clone(),\n            edge_count: self.edge_count,\n            ty: self.ty,\n        }\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Csr<N, E, Ty, Ix> as std::default::Default>::default":["fn default() -> Self{\n        Self::new()\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Csr<N, E, Ty, Ix> as std::ops::Index<Ix>>::index":["fn index(&self, ix: NodeIndex<Ix>) -> &N{\n        &self.node_weights[ix.index()]\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Csr<N, E, Ty, Ix> as std::ops::IndexMut<Ix>>::index_mut":["fn index_mut(&mut self, ix: NodeIndex<Ix>) -> &mut N{\n        &mut self.node_weights[ix.index()]\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeCount>::node_count":["fn node_count(&self) -> usize{\n        (*self).node_count()\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeIndexable>::from_index":["fn from_index(&self, ix: usize) -> Self::NodeId{\n        Ix::new(ix)\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeIndexable>::node_bound":["fn node_bound(&self) -> usize{\n        self.node_count()\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeIndexable>::to_index":["fn to_index(&self, a: Self::NodeId) -> usize{\n        a.index()\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Csr<N, E, Ty, Ix> as visit::Visitable>::reset_map":["fn reset_map(&self, map: &mut Self::Map){\n        map.clear();\n        map.grow(self.node_count());\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Csr<N, E, Ty, Ix> as visit::Visitable>::visit_map":["fn visit_map(&self) -> FixedBitSet{\n        FixedBitSet::with_capacity(self.node_count())\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::EdgeReference<'a, E, Ty, Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        *self\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::id":["fn id(&self) -> Self::EdgeId{\n        self.index\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::source":["fn source(&self) -> Self::NodeId{\n        self.source\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::target":["fn target(&self) -> Self::NodeId{\n        self.target\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::weight":["fn weight(&self) -> &E{\n        self.weight\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::EdgeReferences<'a, E, Ty, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        loop {\n            if let Some((&j, w)) = self.iter.next() {\n                let index = self.index;\n                self.index += 1;\n                return Some(EdgeReference {\n                    index,\n                    source: self.source_index,\n                    target: j,\n                    weight: w,\n                    ty: PhantomData,\n                });\n            }\n            if let Some((i, w)) = self.edge_ranges.next() {\n                let a = w[0];\n                let b = w[1];\n                self.iter = zip(&self.column[a..b], &self.edges[a..b]);\n                self.source_index = Ix::new(i);\n            } else {\n                return None;\n            }\n        }\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().map(move |(&j, w)| {\n            let index = self.index;\n            self.index += 1;\n            EdgeReference {\n                index,\n                source: self.source,\n                target: j,\n                weight: w,\n                ty: PhantomData,\n            }\n        })\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Neighbors<'a, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().cloned()\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::Neighbors<'a, Ix> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::NodeIdentifiers<Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.r.next().map(Ix::new)\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<csr::NodeIdentifiers<Ix> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.r.size_hint()\n    }","Real(LocalPath(\"src/csr.rs\"))"],"<data::FilterElements<I, F> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        loop {\n            let mut elt = match self.iter.next() {\n                None => return None,\n                Some(elt) => elt,\n            };\n            let keep = (self.f)(match elt {\n                Element::Node { ref mut weight } => Element::Node { weight },\n                Element::Edge {\n                    source,\n                    target,\n                    ref mut weight,\n                } => Element::Edge {\n                    source,\n                    target,\n                    weight,\n                },\n            });\n            let is_node = if let Element::Node { .. } = elt {\n                true\n            } else {\n                false\n            };\n            if !keep && is_node {\n                self.map.push(self.node_index);\n            }\n            if is_node {\n                self.node_index += 1;\n            }\n            if !keep {\n                continue;\n            }\n\n            // map edge parts\n            match elt {\n                Element::Edge {\n                    ref mut source,\n                    ref mut target,\n                    ..\n                } => {\n                    // Find the node indices in the map of removed ones.\n                    // If a node was removed, the edge is as well.\n                    // Otherwise the counts are adjusted by the number of nodes\n                    // removed.\n                    // Example: map: [1, 3, 4, 6]\n                    // binary search for 2, result is Err(1). One node has been\n                    // removed before 2.\n                    match self.map.binary_search(source) {\n                        Ok(_) => continue,\n                        Err(i) => *source -= i,\n                    }\n                    match self.map.binary_search(target) {\n                        Ok(_) => continue,\n                        Err(i) => *target -= i,\n                    }\n                }\n                Element::Node { .. } => {}\n            }\n            return Some(elt);\n        }\n    }","Real(LocalPath(\"src/data.rs\"))"],"<dot::DebugFmt<T> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/dot.rs\"))"],"<dot::Dot<'a, G> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.graph_fmt(\n            self.graph,\n            f,\n            |n, cb| cb(&DebugFmt(n)),\n            |e, cb| cb(&DebugFmt(e)),\n        )\n    }","Real(LocalPath(\"src/dot.rs\"))"],"<dot::Dot<'a, G> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.graph_fmt(self.graph, f, |n, cb| cb(n), |e, cb| cb(e))\n    }","Real(LocalPath(\"src/dot.rs\"))"],"<dot::Escaped<T> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if f.alternate() {\n            writeln!(&mut Escaper(f), \"{:#}\", &self.0)\n        } else {\n            write!(&mut Escaper(f), \"{}\", &self.0)\n        }\n    }","Real(LocalPath(\"src/dot.rs\"))"],"<dot::Escaper<W> as std::fmt::Write>::write_char":["fn write_char(&mut self, c: char) -> fmt::Result{\n        match c {\n            '\"' | '\\\\' => self.0.write_char('\\\\')?,\n            // \\l is for left justified linebreak\n            '\\n' => return self.0.write_str(\"\\\\l\"),\n            _ => {}\n        }\n        self.0.write_char(c)\n    }","Real(LocalPath(\"src/dot.rs\"))"],"<dot::Escaper<W> as std::fmt::Write>::write_str":["fn write_str(&mut self, s: &str) -> fmt::Result{\n        for c in s.chars() {\n            self.write_char(c)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/dot.rs\"))"],"<f32 as algo::FloatMeasure>::infinite":["fn infinite() -> Self{\n        1. / 0.\n    }","Real(LocalPath(\"src/algo/mod.rs\"))"],"<f32 as algo::FloatMeasure>::zero":["fn zero() -> Self{\n        0.\n    }","Real(LocalPath(\"src/algo/mod.rs\"))"],"<f32 as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<f32 as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<f64 as algo::FloatMeasure>::infinite":["fn infinite() -> Self{\n        1. / 0.\n    }","Real(LocalPath(\"src/algo/mod.rs\"))"],"<f64 as algo::FloatMeasure>::zero":["fn zero() -> Self{\n        0.\n    }","Real(LocalPath(\"src/algo/mod.rs\"))"],"<f64 as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<f64 as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<fixedbitset::FixedBitSet as visit::VisitMap<Ix>>::is_visited":["fn is_visited(&self, x: &Ix) -> bool{\n        self.contains(x.index())\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<fixedbitset::FixedBitSet as visit::VisitMap<Ix>>::visit":["fn visit(&mut self, x: Ix) -> bool{\n        !self.put(x.index())\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::EdgeIndex<Ix>>>::is_visited":["fn is_visited(&self, x: &graph::EdgeIndex<Ix>) -> bool{\n        self.contains(x.index())\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::EdgeIndex<Ix>>>::visit":["fn visit(&mut self, x: graph::EdgeIndex<Ix>) -> bool{\n        !self.put(x.index())\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::NodeIndex<Ix>>>::is_visited":["fn is_visited(&self, x: &graph::NodeIndex<Ix>) -> bool{\n        self.contains(x.index())\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::NodeIndex<Ix>>>::visit":["fn visit(&mut self, x: graph::NodeIndex<Ix>) -> bool{\n        !self.put(x.index())\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<fixedbitset::FixedBitSet as visit::filter::FilterNode<N>>::include_node":["fn include_node(&self, n: N) -> bool{\n        self.is_visited(&n)\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<graph_impl::Edge<E, Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n            $name {\n                $(\n                    $field : self . $field .clone()\n                ),*\n            }\n        }","Real(LocalPath(\"src/macros.rs\"))"],"<graph_impl::EdgeIndex<Ix> as graph_impl::GraphIndex>::index":["#[inline]\nfn index(&self) -> usize{\n        EdgeIndex::index(*self)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeIndex<Ix> as graph_impl::GraphIndex>::is_node_index":["#[inline]\nfn is_node_index() -> bool{\n        false\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeIndex<Ix> as std::convert::From<Ix>>::from":["fn from(ix: Ix) -> Self{\n        EdgeIndex(ix)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeIndex<Ix> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"EdgeIndex({:?})\", self.0)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeIndices<Ix> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.r.next_back().map(edge_index)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeIndices<Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.r.next().map(edge_index)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeIndices<Ix> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.r.size_hint()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeReference<'a, E, Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        *self\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeReference<'a, E, Ix> as std::cmp::PartialEq>::eq":["fn eq(&self, rhs: &Self) -> bool{\n        self.index == rhs.index && self.weight == rhs.weight\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::id":["fn id(&self) -> Self::EdgeId{\n        self.index\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::source":["fn source(&self) -> Self::NodeId{\n        self.node[0]\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::target":["fn target(&self) -> Self::NodeId{\n        self.node[1]\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::weight":["fn weight(&self) -> &E{\n        self.weight\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeReferences<'a, E, Ix> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.iter.next_back().map(|(i, edge)| EdgeReference {\n            index: edge_index(i),\n            node: edge.node,\n            weight: &edge.weight,\n        })\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeReferences<'a, E, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().map(|(i, edge)| EdgeReference {\n            index: edge_index(i),\n            node: edge.node,\n            weight: &edge.weight,\n        })\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeReferences<'a, E, Ix> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeWeightsMut<'a, E, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a mut E>{\n        self.edges.next().map(|edge| &mut edge.weight)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgeWeightsMut<'a, E, Ix> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.edges.size_hint()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Edges<'a, E, Ty, Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        Edges {\n            skip_start: self.skip_start,\n            edges: self.edges,\n            next: self.next,\n            direction: self.direction,\n            ty: self.ty,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        //      type        direction    |    iterate over    reverse\n        //                               |\n        //    Directed      Outgoing     |      outgoing        no\n        //    Directed      Incoming     |      incoming        no\n        //   Undirected     Outgoing     |        both       incoming\n        //   Undirected     Incoming     |        both       outgoing\n\n        // For iterate_over, \"both\" is represented as None.\n        // For reverse, \"no\" is represented as None.\n        let (iterate_over, reverse) = if Ty::is_directed() {\n            (Some(self.direction), None)\n        } else {\n            (None, Some(self.direction.opposite()))\n        };\n\n        if iterate_over.unwrap_or(Outgoing) == Outgoing {\n            let i = self.next[0].index();\n            if let Some(Edge { node, weight, next }) = self.edges.get(i) {\n                self.next[0] = next[0];\n                return Some(EdgeReference {\n                    index: edge_index(i),\n                    node: if reverse == Some(Outgoing) {\n                        swap_pair(*node)\n                    } else {\n                        *node\n                    },\n                    weight,\n                });\n            }\n        }\n\n        if iterate_over.unwrap_or(Incoming) == Incoming {\n            while let Some(Edge { node, weight, next }) = self.edges.get(self.next[1].index()) {\n                let edge_index = self.next[1];\n                self.next[1] = next[1];\n                // In any of the \"both\" situations, self-loops would be iterated over twice.\n                // Skip them here.\n                if iterate_over.is_none() && node[0] == self.skip_start {\n                    continue;\n                }\n\n                return Some(EdgeReference {\n                    index: edge_index,\n                    node: if reverse == Some(Incoming) {\n                        swap_pair(*node)\n                    } else {\n                        *node\n                    },\n                    weight,\n                });\n            }\n        }\n\n        None\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::EdgesConnecting<'a, E, Ty, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<EdgeReference<'a, E, Ix>>{\n        while let Some(edge) = self.edges.next() {\n            if edge.node[1] == self.target_node {\n                return Some(edge);\n            }\n        }\n\n        None\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Externals<'a, N, Ty, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<NodeIndex<Ix>>{\n        let k = self.dir.index();\n        loop {\n            match self.iter.next() {\n                None => return None,\n                Some((index, node)) => {\n                    if node.next[k] == EdgeIndex::end()\n                        && (Ty::is_directed() || node.next[1 - k] == EdgeIndex::end())\n                    {\n                        return Some(NodeIndex::new(index));\n                    } else {\n                        continue;\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Build>::add_edge":["fn add_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Option<Self::EdgeId>{\n        Some(self.add_edge(a, b, weight))\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Build>::add_node":["fn add_node(&mut self, weight: Self::NodeWeight) -> Self::NodeId{\n        self.add_node(weight)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Build>::update_edge":["fn update_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Self::EdgeId{\n        self.update_edge(a, b, weight)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Create>::with_capacity":["fn with_capacity(nodes: usize, edges: usize) -> Self{\n        Self::with_capacity(nodes, edges)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMap>::edge_weight":["fn edge_weight(&self, id: Self::EdgeId) -> Option<&Self::EdgeWeight>{\n        self.edge_weight(id)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMap>::node_weight":["fn node_weight(&self, id: Self::NodeId) -> Option<&Self::NodeWeight>{\n        self.node_weight(id)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMapMut>::edge_weight_mut":["fn edge_weight_mut(&mut self, id: Self::EdgeId) -> Option<&mut Self::EdgeWeight>{\n        self.edge_weight_mut(id)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMapMut>::node_weight_mut":["fn node_weight_mut(&mut self, id: Self::NodeId) -> Option<&mut Self::NodeWeight>{\n        self.node_weight_mut(id)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as data::FromElements>::from_elements":["fn from_elements<I>(iterable: I) -> Self\n    where\n        Self: Sized,\n        I: IntoIterator<Item = Element<Self::NodeWeight, Self::EdgeWeight>>,{\n        from_elements_indexable(iterable)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        Graph {\n            nodes: self.nodes.clone(),\n            edges: self.edges.clone(),\n            ty: self.ty,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as std::clone::Clone>::clone_from":["fn clone_from(&mut self, rhs: &Self){\n        self.nodes.clone_from(&rhs.nodes);\n        self.edges.clone_from(&rhs.edges);\n        self.ty = rhs.ty;\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as std::default::Default>::default":["fn default() -> Self{\n        Self::with_capacity(0, 0)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let etype = if self.is_directed() {\n            \"Directed\"\n        } else {\n            \"Undirected\"\n        };\n        let mut fmt_struct = f.debug_struct(\"Graph\");\n        fmt_struct.field(\"Ty\", &etype);\n        fmt_struct.field(\"node_count\", &self.node_count());\n        fmt_struct.field(\"edge_count\", &self.edge_count());\n        if self.edge_count() > 0 {\n            fmt_struct.field(\n                \"edges\",\n                &self\n                    .edges\n                    .iter()\n                    .map(|e| NoPretty((e.source().index(), e.target().index())))\n                    .format(\", \"),\n            );\n        }\n        // skip weights if they are ZST!\n        if size_of::<N>() != 0 {\n            fmt_struct.field(\n                \"node weights\",\n                &DebugMap(|| self.nodes.iter().map(|n| &n.weight).enumerate()),\n            );\n        }\n        if size_of::<E>() != 0 {\n            fmt_struct.field(\n                \"edge weights\",\n                &DebugMap(|| self.edges.iter().map(|n| &n.weight).enumerate()),\n            );\n        }\n        fmt_struct.finish()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::Index<graph_impl::EdgeIndex<Ix>>>::index":["fn index(&self, index: EdgeIndex<Ix>) -> &E{\n        &self.edges[index.index()].weight\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::Index<graph_impl::NodeIndex<Ix>>>::index":["fn index(&self, index: NodeIndex<Ix>) -> &N{\n        &self.nodes[index.index()].weight\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::EdgeIndex<Ix>>>::index_mut":["fn index_mut(&mut self, index: EdgeIndex<Ix>) -> &mut E{\n        &mut self.edges[index.index()].weight\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::NodeIndex<Ix>>>::index_mut":["fn index_mut(&mut self, index: NodeIndex<Ix>) -> &mut N{\n        &mut self.nodes[index.index()].weight\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeCount>::node_count":["fn node_count(&self) -> usize{\n        self.node_count()\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeIndexable>::from_index":["fn from_index(&self, ix: usize) -> Self::NodeId{\n        NodeIndex::new(ix)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeIndexable>::node_bound":["fn node_bound(&self) -> usize{\n        self.node_count()\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeIndexable>::to_index":["fn to_index(&self, ix: NodeIndex<Ix>) -> usize{\n        ix.index()\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::Visitable>::reset_map":["fn reset_map(&self, map: &mut Self::Map){\n        map.clear();\n        map.grow(self.node_count());\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::Visitable>::visit_map":["fn visit_map(&self) -> FixedBitSet{\n        FixedBitSet::with_capacity(self.node_count())\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graph_impl::Neighbors<'a, E, Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n            $name {\n                $(\n                    $field : self . $field .clone()\n                ),*\n            }\n        }","Real(LocalPath(\"src/macros.rs\"))"],"<graph_impl::Neighbors<'a, E, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<NodeIndex<Ix>>{\n        // First any outgoing edges\n        match self.edges.get(self.next[0].index()) {\n            None => {}\n            Some(edge) => {\n                self.next[0] = edge.next[0];\n                return Some(edge.node[1]);\n            }\n        }\n        // Then incoming edges\n        // For an \"undirected\" iterator (traverse both incoming\n        // and outgoing edge lists), make sure we don't double\n        // count selfloops by skipping them in the incoming list.\n        while let Some(edge) = self.edges.get(self.next[1].index()) {\n            self.next[1] = edge.next[1];\n            if edge.node[0] != self.skip_start {\n                return Some(edge.node[0]);\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::Node<E, Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n            $name {\n                $(\n                    $field : self . $field .clone()\n                ),*\n            }\n        }","Real(LocalPath(\"src/macros.rs\"))"],"<graph_impl::NodeIndex<Ix> as graph_impl::GraphIndex>::index":["#[inline]\nfn index(&self) -> usize{\n        NodeIndex::index(*self)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::NodeIndex<Ix> as graph_impl::GraphIndex>::is_node_index":["#[inline]\nfn is_node_index() -> bool{\n        true\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::NodeIndex<Ix> as std::convert::From<Ix>>::from":["fn from(ix: Ix) -> Self{\n        NodeIndex(ix)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::NodeIndex<Ix> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"NodeIndex({:?})\", self.0)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::NodeIndices<Ix> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.r.next_back().map(node_index)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::NodeIndices<Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.r.next().map(node_index)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::NodeIndices<Ix> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.r.size_hint()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::NodeReferences<'a, N, Ix> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.iter\n            .next_back()\n            .map(|(i, node)| (node_index(i), &node.weight))\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::NodeReferences<'a, N, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter\n            .next()\n            .map(|(i, node)| (node_index(i), &node.weight))\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::NodeReferences<'a, N, Ix> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::NodeWeightsMut<'a, N, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a mut N>{\n        self.nodes.next().map(|node| &mut node.weight)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::NodeWeightsMut<'a, N, Ix> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.nodes.size_hint()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::WalkNeighbors<Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        WalkNeighbors {\n            skip_start: self.skip_start,\n            next: self.next,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<graph_impl::stable_graph::EdgeIndices<'a, E, Ix> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.iter.ex_rfind_map(|(i, node)| {\n            if node.weight.is_some() {\n                Some(edge_index(i))\n            } else {\n                None\n            }\n        })\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::EdgeIndices<'a, E, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.ex_find_map(|(i, node)| {\n            if node.weight.is_some() {\n                Some(edge_index(i))\n            } else {\n                None\n            }\n        })\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::EdgeIndices<'a, E, Ix> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        *self\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as std::cmp::PartialEq>::eq":["fn eq(&self, rhs: &Self) -> bool{\n        self.index == rhs.index && self.weight == rhs.weight\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::id":["fn id(&self) -> Self::EdgeId{\n        self.index\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::source":["fn source(&self) -> Self::NodeId{\n        self.node[0]\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::target":["fn target(&self) -> Self::NodeId{\n        self.node[1]\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::weight":["fn weight(&self) -> &E{\n        self.weight\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::EdgeReferences<'a, E, Ix> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.iter.ex_rfind_map(|(i, edge)| {\n            edge.weight.as_ref().map(move |weight| EdgeReference {\n                index: edge_index(i),\n                node: edge.node,\n                weight,\n            })\n        })\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::EdgeReferences<'a, E, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.ex_find_map(|(i, edge)| {\n            edge.weight.as_ref().map(move |weight| EdgeReference {\n                index: edge_index(i),\n                node: edge.node,\n                weight,\n            })\n        })\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        //      type        direction    |    iterate over    reverse\n        //                               |\n        //    Directed      Outgoing     |      outgoing        no\n        //    Directed      Incoming     |      incoming        no\n        //   Undirected     Outgoing     |        both       incoming\n        //   Undirected     Incoming     |        both       outgoing\n\n        // For iterate_over, \"both\" is represented as None.\n        // For reverse, \"no\" is represented as None.\n        let (iterate_over, reverse) = if Ty::is_directed() {\n            (Some(self.direction), None)\n        } else {\n            (None, Some(self.direction.opposite()))\n        };\n\n        if iterate_over.unwrap_or(Outgoing) == Outgoing {\n            let i = self.next[0].index();\n            if let Some(Edge {\n                node,\n                weight: Some(weight),\n                next,\n            }) = self.edges.get(i)\n            {\n                self.next[0] = next[0];\n                return Some(EdgeReference {\n                    index: edge_index(i),\n                    node: if reverse == Some(Outgoing) {\n                        swap_pair(*node)\n                    } else {\n                        *node\n                    },\n                    weight,\n                });\n            }\n        }\n\n        if iterate_over.unwrap_or(Incoming) == Incoming {\n            while let Some(Edge { node, weight, next }) = self.edges.get(self.next[1].index()) {\n                debug_assert!(weight.is_some());\n                let edge_index = self.next[1];\n                self.next[1] = next[1];\n                // In any of the \"both\" situations, self-loops would be iterated over twice.\n                // Skip them here.\n                if iterate_over.is_none() && node[0] == self.skip_start {\n                    continue;\n                }\n\n                return Some(EdgeReference {\n                    index: edge_index,\n                    node: if reverse == Some(Incoming) {\n                        swap_pair(*node)\n                    } else {\n                        *node\n                    },\n                    weight: weight.as_ref().unwrap(),\n                });\n            }\n        }\n\n        None\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::Externals<'a, N, Ty, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<NodeIndex<Ix>>{\n        let k = self.dir.index();\n        loop {\n            match self.iter.next() {\n                None => return None,\n                Some((index, node)) => {\n                    if node.weight.is_some()\n                        && node.next[k] == EdgeIndex::end()\n                        && (Ty::is_directed() || node.next[1 - k] == EdgeIndex::end())\n                    {\n                        return Some(NodeIndex::new(index));\n                    } else {\n                        continue;\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::Neighbors<'a, E, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<NodeIndex<Ix>>{\n        // First any outgoing edges\n        match self.edges.get(self.next[0].index()) {\n            None => {}\n            Some(edge) => {\n                debug_assert!(edge.weight.is_some());\n                self.next[0] = edge.next[0];\n                return Some(edge.node[1]);\n            }\n        }\n        // Then incoming edges\n        // For an \"undirected\" iterator (traverse both incoming\n        // and outgoing edge lists), make sure we don't double\n        // count selfloops by skipping them in the incoming list.\n        while let Some(edge) = self.edges.get(self.next[1].index()) {\n            debug_assert!(edge.weight.is_some());\n            self.next[1] = edge.next[1];\n            if edge.node[0] != self.skip_start {\n                return Some(edge.node[0]);\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::NodeIndices<'a, N, Ix> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.iter.ex_rfind_map(|(i, node)| {\n            if node.weight.is_some() {\n                Some(node_index(i))\n            } else {\n                None\n            }\n        })\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::NodeIndices<'a, N, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.ex_find_map(|(i, node)| {\n            if node.weight.is_some() {\n                Some(node_index(i))\n            } else {\n                None\n            }\n        })\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::NodeIndices<'a, N, Ix> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::NodeReferences<'a, N, Ix> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.iter\n            .ex_rfind_map(|(i, node)| node.weight.as_ref().map(move |w| (node_index(i), w)))\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::NodeReferences<'a, N, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter\n            .ex_find_map(|(i, node)| node.weight.as_ref().map(move |w| (node_index(i), w)))\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::NodeReferences<'a, N, Ix> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let (_, hi) = self.iter.size_hint();\n        (0, hi)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Build>::add_edge":["fn add_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Option<Self::EdgeId>{\n        Some(self.add_edge(a, b, weight))\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Build>::add_node":["fn add_node(&mut self, weight: Self::NodeWeight) -> Self::NodeId{\n        self.add_node(weight)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Build>::update_edge":["fn update_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Self::EdgeId{\n        self.update_edge(a, b, weight)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Create>::with_capacity":["fn with_capacity(nodes: usize, edges: usize) -> Self{\n        Self::with_capacity(nodes, edges)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMap>::edge_weight":["fn edge_weight(&self, id: Self::EdgeId) -> Option<&Self::EdgeWeight>{\n        self.edge_weight(id)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMap>::node_weight":["fn node_weight(&self, id: Self::NodeId) -> Option<&Self::NodeWeight>{\n        self.node_weight(id)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMapMut>::edge_weight_mut":["fn edge_weight_mut(&mut self, id: Self::EdgeId) -> Option<&mut Self::EdgeWeight>{\n        self.edge_weight_mut(id)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMapMut>::node_weight_mut":["fn node_weight_mut(&mut self, id: Self::NodeId) -> Option<&mut Self::NodeWeight>{\n        self.node_weight_mut(id)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::FromElements>::from_elements":["fn from_elements<I>(iterable: I) -> Self\n    where\n        Self: Sized,\n        I: IntoIterator<Item = Element<Self::NodeWeight, Self::EdgeWeight>>,{\n        from_elements_indexable(iterable)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        StableGraph {\n            g: self.g.clone(),\n            node_count: self.node_count,\n            edge_count: self.edge_count,\n            free_node: self.free_node,\n            free_edge: self.free_edge,\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::clone::Clone>::clone_from":["fn clone_from(&mut self, rhs: &Self){\n        self.g.clone_from(&rhs.g);\n        self.node_count = rhs.node_count;\n        self.edge_count = rhs.edge_count;\n        self.free_node = rhs.free_node;\n        self.free_edge = rhs.free_edge;\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::convert::From<graph_impl::Graph<N, E, Ty, Ix>>>::from":["fn from(g: Graph<N, E, Ty, Ix>) -> Self{\n        let nodes = g.nodes.into_iter().map(|e| Node {\n            weight: Some(e.weight),\n            next: e.next,\n        });\n        let edges = g.edges.into_iter().map(|e| Edge {\n            weight: Some(e.weight),\n            node: e.node,\n            next: e.next,\n        });\n        StableGraph {\n            node_count: nodes.len(),\n            edge_count: edges.len(),\n            g: Graph {\n                edges: edges.collect(),\n                nodes: nodes.collect(),\n                ty: g.ty,\n            },\n            free_node: NodeIndex::end(),\n            free_edge: EdgeIndex::end(),\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::default::Default>::default":["fn default() -> Self{\n        Self::with_capacity(0, 0)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let etype = if self.is_directed() {\n            \"Directed\"\n        } else {\n            \"Undirected\"\n        };\n        let mut fmt_struct = f.debug_struct(\"StableGraph\");\n        fmt_struct.field(\"Ty\", &etype);\n        fmt_struct.field(\"node_count\", &self.node_count);\n        fmt_struct.field(\"edge_count\", &self.edge_count);\n        if self.g.edges.iter().any(|e| e.weight.is_some()) {\n            fmt_struct.field(\n                \"edges\",\n                &self\n                    .g\n                    .edges\n                    .iter()\n                    .filter(|e| e.weight.is_some())\n                    .map(|e| NoPretty((e.source().index(), e.target().index())))\n                    .format(\", \"),\n            );\n        }\n        // skip weights if they are ZST!\n        if size_of::<N>() != 0 {\n            fmt_struct.field(\n                \"node weights\",\n                &DebugMap(|| {\n                    self.g\n                        .nodes\n                        .iter()\n                        .map(|n| n.weight.as_ref())\n                        .enumerate()\n                        .filter_map(|(i, wo)| wo.map(move |w| (i, w)))\n                }),\n            );\n        }\n        if size_of::<E>() != 0 {\n            fmt_struct.field(\n                \"edge weights\",\n                &DebugMap(|| {\n                    self.g\n                        .edges\n                        .iter()\n                        .map(|n| n.weight.as_ref())\n                        .enumerate()\n                        .filter_map(|(i, wo)| wo.map(move |w| (i, w)))\n                }),\n            );\n        }\n        fmt_struct.field(\"free_node\", &self.free_node);\n        fmt_struct.field(\"free_edge\", &self.free_edge);\n        fmt_struct.finish()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::Index<graph_impl::EdgeIndex<Ix>>>::index":["fn index(&self, index: EdgeIndex<Ix>) -> &E{\n        self.edge_weight(index).unwrap()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::Index<graph_impl::NodeIndex<Ix>>>::index":["fn index(&self, index: NodeIndex<Ix>) -> &N{\n        self.node_weight(index).unwrap()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::EdgeIndex<Ix>>>::index_mut":["fn index_mut(&mut self, index: EdgeIndex<Ix>) -> &mut E{\n        self.edge_weight_mut(index).unwrap()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::NodeIndex<Ix>>>::index_mut":["fn index_mut(&mut self, index: NodeIndex<Ix>) -> &mut N{\n        self.node_weight_mut(index).unwrap()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeCount>::node_count":["fn node_count(&self) -> usize{\n        self.node_count()\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeIndexable>::from_index":["fn from_index(&self, ix: usize) -> Self::NodeId{\n        NodeIndex::new(ix)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeIndexable>::node_bound":["/// Return an upper bound of the node indices in the graph\nfn node_bound(&self) -> usize{\n        self.node_indices().next_back().map_or(0, |i| i.index() + 1)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeIndexable>::to_index":["fn to_index(&self, ix: NodeIndex<Ix>) -> usize{\n        ix.index()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::Visitable>::reset_map":["fn reset_map(&self, map: &mut Self::Map){\n        map.clear();\n        map.grow(self.node_bound());\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::Visitable>::visit_map":["fn visit_map(&self) -> FixedBitSet{\n        FixedBitSet::with_capacity(self.node_bound())\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graph_impl::stable_graph::WalkNeighbors<Ix> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n            $name {\n                $(\n                    $field : self . $field .clone()\n                ),*\n            }\n        }","Real(LocalPath(\"src/macros.rs\"))"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.inner\n            .next_back()\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::count":["fn count(self) -> usize{\n        self.inner.count()\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::last":["fn last(self) -> Option<Self::Item>{\n        self.inner\n            .last()\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        match self.inner.next() {\n            None => None,\n            Some((&(a, b), v)) => Some((a, b, v)),\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::nth":["fn nth(&mut self, n: usize) -> Option<Self::Item>{\n        self.inner\n            .nth(n)\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.inner\n            .next_back()\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::count":["fn count(self) -> usize{\n        self.inner.count()\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::last":["fn last(self) -> Option<Self::Item>{\n        self.inner\n            .last()\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.inner\n            .next()\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::nth":["fn nth(&mut self, n: usize) -> Option<Self::Item>{\n        self.inner\n            .nth(n)\n            .map(|(&(n1, n2), weight)| (n1, n2, weight))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::CompactDirection as std::cmp::PartialEq<Direction>>::eq":["fn eq(&self, rhs: &Direction) -> bool{\n        (*self as usize) == (*rhs as usize)\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::CompactDirection as std::convert::From<Direction>>::from":["fn from(d: Direction) -> Self{\n        match d {\n            Outgoing => CompactDirection::Outgoing,\n            Incoming => CompactDirection::Incoming,\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::Edges<'a, N, E, Ty> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        match self.iter.next() {\n            None => None,\n            Some(b) => {\n                let a = self.from;\n                match self.edges.get(&GraphMap::<N, E, Ty>::edge_key(a, b)) {\n                    None => unreachable!(),\n                    Some(edge) => Some((a, b, edge)),\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as data::Build>::add_edge":["fn add_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Option<Self::EdgeId>{\n        if self.contains_edge(a, b) {\n            None\n        } else {\n            let r = self.add_edge(a, b, weight);\n            debug_assert!(r.is_none());\n            Some((a, b))\n        }\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as data::Build>::add_node":["fn add_node(&mut self, weight: Self::NodeWeight) -> Self::NodeId{\n        self.add_node(weight)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as data::Build>::update_edge":["fn update_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Self::EdgeId{\n        self.add_edge(a, b, weight);\n        (a, b)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as data::Create>::with_capacity":["fn with_capacity(nodes: usize, edges: usize) -> Self{\n        Self::with_capacity(nodes, edges)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as data::FromElements>::from_elements":["fn from_elements<I>(iterable: I) -> Self\n    where\n        Self: Sized,\n        I: IntoIterator<Item = Element<Self::NodeWeight, Self::EdgeWeight>>,{\n        from_elements_indexable(iterable)\n    }","Real(LocalPath(\"src/data.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as std::default::Default>::default":["fn default() -> Self{\n        GraphMap::with_capacity(0, 0)\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.nodes.fmt(f)\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as std::iter::Extend<Item>>::extend":["fn extend<I>(&mut self, iterable: I)\n    where\n        I: IntoIterator<Item = Item>,{\n        let iter = iterable.into_iter();\n        let (low, _) = iter.size_hint();\n        self.edges.reserve(low);\n\n        for elt in iter {\n            let (source, target, weight) = elt.into_weighted_edge();\n            self.add_edge(source, target, weight);\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as std::iter::FromIterator<Item>>::from_iter":["fn from_iter<I>(iterable: I) -> Self\n    where\n        I: IntoIterator<Item = Item>,{\n        let iter = iterable.into_iter();\n        let (low, _) = iter.size_hint();\n        let mut g = Self::with_capacity(0, low);\n        g.extend(iter);\n        g\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as std::ops::Index<(N, N)>>::index":["fn index(&self, index: (N, N)) -> &E{\n        let index = Self::edge_key(index.0, index.1);\n        self.edge_weight(index.0, index.1)\n            .expect(\"GraphMap::index: no such edge\")\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as std::ops::IndexMut<(N, N)>>::index_mut":["fn index_mut(&mut self, index: (N, N)) -> &mut E{\n        let index = Self::edge_key(index.0, index.1);\n        self.edge_weight_mut(index.0, index.1)\n            .expect(\"GraphMap::index: no such edge\")\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as visit::GetAdjacencyMatrix>::adjacency_matrix":["#[inline]\nfn adjacency_matrix(&self){}","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as visit::GetAdjacencyMatrix>::is_adjacent":["#[inline]\nfn is_adjacent(&self, _: &(), a: N, b: N) -> bool{\n        self.contains_edge(a, b)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeCount>::node_count":["fn node_count(&self) -> usize{\n        (*self).node_count()\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeIndexable>::from_index":["fn from_index(&self, ix: usize) -> Self::NodeId{\n        let (&key, _) = self.nodes.get_index(ix).unwrap();\n        key\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeIndexable>::node_bound":["fn node_bound(&self) -> usize{\n        self.node_count()\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeIndexable>::to_index":["fn to_index(&self, ix: Self::NodeId) -> usize{\n        let (i, _, _) = self.nodes.get_full(&ix).unwrap();\n        i\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as visit::Visitable>::reset_map":["fn reset_map(&self, map: &mut Self::Map){\n        map.clear();\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graphmap::GraphMap<N, E, Ty> as visit::Visitable>::visit_map":["fn visit_map(&self) -> HashSet<N>{\n        HashSet::with_capacity(self.node_count())\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<graphmap::Neighbors<'a, N, Ty> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<N>{\n        if Ty::is_directed() {\n            (&mut self.iter)\n                .filter_map(|&(n, dir)| if dir == Outgoing { Some(n) } else { None })\n                .next()\n        } else {\n            self.iter.next().map(|&(n, _)| n)\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::NeighborsDirected<'a, N, Ty> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<N>{\n        if Ty::is_directed() {\n            let self_dir = self.dir;\n            let start_node = self.start_node;\n            (&mut self.iter)\n                .filter_map(move |&(n, dir)| {\n                    if dir == self_dir || n == start_node {\n                        Some(n)\n                    } else {\n                        None\n                    }\n                })\n                .next()\n        } else {\n            self.iter.next().map(|&(n, _)| n)\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::NodeIdentifiers<'a, N, E, Ty> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().map(|(&n, _)| n)\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::NodeReferences<'a, N, E, Ty> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().map(|(n, _)| (*n, n))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::Nodes<'a, N> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::Nodes<'a, N> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::Ptr<'b, T> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        *self\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::Ptr<'b, T> as std::cmp::Ord>::cmp":["/// Ptr is ordered by pointer value, i.e. an arbitrary but stable and total order.\nfn cmp(&self, other: &Ptr<'b, T>) -> Ordering{\n        let a: *const T = self.0;\n        let b: *const T = other.0;\n        a.cmp(&b)\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::Ptr<'b, T> as std::cmp::PartialEq>::eq":["/// Ptr compares by pointer equality, i.e if they point to the same value\nfn eq(&self, other: &Ptr<'b, T>) -> bool{\n        ptr_eq(self.0, other.0)\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::Ptr<'b, T> as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Ptr<'b, T>) -> Option<Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::Ptr<'b, T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::Ptr<'b, T> as std::hash::Hash>::hash":["fn hash<H: hash::Hasher>(&self, st: &mut H){\n        let ptr = (self.0) as *const T;\n        ptr.hash(st)\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<graphmap::Ptr<'b, T> as std::ops::Deref>::deref":["fn deref(&self) -> &T{\n        self.0\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"<i16 as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<i16 as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<i32 as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<i32 as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<i64 as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<i64 as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<i8 as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<i8 as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<isize as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<isize as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<isomorphism::NoSemanticMatch as isomorphism::SemanticMatcher<T>>::enabled":["#[inline]\nfn enabled() -> bool{\n        false\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"<isomorphism::NoSemanticMatch as isomorphism::SemanticMatcher<T>>::eq":["#[inline]\nfn eq(&mut self, _: &T, _: &T) -> bool{\n        true\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"<iter_format::DebugMap<F> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_map().entries((self.0)()).finish()\n    }","Real(LocalPath(\"src/iter_format.rs\"))"],"<iter_format::Format<'a, I> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n                    self.format(f, fmt::$fmt_trait::fmt)\n                }","Real(LocalPath(\"src/iter_format.rs\"))"],"<iter_format::NoPretty<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"{:?}\", self.0)\n    }","Real(LocalPath(\"src/iter_format.rs\"))"],"<matrix_graph::EdgeReferences<'a, Ty, Null, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        loop {\n            let (row, column) = (self.row, self.column);\n            if row >= self.node_capacity {\n                return None;\n            }\n\n            // By default, advance the column. Reset and advance the row if the column overflows.\n            //\n            // Note that for undirected graphs, we don't want to yield the same edge twice,\n            // therefore the maximum column length should be the index new after the row index.\n            self.column += 1;\n            let max_column_len = if !Ty::is_directed() {\n                row + 1\n            } else {\n                self.node_capacity\n            };\n            if self.column >= max_column_len {\n                self.column = 0;\n                self.row += 1;\n            }\n\n            let p = to_linearized_matrix_position::<Ty>(row, column, self.node_capacity);\n            if let Some(e) = self.node_adjacencies[p].as_ref() {\n                return Some((NodeIndex::new(row), NodeIndex::new(column), e));\n            }\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::Edges<'a, Ty, Null, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        use self::NeighborIterDirection::*;\n\n        loop {\n            let (row, column) = (self.row, self.column);\n            if row >= self.node_capacity || column >= self.node_capacity {\n                return None;\n            }\n\n            match self.iter_direction {\n                Rows => self.row += 1,\n                Columns => self.column += 1,\n            }\n\n            let p = to_linearized_matrix_position::<Ty>(row, column, self.node_capacity);\n            if let Some(e) = self.node_adjacencies[p].as_ref() {\n                let (a, b) = match self.iter_direction {\n                    Rows => (column, row),\n                    Columns => (row, column),\n                };\n\n                return Some((NodeIndex::new(a), NodeIndex::new(b), e));\n            }\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::IdIterator<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        // initialize / advance\n        let current = {\n            if self.current.is_none() {\n                self.current = Some(0);\n                self.current.as_mut().unwrap()\n            } else {\n                let current = self.current.as_mut().unwrap();\n                *current += 1;\n                current\n            }\n        };\n\n        // skip removed ids\n        while self.removed_ids.contains(current) && *current < self.upper_bound {\n            *current += 1;\n        }\n\n        if *current < self.upper_bound {\n            Some(*current)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::IdStorage<T> as std::ops::Index<usize>>::index":["fn index(&self, index: usize) -> &T{\n        self.elements[index].as_ref().unwrap()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::IdStorage<T> as std::ops::IndexMut<usize>>::index_mut":["fn index_mut(&mut self, index: usize) -> &mut T{\n        self.elements[index].as_mut().unwrap()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as data::Build>::add_edge":["fn add_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Option<Self::EdgeId>{\n        if !self.has_edge(a, b) {\n            MatrixGraph::update_edge(self, a, b, weight);\n            Some((a, b))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as data::Build>::add_node":["fn add_node(&mut self, weight: Self::NodeWeight) -> Self::NodeId{\n        self.add_node(weight)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as data::Build>::update_edge":["fn update_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Self::EdgeId{\n        MatrixGraph::update_edge(self, a, b, weight);\n        (a, b)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::default::Default>::default":["fn default() -> Self{\n        Self::with_capacity(0)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::Index<(graph_impl::NodeIndex<Ix>, graph_impl::NodeIndex<Ix>)>>::index":["fn index(&self, (ax, bx): (NodeIndex<Ix>, NodeIndex<Ix>)) -> &E{\n        self.edge_weight(ax, bx)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::Index<graph_impl::NodeIndex<Ix>>>::index":["fn index(&self, ax: NodeIndex<Ix>) -> &N{\n        self.node_weight(ax)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::IndexMut<(graph_impl::NodeIndex<Ix>, graph_impl::NodeIndex<Ix>)>>::index_mut":["fn index_mut(&mut self, (ax, bx): (NodeIndex<Ix>, NodeIndex<Ix>)) -> &mut E{\n        self.edge_weight_mut(ax, bx)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::IndexMut<graph_impl::NodeIndex<Ix>>>::index_mut":["fn index_mut(&mut self, ax: NodeIndex<Ix>) -> &mut N{\n        self.node_weight_mut(ax)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::GetAdjacencyMatrix>::adjacency_matrix":["fn adjacency_matrix(&self) -> Self::AdjMatrix{}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::GetAdjacencyMatrix>::is_adjacent":["fn is_adjacent(&self, _: &Self::AdjMatrix, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool{\n        MatrixGraph::has_edge(self, a, b)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeCount>::node_count":["fn node_count(&self) -> usize{\n        MatrixGraph::node_count(self)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeIndexable>::from_index":["fn from_index(&self, ix: usize) -> Self::NodeId{\n        NodeIndex::new(ix)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeIndexable>::node_bound":["fn node_bound(&self) -> usize{\n        self.node_count()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeIndexable>::to_index":["fn to_index(&self, ix: NodeIndex<Ix>) -> usize{\n        ix.index()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::Visitable>::reset_map":["fn reset_map(&self, map: &mut Self::Map){\n        map.clear();\n        map.grow(self.node_count());\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::Visitable>::visit_map":["fn visit_map(&self) -> FixedBitSet{\n        FixedBitSet::with_capacity(self.node_count())\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::Neighbors<'a, Ty, Null, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.0.next().map(|(_, b, _)| b)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::NodeIdentifiers<'a, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().map(NodeIndex::new)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::NodeReferences<'a, N, Ix> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter\n            .next()\n            .map(|i| (NodeIndex::new(i), &self.nodes[i]))\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::as_mut":["fn as_mut(&mut self) -> Option<&mut Self::Wrapped>{\n        if !self.is_null() {\n            Some(&mut self.0)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::as_ref":["fn as_ref(&self) -> Option<&Self::Wrapped>{\n        if !self.is_null() {\n            Some(&self.0)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::is_null":["fn is_null(&self) -> bool{\n        self.0.is_zero()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::new":["fn new(value: T) -> Self{\n        assert!(!value.is_zero());\n        NotZero(value)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::NotZero<T> as std::convert::Into<std::option::Option<T>>>::into":["fn into(self) -> Option<T>{\n        if !self.is_null() {\n            Some(self.0)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<matrix_graph::NotZero<T> as std::default::Default>::default":["fn default() -> Self{\n        NotZero(T::zero())\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<scored::MinScored<K, T> as std::cmp::Ord>::cmp":["#[inline]\nfn cmp(&self, other: &MinScored<K, T>) -> Ordering{\n        let a = &self.0;\n        let b = &other.0;\n        if a == b {\n            Ordering::Equal\n        } else if a < b {\n            Ordering::Greater\n        } else if a > b {\n            Ordering::Less\n        } else if a.ne(a) && b.ne(b) {\n            // these are the NaN cases\n            Ordering::Equal\n        } else if a.ne(a) {\n            // Order NaN less, so that it is last in the MinScore order\n            Ordering::Less\n        } else {\n            Ordering::Greater\n        }\n    }","Real(LocalPath(\"src/scored.rs\"))"],"<scored::MinScored<K, T> as std::cmp::PartialEq>::eq":["#[inline]\nfn eq(&self, other: &MinScored<K, T>) -> bool{\n        self.cmp(other) == Ordering::Equal\n    }","Real(LocalPath(\"src/scored.rs\"))"],"<scored::MinScored<K, T> as std::cmp::PartialOrd>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &MinScored<K, T>) -> Option<Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"src/scored.rs\"))"],"<std::collections::HashSet<N, S> as visit::VisitMap<N>>::is_visited":["fn is_visited(&self, x: &N) -> bool{\n        self.contains(x)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<std::collections::HashSet<N, S> as visit::VisitMap<N>>::visit":["fn visit(&mut self, x: N) -> bool{\n        self.insert(x)\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"<std::collections::HashSet<N, S> as visit::filter::FilterNode<N>>::include_node":["fn include_node(&self, n: N) -> bool{\n        self.is_visited(&n)\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<std::option::Option<T> as matrix_graph::Nullable>::as_mut":["fn as_mut(&mut self) -> Option<&mut Self::Wrapped>{\n        self.as_mut()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<std::option::Option<T> as matrix_graph::Nullable>::as_ref":["fn as_ref(&self) -> Option<&Self::Wrapped>{\n        self.as_ref()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<std::option::Option<T> as matrix_graph::Nullable>::new":["fn new(value: T) -> Self{\n        Some(value)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<std::result::Result<C, E> as visit::dfsvisit::ControlFlow>::continuing":["fn continuing() -> Self{\n        Ok(C::continuing())\n    }","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"<std::result::Result<C, E> as visit::dfsvisit::ControlFlow>::should_break":["fn should_break(&self) -> bool{\n        if let Ok(ref c) = *self {\n            c.should_break()\n        } else {\n            true\n        }\n    }","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"<std::result::Result<C, E> as visit::dfsvisit::ControlFlow>::should_prune":["fn should_prune(&self) -> bool{\n        if let Ok(ref c) = *self {\n            c.should_prune()\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"<u16 as graph_impl::IndexType>::index":["#[inline(always)]\nfn index(&self) -> usize{\n        *self as usize\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<u16 as graph_impl::IndexType>::max":["#[inline(always)]\nfn max() -> Self{\n        ::std::u16::MAX\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<u16 as graph_impl::IndexType>::new":["#[inline(always)]\nfn new(x: usize) -> Self{\n        x as u16\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<u16 as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<u16 as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<u32 as graph_impl::IndexType>::index":["#[inline(always)]\nfn index(&self) -> usize{\n        *self as usize\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<u32 as graph_impl::IndexType>::max":["#[inline(always)]\nfn max() -> Self{\n        ::std::u32::MAX\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<u32 as graph_impl::IndexType>::new":["#[inline(always)]\nfn new(x: usize) -> Self{\n        x as u32\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<u32 as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<u32 as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<u64 as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<u64 as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<u8 as graph_impl::IndexType>::index":["#[inline(always)]\nfn index(&self) -> usize{\n        *self as usize\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<u8 as graph_impl::IndexType>::max":["#[inline(always)]\nfn max() -> Self{\n        ::std::u8::MAX\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<u8 as graph_impl::IndexType>::new":["#[inline(always)]\nfn new(x: usize) -> Self{\n        x as u8\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<u8 as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<u8 as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<usize as graph_impl::IndexType>::index":["#[inline(always)]\nfn index(&self) -> Self{\n        *self\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<usize as graph_impl::IndexType>::max":["#[inline(always)]\nfn max() -> Self{\n        ::std::usize::MAX\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<usize as graph_impl::IndexType>::new":["#[inline(always)]\nfn new(x: usize) -> Self{\n        x\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"<usize as matrix_graph::Zero>::is_zero":["fn is_zero(&self) -> bool{\n                self == &Self::zero()\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<usize as matrix_graph::Zero>::zero":["fn zero() -> Self{\n                $z as $t\n            }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"<visit::dfsvisit::Control<B> as std::default::Default>::default":["fn default() -> Self{\n        Control::Continue\n    }","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"<visit::dfsvisit::Control<B> as visit::dfsvisit::ControlFlow>::continuing":["fn continuing() -> Self{\n        Control::Continue\n    }","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"<visit::dfsvisit::Control<B> as visit::dfsvisit::ControlFlow>::should_break":["fn should_break(&self) -> bool{\n        if let Control::Break(_) = *self {\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"<visit::dfsvisit::Control<B> as visit::dfsvisit::ControlFlow>::should_prune":["fn should_prune(&self) -> bool{\n        match *self {\n            Control::Prune => true,\n            Control::Continue | Control::Break(_) => false,\n        }\n    }","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeCount>::node_count":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeIndexable>::from_index":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeIndexable>::node_bound":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeIndexable>::to_index":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::filter::EdgeFiltered<G, F> as visit::Visitable>::reset_map":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*){\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::filter::EdgeFiltered<G, F> as visit::Visitable>::visit_map":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::filter::EdgeFilteredEdges<'a, G, I, F> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let f = self.f;\n        self.iter.find(move |&edge| f.include_edge(edge))\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<visit::filter::EdgeFilteredNeighbors<'a, G, F> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let f = self.f;\n        (&mut self.iter)\n            .filter_map(move |edge| {\n                if f.include_edge(edge) {\n                    Some(edge.target())\n                } else {\n                    None\n                }\n            })\n            .next()\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<visit::filter::EdgeFilteredNeighborsDirected<'a, G, F> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let f = self.f;\n        let from = self.from;\n        (&mut self.iter)\n            .filter_map(move |edge| {\n                if f.include_edge(edge) {\n                    if edge.source() != from {\n                        Some(edge.source())\n                    } else {\n                        Some(edge.target()) // includes case where from == source == target\n                    }\n                } else {\n                    None\n                }\n            })\n            .next()\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<visit::filter::NodeFiltered<G, F> as data::DataMap>::edge_weight":["fn edge_weight(&self, id: Self::EdgeId) -> Option<&Self::EdgeWeight>{\n        self.0.edge_weight(id)\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<visit::filter::NodeFiltered<G, F> as data::DataMap>::node_weight":["fn node_weight(&self, id: Self::NodeId) -> Option<&Self::NodeWeight>{\n        if self.1.include_node(id) {\n            self.0.node_weight(id)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<visit::filter::NodeFiltered<G, F> as visit::NodeIndexable>::from_index":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::filter::NodeFiltered<G, F> as visit::NodeIndexable>::node_bound":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::filter::NodeFiltered<G, F> as visit::NodeIndexable>::to_index":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::filter::NodeFiltered<G, F> as visit::Visitable>::reset_map":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*){\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::filter::NodeFiltered<G, F> as visit::Visitable>::visit_map":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::filter::NodeFilteredEdgeReferences<'a, G, I, F> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let f = self.f;\n        self.iter\n            .find(move |&edge| f.include_node(edge.source()) && f.include_node(edge.target()))\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<visit::filter::NodeFilteredEdges<'a, G, I, F> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        if !self.include_source {\n            None\n        } else {\n            let f = self.f;\n            self.iter.find(move |&edge| f.include_node(edge.target()))\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<visit::filter::NodeFilteredNeighbors<'a, I, F> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let f = self.f;\n        if !self.include_source {\n            None\n        } else {\n            self.iter.find(move |&target| f.include_node(target))\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<visit::filter::NodeFilteredNodes<'a, I, F> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let f = self.f;\n        if !self.include_source {\n            None\n        } else {\n            self.iter.find(move |&target| f.include_node(target.id()))\n        }\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"<visit::reversed::Reversed<G> as data::DataMap>::edge_weight":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::reversed::Reversed<G> as data::DataMap>::node_weight":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::reversed::Reversed<G> as data::DataMapMut>::edge_weight_mut":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::reversed::Reversed<G> as data::DataMapMut>::node_weight_mut":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::reversed::Reversed<G> as visit::IntoEdgeReferences>::edge_references":["fn edge_references(self) -> Self::EdgeReferences{\n        ReversedEdgeReferences {\n            iter: self.0.edge_references(),\n        }\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::Reversed<G> as visit::IntoEdges>::edges":["fn edges(self, a: Self::NodeId) -> Self::Edges{\n        ReversedEdges {\n            iter: self.0.edges_directed(a, Incoming),\n        }\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::Reversed<G> as visit::IntoEdgesDirected>::edges_directed":["fn edges_directed(self, a: Self::NodeId, dir: Direction) -> Self::Edges{\n        ReversedEdges {\n            iter: self.0.edges_directed(a, dir.opposite()),\n        }\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::Reversed<G> as visit::IntoNeighbors>::neighbors":["fn neighbors(self, n: G::NodeId) -> G::NeighborsDirected{\n        self.0.neighbors_directed(n, Incoming)\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::Reversed<G> as visit::IntoNeighborsDirected>::neighbors_directed":["fn neighbors_directed(self, n: G::NodeId, d: Direction) -> G::NeighborsDirected{\n        self.0.neighbors_directed(n, d.opposite())\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::Reversed<G> as visit::IntoNodeIdentifiers>::node_identifiers":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::reversed::Reversed<G> as visit::IntoNodeReferences>::node_references":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::reversed::Reversed<G> as visit::NodeCount>::node_count":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::reversed::Reversed<G> as visit::NodeIndexable>::from_index":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::reversed::Reversed<G> as visit::NodeIndexable>::node_bound":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::reversed::Reversed<G> as visit::NodeIndexable>::to_index":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"<visit::reversed::Reversed<G> as visit::Visitable>::reset_map":["fn reset_map(&self, map: &mut Self::Map){\n        self.0.reset_map(map);\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::Reversed<G> as visit::Visitable>::visit_map":["fn visit_map(&self) -> G::Map{\n        self.0.visit_map()\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::id":["fn id(&self) -> Self::EdgeId{\n        self.0.id()\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::source":["fn source(&self) -> Self::NodeId{\n        self.0.target()\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::target":["fn target(&self) -> Self::NodeId{\n        self.0.source()\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::weight":["fn weight(&self) -> &Self::Weight{\n        self.0.weight()\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::ReversedEdgeReferences<I> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().map(ReversedEdgeReference)\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::reversed::ReversedEdges<I> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next().map(ReversedEdgeReference)\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"<visit::traversal::Bfs<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["fn walk_next(&mut self, context: G) -> Option<Self::Item>{\n        self.next(context)\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"<visit::traversal::Bfs<N, VM> as std::default::Default>::default":["fn default() -> Self{\n        Bfs {\n            stack: VecDeque::new(),\n            discovered: VM::default(),\n        }\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"<visit::traversal::Dfs<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["fn walk_next(&mut self, context: G) -> Option<Self::Item>{\n        self.next(context)\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"<visit::traversal::Dfs<N, VM> as std::default::Default>::default":["fn default() -> Self{\n        Dfs {\n            stack: Vec::new(),\n            discovered: VM::default(),\n        }\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"<visit::traversal::DfsPostOrder<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["fn walk_next(&mut self, context: G) -> Option<Self::Item>{\n        self.next(context)\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"<visit::traversal::DfsPostOrder<N, VM> as std::default::Default>::default":["fn default() -> Self{\n        DfsPostOrder {\n            stack: Vec::new(),\n            discovered: VM::default(),\n            finished: VM::default(),\n        }\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"<visit::traversal::Topo<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["fn walk_next(&mut self, context: G) -> Option<Self::Item>{\n        self.next(context)\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"<visit::traversal::Topo<N, VM> as std::default::Default>::default":["fn default() -> Self{\n        Topo {\n            tovisit: Vec::new(),\n            ordered: VM::default(),\n        }\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"<visit::traversal::WalkerIter<W, C> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.walker.walk_next(self.context.clone())\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"Directed":["/// Marker type for a directed graph.\npub enum Directed {}","Real(LocalPath(\"src/lib.rs\"))"],"Direction":["/// Edge direction.\n#[repr(usize)]\npub enum Direction {\n    /// An `Outgoing` edge is an outward edge *from* the current node.\n    Outgoing = 0,\n    /// An `Incoming` edge is an inbound edge *to* the current node.\n    Incoming = 1,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Direction::index":["/// Return `0` for `Outgoing` and `1` for `Incoming`.\n#[inline]\npub fn index(self) -> usize{\n        (self as usize) & 0x1\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Direction::opposite":["/// Return the opposite `Direction`.\n#[inline]\npub fn opposite(self) -> Direction{\n        match self {\n            Outgoing => Incoming,\n            Incoming => Outgoing,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"EdgeType":["/// A graph's edge type determines whether it has directed edges or not.\npub trait EdgeType {\n    fn is_directed() -> bool;\n}","Real(LocalPath(\"src/lib.rs\"))"],"IntoWeightedEdge":["/// Convert an element like `(i, j)` or `(i, j, w)` into\n/// a triple of source, target, edge weight.\n///\n/// For `Graph::from_edges` and `GraphMap::from_edges`.\npub trait IntoWeightedEdge<E> {\n    type NodeId;\n    fn into_weighted_edge(self) -> (Self::NodeId, Self::NodeId, E);\n}","Real(LocalPath(\"src/lib.rs\"))"],"Undirected":["/// Marker type for an undirected graph.\npub enum Undirected {}","Real(LocalPath(\"src/lib.rs\"))"],"algo::Cycle":["/// An algorithm error: a cycle was found in the graph.\npub struct Cycle<N>(N);","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::Cycle::<N>::node_id":["/// Return a node id that participates in the cycle\npub fn node_id(&self) -> N\n    where\n        N: Copy,{\n        self.0\n    }","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::DfsSpace":["/// Workspace for a graph traversal.\npub struct DfsSpace<N, VM> {\n    dfs: Dfs<N, VM>,\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::DfsSpace::<N, VM>::new":["pub fn new<G>(g: G) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,{\n        DfsSpace { dfs: Dfs::empty(g) }\n    }","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::FloatMeasure":["/// A floating-point measure.\npub trait FloatMeasure: Measure + Copy {\n    fn zero() -> Self;\n    fn infinite() -> Self;\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::Measure":["/// Associated data that can be used for measures (such as length).\npub trait Measure: Debug + PartialOrd + Add<Self, Output = Self> + Default + Clone {}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::MinSpanningTree":["/// An iterator producing a minimum spanning forest of a graph.\npub struct MinSpanningTree<G>\nwhere\n    G: Data + IntoNodeReferences,\n{\n    graph: G,\n    node_ids: Option<G::NodeReferences>,\n    subgraphs: UnionFind<usize>,\n    sort_edges: BinaryHeap<MinScored<G::EdgeWeight, (G::NodeId, G::NodeId)>>,\n    node_map: HashMap<usize, usize>,\n    node_count: usize,\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::NegativeCycle":["/// An algorithm error: a cycle of negative weights was found in the graph.\npub struct NegativeCycle(());","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::bellman_ford":["/// \\[Generic\\] Compute shortest paths from node `source` to all other.\n///\n/// Using the [Bellman–Ford algorithm][bf]; negative edge costs are\n/// permitted, but the graph must not have a cycle of negative weights\n/// (in that case it will return an error).\n///\n/// On success, return one vec with path costs, and another one which points\n/// out the predecessor of a node along a shortest path. The vectors\n/// are indexed by the graph's node indices.\n///\n/// [bf]: https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\n///\n/// # Example\n/// ```rust\n/// use petgraph::Graph;\n/// use petgraph::algo::bellman_ford;\n/// use petgraph::prelude::*;\n///\n/// let mut g = Graph::new();\n/// let a = g.add_node(()); // node with no weight\n/// let b = g.add_node(());\n/// let c = g.add_node(());\n/// let d = g.add_node(());\n/// let e = g.add_node(());\n/// let f = g.add_node(());\n/// g.extend_with_edges(&[\n///     (0, 1, 2.0),\n///     (0, 3, 4.0),\n///     (1, 2, 1.0),\n///     (1, 5, 7.0),\n///     (2, 4, 5.0),\n///     (4, 5, 1.0),\n///     (3, 4, 1.0),\n/// ]);\n///\n/// // Graph represented with the weight of each edge\n/// //\n/// //     2       1\n/// // a ----- b ----- c\n/// // | 4     | 7     |\n/// // d       f       | 5\n/// // | 1     | 1     |\n/// // \\------ e ------/\n///\n/// let path = bellman_ford(&g, a);\n/// assert_eq!(path, Ok((vec![0.0 ,     2.0,    3.0,    4.0,     5.0,     6.0],\n///                      vec![None, Some(a),Some(b),Some(a), Some(d), Some(e)]\n///                    ))\n///           );\n/// // Node f (indice 5) can be reach from a with a path costing 6.\n/// // Predecessor of f is Some(e) which predecessor is Some(d) which predecessor is Some(a).\n/// // Thus the path from a to f is a <-> d <-> e <-> f\n///\n/// let graph_with_neg_cycle = Graph::<(), f32, Undirected>::from_edges(&[\n///         (0, 1, -2.0),\n///         (0, 3, -4.0),\n///         (1, 2, -1.0),\n///         (1, 5, -25.0),\n///         (2, 4, -5.0),\n///         (4, 5, -25.0),\n///         (3, 4, -1.0),\n/// ]);\n///\n/// assert!(bellman_ford(&graph_with_neg_cycle, NodeIndex::new(0)).is_err());\n/// ```\npub fn bellman_ford<G>(\n    g: G,\n    source: G::NodeId,\n) -> Result<(Vec<G::EdgeWeight>, Vec<Option<G::NodeId>>), NegativeCycle>\nwhere\n    G: NodeCount + IntoNodeIdentifiers + IntoEdges + NodeIndexable,\n    G::EdgeWeight: FloatMeasure,{\n    let mut predecessor = vec![None; g.node_bound()];\n    let mut distance = vec![<_>::infinite(); g.node_bound()];\n\n    let ix = |i| g.to_index(i);\n\n    distance[ix(source)] = <_>::zero();\n    // scan up to |V| - 1 times.\n    for _ in 1..g.node_count() {\n        let mut did_update = false;\n        for i in g.node_identifiers() {\n            for edge in g.edges(i) {\n                let i = edge.source();\n                let j = edge.target();\n                let w = *edge.weight();\n                if distance[ix(i)] + w < distance[ix(j)] {\n                    distance[ix(j)] = distance[ix(i)] + w;\n                    predecessor[ix(j)] = Some(i);\n                    did_update = true;\n                }\n            }\n        }\n        if !did_update {\n            break;\n        }\n    }\n\n    // check for negative weight cycle\n    for i in g.node_identifiers() {\n        for edge in g.edges(i) {\n            let j = edge.target();\n            let w = *edge.weight();\n            if distance[ix(i)] + w < distance[ix(j)] {\n                //println!(\"neg cycle, detected from {} to {}, weight={}\", i, j, w);\n                return Err(NegativeCycle(()));\n            }\n        }\n    }\n\n    Ok((distance, predecessor))\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::condensation":["/// [Graph] Condense every strongly connected component into a single node and return the result.\n///\n/// If `make_acyclic` is true, self-loops and multi edges are ignored, guaranteeing that\n/// the output is acyclic.\n/// # Example\n/// ```rust\n/// use petgraph::Graph;\n/// use petgraph::algo::condensation;\n/// use petgraph::prelude::*;\n///\n/// let mut graph : Graph<(),(),Directed> = Graph::new();\n/// let a = graph.add_node(()); // node with no weight\n/// let b = graph.add_node(());\n/// let c = graph.add_node(());\n/// let d = graph.add_node(());\n/// let e = graph.add_node(());\n/// let f = graph.add_node(());\n/// let g = graph.add_node(());\n/// let h = graph.add_node(());\n///\n/// graph.extend_with_edges(&[\n///     (a, b),\n///     (b, c),\n///     (c, d),\n///     (d, a),\n///     (b, e),\n///     (e, f),\n///     (f, g),\n///     (g, h),\n///     (h, e)\n/// ]);\n///\n/// // a ----> b ----> e ----> f\n/// // ^       |       ^       |\n/// // |       v       |       v\n/// // d <---- c       h <---- g\n///\n/// let condensed_graph = condensation(graph,false);\n/// let A = NodeIndex::new(0);\n/// let B = NodeIndex::new(1);\n/// assert_eq!(condensed_graph.node_count(), 2);\n/// assert_eq!(condensed_graph.edge_count(), 9);\n/// assert_eq!(condensed_graph.neighbors(A).collect::<Vec<_>>(), vec![A, A, A, A]);\n/// assert_eq!(condensed_graph.neighbors(B).collect::<Vec<_>>(), vec![A, B, B, B, B]);\n/// ```\n/// If `make_acyclic` is true, self-loops and multi edges are ignored:\n///\n/// ```rust\n/// # use petgraph::Graph;\n/// # use petgraph::algo::condensation;\n/// # use petgraph::prelude::*;\n/// #\n/// # let mut graph : Graph<(),(),Directed> = Graph::new();\n/// # let a = graph.add_node(()); // node with no weight\n/// # let b = graph.add_node(());\n/// # let c = graph.add_node(());\n/// # let d = graph.add_node(());\n/// # let e = graph.add_node(());\n/// # let f = graph.add_node(());\n/// # let g = graph.add_node(());\n/// # let h = graph.add_node(());\n/// #\n/// # graph.extend_with_edges(&[\n/// #    (a, b),\n/// #    (b, c),\n/// #    (c, d),\n/// #    (d, a),\n/// #    (b, e),\n/// #    (e, f),\n/// #    (f, g),\n/// #    (g, h),\n/// #    (h, e)\n/// # ]);\n/// let acyclic_condensed_graph = condensation(graph, true);\n/// let A = NodeIndex::new(0);\n/// let B = NodeIndex::new(1);\n/// assert_eq!(acyclic_condensed_graph.node_count(), 2);\n/// assert_eq!(acyclic_condensed_graph.edge_count(), 1);\n/// assert_eq!(acyclic_condensed_graph.neighbors(B).collect::<Vec<_>>(), vec![A]);\n/// ```\npub fn condensation<N, E, Ty, Ix>(\n    g: Graph<N, E, Ty, Ix>,\n    make_acyclic: bool,\n) -> Graph<Vec<N>, E, Ty, Ix>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,{\n    let sccs = kosaraju_scc(&g);\n    let mut condensed: Graph<Vec<N>, E, Ty, Ix> = Graph::with_capacity(sccs.len(), g.edge_count());\n\n    // Build a map from old indices to new ones.\n    let mut node_map = vec![NodeIndex::end(); g.node_count()];\n    for comp in sccs {\n        let new_nix = condensed.add_node(Vec::new());\n        for nix in comp {\n            node_map[nix.index()] = new_nix;\n        }\n    }\n\n    // Consume nodes and edges of the old graph and insert them into the new one.\n    let (nodes, edges) = g.into_nodes_edges();\n    for (nix, node) in nodes.into_iter().enumerate() {\n        condensed[node_map[nix]].push(node.weight);\n    }\n    for edge in edges {\n        let source = node_map[edge.source().index()];\n        let target = node_map[edge.target().index()];\n        if make_acyclic {\n            if source != target {\n                condensed.update_edge(source, target, edge.weight);\n            }\n        } else {\n            condensed.add_edge(source, target, edge.weight);\n        }\n    }\n    condensed\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::connected_components":["/// \\[Generic\\] Return the number of connected components of the graph.\n///\n/// For a directed graph, this is the *weakly* connected components.\n/// # Example\n/// ```rust\n/// use petgraph::Graph;\n/// use petgraph::algo::connected_components;\n/// use petgraph::prelude::*;\n///\n/// let mut graph : Graph<(),(),Directed>= Graph::new();\n/// let a = graph.add_node(()); // node with no weight\n/// let b = graph.add_node(());\n/// let c = graph.add_node(());\n/// let d = graph.add_node(());\n/// let e = graph.add_node(());\n/// let f = graph.add_node(());\n/// let g = graph.add_node(());\n/// let h = graph.add_node(());\n///\n/// graph.extend_with_edges(&[\n///     (a, b),\n///     (b, c),\n///     (c, d),\n///     (d, a),\n///     (e, f),\n///     (f, g),\n///     (g, h),\n///     (h, e)\n/// ]);\n/// // a ----> b       e ----> f\n/// // ^       |       ^       |\n/// // |       v       |       v\n/// // d <---- c       h <---- g\n///\n/// assert_eq!(connected_components(&graph),2);\n/// graph.add_edge(b,e,());\n/// assert_eq!(connected_components(&graph),1);\n/// ```\npub fn connected_components<G>(g: G) -> usize\nwhere\n    G: NodeCompactIndexable + IntoEdgeReferences,{\n    let mut vertex_sets = UnionFind::new(g.node_bound());\n    for edge in g.edge_references() {\n        let (a, b) = (edge.source(), edge.target());\n\n        // union the two vertices of the edge\n        vertex_sets.union(g.to_index(a), g.to_index(b));\n    }\n    let mut labels = vertex_sets.into_labeling();\n    labels.sort();\n    labels.dedup();\n    labels.len()\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::dominators::Dominators":["/// The dominance relation for some graph and root.\npub struct Dominators<N>\nwhere\n    N: Copy + Eq + Hash,\n{\n    root: N,\n    dominators: HashMap<N, N>,\n}","Real(LocalPath(\"src/algo/dominators.rs\"))"],"algo::dominators::Dominators::<N>::dominators":["/// Iterate over all of the given node's dominators (including the given\n/// node itself).\n///\n/// If the given node is not reachable from the root, then `None` is\n/// returned.\npub fn dominators(&self, node: N) -> Option<DominatorsIter<N>>{\n        if self.dominators.contains_key(&node) {\n            Some(DominatorsIter {\n                dominators: self,\n                node: Some(node),\n            })\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/algo/dominators.rs\"))"],"algo::dominators::Dominators::<N>::immediate_dominator":["/// Get the immediate dominator of the given node.\n///\n/// Returns `None` for any node that is not reachable from the root, and for\n/// the root itself.\npub fn immediate_dominator(&self, node: N) -> Option<N>{\n        if node == self.root {\n            None\n        } else {\n            self.dominators.get(&node).cloned()\n        }\n    }","Real(LocalPath(\"src/algo/dominators.rs\"))"],"algo::dominators::Dominators::<N>::root":["/// Get the root node used to construct these dominance relations.\npub fn root(&self) -> N{\n        self.root\n    }","Real(LocalPath(\"src/algo/dominators.rs\"))"],"algo::dominators::Dominators::<N>::strict_dominators":["/// Iterate over the given node's strict dominators.\n///\n/// If the given node is not reachable from the root, then `None` is\n/// returned.\npub fn strict_dominators(&self, node: N) -> Option<DominatorsIter<N>>{\n        if self.dominators.contains_key(&node) {\n            Some(DominatorsIter {\n                dominators: self,\n                node: self.immediate_dominator(node),\n            })\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/algo/dominators.rs\"))"],"algo::dominators::DominatorsIter":["/// Iterator for a node's dominators.\npub struct DominatorsIter<'a, N>\nwhere\n    N: 'a + Copy + Eq + Hash,\n{\n    dominators: &'a Dominators<N>,\n    node: Option<N>,\n}","Real(LocalPath(\"src/algo/dominators.rs\"))"],"algo::dominators::intersect":["fn intersect(dominators: &[usize], mut finger1: usize, mut finger2: usize) -> usize{\n    loop {\n        match finger1.cmp(&finger2) {\n            Ordering::Less => finger1 = dominators[finger1],\n            Ordering::Greater => finger2 = dominators[finger2],\n            Ordering::Equal => return finger1,\n        }\n    }\n}","Real(LocalPath(\"src/algo/dominators.rs\"))"],"algo::dominators::predecessor_sets_to_idx_vecs":["fn predecessor_sets_to_idx_vecs<N>(\n    post_order: &[N],\n    node_to_post_order_idx: &HashMap<N, usize>,\n    mut predecessor_sets: HashMap<N, HashSet<N>>,\n) -> Vec<Vec<usize>>\nwhere\n    N: Copy + Eq + Hash,{\n    post_order\n        .iter()\n        .map(|node| {\n            predecessor_sets\n                .remove(node)\n                .map(|predecessors| {\n                    predecessors\n                        .into_iter()\n                        .map(|p| *node_to_post_order_idx.get(&p).unwrap())\n                        .collect()\n                })\n                .unwrap_or_else(Vec::new)\n        })\n        .collect()\n}","Real(LocalPath(\"src/algo/dominators.rs\"))"],"algo::dominators::simple_fast":["/// This is an implementation of the engineered [\"Simple, Fast Dominance\n/// Algorithm\"][0] discovered by Cooper et al.\n///\n/// This algorithm is **O(|V|²)**, and therefore has slower theoretical running time\n/// than the Lengauer-Tarjan algorithm (which is **O(|E| log |V|)**. However,\n/// Cooper et al found it to be faster in practice on control flow graphs of up\n/// to ~30,000 vertices.\n///\n/// [0]: http://www.cs.rice.edu/~keith/EMBED/dom.pdf\npub fn simple_fast<G>(graph: G, root: G::NodeId) -> Dominators<G::NodeId>\nwhere\n    G: IntoNeighbors + Visitable,\n    <G as GraphBase>::NodeId: Eq + Hash,{\n    let (post_order, predecessor_sets) = simple_fast_post_order(graph, root);\n    let length = post_order.len();\n    debug_assert!(length > 0);\n    debug_assert!(post_order.last() == Some(&root));\n\n    // From here on out we use indices into `post_order` instead of actual\n    // `NodeId`s wherever possible. This greatly improves the performance of\n    // this implementation, but we have to pay a little bit of upfront cost to\n    // convert our data structures to play along first.\n\n    // Maps a node to its index into `post_order`.\n    let node_to_post_order_idx: HashMap<_, _> = post_order\n        .iter()\n        .enumerate()\n        .map(|(idx, &node)| (node, idx))\n        .collect();\n\n    // Maps a node's `post_order` index to its set of predecessors's indices\n    // into `post_order` (as a vec).\n    let idx_to_predecessor_vec =\n        predecessor_sets_to_idx_vecs(&post_order, &node_to_post_order_idx, predecessor_sets);\n\n    let mut dominators = vec![UNDEFINED; length];\n    dominators[length - 1] = length - 1;\n\n    let mut changed = true;\n    while changed {\n        changed = false;\n\n        // Iterate in reverse post order, skipping the root.\n\n        for idx in (0..length - 1).rev() {\n            debug_assert!(post_order[idx] != root);\n\n            // Take the intersection of every predecessor's dominator set; that\n            // is the current best guess at the immediate dominator for this\n            // node.\n\n            let new_idom_idx = {\n                let mut predecessors = idx_to_predecessor_vec[idx]\n                    .iter()\n                    .filter(|&&p| dominators[p] != UNDEFINED);\n                let new_idom_idx = predecessors.next().expect(\n                    \"Because the root is initialized to dominate itself, and is the \\\n                     first node in every path, there must exist a predecessor to this \\\n                     node that also has a dominator\",\n                );\n                predecessors.fold(*new_idom_idx, |new_idom_idx, &predecessor_idx| {\n                    intersect(&dominators, new_idom_idx, predecessor_idx)\n                })\n            };\n\n            debug_assert!(new_idom_idx < length);\n\n            if new_idom_idx != dominators[idx] {\n                dominators[idx] = new_idom_idx;\n                changed = true;\n            }\n        }\n    }\n\n    // All done! Translate the indices back into proper `G::NodeId`s.\n\n    debug_assert!(!dominators.iter().any(|&dom| dom == UNDEFINED));\n\n    Dominators {\n        root,\n        dominators: dominators\n            .into_iter()\n            .enumerate()\n            .map(|(idx, dom_idx)| (post_order[idx], post_order[dom_idx]))\n            .collect(),\n    }\n}","Real(LocalPath(\"src/algo/dominators.rs\"))"],"algo::dominators::simple_fast_post_order":["fn simple_fast_post_order<G>(\n    graph: G,\n    root: G::NodeId,\n) -> (Vec<G::NodeId>, HashMap<G::NodeId, HashSet<G::NodeId>>)\nwhere\n    G: IntoNeighbors + Visitable,\n    <G as GraphBase>::NodeId: Eq + Hash,{\n    let mut post_order = vec![];\n    let mut predecessor_sets = HashMap::new();\n\n    for node in DfsPostOrder::new(graph, root).iter(graph) {\n        post_order.push(node);\n\n        for successor in graph.neighbors(node) {\n            predecessor_sets\n                .entry(successor)\n                .or_insert_with(HashSet::new)\n                .insert(node);\n        }\n    }\n\n    (post_order, predecessor_sets)\n}","Real(LocalPath(\"src/algo/dominators.rs\"))"],"algo::has_path_connecting":["/// \\[Generic\\] Check if there exists a path starting at `from` and reaching `to`.\n///\n/// If `from` and `to` are equal, this function returns true.\n///\n/// If `space` is not `None`, it is used instead of creating a new workspace for\n/// graph traversal.\npub fn has_path_connecting<G>(\n    g: G,\n    from: G::NodeId,\n    to: G::NodeId,\n    space: Option<&mut DfsSpace<G::NodeId, G::Map>>,\n) -> bool\nwhere\n    G: IntoNeighbors + Visitable,{\n    with_dfs(g, space, |dfs| {\n        dfs.reset(g);\n        dfs.move_to(from);\n        dfs.iter(g).any(|x| x == to)\n    })\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::is_bipartite_undirected":["/// Return `true` if the graph is bipartite. A graph is bipartite if it's nodes can be divided into\n/// two disjoint and indepedent sets U and V such that every edge connects U to one in V. This\n/// algorithm implements 2-coloring algorithm based on the BFS algorithm.\n///\n/// Always treats the input graph as if undirected.\npub fn is_bipartite_undirected<G, N, VM>(g: G, start: N) -> bool\nwhere\n    G: GraphRef + Visitable<NodeId = N, Map = VM> + IntoNeighbors<NodeId = N>,\n    N: Copy + PartialEq + std::fmt::Debug,\n    VM: VisitMap<N>,{\n    let mut red = g.visit_map();\n    red.visit(start);\n    let mut blue = g.visit_map();\n\n    let mut stack = ::std::collections::VecDeque::new();\n    stack.push_front(start);\n\n    while let Some(node) = stack.pop_front() {\n        let is_red = red.is_visited(&node);\n        let is_blue = blue.is_visited(&node);\n\n        assert!(is_red ^ is_blue);\n\n        for neighbour in g.neighbors(node) {\n            let is_neigbour_red = red.is_visited(&neighbour);\n            let is_neigbour_blue = blue.is_visited(&neighbour);\n\n            if (is_red && is_neigbour_red) || (is_blue && is_neigbour_blue) {\n                return false;\n            }\n\n            if !is_neigbour_red && !is_neigbour_blue {\n                //hasn't been visited yet\n\n                match (is_red, is_blue) {\n                    (true, false) => {\n                        blue.visit(neighbour);\n                    }\n                    (false, true) => {\n                        red.visit(neighbour);\n                    }\n                    (_, _) => {\n                        panic!(\"Invariant doesn't hold\");\n                    }\n                }\n\n                stack.push_back(neighbour);\n            }\n        }\n    }\n\n    true\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::is_cyclic_directed":["/// \\[Generic\\] Return `true` if the input directed graph contains a cycle.\n///\n/// This implementation is recursive; use `toposort` if an alternative is\n/// needed.\npub fn is_cyclic_directed<G>(g: G) -> bool\nwhere\n    G: IntoNodeIdentifiers + IntoNeighbors + Visitable,{\n    use crate::visit::{depth_first_search, DfsEvent};\n\n    depth_first_search(g, g.node_identifiers(), |event| match event {\n        DfsEvent::BackEdge(_, _) => Err(()),\n        _ => Ok(()),\n    })\n    .is_err()\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::is_cyclic_undirected":["/// \\[Generic\\] Return `true` if the input graph contains a cycle.\n///\n/// Always treats the input graph as if undirected.\npub fn is_cyclic_undirected<G>(g: G) -> bool\nwhere\n    G: NodeIndexable + IntoEdgeReferences,{\n    let mut edge_sets = UnionFind::new(g.node_bound());\n    for edge in g.edge_references() {\n        let (a, b) = (edge.source(), edge.target());\n\n        // union the two vertices of the edge\n        //  -- if they were already the same, then we have a cycle\n        if !edge_sets.union(g.to_index(a), g.to_index(b)) {\n            return true;\n        }\n    }\n    false\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::kosaraju_scc":["/// \\[Generic\\] Compute the *strongly connected components* using [Kosaraju's algorithm][1].\n///\n/// [1]: https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm\n///\n/// Return a vector where each element is a strongly connected component (scc).\n/// The order of node ids within each scc is arbitrary, but the order of\n/// the sccs is their postorder (reverse topological sort).\n///\n/// For an undirected graph, the sccs are simply the connected components.\n///\n/// This implementation is iterative and does two passes over the nodes.\npub fn kosaraju_scc<G>(g: G) -> Vec<Vec<G::NodeId>>\nwhere\n    G: IntoNeighborsDirected + Visitable + IntoNodeIdentifiers,{\n    let mut dfs = DfsPostOrder::empty(g);\n\n    // First phase, reverse dfs pass, compute finishing times.\n    // http://stackoverflow.com/a/26780899/161659\n    let mut finish_order = Vec::with_capacity(0);\n    for i in g.node_identifiers() {\n        if dfs.discovered.is_visited(&i) {\n            continue;\n        }\n\n        dfs.move_to(i);\n        while let Some(nx) = dfs.next(Reversed(g)) {\n            finish_order.push(nx);\n        }\n    }\n\n    let mut dfs = Dfs::from_parts(dfs.stack, dfs.discovered);\n    dfs.reset(g);\n    let mut sccs = Vec::new();\n\n    // Second phase\n    // Process in decreasing finishing time order\n    for i in finish_order.into_iter().rev() {\n        if dfs.discovered.is_visited(&i) {\n            continue;\n        }\n        // Move to the leader node `i`.\n        dfs.move_to(i);\n        let mut scc = Vec::new();\n        while let Some(nx) = dfs.next(g) {\n            scc.push(nx);\n        }\n        sccs.push(scc);\n    }\n    sccs\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::min_spanning_tree":["/// \\[Generic\\] Compute a *minimum spanning tree* of a graph.\n///\n/// The input graph is treated as if undirected.\n///\n/// Using Kruskal's algorithm with runtime **O(|E| log |E|)**. We actually\n/// return a minimum spanning forest, i.e. a minimum spanning tree for each connected\n/// component of the graph.\n///\n/// The resulting graph has all the vertices of the input graph (with identical node indices),\n/// and **|V| - c** edges, where **c** is the number of connected components in `g`.\n///\n/// Use `from_elements` to create a graph from the resulting iterator.\npub fn min_spanning_tree<G>(g: G) -> MinSpanningTree<G>\nwhere\n    G::NodeWeight: Clone,\n    G::EdgeWeight: Clone + PartialOrd,\n    G: IntoNodeReferences + IntoEdgeReferences + NodeIndexable,{\n    // Initially each vertex is its own disjoint subgraph, track the connectedness\n    // of the pre-MST with a union & find datastructure.\n    let subgraphs = UnionFind::new(g.node_bound());\n\n    let edges = g.edge_references();\n    let mut sort_edges = BinaryHeap::with_capacity(edges.size_hint().0);\n    for edge in edges {\n        sort_edges.push(MinScored(\n            edge.weight().clone(),\n            (edge.source(), edge.target()),\n        ));\n    }\n\n    MinSpanningTree {\n        graph: g,\n        node_ids: Some(g.node_references()),\n        subgraphs,\n        sort_edges,\n        node_map: HashMap::new(),\n        node_count: 0,\n    }\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::scc":["/// Renamed to `kosaraju_scc`.\n#[deprecated(note = \"renamed to kosaraju_scc\")]\npub fn scc<G>(g: G) -> Vec<Vec<G::NodeId>>\nwhere\n    G: IntoNeighborsDirected + Visitable + IntoNodeIdentifiers,{\n    kosaraju_scc(g)\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::tarjan_scc":["/// \\[Generic\\] Compute the *strongly connected components* using [Tarjan's algorithm][1].\n///\n/// [1]: https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n///\n/// Return a vector where each element is a strongly connected component (scc).\n/// The order of node ids within each scc is arbitrary, but the order of\n/// the sccs is their postorder (reverse topological sort).\n///\n/// For an undirected graph, the sccs are simply the connected components.\n///\n/// This implementation is recursive and does one pass over the nodes.\npub fn tarjan_scc<G>(g: G) -> Vec<Vec<G::NodeId>>\nwhere\n    G: IntoNodeIdentifiers + IntoNeighbors + NodeIndexable,{\n    #[derive(Copy, Clone, Debug)]\n    struct NodeData {\n        index: Option<usize>,\n        lowlink: usize,\n        on_stack: bool,\n    }\n\n    #[derive(Debug)]\n    struct Data<'a, G>\n    where\n        G: NodeIndexable,\n        G::NodeId: 'a,\n    {\n        index: usize,\n        nodes: Vec<NodeData>,\n        stack: Vec<G::NodeId>,\n        sccs: &'a mut Vec<Vec<G::NodeId>>,\n    }\n\n    fn scc_visit<G>(v: G::NodeId, g: G, data: &mut Data<G>)\n    where\n        G: IntoNeighbors + NodeIndexable,\n    {\n        macro_rules! node {\n            ($node:expr) => {\n                data.nodes[g.to_index($node)]\n            };\n        }\n\n        if node![v].index.is_some() {\n            // already visited\n            return;\n        }\n\n        let v_index = data.index;\n        node![v].index = Some(v_index);\n        node![v].lowlink = v_index;\n        node![v].on_stack = true;\n        data.stack.push(v);\n        data.index += 1;\n\n        for w in g.neighbors(v) {\n            match node![w].index {\n                None => {\n                    scc_visit(w, g, data);\n                    node![v].lowlink = min(node![v].lowlink, node![w].lowlink);\n                }\n                Some(w_index) => {\n                    if node![w].on_stack {\n                        // Successor w is in stack S and hence in the current SCC\n                        let v_lowlink = &mut node![v].lowlink;\n                        *v_lowlink = min(*v_lowlink, w_index);\n                    }\n                }\n            }\n        }\n\n        // If v is a root node, pop the stack and generate an SCC\n        if let Some(v_index) = node![v].index {\n            if node![v].lowlink == v_index {\n                let mut cur_scc = Vec::new();\n                loop {\n                    let w = data.stack.pop().unwrap();\n                    node![w].on_stack = false;\n                    cur_scc.push(w);\n                    if g.to_index(w) == g.to_index(v) {\n                        break;\n                    }\n                }\n                data.sccs.push(cur_scc);\n            }\n        }\n    }\n\n    let mut sccs = Vec::new();\n    {\n        let map = vec![\n            NodeData {\n                index: None,\n                lowlink: !0,\n                on_stack: false\n            };\n            g.node_bound()\n        ];\n\n        let mut data = Data {\n            index: 0,\n            nodes: map,\n            stack: Vec::new(),\n            sccs: &mut sccs,\n        };\n\n        for n in g.node_identifiers() {\n            scc_visit(n, g, &mut data);\n        }\n    }\n    sccs\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::tarjan_scc::Data":["struct Data<'a, G>\n    where\n        G: NodeIndexable,\n        G::NodeId: 'a,\n    {\n        index: usize,\n        nodes: Vec<NodeData>,\n        stack: Vec<G::NodeId>,\n        sccs: &'a mut Vec<Vec<G::NodeId>>,\n    }","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::tarjan_scc::NodeData":["struct NodeData {\n        index: Option<usize>,\n        lowlink: usize,\n        on_stack: bool,\n    }","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::tarjan_scc::scc_visit":["fn scc_visit<G>(v: G::NodeId, g: G, data: &mut Data<G>)\n    where\n        G: IntoNeighbors + NodeIndexable,{\n        macro_rules! node {\n            ($node:expr) => {\n                data.nodes[g.to_index($node)]\n            };\n        }\n\n        if node![v].index.is_some() {\n            // already visited\n            return;\n        }\n\n        let v_index = data.index;\n        node![v].index = Some(v_index);\n        node![v].lowlink = v_index;\n        node![v].on_stack = true;\n        data.stack.push(v);\n        data.index += 1;\n\n        for w in g.neighbors(v) {\n            match node![w].index {\n                None => {\n                    scc_visit(w, g, data);\n                    node![v].lowlink = min(node![v].lowlink, node![w].lowlink);\n                }\n                Some(w_index) => {\n                    if node![w].on_stack {\n                        // Successor w is in stack S and hence in the current SCC\n                        let v_lowlink = &mut node![v].lowlink;\n                        *v_lowlink = min(*v_lowlink, w_index);\n                    }\n                }\n            }\n        }\n\n        // If v is a root node, pop the stack and generate an SCC\n        if let Some(v_index) = node![v].index {\n            if node![v].lowlink == v_index {\n                let mut cur_scc = Vec::new();\n                loop {\n                    let w = data.stack.pop().unwrap();\n                    node![w].on_stack = false;\n                    cur_scc.push(w);\n                    if g.to_index(w) == g.to_index(v) {\n                        break;\n                    }\n                }\n                data.sccs.push(cur_scc);\n            }\n        }\n    }","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::toposort":["/// \\[Generic\\] Perform a topological sort of a directed graph.\n///\n/// If the graph was acyclic, return a vector of nodes in topological order:\n/// each node is ordered before its successors.\n/// Otherwise, it will return a `Cycle` error. Self loops are also cycles.\n///\n/// To handle graphs with cycles, use the scc algorithms or `DfsPostOrder`\n/// instead of this function.\n///\n/// If `space` is not `None`, it is used instead of creating a new workspace for\n/// graph traversal. The implementation is iterative.\npub fn toposort<G>(\n    g: G,\n    space: Option<&mut DfsSpace<G::NodeId, G::Map>>,\n) -> Result<Vec<G::NodeId>, Cycle<G::NodeId>>\nwhere\n    G: IntoNeighborsDirected + IntoNodeIdentifiers + Visitable,{\n    // based on kosaraju scc\n    with_dfs(g, space, |dfs| {\n        dfs.reset(g);\n        let mut finished = g.visit_map();\n\n        let mut finish_stack = Vec::new();\n        for i in g.node_identifiers() {\n            if dfs.discovered.is_visited(&i) {\n                continue;\n            }\n            dfs.stack.push(i);\n            while let Some(&nx) = dfs.stack.last() {\n                if dfs.discovered.visit(nx) {\n                    // First time visiting `nx`: Push neighbors, don't pop `nx`\n                    for succ in g.neighbors(nx) {\n                        if succ == nx {\n                            // self cycle\n                            return Err(Cycle(nx));\n                        }\n                        if !dfs.discovered.is_visited(&succ) {\n                            dfs.stack.push(succ);\n                        }\n                    }\n                } else {\n                    dfs.stack.pop();\n                    if finished.visit(nx) {\n                        // Second time: All reachable nodes must have been finished\n                        finish_stack.push(nx);\n                    }\n                }\n            }\n        }\n        finish_stack.reverse();\n\n        dfs.reset(g);\n        for &i in &finish_stack {\n            dfs.move_to(i);\n            let mut cycle = false;\n            while let Some(j) = dfs.next(Reversed(g)) {\n                if cycle {\n                    return Err(Cycle(j));\n                }\n                cycle = true;\n            }\n        }\n\n        Ok(finish_stack)\n    })\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"algo::with_dfs":["/// Create a Dfs if it's needed\nfn with_dfs<G, F, R>(g: G, space: Option<&mut DfsSpaceType<G>>, f: F) -> R\nwhere\n    G: GraphRef + Visitable,\n    F: FnOnce(&mut Dfs<G::NodeId, G::Map>) -> R,{\n    let mut local_visitor;\n    let dfs = if let Some(v) = space {\n        &mut v.dfs\n    } else {\n        local_visitor = Dfs::empty(g);\n        &mut local_visitor\n    };\n    f(dfs)\n}","Real(LocalPath(\"src/algo/mod.rs\"))"],"astar::PathTracker":["struct PathTracker<G>\nwhere\n    G: GraphBase,\n    G::NodeId: Eq + Hash,\n{\n    came_from: HashMap<G::NodeId, G::NodeId>,\n}","Real(LocalPath(\"src/astar.rs\"))"],"astar::PathTracker::<G>::new":["fn new() -> PathTracker<G>{\n        PathTracker {\n            came_from: HashMap::new(),\n        }\n    }","Real(LocalPath(\"src/astar.rs\"))"],"astar::PathTracker::<G>::reconstruct_path_to":["fn reconstruct_path_to(&self, last: G::NodeId) -> Vec<G::NodeId>{\n        let mut path = vec![last];\n\n        let mut current = last;\n        while let Some(&previous) = self.came_from.get(&current) {\n            path.push(previous);\n            current = previous;\n        }\n\n        path.reverse();\n\n        path\n    }","Real(LocalPath(\"src/astar.rs\"))"],"astar::PathTracker::<G>::set_predecessor":["fn set_predecessor(&mut self, node: G::NodeId, previous: G::NodeId){\n        self.came_from.insert(node, previous);\n    }","Real(LocalPath(\"src/astar.rs\"))"],"astar::astar":["/// \\[Generic\\] A* shortest path algorithm.\n///\n/// Computes the shortest path from `start` to `finish`, including the total path cost.\n///\n/// `finish` is implicitly given via the `is_goal` callback, which should return `true` if the\n/// given node is the finish node.\n///\n/// The function `edge_cost` should return the cost for a particular edge. Edge costs must be\n/// non-negative.\n///\n/// The function `estimate_cost` should return the estimated cost to the finish for a particular\n/// node. For the algorithm to find the actual shortest path, it should be admissible, meaning that\n/// it should never overestimate the actual cost to get to the nearest goal node. Estimate costs\n/// must also be non-negative.\n///\n/// The graph should be `Visitable` and implement `IntoEdges`.\n///\n/// # Example\n/// ```\n/// use petgraph::Graph;\n/// use petgraph::algo::astar;\n///\n/// let mut g = Graph::new();\n/// let a = g.add_node((0., 0.));\n/// let b = g.add_node((2., 0.));\n/// let c = g.add_node((1., 1.));\n/// let d = g.add_node((0., 2.));\n/// let e = g.add_node((3., 3.));\n/// let f = g.add_node((4., 2.));\n/// g.extend_with_edges(&[\n///     (a, b, 2),\n///     (a, d, 4),\n///     (b, c, 1),\n///     (b, f, 7),\n///     (c, e, 5),\n///     (e, f, 1),\n///     (d, e, 1),\n/// ]);\n///\n/// // Graph represented with the weight of each edge\n/// // Edges with '*' are part of the optimal path.\n/// //\n/// //     2       1\n/// // a ----- b ----- c\n/// // | 4*    | 7     |\n/// // d       f       | 5\n/// // | 1*    | 1*    |\n/// // \\------ e ------/\n///\n/// let path = astar(&g, a, |finish| finish == f, |e| *e.weight(), |_| 0);\n/// assert_eq!(path, Some((6, vec![a, d, e, f])));\n/// ```\n///\n/// Returns the total cost + the path of subsequent `NodeId` from start to finish, if one was\n/// found.\npub fn astar<G, F, H, K, IsGoal>(\n    graph: G,\n    start: G::NodeId,\n    mut is_goal: IsGoal,\n    mut edge_cost: F,\n    mut estimate_cost: H,\n) -> Option<(K, Vec<G::NodeId>)>\nwhere\n    G: IntoEdges + Visitable,\n    IsGoal: FnMut(G::NodeId) -> bool,\n    G::NodeId: Eq + Hash,\n    F: FnMut(G::EdgeRef) -> K,\n    H: FnMut(G::NodeId) -> K,\n    K: Measure + Copy,{\n    let mut visited = graph.visit_map();\n    let mut visit_next = BinaryHeap::new();\n    let mut scores = HashMap::new();\n    let mut path_tracker = PathTracker::<G>::new();\n\n    let zero_score = K::default();\n    scores.insert(start, zero_score);\n    visit_next.push(MinScored(estimate_cost(start), start));\n\n    while let Some(MinScored(_, node)) = visit_next.pop() {\n        if is_goal(node) {\n            let path = path_tracker.reconstruct_path_to(node);\n            let cost = scores[&node];\n            return Some((cost, path));\n        }\n\n        // Don't visit the same node several times, as the first time it was visited it was using\n        // the shortest available path.\n        if !visited.visit(node) {\n            continue;\n        }\n\n        // This lookup can be unwrapped without fear of panic since the node was necessarily scored\n        // before adding him to `visit_next`.\n        let node_score = scores[&node];\n\n        for edge in graph.edges(node) {\n            let next = edge.target();\n            if visited.is_visited(&next) {\n                continue;\n            }\n\n            let mut next_score = node_score + edge_cost(edge);\n\n            match scores.entry(next) {\n                Occupied(ent) => {\n                    let old_score = *ent.get();\n                    if next_score < old_score {\n                        *ent.into_mut() = next_score;\n                        path_tracker.set_predecessor(next, node);\n                    } else {\n                        next_score = old_score;\n                    }\n                }\n                Vacant(ent) => {\n                    ent.insert(next_score);\n                    path_tracker.set_predecessor(next, node);\n                }\n            }\n\n            let next_estimate_score = next_score + estimate_cost(next);\n            visit_next.push(MinScored(next_estimate_score, next));\n        }\n    }\n\n    None\n}","Real(LocalPath(\"src/astar.rs\"))"],"csr::Csr":["/// Compressed Sparse Row ([`CSR`]) is a sparse adjacency matrix graph.\n///\n/// `CSR` is parameterized over:\n///\n/// - Associated data `N` for nodes and `E` for edges, called *weights*.\n///   The associated data can be of arbitrary type.\n/// - Edge type `Ty` that determines whether the graph edges are directed or undirected.\n/// - Index type `Ix`, which determines the maximum size of the graph.\n///\n///\n/// Using **O(|E| + |V|)** space.\n///\n/// Self loops are allowed, no parallel edges.\n///\n/// Fast iteration of the outgoing edges of a vertex.\n///\n/// [`CSR`]: https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)\npub struct Csr<N = (), E = (), Ty = Directed, Ix = DefaultIx> {\n    /// Column of next edge\n    column: Vec<NodeIndex<Ix>>,\n    /// weight of each edge; lock step with column\n    edges: Vec<E>,\n    /// Index of start of row Always node_count + 1 long.\n    /// Last element is always equal to column.len()\n    row: Vec<usize>,\n    node_weights: Vec<N>,\n    edge_count: usize,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Directed, Ix>::from_sorted_edges":["/// Create a new `Csr` from a sorted sequence of edges\n///\n/// Edges **must** be sorted and unique, where the sort order is the default\n/// order for the pair *(u, v)* in Rust (*u* has priority).\n///\n/// Computes in **O(|E| + |V|)** time.\n/// # Example\n/// ```rust\n/// use petgraph::csr::Csr;\n/// use petgraph::prelude::*;\n///\n/// let graph = Csr::<(),()>::from_sorted_edges(&[\n///                     (0, 1), (0, 2),\n///                     (1, 0), (1, 2), (1, 3),\n///                     (2, 0),\n///                     (3, 1),\n/// ]);\n/// ```\npub fn from_sorted_edges<Edge>(edges: &[Edge]) -> Result<Self, EdgesNotSorted>\n    where\n        Edge: Clone + IntoWeightedEdge<E, NodeId = NodeIndex<Ix>>,\n        N: Default,{\n        let max_node_id = match edges\n            .iter()\n            .map(|edge| {\n                let (x, y, _) = edge.clone().into_weighted_edge();\n                max(x.index(), y.index())\n            })\n            .max()\n        {\n            None => return Ok(Self::with_nodes(0)),\n            Some(x) => x,\n        };\n        let mut self_ = Self::with_nodes(max_node_id + 1);\n        let mut iter = edges.iter().cloned().peekable();\n        {\n            let mut rows = self_.row.iter_mut();\n\n            let mut node = 0;\n            let mut rstart = 0;\n            let mut last_target;\n            'outer: for r in &mut rows {\n                *r = rstart;\n                last_target = None;\n                'inner: loop {\n                    if let Some(edge) = iter.peek() {\n                        let (n, m, weight) = edge.clone().into_weighted_edge();\n                        // check that the edges are in increasing sequence\n                        if node > n.index() {\n                            return Err(EdgesNotSorted {\n                                first_error: (n.index(), m.index()),\n                            });\n                        }\n                        /*\n                        debug_assert!(node <= n.index(),\n                                      concat!(\"edges are not sorted, \",\n                                              \"failed assertion source {:?} <= {:?} \",\n                                              \"for edge {:?}\"),\n                                      node, n, (n, m));\n                                      */\n                        if n.index() != node {\n                            break 'inner;\n                        }\n                        // check that the edges are in increasing sequence\n                        /*\n                        debug_assert!(last_target.map_or(true, |x| m > x),\n                                      \"edges are not sorted, failed assertion {:?} < {:?}\",\n                                      last_target, m);\n                                      */\n                        if !last_target.map_or(true, |x| m > x) {\n                            return Err(EdgesNotSorted {\n                                first_error: (n.index(), m.index()),\n                            });\n                        }\n                        last_target = Some(m);\n                        self_.column.push(m);\n                        self_.edges.push(weight);\n                        rstart += 1;\n                    } else {\n                        break 'outer;\n                    }\n                    iter.next();\n                }\n                node += 1;\n            }\n            for r in rows {\n                *r = rstart;\n            }\n        }\n\n        Ok(self_)\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::add_edge":["/// Return `true` if the edge was added\n///\n/// If you add all edges in row-major order, the time complexity\n/// is **O(|V|·|E|)** for the whole operation.\n///\n/// **Panics** if `a` or `b` are out of bounds.\npub fn add_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> bool\n    where\n        E: Clone,{\n        let ret = self.add_edge_(a, b, weight.clone());\n        if ret && !self.is_directed() {\n            self.edge_count += 1;\n        }\n        if ret && !self.is_directed() && a != b {\n            let _ret2 = self.add_edge_(b, a, weight);\n            debug_assert_eq!(ret, _ret2);\n        }\n        ret\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::add_edge_":["fn add_edge_(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> bool{\n        assert!(a.index() < self.node_count() && b.index() < self.node_count());\n        // a x b is at (a, b) in the matrix\n\n        // find current range of edges from a\n        let pos = match self.find_edge_pos(a, b) {\n            Ok(_) => return false, /* already exists */\n            Err(i) => i,\n        };\n        self.column.insert(pos, b);\n        self.edges.insert(pos, weight);\n        // update row vector\n        for r in &mut self.row[a.index() + 1..] {\n            *r += 1;\n        }\n        true\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::add_node":["/// Adds a new node with the given weight, returning the corresponding node index.\npub fn add_node(&mut self, weight: N) -> NodeIndex<Ix>{\n        let i = self.row.len() - 1;\n        self.row.insert(i, self.column.len());\n        self.node_weights.insert(i, weight);\n        Ix::new(i)\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::clear_edges":["/// Remove all edges\npub fn clear_edges(&mut self){\n        self.column.clear();\n        self.edges.clear();\n        for r in &mut self.row {\n            *r = 0;\n        }\n        if !self.is_directed() {\n            self.edge_count = 0;\n        }\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::contains_edge":["/// Computes in **O(log |V|)** time.\n///\n/// **Panics** if the node `a` does not exist.\npub fn contains_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool{\n        self.find_edge_pos(a, b).is_ok()\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::edge_count":["pub fn edge_count(&self) -> usize{\n        if self.is_directed() {\n            self.column.len()\n        } else {\n            self.edge_count\n        }\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::edges":["/// Return an iterator of all edges of `a`.\n///\n/// - `Directed`: Outgoing edges from `a`.\n/// - `Undirected`: All edges connected to `a`.\n///\n/// **Panics** if the node `a` does not exist.<br>\n/// Iterator element type is `EdgeReference<E, Ty, Ix>`.\npub fn edges(&self, a: NodeIndex<Ix>) -> Edges<E, Ty, Ix>{\n        let r = self.neighbors_range(a);\n        Edges {\n            index: r.start,\n            source: a,\n            iter: zip(&self.column[r.clone()], &self.edges[r]),\n            ty: self.ty,\n        }\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::edges_slice":["/// Computes in **O(1)** time.\n///\n/// **Panics** if the node `a` does not exist.\npub fn edges_slice(&self, a: NodeIndex<Ix>) -> &[E]{\n        &self.edges[self.neighbors_range(a)]\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::find_edge_pos":["fn find_edge_pos(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> Result<usize, usize>{\n        let (index, neighbors) = self.neighbors_of(a);\n        if neighbors.len() < BINARY_SEARCH_CUTOFF {\n            for (i, elt) in neighbors.iter().enumerate() {\n                match elt.cmp(&b) {\n                    Ordering::Equal => return Ok(i + index),\n                    Ordering::Greater => return Err(i + index),\n                    Ordering::Less => {}\n                }\n            }\n            Err(neighbors.len() + index)\n        } else {\n            match neighbors.binary_search(&b) {\n                Ok(i) => Ok(i + index),\n                Err(i) => Err(i + index),\n            }\n        }\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::is_directed":["pub fn is_directed(&self) -> bool{\n        Ty::is_directed()\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::neighbors_of":["fn neighbors_of(&self, a: NodeIndex<Ix>) -> (usize, &[Ix]){\n        let r = self.neighbors_range(a);\n        (r.start, &self.column[r])\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::neighbors_range":["fn neighbors_range(&self, a: NodeIndex<Ix>) -> Range<usize>{\n        let index = self.row[a.index()];\n        let end = self\n            .row\n            .get(a.index() + 1)\n            .cloned()\n            .unwrap_or_else(|| self.column.len());\n        index..end\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::neighbors_slice":["/// Computes in **O(1)** time.\n///\n/// **Panics** if the node `a` does not exist.\npub fn neighbors_slice(&self, a: NodeIndex<Ix>) -> &[NodeIndex<Ix>]{\n        self.neighbors_of(a).1\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::new":["/// Create an empty `Csr`.\npub fn new() -> Self{\n        Csr {\n            column: vec![],\n            edges: vec![],\n            row: vec![0; 1],\n            node_weights: vec![],\n            edge_count: 0,\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::node_count":["pub fn node_count(&self) -> usize{\n        self.row.len() - 1\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::out_degree":["/// Computes in **O(1)** time.\n///\n/// **Panics** if the node `a` does not exist.\npub fn out_degree(&self, a: NodeIndex<Ix>) -> usize{\n        let r = self.neighbors_range(a);\n        r.end - r.start\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::Csr::<N, E, Ty, Ix>::with_nodes":["/// Create a new [`Csr`] with `n` nodes. `N` must implement [`Default`] for the weight of each node.\n///\n/// [`Default`]: https://doc.rust-lang.org/nightly/core/default/trait.Default.html\n/// [`Csr`]: #struct.Csr.html\n///\n/// # Example\n/// ```rust\n/// use petgraph::csr::Csr;\n/// use petgraph::prelude::*;\n///\n/// let graph = Csr::<u8,()>::with_nodes(5);\n/// assert_eq!(graph.node_count(),5);\n/// assert_eq!(graph.edge_count(),0);\n///\n/// assert_eq!(graph[0],0);\n/// assert_eq!(graph[4],0);\n/// ```\npub fn with_nodes(n: usize) -> Self\n    where\n        N: Default,{\n        Csr {\n            column: Vec::new(),\n            edges: Vec::new(),\n            row: vec![0; n + 1],\n            node_weights: (0..n).map(|_| N::default()).collect(),\n            edge_count: 0,\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::EdgeReference":["pub struct EdgeReference<'a, E: 'a, Ty, Ix: 'a = DefaultIx> {\n    index: EdgeIndex,\n    source: NodeIndex<Ix>,\n    target: NodeIndex<Ix>,\n    weight: &'a E,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/csr.rs\"))"],"csr::EdgeReference::<'a, E, Ty, Ix>::weight":["/// Access the edge’s weight.\n///\n/// **NOTE** that this method offers a longer lifetime\n/// than the trait (unfortunately they don't match yet).\npub fn weight(&self) -> &'a E{\n        self.weight\n    }","Real(LocalPath(\"src/csr.rs\"))"],"csr::EdgeReferences":["pub struct EdgeReferences<'a, E: 'a, Ty, Ix: 'a> {\n    source_index: NodeIndex<Ix>,\n    index: usize,\n    edge_ranges: Enumerate<Windows<'a, usize>>,\n    column: &'a [NodeIndex<Ix>],\n    edges: &'a [E],\n    iter: Zip<SliceIter<'a, NodeIndex<Ix>>, SliceIter<'a, E>>,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/csr.rs\"))"],"csr::Edges":["pub struct Edges<'a, E: 'a, Ty = Directed, Ix: 'a = DefaultIx> {\n    index: usize,\n    source: NodeIndex<Ix>,\n    iter: Zip<SliceIter<'a, NodeIndex<Ix>>, SliceIter<'a, E>>,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/csr.rs\"))"],"csr::EdgesNotSorted":["/// Csr creation error: edges were not in sorted order.\npub struct EdgesNotSorted {\n    first_error: (usize, usize),\n}","Real(LocalPath(\"src/csr.rs\"))"],"csr::Neighbors":["pub struct Neighbors<'a, Ix: 'a = DefaultIx> {\n    iter: SliceIter<'a, NodeIndex<Ix>>,\n}","Real(LocalPath(\"src/csr.rs\"))"],"csr::NodeIdentifiers":["pub struct NodeIdentifiers<Ix = DefaultIx> {\n    r: Range<usize>,\n    ty: PhantomData<Ix>,\n}","Real(LocalPath(\"src/csr.rs\"))"],"data::Build":["/// A graph that can be extended with further nodes and edges\npub trait Build: Data + NodeCount {\n    fn add_node(&mut self, weight: Self::NodeWeight) -> Self::NodeId;\n    /// Add a new edge. If parallel edges (duplicate) are not allowed and\n    /// the edge already exists, return `None`.\n    fn add_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Option<Self::EdgeId> {\n        Some(self.update_edge(a, b, weight))\n    }\n    /// Add or update the edge from `a` to `b`. Return the id of the affected\n    /// edge.\n    fn update_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Self::EdgeId;\n}","Real(LocalPath(\"src/data.rs\"))"],"data::Build::add_edge":["/// Add a new edge. If parallel edges (duplicate) are not allowed and\n/// the edge already exists, return `None`.\nfn add_edge(\n        &mut self,\n        a: Self::NodeId,\n        b: Self::NodeId,\n        weight: Self::EdgeWeight,\n    ) -> Option<Self::EdgeId>{\n        Some(self.update_edge(a, b, weight))\n    }","Real(LocalPath(\"src/data.rs\"))"],"data::Create":["/// A graph that can be created\npub trait Create: Build + Default {\n    fn with_capacity(nodes: usize, edges: usize) -> Self;\n}","Real(LocalPath(\"src/data.rs\"))"],"data::DataMap":["#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"data::DataMapMut":["#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"data::Element":["/// A graph element.\n///\n/// A sequence of Elements, for example an iterator, is laid out as follows:\n/// Nodes are implicitly given the index of their appearance in the sequence.\n/// The edges’ source and target fields refer to these indices.\npub enum Element<N, E> {\n    /// A graph node.\n    Node { weight: N },\n    /// A graph edge.\n    Edge {\n        source: usize,\n        target: usize,\n        weight: E,\n    },\n}","Real(LocalPath(\"src/data.rs\"))"],"data::ElementIterator":["/// Iterator adaptors for iterators of `Element`.\npub trait ElementIterator<N, E>: Iterator<Item = Element<N, E>> {\n    /// Create an iterator adaptor that filters graph elements.\n    ///\n    /// The function `f` is called with each element and if its return value\n    /// is `true` the element is accepted and if `false` it is removed.\n    /// `f` is called with mutable references to the node and edge weights,\n    /// so that they can be mutated (but the edge endpoints can not).\n    ///\n    /// This filter adapts the edge source and target indices in the\n    /// stream so that they are correct after the removals.\n    fn filter_elements<F>(self, f: F) -> FilterElements<Self, F>\n    where\n        Self: Sized,\n        F: FnMut(Element<&mut N, &mut E>) -> bool,\n    {\n        FilterElements {\n            iter: self,\n            node_index: 0,\n            map: Vec::new(),\n            f,\n        }\n    }\n}","Real(LocalPath(\"src/data.rs\"))"],"data::ElementIterator::filter_elements":["/// Create an iterator adaptor that filters graph elements.\n///\n/// The function `f` is called with each element and if its return value\n/// is `true` the element is accepted and if `false` it is removed.\n/// `f` is called with mutable references to the node and edge weights,\n/// so that they can be mutated (but the edge endpoints can not).\n///\n/// This filter adapts the edge source and target indices in the\n/// stream so that they are correct after the removals.\nfn filter_elements<F>(self, f: F) -> FilterElements<Self, F>\n    where\n        Self: Sized,\n        F: FnMut(Element<&mut N, &mut E>) -> bool,{\n        FilterElements {\n            iter: self,\n            node_index: 0,\n            map: Vec::new(),\n            f,\n        }\n    }","Real(LocalPath(\"src/data.rs\"))"],"data::FilterElements":["/// An iterator that filters graph elements.\n///\n/// See [`.filter_elements()`][1] for more information.\n///\n/// [1]: trait.ElementIterator.html#method.filter_elements\npub struct FilterElements<I, F> {\n    iter: I,\n    node_index: usize,\n    map: Vec<usize>,\n    f: F,\n}","Real(LocalPath(\"src/data.rs\"))"],"data::FromElements":["/// Create a graph from an iterator of elements.\npub trait FromElements: Create {\n    fn from_elements<I>(iterable: I) -> Self\n    where\n        Self: Sized,\n        I: IntoIterator<Item = Element<Self::NodeWeight, Self::EdgeWeight>>,\n    {\n        let mut gr = Self::with_capacity(0, 0);\n        // usize -> NodeId map\n        let mut map = Vec::new();\n        for element in iterable {\n            match element {\n                Element::Node { weight } => {\n                    map.push(gr.add_node(weight));\n                }\n                Element::Edge {\n                    source,\n                    target,\n                    weight,\n                } => {\n                    gr.add_edge(map[source], map[target], weight);\n                }\n            }\n        }\n        gr\n    }\n}","Real(LocalPath(\"src/data.rs\"))"],"data::FromElements::from_elements":["fn from_elements<I>(iterable: I) -> Self\n    where\n        Self: Sized,\n        I: IntoIterator<Item = Element<Self::NodeWeight, Self::EdgeWeight>>,{\n        let mut gr = Self::with_capacity(0, 0);\n        // usize -> NodeId map\n        let mut map = Vec::new();\n        for element in iterable {\n            match element {\n                Element::Node { weight } => {\n                    map.push(gr.add_node(weight));\n                }\n                Element::Edge {\n                    source,\n                    target,\n                    weight,\n                } => {\n                    gr.add_edge(map[source], map[target], weight);\n                }\n            }\n        }\n        gr\n    }","Real(LocalPath(\"src/data.rs\"))"],"data::from_elements_indexable":["fn from_elements_indexable<G, I>(iterable: I) -> G\nwhere\n    G: Create + NodeIndexable,\n    I: IntoIterator<Item = Element<G::NodeWeight, G::EdgeWeight>>,{\n    let mut gr = G::with_capacity(0, 0);\n    let map = |gr: &G, i| gr.from_index(i);\n    for element in iterable {\n        match element {\n            Element::Node { weight } => {\n                gr.add_node(weight);\n            }\n            Element::Edge {\n                source,\n                target,\n                weight,\n            } => {\n                let from = map(&gr, source);\n                let to = map(&gr, target);\n                gr.add_edge(from, to, weight);\n            }\n        }\n    }\n    gr\n}","Real(LocalPath(\"src/data.rs\"))"],"dijkstra::dijkstra":["/// \\[Generic\\] Dijkstra's shortest path algorithm.\n///\n/// Compute the length of the shortest path from `start` to every reachable\n/// node.\n///\n/// The graph should be `Visitable` and implement `IntoEdges`. The function\n/// `edge_cost` should return the cost for a particular edge, which is used\n/// to compute path costs. Edge costs must be non-negative.\n///\n/// If `goal` is not `None`, then the algorithm terminates once the `goal` node's\n/// cost is calculated.\n///\n/// Returns a `HashMap` that maps `NodeId` to path cost.\n/// # Example\n/// ```rust\n/// use petgraph::Graph;\n/// use petgraph::algo::dijkstra;\n/// use petgraph::prelude::*;\n/// use std::collections::HashMap;\n///\n/// let mut graph : Graph<(),(),Directed>= Graph::new();\n/// let a = graph.add_node(()); // node with no weight\n/// let b = graph.add_node(());\n/// let c = graph.add_node(());\n/// let d = graph.add_node(());\n/// let e = graph.add_node(());\n/// let f = graph.add_node(());\n/// let g = graph.add_node(());\n/// let h = graph.add_node(());\n/// // z will be in another connected component\n/// let z = graph.add_node(());\n///\n/// graph.extend_with_edges(&[\n///     (a, b),\n///     (b, c),\n///     (c, d),\n///     (d, a),\n///     (e, f),\n///     (b, e),\n///     (f, g),\n///     (g, h),\n///     (h, e)\n/// ]);\n/// // a ----> b ----> e ----> f\n/// // ^       |       ^       |\n/// // |       v       |       v\n/// // d <---- c       h <---- g\n///\n/// let expected_res: HashMap<NodeIndex, usize> = [\n///      (a, 3),\n///      (b, 0),\n///      (c, 1),\n///      (d, 2),\n///      (e, 1),\n///      (f, 2),\n///      (g, 3),\n///      (h, 4)\n///     ].iter().cloned().collect();\n/// let res = dijkstra(&graph,b,None, |_| 1);\n/// assert_eq!(res, expected_res);\n/// // z is not inside res because there is not path from b to z.\n/// ```\npub fn dijkstra<G, F, K>(\n    graph: G,\n    start: G::NodeId,\n    goal: Option<G::NodeId>,\n    mut edge_cost: F,\n) -> HashMap<G::NodeId, K>\nwhere\n    G: IntoEdges + Visitable,\n    G::NodeId: Eq + Hash,\n    F: FnMut(G::EdgeRef) -> K,\n    K: Measure + Copy,{\n    let mut visited = graph.visit_map();\n    let mut scores = HashMap::new();\n    //let mut predecessor = HashMap::new();\n    let mut visit_next = BinaryHeap::new();\n    let zero_score = K::default();\n    scores.insert(start, zero_score);\n    visit_next.push(MinScored(zero_score, start));\n    while let Some(MinScored(node_score, node)) = visit_next.pop() {\n        if visited.is_visited(&node) {\n            continue;\n        }\n        if goal.as_ref() == Some(&node) {\n            break;\n        }\n        for edge in graph.edges(node) {\n            let next = edge.target();\n            if visited.is_visited(&next) {\n                continue;\n            }\n            let next_score = node_score + edge_cost(edge);\n            match scores.entry(next) {\n                Occupied(ent) => {\n                    if next_score < *ent.get() {\n                        *ent.into_mut() = next_score;\n                        visit_next.push(MinScored(next_score, next));\n                        //predecessor.insert(next.clone(), node.clone());\n                    }\n                }\n                Vacant(ent) => {\n                    ent.insert(next_score);\n                    visit_next.push(MinScored(next_score, next));\n                    //predecessor.insert(next.clone(), node.clone());\n                }\n            }\n        }\n        visited.visit(node);\n    }\n    scores\n}","Real(LocalPath(\"src/dijkstra.rs\"))"],"dot::Config":["/// `Dot` configuration.\n///\n/// This enum does not have an exhaustive definition (will be expanded)\npub enum Config {\n    /// Use indices for node labels.\n    NodeIndexLabel,\n    /// Use indices for edge labels.\n    EdgeIndexLabel,\n    /// Use no edge labels.\n    EdgeNoLabel,\n    /// Use no node labels.\n    NodeNoLabel,\n    /// Do not print the graph/digraph string.\n    GraphContentOnly,\n    #[doc(hidden)]\n    _Incomplete(()),\n}","Real(LocalPath(\"src/dot.rs\"))"],"dot::DebugFmt":["/// Pass Debug formatting to Display\nstruct DebugFmt<T>(T);","Real(LocalPath(\"src/dot.rs\"))"],"dot::Dot":["/// `Dot` implements output to graphviz .dot format for a graph.\n///\n/// Formatting and options are rather simple, this is mostly intended\n/// for debugging. Exact output may change.\n///\n/// # Examples\n///\n/// ```\n/// use petgraph::Graph;\n/// use petgraph::dot::{Dot, Config};\n///\n/// let mut graph = Graph::<_, ()>::new();\n/// graph.add_node(\"A\");\n/// graph.add_node(\"B\");\n/// graph.add_node(\"C\");\n/// graph.add_node(\"D\");\n/// graph.extend_with_edges(&[\n///     (0, 1), (0, 2), (0, 3),\n///     (1, 2), (1, 3),\n///     (2, 3),\n/// ]);\n///\n/// println!(\"{:?}\", Dot::with_config(&graph, &[Config::EdgeNoLabel]));\n///\n/// // In this case the output looks like this:\n/// //\n/// // digraph {\n/// //     0 [label=\"\\\"A\\\"\"]\n/// //     1 [label=\"\\\"B\\\"\"]\n/// //     2 [label=\"\\\"C\\\"\"]\n/// //     3 [label=\"\\\"D\\\"\"]\n/// //     0 -> 1\n/// //     0 -> 2\n/// //     0 -> 3\n/// //     1 -> 2\n/// //     1 -> 3\n/// //     2 -> 3\n/// // }\n///\n/// // If you need multiple config options, just list them all in the slice.\n/// ```\npub struct Dot<'a, G>\nwhere\n    G: IntoEdgeReferences + IntoNodeReferences,\n{\n    graph: G,\n    config: &'a [Config],\n    get_edge_attributes: &'a dyn Fn(G, G::EdgeRef) -> String,\n    get_node_attributes: &'a dyn Fn(G, G::NodeRef) -> String,\n}","Real(LocalPath(\"src/dot.rs\"))"],"dot::Dot::<'a, G>::graph_fmt":["fn graph_fmt<NF, EF, NW, EW>(\n        &self,\n        g: G,\n        f: &mut fmt::Formatter,\n        mut node_fmt: NF,\n        mut edge_fmt: EF,\n    ) -> fmt::Result\n    where\n        G: NodeIndexable + IntoNodeReferences + IntoEdgeReferences,\n        G: GraphProp + GraphBase,\n        G: Data<NodeWeight = NW, EdgeWeight = EW>,\n        NF: FnMut(&NW, &mut dyn FnMut(&dyn Display) -> fmt::Result) -> fmt::Result,\n        EF: FnMut(&EW, &mut dyn FnMut(&dyn Display) -> fmt::Result) -> fmt::Result,{\n        if !self.config.contains(&Config::GraphContentOnly) {\n            writeln!(f, \"{} {{\", TYPE[g.is_directed() as usize])?;\n        }\n\n        // output all labels\n        for node in g.node_references() {\n            write!(f, \"{}{} [ \", INDENT, g.to_index(node.id()),)?;\n            if !self.config.contains(&Config::NodeNoLabel) {\n                write!(f, \"label = \\\"\")?;\n                if self.config.contains(&Config::NodeIndexLabel) {\n                    write!(f, \"{}\", g.to_index(node.id()))?;\n                } else {\n                    node_fmt(node.weight(), &mut |d| Escaped(d).fmt(f))?;\n                }\n                write!(f, \"\\\" \")?;\n            }\n            writeln!(f, \"{}]\", (self.get_node_attributes)(g, node))?;\n        }\n        // output all edges\n        for (i, edge) in g.edge_references().enumerate() {\n            write!(\n                f,\n                \"{}{} {} {} [ \",\n                INDENT,\n                g.to_index(edge.source()),\n                EDGE[g.is_directed() as usize],\n                g.to_index(edge.target()),\n            )?;\n            if !self.config.contains(&Config::EdgeNoLabel) {\n                write!(f, \"label = \\\"\")?;\n                if self.config.contains(&Config::EdgeIndexLabel) {\n                    write!(f, \"{}\", i)?;\n                } else {\n                    edge_fmt(edge.weight(), &mut |d| Escaped(d).fmt(f))?;\n                }\n                write!(f, \"\\\" \")?;\n            }\n            writeln!(f, \"{}]\", (self.get_edge_attributes)(g, edge))?;\n        }\n\n        if !self.config.contains(&Config::GraphContentOnly) {\n            writeln!(f, \"}}\")?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/dot.rs\"))"],"dot::Dot::<'a, G>::new":["/// Create a `Dot` formatting wrapper with default configuration.\npub fn new(graph: G) -> Self{\n        Self::with_config(graph, &[])\n    }","Real(LocalPath(\"src/dot.rs\"))"],"dot::Dot::<'a, G>::with_attr_getters":["pub fn with_attr_getters(\n        graph: G,\n        config: &'a [Config],\n        get_edge_attributes: &'a dyn Fn(G, G::EdgeRef) -> String,\n        get_node_attributes: &'a dyn Fn(G, G::NodeRef) -> String,\n    ) -> Self{\n        Dot {\n            graph,\n            config,\n            get_edge_attributes,\n            get_node_attributes,\n        }\n    }","Real(LocalPath(\"src/dot.rs\"))"],"dot::Dot::<'a, G>::with_config":["/// Create a `Dot` formatting wrapper with custom configuration.\npub fn with_config(graph: G, config: &'a [Config]) -> Self{\n        Self::with_attr_getters(graph, config, &|_, _| \"\".to_string(), &|_, _| {\n            \"\".to_string()\n        })\n    }","Real(LocalPath(\"src/dot.rs\"))"],"dot::Escaped":["/// Pass Display formatting through a simple escaping filter\nstruct Escaped<T>(T);","Real(LocalPath(\"src/dot.rs\"))"],"dot::Escaper":["/// Escape for Graphviz\nstruct Escaper<W>(W);","Real(LocalPath(\"src/dot.rs\"))"],"graph_impl::Edge":["/// The graph's edge type.\npub struct Edge<E, Ix = DefaultIx> {\n    /// Associated edge data.\n    pub weight: E,\n    /// Next edge in outgoing and incoming edge lists.\n    next: [EdgeIndex<Ix>; 2],\n    /// Start and End node index\n    node: [NodeIndex<Ix>; 2],\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Edge::<E, Ix>::next_edge":["/// Accessor for data structure internals: the next edge for the given direction.\npub fn next_edge(&self, dir: Direction) -> EdgeIndex<Ix>{\n        self.next[dir.index()]\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Edge::<E, Ix>::source":["/// Return the source node index.\npub fn source(&self) -> NodeIndex<Ix>{\n        self.node[0]\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Edge::<E, Ix>::target":["/// Return the target node index.\npub fn target(&self) -> NodeIndex<Ix>{\n        self.node[1]\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgeIndex":["/// Edge identifier.\npub struct EdgeIndex<Ix = DefaultIx>(Ix);","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgeIndex::<Ix>::_into_node":["fn _into_node(self) -> NodeIndex<Ix>{\n        NodeIndex(self.0)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgeIndex::<Ix>::end":["/// An invalid `EdgeIndex` used to denote absence of an edge, for example\n/// to end an adjacency list.\n#[inline]\npub fn end() -> Self{\n        EdgeIndex(IndexType::max())\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgeIndex::<Ix>::index":["#[inline]\npub fn index(self) -> usize{\n        self.0.index()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgeIndex::<Ix>::new":["#[inline]\npub fn new(x: usize) -> Self{\n        EdgeIndex(IndexType::new(x))\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgeIndices":["/// Iterator over the edge indices of a graph.\npub struct EdgeIndices<Ix = DefaultIx> {\n    r: Range<usize>,\n    ty: PhantomData<fn() -> Ix>,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgeReference":["/// Reference to a `Graph` edge.\npub struct EdgeReference<'a, E: 'a, Ix = DefaultIx> {\n    index: EdgeIndex<Ix>,\n    node: [NodeIndex<Ix>; 2],\n    weight: &'a E,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgeReference::<'a, E, Ix>::weight":["/// Access the edge’s weight.\n///\n/// **NOTE** that this method offers a longer lifetime\n/// than the trait (unfortunately they don't match yet).\npub fn weight(&self) -> &'a E{\n        self.weight\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgeReferences":["/// Iterator over all edges of a graph.\npub struct EdgeReferences<'a, E: 'a, Ix: IndexType = DefaultIx> {\n    iter: iter::Enumerate<slice::Iter<'a, Edge<E, Ix>>>,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgeWeightsMut":["/// Iterator yielding mutable access to all edge weights.\npub struct EdgeWeightsMut<'a, E: 'a, Ix: IndexType = DefaultIx> {\n    edges: ::std::slice::IterMut<'a, Edge<E, Ix>>,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Edges":["/// Iterator over the edges of from or to a node\npub struct Edges<'a, E: 'a, Ty, Ix: 'a = DefaultIx>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    /// starting node to skip over\n    skip_start: NodeIndex<Ix>,\n    edges: &'a [Edge<E, Ix>],\n\n    /// Next edge to visit.\n    next: [EdgeIndex<Ix>; 2],\n\n    /// For directed graphs: the direction to iterate in\n    /// For undirected graphs: the direction of edges\n    direction: Direction,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgesConnecting":["/// Iterator over the multiple directed edges connecting a source node to a target node\npub struct EdgesConnecting<'a, E: 'a, Ty, Ix: 'a = DefaultIx>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    target_node: NodeIndex<Ix>,\n    edges: Edges<'a, E, Ty, Ix>,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgesWalkerMut":["struct EdgesWalkerMut<'a, E: 'a, Ix: IndexType = DefaultIx> {\n    edges: &'a mut [Edge<E, Ix>],\n    next: EdgeIndex<Ix>,\n    dir: Direction,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgesWalkerMut::<'a, E, Ix>::next":["fn next(&mut self) -> Option<(EdgeIndex<Ix>, &mut Edge<E, Ix>)>{\n        let this_index = self.next;\n        let k = self.dir.index();\n        match self.edges.get_mut(self.next.index()) {\n            None => None,\n            Some(edge) => {\n                self.next = edge.next[k];\n                Some((this_index, edge))\n            }\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::EdgesWalkerMut::<'a, E, Ix>::next_edge":["fn next_edge(&mut self) -> Option<&mut Edge<E, Ix>>{\n        self.next().map(|t| t.1)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Externals":["/// An iterator over either the nodes without edges to them or from them.\npub struct Externals<'a, N: 'a, Ty, Ix: IndexType = DefaultIx> {\n    iter: iter::Enumerate<slice::Iter<'a, Node<N, Ix>>>,\n    dir: Direction,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Frozen":["/// `Frozen` is a graph wrapper.\n///\n/// The `Frozen` only allows shared access (read-only) to the\n/// underlying graph `G`, but it allows mutable access to its\n/// node and edge weights.\n///\n/// This is used to ensure immutability of the graph's structure\n/// while permitting weights to be both read and written.\n///\n/// See indexing implementations and the traits `Data` and `DataMap`\n/// for read-write access to the graph's weights.\npub struct Frozen<'a, G: 'a>(&'a mut G);","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph":["/// `Graph<N, E, Ty, Ix>` is a graph datastructure using an adjacency list representation.\n///\n/// `Graph` is parameterized over:\n///\n/// - Associated data `N` for nodes and `E` for edges, called *weights*.\n///   The associated data can be of arbitrary type.\n/// - Edge type `Ty` that determines whether the graph edges are directed or undirected.\n/// - Index type `Ix`, which determines the maximum size of the graph.\n///\n/// The `Graph` is a regular Rust collection and is `Send` and `Sync` (as long\n/// as associated data `N` and `E` are).\n///\n/// The graph uses **O(|V| + |E|)** space, and allows fast node and edge insert,\n/// efficient graph search and graph algorithms.\n/// It implements **O(e')** edge lookup and edge and node removals, where **e'**\n/// is some local measure of edge count.\n/// Based on the graph datastructure used in rustc.\n///\n/// Here's an example of building a graph with directed edges, and below\n/// an illustration of how it could be rendered with graphviz (see\n/// [`Dot`](../dot/struct.Dot.html)):\n///\n/// ```\n/// use petgraph::Graph;\n///\n/// let mut deps = Graph::<&str, &str>::new();\n/// let pg = deps.add_node(\"petgraph\");\n/// let fb = deps.add_node(\"fixedbitset\");\n/// let qc = deps.add_node(\"quickcheck\");\n/// let rand = deps.add_node(\"rand\");\n/// let libc = deps.add_node(\"libc\");\n/// deps.extend_with_edges(&[\n///     (pg, fb), (pg, qc),\n///     (qc, rand), (rand, libc), (qc, libc),\n/// ]);\n/// ```\n///\n/// ![graph-example](https://bluss.github.io/ndarray/images/graph-example.svg)\n///\n/// ### Graph Indices\n///\n/// The graph maintains indices for nodes and edges, and node and edge\n/// weights may be accessed mutably. Indices range in a compact interval, for\n/// example for *n* nodes indices are 0 to *n* - 1 inclusive.\n///\n/// `NodeIndex` and `EdgeIndex` are types that act as references to nodes and edges,\n/// but these are only stable across certain operations:\n///\n/// * **Removing nodes or edges may shift other indices.** Removing a node will\n/// force the last node to shift its index to take its place. Similarly,\n/// removing an edge shifts the index of the last edge.\n/// * Adding nodes or edges keeps indices stable.\n///\n/// The `Ix` parameter is `u32` by default. The goal is that you can ignore this parameter\n/// completely unless you need a very big graph -- then you can use `usize`.\n///\n/// * The fact that the node and edge indices in the graph each are numbered in compact\n/// intervals (from 0 to *n* - 1 for *n* nodes) simplifies some graph algorithms.\n///\n/// * You can select graph index integer type after the size of the graph. A smaller\n/// size may have better performance.\n///\n/// * Using indices allows mutation while traversing the graph, see `Dfs`,\n/// and `.neighbors(a).detach()`.\n///\n/// * You can create several graphs using the equal node indices but with\n/// differing weights or differing edges.\n///\n/// * Indices don't allow as much compile time checking as references.\n///\npub struct Graph<N, E, Ty = Directed, Ix = DefaultIx> {\n    nodes: Vec<Node<N, Ix>>,\n    edges: Vec<Edge<E, Ix>>,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::add_edge":["/// Add an edge from `a` to `b` to the graph, with its associated\n/// data `weight`.\n///\n/// Return the index of the new edge.\n///\n/// Computes in **O(1)** time.\n///\n/// **Panics** if any of the nodes don't exist.<br>\n/// **Panics** if the Graph is at the maximum number of edges for its index\n/// type (N/A if usize).\n///\n/// **Note:** `Graph` allows adding parallel (“duplicate”) edges. If you want\n/// to avoid this, use [`.update_edge(a, b, weight)`](#method.update_edge) instead.\npub fn add_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> EdgeIndex<Ix>{\n        let edge_idx = EdgeIndex::new(self.edges.len());\n        assert!(<Ix as IndexType>::max().index() == !0 || EdgeIndex::end() != edge_idx);\n        let mut edge = Edge {\n            weight,\n            node: [a, b],\n            next: [EdgeIndex::end(); 2],\n        };\n        match index_twice(&mut self.nodes, a.index(), b.index()) {\n            Pair::None => panic!(\"Graph::add_edge: node indices out of bounds\"),\n            Pair::One(an) => {\n                edge.next = an.next;\n                an.next[0] = edge_idx;\n                an.next[1] = edge_idx;\n            }\n            Pair::Both(an, bn) => {\n                // a and b are different indices\n                edge.next = [an.next[0], bn.next[1]];\n                an.next[0] = edge_idx;\n                bn.next[1] = edge_idx;\n            }\n        }\n        self.edges.push(edge);\n        edge_idx\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::add_node":["/// Add a node (also called vertex) with associated data `weight` to the graph.\n///\n/// Computes in **O(1)** time.\n///\n/// Return the index of the new node.\n///\n/// **Panics** if the Graph is at the maximum number of nodes for its index\n/// type (N/A if usize).\npub fn add_node(&mut self, weight: N) -> NodeIndex<Ix>{\n        let node = Node {\n            weight,\n            next: [EdgeIndex::end(), EdgeIndex::end()],\n        };\n        let node_idx = NodeIndex::new(self.nodes.len());\n        // check for max capacity, except if we use usize\n        assert!(<Ix as IndexType>::max().index() == !0 || NodeIndex::end() != node_idx);\n        self.nodes.push(node);\n        node_idx\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::capacity":["/// Return the current node and edge capacity of the graph.\npub fn capacity(&self) -> (usize, usize){\n        (self.nodes.capacity(), self.edges.capacity())\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::change_edge_links":["/// For edge `e` with endpoints `edge_node`, replace links to it,\n/// with links to `edge_next`.\nfn change_edge_links(\n        &mut self,\n        edge_node: [NodeIndex<Ix>; 2],\n        e: EdgeIndex<Ix>,\n        edge_next: [EdgeIndex<Ix>; 2],\n    ){\n        for &d in &DIRECTIONS {\n            let k = d.index();\n            let node = match self.nodes.get_mut(edge_node[k].index()) {\n                Some(r) => r,\n                None => {\n                    debug_assert!(\n                        false,\n                        \"Edge's endpoint dir={:?} index={:?} not found\",\n                        d, edge_node[k]\n                    );\n                    return;\n                }\n            };\n            let fst = node.next[k];\n            if fst == e {\n                //println!(\"Updating first edge 0 for node {}, set to {}\", edge_node[0], edge_next[0]);\n                node.next[k] = edge_next[k];\n            } else {\n                let mut edges = edges_walker_mut(&mut self.edges, fst, d);\n                while let Some(curedge) = edges.next_edge() {\n                    if curedge.next[k] == e {\n                        curedge.next[k] = edge_next[k];\n                        break; // the edge can only be present once in the list.\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::clear":["/// Remove all nodes and edges\npub fn clear(&mut self){\n        self.nodes.clear();\n        self.edges.clear();\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::clear_edges":["/// Remove all edges\npub fn clear_edges(&mut self){\n        self.edges.clear();\n        for node in &mut self.nodes {\n            node.next = [EdgeIndex::end(), EdgeIndex::end()];\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::contains_edge":["/// Lookup if there is an edge from `a` to `b`.\n///\n/// Computes in **O(e')** time, where **e'** is the number of edges\n/// connected to `a` (and `b`, if the graph edges are undirected).\npub fn contains_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool{\n        self.find_edge(a, b).is_some()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_count":["/// Return the number of edges in the graph.\n///\n/// Computes in **O(1)** time.\npub fn edge_count(&self) -> usize{\n        self.edges.len()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_endpoints":["/// Access the source and target nodes for `e`.\npub fn edge_endpoints(&self, e: EdgeIndex<Ix>) -> Option<(NodeIndex<Ix>, NodeIndex<Ix>)>{\n        self.edges\n            .get(e.index())\n            .map(|ed| (ed.source(), ed.target()))\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_indices":["/// Return an iterator over the edge indices of the graph\npub fn edge_indices(&self) -> EdgeIndices<Ix>{\n        EdgeIndices {\n            r: 0..self.edge_count(),\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_references":["/// Create an iterator over all edges, in indexed order.\n///\n/// Iterator element type is `EdgeReference<E, Ix>`.\npub fn edge_references(&self) -> EdgeReferences<E, Ix>{\n        EdgeReferences {\n            iter: self.edges.iter().enumerate(),\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_weight":["/// Access the weight for edge `e`.\n///\n/// Also available with indexing syntax: `&graph[e]`.\npub fn edge_weight(&self, e: EdgeIndex<Ix>) -> Option<&E>{\n        self.edges.get(e.index()).map(|ed| &ed.weight)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_weight_mut":["/// Access the weight for edge `e`, mutably.\n///\n/// Also available with indexing syntax: `&mut graph[e]`.\npub fn edge_weight_mut(&mut self, e: EdgeIndex<Ix>) -> Option<&mut E>{\n        self.edges.get_mut(e.index()).map(|ed| &mut ed.weight)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::edge_weights_mut":["/// Return an iterator yielding mutable access to all edge weights.\n///\n/// The order in which weights are yielded matches the order of their\n/// edge indices.\npub fn edge_weights_mut(&mut self) -> EdgeWeightsMut<E, Ix>{\n        EdgeWeightsMut {\n            edges: self.edges.iter_mut(),\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::edges":["/// Return an iterator of all edges of `a`.\n///\n/// - `Directed`: Outgoing edges from `a`.\n/// - `Undirected`: All edges connected to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is `EdgeReference<E, Ix>`.\npub fn edges(&self, a: NodeIndex<Ix>) -> Edges<E, Ty, Ix>{\n        self.edges_directed(a, Outgoing)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::edges_connecting":["/// Return an iterator over all the edges connecting `a` and `b`.\n///\n/// - `Directed`: Outgoing edges from `a`.\n/// - `Undirected`: All edges connected to `a`.\n///\n/// Iterator element type is `EdgeReference<E, Ix>`.\npub fn edges_connecting(\n        &self,\n        a: NodeIndex<Ix>,\n        b: NodeIndex<Ix>,\n    ) -> EdgesConnecting<E, Ty, Ix>{\n        EdgesConnecting {\n            target_node: b,\n            edges: self.edges_directed(a, Direction::Outgoing),\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::edges_directed":["/// Return an iterator of all edges of `a`, in the specified direction.\n///\n/// - `Directed`, `Outgoing`: All edges from `a`.\n/// - `Directed`, `Incoming`: All edges to `a`.\n/// - `Undirected`, `Outgoing`: All edges connected to `a`, with `a` being the source of each\n///   edge.\n/// - `Undirected`, `Incoming`: All edges connected to `a`, with `a` being the target of each\n///   edge.\n///\n/// Produces an empty iterator if the node `a` doesn't exist.<br>\n/// Iterator element type is `EdgeReference<E, Ix>`.\npub fn edges_directed(&self, a: NodeIndex<Ix>, dir: Direction) -> Edges<E, Ty, Ix>{\n        Edges {\n            skip_start: a,\n            edges: &self.edges,\n            direction: dir,\n            next: match self.nodes.get(a.index()) {\n                None => [EdgeIndex::end(), EdgeIndex::end()],\n                Some(n) => n.next,\n            },\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::extend_with_edges":["/// Extend the graph from an iterable of edges.\n///\n/// Node weights `N` are set to default values.\n/// Edge weights `E` may either be specified in the list,\n/// or they are filled with default values.\n///\n/// Nodes are inserted automatically to match the edges.\npub fn extend_with_edges<I>(&mut self, iterable: I)\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,{\n        let iter = iterable.into_iter();\n        let (low, _) = iter.size_hint();\n        self.edges.reserve(low);\n\n        for elt in iter {\n            let (source, target, weight) = elt.into_weighted_edge();\n            let (source, target) = (source.into(), target.into());\n            let nx = cmp::max(source, target);\n            while nx.index() >= self.node_count() {\n                self.add_node(N::default());\n            }\n            self.add_edge(source, target, weight);\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::externals":["/// Return an iterator over either the nodes without edges to them\n/// (`Incoming`) or from them (`Outgoing`).\n///\n/// An *internal* node has both incoming and outgoing edges.\n/// The nodes in `.externals(Incoming)` are the source nodes and\n/// `.externals(Outgoing)` are the sinks of the graph.\n///\n/// For a graph with undirected edges, both the sinks and the sources are\n/// just the nodes without edges.\n///\n/// The whole iteration computes in **O(|V|)** time.\npub fn externals(&self, dir: Direction) -> Externals<N, Ty, Ix>{\n        Externals {\n            iter: self.nodes.iter().enumerate(),\n            dir,\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::filter_map":["/// Create a new `Graph` by mapping nodes and edges.\n/// A node or edge may be mapped to `None` to exclude it from\n/// the resulting graph.\n///\n/// Nodes are mapped first with the `node_map` closure, then\n/// `edge_map` is called for the edges that have not had any endpoint\n/// removed.\n///\n/// The resulting graph has the structure of a subgraph of the original graph.\n/// If no nodes are removed, the resulting graph has compatible node\n/// indices; if neither nodes nor edges are removed, the result has\n/// the same graph indices as `self`.\npub fn filter_map<'a, F, G, N2, E2>(\n        &'a self,\n        mut node_map: F,\n        mut edge_map: G,\n    ) -> Graph<N2, E2, Ty, Ix>\n    where\n        F: FnMut(NodeIndex<Ix>, &'a N) -> Option<N2>,\n        G: FnMut(EdgeIndex<Ix>, &'a E) -> Option<E2>,{\n        let mut g = Graph::with_capacity(0, 0);\n        // mapping from old node index to new node index, end represents removed.\n        let mut node_index_map = vec![NodeIndex::end(); self.node_count()];\n        for (i, node) in enumerate(&self.nodes) {\n            if let Some(nw) = node_map(NodeIndex::new(i), &node.weight) {\n                node_index_map[i] = g.add_node(nw);\n            }\n        }\n        for (i, edge) in enumerate(&self.edges) {\n            // skip edge if any endpoint was removed\n            let source = node_index_map[edge.source().index()];\n            let target = node_index_map[edge.target().index()];\n            if source != NodeIndex::end() && target != NodeIndex::end() {\n                if let Some(ew) = edge_map(EdgeIndex::new(i), &edge.weight) {\n                    g.add_edge(source, target, ew);\n                }\n            }\n        }\n        g\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge":["/// Lookup an edge from `a` to `b`.\n///\n/// Computes in **O(e')** time, where **e'** is the number of edges\n/// connected to `a` (and `b`, if the graph edges are undirected).\npub fn find_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> Option<EdgeIndex<Ix>>{\n        if !self.is_directed() {\n            self.find_edge_undirected(a, b).map(|(ix, _)| ix)\n        } else {\n            match self.nodes.get(a.index()) {\n                None => None,\n                Some(node) => self.find_edge_directed_from_node(node, b),\n            }\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge_directed_from_node":["fn find_edge_directed_from_node(\n        &self,\n        node: &Node<N, Ix>,\n        b: NodeIndex<Ix>,\n    ) -> Option<EdgeIndex<Ix>>{\n        let mut edix = node.next[0];\n        while let Some(edge) = self.edges.get(edix.index()) {\n            if edge.node[1] == b {\n                return Some(edix);\n            }\n            edix = edge.next[0];\n        }\n        None\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge_undirected":["/// Lookup an edge between `a` and `b`, in either direction.\n///\n/// If the graph is undirected, then this is equivalent to `.find_edge()`.\n///\n/// Return the edge index and its directionality, with `Outgoing` meaning\n/// from `a` to `b` and `Incoming` the reverse,\n/// or `None` if the edge does not exist.\npub fn find_edge_undirected(\n        &self,\n        a: NodeIndex<Ix>,\n        b: NodeIndex<Ix>,\n    ) -> Option<(EdgeIndex<Ix>, Direction)>{\n        match self.nodes.get(a.index()) {\n            None => None,\n            Some(node) => self.find_edge_undirected_from_node(node, b),\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge_undirected_from_node":["fn find_edge_undirected_from_node(\n        &self,\n        node: &Node<N, Ix>,\n        b: NodeIndex<Ix>,\n    ) -> Option<(EdgeIndex<Ix>, Direction)>{\n        for &d in &DIRECTIONS {\n            let k = d.index();\n            let mut edix = node.next[k];\n            while let Some(edge) = self.edges.get(edix.index()) {\n                if edge.node[1 - k] == b {\n                    return Some((edix, d));\n                }\n                edix = edge.next[k];\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::first_edge":["/// Accessor for data structure internals: the first edge in the given direction.\npub fn first_edge(&self, a: NodeIndex<Ix>, dir: Direction) -> Option<EdgeIndex<Ix>>{\n        match self.nodes.get(a.index()) {\n            None => None,\n            Some(node) => {\n                let edix = node.next[dir.index()];\n                if edix == EdgeIndex::end() {\n                    None\n                } else {\n                    Some(edix)\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::from_edges":["/// Create a new `Graph` from an iterable of edges.\n///\n/// Node weights `N` are set to default values.\n/// Edge weights `E` may either be specified in the list,\n/// or they are filled with default values.\n///\n/// Nodes are inserted automatically to match the edges.\n///\n/// ```\n/// use petgraph::Graph;\n///\n/// let gr = Graph::<(), i32>::from_edges(&[\n///     (0, 1), (0, 2), (0, 3),\n///     (1, 2), (1, 3),\n///     (2, 3),\n/// ]);\n/// ```\npub fn from_edges<I>(iterable: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,{\n        let mut g = Self::with_capacity(0, 0);\n        g.extend_with_edges(iterable);\n        g\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::index_twice_mut":["/// Index the `Graph` by two indices, any combination of\n/// node or edge indices is fine.\n///\n/// **Panics** if the indices are equal or if they are out of bounds.\n///\n/// ```\n/// use petgraph::{Graph, Incoming};\n/// use petgraph::visit::Dfs;\n///\n/// let mut gr = Graph::new();\n/// let a = gr.add_node(0.);\n/// let b = gr.add_node(0.);\n/// let c = gr.add_node(0.);\n/// gr.add_edge(a, b, 3.);\n/// gr.add_edge(b, c, 2.);\n/// gr.add_edge(c, b, 1.);\n///\n/// // walk the graph and sum incoming edges into the node weight\n/// let mut dfs = Dfs::new(&gr, a);\n/// while let Some(node) = dfs.next(&gr) {\n///     // use a walker -- a detached neighbors iterator\n///     let mut edges = gr.neighbors_directed(node, Incoming).detach();\n///     while let Some(edge) = edges.next_edge(&gr) {\n///         let (nw, ew) = gr.index_twice_mut(node, edge);\n///         *nw += *ew;\n///     }\n/// }\n///\n/// // check the result\n/// assert_eq!(gr[a], 0.);\n/// assert_eq!(gr[b], 4.);\n/// assert_eq!(gr[c], 2.);\n/// ```\npub fn index_twice_mut<T, U>(\n        &mut self,\n        i: T,\n        j: U,\n    ) -> (\n        &mut <Self as Index<T>>::Output,\n        &mut <Self as Index<U>>::Output,\n    )\n    where\n        Self: IndexMut<T> + IndexMut<U>,\n        T: GraphIndex,\n        U: GraphIndex,{\n        assert!(T::is_node_index() != U::is_node_index() || i.index() != j.index());\n\n        // Allow two mutable indexes here -- they are nonoverlapping\n        unsafe {\n            let self_mut = self as *mut _;\n            (\n                <Self as IndexMut<T>>::index_mut(&mut *self_mut, i),\n                <Self as IndexMut<U>>::index_mut(&mut *self_mut, j),\n            )\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::into_edge_type":["/// Convert the graph into either undirected or directed. No edge adjustments\n/// are done, so you may want to go over the result to remove or add edges.\n///\n/// Computes in **O(1)** time.\npub fn into_edge_type<NewTy>(self) -> Graph<N, E, NewTy, Ix>\n    where\n        NewTy: EdgeType,{\n        Graph {\n            nodes: self.nodes,\n            edges: self.edges,\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::into_nodes_edges":["/// Convert the graph into a vector of Nodes and a vector of Edges\npub fn into_nodes_edges(self) -> (Vec<Node<N, Ix>>, Vec<Edge<E, Ix>>){\n        (self.nodes, self.edges)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::is_directed":["/// Whether the graph has directed edges or not.\n#[inline]\npub fn is_directed(&self) -> bool{\n        Ty::is_directed()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::map":["/// Create a new `Graph` by mapping node and\n/// edge weights to new values.\n///\n/// The resulting graph has the same structure and the same\n/// graph indices as `self`.\npub fn map<'a, F, G, N2, E2>(\n        &'a self,\n        mut node_map: F,\n        mut edge_map: G,\n    ) -> Graph<N2, E2, Ty, Ix>\n    where\n        F: FnMut(NodeIndex<Ix>, &'a N) -> N2,\n        G: FnMut(EdgeIndex<Ix>, &'a E) -> E2,{\n        let mut g = Graph::with_capacity(self.node_count(), self.edge_count());\n        g.nodes.extend(enumerate(&self.nodes).map(|(i, node)| Node {\n            weight: node_map(NodeIndex::new(i), &node.weight),\n            next: node.next,\n        }));\n        g.edges.extend(enumerate(&self.edges).map(|(i, edge)| Edge {\n            weight: edge_map(EdgeIndex::new(i), &edge.weight),\n            next: edge.next,\n            node: edge.node,\n        }));\n        g\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::neighbors":["/// Return an iterator of all nodes with an edge starting from `a`.\n///\n/// - `Directed`: Outgoing edges from `a`.\n/// - `Undirected`: All edges from or to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is `NodeIndex<Ix>`.\n///\n/// Use [`.neighbors(a).detach()`][1] to get a neighbor walker that does\n/// not borrow from the graph.\n///\n/// [1]: struct.Neighbors.html#method.detach\npub fn neighbors(&self, a: NodeIndex<Ix>) -> Neighbors<E, Ix>{\n        self.neighbors_directed(a, Outgoing)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::neighbors_directed":["/// Return an iterator of all neighbors that have an edge between them and\n/// `a`, in the specified direction.\n/// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n///\n/// - `Directed`, `Outgoing`: All edges from `a`.\n/// - `Directed`, `Incoming`: All edges to `a`.\n/// - `Undirected`: All edges from or to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is `NodeIndex<Ix>`.\n///\n/// For a `Directed` graph, neighbors are listed in reverse order of their\n/// addition to the graph, so the most recently added edge's neighbor is\n/// listed first. The order in an `Undirected` graph is arbitrary.\n///\n/// Use [`.neighbors_directed(a, dir).detach()`][1] to get a neighbor walker that does\n/// not borrow from the graph.\n///\n/// [1]: struct.Neighbors.html#method.detach\npub fn neighbors_directed(&self, a: NodeIndex<Ix>, dir: Direction) -> Neighbors<E, Ix>{\n        let mut iter = self.neighbors_undirected(a);\n        if self.is_directed() {\n            let k = dir.index();\n            iter.next[1 - k] = EdgeIndex::end();\n            iter.skip_start = NodeIndex::end();\n        }\n        iter\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::neighbors_undirected":["/// Return an iterator of all neighbors that have an edge between them and\n/// `a`, in either direction.\n/// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n///\n/// - `Directed` and `Undirected`: All edges from or to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is `NodeIndex<Ix>`.\n///\n/// Use [`.neighbors_undirected(a).detach()`][1] to get a neighbor walker that does\n/// not borrow from the graph.\n///\n/// [1]: struct.Neighbors.html#method.detach\n///\npub fn neighbors_undirected(&self, a: NodeIndex<Ix>) -> Neighbors<E, Ix>{\n        Neighbors {\n            skip_start: a,\n            edges: &self.edges,\n            next: match self.nodes.get(a.index()) {\n                None => [EdgeIndex::end(), EdgeIndex::end()],\n                Some(n) => n.next,\n            },\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::next_edge":["/// Accessor for data structure internals: the next edge for the given direction.\npub fn next_edge(&self, e: EdgeIndex<Ix>, dir: Direction) -> Option<EdgeIndex<Ix>>{\n        match self.edges.get(e.index()) {\n            None => None,\n            Some(node) => {\n                let edix = node.next[dir.index()];\n                if edix == EdgeIndex::end() {\n                    None\n                } else {\n                    Some(edix)\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::node_count":["/// Return the number of nodes (vertices) in the graph.\n///\n/// Computes in **O(1)** time.\npub fn node_count(&self) -> usize{\n        self.nodes.len()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::node_indices":["/// Return an iterator over the node indices of the graph.\n///\n/// For example, in a rare case where a graph algorithm were not applicable,\n/// the following code will iterate through all nodes to find a\n/// specific index:\n///\n/// ```\n/// # use petgraph::Graph;\n/// # let mut g = Graph::<&str, i32>::new();\n/// # g.add_node(\"book\");\n/// let index = g.node_indices().find(|i| g[*i] == \"book\").unwrap();\n/// ```\npub fn node_indices(&self) -> NodeIndices<Ix>{\n        NodeIndices {\n            r: 0..self.node_count(),\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::node_weight":["/// Access the weight for node `a`.\n///\n/// Also available with indexing syntax: `&graph[a]`.\npub fn node_weight(&self, a: NodeIndex<Ix>) -> Option<&N>{\n        self.nodes.get(a.index()).map(|n| &n.weight)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::node_weight_mut":["/// Access the weight for node `a`, mutably.\n///\n/// Also available with indexing syntax: `&mut graph[a]`.\npub fn node_weight_mut(&mut self, a: NodeIndex<Ix>) -> Option<&mut N>{\n        self.nodes.get_mut(a.index()).map(|n| &mut n.weight)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::node_weights_mut":["/// Return an iterator yielding mutable access to all node weights.\n///\n/// The order in which weights are yielded matches the order of their\n/// node indices.\npub fn node_weights_mut(&mut self) -> NodeWeightsMut<N, Ix>{\n        NodeWeightsMut {\n            nodes: self.nodes.iter_mut(),\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::raw_edges":["/// Access the internal edge array.\npub fn raw_edges(&self) -> &[Edge<E, Ix>]{\n        &self.edges\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::raw_nodes":["/// Access the internal node array.\npub fn raw_nodes(&self) -> &[Node<N, Ix>]{\n        &self.nodes\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::remove_edge":["/// Remove an edge and return its edge weight, or `None` if it didn't exist.\n///\n/// Apart from `e`, this invalidates the last edge index in the graph\n/// (that edge will adopt the removed edge index).\n///\n/// Computes in **O(e')** time, where **e'** is the size of four particular edge lists, for\n/// the vertices of `e` and the vertices of another affected edge.\npub fn remove_edge(&mut self, e: EdgeIndex<Ix>) -> Option<E>{\n        // every edge is part of two lists,\n        // outgoing and incoming edges.\n        // Remove it from both\n        let (edge_node, edge_next) = match self.edges.get(e.index()) {\n            None => return None,\n            Some(x) => (x.node, x.next),\n        };\n        // Remove the edge from its in and out lists by replacing it with\n        // a link to the next in the list.\n        self.change_edge_links(edge_node, e, edge_next);\n        self.remove_edge_adjust_indices(e)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::remove_edge_adjust_indices":["fn remove_edge_adjust_indices(&mut self, e: EdgeIndex<Ix>) -> Option<E>{\n        // swap_remove the edge -- only the removed edge\n        // and the edge swapped into place are affected and need updating\n        // indices.\n        let edge = self.edges.swap_remove(e.index());\n        let swap = match self.edges.get(e.index()) {\n            // no elment needed to be swapped.\n            None => return Some(edge.weight),\n            Some(ed) => ed.node,\n        };\n        let swapped_e = EdgeIndex::new(self.edges.len());\n\n        // Update the edge lists by replacing links to the old index by references to the new\n        // edge index.\n        self.change_edge_links(swap, swapped_e, [e, e]);\n        Some(edge.weight)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::remove_node":["/// Remove `a` from the graph if it exists, and return its weight.\n/// If it doesn't exist in the graph, return `None`.\n///\n/// Apart from `a`, this invalidates the last node index in the graph\n/// (that node will adopt the removed node index). Edge indices are\n/// invalidated as they would be following the removal of each edge\n/// with an endpoint in `a`.\n///\n/// Computes in **O(e')** time, where **e'** is the number of affected\n/// edges, including *n* calls to `.remove_edge()` where *n* is the number\n/// of edges with an endpoint in `a`, and including the edges with an\n/// endpoint in the displaced node.\npub fn remove_node(&mut self, a: NodeIndex<Ix>) -> Option<N>{\n        self.nodes.get(a.index())?;\n        for d in &DIRECTIONS {\n            let k = d.index();\n\n            // Remove all edges from and to this node.\n            loop {\n                let next = self.nodes[a.index()].next[k];\n                if next == EdgeIndex::end() {\n                    break;\n                }\n                let ret = self.remove_edge(next);\n                debug_assert!(ret.is_some());\n                let _ = ret;\n            }\n        }\n\n        // Use swap_remove -- only the swapped-in node is going to change\n        // NodeIndex<Ix>, so we only have to walk its edges and update them.\n\n        let node = self.nodes.swap_remove(a.index());\n\n        // Find the edge lists of the node that had to relocate.\n        // It may be that no node had to relocate, then we are done already.\n        let swap_edges = match self.nodes.get(a.index()) {\n            None => return Some(node.weight),\n            Some(ed) => ed.next,\n        };\n\n        // The swapped element's old index\n        let old_index = NodeIndex::new(self.nodes.len());\n        let new_index = a;\n\n        // Adjust the starts of the out edges, and ends of the in edges.\n        for &d in &DIRECTIONS {\n            let k = d.index();\n            let mut edges = edges_walker_mut(&mut self.edges, swap_edges[k], d);\n            while let Some(curedge) = edges.next_edge() {\n                debug_assert!(curedge.node[k] == old_index);\n                curedge.node[k] = new_index;\n            }\n        }\n        Some(node.weight)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_edges":["/// Reserves capacity for at least `additional` more edges to be inserted in\n/// the graph. Graph may reserve more space to avoid frequent reallocations.\n///\n/// **Panics** if the new capacity overflows `usize`.\npub fn reserve_edges(&mut self, additional: usize){\n        self.edges.reserve(additional);\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_exact_edges":["/// Reserves the minimum capacity for exactly `additional` more edges to be\n/// inserted in the graph.\n/// Does nothing if the capacity is already sufficient.\n///\n/// Prefer `reserve_edges` if future insertions are expected.\n///\n/// **Panics** if the new capacity overflows `usize`.\npub fn reserve_exact_edges(&mut self, additional: usize){\n        self.edges.reserve_exact(additional);\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_exact_nodes":["/// Reserves the minimum capacity for exactly `additional` more nodes to be\n/// inserted in the graph. Does nothing if the capacity is already\n/// sufficient.\n///\n/// Prefer `reserve_nodes` if future insertions are expected.\n///\n/// **Panics** if the new capacity overflows `usize`.\npub fn reserve_exact_nodes(&mut self, additional: usize){\n        self.nodes.reserve_exact(additional);\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_nodes":["/// Reserves capacity for at least `additional` more nodes to be inserted in\n/// the graph. Graph may reserve more space to avoid frequent reallocations.\n///\n/// **Panics** if the new capacity overflows `usize`.\npub fn reserve_nodes(&mut self, additional: usize){\n        self.nodes.reserve(additional);\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::retain_edges":["/// Keep all edges that return `true` from the `visit` closure,\n/// remove the others.\n///\n/// `visit` is provided a proxy reference to the graph, so that\n/// the graph can be walked and associated data modified.\n///\n/// The order edges are visited is not specified.\npub fn retain_edges<F>(&mut self, mut visit: F)\n    where\n        F: FnMut(Frozen<Self>, EdgeIndex<Ix>) -> bool,{\n        for index in self.edge_indices().rev() {\n            if !visit(Frozen(self), index) {\n                let ret = self.remove_edge(index);\n                debug_assert!(ret.is_some());\n                let _ = ret;\n            }\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::retain_nodes":["/// Keep all nodes that return `true` from the `visit` closure,\n/// remove the others.\n///\n/// `visit` is provided a proxy reference to the graph, so that\n/// the graph can be walked and associated data modified.\n///\n/// The order nodes are visited is not specified.\npub fn retain_nodes<F>(&mut self, mut visit: F)\n    where\n        F: FnMut(Frozen<Self>, NodeIndex<Ix>) -> bool,{\n        for index in self.node_indices().rev() {\n            if !visit(Frozen(self), index) {\n                let ret = self.remove_node(index);\n                debug_assert!(ret.is_some());\n                let _ = ret;\n            }\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::reverse":["/// Reverse the direction of all edges\npub fn reverse(&mut self){\n        // swap edge endpoints,\n        // edge incoming / outgoing lists,\n        // node incoming / outgoing lists\n        for edge in &mut self.edges {\n            edge.node.swap(0, 1);\n            edge.next.swap(0, 1);\n        }\n        for node in &mut self.nodes {\n            node.next.swap(0, 1);\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::shrink_to_fit":["/// Shrinks the capacity of the graph as much as possible.\npub fn shrink_to_fit(&mut self){\n        self.nodes.shrink_to_fit();\n        self.edges.shrink_to_fit();\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::shrink_to_fit_edges":["/// Shrinks the capacity of the underlying edges collection as much as possible.\npub fn shrink_to_fit_edges(&mut self){\n        self.edges.shrink_to_fit();\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::shrink_to_fit_nodes":["/// Shrinks the capacity of the underlying nodes collection as much as possible.\npub fn shrink_to_fit_nodes(&mut self){\n        self.nodes.shrink_to_fit();\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::update_edge":["/// Add or update an edge from `a` to `b`.\n/// If the edge already exists, its weight is updated.\n///\n/// Return the index of the affected edge.\n///\n/// Computes in **O(e')** time, where **e'** is the number of edges\n/// connected to `a` (and `b`, if the graph edges are undirected).\n///\n/// **Panics** if any of the nodes don't exist.\npub fn update_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> EdgeIndex<Ix>{\n        if let Some(ix) = self.find_edge(a, b) {\n            if let Some(ed) = self.edge_weight_mut(ix) {\n                *ed = weight;\n                return ix;\n            }\n        }\n        self.add_edge(a, b, weight)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Ty, Ix>::with_capacity":["/// Create a new `Graph` with estimated capacity.\npub fn with_capacity(nodes: usize, edges: usize) -> Self{\n        Graph {\n            nodes: Vec::with_capacity(nodes),\n            edges: Vec::with_capacity(edges),\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E, Undirected>::new_undirected":["/// Create a new `Graph` with undirected edges.\n///\n/// This is a convenience method. Use `Graph::with_capacity` or `Graph::default` for\n/// a constructor that is generic in all the type parameters of `Graph`.\npub fn new_undirected() -> Self{\n        Graph {\n            nodes: Vec::new(),\n            edges: Vec::new(),\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Graph::<N, E>::new":["/// Create a new `Graph` with directed edges.\n///\n/// This is a convenience method. Use `Graph::with_capacity` or `Graph::default` for\n/// a constructor that is generic in all the type parameters of `Graph`.\npub fn new() -> Self{\n        Graph {\n            nodes: Vec::new(),\n            edges: Vec::new(),\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::GraphIndex":["/// A  `GraphIndex` is a node or edge index.\npub trait GraphIndex: Copy {\n    #[doc(hidden)]\n    fn index(&self) -> usize;\n    #[doc(hidden)]\n    fn is_node_index() -> bool;\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::IndexType":["/// Trait for the unsigned integer type used for node and edge indices.\n///\n/// Marked `unsafe` because: the trait must faithfully preserve\n/// and convert index values.\npub unsafe trait IndexType: Copy + Default + Hash + Ord + fmt::Debug + 'static {\n    fn new(x: usize) -> Self;\n    fn index(&self) -> usize;\n    fn max() -> Self;\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Neighbors":["/// Iterator over the neighbors of a node.\n///\n/// Iterator element type is `NodeIndex<Ix>`.\n///\n/// Created with [`.neighbors()`][1], [`.neighbors_directed()`][2] or\n/// [`.neighbors_undirected()`][3].\n///\n/// [1]: struct.Graph.html#method.neighbors\n/// [2]: struct.Graph.html#method.neighbors_directed\n/// [3]: struct.Graph.html#method.neighbors_undirected\npub struct Neighbors<'a, E: 'a, Ix: 'a = DefaultIx> {\n    /// starting node to skip over\n    skip_start: NodeIndex<Ix>,\n    edges: &'a [Edge<E, Ix>],\n    next: [EdgeIndex<Ix>; 2],\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Neighbors::<'a, E, Ix>::detach":["/// Return a “walker” object that can be used to step through the\n/// neighbors and edges from the origin node.\n///\n/// Note: The walker does not borrow from the graph, this is to allow mixing\n/// edge walking with mutating the graph's weights.\npub fn detach(&self) -> WalkNeighbors<Ix>{\n        WalkNeighbors {\n            skip_start: self.skip_start,\n            next: self.next,\n        }\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Node":["/// The graph's node type.\npub struct Node<N, Ix = DefaultIx> {\n    /// Associated node data.\n    pub weight: N,\n    /// Next edge in outgoing and incoming edge lists.\n    next: [EdgeIndex<Ix>; 2],\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Node::<N, Ix>::next_edge":["/// Accessor for data structure internals: the first edge in the given direction.\npub fn next_edge(&self, dir: Direction) -> EdgeIndex<Ix>{\n        self.next[dir.index()]\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::NodeIndex":["/// Node identifier.\npub struct NodeIndex<Ix = DefaultIx>(Ix);","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::NodeIndex::<Ix>::_into_edge":["fn _into_edge(self) -> EdgeIndex<Ix>{\n        EdgeIndex(self.0)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::NodeIndex::<Ix>::end":["#[inline]\npub fn end() -> Self{\n        NodeIndex(IndexType::max())\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::NodeIndex::<Ix>::index":["#[inline]\npub fn index(self) -> usize{\n        self.0.index()\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::NodeIndex::<Ix>::new":["#[inline]\npub fn new(x: usize) -> Self{\n        NodeIndex(IndexType::new(x))\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::NodeIndices":["/// Iterator over the node indices of a graph.\npub struct NodeIndices<Ix = DefaultIx> {\n    r: Range<usize>,\n    ty: PhantomData<fn() -> Ix>,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::NodeReferences":["/// Iterator over all nodes of a graph.\npub struct NodeReferences<'a, N: 'a, Ix: IndexType = DefaultIx> {\n    iter: iter::Enumerate<slice::Iter<'a, Node<N, Ix>>>,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::NodeWeightsMut":["/// Iterator yielding mutable access to all node weights.\npub struct NodeWeightsMut<'a, N: 'a, Ix: IndexType = DefaultIx> {\n    nodes: ::std::slice::IterMut<'a, Node<N, Ix>>,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::Pair":["enum Pair<T> {\n    Both(T, T),\n    One(T),\n    None,\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::WalkNeighbors":["/// A “walker” object that can be used to step through the edge list of a node.\n///\n/// Created with [`.detach()`](struct.Neighbors.html#method.detach).\n///\n/// The walker does not borrow from the graph, so it lets you step through\n/// neighbors or incident edges while also mutating graph weights, as\n/// in the following example:\n///\n/// ```\n/// use petgraph::{Graph, Incoming};\n/// use petgraph::visit::Dfs;\n///\n/// let mut gr = Graph::new();\n/// let a = gr.add_node(0.);\n/// let b = gr.add_node(0.);\n/// let c = gr.add_node(0.);\n/// gr.add_edge(a, b, 3.);\n/// gr.add_edge(b, c, 2.);\n/// gr.add_edge(c, b, 1.);\n///\n/// // step through the graph and sum incoming edges into the node weight\n/// let mut dfs = Dfs::new(&gr, a);\n/// while let Some(node) = dfs.next(&gr) {\n///     // use a detached neighbors walker\n///     let mut edges = gr.neighbors_directed(node, Incoming).detach();\n///     while let Some(edge) = edges.next_edge(&gr) {\n///         gr[node] += gr[edge];\n///     }\n/// }\n///\n/// // check the result\n/// assert_eq!(gr[a], 0.);\n/// assert_eq!(gr[b], 4.);\n/// assert_eq!(gr[c], 2.);\n/// ```\npub struct WalkNeighbors<Ix> {\n    skip_start: NodeIndex<Ix>,\n    next: [EdgeIndex<Ix>; 2],\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::WalkNeighbors::<Ix>::next":["/// Step to the next edge and its endpoint node in the walk for graph `g`.\n///\n/// The next node indices are always the others than the starting point\n/// where the `WalkNeighbors` value was created.\n/// For an `Outgoing` walk, the target nodes,\n/// for an `Incoming` walk, the source nodes of the edge.\npub fn next<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &Graph<N, E, Ty, Ix>,\n    ) -> Option<(EdgeIndex<Ix>, NodeIndex<Ix>)>{\n        // First any outgoing edges\n        match g.edges.get(self.next[0].index()) {\n            None => {}\n            Some(edge) => {\n                let ed = self.next[0];\n                self.next[0] = edge.next[0];\n                return Some((ed, edge.node[1]));\n            }\n        }\n        // Then incoming edges\n        // For an \"undirected\" iterator (traverse both incoming\n        // and outgoing edge lists), make sure we don't double\n        // count selfloops by skipping them in the incoming list.\n        while let Some(edge) = g.edges.get(self.next[1].index()) {\n            let ed = self.next[1];\n            self.next[1] = edge.next[1];\n            if edge.node[0] != self.skip_start {\n                return Some((ed, edge.node[0]));\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::WalkNeighbors::<Ix>::next_edge":["pub fn next_edge<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &Graph<N, E, Ty, Ix>,\n    ) -> Option<EdgeIndex<Ix>>{\n        self.next(g).map(|t| t.0)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::WalkNeighbors::<Ix>::next_node":["pub fn next_node<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &Graph<N, E, Ty, Ix>,\n    ) -> Option<NodeIndex<Ix>>{\n        self.next(g).map(|t| t.1)\n    }","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::edge_index":["/// Short version of `EdgeIndex::new`\npub fn edge_index<Ix: IndexType>(index: usize) -> EdgeIndex<Ix>{\n    EdgeIndex::new(index)\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::edges_walker_mut":["fn edges_walker_mut<E, Ix>(\n    edges: &mut [Edge<E, Ix>],\n    next: EdgeIndex<Ix>,\n    dir: Direction,\n) -> EdgesWalkerMut<E, Ix>\nwhere\n    Ix: IndexType,{\n    EdgesWalkerMut { edges, next, dir }\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::frozen::<impl data::DataMap for graph_impl::Frozen<'a, G>>::edge_weight":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl data::DataMap for graph_impl::Frozen<'a, G>>::node_weight":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl data::DataMapMut for graph_impl::Frozen<'a, G>>::edge_weight_mut":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl data::DataMapMut for graph_impl::Frozen<'a, G>>::node_weight_mut":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl graph_impl::Frozen<'a, G>>::new":["/// Create a new `Frozen` from a mutable reference to a graph.\npub fn new(gr: &'a mut G) -> Self{\n        Frozen(gr)\n    }","Real(LocalPath(\"src/graph_impl/frozen.rs\"))"],"graph_impl::frozen::<impl graph_impl::Frozen<'a, graph_impl::Graph<N, E, Ty, Ix>>>::index_twice_mut":["/// Index the `Graph` by two indices, any combination of\n/// node or edge indices is fine.\n///\n/// **Panics** if the indices are equal or if they are out of bounds.\npub fn index_twice_mut<T, U>(\n        &mut self,\n        i: T,\n        j: U,\n    ) -> (\n        &mut <Graph<N, E, Ty, Ix> as Index<T>>::Output,\n        &mut <Graph<N, E, Ty, Ix> as Index<U>>::Output,\n    )\n    where\n        Graph<N, E, Ty, Ix>: IndexMut<T> + IndexMut<U>,\n        T: GraphIndex,\n        U: GraphIndex,{\n        self.0.index_twice_mut(i, j)\n    }","Real(LocalPath(\"src/graph_impl/frozen.rs\"))"],"graph_impl::frozen::<impl std::ops::Deref for graph_impl::Frozen<'a, G>>::deref":["fn deref(&self) -> &G{\n        self.0\n    }","Real(LocalPath(\"src/graph_impl/frozen.rs\"))"],"graph_impl::frozen::<impl std::ops::Index<I> for graph_impl::Frozen<'a, G>>::index":["fn index(&self, i: I) -> &G::Output{\n        self.0.index(i)\n    }","Real(LocalPath(\"src/graph_impl/frozen.rs\"))"],"graph_impl::frozen::<impl std::ops::IndexMut<I> for graph_impl::Frozen<'a, G>>::index_mut":["fn index_mut(&mut self, i: I) -> &mut G::Output{\n        self.0.index_mut(i)\n    }","Real(LocalPath(\"src/graph_impl/frozen.rs\"))"],"graph_impl::frozen::<impl visit::GetAdjacencyMatrix for graph_impl::Frozen<'a, G>>::adjacency_matrix":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::GetAdjacencyMatrix for graph_impl::Frozen<'a, G>>::is_adjacent":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::IntoEdgeReferences for &'b graph_impl::Frozen<'a, G>>::edge_references":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::IntoEdges for &'b graph_impl::Frozen<'a, G>>::edges":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::IntoEdgesDirected for &'b graph_impl::Frozen<'a, G>>::edges_directed":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::IntoNeighbors for &'b graph_impl::Frozen<'a, G>>::neighbors":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::IntoNeighborsDirected for &'b graph_impl::Frozen<'a, G>>::neighbors_directed":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::IntoNodeIdentifiers for &'b graph_impl::Frozen<'a, G>>::node_identifiers":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::IntoNodeReferences for &'b graph_impl::Frozen<'a, G>>::node_references":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::NodeCount for graph_impl::Frozen<'a, G>>::node_count":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::NodeIndexable for graph_impl::Frozen<'a, G>>::from_index":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::NodeIndexable for graph_impl::Frozen<'a, G>>::node_bound":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::NodeIndexable for graph_impl::Frozen<'a, G>>::to_index":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::Visitable for graph_impl::Frozen<'a, G>>::reset_map":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*){\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::frozen::<impl visit::Visitable for graph_impl::Frozen<'a, G>>::visit_map":["fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) $(-> $mret{\n                    $self_map!(self).$method_name($($marg),*)\n                }","Real(LocalPath(\"src/visit/macros.rs\"))"],"graph_impl::index_twice":["/// Get mutable references at index `a` and `b`.\nfn index_twice<T>(slc: &mut [T], a: usize, b: usize) -> Pair<&mut T>{\n    if max(a, b) >= slc.len() {\n        Pair::None\n    } else if a == b {\n        Pair::One(&mut slc[max(a, b)])\n    } else {\n        // safe because a, b are in bounds and distinct\n        unsafe {\n            let ar = &mut *(slc.get_unchecked_mut(a) as *mut _);\n            let br = &mut *(slc.get_unchecked_mut(b) as *mut _);\n            Pair::Both(ar, br)\n        }\n    }\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::node_index":["/// Short version of `NodeIndex::new`\npub fn node_index<Ix: IndexType>(index: usize) -> NodeIndex<Ix>{\n    NodeIndex::new(index)\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graph_impl::stable_graph::<impl std::convert::From<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix>> for graph_impl::Graph<N, E, Ty, Ix>>::from":["fn from(graph: StableGraph<N, E, Ty, Ix>) -> Self{\n        let mut result_g = Graph::with_capacity(graph.node_count(), graph.edge_count());\n        // mapping from old node index to new node index\n        let mut node_index_map = vec![NodeIndex::end(); graph.node_bound()];\n\n        for (i, node) in enumerate(graph.g.nodes) {\n            if let Some(nw) = node.weight {\n                node_index_map[i] = result_g.add_node(nw);\n            }\n        }\n        for edge in graph.g.edges {\n            let source_index = edge.source().index();\n            let target_index = edge.target().index();\n            if let Some(ew) = edge.weight {\n                let source = node_index_map[source_index];\n                let target = node_index_map[target_index];\n                debug_assert!(source != NodeIndex::end());\n                debug_assert!(target != NodeIndex::end());\n                result_g.add_edge(source, target, ew);\n            }\n        }\n        result_g\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::EdgeIndices":["/// Iterator over the edge indices of a graph.\npub struct EdgeIndices<'a, E: 'a, Ix: 'a = DefaultIx> {\n    iter: iter::Enumerate<slice::Iter<'a, Edge<Option<E>, Ix>>>,\n}","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::EdgeReference":["/// Reference to a `StableGraph` edge.\npub struct EdgeReference<'a, E: 'a, Ix = DefaultIx> {\n    index: EdgeIndex<Ix>,\n    node: [NodeIndex<Ix>; 2],\n    weight: &'a E,\n}","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::EdgeReference::<'a, E, Ix>::weight":["/// Access the edge’s weight.\n///\n/// **NOTE** that this method offers a longer lifetime\n/// than the trait (unfortunately they don't match yet).\npub fn weight(&self) -> &'a E{\n        self.weight\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::EdgeReferences":["/// Iterator over all edges of a graph.\npub struct EdgeReferences<'a, E: 'a, Ix: 'a = DefaultIx> {\n    iter: iter::Enumerate<slice::Iter<'a, Edge<Option<E>, Ix>>>,\n}","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::Edges":["/// Iterator over the edges of from or to a node\npub struct Edges<'a, E: 'a, Ty, Ix: 'a = DefaultIx>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n{\n    /// starting node to skip over\n    skip_start: NodeIndex<Ix>,\n    edges: &'a [Edge<Option<E>, Ix>],\n\n    /// Next edge to visit.\n    next: [EdgeIndex<Ix>; 2],\n\n    /// For directed graphs: the direction to iterate in\n    /// For undirected graphs: the direction of edges\n    direction: Direction,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::Externals":["/// An iterator over either the nodes without edges to them or from them.\npub struct Externals<'a, N: 'a, Ty, Ix: IndexType = DefaultIx> {\n    iter: iter::Enumerate<slice::Iter<'a, Node<Option<N>, Ix>>>,\n    dir: Direction,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::Neighbors":["/// Iterator over the neighbors of a node.\n///\n/// Iterator element type is `NodeIndex`.\npub struct Neighbors<'a, E: 'a, Ix: 'a = DefaultIx> {\n    /// starting node to skip over\n    skip_start: NodeIndex<Ix>,\n    edges: &'a [Edge<Option<E>, Ix>],\n    next: [EdgeIndex<Ix>; 2],\n}","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::Neighbors::<'a, E, Ix>::detach":["/// Return a “walker” object that can be used to step through the\n/// neighbors and edges from the origin node.\n///\n/// Note: The walker does not borrow from the graph, this is to allow mixing\n/// edge walking with mutating the graph's weights.\npub fn detach(&self) -> WalkNeighbors<Ix>{\n        WalkNeighbors {\n            inner: super::WalkNeighbors {\n                skip_start: self.skip_start,\n                next: self.next,\n            },\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::NodeIndices":["/// Iterator over the node indices of a graph.\npub struct NodeIndices<'a, N: 'a, Ix: 'a = DefaultIx> {\n    iter: iter::Enumerate<slice::Iter<'a, Node<Option<N>, Ix>>>,\n}","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::NodeReferences":["/// Iterator over all nodes of a graph.\npub struct NodeReferences<'a, N: 'a, Ix: IndexType = DefaultIx> {\n    iter: iter::Enumerate<slice::Iter<'a, Node<Option<N>, Ix>>>,\n}","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph":["/// `StableGraph<N, E, Ty, Ix>` is a graph datastructure using an adjacency\n/// list representation.\n///\n/// The graph **does not invalidate** any unrelated node or edge indices when\n/// items are removed.\n///\n/// `StableGraph` is parameterized over:\n///\n/// - Associated data `N` for nodes and `E` for edges, also called *weights*.\n///   The associated data can be of arbitrary type.\n/// - Edge type `Ty` that determines whether the graph edges are directed or undirected.\n/// - Index type `Ix`, which determines the maximum size of the graph.\n///\n/// The graph uses **O(|V| + |E|)** space, and allows fast node and edge insert\n/// and efficient graph search.\n///\n/// It implements **O(e')** edge lookup and edge and node removals, where **e'**\n/// is some local measure of edge count.\n///\n/// - Nodes and edges are each numbered in an interval from *0* to some number\n/// *m*, but *not all* indices in the range are valid, since gaps are formed\n/// by deletions.\n///\n/// - You can select graph index integer type after the size of the graph. A smaller\n/// size may have better performance.\n///\n/// - Using indices allows mutation while traversing the graph, see `Dfs`.\n///\n/// - The `StableGraph` is a regular rust collection and is `Send` and `Sync`\n/// (as long as associated data `N` and `E` are).\n///\n/// - Indices don't allow as much compile time checking as references.\n///\n/// Depends on crate feature `stable_graph` (default). *Stable Graph is still\n/// missing a few methods compared to Graph. You can contribute to help it\n/// achieve parity.*\npub struct StableGraph<N, E, Ty = Directed, Ix = DefaultIx> {\n    g: Graph<Option<N>, Option<E>, Ty, Ix>,\n    node_count: usize,\n    edge_count: usize,\n\n    // node and edge free lists (both work the same way)\n    //\n    // free_node, if not NodeIndex::end(), points to a node index\n    // that is vacant (after a deletion).  The next item in the list is kept in\n    // that Node's Node.next[0] field. For Node, it's a node index stored\n    // in an EdgeIndex location, and the _into_edge()/_into_node() methods\n    // convert.\n    free_node: NodeIndex<Ix>,\n    free_edge: EdgeIndex<Ix>,\n}","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_edge":["/// Add an edge from `a` to `b` to the graph, with its associated\n/// data `weight`.\n///\n/// Return the index of the new edge.\n///\n/// Computes in **O(1)** time.\n///\n/// **Panics** if any of the nodes don't exist.<br>\n/// **Panics** if the `StableGraph` is at the maximum number of edges for\n/// its index type.\n///\n/// **Note:** `StableGraph` allows adding parallel (“duplicate”) edges.\npub fn add_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> EdgeIndex<Ix>{\n        let edge_idx;\n        let mut new_edge = None::<Edge<_, _>>;\n        {\n            let edge: &mut Edge<_, _>;\n\n            if self.free_edge != EdgeIndex::end() {\n                edge_idx = self.free_edge;\n                edge = &mut self.g.edges[edge_idx.index()];\n                let _old = replace(&mut edge.weight, Some(weight));\n                debug_assert!(_old.is_none());\n                self.free_edge = edge.next[0];\n                edge.node = [a, b];\n            } else {\n                edge_idx = EdgeIndex::new(self.g.edges.len());\n                assert!(<Ix as IndexType>::max().index() == !0 || EdgeIndex::end() != edge_idx);\n                new_edge = Some(Edge {\n                    weight: Some(weight),\n                    node: [a, b],\n                    next: [EdgeIndex::end(); 2],\n                });\n                edge = new_edge.as_mut().unwrap();\n            }\n\n            let wrong_index = match index_twice(&mut self.g.nodes, a.index(), b.index()) {\n                Pair::None => Some(cmp::max(a.index(), b.index())),\n                Pair::One(an) => {\n                    if an.weight.is_none() {\n                        Some(a.index())\n                    } else {\n                        edge.next = an.next;\n                        an.next[0] = edge_idx;\n                        an.next[1] = edge_idx;\n                        None\n                    }\n                }\n                Pair::Both(an, bn) => {\n                    // a and b are different indices\n                    if an.weight.is_none() {\n                        Some(a.index())\n                    } else if bn.weight.is_none() {\n                        Some(b.index())\n                    } else {\n                        edge.next = [an.next[0], bn.next[1]];\n                        an.next[0] = edge_idx;\n                        bn.next[1] = edge_idx;\n                        None\n                    }\n                }\n            };\n            if let Some(i) = wrong_index {\n                panic!(\n                    \"StableGraph::add_edge: node index {} is not a node in the graph\",\n                    i\n                );\n            }\n            self.edge_count += 1;\n        }\n        if let Some(edge) = new_edge {\n            self.g.edges.push(edge);\n        }\n        edge_idx\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_node":["/// Add a node (also called vertex) with associated data `weight` to the graph.\n///\n/// Computes in **O(1)** time.\n///\n/// Return the index of the new node.\n///\n/// **Panics** if the `StableGraph` is at the maximum number of nodes for\n/// its index type.\npub fn add_node(&mut self, weight: N) -> NodeIndex<Ix>{\n        let index = if self.free_node != NodeIndex::end() {\n            let node_idx = self.free_node;\n            let node_slot = &mut self.g.nodes[node_idx.index()];\n            let _old = replace(&mut node_slot.weight, Some(weight));\n            debug_assert!(_old.is_none());\n            self.free_node = node_slot.next[0]._into_node();\n            node_slot.next[0] = EdgeIndex::end();\n            node_idx\n        } else {\n            self.g.add_node(Some(weight))\n        };\n        self.node_count += 1;\n        index\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_vacant_edge":["/// free_edge: Which free list to update for the vacancy\nfn add_vacant_edge(&mut self, free_edge: &mut EdgeIndex<Ix>){\n        let edge_idx = EdgeIndex::new(self.g.edges.len());\n        debug_assert!(edge_idx != EdgeIndex::end());\n        let mut edge = Edge {\n            weight: None,\n            node: [NodeIndex::end(); 2],\n            next: [EdgeIndex::end(); 2],\n        };\n        edge.next[0] = *free_edge;\n        *free_edge = edge_idx;\n        self.g.edges.push(edge);\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_vacant_node":["/// free_node: Which free list to update for the vacancy\nfn add_vacant_node(&mut self, free_node: &mut NodeIndex<Ix>){\n        let node_idx = self.g.add_node(None);\n        // link the free list\n        let node_slot = &mut self.g.nodes[node_idx.index()];\n        node_slot.next[0] = free_node._into_edge();\n        *free_node = node_idx;\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::capacity":["/// Return the current node and edge capacity of the graph.\npub fn capacity(&self) -> (usize, usize){\n        self.g.capacity()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::check_free_lists":["#[cfg(debug_assertions)]\nfn check_free_lists(&self){\n        let mut free_node = self.free_node;\n        let mut free_node_len = 0;\n        while free_node != NodeIndex::end() {\n            if let Some(n) = self.g.nodes.get(free_node.index()) {\n                if n.weight.is_none() {\n                    free_node = n.next[0]._into_node();\n                    free_node_len += 1;\n                    continue;\n                }\n                debug_assert!(\n                    false,\n                    \"Corrupt free list: pointing to existing {:?}\",\n                    free_node.index()\n                );\n            }\n            debug_assert!(false, \"Corrupt free list: missing {:?}\", free_node.index());\n        }\n        debug_assert_eq!(self.node_count(), self.raw_nodes().len() - free_node_len);\n\n        let mut free_edge_len = 0;\n        let mut free_edge = self.free_edge;\n        while free_edge != EdgeIndex::end() {\n            if let Some(n) = self.g.edges.get(free_edge.index()) {\n                if n.weight.is_none() {\n                    free_edge = n.next[0];\n                    free_edge_len += 1;\n                    continue;\n                }\n                debug_assert!(\n                    false,\n                    \"Corrupt free list: pointing to existing {:?}\",\n                    free_node.index()\n                );\n            }\n            debug_assert!(false, \"Corrupt free list: missing {:?}\", free_edge.index());\n        }\n        debug_assert_eq!(self.edge_count(), self.raw_edges().len() - free_edge_len);\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::clear":["/// Remove all nodes and edges\npub fn clear(&mut self){\n        self.node_count = 0;\n        self.edge_count = 0;\n        self.free_node = NodeIndex::end();\n        self.free_edge = EdgeIndex::end();\n        self.g.clear();\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::clear_edges":["/// Remove all edges\npub fn clear_edges(&mut self){\n        self.edge_count = 0;\n        self.free_edge = EdgeIndex::end();\n        self.g.edges.clear();\n        // clear edges without touching the free list\n        for node in &mut self.g.nodes {\n            if node.weight.is_some() {\n                node.next = [EdgeIndex::end(), EdgeIndex::end()];\n            }\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::contains_edge":["/// Lookup if there is an edge from `a` to `b`.\n///\n/// Computes in **O(e')** time, where **e'** is the number of edges\n/// connected to `a` (and `b`, if the graph edges are undirected).\npub fn contains_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool{\n        self.find_edge(a, b).is_some()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::contains_node":["pub fn contains_node(&self, a: NodeIndex<Ix>) -> bool{\n        self.get_node(a).is_some()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_bound":["fn edge_bound(&self) -> usize{\n        self.edge_references()\n            .next_back()\n            .map_or(0, |edge| edge.id().index() + 1)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_count":["/// Return the number of edges in the graph.\n///\n/// Computes in **O(1)** time.\npub fn edge_count(&self) -> usize{\n        self.edge_count\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_endpoints":["/// Access the source and target nodes for `e`.\npub fn edge_endpoints(&self, e: EdgeIndex<Ix>) -> Option<(NodeIndex<Ix>, NodeIndex<Ix>)>{\n        match self.g.edges.get(e.index()) {\n            Some(ed) if ed.weight.is_some() => Some((ed.source(), ed.target())),\n            _otherwise => None,\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_indices":["/// Return an iterator over the edge indices of the graph\npub fn edge_indices(&self) -> EdgeIndices<E, Ix>{\n        EdgeIndices {\n            iter: enumerate(self.raw_edges()),\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_weight":["/// Access the weight for edge `e`.\n///\n/// Also available with indexing syntax: `&graph[e]`.\npub fn edge_weight(&self, e: EdgeIndex<Ix>) -> Option<&E>{\n        match self.g.edges.get(e.index()) {\n            Some(ed) => ed.weight.as_ref(),\n            None => None,\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_weight_mut":["/// Access the weight for edge `e`, mutably\n///\n/// Also available with indexing syntax: `&mut graph[e]`.\npub fn edge_weight_mut(&mut self, e: EdgeIndex<Ix>) -> Option<&mut E>{\n        match self.g.edges.get_mut(e.index()) {\n            Some(ed) => ed.weight.as_mut(),\n            None => None,\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_weights_mut":["/// Return an iterator yielding mutable access to all edge weights.\n///\n/// The order in which weights are yielded matches the order of their edge\n/// indices.\npub fn edge_weights_mut(&mut self) -> impl Iterator<Item = &mut E>{\n        self.g\n            .edge_weights_mut()\n            .flat_map(|maybe_edge| maybe_edge.iter_mut())\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edges":["/// Return an iterator of all edges of `a`.\n///\n/// - `Directed`: Outgoing edges from `a`.\n/// - `Undirected`: All edges connected to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is `EdgeReference<E, Ix>`.\npub fn edges(&self, a: NodeIndex<Ix>) -> Edges<E, Ty, Ix>{\n        self.edges_directed(a, Outgoing)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edges_directed":["/// Return an iterator of all edges of `a`, in the specified direction.\n///\n/// - `Directed`, `Outgoing`: All edges from `a`.\n/// - `Directed`, `Incoming`: All edges to `a`.\n/// - `Undirected`, `Outgoing`: All edges connected to `a`, with `a` being the source of each\n///   edge.\n/// - `Undirected`, `Incoming`: All edges connected to `a`, with `a` being the target of each\n///   edge.\n///\n/// Produces an empty iterator if the node `a` doesn't exist.<br>\n/// Iterator element type is `EdgeReference<E, Ix>`.\npub fn edges_directed(&self, a: NodeIndex<Ix>, dir: Direction) -> Edges<E, Ty, Ix>{\n        Edges {\n            skip_start: a,\n            edges: &self.g.edges,\n            direction: dir,\n            next: match self.get_node(a) {\n                None => [EdgeIndex::end(), EdgeIndex::end()],\n                Some(n) => n.next,\n            },\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::extend_with_edges":["/// Extend the graph from an iterable of edges.\n///\n/// Node weights `N` are set to default values.\n/// Edge weights `E` may either be specified in the list,\n/// or they are filled with default values.\n///\n/// Nodes are inserted automatically to match the edges.\npub fn extend_with_edges<I>(&mut self, iterable: I)\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,{\n        let iter = iterable.into_iter();\n\n        for elt in iter {\n            let (source, target, weight) = elt.into_weighted_edge();\n            let (source, target) = (source.into(), target.into());\n            let nx = cmp::max(source, target);\n            while nx.index() >= self.node_count() {\n                self.add_node(N::default());\n            }\n            self.add_edge(source, target, weight);\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::externals":["/// Return an iterator over either the nodes without edges to them\n/// (`Incoming`) or from them (`Outgoing`).\n///\n/// An *internal* node has both incoming and outgoing edges.\n/// The nodes in `.externals(Incoming)` are the source nodes and\n/// `.externals(Outgoing)` are the sinks of the graph.\n///\n/// For a graph with undirected edges, both the sinks and the sources are\n/// just the nodes without edges.\n///\n/// The whole iteration computes in **O(|V|)** time.\npub fn externals(&self, dir: Direction) -> Externals<N, Ty, Ix>{\n        Externals {\n            iter: self.raw_nodes().iter().enumerate(),\n            dir,\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::filter_map":["/// Create a new `StableGraph` by mapping nodes and edges.\n/// A node or edge may be mapped to `None` to exclude it from\n/// the resulting graph.\n///\n/// Nodes are mapped first with the `node_map` closure, then\n/// `edge_map` is called for the edges that have not had any endpoint\n/// removed.\n///\n/// The resulting graph has the structure of a subgraph of the original graph.\n/// Nodes and edges that are not removed maintain their old node or edge\n/// indices.\npub fn filter_map<'a, F, G, N2, E2>(\n        &'a self,\n        mut node_map: F,\n        mut edge_map: G,\n    ) -> StableGraph<N2, E2, Ty, Ix>\n    where\n        F: FnMut(NodeIndex<Ix>, &'a N) -> Option<N2>,\n        G: FnMut(EdgeIndex<Ix>, &'a E) -> Option<E2>,{\n        let node_bound = self.node_bound();\n        let edge_bound = self.edge_bound();\n        let mut result_g = StableGraph::with_capacity(node_bound, edge_bound);\n        // use separate free lists so that\n        // add_node / add_edge below do not reuse the tombstones\n        let mut free_node = NodeIndex::end();\n        let mut free_edge = EdgeIndex::end();\n\n        // the stable graph keeps the node map itself\n\n        for (i, node) in enumerate(self.raw_nodes()) {\n            if i >= node_bound {\n                break;\n            }\n            if let Some(node_weight) = node.weight.as_ref() {\n                if let Some(new_weight) = node_map(NodeIndex::new(i), node_weight) {\n                    result_g.add_node(new_weight);\n                    continue;\n                }\n            }\n            result_g.add_vacant_node(&mut free_node);\n        }\n        for (i, edge) in enumerate(self.raw_edges()) {\n            if i >= edge_bound {\n                break;\n            }\n            let source = edge.source();\n            let target = edge.target();\n            if let Some(edge_weight) = edge.weight.as_ref() {\n                if result_g.contains_node(source) && result_g.contains_node(target) {\n                    if let Some(new_weight) = edge_map(EdgeIndex::new(i), edge_weight) {\n                        result_g.add_edge(source, target, new_weight);\n                        continue;\n                    }\n                }\n            }\n            result_g.add_vacant_edge(&mut free_edge);\n        }\n        result_g.free_node = free_node;\n        result_g.free_edge = free_edge;\n        result_g.check_free_lists();\n        result_g\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::find_edge":["/// Lookup an edge from `a` to `b`.\n///\n/// Computes in **O(e')** time, where **e'** is the number of edges\n/// connected to `a` (and `b`, if the graph edges are undirected).\npub fn find_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> Option<EdgeIndex<Ix>>{\n        if !self.is_directed() {\n            self.find_edge_undirected(a, b).map(|(ix, _)| ix)\n        } else {\n            match self.get_node(a) {\n                None => None,\n                Some(node) => self.g.find_edge_directed_from_node(node, b),\n            }\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::find_edge_undirected":["/// Lookup an edge between `a` and `b`, in either direction.\n///\n/// If the graph is undirected, then this is equivalent to `.find_edge()`.\n///\n/// Return the edge index and its directionality, with `Outgoing` meaning\n/// from `a` to `b` and `Incoming` the reverse,\n/// or `None` if the edge does not exist.\npub fn find_edge_undirected(\n        &self,\n        a: NodeIndex<Ix>,\n        b: NodeIndex<Ix>,\n    ) -> Option<(EdgeIndex<Ix>, Direction)>{\n        match self.get_node(a) {\n            None => None,\n            Some(node) => self.g.find_edge_undirected_from_node(node, b),\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::from_edges":["/// Create a new `StableGraph` from an iterable of edges.\n///\n/// Node weights `N` are set to default values.\n/// Edge weights `E` may either be specified in the list,\n/// or they are filled with default values.\n///\n/// Nodes are inserted automatically to match the edges.\n///\n/// ```\n/// use petgraph::stable_graph::StableGraph;\n///\n/// let gr = StableGraph::<(), i32>::from_edges(&[\n///     (0, 1), (0, 2), (0, 3),\n///     (1, 2), (1, 3),\n///     (2, 3),\n/// ]);\n/// ```\npub fn from_edges<I>(iterable: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,{\n        let mut g = Self::with_capacity(0, 0);\n        g.extend_with_edges(iterable);\n        g\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::get_node":["fn get_node(&self, a: NodeIndex<Ix>) -> Option<&Node<Option<N>, Ix>>{\n        self.g\n            .nodes\n            .get(a.index())\n            .and_then(|node| node.weight.as_ref().map(move |_| node))\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::index_twice_mut":["/// Index the `StableGraph` by two indices, any combination of\n/// node or edge indices is fine.\n///\n/// **Panics** if the indices are equal or if they are out of bounds.\npub fn index_twice_mut<T, U>(\n        &mut self,\n        i: T,\n        j: U,\n    ) -> (\n        &mut <Self as Index<T>>::Output,\n        &mut <Self as Index<U>>::Output,\n    )\n    where\n        Self: IndexMut<T> + IndexMut<U>,\n        T: GraphIndex,\n        U: GraphIndex,{\n        assert!(T::is_node_index() != U::is_node_index() || i.index() != j.index());\n\n        // Allow two mutable indexes here -- they are nonoverlapping\n        unsafe {\n            let self_mut = self as *mut _;\n            (\n                <Self as IndexMut<T>>::index_mut(&mut *self_mut, i),\n                <Self as IndexMut<U>>::index_mut(&mut *self_mut, j),\n            )\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::is_directed":["/// Whether the graph has directed edges or not.\n#[inline]\npub fn is_directed(&self) -> bool{\n        Ty::is_directed()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::map":["/// Create a new `StableGraph` by mapping node and\n/// edge weights to new values.\n///\n/// The resulting graph has the same structure and the same\n/// graph indices as `self`.\npub fn map<'a, F, G, N2, E2>(\n        &'a self,\n        mut node_map: F,\n        mut edge_map: G,\n    ) -> StableGraph<N2, E2, Ty, Ix>\n    where\n        F: FnMut(NodeIndex<Ix>, &'a N) -> N2,\n        G: FnMut(EdgeIndex<Ix>, &'a E) -> E2,{\n        let g = self.g.map(\n            move |i, w| w.as_ref().map(|w| node_map(i, w)),\n            move |i, w| w.as_ref().map(|w| edge_map(i, w)),\n        );\n        StableGraph {\n            g,\n            node_count: self.node_count,\n            edge_count: self.edge_count,\n            free_node: self.free_node,\n            free_edge: self.free_edge,\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::neighbors":["/// Return an iterator of all nodes with an edge starting from `a`.\n///\n/// - `Directed`: Outgoing edges from `a`.\n/// - `Undirected`: All edges connected to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is `NodeIndex<Ix>`.\n///\n/// Use [`.neighbors(a).detach()`][1] to get a neighbor walker that does\n/// not borrow from the graph.\n///\n/// [1]: struct.Neighbors.html#method.detach\npub fn neighbors(&self, a: NodeIndex<Ix>) -> Neighbors<E, Ix>{\n        self.neighbors_directed(a, Outgoing)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::neighbors_directed":["/// Return an iterator of all neighbors that have an edge between them and `a`,\n/// in the specified direction.\n/// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n///\n/// - `Directed`, `Outgoing`: All edges from `a`.\n/// - `Directed`, `Incoming`: All edges to `a`.\n/// - `Undirected`: All edges connected to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is `NodeIndex<Ix>`.\n///\n/// Use [`.neighbors_directed(a, dir).detach()`][1] to get a neighbor walker that does\n/// not borrow from the graph.\n///\n/// [1]: struct.Neighbors.html#method.detach\npub fn neighbors_directed(&self, a: NodeIndex<Ix>, dir: Direction) -> Neighbors<E, Ix>{\n        let mut iter = self.neighbors_undirected(a);\n        if self.is_directed() {\n            let k = dir.index();\n            iter.next[1 - k] = EdgeIndex::end();\n            iter.skip_start = NodeIndex::end();\n        }\n        iter\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::neighbors_undirected":["/// Return an iterator of all neighbors that have an edge between them and `a`,\n/// in either direction.\n/// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n///\n/// - `Directed` and `Undirected`: All edges connected to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is `NodeIndex<Ix>`.\n///\n/// Use [`.neighbors_undirected(a).detach()`][1] to get a neighbor walker that does\n/// not borrow from the graph.\n///\n/// [1]: struct.Neighbors.html#method.detach\npub fn neighbors_undirected(&self, a: NodeIndex<Ix>) -> Neighbors<E, Ix>{\n        Neighbors {\n            skip_start: a,\n            edges: &self.g.edges,\n            next: match self.get_node(a) {\n                None => [EdgeIndex::end(), EdgeIndex::end()],\n                Some(n) => n.next,\n            },\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_count":["/// Return the number of nodes (vertices) in the graph.\n///\n/// Computes in **O(1)** time.\npub fn node_count(&self) -> usize{\n        self.node_count\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_indices":["/// Return an iterator over the node indices of the graph\npub fn node_indices(&self) -> NodeIndices<N, Ix>{\n        NodeIndices {\n            iter: enumerate(self.raw_nodes()),\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_weight":["/// Access the weight for node `a`.\n///\n/// Also available with indexing syntax: `&graph[a]`.\npub fn node_weight(&self, a: NodeIndex<Ix>) -> Option<&N>{\n        match self.g.nodes.get(a.index()) {\n            Some(no) => no.weight.as_ref(),\n            None => None,\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_weight_mut":["/// Access the weight for node `a`, mutably.\n///\n/// Also available with indexing syntax: `&mut graph[a]`.\npub fn node_weight_mut(&mut self, a: NodeIndex<Ix>) -> Option<&mut N>{\n        match self.g.nodes.get_mut(a.index()) {\n            Some(no) => no.weight.as_mut(),\n            None => None,\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_weights_mut":["/// Return an iterator yielding mutable access to all node weights.\n///\n/// The order in which weights are yielded matches the order of their node\n/// indices.\npub fn node_weights_mut(&mut self) -> impl Iterator<Item = &mut N>{\n        self.g\n            .node_weights_mut()\n            .flat_map(|maybe_node| maybe_node.iter_mut())\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::raw_edges":["fn raw_edges(&self) -> &[Edge<Option<E>, Ix>]{\n        self.g.raw_edges()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::raw_nodes":["fn raw_nodes(&self) -> &[Node<Option<N>, Ix>]{\n        self.g.raw_nodes()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::remove_edge":["/// Remove an edge and return its edge weight, or `None` if it didn't exist.\n///\n/// Invalidates the edge index `e` but no other.\n///\n/// Computes in **O(e')** time, where **e'** is the number of edges\n/// connected to the same endpoints as `e`.\npub fn remove_edge(&mut self, e: EdgeIndex<Ix>) -> Option<E>{\n        // every edge is part of two lists,\n        // outgoing and incoming edges.\n        // Remove it from both\n        let (is_edge, edge_node, edge_next) = match self.g.edges.get(e.index()) {\n            None => return None,\n            Some(x) => (x.weight.is_some(), x.node, x.next),\n        };\n        if !is_edge {\n            return None;\n        }\n\n        // Remove the edge from its in and out lists by replacing it with\n        // a link to the next in the list.\n        self.g.change_edge_links(edge_node, e, edge_next);\n\n        // Clear the edge and put it in the free list\n        let edge = &mut self.g.edges[e.index()];\n        edge.next = [self.free_edge, EdgeIndex::end()];\n        edge.node = [NodeIndex::end(), NodeIndex::end()];\n        self.free_edge = e;\n        self.edge_count -= 1;\n        edge.weight.take()\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::remove_node":["/// Remove `a` from the graph if it exists, and return its weight.\n/// If it doesn't exist in the graph, return `None`.\n///\n/// The node index `a` is invalidated, but none other.\n/// Edge indices are invalidated as they would be following the removal of\n/// each edge with an endpoint in `a`.\n///\n/// Computes in **O(e')** time, where **e'** is the number of affected\n/// edges, including *n* calls to `.remove_edge()` where *n* is the number\n/// of edges with an endpoint in `a`.\npub fn remove_node(&mut self, a: NodeIndex<Ix>) -> Option<N>{\n        let node_weight = self.g.nodes.get_mut(a.index())?.weight.take()?;\n        for d in &DIRECTIONS {\n            let k = d.index();\n\n            // Remove all edges from and to this node.\n            loop {\n                let next = self.g.nodes[a.index()].next[k];\n                if next == EdgeIndex::end() {\n                    break;\n                }\n                let ret = self.remove_edge(next);\n                debug_assert!(ret.is_some());\n                let _ = ret;\n            }\n        }\n\n        let node_slot = &mut self.g.nodes[a.index()];\n        //let node_weight = replace(&mut self.g.nodes[a.index()].weight, Entry::Empty(self.free_node));\n        //self.g.nodes[a.index()].next = [EdgeIndex::end(), EdgeIndex::end()];\n        node_slot.next = [self.free_node._into_edge(), EdgeIndex::end()];\n        self.free_node = a;\n        self.node_count -= 1;\n\n        Some(node_weight)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::retain_edges":["/// Keep all edges that return `true` from the `visit` closure,\n/// remove the others.\n///\n/// `visit` is provided a proxy reference to the graph, so that\n/// the graph can be walked and associated data modified.\n///\n/// The order edges are visited is not specified.\n///\n/// The edge indices of the removed edes are invalidated, but none other.\n///\n/// Computes in **O(e'')** time, **e'** is the number of affected edges,\n/// including the calls to `.remove_edge()` for each removed edge.\npub fn retain_edges<F>(&mut self, mut visit: F)\n    where\n        F: FnMut(Frozen<Self>, EdgeIndex<Ix>) -> bool,{\n        for i in 0..self.edge_bound() {\n            let ix = edge_index(i);\n            if self.edge_weight(ix).is_some() && !visit(Frozen(self), ix) {\n                self.remove_edge(ix);\n            }\n        }\n        self.check_free_lists();\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::retain_nodes":["/// Keep all nodes that return `true` from the `visit` closure,\n/// remove the others.\n///\n/// `visit` is provided a proxy reference to the graph, so that\n/// the graph can be walked and associated data modified.\n///\n/// The order nodes are visited is not specified.\n///\n/// The node indices of the removed nodes are invalidated, but none other.\n/// Edge indices are invalidated as they would be following the removal of\n/// each edge with an endpoint in a removed node.\n///\n/// Computes in **O(n + e')** time, where **n** is the number of node indices and\n///  **e'** is the number of affected edges, including *n* calls to `.remove_edge()`\n/// where *n* is the number of edges with an endpoint in a removed node.\npub fn retain_nodes<F>(&mut self, mut visit: F)\n    where\n        F: FnMut(Frozen<Self>, NodeIndex<Ix>) -> bool,{\n        for i in 0..self.node_bound() {\n            let ix = node_index(i);\n            if self.contains_node(ix) && !visit(Frozen(self), ix) {\n                self.remove_node(ix);\n            }\n        }\n        self.check_free_lists();\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::update_edge":["/// Add or update an edge from `a` to `b`.\n/// If the edge already exists, its weight is updated.\n///\n/// Return the index of the affected edge.\n///\n/// Computes in **O(e')** time, where **e'** is the number of edges\n/// connected to `a` (and `b`, if the graph edges are undirected).\n///\n/// **Panics** if any of the nodes don't exist.\npub fn update_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> EdgeIndex<Ix>{\n        if let Some(ix) = self.find_edge(a, b) {\n            self[ix] = weight;\n            return ix;\n        }\n        self.add_edge(a, b, weight)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::with_capacity":["/// Create a new `StableGraph` with estimated capacity.\npub fn with_capacity(nodes: usize, edges: usize) -> Self{\n        StableGraph {\n            g: Graph::with_capacity(nodes, edges),\n            node_count: 0,\n            edge_count: 0,\n            free_node: NodeIndex::end(),\n            free_edge: EdgeIndex::end(),\n        }\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::StableGraph::<N, E>::new":["/// Create a new `StableGraph` with directed edges.\n///\n/// This is a convenience method. See `StableGraph::with_capacity`\n/// or `StableGraph::default` for a constructor that is generic in all the\n/// type parameters of `StableGraph`.\npub fn new() -> Self{\n        Self::with_capacity(0, 0)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::WalkNeighbors":["/// A “walker” object that can be used to step through the edge list of a node.\n///\n/// See [*.detach()*](struct.Neighbors.html#method.detach) for more information.\n///\n/// The walker does not borrow from the graph, so it lets you step through\n/// neighbors or incident edges while also mutating graph weights, as\n/// in the following example:\n///\n/// ```\n/// use petgraph::visit::Dfs;\n/// use petgraph::Incoming;\n/// use petgraph::stable_graph::StableGraph;\n///\n/// let mut gr = StableGraph::new();\n/// let a = gr.add_node(0.);\n/// let b = gr.add_node(0.);\n/// let c = gr.add_node(0.);\n/// gr.add_edge(a, b, 3.);\n/// gr.add_edge(b, c, 2.);\n/// gr.add_edge(c, b, 1.);\n///\n/// // step through the graph and sum incoming edges into the node weight\n/// let mut dfs = Dfs::new(&gr, a);\n/// while let Some(node) = dfs.next(&gr) {\n///     // use a detached neighbors walker\n///     let mut edges = gr.neighbors_directed(node, Incoming).detach();\n///     while let Some(edge) = edges.next_edge(&gr) {\n///         gr[node] += gr[edge];\n///     }\n/// }\n///\n/// // check the result\n/// assert_eq!(gr[a], 0.);\n/// assert_eq!(gr[b], 4.);\n/// assert_eq!(gr[c], 2.);\n/// ```\npub struct WalkNeighbors<Ix> {\n    inner: super::WalkNeighbors<Ix>,\n}","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::WalkNeighbors::<Ix>::next":["/// Step to the next edge and its endpoint node in the walk for graph `g`.\n///\n/// The next node indices are always the others than the starting point\n/// where the `WalkNeighbors` value was created.\n/// For an `Outgoing` walk, the target nodes,\n/// for an `Incoming` walk, the source nodes of the edge.\npub fn next<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &StableGraph<N, E, Ty, Ix>,\n    ) -> Option<(EdgeIndex<Ix>, NodeIndex<Ix>)>{\n        self.inner.next(&g.g)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::WalkNeighbors::<Ix>::next_edge":["pub fn next_edge<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &StableGraph<N, E, Ty, Ix>,\n    ) -> Option<EdgeIndex<Ix>>{\n        self.next(g).map(|t| t.0)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::WalkNeighbors::<Ix>::next_node":["pub fn next_node<N, E, Ty: EdgeType>(\n        &mut self,\n        g: &StableGraph<N, E, Ty, Ix>,\n    ) -> Option<NodeIndex<Ix>>{\n        self.next(g).map(|t| t.1)\n    }","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::stable_graph::swap_pair":["fn swap_pair<T>(mut x: [T; 2]) -> [T; 2]{\n    x.swap(0, 1);\n    x\n}","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))"],"graph_impl::swap_pair":["fn swap_pair<T>(mut x: [T; 2]) -> [T; 2]{\n    x.swap(0, 1);\n    x\n}","Real(LocalPath(\"src/graph_impl/mod.rs\"))"],"graphmap::AllEdges":["pub struct AllEdges<'a, N, E: 'a, Ty>\nwhere\n    N: 'a + NodeTrait,\n{\n    inner: IndexMapIter<'a, (N, N), E>,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::AllEdgesMut":["pub struct AllEdgesMut<'a, N, E: 'a, Ty>\nwhere\n    N: 'a + NodeTrait,\n{\n    inner: IndexMapIterMut<'a, (N, N), E>,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::CompactDirection":["enum CompactDirection {\n    Outgoing,\n    Incoming,\n}","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::Edges":["pub struct Edges<'a, N, E: 'a, Ty>\nwhere\n    N: 'a + NodeTrait,\n    Ty: EdgeType,\n{\n    from: N,\n    edges: &'a IndexMap<(N, N), E>,\n    iter: Neighbors<'a, N, Ty>,\n}","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap":["/// `GraphMap<N, E, Ty>` is a graph datastructure using an associative array\n/// of its node weights `N`.\n///\n/// It uses an combined adjacency list and sparse adjacency matrix\n/// representation, using **O(|V| + |E|)** space, and allows testing for edge\n/// existence in constant time.\n///\n/// `GraphMap` is parameterized over:\n///\n/// - Associated data `N` for nodes and `E` for edges, called *weights*.\n/// - The node weight `N` must implement `Copy` and will be used as node\n/// identifier, duplicated into several places in the data structure.\n/// It must be suitable as a hash table key (implementing `Eq + Hash`).\n/// The node type must also implement `Ord` so that the implementation can\n/// order the pair (`a`, `b`) for an edge connecting any two nodes `a` and `b`.\n/// - `E` can be of arbitrary type.\n/// - Edge type `Ty` that determines whether the graph edges are directed or\n/// undirected.\n///\n/// You can use the type aliases `UnGraphMap` and `DiGraphMap` for convenience.\n///\n/// `GraphMap` does not allow parallel edges, but self loops are allowed.\n///\n/// Depends on crate feature `graphmap` (default).\npub struct GraphMap<N, E, Ty> {\n    nodes: IndexMap<N, Vec<(N, CompactDirection)>>,\n    edges: IndexMap<(N, N), E>,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::add_edge":["/// Add an edge connecting `a` and `b` to the graph, with associated\n/// data `weight`. For a directed graph, the edge is directed from `a`\n/// to `b`.\n///\n/// Inserts nodes `a` and/or `b` if they aren't already part of the graph.\n///\n/// Return `None` if the edge did not previously exist, otherwise,\n/// the associated data is updated and the old value is returned\n/// as `Some(old_weight)`.\n///\n/// ```\n/// // Create a GraphMap with directed edges, and add one edge to it\n/// use petgraph::graphmap::DiGraphMap;\n///\n/// let mut g = DiGraphMap::new();\n/// g.add_edge(\"x\", \"y\", -1);\n/// assert_eq!(g.node_count(), 2);\n/// assert_eq!(g.edge_count(), 1);\n/// assert!(g.contains_edge(\"x\", \"y\"));\n/// assert!(!g.contains_edge(\"y\", \"x\"));\n/// ```\npub fn add_edge(&mut self, a: N, b: N, weight: E) -> Option<E>{\n        if let old @ Some(_) = self.edges.insert(Self::edge_key(a, b), weight) {\n            old\n        } else {\n            // insert in the adjacency list if it's a new edge\n            self.nodes\n                .entry(a)\n                .or_insert_with(|| Vec::with_capacity(1))\n                .push((b, CompactDirection::Outgoing));\n            if a != b {\n                // self loops don't have the Incoming entry\n                self.nodes\n                    .entry(b)\n                    .or_insert_with(|| Vec::with_capacity(1))\n                    .push((a, CompactDirection::Incoming));\n            }\n            None\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::add_node":["/// Add node `n` to the graph.\npub fn add_node(&mut self, n: N) -> N{\n        self.nodes.entry(n).or_insert(Vec::new());\n        n\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::all_edges":["/// Return an iterator over all edges of the graph with their weight in arbitrary order.\n///\n/// Iterator element type is `(N, N, &E)`\npub fn all_edges(&self) -> AllEdges<N, E, Ty>{\n        AllEdges {\n            inner: self.edges.iter(),\n            ty: self.ty,\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::all_edges_mut":["/// Return an iterator over all edges of the graph in arbitrary order, with a mutable reference\n/// to their weight.\n///\n/// Iterator element type is `(N, N, &mut E)`\npub fn all_edges_mut(&mut self) -> AllEdgesMut<N, E, Ty>{\n        AllEdgesMut {\n            inner: self.edges.iter_mut(),\n            ty: self.ty,\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::capacity":["/// Return the current node and edge capacity of the graph.\npub fn capacity(&self) -> (usize, usize){\n        (self.nodes.capacity(), self.edges.capacity())\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::clear":["/// Remove all nodes and edges\npub fn clear(&mut self){\n        self.nodes.clear();\n        self.edges.clear();\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::contains_edge":["/// Return `true` if the edge connecting `a` with `b` is contained in the graph.\npub fn contains_edge(&self, a: N, b: N) -> bool{\n        self.edges.contains_key(&Self::edge_key(a, b))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::contains_node":["/// Return `true` if the node is contained in the graph.\npub fn contains_node(&self, n: N) -> bool{\n        self.nodes.contains_key(&n)\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::edge_count":["/// Return the number of edges in the graph.\npub fn edge_count(&self) -> usize{\n        self.edges.len()\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::edge_key":["/// Use their natural order to map the node pair (a, b) to a canonical edge id.\n#[inline]\nfn edge_key(a: N, b: N) -> (N, N){\n        if Ty::is_directed() || a <= b {\n            (a, b)\n        } else {\n            (b, a)\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::edge_weight":["/// Return a reference to the edge weight connecting `a` with `b`, or\n/// `None` if the edge does not exist in the graph.\npub fn edge_weight(&self, a: N, b: N) -> Option<&E>{\n        self.edges.get(&Self::edge_key(a, b))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::edge_weight_mut":["/// Return a mutable reference to the edge weight connecting `a` with `b`, or\n/// `None` if the edge does not exist in the graph.\npub fn edge_weight_mut(&mut self, a: N, b: N) -> Option<&mut E>{\n        self.edges.get_mut(&Self::edge_key(a, b))\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::edges":["/// Return an iterator of target nodes with an edge starting from `a`,\n/// paired with their respective edge weights.\n///\n/// - `Directed`: Outgoing edges from `a`.\n/// - `Undirected`: All edges from or to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is `(N, &E)`.\npub fn edges(&self, from: N) -> Edges<N, E, Ty>{\n        Edges {\n            from,\n            iter: self.neighbors(from),\n            edges: &self.edges,\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::from_edges":["/// Create a new `GraphMap` from an iterable of edges.\n///\n/// Node values are taken directly from the list.\n/// Edge weights `E` may either be specified in the list,\n/// or they are filled with default values.\n///\n/// Nodes are inserted automatically to match the edges.\n///\n/// ```\n/// use petgraph::graphmap::UnGraphMap;\n///\n/// // Create a new undirected GraphMap.\n/// // Use a type hint to have `()` be the edge weight type.\n/// let gr = UnGraphMap::<_, ()>::from_edges(&[\n///     (0, 1), (0, 2), (0, 3),\n///     (1, 2), (1, 3),\n///     (2, 3),\n/// ]);\n/// ```\npub fn from_edges<I>(iterable: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E, NodeId = N>,{\n        Self::from_iter(iterable)\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::into_graph":["/// Return a `Graph` that corresponds to this `GraphMap`.\n///\n/// 1. Note that node and edge indices in the `Graph` have nothing in common\n///    with the `GraphMap`s node weights `N`. The node weights `N` are used as\n///    node weights in the resulting `Graph`, too.\n/// 2. Note that the index type is user-chosen.\n///\n/// Computes in **O(|V| + |E|)** time (average).\n///\n/// **Panics** if the number of nodes or edges does not fit with\n/// the resulting graph's index type.\npub fn into_graph<Ix>(self) -> Graph<N, E, Ty, Ix>\n    where\n        Ix: crate::graph::IndexType,{\n        // assuming two successive iterations of the same hashmap produce the same order\n        let mut gr = Graph::with_capacity(self.node_count(), self.edge_count());\n        for (&node, _) in &self.nodes {\n            gr.add_node(node);\n        }\n        for ((a, b), edge_weight) in self.edges {\n            let (ai, _, _) = self.nodes.get_full(&a).unwrap();\n            let (bi, _, _) = self.nodes.get_full(&b).unwrap();\n            gr.add_edge(node_index(ai), node_index(bi), edge_weight);\n        }\n        gr\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::is_directed":["/// Whether the graph has directed edges.\npub fn is_directed(&self) -> bool{\n        Ty::is_directed()\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::neighbors":["/// Return an iterator of all nodes with an edge starting from `a`.\n///\n/// - `Directed`: Outgoing edges from `a`.\n/// - `Undirected`: All edges from or to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is `N`.\npub fn neighbors(&self, a: N) -> Neighbors<N, Ty>{\n        Neighbors {\n            iter: match self.nodes.get(&a) {\n                Some(neigh) => neigh.iter(),\n                None => [].iter(),\n            },\n            ty: self.ty,\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::neighbors_directed":["/// Return an iterator of all neighbors that have an edge between them and\n/// `a`, in the specified direction.\n/// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n///\n/// - `Directed`, `Outgoing`: All edges from `a`.\n/// - `Directed`, `Incoming`: All edges to `a`.\n/// - `Undirected`: All edges from or to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is `N`.\npub fn neighbors_directed(&self, a: N, dir: Direction) -> NeighborsDirected<N, Ty>{\n        NeighborsDirected {\n            iter: match self.nodes.get(&a) {\n                Some(neigh) => neigh.iter(),\n                None => [].iter(),\n            },\n            start_node: a,\n            dir,\n            ty: self.ty,\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::new":["/// Create a new `GraphMap`\npub fn new() -> Self{\n        Self::default()\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::node_count":["/// Return the number of nodes in the graph.\npub fn node_count(&self) -> usize{\n        self.nodes.len()\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::nodes":["/// Return an iterator over the nodes of the graph.\n///\n/// Iterator element type is `N`.\npub fn nodes(&self) -> Nodes<N>{\n        Nodes {\n            iter: self.nodes.keys().cloned(),\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::remove_edge":["/// Remove edge from `a` to `b` from the graph and return the edge weight.\n///\n/// Return `None` if the edge didn't exist.\n///\n/// ```\n/// // Create a GraphMap with undirected edges, and add and remove an edge.\n/// use petgraph::graphmap::UnGraphMap;\n///\n/// let mut g = UnGraphMap::new();\n/// g.add_edge(\"x\", \"y\", -1);\n///\n/// let edge_data = g.remove_edge(\"y\", \"x\");\n/// assert_eq!(edge_data, Some(-1));\n/// assert_eq!(g.edge_count(), 0);\n/// ```\npub fn remove_edge(&mut self, a: N, b: N) -> Option<E>{\n        let exist1 = self.remove_single_edge(&a, &b, Outgoing);\n        let exist2 = if a != b {\n            self.remove_single_edge(&b, &a, Incoming)\n        } else {\n            exist1\n        };\n        let weight = self.edges.remove(&Self::edge_key(a, b));\n        debug_assert!(exist1 == exist2 && exist1 == weight.is_some());\n        weight\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::remove_node":["/// Return `true` if node `n` was removed.\n///\n/// Computes in **O(V)** time, due to the removal of edges with other nodes.\npub fn remove_node(&mut self, n: N) -> bool{\n        let links = match self.nodes.swap_remove(&n) {\n            None => return false,\n            Some(sus) => sus,\n        };\n        for (succ, _) in links {\n            // remove all successor links\n            self.remove_single_edge(&succ, &n, Incoming);\n            // Remove all edge values\n            self.edges.swap_remove(&Self::edge_key(n, succ));\n        }\n        true\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::remove_single_edge":["/// Remove edge relation from a to b\n///\n/// Return `true` if it did exist.\nfn remove_single_edge(&mut self, a: &N, b: &N, dir: Direction) -> bool{\n        match self.nodes.get_mut(a) {\n            None => false,\n            Some(sus) => {\n                if Ty::is_directed() {\n                    match sus\n                        .iter()\n                        .position(|elt| elt == &(*b, CompactDirection::from(dir)))\n                    {\n                        Some(index) => {\n                            sus.swap_remove(index);\n                            true\n                        }\n                        None => false,\n                    }\n                } else {\n                    match sus.iter().position(|elt| &elt.0 == b) {\n                        Some(index) => {\n                            sus.swap_remove(index);\n                            true\n                        }\n                        None => false,\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::GraphMap::<N, E, Ty>::with_capacity":["/// Create a new `GraphMap` with estimated capacity.\npub fn with_capacity(nodes: usize, edges: usize) -> Self{\n        GraphMap {\n            nodes: IndexMap::with_capacity(nodes),\n            edges: IndexMap::with_capacity(edges),\n            ty: PhantomData,\n        }\n    }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::Neighbors":["pub struct Neighbors<'a, N, Ty = Undirected>\nwhere\n    N: 'a,\n    Ty: EdgeType,\n{\n    iter: Iter<'a, (N, CompactDirection)>,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::NeighborsDirected":["pub struct NeighborsDirected<'a, N, Ty>\nwhere\n    N: 'a,\n    Ty: EdgeType,\n{\n    iter: Iter<'a, (N, CompactDirection)>,\n    start_node: N,\n    dir: Direction,\n    ty: PhantomData<Ty>,\n}","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::NodeIdentifiers":["pub struct NodeIdentifiers<'a, N, E: 'a, Ty>\nwhere\n    N: 'a + NodeTrait,\n{\n    iter: IndexMapIter<'a, N, Vec<(N, CompactDirection)>>,\n    ty: PhantomData<Ty>,\n    edge_ty: PhantomData<E>,\n}","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::NodeReferences":["pub struct NodeReferences<'a, N, E: 'a, Ty>\nwhere\n    N: 'a + NodeTrait,\n{\n    iter: IndexMapIter<'a, N, Vec<(N, CompactDirection)>>,\n    ty: PhantomData<Ty>,\n    edge_ty: PhantomData<E>,\n}","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::NodeTrait":["/// A trait group for `GraphMap`'s node identifier.\npub trait NodeTrait: Copy + Ord + Hash {}","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::Nodes":["pub struct $name <$($typarm),*> where $($bounds)* {\n            iter: $iter,\n        }","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::Ptr":["/// A reference that is hashed and compared by its pointer value.\n///\n/// `Ptr` is used for certain configurations of `GraphMap`,\n/// in particular in the combination where the node type for\n/// `GraphMap` is something of type for example `Ptr(&Cell<T>)`,\n/// with the `Cell<T>` being `TypedArena` allocated.\npub struct Ptr<'b, T: 'b>(pub &'b T);","Real(LocalPath(\"src/graphmap.rs\"))"],"graphmap::ptr_eq":["fn ptr_eq<T>(a: *const T, b: *const T) -> bool{\n    a == b\n}","Real(LocalPath(\"src/graphmap.rs\"))"],"isomorphism::NoSemanticMatch":["struct NoSemanticMatch;","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::SemanticMatcher":["trait SemanticMatcher<T> {\n    fn enabled() -> bool;\n    fn eq(&mut self, _: &T, _: &T) -> bool;\n}","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::Vf2State":["struct Vf2State<Ty, Ix> {\n    /// The current mapping M(s) of nodes from G0 → G1 and G1 → G0,\n    /// NodeIndex::end() for no mapping.\n    mapping: Vec<NodeIndex<Ix>>,\n    /// out[i] is non-zero if i is in either M_0(s) or Tout_0(s)\n    /// These are all the next vertices that are not mapped yet, but\n    /// have an outgoing edge from the mapping.\n    out: Vec<usize>,\n    /// ins[i] is non-zero if i is in either M_0(s) or Tin_0(s)\n    /// These are all the incoming vertices, those not mapped yet, but\n    /// have an edge from them into the mapping.\n    /// Unused if graph is undirected -- it's identical with out in that case.\n    ins: Vec<usize>,\n    out_size: usize,\n    ins_size: usize,\n    adjacency_matrix: FixedBitSet,\n    generation: usize,\n    _etype: marker::PhantomData<Ty>,\n}","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::Vf2State::<Ty, Ix>::is_complete":["/// Return **true** if we have a complete mapping\npub fn is_complete(&self) -> bool{\n        self.generation == self.mapping.len()\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::Vf2State::<Ty, Ix>::new":["pub fn new<N, E>(g: &Graph<N, E, Ty, Ix>) -> Self{\n        let c0 = g.node_count();\n        let mut state = Vf2State {\n            mapping: Vec::with_capacity(c0),\n            out: Vec::with_capacity(c0),\n            ins: Vec::with_capacity(c0 * (g.is_directed() as usize)),\n            out_size: 0,\n            ins_size: 0,\n            adjacency_matrix: g.adjacency_matrix(),\n            generation: 0,\n            _etype: marker::PhantomData,\n        };\n        for _ in 0..c0 {\n            state.mapping.push(NodeIndex::end());\n            state.out.push(0);\n            if Ty::is_directed() {\n                state.ins.push(0);\n            }\n        }\n        state\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::Vf2State::<Ty, Ix>::next_in_index":["/// Find the next (least) node in the Tin set.\npub fn next_in_index(&self, from_index: usize) -> Option<usize>{\n        if !Ty::is_directed() {\n            return None;\n        }\n        self.ins[from_index..]\n            .iter()\n            .enumerate()\n            .find(move |&(index, elt)| {\n                *elt > 0 && self.mapping[from_index + index] == NodeIndex::end()\n            })\n            .map(|(index, _)| index)\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::Vf2State::<Ty, Ix>::next_out_index":["/// Find the next (least) node in the Tout set.\npub fn next_out_index(&self, from_index: usize) -> Option<usize>{\n        self.out[from_index..]\n            .iter()\n            .enumerate()\n            .find(move |&(index, elt)| {\n                *elt > 0 && self.mapping[from_index + index] == NodeIndex::end()\n            })\n            .map(|(index, _)| index)\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::Vf2State::<Ty, Ix>::next_rest_index":["/// Find the next (least) node in the N - M set.\npub fn next_rest_index(&self, from_index: usize) -> Option<usize>{\n        self.mapping[from_index..]\n            .iter()\n            .enumerate()\n            .find(|&(_, elt)| *elt == NodeIndex::end())\n            .map(|(index, _)| index)\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::Vf2State::<Ty, Ix>::pop_mapping":["/// Restore the state to before the last added mapping\npub fn pop_mapping<N, E>(&mut self, from: NodeIndex<Ix>, g: &Graph<N, E, Ty, Ix>){\n        let s = self.generation;\n        self.generation -= 1;\n\n        // undo (n, m) mapping\n        self.mapping[from.index()] = NodeIndex::end();\n\n        // unmark in ins and outs\n        for ix in g.neighbors(from) {\n            if self.out[ix.index()] == s {\n                self.out[ix.index()] = 0;\n                self.out_size -= 1;\n            }\n        }\n        if g.is_directed() {\n            for ix in g.neighbors_directed(from, Incoming) {\n                if self.ins[ix.index()] == s {\n                    self.ins[ix.index()] = 0;\n                    self.ins_size -= 1;\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::Vf2State::<Ty, Ix>::push_mapping":["/// Add mapping **from** <-> **to** to the state.\npub fn push_mapping<N, E>(\n        &mut self,\n        from: NodeIndex<Ix>,\n        to: NodeIndex<Ix>,\n        g: &Graph<N, E, Ty, Ix>,\n    ){\n        self.generation += 1;\n        let s = self.generation;\n        self.mapping[from.index()] = to;\n        // update T0 & T1 ins/outs\n        // T0out: Node in G0 not in M0 but successor of a node in M0.\n        // st.out[0]: Node either in M0 or successor of M0\n        for ix in g.neighbors(from) {\n            if self.out[ix.index()] == 0 {\n                self.out[ix.index()] = s;\n                self.out_size += 1;\n            }\n        }\n        if g.is_directed() {\n            for ix in g.neighbors_directed(from, Incoming) {\n                if self.ins[ix.index()] == 0 {\n                    self.ins[ix.index()] = s;\n                    self.ins_size += 1;\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::is_isomorphic":["/// [Graph] Return `true` if the graphs `g0` and `g1` are isomorphic.\n///\n/// Using the VF2 algorithm, only matching graph syntactically (graph\n/// structure).\n///\n/// The graphs should not be multigraphs.\n///\n/// **Reference**\n///\n/// * Luigi P. Cordella, Pasquale Foggia, Carlo Sansone, Mario Vento;\n///   *A (Sub)Graph Isomorphism Algorithm for Matching Large Graphs*\npub fn is_isomorphic<N, E, Ty, Ix>(g0: &Graph<N, E, Ty, Ix>, g1: &Graph<N, E, Ty, Ix>) -> bool\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,{\n    if g0.node_count() != g1.node_count() || g0.edge_count() != g1.edge_count() {\n        return false;\n    }\n\n    let mut st = [Vf2State::new(g0), Vf2State::new(g1)];\n    try_match(&mut st, g0, g1, &mut NoSemanticMatch, &mut NoSemanticMatch).unwrap_or(false)\n}","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::is_isomorphic_matching":["/// [Graph] Return `true` if the graphs `g0` and `g1` are isomorphic.\n///\n/// Using the VF2 algorithm, examining both syntactic and semantic\n/// graph isomorphism (graph structure and matching node and edge weights).\n///\n/// The graphs should not be multigraphs.\npub fn is_isomorphic_matching<N, E, Ty, Ix, F, G>(\n    g0: &Graph<N, E, Ty, Ix>,\n    g1: &Graph<N, E, Ty, Ix>,\n    mut node_match: F,\n    mut edge_match: G,\n) -> bool\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n    F: FnMut(&N, &N) -> bool,\n    G: FnMut(&E, &E) -> bool,{\n    if g0.node_count() != g1.node_count() || g0.edge_count() != g1.edge_count() {\n        return false;\n    }\n\n    let mut st = [Vf2State::new(g0), Vf2State::new(g1)];\n    try_match(&mut st, g0, g1, &mut node_match, &mut edge_match).unwrap_or(false)\n}","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::try_match":["/// Return Some(bool) if isomorphism is decided, else None.\nfn try_match<N, E, Ty, Ix, F, G>(\n    mut st: &mut [Vf2State<Ty, Ix>; 2],\n    g0: &Graph<N, E, Ty, Ix>,\n    g1: &Graph<N, E, Ty, Ix>,\n    node_match: &mut F,\n    edge_match: &mut G,\n) -> Option<bool>\nwhere\n    Ty: EdgeType,\n    Ix: IndexType,\n    F: SemanticMatcher<N>,\n    G: SemanticMatcher<E>,{\n    if st[0].is_complete() {\n        return Some(true);\n    }\n    let g = [g0, g1];\n    let graph_indices = 0..2;\n    let end = NodeIndex::end();\n\n    // A \"depth first\" search of a valid mapping from graph 1 to graph 2\n\n    // F(s, n, m) -- evaluate state s and add mapping n <-> m\n\n    // Find least T1out node (in st.out[1] but not in M[1])\n    #[derive(Copy, Clone, PartialEq, Debug)]\n    enum OpenList {\n        Out,\n        In,\n        Other,\n    }\n\n    #[derive(Clone, PartialEq, Debug)]\n    enum Frame<N: marker::Copy> {\n        Outer,\n        Inner { nodes: [N; 2], open_list: OpenList },\n        Unwind { nodes: [N; 2], open_list: OpenList },\n    }\n\n    let next_candidate =\n        |st: &mut [Vf2State<Ty, Ix>; 2]| -> Option<(NodeIndex<Ix>, NodeIndex<Ix>, OpenList)> {\n            let mut to_index;\n            let mut from_index = None;\n            let mut open_list = OpenList::Out;\n            // Try the out list\n            to_index = st[1].next_out_index(0);\n\n            if to_index.is_some() {\n                from_index = st[0].next_out_index(0);\n                open_list = OpenList::Out;\n            }\n            // Try the in list\n            if to_index.is_none() || from_index.is_none() {\n                to_index = st[1].next_in_index(0);\n\n                if to_index.is_some() {\n                    from_index = st[0].next_in_index(0);\n                    open_list = OpenList::In;\n                }\n            }\n            // Try the other list -- disconnected graph\n            if to_index.is_none() || from_index.is_none() {\n                to_index = st[1].next_rest_index(0);\n                if to_index.is_some() {\n                    from_index = st[0].next_rest_index(0);\n                    open_list = OpenList::Other;\n                }\n            }\n            match (from_index, to_index) {\n                (Some(n), Some(m)) => Some((NodeIndex::new(n), NodeIndex::new(m), open_list)),\n                // No more candidates\n                _ => None,\n            }\n        };\n    let next_from_ix = |st: &mut [Vf2State<Ty, Ix>; 2],\n                        nx: NodeIndex<Ix>,\n                        open_list: OpenList|\n     -> Option<NodeIndex<Ix>> {\n        // Find the next node index to try on the `from` side of the mapping\n        let start = nx.index() + 1;\n        let cand0 = match open_list {\n            OpenList::Out => st[0].next_out_index(start),\n            OpenList::In => st[0].next_in_index(start),\n            OpenList::Other => st[0].next_rest_index(start),\n        }\n        .map(|c| c + start); // compensate for start offset.\n        match cand0 {\n            None => None, // no more candidates\n            Some(ix) => {\n                debug_assert!(ix >= start);\n                Some(NodeIndex::new(ix))\n            }\n        }\n    };\n    //fn pop_state(nodes: [NodeIndex<Ix>; 2]) {\n    let pop_state = |st: &mut [Vf2State<Ty, Ix>; 2], nodes: [NodeIndex<Ix>; 2]| {\n        // Restore state.\n        for j in graph_indices.clone() {\n            st[j].pop_mapping(nodes[j], g[j]);\n        }\n    };\n    //fn push_state(nodes: [NodeIndex<Ix>; 2]) {\n    let push_state = |st: &mut [Vf2State<Ty, Ix>; 2], nodes: [NodeIndex<Ix>; 2]| {\n        // Add mapping nx <-> mx to the state\n        for j in graph_indices.clone() {\n            st[j].push_mapping(nodes[j], nodes[1 - j], g[j]);\n        }\n    };\n    //fn is_feasible(nodes: [NodeIndex<Ix>; 2]) -> bool {\n    let mut is_feasible = |st: &mut [Vf2State<Ty, Ix>; 2], nodes: [NodeIndex<Ix>; 2]| -> bool {\n        // Check syntactic feasibility of mapping by ensuring adjacencies\n        // of nx map to adjacencies of mx.\n        //\n        // nx == map to => mx\n        //\n        // R_succ\n        //\n        // Check that every neighbor of nx is mapped to a neighbor of mx,\n        // then check the reverse, from mx to nx. Check that they have the same\n        // count of edges.\n        //\n        // Note: We want to check the lookahead measures here if we can,\n        // R_out: Equal for G0, G1: Card(Succ(G, n) ^ Tout); for both Succ and Pred\n        // R_in: Same with Tin\n        // R_new: Equal for G0, G1: Ñ n Pred(G, n); both Succ and Pred,\n        //      Ñ is G0 - M - Tin - Tout\n        // last attempt to add these did not speed up any of the testcases\n        let mut succ_count = [0, 0];\n        for j in graph_indices.clone() {\n            for n_neigh in g[j].neighbors(nodes[j]) {\n                succ_count[j] += 1;\n                // handle the self loop case; it's not in the mapping (yet)\n                let m_neigh = if nodes[j] != n_neigh {\n                    st[j].mapping[n_neigh.index()]\n                } else {\n                    nodes[1 - j]\n                };\n                if m_neigh == end {\n                    continue;\n                }\n                let has_edge =\n                    g[1 - j].is_adjacent(&st[1 - j].adjacency_matrix, nodes[1 - j], m_neigh);\n                if !has_edge {\n                    return false;\n                }\n            }\n        }\n        if succ_count[0] != succ_count[1] {\n            return false;\n        }\n        // R_pred\n        if g[0].is_directed() {\n            let mut pred_count = [0, 0];\n            for j in graph_indices.clone() {\n                for n_neigh in g[j].neighbors_directed(nodes[j], Incoming) {\n                    pred_count[j] += 1;\n                    // the self loop case is handled in outgoing\n                    let m_neigh = st[j].mapping[n_neigh.index()];\n                    if m_neigh == end {\n                        continue;\n                    }\n                    let has_edge =\n                        g[1 - j].is_adjacent(&st[1 - j].adjacency_matrix, m_neigh, nodes[1 - j]);\n                    if !has_edge {\n                        return false;\n                    }\n                }\n            }\n            if pred_count[0] != pred_count[1] {\n                return false;\n            }\n        }\n        // semantic feasibility: compare associated data for nodes\n        if F::enabled() && !node_match.eq(&g[0][nodes[0]], &g[1][nodes[1]]) {\n            return false;\n        }\n        // semantic feasibility: compare associated data for edges\n        if G::enabled() {\n            // outgoing edges\n            for j in graph_indices.clone() {\n                let mut edges = g[j].neighbors(nodes[j]).detach();\n                while let Some((n_edge, n_neigh)) = edges.next(g[j]) {\n                    // handle the self loop case; it's not in the mapping (yet)\n                    let m_neigh = if nodes[j] != n_neigh {\n                        st[j].mapping[n_neigh.index()]\n                    } else {\n                        nodes[1 - j]\n                    };\n                    if m_neigh == end {\n                        continue;\n                    }\n                    match g[1 - j].find_edge(nodes[1 - j], m_neigh) {\n                        Some(m_edge) => {\n                            if !edge_match.eq(&g[j][n_edge], &g[1 - j][m_edge]) {\n                                return false;\n                            }\n                        }\n                        None => unreachable!(), // covered by syntactic check\n                    }\n                }\n            }\n            // incoming edges\n            if g[0].is_directed() {\n                for j in graph_indices.clone() {\n                    let mut edges = g[j].neighbors_directed(nodes[j], Incoming).detach();\n                    while let Some((n_edge, n_neigh)) = edges.next(g[j]) {\n                        // the self loop case is handled in outgoing\n                        let m_neigh = st[j].mapping[n_neigh.index()];\n                        if m_neigh == end {\n                            continue;\n                        }\n                        match g[1 - j].find_edge(m_neigh, nodes[1 - j]) {\n                            Some(m_edge) => {\n                                if !edge_match.eq(&g[j][n_edge], &g[1 - j][m_edge]) {\n                                    return false;\n                                }\n                            }\n                            None => unreachable!(), // covered by syntactic check\n                        }\n                    }\n                }\n            }\n        }\n        true\n    };\n    let mut stack: Vec<Frame<NodeIndex<Ix>>> = vec![Frame::Outer];\n\n    while let Some(frame) = stack.pop() {\n        match frame {\n            Frame::Unwind {\n                nodes,\n                open_list: ol,\n            } => {\n                pop_state(&mut st, nodes);\n\n                match next_from_ix(&mut st, nodes[0], ol) {\n                    None => continue,\n                    Some(nx) => {\n                        let f = Frame::Inner {\n                            nodes: [nx, nodes[1]],\n                            open_list: ol,\n                        };\n                        stack.push(f);\n                    }\n                }\n            }\n            Frame::Outer => match next_candidate(&mut st) {\n                None => continue,\n                Some((nx, mx, ol)) => {\n                    let f = Frame::Inner {\n                        nodes: [nx, mx],\n                        open_list: ol,\n                    };\n                    stack.push(f);\n                }\n            },\n            Frame::Inner {\n                nodes,\n                open_list: ol,\n            } => {\n                if is_feasible(&mut st, nodes) {\n                    push_state(&mut st, nodes);\n                    if st[0].is_complete() {\n                        return Some(true);\n                    }\n                    // Check cardinalities of Tin, Tout sets\n                    if st[0].out_size == st[1].out_size && st[0].ins_size == st[1].ins_size {\n                        let f0 = Frame::Unwind {\n                            nodes,\n                            open_list: ol,\n                        };\n                        stack.push(f0);\n                        stack.push(Frame::Outer);\n                        continue;\n                    }\n                    pop_state(&mut st, nodes);\n                }\n                match next_from_ix(&mut st, nodes[0], ol) {\n                    None => continue,\n                    Some(nx) => {\n                        let f = Frame::Inner {\n                            nodes: [nx, nodes[1]],\n                            open_list: ol,\n                        };\n                        stack.push(f);\n                    }\n                }\n            }\n        }\n    }\n    None\n}","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::try_match::Frame":["enum Frame<N: marker::Copy> {\n        Outer,\n        Inner { nodes: [N; 2], open_list: OpenList },\n        Unwind { nodes: [N; 2], open_list: OpenList },\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"isomorphism::try_match::OpenList":["enum OpenList {\n        Out,\n        In,\n        Other,\n    }","Real(LocalPath(\"src/isomorphism.rs\"))"],"iter_format::DebugMap":["/// Format the iterator like a map\npub struct DebugMap<F>(pub F);","Real(LocalPath(\"src/iter_format.rs\"))"],"iter_format::Format":["/// Format all iterator elements lazily, separated by `sep`.\n///\n/// The format value can only be formatted once, after that the iterator is\n/// exhausted.\n///\n/// See [`.format()`](../trait.Itertools.html#method.format)\n/// for more information.\npub struct Format<'a, I> {\n    sep: &'a str,\n    /// Format uses interior mutability because Display::fmt takes &self.\n    inner: RefCell<Option<I>>,\n}","Real(LocalPath(\"src/iter_format.rs\"))"],"iter_format::Format::<'a, I>::format":["fn format<F>(&self, f: &mut fmt::Formatter, mut cb: F) -> fmt::Result\n    where\n        F: FnMut(&I::Item, &mut fmt::Formatter) -> fmt::Result,{\n        let mut iter = match self.inner.borrow_mut().take() {\n            Some(t) => t,\n            None => panic!(\"Format: was already formatted once\"),\n        };\n\n        if let Some(fst) = iter.next() {\n            cb(&fst, f)?;\n            for elt in iter {\n                if !self.sep.is_empty() {\n                    f.write_str(self.sep)?;\n                }\n                cb(&elt, f)?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/iter_format.rs\"))"],"iter_format::IterFormatExt":["pub trait IterFormatExt: Iterator {\n    fn format(self, separator: &str) -> Format<Self>\n    where\n        Self: Sized,\n    {\n        Format {\n            sep: separator,\n            inner: RefCell::new(Some(self)),\n        }\n    }\n}","Real(LocalPath(\"src/iter_format.rs\"))"],"iter_format::IterFormatExt::format":["fn format(self, separator: &str) -> Format<Self>\n    where\n        Self: Sized,{\n        Format {\n            sep: separator,\n            inner: RefCell::new(Some(self)),\n        }\n    }","Real(LocalPath(\"src/iter_format.rs\"))"],"iter_format::NoPretty":["/// Avoid \"pretty\" debug\npub struct NoPretty<T>(pub T);","Real(LocalPath(\"src/iter_format.rs\"))"],"iter_utils::IterUtilsExt":["pub trait IterUtilsExt: Iterator {\n    /// Return the first element that maps to `Some(_)`, or None if the iterator\n    /// was exhausted.\n    fn ex_find_map<F, R>(&mut self, mut f: F) -> Option<R>\n    where\n        F: FnMut(Self::Item) -> Option<R>,\n    {\n        for elt in self {\n            if let result @ Some(_) = f(elt) {\n                return result;\n            }\n        }\n        None\n    }\n\n    /// Return the last element from the back that maps to `Some(_)`, or\n    /// None if the iterator was exhausted.\n    fn ex_rfind_map<F, R>(&mut self, mut f: F) -> Option<R>\n    where\n        F: FnMut(Self::Item) -> Option<R>,\n        Self: DoubleEndedIterator,\n    {\n        while let Some(elt) = self.next_back() {\n            if let result @ Some(_) = f(elt) {\n                return result;\n            }\n        }\n        None\n    }\n}","Real(LocalPath(\"src/iter_utils.rs\"))"],"iter_utils::IterUtilsExt::ex_find_map":["/// Return the first element that maps to `Some(_)`, or None if the iterator\n/// was exhausted.\nfn ex_find_map<F, R>(&mut self, mut f: F) -> Option<R>\n    where\n        F: FnMut(Self::Item) -> Option<R>,{\n        for elt in self {\n            if let result @ Some(_) = f(elt) {\n                return result;\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/iter_utils.rs\"))"],"iter_utils::IterUtilsExt::ex_rfind_map":["/// Return the last element from the back that maps to `Some(_)`, or\n/// None if the iterator was exhausted.\nfn ex_rfind_map<F, R>(&mut self, mut f: F) -> Option<R>\n    where\n        F: FnMut(Self::Item) -> Option<R>,\n        Self: DoubleEndedIterator,{\n        while let Some(elt) = self.next_back() {\n            if let result @ Some(_) = f(elt) {\n                return result;\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/iter_utils.rs\"))"],"matrix_graph::EdgeReferences":["/// Iterator over all edges of a graph.\n///\n/// Created from a call to [`.edge_references()`][1] on a [`MatrixGraph`][2].\n///\n/// [1]: ../visit/trait.IntoEdgeReferences.html#tymethod.edge_references\n/// [2]: struct.MatrixGraph.html\npub struct EdgeReferences<'a, Ty: EdgeType, Null: 'a + Nullable, Ix> {\n    row: usize,\n    column: usize,\n    node_adjacencies: &'a [Null],\n    node_capacity: usize,\n    ty: PhantomData<Ty>,\n    ix: PhantomData<Ix>,\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::EdgeReferences::<'a, Ty, Null, Ix>::new":["fn new(node_adjacencies: &'a [Null], node_capacity: usize) -> Self{\n        EdgeReferences {\n            row: 0,\n            column: 0,\n            node_adjacencies,\n            node_capacity,\n            ty: PhantomData,\n            ix: PhantomData,\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::Edges":["/// Iterator over the edges of from or to a node\n///\n/// Created with [`.edges()`][1], [`.edges_directed()`][2].\n///\n/// [1]: struct.MatrixGraph.html#method.edges\n/// [2]: struct.MatrixGraph.html#method.edges_directed\npub struct Edges<'a, Ty: EdgeType, Null: 'a + Nullable, Ix> {\n    iter_direction: NeighborIterDirection,\n    node_adjacencies: &'a [Null],\n    node_capacity: usize,\n    row: usize,\n    column: usize,\n    ty: PhantomData<Ty>,\n    ix: PhantomData<Ix>,\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::Edges::<'a, Ty, Null, Ix>::on_columns":["fn on_columns(row: usize, node_adjacencies: &'a [Null], node_capacity: usize) -> Self{\n        Edges {\n            iter_direction: NeighborIterDirection::Columns,\n            node_adjacencies,\n            node_capacity,\n            row,\n            column: 0,\n            ty: PhantomData,\n            ix: PhantomData,\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::Edges::<'a, Ty, Null, Ix>::on_rows":["fn on_rows(column: usize, node_adjacencies: &'a [Null], node_capacity: usize) -> Self{\n        Edges {\n            iter_direction: NeighborIterDirection::Rows,\n            node_adjacencies,\n            node_capacity,\n            row: 0,\n            column,\n            ty: PhantomData,\n            ix: PhantomData,\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::IdIterator":["struct IdIterator<'a> {\n    upper_bound: usize,\n    removed_ids: &'a IndexSet<usize>,\n    current: Option<usize>,\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::IdStorage":["struct IdStorage<T> {\n    elements: Vec<Option<T>>,\n    upper_bound: usize,\n    removed_ids: IndexSet<usize>,\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::IdStorage::<T>::add":["fn add(&mut self, element: T) -> usize{\n        let id = if let Some(id) = self.removed_ids.pop() {\n            id\n        } else {\n            let id = self.upper_bound;\n            self.upper_bound += 1;\n\n            ensure_len(&mut self.elements, id + 1);\n\n            id\n        };\n\n        self.elements[id] = Some(element);\n\n        id\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::IdStorage::<T>::clear":["fn clear(&mut self){\n        self.upper_bound = 0;\n        self.elements.clear();\n        self.removed_ids.clear();\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::IdStorage::<T>::iter_ids":["fn iter_ids(&self) -> IdIterator{\n        IdIterator {\n            upper_bound: self.upper_bound,\n            removed_ids: &self.removed_ids,\n            current: None,\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::IdStorage::<T>::len":["#[inline]\nfn len(&self) -> usize{\n        self.upper_bound - self.removed_ids.len()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::IdStorage::<T>::remove":["fn remove(&mut self, id: usize) -> T{\n        let data = self.elements[id].take().unwrap();\n        if self.upper_bound - id == 1 {\n            self.upper_bound -= 1;\n        } else {\n            self.removed_ids.insert(id);\n        }\n        data\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::IdStorage::<T>::with_capacity":["fn with_capacity(capacity: usize) -> Self{\n        IdStorage {\n            elements: Vec::with_capacity(capacity),\n            upper_bound: 0,\n            removed_ids: IndexSet::new(),\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph":["/// `MatrixGraph<N, E, Ty, Null>` is a graph datastructure using an adjacency matrix\n/// representation.\n///\n/// `MatrixGraph` is parameterized over:\n///\n/// - Associated data `N` for nodes and `E` for edges, called *weights*.\n///   The associated data can be of arbitrary type.\n/// - Edge type `Ty` that determines whether the graph edges are directed or undirected.\n/// - Nullable type `Null`, which denotes the edges' presence (defaults to `Option<E>`). You may\n///   specify [`NotZero<E>`](struct.NotZero.html) if you want to use a sentinel value (such as 0)\n///   to mark the absence of an edge.\n/// - Index type `Ix` that sets the maximum size for the graph (defaults to `DefaultIx`).\n///\n/// The graph uses **O(|V^2|)** space, with fast edge insertion & amortized node insertion, as well\n/// as efficient graph search and graph algorithms on dense graphs.\n///\n/// This graph is backed by a flattened 2D array. For undirected graphs, only the lower triangular\n/// matrix is stored. Since the backing array stores edge weights, it is recommended to box large\n/// edge weights.\npub struct MatrixGraph<N, E, Ty = Directed, Null: Nullable<Wrapped = E> = Option<E>, Ix = DefaultIx>\n{\n    node_adjacencies: Vec<Null>,\n    node_capacity: usize,\n    nodes: IdStorage<N>,\n    nb_edges: usize,\n    ty: PhantomData<Ty>,\n    ix: PhantomData<Ix>,\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Directed, Null, Ix>::edges_directed":["/// Return an iterator of all edges of `a`, in the specified direction.\n///\n/// - `Outgoing`: All edges from `a`.\n/// - `Incoming`: All edges to `a`.\n///\n/// Produces an empty iterator if the node `a` doesn't exist.<br>\n/// Iterator element type is [`EdgeReference<E, Ix>`](../graph/struct.EdgeReference.html).\npub fn edges_directed(&self, a: NodeIndex<Ix>, d: Direction) -> Edges<Directed, Null, Ix>{\n        if d == Outgoing {\n            self.edges(a)\n        } else {\n            Edges::on_rows(a.index(), &self.node_adjacencies, self.node_capacity)\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Directed, Null, Ix>::neighbors_directed":["/// Return an iterator of all neighbors that have an edge between them and\n/// `a`, in the specified direction.\n/// If the graph's edges are undirected, this is equivalent to *.neighbors(a)*.\n///\n/// - `Outgoing`: All edges from `a`.\n/// - `Incoming`: All edges to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is [`NodeIndex<Ix>`](../graph/struct.NodeIndex.html).\npub fn neighbors_directed(\n        &self,\n        a: NodeIndex<Ix>,\n        d: Direction,\n    ) -> Neighbors<Directed, Null, Ix>{\n        if d == Outgoing {\n            self.neighbors(a)\n        } else {\n            Neighbors(Edges::on_rows(\n                a.index(),\n                &self.node_adjacencies,\n                self.node_capacity,\n            ))\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::add_edge":["/// Add an edge from `a` to `b` to the graph, with its associated\n/// data `weight`.\n///\n/// Return the index of the new edge.\n///\n/// Computes in **O(1)** time, best case.\n/// Computes in **O(|V|^2)** time, worst case (matrix needs to be re-allocated).\n///\n/// **Panics** if any of the nodes don't exist.\n/// **Panics** if an edge already exists from `a` to `b`.\n///\n/// **Note:** `MatrixGraph` does not allow adding parallel (“duplicate”) edges. If you want to avoid\n/// this, use [`.update_edge(a, b, weight)`](#method.update_edge) instead.\npub fn add_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E){\n        let old_edge_id = self.update_edge(a, b, weight);\n        assert!(old_edge_id.is_none());\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::add_node":["/// Add a node (also called vertex) with associated data `weight` to the graph.\n///\n/// Computes in **O(1)** time.\n///\n/// Return the index of the new node.\n///\n/// **Panics** if the MatrixGraph is at the maximum number of nodes for its index type.\npub fn add_node(&mut self, weight: N) -> NodeIndex<Ix>{\n        NodeIndex::new(self.nodes.add(weight))\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::clear":["/// Remove all nodes and edges.\npub fn clear(&mut self){\n        for edge in self.node_adjacencies.iter_mut() {\n            *edge = Default::default();\n        }\n        self.nodes.clear();\n        self.nb_edges = 0;\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edge_count":["/// Return the number of edges in the graph.\n///\n/// Computes in **O(1)** time.\n#[inline]\npub fn edge_count(&self) -> usize{\n        self.nb_edges\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edge_weight":["/// Access the weight for edge `e`.\n///\n/// Also available with indexing syntax: `&graph[e]`.\n///\n/// **Panics** if no edge exists between `a` and `b`.\npub fn edge_weight(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> &E{\n        let p = self.to_edge_position(a, b);\n        self.node_adjacencies[p].as_ref().unwrap()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edge_weight_mut":["/// Access the weight for edge `e`, mutably.\n///\n/// Also available with indexing syntax: `&mut graph[e]`.\n///\n/// **Panics** if no edge exists between `a` and `b`.\npub fn edge_weight_mut(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> &mut E{\n        let p = self.to_edge_position(a, b);\n        self.node_adjacencies[p].as_mut().unwrap()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edges":["/// Return an iterator of all edges of `a`.\n///\n/// - `Directed`: Outgoing edges from `a`.\n/// - `Undirected`: All edges connected to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is [`Edges<E, Ix>`](../graph/struct.Edges.html).\npub fn edges(&self, a: NodeIndex<Ix>) -> Edges<Ty, Null, Ix>{\n        Edges::on_columns(a.index(), &self.node_adjacencies, self.node_capacity)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::extend_capacity_for_edge":["#[inline]\nfn extend_capacity_for_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>){\n        let min_node = cmp::max(a, b);\n        if min_node.index() >= self.node_capacity {\n            self.extend_capacity_for_node(min_node);\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::extend_capacity_for_node":["#[inline]\nfn extend_capacity_for_node(&mut self, min_node: NodeIndex<Ix>){\n        self.node_capacity = extend_linearized_matrix::<Ty, _>(\n            &mut self.node_adjacencies,\n            self.node_capacity,\n            min_node.index(),\n        );\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::extend_with_edges":["/// Extend the graph from an iterable of edges.\n///\n/// Node weights `N` are set to default values.\n/// Edge weights `E` may either be specified in the list,\n/// or they are filled with default values.\n///\n/// Nodes are inserted automatically to match the edges.\npub fn extend_with_edges<I>(&mut self, iterable: I)\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,{\n        for elt in iterable {\n            let (source, target, weight) = elt.into_weighted_edge();\n            let (source, target) = (source.into(), target.into());\n            let nx = cmp::max(source, target);\n            while nx.index() >= self.node_count() {\n                self.add_node(N::default());\n            }\n            self.add_edge(source, target, weight);\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::from_edges":["/// Create a new `MatrixGraph` from an iterable of edges.\n///\n/// Node weights `N` are set to default values.\n/// Edge weights `E` may either be specified in the list,\n/// or they are filled with default values.\n///\n/// Nodes are inserted automatically to match the edges.\n///\n/// ```\n/// use petgraph::matrix_graph::MatrixGraph;\n///\n/// let gr = MatrixGraph::<(), i32>::from_edges(&[\n///     (0, 1), (0, 2), (0, 3),\n///     (1, 2), (1, 3),\n///     (2, 3),\n/// ]);\n/// ```\npub fn from_edges<I>(iterable: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: IntoWeightedEdge<E>,\n        <I::Item as IntoWeightedEdge<E>>::NodeId: Into<NodeIndex<Ix>>,\n        N: Default,{\n        let mut g = Self::default();\n        g.extend_with_edges(iterable);\n        g\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::has_edge":["/// Return true if there is an edge between `a` and `b`.\n///\n/// **Panics** if any of the nodes don't exist.\npub fn has_edge(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool{\n        let p = self.to_edge_position(a, b);\n        !self.node_adjacencies[p].is_null()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::is_directed":["/// Return whether the graph has directed edges or not.\n#[inline]\npub fn is_directed(&self) -> bool{\n        Ty::is_directed()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::neighbors":["/// Return an iterator of all nodes with an edge starting from `a`.\n///\n/// - `Directed`: Outgoing edges from `a`.\n/// - `Undirected`: All edges from or to `a`.\n///\n/// Produces an empty iterator if the node doesn't exist.<br>\n/// Iterator element type is [`NodeIndex<Ix>`](../graph/struct.NodeIndex.html).\npub fn neighbors(&self, a: NodeIndex<Ix>) -> Neighbors<Ty, Null, Ix>{\n        Neighbors(Edges::on_columns(\n            a.index(),\n            &self.node_adjacencies,\n            self.node_capacity,\n        ))\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::node_count":["/// Return the number of nodes (vertices) in the graph.\n///\n/// Computes in **O(1)** time.\n#[inline]\npub fn node_count(&self) -> usize{\n        self.nodes.len()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::node_weight":["/// Access the weight for node `a`.\n///\n/// Also available with indexing syntax: `&graph[a]`.\n///\n/// **Panics** if the node doesn't exist.\npub fn node_weight(&self, a: NodeIndex<Ix>) -> &N{\n        &self.nodes[a.index()]\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::node_weight_mut":["/// Access the weight for node `a`, mutably.\n///\n/// Also available with indexing syntax: `&mut graph[a]`.\n///\n/// **Panics** if the node doesn't exist.\npub fn node_weight_mut(&mut self, a: NodeIndex<Ix>) -> &mut N{\n        &mut self.nodes[a.index()]\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::remove_edge":["/// Remove the edge from `a` to `b` to the graph.\n///\n/// **Panics** if any of the nodes don't exist.\n/// **Panics** if no edge exists between `a` and `b`.\npub fn remove_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> E{\n        let p = self.to_edge_position(a, b);\n        let old_weight = mem::replace(&mut self.node_adjacencies[p], Default::default())\n            .into()\n            .unwrap();\n        let old_weight: Option<_> = old_weight.into();\n        self.nb_edges -= 1;\n        old_weight.unwrap()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::remove_node":["/// Remove `a` from the graph.\n///\n/// Computes in **O(V)** time, due to the removal of edges with other nodes.\n///\n/// **Panics** if the node `a` does not exist.\npub fn remove_node(&mut self, a: NodeIndex<Ix>) -> N{\n        for id in self.nodes.iter_ids() {\n            let position = self.to_edge_position(a, NodeIndex::new(id));\n            self.node_adjacencies[position] = Default::default();\n\n            if Ty::is_directed() {\n                let position = self.to_edge_position(NodeIndex::new(id), a);\n                self.node_adjacencies[position] = Default::default();\n            }\n        }\n\n        self.nodes.remove(a.index())\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::to_edge_position":["#[inline]\nfn to_edge_position(&self, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> usize{\n        to_linearized_matrix_position::<Ty>(a.index(), b.index(), self.node_capacity)\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::update_edge":["/// Update the edge from `a` to `b` to the graph, with its associated data `weight`.\n///\n/// Return the previous data, if any.\n///\n/// Computes in **O(1)** time, best case.\n/// Computes in **O(|V|^2)** time, worst case (matrix needs to be re-allocated).\n///\n/// **Panics** if any of the nodes don't exist.\npub fn update_edge(&mut self, a: NodeIndex<Ix>, b: NodeIndex<Ix>, weight: E) -> Option<E>{\n        self.extend_capacity_for_edge(a, b);\n\n        let p = self.to_edge_position(a, b);\n        let old_weight = mem::replace(&mut self.node_adjacencies[p], Null::new(weight));\n        if old_weight.is_null() {\n            self.nb_edges += 1;\n        }\n        old_weight.into()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::with_capacity":["/// Create a new `MatrixGraph` with estimated capacity for nodes.\npub fn with_capacity(node_capacity: usize) -> Self{\n        let mut m = Self {\n            node_adjacencies: vec![],\n            node_capacity: 0,\n            nodes: IdStorage::with_capacity(node_capacity),\n            nb_edges: 0,\n            ty: PhantomData,\n            ix: PhantomData,\n        };\n\n        debug_assert!(node_capacity <= <Ix as IndexType>::max().index());\n        m.extend_capacity_for_node(NodeIndex::new(node_capacity));\n\n        m\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E, Undirected>::new_undirected":["/// Create a new `MatrixGraph` with undirected edges.\n///\n/// This is a convenience method. Use `MatrixGraph::with_capacity` or `MatrixGraph::default` for\n/// a constructor that is generic in all the type parameters of `MatrixGraph`.\npub fn new_undirected() -> Self{\n        MatrixGraph::default()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::MatrixGraph::<N, E>::new":["/// Create a new `MatrixGraph` with directed edges.\n///\n/// This is a convenience method. Use `MatrixGraph::with_capacity` or `MatrixGraph::default` for\n/// a constructor that is generic in all the type parameters of `MatrixGraph`.\npub fn new() -> Self{\n        MatrixGraph::default()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::NeighborIterDirection":["enum NeighborIterDirection {\n    Rows,\n    Columns,\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::Neighbors":["/// Iterator over the neighbors of a node.\n///\n/// Iterator element type is `NodeIndex<Ix>`.\n///\n/// Created with [`.neighbors()`][1], [`.neighbors_directed()`][2].\n///\n/// [1]: struct.MatrixGraph.html#method.neighbors\n/// [2]: struct.MatrixGraph.html#method.neighbors_directed\npub struct Neighbors<'a, Ty: EdgeType, Null: 'a + Nullable, Ix>(Edges<'a, Ty, Null, Ix>);","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::NodeIdentifiers":["/// Iterator over the node identifiers of a graph.\n///\n/// Created from a call to [`.node_identifiers()`][1] on a [`MatrixGraph`][2].\n///\n/// [1]: ../visit/trait.IntoNodeIdentifiers.html#tymethod.node_identifiers\n/// [2]: struct.MatrixGraph.html\npub struct NodeIdentifiers<'a, Ix> {\n    iter: IdIterator<'a>,\n    ix: PhantomData<Ix>,\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::NodeIdentifiers::<'a, Ix>::new":["fn new(iter: IdIterator<'a>) -> Self{\n        Self {\n            iter,\n            ix: PhantomData,\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::NodeReferences":["/// Iterator over all nodes of a graph.\n///\n/// Created from a call to [`.node_references()`][1] on a [`MatrixGraph`][2].\n///\n/// [1]: ../visit/trait.IntoNodeReferences.html#tymethod.node_references\n/// [2]: struct.MatrixGraph.html\npub struct NodeReferences<'a, N: 'a, Ix> {\n    nodes: &'a IdStorage<N>,\n    iter: IdIterator<'a>,\n    ix: PhantomData<Ix>,\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::NodeReferences::<'a, N, Ix>::new":["fn new(nodes: &'a IdStorage<N>) -> Self{\n        NodeReferences {\n            nodes,\n            iter: nodes.iter_ids(),\n            ix: PhantomData,\n        }\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::NotZero":["/// `NotZero` is used to optimize the memory usage of edge weights `E` in a\n/// [`MatrixGraph`](struct.MatrixGraph.html), replacing the default `Option<E>` sentinel.\n///\n/// Pre-requisite: edge weight should implement [`Zero`](trait.Zero.html).\n///\n/// Note that if you're already using the standard non-zero types (such as `NonZeroU32`), you don't\n/// have to use this wrapper and can leave the default `Null` type argument.\npub struct NotZero<T>(T);","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::Nullable":["/// Wrapper trait for an `Option`, allowing user-defined structs to be input as containers when\n/// defining a null element.\n///\n/// Note: this trait is currently *sealed* and cannot be implemented for types outside this crate.\npub trait Nullable: Default + Into<Option<<Self as Nullable>::Wrapped>> + private::Sealed {\n    #[doc(hidden)]\n    type Wrapped;\n\n    #[doc(hidden)]\n    fn new(value: Self::Wrapped) -> Self;\n\n    #[doc(hidden)]\n    fn as_ref(&self) -> Option<&Self::Wrapped>;\n\n    #[doc(hidden)]\n    fn as_mut(&mut self) -> Option<&mut Self::Wrapped>;\n\n    #[doc(hidden)]\n    fn is_null(&self) -> bool {\n        self.as_ref().is_none()\n    }\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::Nullable::is_null":["#[doc(hidden)]\nfn is_null(&self) -> bool{\n        self.as_ref().is_none()\n    }","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::Zero":["/// Base trait for types that can be wrapped in a [`NotZero`](struct.NotZero.html).\n///\n/// Implementors must provide a singleton object that will be used to mark empty edges in a\n/// [`MatrixGraph`](struct.MatrixGraph.html).\n///\n/// Note that this trait is already implemented for the base numeric types.\npub trait Zero {\n    /// Return the singleton object which can be used as a sentinel value.\n    fn zero() -> Self;\n\n    /// Return true if `self` is equal to the sentinel value.\n    fn is_zero(&self) -> bool;\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::ensure_len":["/// Grow a Vec by appending the type's default value until the `size` is reached.\nfn ensure_len<T: Default>(v: &mut Vec<T>, size: usize){\n    if let Some(n) = size.checked_sub(v.len()) {\n        v.reserve(n);\n        for _ in 0..n {\n            v.push(T::default());\n        }\n    }\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::extend_flat_square_matrix":["#[inline]\nfn extend_flat_square_matrix<T: Default>(\n    node_adjacencies: &mut Vec<T>,\n    old_node_capacity: usize,\n    min_node_capacity: usize,\n) -> usize{\n    let min_node_capacity = (min_node_capacity + 1).next_power_of_two();\n\n    // Optimization: when resizing the matrix this way we skip the first few grows to make\n    // small matrices a bit faster to work with.\n    const MIN_CAPACITY: usize = 4;\n    let new_node_capacity = cmp::max(min_node_capacity, MIN_CAPACITY);\n\n    let mut new_node_adjacencies = vec![];\n    ensure_len(&mut new_node_adjacencies, new_node_capacity.pow(2));\n\n    for c in 0..old_node_capacity {\n        let pos = c * old_node_capacity;\n        let new_pos = c * new_node_capacity;\n\n        let mut old = &mut node_adjacencies[pos..pos + old_node_capacity];\n        let mut new = &mut new_node_adjacencies[new_pos..new_pos + old_node_capacity];\n\n        mem::swap(&mut old, &mut new);\n    }\n\n    mem::swap(node_adjacencies, &mut new_node_adjacencies);\n\n    new_node_capacity\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::extend_linearized_matrix":["#[inline]\nfn extend_linearized_matrix<Ty: EdgeType, T: Default>(\n    node_adjacencies: &mut Vec<T>,\n    old_node_capacity: usize,\n    min_node_capacity: usize,\n) -> usize{\n    if Ty::is_directed() {\n        extend_flat_square_matrix(node_adjacencies, old_node_capacity, min_node_capacity)\n    } else {\n        extend_lower_triangular_matrix(node_adjacencies, min_node_capacity)\n    }\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::extend_lower_triangular_matrix":["#[inline]\nfn extend_lower_triangular_matrix<T: Default>(\n    node_adjacencies: &mut Vec<T>,\n    new_node_capacity: usize,\n) -> usize{\n    let max_pos = to_lower_triangular_matrix_position(new_node_capacity, new_node_capacity);\n    ensure_len(node_adjacencies, max_pos + 1);\n    new_node_capacity + 1\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::node_index":["/// Short version of `NodeIndex::new` (with Ix = `DefaultIx`)\n#[inline]\npub fn node_index(ax: usize) -> NodeIndex{\n    NodeIndex::new(ax)\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::private::Sealed":["pub trait Sealed {}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::to_flat_square_matrix_position":["#[inline]\nfn to_flat_square_matrix_position(row: usize, column: usize, width: usize) -> usize{\n    row * width + column\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::to_linearized_matrix_position":["#[inline]\nfn to_linearized_matrix_position<Ty: EdgeType>(row: usize, column: usize, width: usize) -> usize{\n    if Ty::is_directed() {\n        to_flat_square_matrix_position(row, column, width)\n    } else {\n        to_lower_triangular_matrix_position(row, column)\n    }\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"matrix_graph::to_lower_triangular_matrix_position":["#[inline]\nfn to_lower_triangular_matrix_position(row: usize, column: usize) -> usize{\n    let (row, column) = if row > column {\n        (row, column)\n    } else {\n        (column, row)\n    };\n    (row * (row + 1)) / 2 + column\n}","Real(LocalPath(\"src/matrix_graph.rs\"))"],"scored::MinScored":["/// `MinScored<K, T>` holds a score `K` and a scored object `T` in\n/// a pair for use with a `BinaryHeap`.\n///\n/// `MinScored` compares in reverse order by the score, so that we can\n/// use `BinaryHeap` as a min-heap to extract the score-value pair with the\n/// least score.\n///\n/// **Note:** `MinScored` implements a total order (`Ord`), so that it is\n/// possible to use float types as scores.\npub struct MinScored<K, T>(pub K, pub T);","Real(LocalPath(\"src/scored.rs\"))"],"simple_paths::all_simple_paths":["/// Returns iterator that produces all simple paths from `from` node to `to`, which contains at least `min_intermediate_nodes` nodes\n/// and at most `max_intermediate_nodes`, if given, limited by graph's order otherwise\n/// Simple path is path without repetitions\n/// Algorithm is adopted from https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.simple_paths.all_simple_paths.html\npub fn all_simple_paths<TargetColl, G>(\n    graph: G,\n    from: G::NodeId,\n    to: G::NodeId,\n    min_intermediate_nodes: usize,\n    max_intermediate_nodes: Option<usize>,\n) -> impl Iterator<Item = TargetColl>\nwhere\n    G: NodeCount,\n    G: IntoNeighborsDirected,\n    G::NodeId: Eq + Hash,\n    TargetColl: FromIterator<G::NodeId>,{\n    // how many nodes are allowed in simple path up to target node\n    // it is min/max allowed path length minus one, because it is more appropriate when implementing lookahead\n    // than constantly add 1 to length of current path\n    let max_length = if let Some(l) = max_intermediate_nodes {\n        l + 1\n    } else {\n        graph.node_count() - 1\n    };\n\n    let min_length = min_intermediate_nodes + 1;\n\n    // list of visited nodes\n    let mut visited: IndexSet<G::NodeId> = IndexSet::from_iter(Some(from));\n    // list of childs of currently exploring path nodes,\n    // last elem is list of childs of last visited node\n    let mut stack = vec![graph.neighbors_directed(from, Outgoing)];\n\n    from_fn(move || {\n        while let Some(children) = stack.last_mut() {\n            if let Some(child) = children.next() {\n                if visited.len() < max_length {\n                    if child == to {\n                        if visited.len() >= min_length {\n                            let path = visited\n                                .iter()\n                                .cloned()\n                                .chain(Some(to))\n                                .collect::<TargetColl>();\n                            return Some(path);\n                        }\n                    } else if !visited.contains(&child) {\n                        visited.insert(child);\n                        stack.push(graph.neighbors_directed(child, Outgoing));\n                    }\n                } else {\n                    if (child == to || children.any(|v| v == to)) && visited.len() >= min_length {\n                        let path = visited\n                            .iter()\n                            .cloned()\n                            .chain(Some(to))\n                            .collect::<TargetColl>();\n                        return Some(path);\n                    }\n                    stack.pop();\n                    visited.pop();\n                }\n            } else {\n                stack.pop();\n                visited.pop();\n            }\n        }\n        None\n    })\n}","Real(LocalPath(\"src/simple_paths.rs\"))"],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::Graph<N, E, Ty, Ix>>::adjacency_matrix":["fn adjacency_matrix(&self) -> FixedBitSet{\n        let n = self.node_count();\n        let mut matrix = FixedBitSet::with_capacity(n * n);\n        for edge in self.edge_references() {\n            let i = edge.source().index() * n + edge.target().index();\n            matrix.put(i);\n            if !self.is_directed() {\n                let j = edge.source().index() + n * edge.target().index();\n                matrix.put(j);\n            }\n        }\n        matrix\n    }","Real(LocalPath(\"src/traits_graph.rs\"))"],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::Graph<N, E, Ty, Ix>>::is_adjacent":["fn is_adjacent(&self, matrix: &FixedBitSet, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool{\n        let n = self.node_count();\n        let index = n * a.index() + b.index();\n        matrix.contains(index)\n    }","Real(LocalPath(\"src/traits_graph.rs\"))"],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::stable_graph::StableGraph<N, E, Ty, Ix>>::adjacency_matrix":["fn adjacency_matrix(&self) -> FixedBitSet{\n        let n = self.node_bound();\n        let mut matrix = FixedBitSet::with_capacity(n * n);\n        for edge in self.edge_references() {\n            let i = edge.source().index() * n + edge.target().index();\n            matrix.put(i);\n            if !self.is_directed() {\n                let j = edge.source().index() + n * edge.target().index();\n                matrix.put(j);\n            }\n        }\n        matrix\n    }","Real(LocalPath(\"src/traits_graph.rs\"))"],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::stable_graph::StableGraph<N, E, Ty, Ix>>::is_adjacent":["fn is_adjacent(&self, matrix: &FixedBitSet, a: NodeIndex<Ix>, b: NodeIndex<Ix>) -> bool{\n        let n = self.node_count();\n        let index = n * a.index() + b.index();\n        matrix.contains(index)\n    }","Real(LocalPath(\"src/traits_graph.rs\"))"],"unionfind::UnionFind":["/// `UnionFind<K>` is a disjoint-set data structure. It tracks set membership of *n* elements\n/// indexed from *0* to *n - 1*. The scalar type is `K` which must be an unsigned integer type.\n///\n/// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n///\n/// Too awesome not to quote:\n///\n/// “The amortized time per operation is **O(α(n))** where **α(n)** is the\n/// inverse of **f(x) = A(x, x)** with **A** being the extremely fast-growing Ackermann function.”\npub struct UnionFind<K> {\n    // For element at index *i*, store the index of its parent; the representative itself\n    // stores its own index. This forms equivalence classes which are the disjoint sets, each\n    // with a unique representative.\n    parent: Vec<K>,\n    // It is a balancing tree structure,\n    // so the ranks are logarithmic in the size of the container -- a byte is more than enough.\n    //\n    // Rank is separated out both to save space and to save cache in when searching in the parent\n    // vector.\n    rank: Vec<u8>,\n}","Real(LocalPath(\"src/unionfind.rs\"))"],"unionfind::UnionFind::<K>::equiv":["/// Returns `true` if the given elements belong to the same set, and returns\n/// `false` otherwise.\npub fn equiv(&self, x: K, y: K) -> bool{\n        self.find(x) == self.find(y)\n    }","Real(LocalPath(\"src/unionfind.rs\"))"],"unionfind::UnionFind::<K>::find":["/// Return the representative for `x`.\n///\n/// **Panics** if `x` is out of bounds.\npub fn find(&self, x: K) -> K{\n        assert!(x.index() < self.parent.len());\n        unsafe {\n            let mut x = x;\n            loop {\n                // Use unchecked indexing because we can trust the internal set ids.\n                let xparent = *get_unchecked(&self.parent, x.index());\n                if xparent == x {\n                    break;\n                }\n                x = xparent;\n            }\n            x\n        }\n    }","Real(LocalPath(\"src/unionfind.rs\"))"],"unionfind::UnionFind::<K>::find_mut":["/// Return the representative for `x`.\n///\n/// Write back the found representative, flattening the internal\n/// datastructure in the process and quicken future lookups.\n///\n/// **Panics** if `x` is out of bounds.\npub fn find_mut(&mut self, x: K) -> K{\n        assert!(x.index() < self.parent.len());\n        unsafe { self.find_mut_recursive(x) }\n    }","Real(LocalPath(\"src/unionfind.rs\"))"],"unionfind::UnionFind::<K>::find_mut_recursive":["unsafe fn find_mut_recursive(&mut self, mut x: K) -> K{\n        let mut parent = *get_unchecked(&self.parent, x.index());\n        while parent != x {\n            let grandparent = *get_unchecked(&self.parent, parent.index());\n            *get_unchecked_mut(&mut self.parent, x.index()) = grandparent;\n            x = parent;\n            parent = grandparent;\n        }\n        x\n    }","Real(LocalPath(\"src/unionfind.rs\"))"],"unionfind::UnionFind::<K>::into_labeling":["/// Return a vector mapping each element to its representative.\npub fn into_labeling(mut self) -> Vec<K>{\n        // write in the labeling of each element\n        unsafe {\n            for ix in 0..self.parent.len() {\n                let k = *get_unchecked(&self.parent, ix);\n                let xrep = self.find_mut_recursive(k);\n                *self.parent.get_unchecked_mut(ix) = xrep;\n            }\n        }\n        self.parent\n    }","Real(LocalPath(\"src/unionfind.rs\"))"],"unionfind::UnionFind::<K>::new":["/// Create a new `UnionFind` of `n` disjoint sets.\npub fn new(n: usize) -> Self{\n        let rank = vec![0; n];\n        let parent = (0..n).map(K::new).collect::<Vec<K>>();\n\n        UnionFind { parent, rank }\n    }","Real(LocalPath(\"src/unionfind.rs\"))"],"unionfind::UnionFind::<K>::union":["/// Unify the two sets containing `x` and `y`.\n///\n/// Return `false` if the sets were already the same, `true` if they were unified.\n///\n/// **Panics** if `x` or `y` is out of bounds.\npub fn union(&mut self, x: K, y: K) -> bool{\n        if x == y {\n            return false;\n        }\n        let xrep = self.find_mut(x);\n        let yrep = self.find_mut(y);\n\n        if xrep == yrep {\n            return false;\n        }\n\n        let xrepu = xrep.index();\n        let yrepu = yrep.index();\n        let xrank = self.rank[xrepu];\n        let yrank = self.rank[yrepu];\n\n        // The rank corresponds roughly to the depth of the treeset, so put the\n        // smaller set below the larger\n        match xrank.cmp(&yrank) {\n            Ordering::Less => self.parent[xrepu] = yrep,\n            Ordering::Greater => self.parent[yrepu] = xrep,\n            Ordering::Equal => {\n                self.parent[yrepu] = xrep;\n                self.rank[xrepu] += 1;\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/unionfind.rs\"))"],"unionfind::get_unchecked":["#[inline]\nunsafe fn get_unchecked<K>(xs: &[K], index: usize) -> &K{\n    debug_assert!(index < xs.len());\n    xs.get_unchecked(index)\n}","Real(LocalPath(\"src/unionfind.rs\"))"],"unionfind::get_unchecked_mut":["#[inline]\nunsafe fn get_unchecked_mut<K>(xs: &mut [K], index: usize) -> &mut K{\n    debug_assert!(index < xs.len());\n    xs.get_unchecked_mut(index)\n}","Real(LocalPath(\"src/unionfind.rs\"))"],"util::enumerate":["pub fn enumerate<I>(iterable: I) -> iter::Enumerate<I::IntoIter>\nwhere\n    I: IntoIterator,{\n    iterable.into_iter().enumerate()\n}","Real(LocalPath(\"src/util.rs\"))"],"util::zip":["pub fn zip<I, J>(i: I, j: J) -> iter::Zip<I::IntoIter, J::IntoIter>\nwhere\n    I: IntoIterator,\n    J: IntoIterator,{\n    i.into_iter().zip(j)\n}","Real(LocalPath(\"src/util.rs\"))"],"visit::Data":["#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::EdgeRef":["/// An edge reference.\n///\n/// Edge references are used by traits `IntoEdges` and `IntoEdgeReferences`.\npub trait EdgeRef: Copy {\n    type NodeId;\n    type EdgeId;\n    type Weight;\n    /// The source node of the edge.\n    fn source(&self) -> Self::NodeId;\n    /// The target node of the edge.\n    fn target(&self) -> Self::NodeId;\n    /// A reference to the weight of the edge.\n    fn weight(&self) -> &Self::Weight;\n    /// The edge’s identifier.\n    fn id(&self) -> Self::EdgeId;\n}","Real(LocalPath(\"src/visit/mod.rs\"))"],"visit::GetAdjacencyMatrix":["#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::GraphBase":["#[$doc]\n#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::GraphProp":["#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::GraphProp::is_directed":["fn is_directed(&self) -> bool{\n        <Self::EdgeType>::is_directed()\n    }","Real(LocalPath(\"src/visit/mod.rs\"))"],"visit::GraphRef":["/// A copyable reference to a graph.\npub trait GraphRef: Copy + GraphBase {}","Real(LocalPath(\"src/visit/mod.rs\"))"],"visit::IntoEdgeReferences":["#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::IntoEdges":["#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::IntoEdgesDirected":["#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::IntoNeighbors":["#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::IntoNeighborsDirected":["#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::IntoNodeIdentifiers":["#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::IntoNodeReferences":["#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::NodeCompactIndexable":["#[$doc]\n#[$doc]\n#[$doc]\n#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::NodeCount":["#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::NodeIndexable":["#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::NodeRef":["/// A node reference.\npub trait NodeRef: Copy {\n    type NodeId;\n    type Weight;\n    fn id(&self) -> Self::NodeId;\n    fn weight(&self) -> &Self::Weight;\n}","Real(LocalPath(\"src/visit/mod.rs\"))"],"visit::VisitMap":["/// A mapping for storing the visited status for NodeId `N`.\npub trait VisitMap<N> {\n    /// Mark `a` as visited.\n    ///\n    /// Return **true** if this is the first visit, false otherwise.\n    fn visit(&mut self, a: N) -> bool;\n\n    /// Return whether `a` has been visited before.\n    fn is_visited(&self, a: &N) -> bool;\n}","Real(LocalPath(\"src/visit/mod.rs\"))"],"visit::Visitable":["#[$doc]\npub trait $name $($methods)*\n\n            // This is where the trait definition is reproduced by the macro.\n            // It makes the source links point to this place!\n            //\n            // I'm sorry, you'll have to find the source by looking at the\n            // source of the module the trait is defined in.\n            //\n            // We use this nifty macro so that we can automatically generate\n            // delegation trait impls and implement the graph traits for more\n            // types and combinators.\n        }\n    }\n}\n\nmacro_rules! remove_sections_inner {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    // escape the following tt\n    ([$($stack:tt)*] @escape $_x:tt $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] @section $x:ident $($t:tt)*) => {\n        remove_sections_inner!([$($stack)*] $($t)*);\n    };\n    ([$($stack:tt)*] $t:tt $($tail:tt)*) => {\n        remove_sections_inner!([$($stack)* $t] $($tail)*);\n    };\n}\n\n// This is the outer layer, just find the { } of the actual trait definition\n// recurse once into { }, but not more.\nmacro_rules! remove_sections {\n    ([$($stack:tt)*]) => {\n        $($stack)*\n    };\n    ([$($stack:tt)*] { $($tail:tt)* }) => {\n        $($stack)* {\n            remove_sections_inner!([] $($tail)*);\n        }","Real(LocalPath(\"src/visit/macros.rs\"))"],"visit::dfsvisit::Control":["/// Control flow for `depth_first_search` callbacks.\npub enum Control<B> {\n    /// Continue the DFS traversal as normal.\n    Continue,\n    /// Prune the current node from the DFS traversal. No more edges from this\n    /// node will be reported to the callback. A `DfsEvent::Finish` for this\n    /// node will still be reported. This can be returned in response to any\n    /// `DfsEvent`, except `Finish`, which will panic.\n    Prune,\n    /// Stop the DFS traversal and return the provided value.\n    Break(B),\n}","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"visit::dfsvisit::Control::<B>::break_value":["/// Get the value in `Control::Break(_)`, if present.\npub fn break_value(self) -> Option<B>{\n        match self {\n            Control::Continue | Control::Prune => None,\n            Control::Break(b) => Some(b),\n        }\n    }","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"visit::dfsvisit::Control::<B>::breaking":["pub fn breaking() -> Control<()>{\n        Control::Break(())\n    }","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"visit::dfsvisit::ControlFlow":["/// Control flow for callbacks.\n///\n/// The empty return value `()` is equivalent to continue.\npub trait ControlFlow {\n    fn continuing() -> Self;\n    fn should_break(&self) -> bool;\n    fn should_prune(&self) -> bool;\n}","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"visit::dfsvisit::DfsEvent":["/// A depth first search (DFS) visitor event.\npub enum DfsEvent<N> {\n    Discover(N, Time),\n    /// An edge of the tree formed by the traversal.\n    TreeEdge(N, N),\n    /// An edge to an already visited node.\n    BackEdge(N, N),\n    /// A cross or forward edge.\n    ///\n    /// For an edge *(u, v)*, if the discover time of *v* is greater than *u*,\n    /// then it is a forward edge, else a cross edge.\n    CrossForwardEdge(N, N),\n    /// All edges from a node have been reported.\n    Finish(N, Time),\n}","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"visit::dfsvisit::Time":["/// Strictly monotonically increasing event time for a depth first search.\npub struct Time(pub usize);","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"visit::dfsvisit::depth_first_search":["/// A recursive depth first search.\n///\n/// Starting points are the nodes in the iterator `starts` (specify just one\n/// start vertex *x* by using `Some(x)`).\n///\n/// The traversal emits discovery and finish events for each reachable vertex,\n/// and edge classification of each reachable edge. `visitor` is called for each\n/// event, see [`DfsEvent`][de] for possible values.\n///\n/// The return value should implement the trait `ControlFlow`, and can be used to change\n/// the control flow of the search.\n///\n/// `Control` Implements `ControlFlow` such that `Control::Continue` resumes the search.\n/// `Control::Break` will stop the visit early, returning the contained value.\n/// `Control::Prune` will stop traversing any additional edges from the current\n/// node and proceed immediately to the `Finish` event.\n///\n/// There are implementations of `ControlFlow` for `()`, and `Result<C, E>` where\n/// `C: ControlFlow`. The implementation for `()` will continue until finished.\n/// For `Result`, upon encountering an `E` it will break, otherwise acting the same as `C`.\n///\n/// ***Panics** if you attempt to prune a node from its `Finish` event.\n///\n/// [de]: enum.DfsEvent.html\n///\n/// # Example returning `Control`.\n///\n/// Find a path from vertex 0 to 5, and exit the visit as soon as we reach\n/// the goal vertex.\n///\n/// ```\n/// use petgraph::prelude::*;\n/// use petgraph::graph::node_index as n;\n/// use petgraph::visit::depth_first_search;\n/// use petgraph::visit::{DfsEvent, Control};\n///\n/// let gr: Graph<(), ()> = Graph::from_edges(&[\n///     (0, 1), (0, 2), (0, 3),\n///     (1, 3),\n///     (2, 3), (2, 4),\n///     (4, 0), (4, 5),\n/// ]);\n///\n/// // record each predecessor, mapping node → node\n/// let mut predecessor = vec![NodeIndex::end(); gr.node_count()];\n/// let start = n(0);\n/// let goal = n(5);\n/// depth_first_search(&gr, Some(start), |event| {\n///     if let DfsEvent::TreeEdge(u, v) = event {\n///         predecessor[v.index()] = u;\n///         if v == goal {\n///             return Control::Break(v);\n///         }\n///     }\n///     Control::Continue\n/// });\n///\n/// let mut next = goal;\n/// let mut path = vec![next];\n/// while next != start {\n///     let pred = predecessor[next.index()];\n///     path.push(pred);\n///     next = pred;\n/// }\n/// path.reverse();\n/// assert_eq!(&path, &[n(0), n(2), n(4), n(5)]);\n/// ```\n///\n/// # Example returning a `Result`.\n/// ```\n/// use petgraph::graph::node_index as n;\n/// use petgraph::prelude::*;\n/// use petgraph::visit::depth_first_search;\n/// use petgraph::visit::{DfsEvent, Time};\n///\n/// let gr: Graph<(), ()> = Graph::from_edges(&[(0, 1), (1, 2), (1, 1), (2, 1)]);\n/// let start = n(0);\n/// let mut back_edges = 0;\n/// let mut discover_time = 0;\n/// // Stop the search, the first time a BackEdge is encountered.\n/// let result = depth_first_search(&gr, Some(start), |event| {\n///     match event {\n///         // In the cases where Ok(()) is returned,\n///         // Result falls back to the implementation of Control on the value ().\n///         // In the case of (), this is to always return Control::Continue.\n///         // continuing the search.\n///         DfsEvent::Discover(_, Time(t)) => {\n///             discover_time = t;\n///             Ok(())\n///         }\n///         DfsEvent::BackEdge(_, _) => {\n///             back_edges += 1;\n///             // the implementation of ControlFlow for Result,\n///             // treats this Err value as Continue::Break\n///             Err(event)\n///         }\n///         _ => Ok(()),\n///     }\n/// });\n///\n/// // Even though the graph has more than one cycle,\n/// // The number of back_edges visited by the search should always be 1.\n/// assert_eq!(back_edges, 1);\n/// println!(\"discover time:{:?}\", discover_time);\n/// println!(\"number of backedges encountered: {}\", back_edges);\n/// println!(\"back edge: {:?}\", result);\n/// ```\npub fn depth_first_search<G, I, F, C>(graph: G, starts: I, mut visitor: F) -> C\nwhere\n    G: IntoNeighbors + Visitable,\n    I: IntoIterator<Item = G::NodeId>,\n    F: FnMut(DfsEvent<G::NodeId>) -> C,\n    C: ControlFlow,{\n    let time = &mut Time(0);\n    let discovered = &mut graph.visit_map();\n    let finished = &mut graph.visit_map();\n\n    for start in starts {\n        try_control!(\n            dfs_visitor(graph, start, &mut visitor, discovered, finished, time),\n            unreachable!()\n        );\n    }\n    C::continuing()\n}","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"visit::dfsvisit::dfs_visitor":["fn dfs_visitor<G, F, C>(\n    graph: G,\n    u: G::NodeId,\n    visitor: &mut F,\n    discovered: &mut G::Map,\n    finished: &mut G::Map,\n    time: &mut Time,\n) -> C\nwhere\n    G: IntoNeighbors + Visitable,\n    F: FnMut(DfsEvent<G::NodeId>) -> C,\n    C: ControlFlow,{\n    if !discovered.visit(u) {\n        return C::continuing();\n    }\n\n    try_control!(\n        visitor(DfsEvent::Discover(u, time_post_inc(time))),\n        {},\n        for v in graph.neighbors(u) {\n            if !discovered.is_visited(&v) {\n                try_control!(visitor(DfsEvent::TreeEdge(u, v)), continue);\n                try_control!(\n                    dfs_visitor(graph, v, visitor, discovered, finished, time),\n                    unreachable!()\n                );\n            } else if !finished.is_visited(&v) {\n                try_control!(visitor(DfsEvent::BackEdge(u, v)), continue);\n            } else {\n                try_control!(visitor(DfsEvent::CrossForwardEdge(u, v)), continue);\n            }\n        }\n    );\n    let first_finish = finished.visit(u);\n    debug_assert!(first_finish);\n    try_control!(\n        visitor(DfsEvent::Finish(u, time_post_inc(time))),\n        panic!(\"Pruning on the `DfsEvent::Finish` is not supported!\")\n    );\n    C::continuing()\n}","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"visit::dfsvisit::time_post_inc":["fn time_post_inc(x: &mut Time) -> Time{\n    let v = *x;\n    x.0 += 1;\n    v\n}","Real(LocalPath(\"src/visit/dfsvisit.rs\"))"],"visit::filter::EdgeFiltered":["/// An edge-filtering graph adaptor.\n///\n/// The adaptor may filter out edges. The filter implements the trait\n/// `FilterEdge`. Closures of type `Fn(G::EdgeRef) -> bool` already\n/// implement this trait.\n///\n/// The filter may use edge source, target, id, and weight to select whether to\n/// include the edge or not.\npub struct EdgeFiltered<G, F>(pub G, pub F);","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::EdgeFiltered::<G, F>::from_fn":["/// Create an `EdgeFiltered` adaptor from the closure `filter`.\npub fn from_fn(graph: G, filter: F) -> Self{\n        EdgeFiltered(graph, filter)\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::EdgeFilteredEdges":["/// A filtered edges iterator.\npub struct EdgeFilteredEdges<'a, G, I, F: 'a> {\n    graph: PhantomData<G>,\n    iter: I,\n    f: &'a F,\n}","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::EdgeFilteredNeighbors":["/// A filtered neighbors iterator.\npub struct EdgeFilteredNeighbors<'a, G, F: 'a>\nwhere\n    G: IntoEdges,\n{\n    iter: G::Edges,\n    f: &'a F,\n}","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::EdgeFilteredNeighborsDirected":["/// A filtered neighbors-directed iterator.\npub struct EdgeFilteredNeighborsDirected<'a, G, F: 'a>\nwhere\n    G: IntoEdgesDirected,\n{\n    iter: G::EdgesDirected,\n    f: &'a F,\n    from: G::NodeId,\n}","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::FilterEdge":["/// A graph filter for edges\npub trait FilterEdge<Edge> {\n    /// Return true to have the edge be part of the graph\n    fn include_edge(&self, edge: Edge) -> bool;\n}","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::FilterNode":["/// A graph filter for nodes.\npub trait FilterNode<N> {\n    /// Return true to have the node be part of the graph\n    fn include_node(&self, node: N) -> bool;\n}","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::NodeFiltered":["/// A node-filtering graph adaptor.\npub struct NodeFiltered<G, F>(pub G, pub F);","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::NodeFiltered::<G, F>::from_fn":["/// Create an `NodeFiltered` adaptor from the closure `filter`.\npub fn from_fn(graph: G, filter: F) -> Self{\n        NodeFiltered(graph, filter)\n    }","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::NodeFilteredEdgeReferences":["/// A filtered edges iterator.\npub struct NodeFilteredEdgeReferences<'a, G, I, F: 'a> {\n    graph: PhantomData<G>,\n    iter: I,\n    f: &'a F,\n}","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::NodeFilteredEdges":["/// A filtered edges iterator.\npub struct NodeFilteredEdges<'a, G, I, F: 'a> {\n    graph: PhantomData<G>,\n    include_source: bool,\n    iter: I,\n    f: &'a F,\n}","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::NodeFilteredNeighbors":["/// A filtered neighbors iterator.\npub struct NodeFilteredNeighbors<'a, I, F: 'a> {\n    include_source: bool,\n    iter: I,\n    f: &'a F,\n}","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::filter::NodeFilteredNodes":["/// A filtered node references iterator.\npub struct NodeFilteredNodes<'a, I, F: 'a> {\n    include_source: bool,\n    iter: I,\n    f: &'a F,\n}","Real(LocalPath(\"src/visit/filter.rs\"))"],"visit::reversed::Reversed":["/// An edge-reversing graph adaptor.\n///\n/// All edges have the opposite direction with `Reversed`.\npub struct Reversed<G>(pub G);","Real(LocalPath(\"src/visit/reversed.rs\"))"],"visit::reversed::ReversedEdgeReference":["/// A reversed edge reference\npub struct ReversedEdgeReference<R>(R);","Real(LocalPath(\"src/visit/reversed.rs\"))"],"visit::reversed::ReversedEdgeReference::<R>::as_unreversed":["/// Return the original, unreversed edge reference.\npub fn as_unreversed(&self) -> &R{ &self.0 }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"visit::reversed::ReversedEdgeReference::<R>::into_unreversed":["/// Consume `self` and return the original, unreversed edge reference.\npub fn into_unreversed(self) -> R{\n        self.0\n    }","Real(LocalPath(\"src/visit/reversed.rs\"))"],"visit::reversed::ReversedEdgeReferences":["/// A reversed edge references iterator.\npub struct ReversedEdgeReferences<I> {\n    iter: I,\n}","Real(LocalPath(\"src/visit/reversed.rs\"))"],"visit::reversed::ReversedEdges":["/// A reversed edges iterator.\npub struct ReversedEdges<I> {\n    iter: I,\n}","Real(LocalPath(\"src/visit/reversed.rs\"))"],"visit::traversal::Bfs":["/// A breadth first search (BFS) of a graph.\n///\n/// The traversal starts at a given node and only traverses nodes reachable\n/// from it.\n///\n/// `Bfs` is not recursive.\n///\n/// `Bfs` does not itself borrow the graph, and because of this you can run\n/// a traversal over a graph while still retaining mutable access to it, if you\n/// use it like the following example:\n///\n/// ```\n/// use petgraph::Graph;\n/// use petgraph::visit::Bfs;\n///\n/// let mut graph = Graph::<_,()>::new();\n/// let a = graph.add_node(0);\n///\n/// let mut bfs = Bfs::new(&graph, a);\n/// while let Some(nx) = bfs.next(&graph) {\n///     // we can access `graph` mutably here still\n///     graph[nx] += 1;\n/// }\n///\n/// assert_eq!(graph[a], 1);\n/// ```\n///\n/// **Note:** The algorithm may not behave correctly if nodes are removed\n/// during iteration. It may not necessarily visit added nodes or edges.\npub struct Bfs<N, VM> {\n    /// The queue of nodes to visit\n    pub stack: VecDeque<N>,\n    /// The map of discovered nodes\n    pub discovered: VM,\n}","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Bfs::<N, VM>::new":["/// Create a new **Bfs**, using the graph's visitor map, and put **start**\n/// in the stack of nodes to visit.\npub fn new<G>(graph: G, start: N) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,{\n        let mut discovered = graph.visit_map();\n        discovered.visit(start);\n        let mut stack = VecDeque::new();\n        stack.push_front(start);\n        Bfs { stack, discovered }\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Bfs::<N, VM>::next":["/// Return the next node in the bfs, or **None** if the traversal is done.\npub fn next<G>(&mut self, graph: G) -> Option<N>\n    where\n        G: IntoNeighbors<NodeId = N>,{\n        if let Some(node) = self.stack.pop_front() {\n            for succ in graph.neighbors(node) {\n                if self.discovered.visit(succ) {\n                    self.stack.push_back(succ);\n                }\n            }\n\n            return Some(node);\n        }\n        None\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Dfs":["/// Visit nodes of a graph in a depth-first-search (DFS) emitting nodes in\n/// preorder (when they are first discovered).\n///\n/// The traversal starts at a given node and only traverses nodes reachable\n/// from it.\n///\n/// `Dfs` is not recursive.\n///\n/// `Dfs` does not itself borrow the graph, and because of this you can run\n/// a traversal over a graph while still retaining mutable access to it, if you\n/// use it like the following example:\n///\n/// ```\n/// use petgraph::Graph;\n/// use petgraph::visit::Dfs;\n///\n/// let mut graph = Graph::<_,()>::new();\n/// let a = graph.add_node(0);\n///\n/// let mut dfs = Dfs::new(&graph, a);\n/// while let Some(nx) = dfs.next(&graph) {\n///     // we can access `graph` mutably here still\n///     graph[nx] += 1;\n/// }\n///\n/// assert_eq!(graph[a], 1);\n/// ```\n///\n/// **Note:** The algorithm may not behave correctly if nodes are removed\n/// during iteration. It may not necessarily visit added nodes or edges.\npub struct Dfs<N, VM> {\n    /// The stack of nodes to visit\n    pub stack: Vec<N>,\n    /// The map of discovered nodes\n    pub discovered: VM,\n}","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Dfs::<N, VM>::empty":["/// Create a new **Dfs** using the graph's visitor map, and no stack.\npub fn empty<G>(graph: G) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,{\n        Dfs {\n            stack: Vec::new(),\n            discovered: graph.visit_map(),\n        }\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Dfs::<N, VM>::from_parts":["/// Create a `Dfs` from a vector and a visit map\npub fn from_parts(stack: Vec<N>, discovered: VM) -> Self{\n        Dfs { stack, discovered }\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Dfs::<N, VM>::move_to":["/// Keep the discovered map, but clear the visit stack and restart\n/// the dfs from a particular node.\npub fn move_to(&mut self, start: N){\n        self.stack.clear();\n        self.stack.push(start);\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Dfs::<N, VM>::new":["/// Create a new **Dfs**, using the graph's visitor map, and put **start**\n/// in the stack of nodes to visit.\npub fn new<G>(graph: G, start: N) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,{\n        let mut dfs = Dfs::empty(graph);\n        dfs.move_to(start);\n        dfs\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Dfs::<N, VM>::next":["/// Return the next node in the dfs, or **None** if the traversal is done.\npub fn next<G>(&mut self, graph: G) -> Option<N>\n    where\n        G: IntoNeighbors<NodeId = N>,{\n        while let Some(node) = self.stack.pop() {\n            if self.discovered.visit(node) {\n                for succ in graph.neighbors(node) {\n                    if !self.discovered.is_visited(&succ) {\n                        self.stack.push(succ);\n                    }\n                }\n                return Some(node);\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Dfs::<N, VM>::reset":["/// Clear the visit state\npub fn reset<G>(&mut self, graph: G)\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,{\n        graph.reset_map(&mut self.discovered);\n        self.stack.clear();\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::DfsPostOrder":["/// Visit nodes in a depth-first-search (DFS) emitting nodes in postorder\n/// (each node after all its descendants have been emitted).\n///\n/// `DfsPostOrder` is not recursive.\n///\n/// The traversal starts at a given node and only traverses nodes reachable\n/// from it.\npub struct DfsPostOrder<N, VM> {\n    /// The stack of nodes to visit\n    pub stack: Vec<N>,\n    /// The map of discovered nodes\n    pub discovered: VM,\n    /// The map of finished nodes\n    pub finished: VM,\n}","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::DfsPostOrder::<N, VM>::empty":["/// Create a new `DfsPostOrder` using the graph's visitor map, and no stack.\npub fn empty<G>(graph: G) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,{\n        DfsPostOrder {\n            stack: Vec::new(),\n            discovered: graph.visit_map(),\n            finished: graph.visit_map(),\n        }\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::DfsPostOrder::<N, VM>::move_to":["/// Keep the discovered and finished map, but clear the visit stack and restart\n/// the dfs from a particular node.\npub fn move_to(&mut self, start: N){\n        self.stack.clear();\n        self.stack.push(start);\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::DfsPostOrder::<N, VM>::new":["/// Create a new `DfsPostOrder` using the graph's visitor map, and put\n/// `start` in the stack of nodes to visit.\npub fn new<G>(graph: G, start: N) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,{\n        let mut dfs = Self::empty(graph);\n        dfs.move_to(start);\n        dfs\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::DfsPostOrder::<N, VM>::next":["/// Return the next node in the traversal, or `None` if the traversal is done.\npub fn next<G>(&mut self, graph: G) -> Option<N>\n    where\n        G: IntoNeighbors<NodeId = N>,{\n        while let Some(&nx) = self.stack.last() {\n            if self.discovered.visit(nx) {\n                // First time visiting `nx`: Push neighbors, don't pop `nx`\n                for succ in graph.neighbors(nx) {\n                    if !self.discovered.is_visited(&succ) {\n                        self.stack.push(succ);\n                    }\n                }\n            } else {\n                self.stack.pop();\n                if self.finished.visit(nx) {\n                    // Second time: All reachable nodes must have been finished\n                    return Some(nx);\n                }\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::DfsPostOrder::<N, VM>::reset":["/// Clear the visit state\npub fn reset<G>(&mut self, graph: G)\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,{\n        graph.reset_map(&mut self.discovered);\n        graph.reset_map(&mut self.finished);\n        self.stack.clear();\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Topo":["/// A topological order traversal for a graph.\n///\n/// **Note** that `Topo` only visits nodes that are not part of cycles,\n/// i.e. nodes in a true DAG. Use other visitors like `DfsPostOrder` or\n/// algorithms like kosaraju_scc to handle graphs with possible cycles.\npub struct Topo<N, VM> {\n    tovisit: Vec<N>,\n    ordered: VM,\n}","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Topo::<N, VM>::empty":["/// Create a new `Topo`, using the graph's visitor map with *no* starting\n/// index specified.\nfn empty<G>(graph: G) -> Self\n    where\n        G: GraphRef + Visitable<NodeId = N, Map = VM>,{\n        Topo {\n            ordered: graph.visit_map(),\n            tovisit: Vec::new(),\n        }\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Topo::<N, VM>::extend_with_initials":["fn extend_with_initials<G>(&mut self, g: G)\n    where\n        G: IntoNodeIdentifiers + IntoNeighborsDirected<NodeId = N>,{\n        // find all initial nodes (nodes without incoming edges)\n        self.tovisit.extend(\n            g.node_identifiers()\n                .filter(move |&a| g.neighbors_directed(a, Incoming).next().is_none()),\n        );\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Topo::<N, VM>::new":["/// Create a new `Topo`, using the graph's visitor map, and put all\n/// initial nodes in the to visit list.\npub fn new<G>(graph: G) -> Self\n    where\n        G: IntoNodeIdentifiers + IntoNeighborsDirected + Visitable<NodeId = N, Map = VM>,{\n        let mut topo = Self::empty(graph);\n        topo.extend_with_initials(graph);\n        topo\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Topo::<N, VM>::next":["/// Return the next node in the current topological order traversal, or\n/// `None` if the traversal is at the end.\n///\n/// *Note:* The graph may not have a complete topological order, and the only\n/// way to know is to run the whole traversal and make sure it visits every node.\npub fn next<G>(&mut self, g: G) -> Option<N>\n    where\n        G: IntoNeighborsDirected + Visitable<NodeId = N, Map = VM>,{\n        // Take an unvisited element and find which of its neighbors are next\n        while let Some(nix) = self.tovisit.pop() {\n            if self.ordered.is_visited(&nix) {\n                continue;\n            }\n            self.ordered.visit(nix);\n            for neigh in g.neighbors(nix) {\n                // Look at each neighbor, and those that only have incoming edges\n                // from the already ordered list, they are the next to visit.\n                if Reversed(g)\n                    .neighbors(neigh)\n                    .all(|b| self.ordered.is_visited(&b))\n                {\n                    self.tovisit.push(neigh);\n                }\n            }\n            return Some(nix);\n        }\n        None\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Topo::<N, VM>::reset":["/// Clear visited state, and put all initial nodes in the to visit list.\npub fn reset<G>(&mut self, graph: G)\n    where\n        G: IntoNodeIdentifiers + IntoNeighborsDirected + Visitable<NodeId = N, Map = VM>,{\n        graph.reset_map(&mut self.ordered);\n        self.tovisit.clear();\n        self.extend_with_initials(graph);\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Walker":["/// A walker is a traversal state, but where part of the traversal\n/// information is supplied manually to each next call.\n///\n/// This for example allows graph traversals that don't hold a borrow of the\n/// graph they are traversing.\npub trait Walker<Context> {\n    type Item;\n    /// Advance to the next item\n    fn walk_next(&mut self, context: Context) -> Option<Self::Item>;\n\n    /// Create an iterator out of the walker and given `context`.\n    fn iter(self, context: Context) -> WalkerIter<Self, Context>\n    where\n        Self: Sized,\n        Context: Clone,\n    {\n        WalkerIter {\n            walker: self,\n            context,\n        }\n    }\n}","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::Walker::iter":["/// Create an iterator out of the walker and given `context`.\nfn iter(self, context: Context) -> WalkerIter<Self, Context>\n    where\n        Self: Sized,\n        Context: Clone,{\n        WalkerIter {\n            walker: self,\n            context,\n        }\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::WalkerIter":["/// A walker and its context wrapped into an iterator.\npub struct WalkerIter<W, C> {\n    walker: W,\n    context: C,\n}","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::WalkerIter::<W, C>::context":["pub fn context(&self) -> C{\n        self.context.clone()\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::WalkerIter::<W, C>::inner_mut":["pub fn inner_mut(&mut self) -> &mut W{\n        &mut self.walker\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"],"visit::traversal::WalkerIter::<W, C>::inner_ref":["pub fn inner_ref(&self) -> &W{\n        &self.walker\n    }","Real(LocalPath(\"src/visit/traversal.rs\"))"]},"struct_constructor":{"&<&'a G as visit::Data>::EdgeWeight":["edge_weight"],"&<&'a G as visit::Data>::NodeWeight":["node_weight"],"&<&'a mut G as visit::Data>::EdgeWeight":["edge_weight"],"&<&'a mut G as visit::Data>::NodeWeight":["node_weight"],"&<(Id, &'a W) as visit::NodeRef>::Weight":["weight"],"&<(Id, ()) as visit::NodeRef>::Weight":["weight"],"&<G as std::ops::Index<I>>::Output":["index"],"&<Self as matrix_graph::Nullable>::Wrapped":["as_ref"],"&<Self as visit::Data>::EdgeWeight":["edge_weight"],"&<Self as visit::Data>::NodeWeight":["node_weight"],"&<Self as visit::EdgeRef>::Weight":["weight"],"&<Self as visit::NodeRef>::Weight":["weight"],"&<graph_impl::Frozen<'a, G> as visit::Data>::EdgeWeight":["edge_weight"],"&<graph_impl::Frozen<'a, G> as visit::Data>::NodeWeight":["node_weight"],"&<graph_impl::Graph<N, E, Ty, Ix> as visit::Data>::EdgeWeight":["edge_weight"],"&<graph_impl::Graph<N, E, Ty, Ix> as visit::Data>::NodeWeight":["node_weight"],"&<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::Data>::EdgeWeight":["edge_weight"],"&<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::Data>::NodeWeight":["node_weight"],"&<matrix_graph::NotZero<T> as matrix_graph::Nullable>::Wrapped":["as_ref"],"&<std::option::Option<T> as matrix_graph::Nullable>::Wrapped":["as_ref"],"&<visit::filter::NodeFiltered<G, F> as visit::Data>::EdgeWeight":["edge_weight"],"&<visit::filter::NodeFiltered<G, F> as visit::Data>::NodeWeight":["node_weight"],"&<visit::reversed::Reversed<G> as visit::Data>::EdgeWeight":["edge_weight"],"&<visit::reversed::Reversed<G> as visit::Data>::NodeWeight":["node_weight"],"&<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::Weight":["weight"],"&[E]":["edges_slice"],"&[Ix]":["neighbors_slice"],"&[graph_impl::Edge<E, Ix>]":["raw_edges"],"&[graph_impl::Edge<std::option::Option<E>, Ix>]":["raw_edges"],"&[graph_impl::Node<N, Ix>]":["raw_nodes"],"&[graph_impl::Node<std::option::Option<N>, Ix>]":["raw_nodes"],"&mut <&'a mut G as visit::Data>::EdgeWeight":["edge_weight_mut"],"&mut <&'a mut G as visit::Data>::NodeWeight":["node_weight_mut"],"&mut <G as std::ops::Index<I>>::Output":["index_mut"],"&mut <Self as matrix_graph::Nullable>::Wrapped":["as_mut"],"&mut <Self as visit::Data>::EdgeWeight":["edge_weight_mut"],"&mut <Self as visit::Data>::NodeWeight":["node_weight_mut"],"&mut <graph_impl::Frozen<'a, G> as visit::Data>::EdgeWeight":["edge_weight_mut"],"&mut <graph_impl::Frozen<'a, G> as visit::Data>::NodeWeight":["node_weight_mut"],"&mut <graph_impl::Graph<N, E, Ty, Ix> as visit::Data>::EdgeWeight":["edge_weight_mut"],"&mut <graph_impl::Graph<N, E, Ty, Ix> as visit::Data>::NodeWeight":["node_weight_mut"],"&mut <graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::Data>::EdgeWeight":["edge_weight_mut"],"&mut <graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::Data>::NodeWeight":["node_weight_mut"],"&mut <matrix_graph::NotZero<T> as matrix_graph::Nullable>::Wrapped":["as_mut"],"&mut <std::option::Option<T> as matrix_graph::Nullable>::Wrapped":["as_mut"],"&mut <visit::reversed::Reversed<G> as visit::Data>::EdgeWeight":["edge_weight_mut"],"&mut <visit::reversed::Reversed<G> as visit::Data>::NodeWeight":["node_weight_mut"],"(&mut <graph_impl::Graph<N, E, Ty, Ix> as std::ops::Index<T>>::Output, &mut <graph_impl::Graph<N, E, Ty, Ix> as std::ops::Index<U>>::Output)":["index_twice_mut"],"(&mut <graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::Index<T>>::Output, &mut <graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::Index<U>>::Output)":["index_twice_mut"],"(<Self as IntoWeightedEdge<E>>::NodeId, <Self as IntoWeightedEdge<E>>::NodeId, E)":["into_weighted_edge"],"(Ix, Ix, E)":["into_weighted_edge"],"(K, std::vec::Vec<<G as visit::GraphBase>::NodeId>)":["astar"],"(N, N)":["edge_key","id"],"(graph_impl::EdgeIndex<Ix>, &mut graph_impl::Edge<E, Ix>)":["next"],"(graph_impl::EdgeIndex<Ix>, Direction)":["find_edge_undirected","find_edge_undirected_from_node"],"(graph_impl::EdgeIndex<Ix>, graph_impl::NodeIndex<Ix>)":["next"],"(graph_impl::NodeIndex<Ix>, graph_impl::NodeIndex<Ix>)":["edge_endpoints"],"(std::vec::Vec<<G as visit::Data>::EdgeWeight>, std::vec::Vec<std::option::Option<<G as visit::GraphBase>::NodeId>>)":["bellman_ford"],"(std::vec::Vec<<G as visit::GraphBase>::NodeId>, std::collections::HashMap<<G as visit::GraphBase>::NodeId, std::collections::HashSet<<G as visit::GraphBase>::NodeId>>)":["simple_fast_post_order"],"(std::vec::Vec<graph_impl::Node<N, Ix>>, std::vec::Vec<graph_impl::Edge<E, Ix>>)":["into_nodes_edges"],"(usize, &[Ix])":["neighbors_of"],"(usize, std::option::Option<usize>)":["size_hint"],"(usize, usize)":["capacity"],"<&'a G as visit::GetAdjacencyMatrix>::AdjMatrix":["adjacency_matrix"],"<&'a G as visit::GraphBase>::NodeId":["from_index"],"<&'a G as visit::IntoEdgeReferences>::EdgeReferences":["edge_references"],"<&'a G as visit::IntoEdges>::Edges":["edges"],"<&'a G as visit::IntoEdgesDirected>::EdgesDirected":["edges_directed"],"<&'a G as visit::IntoNeighbors>::Neighbors":["neighbors"],"<&'a G as visit::IntoNeighborsDirected>::NeighborsDirected":["neighbors_directed"],"<&'a G as visit::IntoNodeIdentifiers>::NodeIdentifiers":["node_identifiers"],"<&'a G as visit::IntoNodeReferences>::NodeReferences":["node_references"],"<&'a G as visit::Visitable>::Map":["visit_map"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoEdgeReferences>::EdgeReferences":["edge_references"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoEdges>::Edges":["edges"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoNeighbors>::Neighbors":["neighbors"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoNodeIdentifiers>::NodeIdentifiers":["node_identifiers"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdgeReferences>::EdgeReferences":["edge_references"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdges>::Edges":["edges"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdgesDirected>::EdgesDirected":["edges_directed"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNodeReferences>::NodeReferences":["node_references"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdgeReferences>::EdgeReferences":["edge_references"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdges>::Edges":["edges"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdgesDirected>::EdgesDirected":["edges_directed"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNeighbors>::Neighbors":["neighbors"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNeighborsDirected>::NeighborsDirected":["neighbors_directed"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNodeIdentifiers>::NodeIdentifiers":["node_identifiers"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNodeReferences>::NodeReferences":["node_references"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoEdgeReferences>::EdgeReferences":["edge_references"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoEdges>::Edges":["edges"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNeighbors>::Neighbors":["neighbors"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNeighborsDirected>::NeighborsDirected":["neighbors_directed"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNodeIdentifiers>::NodeIdentifiers":["node_identifiers"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNodeReferences>::NodeReferences":["node_references"],"<&'a matrix_graph::MatrixGraph<N, E, Directed, Null, Ix> as visit::IntoNeighborsDirected>::NeighborsDirected":["neighbors_directed"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoEdgeReferences>::EdgeReferences":["edge_references"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoEdges>::Edges":["edges"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNeighbors>::Neighbors":["neighbors"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNodeIdentifiers>::NodeIdentifiers":["node_identifiers"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNodeReferences>::NodeReferences":["node_references"],"<&'a mut W as visit::traversal::Walker<C>>::Item":["walk_next"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoEdgeReferences>::EdgeReferences":["edge_references"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoEdges>::Edges":["edges"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNeighbors>::Neighbors":["neighbors"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNeighborsDirected>::NeighborsDirected":["neighbors_directed"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNodeIdentifiers>::NodeIdentifiers":["node_identifiers"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNodeReferences>::NodeReferences":["node_references"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoEdgeReferences>::EdgeReferences":["edge_references"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoEdges>::Edges":["edges"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNeighbors>::Neighbors":["neighbors"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNeighborsDirected>::NeighborsDirected":["neighbors_directed"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNodeIdentifiers>::NodeIdentifiers":["node_identifiers"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNodeReferences>::NodeReferences":["node_references"],"<&'b graph_impl::Frozen<'a, G> as visit::IntoEdgeReferences>::EdgeReferences":["edge_references"],"<&'b graph_impl::Frozen<'a, G> as visit::IntoEdges>::Edges":["edges"],"<&'b graph_impl::Frozen<'a, G> as visit::IntoEdgesDirected>::EdgesDirected":["edges_directed"],"<&'b graph_impl::Frozen<'a, G> as visit::IntoNeighbors>::Neighbors":["neighbors"],"<&'b graph_impl::Frozen<'a, G> as visit::IntoNeighborsDirected>::NeighborsDirected":["neighbors_directed"],"<&'b graph_impl::Frozen<'a, G> as visit::IntoNodeIdentifiers>::NodeIdentifiers":["node_identifiers"],"<&'b graph_impl::Frozen<'a, G> as visit::IntoNodeReferences>::NodeReferences":["node_references"],"<(Id, &'a W) as visit::NodeRef>::NodeId":["id"],"<(Id, ()) as visit::NodeRef>::NodeId":["id"],"<G as visit::IntoNeighborsDirected>::NeighborsDirected":["neighbors","neighbors_directed"],"<G as visit::Visitable>::Map":["visit_map"],"<Self as visit::EdgeRef>::EdgeId":["id"],"<Self as visit::EdgeRef>::NodeId":["source","target"],"<Self as visit::GetAdjacencyMatrix>::AdjMatrix":["adjacency_matrix"],"<Self as visit::GraphBase>::EdgeId":["add_edge","update_edge"],"<Self as visit::GraphBase>::NodeId":["add_node","from_index"],"<Self as visit::IntoEdgeReferences>::EdgeReferences":["edge_references"],"<Self as visit::IntoEdges>::Edges":["edges"],"<Self as visit::IntoEdgesDirected>::EdgesDirected":["edges_directed"],"<Self as visit::IntoNeighbors>::Neighbors":["neighbors"],"<Self as visit::IntoNeighborsDirected>::NeighborsDirected":["neighbors_directed"],"<Self as visit::IntoNodeIdentifiers>::NodeIdentifiers":["node_identifiers"],"<Self as visit::IntoNodeReferences>::NodeReferences":["node_references"],"<Self as visit::NodeRef>::NodeId":["id"],"<Self as visit::Visitable>::Map":["visit_map"],"<Self as visit::traversal::Walker<Context>>::Item":["walk_next"],"<algo::MinSpanningTree<G> as std::iter::Iterator>::Item":["next"],"<algo::dominators::DominatorsIter<'a, N> as std::iter::Iterator>::Item":["next"],"<csr::Csr<N, E, Ty, Ix> as visit::GraphBase>::NodeId":["from_index"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::EdgeId":["id"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::NodeId":["source","target"],"<csr::EdgeReferences<'a, E, Ty, Ix> as std::iter::Iterator>::Item":["next"],"<csr::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::Item":["next"],"<csr::Neighbors<'a, Ix> as std::iter::Iterator>::Item":["next"],"<csr::NodeIdentifiers<Ix> as std::iter::Iterator>::Item":["next"],"<data::FilterElements<I, F> as std::iter::Iterator>::Item":["next"],"<graph_impl::EdgeIndices<Ix> as std::iter::Iterator>::Item":["next","next_back"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::EdgeId":["id"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::NodeId":["source","target"],"<graph_impl::EdgeReferences<'a, E, Ix> as std::iter::Iterator>::Item":["next","next_back"],"<graph_impl::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::Item":["next"],"<graph_impl::Frozen<'a, G> as visit::GetAdjacencyMatrix>::AdjMatrix":["adjacency_matrix"],"<graph_impl::Frozen<'a, G> as visit::GraphBase>::NodeId":["from_index"],"<graph_impl::Frozen<'a, G> as visit::Visitable>::Map":["visit_map"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::GraphBase>::EdgeId":["add_edge","update_edge"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::GraphBase>::NodeId":["add_node","from_index"],"<graph_impl::NodeIndices<Ix> as std::iter::Iterator>::Item":["next","next_back"],"<graph_impl::NodeReferences<'a, N, Ix> as std::iter::Iterator>::Item":["next","next_back"],"<graph_impl::stable_graph::EdgeIndices<'a, E, Ix> as std::iter::Iterator>::Item":["next","next_back"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::EdgeId":["id"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::NodeId":["source","target"],"<graph_impl::stable_graph::EdgeReferences<'a, E, Ix> as std::iter::Iterator>::Item":["next","next_back"],"<graph_impl::stable_graph::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::Item":["next"],"<graph_impl::stable_graph::NodeIndices<'a, N, Ix> as std::iter::Iterator>::Item":["next","next_back"],"<graph_impl::stable_graph::NodeReferences<'a, N, Ix> as std::iter::Iterator>::Item":["next","next_back"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::GraphBase>::EdgeId":["add_edge","update_edge"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::GraphBase>::NodeId":["add_node","from_index"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::Item":["last","next","next_back","nth"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::Item":["last","next","next_back","nth"],"<graphmap::Edges<'a, N, E, Ty> as std::iter::Iterator>::Item":["next"],"<graphmap::GraphMap<N, E, Ty> as visit::GraphBase>::EdgeId":["add_edge","update_edge"],"<graphmap::GraphMap<N, E, Ty> as visit::GraphBase>::NodeId":["add_node","from_index"],"<graphmap::NodeIdentifiers<'a, N, E, Ty> as std::iter::Iterator>::Item":["next"],"<graphmap::NodeReferences<'a, N, E, Ty> as std::iter::Iterator>::Item":["next"],"<graphmap::Nodes<'a, N> as std::iter::Iterator>::Item":["next"],"<matrix_graph::EdgeReferences<'a, Ty, Null, Ix> as std::iter::Iterator>::Item":["next"],"<matrix_graph::Edges<'a, Ty, Null, Ix> as std::iter::Iterator>::Item":["next"],"<matrix_graph::IdIterator<'a> as std::iter::Iterator>::Item":["next"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::GetAdjacencyMatrix>::AdjMatrix":["adjacency_matrix"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::GraphBase>::EdgeId":["add_edge","update_edge"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::GraphBase>::NodeId":["add_node","from_index"],"<matrix_graph::Neighbors<'a, Ty, Null, Ix> as std::iter::Iterator>::Item":["next"],"<matrix_graph::NodeIdentifiers<'a, Ix> as std::iter::Iterator>::Item":["next"],"<matrix_graph::NodeReferences<'a, N, Ix> as std::iter::Iterator>::Item":["next"],"<visit::filter::EdgeFiltered<G, F> as visit::GraphBase>::NodeId":["from_index"],"<visit::filter::EdgeFiltered<G, F> as visit::Visitable>::Map":["visit_map"],"<visit::filter::EdgeFilteredEdges<'a, G, I, F> as std::iter::Iterator>::Item":["next"],"<visit::filter::EdgeFilteredNeighbors<'a, G, F> as std::iter::Iterator>::Item":["next"],"<visit::filter::EdgeFilteredNeighborsDirected<'a, G, F> as std::iter::Iterator>::Item":["next"],"<visit::filter::NodeFiltered<G, F> as visit::GraphBase>::NodeId":["from_index"],"<visit::filter::NodeFiltered<G, F> as visit::Visitable>::Map":["visit_map"],"<visit::filter::NodeFilteredEdgeReferences<'a, G, I, F> as std::iter::Iterator>::Item":["next"],"<visit::filter::NodeFilteredEdges<'a, G, I, F> as std::iter::Iterator>::Item":["next"],"<visit::filter::NodeFilteredNeighbors<'a, I, F> as std::iter::Iterator>::Item":["next"],"<visit::filter::NodeFilteredNodes<'a, I, F> as std::iter::Iterator>::Item":["next"],"<visit::reversed::Reversed<G> as visit::GraphBase>::NodeId":["from_index"],"<visit::reversed::Reversed<G> as visit::IntoEdgeReferences>::EdgeReferences":["edge_references"],"<visit::reversed::Reversed<G> as visit::IntoEdges>::Edges":["edges","edges_directed"],"<visit::reversed::Reversed<G> as visit::IntoNodeIdentifiers>::NodeIdentifiers":["node_identifiers"],"<visit::reversed::Reversed<G> as visit::IntoNodeReferences>::NodeReferences":["node_references"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::EdgeId":["id"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::NodeId":["source","target"],"<visit::reversed::ReversedEdgeReferences<I> as std::iter::Iterator>::Item":["next"],"<visit::reversed::ReversedEdges<I> as std::iter::Iterator>::Item":["next"],"<visit::traversal::Bfs<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::Item":["walk_next"],"<visit::traversal::Dfs<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::Item":["walk_next"],"<visit::traversal::DfsPostOrder<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::Item":["walk_next"],"<visit::traversal::Topo<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::Item":["walk_next"],"<visit::traversal::WalkerIter<W, C> as std::iter::Iterator>::Item":["next"],"Directed":["clone"],"Direction":["clone"],"Undirected":["clone"],"algo::Cycle":["clone"],"algo::DfsSpace":["clone","default","new"],"algo::MinSpanningTree":["min_spanning_tree"],"algo::NegativeCycle":["clone"],"algo::dominators::Dominators":["clone","simple_fast"],"algo::dominators::DominatorsIter":["dominators","strict_dominators"],"algo::tarjan_scc::NodeData":["clone"],"astar::PathTracker":["new"],"bool":["add_edge","add_edge_","contains_edge","contains_node","enabled","eq","equiv","has_edge","has_path_connecting","include_edge","include_node","is_adjacent","is_bipartite_undirected","is_complete","is_cyclic_directed","is_cyclic_undirected","is_directed","is_isomorphic","is_isomorphic_matching","is_node_index","is_null","is_visited","is_zero","ptr_eq","remove_node","remove_single_edge","should_break","should_prune","try_match","union","visit"],"csr::Csr":["clone","default","from_sorted_edges","new","with_nodes"],"csr::EdgeReference":["clone"],"csr::Edges":["clone","edges"],"csr::EdgesNotSorted":["clone"],"csr::Neighbors":["clone"],"data::Element":["clone"],"data::FilterElements":["filter_elements"],"dot::Dot":["new","with_attr_getters","with_config"],"f32":["infinite","zero"],"f64":["infinite","zero"],"fixedbitset::FixedBitSet":["adjacency_matrix","visit_map"],"graph_impl::Edge":["clone"],"graph_impl::EdgeIndex":["_into_edge","add_edge","clone","default","edge_index","end","find_edge","find_edge_directed_from_node","first_edge","from","new","next_edge","update_edge"],"graph_impl::EdgeIndices":["clone","edge_indices"],"graph_impl::EdgeReference":["clone","next"],"graph_impl::EdgeReferences":["edge_references"],"graph_impl::EdgeWeightsMut":["edge_weights_mut"],"graph_impl::Edges":["clone","edges","edges_directed"],"graph_impl::EdgesConnecting":["edges_connecting"],"graph_impl::EdgesWalkerMut":["edges_walker_mut"],"graph_impl::Externals":["externals"],"graph_impl::Frozen":["new"],"graph_impl::Graph":["clone","default","filter_map","from","from_edges","from_elements","into_graph","map","new","new_undirected","with_capacity"],"graph_impl::Neighbors":["clone","neighbors","neighbors_directed","neighbors_undirected"],"graph_impl::Node":["clone"],"graph_impl::NodeIndex":["_into_node","add_node","clone","default","end","from","new","next","next_node","node_index","source","target"],"graph_impl::NodeIndices":["clone","node_identifiers","node_indices"],"graph_impl::NodeWeightsMut":["node_weights_mut"],"graph_impl::Pair":["index_twice"],"graph_impl::WalkNeighbors":["clone","detach"],"graph_impl::stable_graph::EdgeIndices":["edge_indices"],"graph_impl::stable_graph::EdgeReference":["clone"],"graph_impl::stable_graph::Edges":["edges","edges_directed"],"graph_impl::stable_graph::Externals":["externals"],"graph_impl::stable_graph::Neighbors":["neighbors","neighbors_directed","neighbors_undirected"],"graph_impl::stable_graph::NodeIndices":["node_indices"],"graph_impl::stable_graph::StableGraph":["clone","default","filter_map","from","from_edges","from_elements","map","new","with_capacity"],"graph_impl::stable_graph::WalkNeighbors":["clone","detach"],"graphmap::AllEdges":["all_edges"],"graphmap::AllEdgesMut":["all_edges_mut"],"graphmap::CompactDirection":["clone","from"],"graphmap::Edges":["edges"],"graphmap::GraphMap":["clone","default","from_edges","from_elements","from_iter","new","with_capacity"],"graphmap::Neighbors":["neighbors"],"graphmap::NeighborsDirected":["neighbors_directed"],"graphmap::Nodes":["nodes"],"graphmap::Ptr":["clone"],"i16":["zero"],"i32":["zero"],"i64":["zero"],"i8":["zero"],"impl std::iter::Iterator<Item = &mut E>":["edge_weights_mut"],"impl std::iter::Iterator<Item = &mut N>":["node_weights_mut"],"impl std::iter::Iterator<Item = TargetColl>":["all_simple_paths"],"isize":["zero"],"isomorphism::Vf2State":["new"],"isomorphism::try_match::Frame":["clone"],"isomorphism::try_match::OpenList":["clone"],"iter_format::Format":["clone","format"],"matrix_graph::EdgeReferences":["new"],"matrix_graph::Edges":["edges","edges_directed","on_columns","on_rows"],"matrix_graph::IdIterator":["iter_ids"],"matrix_graph::IdStorage":["clone","with_capacity"],"matrix_graph::MatrixGraph":["clone","default","from_edges","new","new_undirected","with_capacity"],"matrix_graph::Neighbors":["neighbors","neighbors_directed"],"matrix_graph::NodeIdentifiers":["new"],"matrix_graph::NodeReferences":["new"],"matrix_graph::NotZero":["default","new"],"scored::MinScored":["clone"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::collections::HashMap":["dijkstra"],"std::collections::HashSet":["visit_map"],"std::iter::Enumerate":["enumerate"],"std::iter::Zip":["zip"],"std::ops::Range":["neighbors_range"],"std::vec::Vec":["into_labeling","kosaraju_scc","predecessor_sets_to_idx_vecs","reconstruct_path_to","scc","tarjan_scc","toposort"],"u16":["max","new","zero"],"u32":["max","new","zero"],"u64":["zero"],"u8":["max","new","zero"],"unionfind::UnionFind":["clone","new"],"usize":["add","connected_components","count","edge_bound","edge_count","find_edge_pos","index","len","max","node_bound","node_count","out_degree","to_edge_position","to_index","zero"],"visit::dfsvisit::Control":["breaking","clone","continuing","default"],"visit::dfsvisit::DfsEvent":["clone"],"visit::dfsvisit::Time":["clone","default","time_post_inc"],"visit::filter::EdgeFiltered":["clone","from_fn"],"visit::filter::NodeFiltered":["clone","from_fn"],"visit::reversed::Reversed":["clone"],"visit::reversed::ReversedEdgeReference":["clone"],"visit::traversal::Bfs":["clone","default","new"],"visit::traversal::Dfs":["clone","default","empty","from_parts","new"],"visit::traversal::DfsPostOrder":["clone","default","empty","new"],"visit::traversal::Topo":["clone","default","empty","new"],"visit::traversal::WalkerIter":["clone","iter"]},"struct_to_trait":{"<F as isomorphism::SemanticMatcher<T>>::F":["isomorphism::SemanticMatcher"],"<F as visit::filter::FilterEdge<N>>::F":["visit::filter::FilterEdge"],"<F as visit::filter::FilterNode<N>>::F":["visit::filter::FilterNode"],"<I as data::ElementIterator<N, E>>::I":["data::ElementIterator"],"<I as iter_format::IterFormatExt>::I":["iter_format::IterFormatExt"],"<I as iter_utils::IterUtilsExt>::I":["iter_utils::IterUtilsExt"],"<M as algo::Measure>::M":["algo::Measure"],"<N as graphmap::NodeTrait>::N":["graphmap::NodeTrait"],"Directed":["EdgeType","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"Direction":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"Undirected":["EdgeType","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"algo::Cycle":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"algo::DfsSpace":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"algo::MinSpanningTree":["std::iter::Iterator"],"algo::NegativeCycle":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"algo::dominators::Dominators":["std::clone::Clone","std::fmt::Debug"],"algo::dominators::DominatorsIter":["std::iter::Iterator"],"algo::tarjan_scc::Data":["std::fmt::Debug"],"algo::tarjan_scc::NodeData":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"csr::Csr":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::ops::Index","std::ops::IndexMut","visit::Data","visit::GraphBase","visit::GraphProp","visit::NodeCompactIndexable","visit::NodeCount","visit::NodeIndexable","visit::Visitable"],"csr::EdgeReference":["std::clone::Clone","std::fmt::Debug","std::marker::Copy","visit::EdgeRef"],"csr::EdgeReferences":["std::iter::Iterator"],"csr::Edges":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"csr::EdgesNotSorted":["std::clone::Clone","std::fmt::Debug"],"csr::Neighbors":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"csr::NodeIdentifiers":["std::iter::Iterator"],"data::Element":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"data::FilterElements":["std::iter::Iterator"],"dot::Config":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"dot::DebugFmt":["std::fmt::Display"],"dot::Dot":["std::fmt::Debug","std::fmt::Display"],"dot::Escaped":["std::fmt::Display"],"dot::Escaper":["std::fmt::Write"],"fixedbitset::FixedBitSet":["visit::VisitMap","visit::filter::FilterNode"],"graph_impl::Edge":["std::clone::Clone","std::fmt::Debug"],"graph_impl::EdgeIndex":["graph_impl::GraphIndex","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"graph_impl::EdgeIndices":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"graph_impl::EdgeReference":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","visit::EdgeRef"],"graph_impl::EdgeReferences":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"graph_impl::EdgeWeightsMut":["std::iter::Iterator"],"graph_impl::Edges":["std::clone::Clone","std::iter::Iterator"],"graph_impl::EdgesConnecting":["std::iter::Iterator"],"graph_impl::Externals":["std::iter::Iterator"],"graph_impl::Frozen":["data::DataMap","data::DataMapMut","std::ops::Deref","std::ops::Index","std::ops::IndexMut","visit::Data","visit::GetAdjacencyMatrix","visit::GraphBase","visit::GraphProp","visit::NodeCompactIndexable","visit::NodeCount","visit::NodeIndexable","visit::Visitable"],"graph_impl::Graph":["data::Build","data::Create","data::DataMap","data::DataMapMut","data::FromElements","std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug","std::ops::Index","std::ops::IndexMut","visit::Data","visit::GetAdjacencyMatrix","visit::GraphBase","visit::GraphProp","visit::NodeCompactIndexable","visit::NodeCount","visit::NodeIndexable","visit::Visitable"],"graph_impl::Neighbors":["std::clone::Clone","std::iter::Iterator"],"graph_impl::Node":["std::clone::Clone","std::fmt::Debug"],"graph_impl::NodeIndex":["graph_impl::GraphIndex","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"graph_impl::NodeIndices":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"graph_impl::NodeReferences":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"graph_impl::NodeWeightsMut":["std::iter::Iterator"],"graph_impl::WalkNeighbors":["std::clone::Clone"],"graph_impl::stable_graph::EdgeIndices":["std::iter::DoubleEndedIterator","std::iter::Iterator"],"graph_impl::stable_graph::EdgeReference":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","visit::EdgeRef"],"graph_impl::stable_graph::EdgeReferences":["std::iter::DoubleEndedIterator","std::iter::Iterator"],"graph_impl::stable_graph::Edges":["std::iter::Iterator"],"graph_impl::stable_graph::Externals":["std::iter::Iterator"],"graph_impl::stable_graph::Neighbors":["std::iter::Iterator"],"graph_impl::stable_graph::NodeIndices":["std::iter::DoubleEndedIterator","std::iter::Iterator"],"graph_impl::stable_graph::NodeReferences":["std::iter::DoubleEndedIterator","std::iter::Iterator"],"graph_impl::stable_graph::StableGraph":["data::Build","data::Create","data::DataMap","data::DataMapMut","data::FromElements","std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug","std::ops::Index","std::ops::IndexMut","visit::Data","visit::GetAdjacencyMatrix","visit::GraphBase","visit::GraphProp","visit::NodeCount","visit::NodeIndexable","visit::Visitable"],"graph_impl::stable_graph::WalkNeighbors":["std::clone::Clone"],"graphmap::AllEdges":["std::iter::DoubleEndedIterator","std::iter::Iterator"],"graphmap::AllEdgesMut":["std::iter::DoubleEndedIterator","std::iter::Iterator"],"graphmap::CompactDirection":["std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"graphmap::Edges":["std::iter::Iterator"],"graphmap::GraphMap":["data::Build","data::Create","data::FromElements","std::clone::Clone","std::default::Default","std::fmt::Debug","std::iter::Extend","std::iter::FromIterator","std::ops::Index","std::ops::IndexMut","visit::Data","visit::GetAdjacencyMatrix","visit::GraphBase","visit::GraphProp","visit::NodeCompactIndexable","visit::NodeCount","visit::NodeIndexable","visit::Visitable"],"graphmap::Neighbors":["std::iter::Iterator"],"graphmap::NeighborsDirected":["std::iter::Iterator"],"graphmap::NodeIdentifiers":["std::iter::Iterator"],"graphmap::NodeReferences":["std::iter::Iterator"],"graphmap::Nodes":["std::iter::Iterator"],"graphmap::Ptr":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::ops::Deref"],"isomorphism::NoSemanticMatch":["isomorphism::SemanticMatcher"],"isomorphism::Vf2State":["std::fmt::Debug"],"isomorphism::try_match::Frame":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"isomorphism::try_match::OpenList":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"iter_format::DebugMap":["std::fmt::Debug"],"iter_format::Format":["std::clone::Clone","std::fmt::Debug"],"iter_format::NoPretty":["std::fmt::Debug"],"matrix_graph::EdgeReferences":["std::iter::Iterator"],"matrix_graph::Edges":["std::iter::Iterator"],"matrix_graph::IdIterator":["std::iter::Iterator"],"matrix_graph::IdStorage":["std::clone::Clone","std::ops::Index","std::ops::IndexMut"],"matrix_graph::MatrixGraph":["data::Build","std::clone::Clone","std::default::Default","std::ops::Index","std::ops::IndexMut","visit::Data","visit::GetAdjacencyMatrix","visit::GraphBase","visit::GraphProp","visit::NodeCompactIndexable","visit::NodeCount","visit::NodeIndexable","visit::Visitable"],"matrix_graph::Neighbors":["std::iter::Iterator"],"matrix_graph::NodeIdentifiers":["std::iter::Iterator"],"matrix_graph::NodeReferences":["std::iter::Iterator"],"matrix_graph::NotZero":["matrix_graph::Nullable","matrix_graph::private::Sealed","std::convert::Into","std::default::Default"],"scored::MinScored":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy"],"std::collections::HashSet":["visit::VisitMap","visit::filter::FilterNode"],"std::option::Option":["matrix_graph::Nullable","matrix_graph::private::Sealed"],"std::result::Result":["visit::dfsvisit::ControlFlow"],"unionfind::UnionFind":["std::clone::Clone","std::fmt::Debug"],"visit::dfsvisit::Control":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::marker::Copy","visit::dfsvisit::ControlFlow"],"visit::dfsvisit::DfsEvent":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"visit::dfsvisit::Time":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"visit::filter::EdgeFiltered":["std::clone::Clone","std::fmt::Debug","std::marker::Copy","visit::Data","visit::GraphBase","visit::GraphProp","visit::NodeCompactIndexable","visit::NodeCount","visit::NodeIndexable","visit::Visitable"],"visit::filter::EdgeFilteredEdges":["std::iter::Iterator"],"visit::filter::EdgeFilteredNeighbors":["std::iter::Iterator"],"visit::filter::EdgeFilteredNeighborsDirected":["std::iter::Iterator"],"visit::filter::NodeFiltered":["data::DataMap","std::clone::Clone","std::fmt::Debug","std::marker::Copy","visit::Data","visit::GraphBase","visit::GraphProp","visit::NodeIndexable","visit::Visitable"],"visit::filter::NodeFilteredEdgeReferences":["std::iter::Iterator"],"visit::filter::NodeFilteredEdges":["std::iter::Iterator"],"visit::filter::NodeFilteredNeighbors":["std::iter::Iterator"],"visit::filter::NodeFilteredNodes":["std::iter::Iterator"],"visit::reversed::Reversed":["data::DataMap","data::DataMapMut","std::clone::Clone","std::fmt::Debug","std::marker::Copy","visit::Data","visit::GraphBase","visit::GraphProp","visit::GraphRef","visit::IntoEdgeReferences","visit::IntoEdges","visit::IntoEdgesDirected","visit::IntoNeighbors","visit::IntoNeighborsDirected","visit::IntoNodeIdentifiers","visit::IntoNodeReferences","visit::NodeCompactIndexable","visit::NodeCount","visit::NodeIndexable","visit::Visitable"],"visit::reversed::ReversedEdgeReference":["std::clone::Clone","std::fmt::Debug","std::marker::Copy","visit::EdgeRef"],"visit::reversed::ReversedEdgeReferences":["std::iter::Iterator"],"visit::reversed::ReversedEdges":["std::iter::Iterator"],"visit::traversal::Bfs":["std::clone::Clone","std::default::Default","visit::traversal::Walker"],"visit::traversal::Dfs":["std::clone::Clone","std::default::Default","std::fmt::Debug","visit::traversal::Walker"],"visit::traversal::DfsPostOrder":["std::clone::Clone","std::default::Default","std::fmt::Debug","visit::traversal::Walker"],"visit::traversal::Topo":["std::clone::Clone","std::default::Default","visit::traversal::Walker"],"visit::traversal::WalkerIter":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"]},"targets":{"<&'a (Ix, Ix) as IntoWeightedEdge<E>>::into_weighted_edge":["into_weighted_edge","Real(LocalPath(\"src/lib.rs\"))","IntoWeightedEdge"],"<&'a (Ix, Ix, E) as IntoWeightedEdge<E>>::into_weighted_edge":["into_weighted_edge","Real(LocalPath(\"src/lib.rs\"))","IntoWeightedEdge"],"<&'a G as data::DataMap>::edge_weight":["edge_weight","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMap"],"<&'a G as data::DataMap>::node_weight":["node_weight","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMap"],"<&'a G as visit::GetAdjacencyMatrix>::adjacency_matrix":["adjacency_matrix","Real(LocalPath(\"src/visit/macros.rs\"))","visit::GetAdjacencyMatrix"],"<&'a G as visit::GetAdjacencyMatrix>::is_adjacent":["is_adjacent","Real(LocalPath(\"src/visit/macros.rs\"))","visit::GetAdjacencyMatrix"],"<&'a G as visit::IntoEdgeReferences>::edge_references":["edge_references","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoEdgeReferences"],"<&'a G as visit::IntoEdges>::edges":["edges","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoEdges"],"<&'a G as visit::IntoEdgesDirected>::edges_directed":["edges_directed","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoEdgesDirected"],"<&'a G as visit::IntoNeighbors>::neighbors":["neighbors","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNeighbors"],"<&'a G as visit::IntoNeighborsDirected>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNeighborsDirected"],"<&'a G as visit::IntoNodeIdentifiers>::node_identifiers":["node_identifiers","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNodeIdentifiers"],"<&'a G as visit::IntoNodeReferences>::node_references":["node_references","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNodeReferences"],"<&'a G as visit::NodeCount>::node_count":["node_count","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeCount"],"<&'a G as visit::NodeIndexable>::from_index":["from_index","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<&'a G as visit::NodeIndexable>::node_bound":["node_bound","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<&'a G as visit::NodeIndexable>::to_index":["to_index","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<&'a G as visit::Visitable>::reset_map":["reset_map","Real(LocalPath(\"src/visit/macros.rs\"))","visit::Visitable"],"<&'a G as visit::Visitable>::visit_map":["visit_map","Real(LocalPath(\"src/visit/macros.rs\"))","visit::Visitable"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoEdgeReferences>::edge_references":["edge_references","Real(LocalPath(\"src/csr.rs\"))","visit::IntoEdgeReferences"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoEdges>::edges":["edges","Real(LocalPath(\"src/csr.rs\"))","visit::IntoEdges"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoNeighbors>::neighbors":["neighbors","Real(LocalPath(\"src/csr.rs\"))","visit::IntoNeighbors"],"<&'a csr::Csr<N, E, Ty, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["node_identifiers","Real(LocalPath(\"src/csr.rs\"))","visit::IntoNodeIdentifiers"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdgeReferences>::edge_references":["edge_references","Real(LocalPath(\"src/visit/mod.rs\"))","visit::IntoEdgeReferences"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdges>::edges":["edges","Real(LocalPath(\"src/graph_impl/mod.rs\"))","visit::IntoEdges"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoEdgesDirected>::edges_directed":["edges_directed","Real(LocalPath(\"src/graph_impl/mod.rs\"))","visit::IntoEdgesDirected"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNeighbors>::neighbors":["neighbors","Real(LocalPath(\"src/visit/mod.rs\"))","visit::IntoNeighbors"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNeighborsDirected>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/visit/mod.rs\"))","visit::IntoNeighborsDirected"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["node_identifiers","Real(LocalPath(\"src/visit/mod.rs\"))","visit::IntoNodeIdentifiers"],"<&'a graph_impl::Graph<N, E, Ty, Ix> as visit::IntoNodeReferences>::node_references":["node_references","Real(LocalPath(\"src/graph_impl/mod.rs\"))","visit::IntoNodeReferences"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdgeReferences>::edge_references":["edge_references","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","visit::IntoEdgeReferences"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdges>::edges":["edges","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","visit::IntoEdges"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoEdgesDirected>::edges_directed":["edges_directed","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","visit::IntoEdgesDirected"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNeighbors>::neighbors":["neighbors","Real(LocalPath(\"src/visit/mod.rs\"))","visit::IntoNeighbors"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNeighborsDirected>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/visit/mod.rs\"))","visit::IntoNeighborsDirected"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["node_identifiers","Real(LocalPath(\"src/visit/mod.rs\"))","visit::IntoNodeIdentifiers"],"<&'a graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::IntoNodeReferences>::node_references":["node_references","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","visit::IntoNodeReferences"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoEdgeReferences>::edge_references":["edge_references","Real(LocalPath(\"src/graphmap.rs\"))","visit::IntoEdgeReferences"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoEdges>::edges":["edges","Real(LocalPath(\"src/graphmap.rs\"))","visit::IntoEdges"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNeighbors>::neighbors":["neighbors","Real(LocalPath(\"src/visit/mod.rs\"))","visit::IntoNeighbors"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNeighborsDirected>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/visit/mod.rs\"))","visit::IntoNeighborsDirected"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNodeIdentifiers>::node_identifiers":["node_identifiers","Real(LocalPath(\"src/graphmap.rs\"))","visit::IntoNodeIdentifiers"],"<&'a graphmap::GraphMap<N, E, Ty> as visit::IntoNodeReferences>::node_references":["node_references","Real(LocalPath(\"src/graphmap.rs\"))","visit::IntoNodeReferences"],"<&'a matrix_graph::MatrixGraph<N, E, Directed, Null, Ix> as visit::IntoNeighborsDirected>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::IntoNeighborsDirected"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoEdgeReferences>::edge_references":["edge_references","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::IntoEdgeReferences"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoEdges>::edges":["edges","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::IntoEdges"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNeighbors>::neighbors":["neighbors","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::IntoNeighbors"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNodeIdentifiers>::node_identifiers":["node_identifiers","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::IntoNodeIdentifiers"],"<&'a matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::IntoNodeReferences>::node_references":["node_references","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::IntoNodeReferences"],"<&'a mut G as data::DataMap>::edge_weight":["edge_weight","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMap"],"<&'a mut G as data::DataMap>::node_weight":["node_weight","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMap"],"<&'a mut G as data::DataMapMut>::edge_weight_mut":["edge_weight_mut","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMapMut"],"<&'a mut G as data::DataMapMut>::node_weight_mut":["node_weight_mut","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMapMut"],"<&'a mut W as visit::traversal::Walker<C>>::walk_next":["walk_next","Real(LocalPath(\"src/visit/traversal.rs\"))","visit::traversal::Walker"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoEdgeReferences>::edge_references":["edge_references","Real(LocalPath(\"src/visit/filter.rs\"))","visit::IntoEdgeReferences"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoEdges>::edges":["edges","Real(LocalPath(\"src/visit/filter.rs\"))","visit::IntoEdges"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNeighbors>::neighbors":["neighbors","Real(LocalPath(\"src/visit/filter.rs\"))","visit::IntoNeighbors"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNeighborsDirected>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/visit/filter.rs\"))","visit::IntoNeighborsDirected"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNodeIdentifiers>::node_identifiers":["node_identifiers","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNodeIdentifiers"],"<&'a visit::filter::EdgeFiltered<G, F> as visit::IntoNodeReferences>::node_references":["node_references","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNodeReferences"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoEdgeReferences>::edge_references":["edge_references","Real(LocalPath(\"src/visit/filter.rs\"))","visit::IntoEdgeReferences"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoEdges>::edges":["edges","Real(LocalPath(\"src/visit/filter.rs\"))","visit::IntoEdges"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNeighbors>::neighbors":["neighbors","Real(LocalPath(\"src/visit/filter.rs\"))","visit::IntoNeighbors"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNeighborsDirected>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/visit/filter.rs\"))","visit::IntoNeighborsDirected"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNodeIdentifiers>::node_identifiers":["node_identifiers","Real(LocalPath(\"src/visit/filter.rs\"))","visit::IntoNodeIdentifiers"],"<&'a visit::filter::NodeFiltered<G, F> as visit::IntoNodeReferences>::node_references":["node_references","Real(LocalPath(\"src/visit/filter.rs\"))","visit::IntoNodeReferences"],"<&fixedbitset::FixedBitSet as visit::filter::FilterNode<N>>::include_node":["include_node","Real(LocalPath(\"src/visit/filter.rs\"))","visit::filter::FilterNode"],"<&std::collections::HashSet<N, S> as visit::filter::FilterNode<N>>::include_node":["include_node","Real(LocalPath(\"src/visit/filter.rs\"))","visit::filter::FilterNode"],"<() as visit::dfsvisit::ControlFlow>::continuing":["continuing","Real(LocalPath(\"src/visit/dfsvisit.rs\"))","visit::dfsvisit::ControlFlow"],"<() as visit::dfsvisit::ControlFlow>::should_break":["should_break","Real(LocalPath(\"src/visit/dfsvisit.rs\"))","visit::dfsvisit::ControlFlow"],"<() as visit::dfsvisit::ControlFlow>::should_prune":["should_prune","Real(LocalPath(\"src/visit/dfsvisit.rs\"))","visit::dfsvisit::ControlFlow"],"<(Id, &'a W) as visit::NodeRef>::id":["id","Real(LocalPath(\"src/visit/mod.rs\"))","visit::NodeRef"],"<(Id, &'a W) as visit::NodeRef>::weight":["weight","Real(LocalPath(\"src/visit/mod.rs\"))","visit::NodeRef"],"<(Id, ()) as visit::NodeRef>::id":["id","Real(LocalPath(\"src/visit/mod.rs\"))","visit::NodeRef"],"<(Id, ()) as visit::NodeRef>::weight":["weight","Real(LocalPath(\"src/visit/mod.rs\"))","visit::NodeRef"],"<(Ix, Ix) as IntoWeightedEdge<E>>::into_weighted_edge":["into_weighted_edge","Real(LocalPath(\"src/lib.rs\"))","IntoWeightedEdge"],"<(Ix, Ix, &'a E) as IntoWeightedEdge<E>>::into_weighted_edge":["into_weighted_edge","Real(LocalPath(\"src/lib.rs\"))","IntoWeightedEdge"],"<(Ix, Ix, E) as IntoWeightedEdge<E>>::into_weighted_edge":["into_weighted_edge","Real(LocalPath(\"src/lib.rs\"))","IntoWeightedEdge"],"<(N, N, &'a E) as visit::EdgeRef>::id":["id","Real(LocalPath(\"src/visit/mod.rs\"))","visit::EdgeRef"],"<(N, N, &'a E) as visit::EdgeRef>::source":["source","Real(LocalPath(\"src/visit/mod.rs\"))","visit::EdgeRef"],"<(N, N, &'a E) as visit::EdgeRef>::target":["target","Real(LocalPath(\"src/visit/mod.rs\"))","visit::EdgeRef"],"<(N, N, &'a E) as visit::EdgeRef>::weight":["weight","Real(LocalPath(\"src/visit/mod.rs\"))","visit::EdgeRef"],"<Directed as EdgeType>::is_directed":["is_directed","Real(LocalPath(\"src/lib.rs\"))","EdgeType"],"<Directed as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","std::clone::Clone"],"<Direction as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","std::clone::Clone"],"<F as isomorphism::SemanticMatcher<T>>::enabled":["enabled","Real(LocalPath(\"src/isomorphism.rs\"))","isomorphism::SemanticMatcher"],"<F as isomorphism::SemanticMatcher<T>>::eq":["eq","Real(LocalPath(\"src/isomorphism.rs\"))","isomorphism::SemanticMatcher"],"<F as visit::filter::FilterEdge<N>>::include_edge":["include_edge","Real(LocalPath(\"src/visit/filter.rs\"))","visit::filter::FilterEdge"],"<F as visit::filter::FilterNode<N>>::include_node":["include_node","Real(LocalPath(\"src/visit/filter.rs\"))","visit::filter::FilterNode"],"<Undirected as EdgeType>::is_directed":["is_directed","Real(LocalPath(\"src/lib.rs\"))","EdgeType"],"<Undirected as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","std::clone::Clone"],"<algo::DfsSpace<N, VM> as std::default::Default>::default":["default","Real(LocalPath(\"src/algo/mod.rs\"))","std::default::Default"],"<algo::MinSpanningTree<G> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/algo/mod.rs\"))","std::iter::Iterator"],"<algo::dominators::DominatorsIter<'a, N> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/algo/dominators.rs\"))","std::iter::Iterator"],"<csr::Csr<N, E, Ty, Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/csr.rs\"))","std::clone::Clone"],"<csr::Csr<N, E, Ty, Ix> as std::default::Default>::default":["default","Real(LocalPath(\"src/csr.rs\"))","std::default::Default"],"<csr::Csr<N, E, Ty, Ix> as std::ops::Index<Ix>>::index":["index","Real(LocalPath(\"src/csr.rs\"))","std::ops::Index"],"<csr::Csr<N, E, Ty, Ix> as std::ops::IndexMut<Ix>>::index_mut":["index_mut","Real(LocalPath(\"src/csr.rs\"))","std::ops::IndexMut"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeCount>::node_count":["node_count","Real(LocalPath(\"src/csr.rs\"))","visit::NodeCount"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeIndexable>::from_index":["from_index","Real(LocalPath(\"src/csr.rs\"))","visit::NodeIndexable"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeIndexable>::node_bound":["node_bound","Real(LocalPath(\"src/csr.rs\"))","visit::NodeIndexable"],"<csr::Csr<N, E, Ty, Ix> as visit::NodeIndexable>::to_index":["to_index","Real(LocalPath(\"src/csr.rs\"))","visit::NodeIndexable"],"<csr::Csr<N, E, Ty, Ix> as visit::Visitable>::reset_map":["reset_map","Real(LocalPath(\"src/csr.rs\"))","visit::Visitable"],"<csr::Csr<N, E, Ty, Ix> as visit::Visitable>::visit_map":["visit_map","Real(LocalPath(\"src/csr.rs\"))","visit::Visitable"],"<csr::EdgeReference<'a, E, Ty, Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/csr.rs\"))","std::clone::Clone"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::id":["id","Real(LocalPath(\"src/csr.rs\"))","visit::EdgeRef"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::source":["source","Real(LocalPath(\"src/csr.rs\"))","visit::EdgeRef"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::target":["target","Real(LocalPath(\"src/csr.rs\"))","visit::EdgeRef"],"<csr::EdgeReference<'a, E, Ty, Ix> as visit::EdgeRef>::weight":["weight","Real(LocalPath(\"src/csr.rs\"))","visit::EdgeRef"],"<csr::EdgeReferences<'a, E, Ty, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/csr.rs\"))","std::iter::Iterator"],"<csr::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/csr.rs\"))","std::iter::Iterator"],"<csr::Neighbors<'a, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/csr.rs\"))","std::iter::Iterator"],"<csr::Neighbors<'a, Ix> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/csr.rs\"))","std::iter::Iterator"],"<csr::NodeIdentifiers<Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/csr.rs\"))","std::iter::Iterator"],"<csr::NodeIdentifiers<Ix> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/csr.rs\"))","std::iter::Iterator"],"<data::FilterElements<I, F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/data.rs\"))","std::iter::Iterator"],"<dot::DebugFmt<T> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/dot.rs\"))","std::fmt::Display"],"<dot::Dot<'a, G> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/dot.rs\"))","std::fmt::Debug"],"<dot::Dot<'a, G> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/dot.rs\"))","std::fmt::Display"],"<dot::Escaped<T> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/dot.rs\"))","std::fmt::Display"],"<dot::Escaper<W> as std::fmt::Write>::write_char":["write_char","Real(LocalPath(\"src/dot.rs\"))","std::fmt::Write"],"<dot::Escaper<W> as std::fmt::Write>::write_str":["write_str","Real(LocalPath(\"src/dot.rs\"))","std::fmt::Write"],"<f32 as algo::FloatMeasure>::infinite":["infinite","Real(LocalPath(\"src/algo/mod.rs\"))","algo::FloatMeasure"],"<f32 as algo::FloatMeasure>::zero":["zero","Real(LocalPath(\"src/algo/mod.rs\"))","algo::FloatMeasure"],"<f32 as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<f32 as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<f64 as algo::FloatMeasure>::infinite":["infinite","Real(LocalPath(\"src/algo/mod.rs\"))","algo::FloatMeasure"],"<f64 as algo::FloatMeasure>::zero":["zero","Real(LocalPath(\"src/algo/mod.rs\"))","algo::FloatMeasure"],"<f64 as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<f64 as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<fixedbitset::FixedBitSet as visit::VisitMap<Ix>>::is_visited":["is_visited","Real(LocalPath(\"src/visit/mod.rs\"))","visit::VisitMap"],"<fixedbitset::FixedBitSet as visit::VisitMap<Ix>>::visit":["visit","Real(LocalPath(\"src/visit/mod.rs\"))","visit::VisitMap"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::EdgeIndex<Ix>>>::is_visited":["is_visited","Real(LocalPath(\"src/visit/mod.rs\"))","visit::VisitMap"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::EdgeIndex<Ix>>>::visit":["visit","Real(LocalPath(\"src/visit/mod.rs\"))","visit::VisitMap"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::NodeIndex<Ix>>>::is_visited":["is_visited","Real(LocalPath(\"src/visit/mod.rs\"))","visit::VisitMap"],"<fixedbitset::FixedBitSet as visit::VisitMap<graph_impl::NodeIndex<Ix>>>::visit":["visit","Real(LocalPath(\"src/visit/mod.rs\"))","visit::VisitMap"],"<fixedbitset::FixedBitSet as visit::filter::FilterNode<N>>::include_node":["include_node","Real(LocalPath(\"src/visit/filter.rs\"))","visit::filter::FilterNode"],"<graph_impl::Edge<E, Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macros.rs\"))","std::clone::Clone"],"<graph_impl::EdgeIndex<Ix> as graph_impl::GraphIndex>::index":["index","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::GraphIndex"],"<graph_impl::EdgeIndex<Ix> as graph_impl::GraphIndex>::is_node_index":["is_node_index","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::GraphIndex"],"<graph_impl::EdgeIndex<Ix> as std::convert::From<Ix>>::from":["from","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::convert::From"],"<graph_impl::EdgeIndex<Ix> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::fmt::Debug"],"<graph_impl::EdgeIndices<Ix> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::DoubleEndedIterator"],"<graph_impl::EdgeIndices<Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::EdgeIndices<Ix> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::EdgeReference<'a, E, Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::clone::Clone"],"<graph_impl::EdgeReference<'a, E, Ix> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::cmp::PartialEq"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::id":["id","Real(LocalPath(\"src/graph_impl/mod.rs\"))","visit::EdgeRef"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::source":["source","Real(LocalPath(\"src/graph_impl/mod.rs\"))","visit::EdgeRef"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::target":["target","Real(LocalPath(\"src/graph_impl/mod.rs\"))","visit::EdgeRef"],"<graph_impl::EdgeReference<'a, E, Ix> as visit::EdgeRef>::weight":["weight","Real(LocalPath(\"src/graph_impl/mod.rs\"))","visit::EdgeRef"],"<graph_impl::EdgeReferences<'a, E, Ix> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::DoubleEndedIterator"],"<graph_impl::EdgeReferences<'a, E, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::EdgeReferences<'a, E, Ix> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::EdgeWeightsMut<'a, E, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::EdgeWeightsMut<'a, E, Ix> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::Edges<'a, E, Ty, Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::clone::Clone"],"<graph_impl::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::EdgesConnecting<'a, E, Ty, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::Externals<'a, N, Ty, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Build>::add_edge":["add_edge","Real(LocalPath(\"src/data.rs\"))","data::Build"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Build>::add_node":["add_node","Real(LocalPath(\"src/data.rs\"))","data::Build"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Build>::update_edge":["update_edge","Real(LocalPath(\"src/data.rs\"))","data::Build"],"<graph_impl::Graph<N, E, Ty, Ix> as data::Create>::with_capacity":["with_capacity","Real(LocalPath(\"src/data.rs\"))","data::Create"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMap>::edge_weight":["edge_weight","Real(LocalPath(\"src/data.rs\"))","data::DataMap"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMap>::node_weight":["node_weight","Real(LocalPath(\"src/data.rs\"))","data::DataMap"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMapMut>::edge_weight_mut":["edge_weight_mut","Real(LocalPath(\"src/data.rs\"))","data::DataMapMut"],"<graph_impl::Graph<N, E, Ty, Ix> as data::DataMapMut>::node_weight_mut":["node_weight_mut","Real(LocalPath(\"src/data.rs\"))","data::DataMapMut"],"<graph_impl::Graph<N, E, Ty, Ix> as data::FromElements>::from_elements":["from_elements","Real(LocalPath(\"src/data.rs\"))","data::FromElements"],"<graph_impl::Graph<N, E, Ty, Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::clone::Clone"],"<graph_impl::Graph<N, E, Ty, Ix> as std::clone::Clone>::clone_from":["clone_from","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::clone::Clone"],"<graph_impl::Graph<N, E, Ty, Ix> as std::default::Default>::default":["default","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::default::Default"],"<graph_impl::Graph<N, E, Ty, Ix> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::fmt::Debug"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::Index<graph_impl::EdgeIndex<Ix>>>::index":["index","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::ops::Index"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::Index<graph_impl::NodeIndex<Ix>>>::index":["index","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::ops::Index"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::EdgeIndex<Ix>>>::index_mut":["index_mut","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::ops::IndexMut"],"<graph_impl::Graph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::NodeIndex<Ix>>>::index_mut":["index_mut","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::ops::IndexMut"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeCount>::node_count":["node_count","Real(LocalPath(\"src/visit/mod.rs\"))","visit::NodeCount"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeIndexable>::from_index":["from_index","Real(LocalPath(\"src/visit/mod.rs\"))","visit::NodeIndexable"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeIndexable>::node_bound":["node_bound","Real(LocalPath(\"src/visit/mod.rs\"))","visit::NodeIndexable"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::NodeIndexable>::to_index":["to_index","Real(LocalPath(\"src/visit/mod.rs\"))","visit::NodeIndexable"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::Visitable>::reset_map":["reset_map","Real(LocalPath(\"src/visit/mod.rs\"))","visit::Visitable"],"<graph_impl::Graph<N, E, Ty, Ix> as visit::Visitable>::visit_map":["visit_map","Real(LocalPath(\"src/visit/mod.rs\"))","visit::Visitable"],"<graph_impl::Neighbors<'a, E, Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macros.rs\"))","std::clone::Clone"],"<graph_impl::Neighbors<'a, E, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::Node<E, Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macros.rs\"))","std::clone::Clone"],"<graph_impl::NodeIndex<Ix> as graph_impl::GraphIndex>::index":["index","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::GraphIndex"],"<graph_impl::NodeIndex<Ix> as graph_impl::GraphIndex>::is_node_index":["is_node_index","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::GraphIndex"],"<graph_impl::NodeIndex<Ix> as std::convert::From<Ix>>::from":["from","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::convert::From"],"<graph_impl::NodeIndex<Ix> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::fmt::Debug"],"<graph_impl::NodeIndices<Ix> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::DoubleEndedIterator"],"<graph_impl::NodeIndices<Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::NodeIndices<Ix> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::NodeReferences<'a, N, Ix> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::DoubleEndedIterator"],"<graph_impl::NodeReferences<'a, N, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::NodeReferences<'a, N, Ix> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::NodeWeightsMut<'a, N, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::NodeWeightsMut<'a, N, Ix> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::iter::Iterator"],"<graph_impl::WalkNeighbors<Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/graph_impl/mod.rs\"))","std::clone::Clone"],"<graph_impl::stable_graph::EdgeIndices<'a, E, Ix> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::DoubleEndedIterator"],"<graph_impl::stable_graph::EdgeIndices<'a, E, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::Iterator"],"<graph_impl::stable_graph::EdgeIndices<'a, E, Ix> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::Iterator"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::clone::Clone"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::cmp::PartialEq"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::id":["id","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","visit::EdgeRef"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::source":["source","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","visit::EdgeRef"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::target":["target","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","visit::EdgeRef"],"<graph_impl::stable_graph::EdgeReference<'a, E, Ix> as visit::EdgeRef>::weight":["weight","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","visit::EdgeRef"],"<graph_impl::stable_graph::EdgeReferences<'a, E, Ix> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::DoubleEndedIterator"],"<graph_impl::stable_graph::EdgeReferences<'a, E, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::Iterator"],"<graph_impl::stable_graph::Edges<'a, E, Ty, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::Iterator"],"<graph_impl::stable_graph::Externals<'a, N, Ty, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::Iterator"],"<graph_impl::stable_graph::Neighbors<'a, E, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::Iterator"],"<graph_impl::stable_graph::NodeIndices<'a, N, Ix> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::DoubleEndedIterator"],"<graph_impl::stable_graph::NodeIndices<'a, N, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::Iterator"],"<graph_impl::stable_graph::NodeIndices<'a, N, Ix> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::Iterator"],"<graph_impl::stable_graph::NodeReferences<'a, N, Ix> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::DoubleEndedIterator"],"<graph_impl::stable_graph::NodeReferences<'a, N, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::Iterator"],"<graph_impl::stable_graph::NodeReferences<'a, N, Ix> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::iter::Iterator"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Build>::add_edge":["add_edge","Real(LocalPath(\"src/data.rs\"))","data::Build"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Build>::add_node":["add_node","Real(LocalPath(\"src/data.rs\"))","data::Build"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Build>::update_edge":["update_edge","Real(LocalPath(\"src/data.rs\"))","data::Build"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::Create>::with_capacity":["with_capacity","Real(LocalPath(\"src/data.rs\"))","data::Create"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMap>::edge_weight":["edge_weight","Real(LocalPath(\"src/data.rs\"))","data::DataMap"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMap>::node_weight":["node_weight","Real(LocalPath(\"src/data.rs\"))","data::DataMap"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMapMut>::edge_weight_mut":["edge_weight_mut","Real(LocalPath(\"src/data.rs\"))","data::DataMapMut"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::DataMapMut>::node_weight_mut":["node_weight_mut","Real(LocalPath(\"src/data.rs\"))","data::DataMapMut"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as data::FromElements>::from_elements":["from_elements","Real(LocalPath(\"src/data.rs\"))","data::FromElements"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::clone::Clone"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::clone::Clone>::clone_from":["clone_from","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::clone::Clone"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::convert::From<graph_impl::Graph<N, E, Ty, Ix>>>::from":["from","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::convert::From"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::default::Default>::default":["default","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::default::Default"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::fmt::Debug"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::Index<graph_impl::EdgeIndex<Ix>>>::index":["index","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::ops::Index"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::Index<graph_impl::NodeIndex<Ix>>>::index":["index","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::ops::Index"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::EdgeIndex<Ix>>>::index_mut":["index_mut","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::ops::IndexMut"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as std::ops::IndexMut<graph_impl::NodeIndex<Ix>>>::index_mut":["index_mut","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::ops::IndexMut"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeCount>::node_count":["node_count","Real(LocalPath(\"src/visit/mod.rs\"))","visit::NodeCount"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeIndexable>::from_index":["from_index","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","visit::NodeIndexable"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeIndexable>::node_bound":["node_bound","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","visit::NodeIndexable"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::NodeIndexable>::to_index":["to_index","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","visit::NodeIndexable"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::Visitable>::reset_map":["reset_map","Real(LocalPath(\"src/visit/mod.rs\"))","visit::Visitable"],"<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix> as visit::Visitable>::visit_map":["visit_map","Real(LocalPath(\"src/visit/mod.rs\"))","visit::Visitable"],"<graph_impl::stable_graph::WalkNeighbors<Ix> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/macros.rs\"))","std::clone::Clone"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::DoubleEndedIterator"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::last":["last","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::nth":["nth","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::AllEdges<'a, N, E, Ty> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::DoubleEndedIterator"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::last":["last","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::nth":["nth","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::AllEdgesMut<'a, N, E, Ty> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::CompactDirection as std::cmp::PartialEq<Direction>>::eq":["eq","Real(LocalPath(\"src/graphmap.rs\"))","std::cmp::PartialEq"],"<graphmap::CompactDirection as std::convert::From<Direction>>::from":["from","Real(LocalPath(\"src/graphmap.rs\"))","std::convert::From"],"<graphmap::Edges<'a, N, E, Ty> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::GraphMap<N, E, Ty> as data::Build>::add_edge":["add_edge","Real(LocalPath(\"src/data.rs\"))","data::Build"],"<graphmap::GraphMap<N, E, Ty> as data::Build>::add_node":["add_node","Real(LocalPath(\"src/data.rs\"))","data::Build"],"<graphmap::GraphMap<N, E, Ty> as data::Build>::update_edge":["update_edge","Real(LocalPath(\"src/data.rs\"))","data::Build"],"<graphmap::GraphMap<N, E, Ty> as data::Create>::with_capacity":["with_capacity","Real(LocalPath(\"src/data.rs\"))","data::Create"],"<graphmap::GraphMap<N, E, Ty> as data::FromElements>::from_elements":["from_elements","Real(LocalPath(\"src/data.rs\"))","data::FromElements"],"<graphmap::GraphMap<N, E, Ty> as std::default::Default>::default":["default","Real(LocalPath(\"src/graphmap.rs\"))","std::default::Default"],"<graphmap::GraphMap<N, E, Ty> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/graphmap.rs\"))","std::fmt::Debug"],"<graphmap::GraphMap<N, E, Ty> as std::iter::Extend<Item>>::extend":["extend","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Extend"],"<graphmap::GraphMap<N, E, Ty> as std::iter::FromIterator<Item>>::from_iter":["from_iter","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::FromIterator"],"<graphmap::GraphMap<N, E, Ty> as std::ops::Index<(N, N)>>::index":["index","Real(LocalPath(\"src/graphmap.rs\"))","std::ops::Index"],"<graphmap::GraphMap<N, E, Ty> as std::ops::IndexMut<(N, N)>>::index_mut":["index_mut","Real(LocalPath(\"src/graphmap.rs\"))","std::ops::IndexMut"],"<graphmap::GraphMap<N, E, Ty> as visit::GetAdjacencyMatrix>::adjacency_matrix":["adjacency_matrix","Real(LocalPath(\"src/visit/mod.rs\"))","visit::GetAdjacencyMatrix"],"<graphmap::GraphMap<N, E, Ty> as visit::GetAdjacencyMatrix>::is_adjacent":["is_adjacent","Real(LocalPath(\"src/visit/mod.rs\"))","visit::GetAdjacencyMatrix"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeCount>::node_count":["node_count","Real(LocalPath(\"src/graphmap.rs\"))","visit::NodeCount"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeIndexable>::from_index":["from_index","Real(LocalPath(\"src/graphmap.rs\"))","visit::NodeIndexable"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeIndexable>::node_bound":["node_bound","Real(LocalPath(\"src/graphmap.rs\"))","visit::NodeIndexable"],"<graphmap::GraphMap<N, E, Ty> as visit::NodeIndexable>::to_index":["to_index","Real(LocalPath(\"src/graphmap.rs\"))","visit::NodeIndexable"],"<graphmap::GraphMap<N, E, Ty> as visit::Visitable>::reset_map":["reset_map","Real(LocalPath(\"src/visit/mod.rs\"))","visit::Visitable"],"<graphmap::GraphMap<N, E, Ty> as visit::Visitable>::visit_map":["visit_map","Real(LocalPath(\"src/visit/mod.rs\"))","visit::Visitable"],"<graphmap::Neighbors<'a, N, Ty> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::NeighborsDirected<'a, N, Ty> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::NodeIdentifiers<'a, N, E, Ty> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::NodeReferences<'a, N, E, Ty> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::Nodes<'a, N> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::Nodes<'a, N> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/graphmap.rs\"))","std::iter::Iterator"],"<graphmap::Ptr<'b, T> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/graphmap.rs\"))","std::clone::Clone"],"<graphmap::Ptr<'b, T> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/graphmap.rs\"))","std::cmp::Ord"],"<graphmap::Ptr<'b, T> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/graphmap.rs\"))","std::cmp::PartialEq"],"<graphmap::Ptr<'b, T> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/graphmap.rs\"))","std::cmp::PartialOrd"],"<graphmap::Ptr<'b, T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/graphmap.rs\"))","std::fmt::Debug"],"<graphmap::Ptr<'b, T> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/graphmap.rs\"))","std::hash::Hash"],"<graphmap::Ptr<'b, T> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/graphmap.rs\"))","std::ops::Deref"],"<i16 as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<i16 as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<i32 as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<i32 as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<i64 as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<i64 as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<i8 as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<i8 as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<isize as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<isize as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<isomorphism::NoSemanticMatch as isomorphism::SemanticMatcher<T>>::enabled":["enabled","Real(LocalPath(\"src/isomorphism.rs\"))","isomorphism::SemanticMatcher"],"<isomorphism::NoSemanticMatch as isomorphism::SemanticMatcher<T>>::eq":["eq","Real(LocalPath(\"src/isomorphism.rs\"))","isomorphism::SemanticMatcher"],"<iter_format::DebugMap<F> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/iter_format.rs\"))","std::fmt::Debug"],"<iter_format::Format<'a, I> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/iter_format.rs\"))","std::fmt::Debug"],"<iter_format::NoPretty<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/iter_format.rs\"))","std::fmt::Debug"],"<matrix_graph::EdgeReferences<'a, Ty, Null, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/matrix_graph.rs\"))","std::iter::Iterator"],"<matrix_graph::Edges<'a, Ty, Null, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/matrix_graph.rs\"))","std::iter::Iterator"],"<matrix_graph::IdIterator<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/matrix_graph.rs\"))","std::iter::Iterator"],"<matrix_graph::IdStorage<T> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/matrix_graph.rs\"))","std::ops::Index"],"<matrix_graph::IdStorage<T> as std::ops::IndexMut<usize>>::index_mut":["index_mut","Real(LocalPath(\"src/matrix_graph.rs\"))","std::ops::IndexMut"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as data::Build>::add_edge":["add_edge","Real(LocalPath(\"src/matrix_graph.rs\"))","data::Build"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as data::Build>::add_node":["add_node","Real(LocalPath(\"src/matrix_graph.rs\"))","data::Build"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as data::Build>::update_edge":["update_edge","Real(LocalPath(\"src/matrix_graph.rs\"))","data::Build"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::default::Default>::default":["default","Real(LocalPath(\"src/matrix_graph.rs\"))","std::default::Default"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::Index<(graph_impl::NodeIndex<Ix>, graph_impl::NodeIndex<Ix>)>>::index":["index","Real(LocalPath(\"src/matrix_graph.rs\"))","std::ops::Index"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::Index<graph_impl::NodeIndex<Ix>>>::index":["index","Real(LocalPath(\"src/matrix_graph.rs\"))","std::ops::Index"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::IndexMut<(graph_impl::NodeIndex<Ix>, graph_impl::NodeIndex<Ix>)>>::index_mut":["index_mut","Real(LocalPath(\"src/matrix_graph.rs\"))","std::ops::IndexMut"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as std::ops::IndexMut<graph_impl::NodeIndex<Ix>>>::index_mut":["index_mut","Real(LocalPath(\"src/matrix_graph.rs\"))","std::ops::IndexMut"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::GetAdjacencyMatrix>::adjacency_matrix":["adjacency_matrix","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::GetAdjacencyMatrix"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::GetAdjacencyMatrix>::is_adjacent":["is_adjacent","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::GetAdjacencyMatrix"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeCount>::node_count":["node_count","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::NodeCount"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeIndexable>::from_index":["from_index","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::NodeIndexable"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeIndexable>::node_bound":["node_bound","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::NodeIndexable"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::NodeIndexable>::to_index":["to_index","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::NodeIndexable"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::Visitable>::reset_map":["reset_map","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::Visitable"],"<matrix_graph::MatrixGraph<N, E, Ty, Null, Ix> as visit::Visitable>::visit_map":["visit_map","Real(LocalPath(\"src/matrix_graph.rs\"))","visit::Visitable"],"<matrix_graph::Neighbors<'a, Ty, Null, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/matrix_graph.rs\"))","std::iter::Iterator"],"<matrix_graph::NodeIdentifiers<'a, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/matrix_graph.rs\"))","std::iter::Iterator"],"<matrix_graph::NodeReferences<'a, N, Ix> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/matrix_graph.rs\"))","std::iter::Iterator"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::as_mut":["as_mut","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Nullable"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::as_ref":["as_ref","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Nullable"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::is_null":["is_null","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Nullable"],"<matrix_graph::NotZero<T> as matrix_graph::Nullable>::new":["new","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Nullable"],"<matrix_graph::NotZero<T> as std::convert::Into<std::option::Option<T>>>::into":["into","Real(LocalPath(\"src/matrix_graph.rs\"))","std::convert::Into"],"<matrix_graph::NotZero<T> as std::default::Default>::default":["default","Real(LocalPath(\"src/matrix_graph.rs\"))","std::default::Default"],"<scored::MinScored<K, T> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/scored.rs\"))","std::cmp::Ord"],"<scored::MinScored<K, T> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/scored.rs\"))","std::cmp::PartialEq"],"<scored::MinScored<K, T> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/scored.rs\"))","std::cmp::PartialOrd"],"<std::collections::HashSet<N, S> as visit::VisitMap<N>>::is_visited":["is_visited","Real(LocalPath(\"src/visit/mod.rs\"))","visit::VisitMap"],"<std::collections::HashSet<N, S> as visit::VisitMap<N>>::visit":["visit","Real(LocalPath(\"src/visit/mod.rs\"))","visit::VisitMap"],"<std::collections::HashSet<N, S> as visit::filter::FilterNode<N>>::include_node":["include_node","Real(LocalPath(\"src/visit/filter.rs\"))","visit::filter::FilterNode"],"<std::option::Option<T> as matrix_graph::Nullable>::as_mut":["as_mut","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Nullable"],"<std::option::Option<T> as matrix_graph::Nullable>::as_ref":["as_ref","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Nullable"],"<std::option::Option<T> as matrix_graph::Nullable>::new":["new","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Nullable"],"<std::result::Result<C, E> as visit::dfsvisit::ControlFlow>::continuing":["continuing","Real(LocalPath(\"src/visit/dfsvisit.rs\"))","visit::dfsvisit::ControlFlow"],"<std::result::Result<C, E> as visit::dfsvisit::ControlFlow>::should_break":["should_break","Real(LocalPath(\"src/visit/dfsvisit.rs\"))","visit::dfsvisit::ControlFlow"],"<std::result::Result<C, E> as visit::dfsvisit::ControlFlow>::should_prune":["should_prune","Real(LocalPath(\"src/visit/dfsvisit.rs\"))","visit::dfsvisit::ControlFlow"],"<u16 as graph_impl::IndexType>::index":["index","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<u16 as graph_impl::IndexType>::max":["max","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<u16 as graph_impl::IndexType>::new":["new","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<u16 as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<u16 as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<u32 as graph_impl::IndexType>::index":["index","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<u32 as graph_impl::IndexType>::max":["max","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<u32 as graph_impl::IndexType>::new":["new","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<u32 as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<u32 as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<u64 as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<u64 as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<u8 as graph_impl::IndexType>::index":["index","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<u8 as graph_impl::IndexType>::max":["max","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<u8 as graph_impl::IndexType>::new":["new","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<u8 as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<u8 as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<usize as graph_impl::IndexType>::index":["index","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<usize as graph_impl::IndexType>::max":["max","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<usize as graph_impl::IndexType>::new":["new","Real(LocalPath(\"src/graph_impl/mod.rs\"))","graph_impl::IndexType"],"<usize as matrix_graph::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<usize as matrix_graph::Zero>::zero":["zero","Real(LocalPath(\"src/matrix_graph.rs\"))","matrix_graph::Zero"],"<visit::dfsvisit::Control<B> as std::default::Default>::default":["default","Real(LocalPath(\"src/visit/dfsvisit.rs\"))","std::default::Default"],"<visit::dfsvisit::Control<B> as visit::dfsvisit::ControlFlow>::continuing":["continuing","Real(LocalPath(\"src/visit/dfsvisit.rs\"))","visit::dfsvisit::ControlFlow"],"<visit::dfsvisit::Control<B> as visit::dfsvisit::ControlFlow>::should_break":["should_break","Real(LocalPath(\"src/visit/dfsvisit.rs\"))","visit::dfsvisit::ControlFlow"],"<visit::dfsvisit::Control<B> as visit::dfsvisit::ControlFlow>::should_prune":["should_prune","Real(LocalPath(\"src/visit/dfsvisit.rs\"))","visit::dfsvisit::ControlFlow"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeCount>::node_count":["node_count","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeCount"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeIndexable>::from_index":["from_index","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeIndexable>::node_bound":["node_bound","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<visit::filter::EdgeFiltered<G, F> as visit::NodeIndexable>::to_index":["to_index","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<visit::filter::EdgeFiltered<G, F> as visit::Visitable>::reset_map":["reset_map","Real(LocalPath(\"src/visit/macros.rs\"))","visit::Visitable"],"<visit::filter::EdgeFiltered<G, F> as visit::Visitable>::visit_map":["visit_map","Real(LocalPath(\"src/visit/macros.rs\"))","visit::Visitable"],"<visit::filter::EdgeFilteredEdges<'a, G, I, F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/visit/filter.rs\"))","std::iter::Iterator"],"<visit::filter::EdgeFilteredNeighbors<'a, G, F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/visit/filter.rs\"))","std::iter::Iterator"],"<visit::filter::EdgeFilteredNeighborsDirected<'a, G, F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/visit/filter.rs\"))","std::iter::Iterator"],"<visit::filter::NodeFiltered<G, F> as data::DataMap>::edge_weight":["edge_weight","Real(LocalPath(\"src/visit/filter.rs\"))","data::DataMap"],"<visit::filter::NodeFiltered<G, F> as data::DataMap>::node_weight":["node_weight","Real(LocalPath(\"src/visit/filter.rs\"))","data::DataMap"],"<visit::filter::NodeFiltered<G, F> as visit::NodeIndexable>::from_index":["from_index","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<visit::filter::NodeFiltered<G, F> as visit::NodeIndexable>::node_bound":["node_bound","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<visit::filter::NodeFiltered<G, F> as visit::NodeIndexable>::to_index":["to_index","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<visit::filter::NodeFiltered<G, F> as visit::Visitable>::reset_map":["reset_map","Real(LocalPath(\"src/visit/macros.rs\"))","visit::Visitable"],"<visit::filter::NodeFiltered<G, F> as visit::Visitable>::visit_map":["visit_map","Real(LocalPath(\"src/visit/macros.rs\"))","visit::Visitable"],"<visit::filter::NodeFilteredEdgeReferences<'a, G, I, F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/visit/filter.rs\"))","std::iter::Iterator"],"<visit::filter::NodeFilteredEdges<'a, G, I, F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/visit/filter.rs\"))","std::iter::Iterator"],"<visit::filter::NodeFilteredNeighbors<'a, I, F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/visit/filter.rs\"))","std::iter::Iterator"],"<visit::filter::NodeFilteredNodes<'a, I, F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/visit/filter.rs\"))","std::iter::Iterator"],"<visit::reversed::Reversed<G> as data::DataMap>::edge_weight":["edge_weight","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMap"],"<visit::reversed::Reversed<G> as data::DataMap>::node_weight":["node_weight","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMap"],"<visit::reversed::Reversed<G> as data::DataMapMut>::edge_weight_mut":["edge_weight_mut","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMapMut"],"<visit::reversed::Reversed<G> as data::DataMapMut>::node_weight_mut":["node_weight_mut","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMapMut"],"<visit::reversed::Reversed<G> as visit::IntoEdgeReferences>::edge_references":["edge_references","Real(LocalPath(\"src/visit/reversed.rs\"))","visit::IntoEdgeReferences"],"<visit::reversed::Reversed<G> as visit::IntoEdges>::edges":["edges","Real(LocalPath(\"src/visit/reversed.rs\"))","visit::IntoEdges"],"<visit::reversed::Reversed<G> as visit::IntoEdgesDirected>::edges_directed":["edges_directed","Real(LocalPath(\"src/visit/reversed.rs\"))","visit::IntoEdgesDirected"],"<visit::reversed::Reversed<G> as visit::IntoNeighbors>::neighbors":["neighbors","Real(LocalPath(\"src/visit/reversed.rs\"))","visit::IntoNeighbors"],"<visit::reversed::Reversed<G> as visit::IntoNeighborsDirected>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/visit/reversed.rs\"))","visit::IntoNeighborsDirected"],"<visit::reversed::Reversed<G> as visit::IntoNodeIdentifiers>::node_identifiers":["node_identifiers","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNodeIdentifiers"],"<visit::reversed::Reversed<G> as visit::IntoNodeReferences>::node_references":["node_references","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNodeReferences"],"<visit::reversed::Reversed<G> as visit::NodeCount>::node_count":["node_count","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeCount"],"<visit::reversed::Reversed<G> as visit::NodeIndexable>::from_index":["from_index","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<visit::reversed::Reversed<G> as visit::NodeIndexable>::node_bound":["node_bound","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<visit::reversed::Reversed<G> as visit::NodeIndexable>::to_index":["to_index","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"<visit::reversed::Reversed<G> as visit::Visitable>::reset_map":["reset_map","Real(LocalPath(\"src/visit/reversed.rs\"))","visit::Visitable"],"<visit::reversed::Reversed<G> as visit::Visitable>::visit_map":["visit_map","Real(LocalPath(\"src/visit/reversed.rs\"))","visit::Visitable"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::id":["id","Real(LocalPath(\"src/visit/reversed.rs\"))","visit::EdgeRef"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::source":["source","Real(LocalPath(\"src/visit/reversed.rs\"))","visit::EdgeRef"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::target":["target","Real(LocalPath(\"src/visit/reversed.rs\"))","visit::EdgeRef"],"<visit::reversed::ReversedEdgeReference<R> as visit::EdgeRef>::weight":["weight","Real(LocalPath(\"src/visit/reversed.rs\"))","visit::EdgeRef"],"<visit::reversed::ReversedEdgeReferences<I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/visit/reversed.rs\"))","std::iter::Iterator"],"<visit::reversed::ReversedEdges<I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/visit/reversed.rs\"))","std::iter::Iterator"],"<visit::traversal::Bfs<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["walk_next","Real(LocalPath(\"src/visit/traversal.rs\"))","visit::traversal::Walker"],"<visit::traversal::Bfs<N, VM> as std::default::Default>::default":["default","Real(LocalPath(\"src/visit/traversal.rs\"))","std::default::Default"],"<visit::traversal::Dfs<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["walk_next","Real(LocalPath(\"src/visit/traversal.rs\"))","visit::traversal::Walker"],"<visit::traversal::Dfs<N, VM> as std::default::Default>::default":["default","Real(LocalPath(\"src/visit/traversal.rs\"))","std::default::Default"],"<visit::traversal::DfsPostOrder<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["walk_next","Real(LocalPath(\"src/visit/traversal.rs\"))","visit::traversal::Walker"],"<visit::traversal::DfsPostOrder<N, VM> as std::default::Default>::default":["default","Real(LocalPath(\"src/visit/traversal.rs\"))","std::default::Default"],"<visit::traversal::Topo<<G as visit::GraphBase>::NodeId, <G as visit::Visitable>::Map> as visit::traversal::Walker<G>>::walk_next":["walk_next","Real(LocalPath(\"src/visit/traversal.rs\"))","visit::traversal::Walker"],"<visit::traversal::Topo<N, VM> as std::default::Default>::default":["default","Real(LocalPath(\"src/visit/traversal.rs\"))","std::default::Default"],"<visit::traversal::WalkerIter<W, C> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/visit/traversal.rs\"))","std::iter::Iterator"],"Direction::index":["index","Real(LocalPath(\"src/lib.rs\"))",""],"Direction::opposite":["opposite","Real(LocalPath(\"src/lib.rs\"))",""],"algo::Cycle::<N>::node_id":["node_id","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::DfsSpace::<N, VM>::new":["new","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::bellman_ford":["bellman_ford","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::condensation":["condensation","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::connected_components":["connected_components","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::dominators::Dominators::<N>::dominators":["dominators","Real(LocalPath(\"src/algo/dominators.rs\"))",""],"algo::dominators::Dominators::<N>::immediate_dominator":["immediate_dominator","Real(LocalPath(\"src/algo/dominators.rs\"))",""],"algo::dominators::Dominators::<N>::root":["root","Real(LocalPath(\"src/algo/dominators.rs\"))",""],"algo::dominators::Dominators::<N>::strict_dominators":["strict_dominators","Real(LocalPath(\"src/algo/dominators.rs\"))",""],"algo::dominators::intersect":["intersect","Real(LocalPath(\"src/algo/dominators.rs\"))",""],"algo::dominators::predecessor_sets_to_idx_vecs":["predecessor_sets_to_idx_vecs","Real(LocalPath(\"src/algo/dominators.rs\"))",""],"algo::dominators::simple_fast":["simple_fast","Real(LocalPath(\"src/algo/dominators.rs\"))",""],"algo::dominators::simple_fast_post_order":["simple_fast_post_order","Real(LocalPath(\"src/algo/dominators.rs\"))",""],"algo::has_path_connecting":["has_path_connecting","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::is_bipartite_undirected":["is_bipartite_undirected","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::is_cyclic_directed":["is_cyclic_directed","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::is_cyclic_undirected":["is_cyclic_undirected","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::kosaraju_scc":["kosaraju_scc","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::min_spanning_tree":["min_spanning_tree","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::scc":["scc","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::tarjan_scc":["tarjan_scc","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::tarjan_scc::scc_visit":["scc_visit","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::toposort":["toposort","Real(LocalPath(\"src/algo/mod.rs\"))",""],"algo::with_dfs":["with_dfs","Real(LocalPath(\"src/algo/mod.rs\"))",""],"astar::PathTracker::<G>::new":["new","Real(LocalPath(\"src/astar.rs\"))",""],"astar::PathTracker::<G>::reconstruct_path_to":["reconstruct_path_to","Real(LocalPath(\"src/astar.rs\"))",""],"astar::PathTracker::<G>::set_predecessor":["set_predecessor","Real(LocalPath(\"src/astar.rs\"))",""],"astar::astar":["astar","Real(LocalPath(\"src/astar.rs\"))",""],"csr::Csr::<N, E, Directed, Ix>::from_sorted_edges":["from_sorted_edges","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::add_edge":["add_edge","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::add_edge_":["add_edge_","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::add_node":["add_node","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::clear_edges":["clear_edges","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::contains_edge":["contains_edge","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::edge_count":["edge_count","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::edges":["edges","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::edges_slice":["edges_slice","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::find_edge_pos":["find_edge_pos","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::is_directed":["is_directed","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::neighbors_of":["neighbors_of","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::neighbors_range":["neighbors_range","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::neighbors_slice":["neighbors_slice","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::new":["new","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::node_count":["node_count","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::out_degree":["out_degree","Real(LocalPath(\"src/csr.rs\"))",""],"csr::Csr::<N, E, Ty, Ix>::with_nodes":["with_nodes","Real(LocalPath(\"src/csr.rs\"))",""],"csr::EdgeReference::<'a, E, Ty, Ix>::weight":["weight","Real(LocalPath(\"src/csr.rs\"))",""],"data::Build::add_edge":["add_edge","Real(LocalPath(\"src/data.rs\"))",""],"data::ElementIterator::filter_elements":["filter_elements","Real(LocalPath(\"src/data.rs\"))",""],"data::FromElements::from_elements":["from_elements","Real(LocalPath(\"src/data.rs\"))",""],"data::from_elements_indexable":["from_elements_indexable","Real(LocalPath(\"src/data.rs\"))",""],"dijkstra::dijkstra":["dijkstra","Real(LocalPath(\"src/dijkstra.rs\"))",""],"dot::Dot::<'a, G>::graph_fmt":["graph_fmt","Real(LocalPath(\"src/dot.rs\"))",""],"dot::Dot::<'a, G>::new":["new","Real(LocalPath(\"src/dot.rs\"))",""],"dot::Dot::<'a, G>::with_attr_getters":["with_attr_getters","Real(LocalPath(\"src/dot.rs\"))",""],"dot::Dot::<'a, G>::with_config":["with_config","Real(LocalPath(\"src/dot.rs\"))",""],"graph_impl::Edge::<E, Ix>::next_edge":["next_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Edge::<E, Ix>::source":["source","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Edge::<E, Ix>::target":["target","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::EdgeIndex::<Ix>::_into_node":["_into_node","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::EdgeIndex::<Ix>::end":["end","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::EdgeIndex::<Ix>::index":["index","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::EdgeIndex::<Ix>::new":["new","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::EdgeReference::<'a, E, Ix>::weight":["weight","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::EdgesWalkerMut::<'a, E, Ix>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::EdgesWalkerMut::<'a, E, Ix>::next_edge":["next_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::add_edge":["add_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::add_node":["add_node","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::capacity":["capacity","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::change_edge_links":["change_edge_links","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::clear":["clear","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::clear_edges":["clear_edges","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::contains_edge":["contains_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::edge_count":["edge_count","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::edge_endpoints":["edge_endpoints","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::edge_indices":["edge_indices","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::edge_references":["edge_references","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::edge_weight":["edge_weight","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::edge_weight_mut":["edge_weight_mut","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::edge_weights_mut":["edge_weights_mut","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::edges":["edges","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::edges_connecting":["edges_connecting","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::edges_directed":["edges_directed","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::extend_with_edges":["extend_with_edges","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::externals":["externals","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::filter_map":["filter_map","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge":["find_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge_directed_from_node":["find_edge_directed_from_node","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge_undirected":["find_edge_undirected","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::find_edge_undirected_from_node":["find_edge_undirected_from_node","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::first_edge":["first_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::from_edges":["from_edges","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::index_twice_mut":["index_twice_mut","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::into_edge_type":["into_edge_type","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::into_nodes_edges":["into_nodes_edges","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::is_directed":["is_directed","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::map":["map","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::neighbors":["neighbors","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::neighbors_undirected":["neighbors_undirected","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::next_edge":["next_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::node_count":["node_count","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::node_indices":["node_indices","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::node_weight":["node_weight","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::node_weight_mut":["node_weight_mut","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::node_weights_mut":["node_weights_mut","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::raw_edges":["raw_edges","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::raw_nodes":["raw_nodes","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::remove_edge":["remove_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::remove_edge_adjust_indices":["remove_edge_adjust_indices","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::remove_node":["remove_node","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_edges":["reserve_edges","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_exact_edges":["reserve_exact_edges","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_exact_nodes":["reserve_exact_nodes","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::reserve_nodes":["reserve_nodes","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::retain_edges":["retain_edges","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::retain_nodes":["retain_nodes","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::reverse":["reverse","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::shrink_to_fit":["shrink_to_fit","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::shrink_to_fit_edges":["shrink_to_fit_edges","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::shrink_to_fit_nodes":["shrink_to_fit_nodes","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::update_edge":["update_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Ty, Ix>::with_capacity":["with_capacity","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E, Undirected>::new_undirected":["new_undirected","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Graph::<N, E>::new":["new","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Neighbors::<'a, E, Ix>::detach":["detach","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::Node::<N, Ix>::next_edge":["next_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::NodeIndex::<Ix>::_into_edge":["_into_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::NodeIndex::<Ix>::end":["end","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::NodeIndex::<Ix>::index":["index","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::NodeIndex::<Ix>::new":["new","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::WalkNeighbors::<Ix>::next":["next","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::WalkNeighbors::<Ix>::next_edge":["next_edge","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::WalkNeighbors::<Ix>::next_node":["next_node","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::edge_index":["edge_index","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::edges_walker_mut":["edges_walker_mut","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::frozen::<impl data::DataMap for graph_impl::Frozen<'a, G>>::edge_weight":["edge_weight","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMap"],"graph_impl::frozen::<impl data::DataMap for graph_impl::Frozen<'a, G>>::node_weight":["node_weight","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMap"],"graph_impl::frozen::<impl data::DataMapMut for graph_impl::Frozen<'a, G>>::edge_weight_mut":["edge_weight_mut","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMapMut"],"graph_impl::frozen::<impl data::DataMapMut for graph_impl::Frozen<'a, G>>::node_weight_mut":["node_weight_mut","Real(LocalPath(\"src/visit/macros.rs\"))","data::DataMapMut"],"graph_impl::frozen::<impl graph_impl::Frozen<'a, G>>::new":["new","Real(LocalPath(\"src/graph_impl/frozen.rs\"))",""],"graph_impl::frozen::<impl graph_impl::Frozen<'a, graph_impl::Graph<N, E, Ty, Ix>>>::index_twice_mut":["index_twice_mut","Real(LocalPath(\"src/graph_impl/frozen.rs\"))",""],"graph_impl::frozen::<impl std::ops::Deref for graph_impl::Frozen<'a, G>>::deref":["deref","Real(LocalPath(\"src/graph_impl/frozen.rs\"))","std::ops::Deref"],"graph_impl::frozen::<impl std::ops::Index<I> for graph_impl::Frozen<'a, G>>::index":["index","Real(LocalPath(\"src/graph_impl/frozen.rs\"))","std::ops::Index"],"graph_impl::frozen::<impl std::ops::IndexMut<I> for graph_impl::Frozen<'a, G>>::index_mut":["index_mut","Real(LocalPath(\"src/graph_impl/frozen.rs\"))","std::ops::IndexMut"],"graph_impl::frozen::<impl visit::GetAdjacencyMatrix for graph_impl::Frozen<'a, G>>::adjacency_matrix":["adjacency_matrix","Real(LocalPath(\"src/visit/macros.rs\"))","visit::GetAdjacencyMatrix"],"graph_impl::frozen::<impl visit::GetAdjacencyMatrix for graph_impl::Frozen<'a, G>>::is_adjacent":["is_adjacent","Real(LocalPath(\"src/visit/macros.rs\"))","visit::GetAdjacencyMatrix"],"graph_impl::frozen::<impl visit::IntoEdgeReferences for &'b graph_impl::Frozen<'a, G>>::edge_references":["edge_references","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoEdgeReferences"],"graph_impl::frozen::<impl visit::IntoEdges for &'b graph_impl::Frozen<'a, G>>::edges":["edges","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoEdges"],"graph_impl::frozen::<impl visit::IntoEdgesDirected for &'b graph_impl::Frozen<'a, G>>::edges_directed":["edges_directed","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoEdgesDirected"],"graph_impl::frozen::<impl visit::IntoNeighbors for &'b graph_impl::Frozen<'a, G>>::neighbors":["neighbors","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNeighbors"],"graph_impl::frozen::<impl visit::IntoNeighborsDirected for &'b graph_impl::Frozen<'a, G>>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNeighborsDirected"],"graph_impl::frozen::<impl visit::IntoNodeIdentifiers for &'b graph_impl::Frozen<'a, G>>::node_identifiers":["node_identifiers","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNodeIdentifiers"],"graph_impl::frozen::<impl visit::IntoNodeReferences for &'b graph_impl::Frozen<'a, G>>::node_references":["node_references","Real(LocalPath(\"src/visit/macros.rs\"))","visit::IntoNodeReferences"],"graph_impl::frozen::<impl visit::NodeCount for graph_impl::Frozen<'a, G>>::node_count":["node_count","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeCount"],"graph_impl::frozen::<impl visit::NodeIndexable for graph_impl::Frozen<'a, G>>::from_index":["from_index","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"graph_impl::frozen::<impl visit::NodeIndexable for graph_impl::Frozen<'a, G>>::node_bound":["node_bound","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"graph_impl::frozen::<impl visit::NodeIndexable for graph_impl::Frozen<'a, G>>::to_index":["to_index","Real(LocalPath(\"src/visit/macros.rs\"))","visit::NodeIndexable"],"graph_impl::frozen::<impl visit::Visitable for graph_impl::Frozen<'a, G>>::reset_map":["reset_map","Real(LocalPath(\"src/visit/macros.rs\"))","visit::Visitable"],"graph_impl::frozen::<impl visit::Visitable for graph_impl::Frozen<'a, G>>::visit_map":["visit_map","Real(LocalPath(\"src/visit/macros.rs\"))","visit::Visitable"],"graph_impl::index_twice":["index_twice","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::node_index":["node_index","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graph_impl::stable_graph::<impl std::convert::From<graph_impl::stable_graph::StableGraph<N, E, Ty, Ix>> for graph_impl::Graph<N, E, Ty, Ix>>::from":["from","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))","std::convert::From"],"graph_impl::stable_graph::EdgeReference::<'a, E, Ix>::weight":["weight","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::Neighbors::<'a, E, Ix>::detach":["detach","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_edge":["add_edge","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_node":["add_node","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_vacant_edge":["add_vacant_edge","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::add_vacant_node":["add_vacant_node","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::capacity":["capacity","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::check_free_lists":["check_free_lists","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::clear":["clear","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::clear_edges":["clear_edges","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::contains_edge":["contains_edge","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::contains_node":["contains_node","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_bound":["edge_bound","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_count":["edge_count","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_endpoints":["edge_endpoints","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_indices":["edge_indices","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_weight":["edge_weight","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_weight_mut":["edge_weight_mut","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edge_weights_mut":["edge_weights_mut","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edges":["edges","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::edges_directed":["edges_directed","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::extend_with_edges":["extend_with_edges","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::externals":["externals","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::filter_map":["filter_map","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::find_edge":["find_edge","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::find_edge_undirected":["find_edge_undirected","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::from_edges":["from_edges","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::get_node":["get_node","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::index_twice_mut":["index_twice_mut","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::is_directed":["is_directed","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::map":["map","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::neighbors":["neighbors","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::neighbors_undirected":["neighbors_undirected","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_count":["node_count","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_indices":["node_indices","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_weight":["node_weight","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_weight_mut":["node_weight_mut","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::node_weights_mut":["node_weights_mut","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::raw_edges":["raw_edges","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::raw_nodes":["raw_nodes","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::remove_edge":["remove_edge","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::remove_node":["remove_node","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::retain_edges":["retain_edges","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::retain_nodes":["retain_nodes","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::update_edge":["update_edge","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E, Ty, Ix>::with_capacity":["with_capacity","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::StableGraph::<N, E>::new":["new","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::WalkNeighbors::<Ix>::next":["next","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::WalkNeighbors::<Ix>::next_edge":["next_edge","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::WalkNeighbors::<Ix>::next_node":["next_node","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::stable_graph::swap_pair":["swap_pair","Real(LocalPath(\"src/graph_impl/stable_graph/mod.rs\"))",""],"graph_impl::swap_pair":["swap_pair","Real(LocalPath(\"src/graph_impl/mod.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::add_edge":["add_edge","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::add_node":["add_node","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::all_edges":["all_edges","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::all_edges_mut":["all_edges_mut","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::capacity":["capacity","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::clear":["clear","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::contains_edge":["contains_edge","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::contains_node":["contains_node","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::edge_count":["edge_count","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::edge_key":["edge_key","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::edge_weight":["edge_weight","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::edge_weight_mut":["edge_weight_mut","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::edges":["edges","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::from_edges":["from_edges","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::into_graph":["into_graph","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::is_directed":["is_directed","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::neighbors":["neighbors","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::new":["new","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::node_count":["node_count","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::nodes":["nodes","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::remove_edge":["remove_edge","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::remove_node":["remove_node","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::remove_single_edge":["remove_single_edge","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::GraphMap::<N, E, Ty>::with_capacity":["with_capacity","Real(LocalPath(\"src/graphmap.rs\"))",""],"graphmap::ptr_eq":["ptr_eq","Real(LocalPath(\"src/graphmap.rs\"))",""],"isomorphism::Vf2State::<Ty, Ix>::is_complete":["is_complete","Real(LocalPath(\"src/isomorphism.rs\"))",""],"isomorphism::Vf2State::<Ty, Ix>::new":["new","Real(LocalPath(\"src/isomorphism.rs\"))",""],"isomorphism::Vf2State::<Ty, Ix>::next_in_index":["next_in_index","Real(LocalPath(\"src/isomorphism.rs\"))",""],"isomorphism::Vf2State::<Ty, Ix>::next_out_index":["next_out_index","Real(LocalPath(\"src/isomorphism.rs\"))",""],"isomorphism::Vf2State::<Ty, Ix>::next_rest_index":["next_rest_index","Real(LocalPath(\"src/isomorphism.rs\"))",""],"isomorphism::Vf2State::<Ty, Ix>::pop_mapping":["pop_mapping","Real(LocalPath(\"src/isomorphism.rs\"))",""],"isomorphism::Vf2State::<Ty, Ix>::push_mapping":["push_mapping","Real(LocalPath(\"src/isomorphism.rs\"))",""],"isomorphism::is_isomorphic":["is_isomorphic","Real(LocalPath(\"src/isomorphism.rs\"))",""],"isomorphism::is_isomorphic_matching":["is_isomorphic_matching","Real(LocalPath(\"src/isomorphism.rs\"))",""],"isomorphism::try_match":["try_match","Real(LocalPath(\"src/isomorphism.rs\"))",""],"iter_format::Format::<'a, I>::format":["format","Real(LocalPath(\"src/iter_format.rs\"))",""],"iter_format::IterFormatExt::format":["format","Real(LocalPath(\"src/iter_format.rs\"))",""],"iter_utils::IterUtilsExt::ex_find_map":["ex_find_map","Real(LocalPath(\"src/iter_utils.rs\"))",""],"iter_utils::IterUtilsExt::ex_rfind_map":["ex_rfind_map","Real(LocalPath(\"src/iter_utils.rs\"))",""],"matrix_graph::EdgeReferences::<'a, Ty, Null, Ix>::new":["new","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::Edges::<'a, Ty, Null, Ix>::on_columns":["on_columns","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::Edges::<'a, Ty, Null, Ix>::on_rows":["on_rows","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::IdStorage::<T>::add":["add","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::IdStorage::<T>::clear":["clear","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::IdStorage::<T>::iter_ids":["iter_ids","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::IdStorage::<T>::len":["len","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::IdStorage::<T>::remove":["remove","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::IdStorage::<T>::with_capacity":["with_capacity","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Directed, Null, Ix>::edges_directed":["edges_directed","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Directed, Null, Ix>::neighbors_directed":["neighbors_directed","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::add_edge":["add_edge","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::add_node":["add_node","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::clear":["clear","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edge_count":["edge_count","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edge_weight":["edge_weight","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edge_weight_mut":["edge_weight_mut","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::edges":["edges","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::extend_capacity_for_edge":["extend_capacity_for_edge","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::extend_capacity_for_node":["extend_capacity_for_node","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::extend_with_edges":["extend_with_edges","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::from_edges":["from_edges","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::has_edge":["has_edge","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::is_directed":["is_directed","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::neighbors":["neighbors","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::node_count":["node_count","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::node_weight":["node_weight","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::node_weight_mut":["node_weight_mut","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::remove_edge":["remove_edge","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::remove_node":["remove_node","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::to_edge_position":["to_edge_position","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::update_edge":["update_edge","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Ty, Null, Ix>::with_capacity":["with_capacity","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E, Undirected>::new_undirected":["new_undirected","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::MatrixGraph::<N, E>::new":["new","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::NodeIdentifiers::<'a, Ix>::new":["new","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::NodeReferences::<'a, N, Ix>::new":["new","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::Nullable::is_null":["is_null","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::ensure_len":["ensure_len","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::extend_flat_square_matrix":["extend_flat_square_matrix","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::extend_linearized_matrix":["extend_linearized_matrix","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::extend_lower_triangular_matrix":["extend_lower_triangular_matrix","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::node_index":["node_index","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::to_flat_square_matrix_position":["to_flat_square_matrix_position","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::to_linearized_matrix_position":["to_linearized_matrix_position","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"matrix_graph::to_lower_triangular_matrix_position":["to_lower_triangular_matrix_position","Real(LocalPath(\"src/matrix_graph.rs\"))",""],"simple_paths::all_simple_paths":["all_simple_paths","Real(LocalPath(\"src/simple_paths.rs\"))",""],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::Graph<N, E, Ty, Ix>>::adjacency_matrix":["adjacency_matrix","Real(LocalPath(\"src/traits_graph.rs\"))","visit::GetAdjacencyMatrix"],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::Graph<N, E, Ty, Ix>>::is_adjacent":["is_adjacent","Real(LocalPath(\"src/traits_graph.rs\"))","visit::GetAdjacencyMatrix"],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::stable_graph::StableGraph<N, E, Ty, Ix>>::adjacency_matrix":["adjacency_matrix","Real(LocalPath(\"src/traits_graph.rs\"))","visit::GetAdjacencyMatrix"],"traits_graph::<impl visit::GetAdjacencyMatrix for graph_impl::stable_graph::StableGraph<N, E, Ty, Ix>>::is_adjacent":["is_adjacent","Real(LocalPath(\"src/traits_graph.rs\"))","visit::GetAdjacencyMatrix"],"unionfind::UnionFind::<K>::equiv":["equiv","Real(LocalPath(\"src/unionfind.rs\"))",""],"unionfind::UnionFind::<K>::find":["find","Real(LocalPath(\"src/unionfind.rs\"))",""],"unionfind::UnionFind::<K>::find_mut":["find_mut","Real(LocalPath(\"src/unionfind.rs\"))",""],"unionfind::UnionFind::<K>::find_mut_recursive":["find_mut_recursive","Real(LocalPath(\"src/unionfind.rs\"))",""],"unionfind::UnionFind::<K>::into_labeling":["into_labeling","Real(LocalPath(\"src/unionfind.rs\"))",""],"unionfind::UnionFind::<K>::new":["new","Real(LocalPath(\"src/unionfind.rs\"))",""],"unionfind::UnionFind::<K>::union":["union","Real(LocalPath(\"src/unionfind.rs\"))",""],"unionfind::get_unchecked":["get_unchecked","Real(LocalPath(\"src/unionfind.rs\"))",""],"unionfind::get_unchecked_mut":["get_unchecked_mut","Real(LocalPath(\"src/unionfind.rs\"))",""],"util::enumerate":["enumerate","Real(LocalPath(\"src/util.rs\"))",""],"util::zip":["zip","Real(LocalPath(\"src/util.rs\"))",""],"visit::GraphProp::is_directed":["is_directed","Real(LocalPath(\"src/visit/mod.rs\"))",""],"visit::dfsvisit::Control::<B>::break_value":["break_value","Real(LocalPath(\"src/visit/dfsvisit.rs\"))",""],"visit::dfsvisit::Control::<B>::breaking":["breaking","Real(LocalPath(\"src/visit/dfsvisit.rs\"))",""],"visit::dfsvisit::depth_first_search":["depth_first_search","Real(LocalPath(\"src/visit/dfsvisit.rs\"))",""],"visit::dfsvisit::dfs_visitor":["dfs_visitor","Real(LocalPath(\"src/visit/dfsvisit.rs\"))",""],"visit::dfsvisit::time_post_inc":["time_post_inc","Real(LocalPath(\"src/visit/dfsvisit.rs\"))",""],"visit::filter::EdgeFiltered::<G, F>::from_fn":["from_fn","Real(LocalPath(\"src/visit/filter.rs\"))",""],"visit::filter::NodeFiltered::<G, F>::from_fn":["from_fn","Real(LocalPath(\"src/visit/filter.rs\"))",""],"visit::reversed::ReversedEdgeReference::<R>::as_unreversed":["as_unreversed","Real(LocalPath(\"src/visit/reversed.rs\"))",""],"visit::reversed::ReversedEdgeReference::<R>::into_unreversed":["into_unreversed","Real(LocalPath(\"src/visit/reversed.rs\"))",""],"visit::traversal::Bfs::<N, VM>::new":["new","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Bfs::<N, VM>::next":["next","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Dfs::<N, VM>::empty":["empty","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Dfs::<N, VM>::from_parts":["from_parts","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Dfs::<N, VM>::move_to":["move_to","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Dfs::<N, VM>::new":["new","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Dfs::<N, VM>::next":["next","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Dfs::<N, VM>::reset":["reset","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::DfsPostOrder::<N, VM>::empty":["empty","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::DfsPostOrder::<N, VM>::move_to":["move_to","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::DfsPostOrder::<N, VM>::new":["new","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::DfsPostOrder::<N, VM>::next":["next","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::DfsPostOrder::<N, VM>::reset":["reset","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Topo::<N, VM>::empty":["empty","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Topo::<N, VM>::extend_with_initials":["extend_with_initials","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Topo::<N, VM>::new":["new","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Topo::<N, VM>::next":["next","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Topo::<N, VM>::reset":["reset","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::Walker::iter":["iter","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::WalkerIter::<W, C>::context":["context","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::WalkerIter::<W, C>::inner_mut":["inner_mut","Real(LocalPath(\"src/visit/traversal.rs\"))",""],"visit::traversal::WalkerIter::<W, C>::inner_ref":["inner_ref","Real(LocalPath(\"src/visit/traversal.rs\"))",""]},"trait_to_struct":{"EdgeType":["Directed","Undirected"],"algo::Measure":["<M as algo::Measure>::M"],"data::Build":["graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap","matrix_graph::MatrixGraph"],"data::Create":["graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap"],"data::DataMap":["graph_impl::Frozen","graph_impl::Graph","graph_impl::stable_graph::StableGraph","visit::filter::NodeFiltered","visit::reversed::Reversed"],"data::DataMapMut":["graph_impl::Frozen","graph_impl::Graph","graph_impl::stable_graph::StableGraph","visit::reversed::Reversed"],"data::ElementIterator":["<I as data::ElementIterator<N, E>>::I"],"data::FromElements":["graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap"],"graph_impl::GraphIndex":["graph_impl::EdgeIndex","graph_impl::NodeIndex"],"graphmap::NodeTrait":["<N as graphmap::NodeTrait>::N"],"isomorphism::SemanticMatcher":["<F as isomorphism::SemanticMatcher<T>>::F","isomorphism::NoSemanticMatch"],"iter_format::IterFormatExt":["<I as iter_format::IterFormatExt>::I"],"iter_utils::IterUtilsExt":["<I as iter_utils::IterUtilsExt>::I"],"matrix_graph::Nullable":["matrix_graph::NotZero","std::option::Option"],"matrix_graph::private::Sealed":["matrix_graph::NotZero","std::option::Option"],"std::clone::Clone":["Directed","Direction","Undirected","algo::Cycle","algo::DfsSpace","algo::NegativeCycle","algo::dominators::Dominators","algo::tarjan_scc::NodeData","csr::Csr","csr::EdgeReference","csr::Edges","csr::EdgesNotSorted","csr::Neighbors","data::Element","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::EdgeIndices","graph_impl::EdgeReference","graph_impl::Edges","graph_impl::Graph","graph_impl::Neighbors","graph_impl::Node","graph_impl::NodeIndex","graph_impl::NodeIndices","graph_impl::WalkNeighbors","graph_impl::stable_graph::EdgeReference","graph_impl::stable_graph::StableGraph","graph_impl::stable_graph::WalkNeighbors","graphmap::CompactDirection","graphmap::GraphMap","graphmap::Ptr","isomorphism::try_match::Frame","isomorphism::try_match::OpenList","iter_format::Format","matrix_graph::IdStorage","matrix_graph::MatrixGraph","scored::MinScored","unionfind::UnionFind","visit::dfsvisit::Control","visit::dfsvisit::DfsEvent","visit::dfsvisit::Time","visit::filter::EdgeFiltered","visit::filter::NodeFiltered","visit::reversed::Reversed","visit::reversed::ReversedEdgeReference","visit::traversal::Bfs","visit::traversal::Dfs","visit::traversal::DfsPostOrder","visit::traversal::Topo","visit::traversal::WalkerIter"],"std::cmp::Eq":["Direction","data::Element","dot::Config","graph_impl::EdgeIndex","graph_impl::NodeIndex","graphmap::Ptr","scored::MinScored","visit::dfsvisit::Time"],"std::cmp::Ord":["Direction","graph_impl::EdgeIndex","graph_impl::NodeIndex","graphmap::Ptr","scored::MinScored","visit::dfsvisit::Time"],"std::cmp::PartialEq":["Direction","algo::Cycle","algo::NegativeCycle","data::Element","dot::Config","graph_impl::EdgeIndex","graph_impl::EdgeReference","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeReference","graphmap::CompactDirection","graphmap::Ptr","isomorphism::try_match::Frame","isomorphism::try_match::OpenList","scored::MinScored","visit::dfsvisit::Time"],"std::cmp::PartialOrd":["Direction","graph_impl::EdgeIndex","graph_impl::NodeIndex","graphmap::Ptr","scored::MinScored","visit::dfsvisit::Time"],"std::convert::From":["graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","graphmap::CompactDirection"],"std::convert::Into":["matrix_graph::NotZero"],"std::default::Default":["algo::DfsSpace","csr::Csr","graph_impl::EdgeIndex","graph_impl::Graph","graph_impl::NodeIndex","graph_impl::stable_graph::StableGraph","graphmap::GraphMap","matrix_graph::MatrixGraph","matrix_graph::NotZero","visit::dfsvisit::Control","visit::dfsvisit::Time","visit::traversal::Bfs","visit::traversal::Dfs","visit::traversal::DfsPostOrder","visit::traversal::Topo"],"std::fmt::Debug":["Directed","Direction","Undirected","algo::Cycle","algo::DfsSpace","algo::NegativeCycle","algo::dominators::Dominators","algo::tarjan_scc::Data","algo::tarjan_scc::NodeData","csr::Csr","csr::EdgeReference","csr::Edges","csr::EdgesNotSorted","csr::Neighbors","data::Element","dot::Config","dot::Dot","graph_impl::Edge","graph_impl::EdgeIndex","graph_impl::EdgeIndices","graph_impl::EdgeReference","graph_impl::Graph","graph_impl::Node","graph_impl::NodeIndex","graph_impl::NodeIndices","graph_impl::stable_graph::EdgeReference","graph_impl::stable_graph::StableGraph","graphmap::CompactDirection","graphmap::GraphMap","graphmap::Ptr","isomorphism::Vf2State","isomorphism::try_match::Frame","isomorphism::try_match::OpenList","iter_format::DebugMap","iter_format::Format","iter_format::NoPretty","scored::MinScored","unionfind::UnionFind","visit::dfsvisit::Control","visit::dfsvisit::DfsEvent","visit::dfsvisit::Time","visit::filter::EdgeFiltered","visit::filter::NodeFiltered","visit::reversed::Reversed","visit::reversed::ReversedEdgeReference","visit::traversal::Dfs","visit::traversal::DfsPostOrder","visit::traversal::WalkerIter"],"std::fmt::Display":["dot::DebugFmt","dot::Dot","dot::Escaped"],"std::fmt::Write":["dot::Escaper"],"std::hash::Hash":["Direction","graph_impl::EdgeIndex","graph_impl::NodeIndex","graphmap::Ptr","visit::dfsvisit::Time"],"std::iter::DoubleEndedIterator":["graph_impl::EdgeIndices","graph_impl::EdgeReferences","graph_impl::NodeIndices","graph_impl::NodeReferences","graph_impl::stable_graph::EdgeIndices","graph_impl::stable_graph::EdgeReferences","graph_impl::stable_graph::NodeIndices","graph_impl::stable_graph::NodeReferences","graphmap::AllEdges","graphmap::AllEdgesMut"],"std::iter::ExactSizeIterator":["graph_impl::EdgeIndices","graph_impl::EdgeReferences","graph_impl::NodeIndices","graph_impl::NodeReferences"],"std::iter::Extend":["graphmap::GraphMap"],"std::iter::FromIterator":["graphmap::GraphMap"],"std::iter::Iterator":["algo::MinSpanningTree","algo::dominators::DominatorsIter","csr::EdgeReferences","csr::Edges","csr::Neighbors","csr::NodeIdentifiers","data::FilterElements","graph_impl::EdgeIndices","graph_impl::EdgeReferences","graph_impl::EdgeWeightsMut","graph_impl::Edges","graph_impl::EdgesConnecting","graph_impl::Externals","graph_impl::Neighbors","graph_impl::NodeIndices","graph_impl::NodeReferences","graph_impl::NodeWeightsMut","graph_impl::stable_graph::EdgeIndices","graph_impl::stable_graph::EdgeReferences","graph_impl::stable_graph::Edges","graph_impl::stable_graph::Externals","graph_impl::stable_graph::Neighbors","graph_impl::stable_graph::NodeIndices","graph_impl::stable_graph::NodeReferences","graphmap::AllEdges","graphmap::AllEdgesMut","graphmap::Edges","graphmap::Neighbors","graphmap::NeighborsDirected","graphmap::NodeIdentifiers","graphmap::NodeReferences","graphmap::Nodes","matrix_graph::EdgeReferences","matrix_graph::Edges","matrix_graph::IdIterator","matrix_graph::Neighbors","matrix_graph::NodeIdentifiers","matrix_graph::NodeReferences","visit::filter::EdgeFilteredEdges","visit::filter::EdgeFilteredNeighbors","visit::filter::EdgeFilteredNeighborsDirected","visit::filter::NodeFilteredEdgeReferences","visit::filter::NodeFilteredEdges","visit::filter::NodeFilteredNeighbors","visit::filter::NodeFilteredNodes","visit::reversed::ReversedEdgeReferences","visit::reversed::ReversedEdges","visit::traversal::WalkerIter"],"std::marker::Copy":["Directed","Direction","Undirected","algo::tarjan_scc::NodeData","csr::EdgeReference","graph_impl::EdgeIndex","graph_impl::EdgeReference","graph_impl::NodeIndex","graph_impl::stable_graph::EdgeReference","graphmap::CompactDirection","graphmap::Ptr","isomorphism::try_match::OpenList","scored::MinScored","visit::dfsvisit::Control","visit::dfsvisit::DfsEvent","visit::dfsvisit::Time","visit::filter::EdgeFiltered","visit::filter::NodeFiltered","visit::reversed::Reversed","visit::reversed::ReversedEdgeReference"],"std::marker::StructuralEq":["Direction","data::Element","dot::Config","graph_impl::EdgeIndex","graph_impl::NodeIndex","visit::dfsvisit::Time"],"std::marker::StructuralPartialEq":["Direction","algo::Cycle","algo::NegativeCycle","data::Element","dot::Config","graph_impl::EdgeIndex","graph_impl::NodeIndex","graphmap::CompactDirection","isomorphism::try_match::Frame","isomorphism::try_match::OpenList","visit::dfsvisit::Time"],"std::ops::Deref":["graph_impl::Frozen","graphmap::Ptr"],"std::ops::Index":["csr::Csr","graph_impl::Frozen","graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap","matrix_graph::IdStorage","matrix_graph::MatrixGraph"],"std::ops::IndexMut":["csr::Csr","graph_impl::Frozen","graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap","matrix_graph::IdStorage","matrix_graph::MatrixGraph"],"visit::Data":["csr::Csr","graph_impl::Frozen","graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap","matrix_graph::MatrixGraph","visit::filter::EdgeFiltered","visit::filter::NodeFiltered","visit::reversed::Reversed"],"visit::EdgeRef":["csr::EdgeReference","graph_impl::EdgeReference","graph_impl::stable_graph::EdgeReference","visit::reversed::ReversedEdgeReference"],"visit::GetAdjacencyMatrix":["graph_impl::Frozen","graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap","matrix_graph::MatrixGraph"],"visit::GraphBase":["csr::Csr","graph_impl::Frozen","graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap","matrix_graph::MatrixGraph","visit::filter::EdgeFiltered","visit::filter::NodeFiltered","visit::reversed::Reversed"],"visit::GraphProp":["csr::Csr","graph_impl::Frozen","graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap","matrix_graph::MatrixGraph","visit::filter::EdgeFiltered","visit::filter::NodeFiltered","visit::reversed::Reversed"],"visit::GraphRef":["visit::reversed::Reversed"],"visit::IntoEdgeReferences":["visit::reversed::Reversed"],"visit::IntoEdges":["visit::reversed::Reversed"],"visit::IntoEdgesDirected":["visit::reversed::Reversed"],"visit::IntoNeighbors":["visit::reversed::Reversed"],"visit::IntoNeighborsDirected":["visit::reversed::Reversed"],"visit::IntoNodeIdentifiers":["visit::reversed::Reversed"],"visit::IntoNodeReferences":["visit::reversed::Reversed"],"visit::NodeCompactIndexable":["csr::Csr","graph_impl::Frozen","graph_impl::Graph","graphmap::GraphMap","matrix_graph::MatrixGraph","visit::filter::EdgeFiltered","visit::reversed::Reversed"],"visit::NodeCount":["csr::Csr","graph_impl::Frozen","graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap","matrix_graph::MatrixGraph","visit::filter::EdgeFiltered","visit::reversed::Reversed"],"visit::NodeIndexable":["csr::Csr","graph_impl::Frozen","graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap","matrix_graph::MatrixGraph","visit::filter::EdgeFiltered","visit::filter::NodeFiltered","visit::reversed::Reversed"],"visit::VisitMap":["fixedbitset::FixedBitSet","std::collections::HashSet"],"visit::Visitable":["csr::Csr","graph_impl::Frozen","graph_impl::Graph","graph_impl::stable_graph::StableGraph","graphmap::GraphMap","matrix_graph::MatrixGraph","visit::filter::EdgeFiltered","visit::filter::NodeFiltered","visit::reversed::Reversed"],"visit::dfsvisit::ControlFlow":["std::result::Result","visit::dfsvisit::Control"],"visit::filter::FilterEdge":["<F as visit::filter::FilterEdge<N>>::F"],"visit::filter::FilterNode":["<F as visit::filter::FilterNode<N>>::F","fixedbitset::FixedBitSet","std::collections::HashSet"],"visit::traversal::Walker":["visit::traversal::Bfs","visit::traversal::Dfs","visit::traversal::DfsPostOrder","visit::traversal::Topo"]},"type_to_def_path":{"Directed":"Directed","Direction":"Direction","Undirected":"Undirected","algo::Cycle<N>":"algo::Cycle","algo::DfsSpace<N, VM>":"algo::DfsSpace","algo::MinSpanningTree<G>":"algo::MinSpanningTree","algo::NegativeCycle":"algo::NegativeCycle","algo::dominators::Dominators<N>":"algo::dominators::Dominators","algo::dominators::DominatorsIter<'a, N>":"algo::dominators::DominatorsIter","algo::tarjan_scc::Data<'a, G>":"algo::tarjan_scc::Data","algo::tarjan_scc::NodeData":"algo::tarjan_scc::NodeData","astar::PathTracker<G>":"astar::PathTracker","csr::Csr<N, E, Ty, Ix>":"csr::Csr","csr::EdgeReference<'a, E, Ty, Ix>":"csr::EdgeReference","csr::EdgeReferences<'a, E, Ty, Ix>":"csr::EdgeReferences","csr::Edges<'a, E, Ty, Ix>":"csr::Edges","csr::EdgesNotSorted":"csr::EdgesNotSorted","csr::Neighbors<'a, Ix>":"csr::Neighbors","csr::NodeIdentifiers<Ix>":"csr::NodeIdentifiers","data::Element<N, E>":"data::Element","data::FilterElements<I, F>":"data::FilterElements","dot::Config":"dot::Config","dot::DebugFmt<T>":"dot::DebugFmt","dot::Dot<'a, G>":"dot::Dot","dot::Escaped<T>":"dot::Escaped","dot::Escaper<W>":"dot::Escaper","graph_impl::Edge<E, Ix>":"graph_impl::Edge","graph_impl::EdgeIndex<Ix>":"graph_impl::EdgeIndex","graph_impl::EdgeIndices<Ix>":"graph_impl::EdgeIndices","graph_impl::EdgeReference<'a, E, Ix>":"graph_impl::EdgeReference","graph_impl::EdgeReferences<'a, E, Ix>":"graph_impl::EdgeReferences","graph_impl::EdgeWeightsMut<'a, E, Ix>":"graph_impl::EdgeWeightsMut","graph_impl::Edges<'a, E, Ty, Ix>":"graph_impl::Edges","graph_impl::EdgesConnecting<'a, E, Ty, Ix>":"graph_impl::EdgesConnecting","graph_impl::EdgesWalkerMut<'a, E, Ix>":"graph_impl::EdgesWalkerMut","graph_impl::Externals<'a, N, Ty, Ix>":"graph_impl::Externals","graph_impl::Frozen<'a, G>":"graph_impl::Frozen","graph_impl::Graph<N, E, Ty, Ix>":"graph_impl::Graph","graph_impl::Neighbors<'a, E, Ix>":"graph_impl::Neighbors","graph_impl::Node<N, Ix>":"graph_impl::Node","graph_impl::NodeIndex<Ix>":"graph_impl::NodeIndex","graph_impl::NodeIndices<Ix>":"graph_impl::NodeIndices","graph_impl::NodeReferences<'a, N, Ix>":"graph_impl::NodeReferences","graph_impl::NodeWeightsMut<'a, N, Ix>":"graph_impl::NodeWeightsMut","graph_impl::Pair<T>":"graph_impl::Pair","graph_impl::WalkNeighbors<Ix>":"graph_impl::WalkNeighbors","graph_impl::stable_graph::EdgeIndices<'a, E, Ix>":"graph_impl::stable_graph::EdgeIndices","graph_impl::stable_graph::EdgeReference<'a, E, Ix>":"graph_impl::stable_graph::EdgeReference","graph_impl::stable_graph::EdgeReferences<'a, E, Ix>":"graph_impl::stable_graph::EdgeReferences","graph_impl::stable_graph::Edges<'a, E, Ty, Ix>":"graph_impl::stable_graph::Edges","graph_impl::stable_graph::Externals<'a, N, Ty, Ix>":"graph_impl::stable_graph::Externals","graph_impl::stable_graph::Neighbors<'a, E, Ix>":"graph_impl::stable_graph::Neighbors","graph_impl::stable_graph::NodeIndices<'a, N, Ix>":"graph_impl::stable_graph::NodeIndices","graph_impl::stable_graph::NodeReferences<'a, N, Ix>":"graph_impl::stable_graph::NodeReferences","graph_impl::stable_graph::StableGraph<N, E, Ty, Ix>":"graph_impl::stable_graph::StableGraph","graph_impl::stable_graph::WalkNeighbors<Ix>":"graph_impl::stable_graph::WalkNeighbors","graphmap::AllEdges<'a, N, E, Ty>":"graphmap::AllEdges","graphmap::AllEdgesMut<'a, N, E, Ty>":"graphmap::AllEdgesMut","graphmap::CompactDirection":"graphmap::CompactDirection","graphmap::Edges<'a, N, E, Ty>":"graphmap::Edges","graphmap::GraphMap<N, E, Ty>":"graphmap::GraphMap","graphmap::Neighbors<'a, N, Ty>":"graphmap::Neighbors","graphmap::NeighborsDirected<'a, N, Ty>":"graphmap::NeighborsDirected","graphmap::NodeIdentifiers<'a, N, E, Ty>":"graphmap::NodeIdentifiers","graphmap::NodeReferences<'a, N, E, Ty>":"graphmap::NodeReferences","graphmap::Nodes<'a, N>":"graphmap::Nodes","graphmap::Ptr<'b, T>":"graphmap::Ptr","isomorphism::NoSemanticMatch":"isomorphism::NoSemanticMatch","isomorphism::Vf2State<Ty, Ix>":"isomorphism::Vf2State","isomorphism::try_match::Frame<N>":"isomorphism::try_match::Frame","isomorphism::try_match::OpenList":"isomorphism::try_match::OpenList","iter_format::DebugMap<F>":"iter_format::DebugMap","iter_format::Format<'a, I>":"iter_format::Format","iter_format::NoPretty<T>":"iter_format::NoPretty","matrix_graph::EdgeReferences<'a, Ty, Null, Ix>":"matrix_graph::EdgeReferences","matrix_graph::Edges<'a, Ty, Null, Ix>":"matrix_graph::Edges","matrix_graph::IdIterator<'a>":"matrix_graph::IdIterator","matrix_graph::IdStorage<T>":"matrix_graph::IdStorage","matrix_graph::MatrixGraph<N, E, Ty, Null, Ix>":"matrix_graph::MatrixGraph","matrix_graph::NeighborIterDirection":"matrix_graph::NeighborIterDirection","matrix_graph::Neighbors<'a, Ty, Null, Ix>":"matrix_graph::Neighbors","matrix_graph::NodeIdentifiers<'a, Ix>":"matrix_graph::NodeIdentifiers","matrix_graph::NodeReferences<'a, N, Ix>":"matrix_graph::NodeReferences","matrix_graph::NotZero<T>":"matrix_graph::NotZero","scored::MinScored<K, T>":"scored::MinScored","unionfind::UnionFind<K>":"unionfind::UnionFind","visit::dfsvisit::Control<B>":"visit::dfsvisit::Control","visit::dfsvisit::DfsEvent<N>":"visit::dfsvisit::DfsEvent","visit::dfsvisit::Time":"visit::dfsvisit::Time","visit::filter::EdgeFiltered<G, F>":"visit::filter::EdgeFiltered","visit::filter::EdgeFilteredEdges<'a, G, I, F>":"visit::filter::EdgeFilteredEdges","visit::filter::EdgeFilteredNeighbors<'a, G, F>":"visit::filter::EdgeFilteredNeighbors","visit::filter::EdgeFilteredNeighborsDirected<'a, G, F>":"visit::filter::EdgeFilteredNeighborsDirected","visit::filter::NodeFiltered<G, F>":"visit::filter::NodeFiltered","visit::filter::NodeFilteredEdgeReferences<'a, G, I, F>":"visit::filter::NodeFilteredEdgeReferences","visit::filter::NodeFilteredEdges<'a, G, I, F>":"visit::filter::NodeFilteredEdges","visit::filter::NodeFilteredNeighbors<'a, I, F>":"visit::filter::NodeFilteredNeighbors","visit::filter::NodeFilteredNodes<'a, I, F>":"visit::filter::NodeFilteredNodes","visit::reversed::Reversed<G>":"visit::reversed::Reversed","visit::reversed::ReversedEdgeReference<R>":"visit::reversed::ReversedEdgeReference","visit::reversed::ReversedEdgeReferences<I>":"visit::reversed::ReversedEdgeReferences","visit::reversed::ReversedEdges<I>":"visit::reversed::ReversedEdges","visit::traversal::Bfs<N, VM>":"visit::traversal::Bfs","visit::traversal::Dfs<N, VM>":"visit::traversal::Dfs","visit::traversal::DfsPostOrder<N, VM>":"visit::traversal::DfsPostOrder","visit::traversal::Topo<N, VM>":"visit::traversal::Topo","visit::traversal::WalkerIter<W, C>":"visit::traversal::WalkerIter"}}