{"dependencies":{"<[u8] as ext_slice::ByteSlice>::as_bytes":[],"<[u8] as ext_slice::ByteSlice>::as_bytes_mut":[],"<bstr::BStr as std::hash::Hash>::hash":["bstr::BStr","std::hash::Hasher","std::marker::Sized"],"<bstring::BString as std::clone::Clone>::clone":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<bstring::BString as std::hash::Hash>::hash":["bstring::BString","std::alloc::Allocator","std::hash::Hasher","std::marker::Sized","std::vec::Vec"],"<cow::CowBytes<'a> as lazy_static::__Deref>::deref":["bstr::BStr","cow::CowBytes","cow::Imp","std::borrow::Cow","std::borrow::ToOwned"],"<cow::CowBytes<'a> as std::clone::Clone>::clone":["bstr::BStr","cow::CowBytes","cow::Imp","std::borrow::Cow","std::borrow::ToOwned"],"<cow::CowBytes<'a> as std::fmt::Debug>::fmt":["bstr::BStr","cow::CowBytes","cow::Imp","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<cow::Imp<'a> as std::clone::Clone>::clone":["bstr::BStr","cow::Imp","std::borrow::Cow","std::borrow::ToOwned"],"<cow::Imp<'a> as std::fmt::Debug>::fmt":["bstr::BStr","cow::Imp","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ext_slice::Bytes<'a> as std::clone::Clone>::clone":["ext_slice::Bytes","std::marker::Sized","std::slice::Iter"],"<ext_slice::Bytes<'a> as std::fmt::Debug>::fmt":["ext_slice::Bytes","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::slice::Iter"],"<ext_slice::Bytes<'a> as std::iter::DoubleEndedIterator>::next_back":["ext_slice::Bytes","std::marker::Sized","std::option::Option","std::slice::Iter"],"<ext_slice::Bytes<'a> as std::iter::ExactSizeIterator>::len":["ext_slice::Bytes","std::marker::Sized","std::slice::Iter"],"<ext_slice::Bytes<'a> as std::iter::Iterator>::next":["ext_slice::Bytes","std::marker::Sized","std::option::Option","std::slice::Iter"],"<ext_slice::Bytes<'a> as std::iter::Iterator>::size_hint":["ext_slice::Bytes","std::marker::Sized","std::option::Option","std::slice::Iter"],"<ext_slice::Fields<'a> as std::fmt::Debug>::fmt":["ext_slice::Fields","ext_slice::FieldsWith","std::fmt::Formatter","std::marker::Sized","std::result::Result","utf8::CharIndices"],"<ext_slice::Fields<'a> as std::iter::Iterator>::next":["ext_slice::Fields","ext_slice::FieldsWith","std::marker::Sized","std::option::Option","utf8::CharIndices"],"<ext_slice::FieldsWith<'a, F> as std::fmt::Debug>::fmt":["ext_slice::FieldsWith","std::fmt::Formatter","std::marker::Sized","std::result::Result","utf8::CharIndices"],"<ext_slice::FieldsWith<'a, F> as std::iter::Iterator>::next":["ext_slice::FieldsWith","std::marker::Sized","std::option::Option","utf8::CharIndices"],"<ext_slice::Find<'a> as std::fmt::Debug>::fmt":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ext_slice::Find<'a> as std::iter::Iterator>::next":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<ext_slice::FindReverse<'a> as std::fmt::Debug>::fmt":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<ext_slice::FindReverse<'a> as std::iter::Iterator>::next":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<ext_slice::Finder<'a> as std::clone::Clone>::clone":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Finder","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"<ext_slice::Finder<'a> as std::fmt::Debug>::fmt":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Finder","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ext_slice::FinderReverse<'a> as std::clone::Clone>::clone":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FinderReverse","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"<ext_slice::FinderReverse<'a> as std::fmt::Debug>::fmt":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FinderReverse","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ext_slice::Lines<'a> as std::iter::Iterator>::next":["ext_slice::Lines","ext_slice::LinesWithTerminator","std::marker::Sized","std::option::Option"],"<ext_slice::LinesWithTerminator<'a> as std::iter::Iterator>::next":["ext_slice::LinesWithTerminator","std::marker::Sized","std::option::Option"],"<ext_slice::Split<'a> as std::fmt::Debug>::fmt":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","ext_slice::Split","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ext_slice::Split<'a> as std::iter::Iterator>::next":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","ext_slice::Split","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<ext_slice::SplitN<'a> as std::fmt::Debug>::fmt":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","ext_slice::Split","ext_slice::SplitN","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ext_slice::SplitN<'a> as std::iter::Iterator>::next":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","ext_slice::Split","ext_slice::SplitN","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<ext_slice::SplitNReverse<'a> as std::fmt::Debug>::fmt":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","ext_slice::SplitNReverse","ext_slice::SplitReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<ext_slice::SplitNReverse<'a> as std::iter::Iterator>::next":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","ext_slice::SplitNReverse","ext_slice::SplitReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<ext_slice::SplitReverse<'a> as std::fmt::Debug>::fmt":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","ext_slice::SplitReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<ext_slice::SplitReverse<'a> as std::iter::Iterator>::next":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","ext_slice::SplitReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<ext_vec::DrainBytes<'a> as std::fmt::Debug>::fmt":["ext_vec::DrainBytes","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Drain"],"<ext_vec::DrainBytes<'a> as std::iter::DoubleEndedIterator>::next_back":["ext_vec::DrainBytes","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Drain"],"<ext_vec::DrainBytes<'a> as std::iter::ExactSizeIterator>::len":["ext_vec::DrainBytes","std::alloc::Allocator","std::marker::Sized","std::vec::Drain"],"<ext_vec::DrainBytes<'a> as std::iter::Iterator>::next":["ext_vec::DrainBytes","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Drain"],"<ext_vec::FromUtf8Error as std::cmp::Eq>::assert_receiver_is_total_eq":["ext_vec::FromUtf8Error","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","utf8::Utf8Error"],"<ext_vec::FromUtf8Error as std::cmp::PartialEq>::eq":["ext_vec::FromUtf8Error","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","utf8::Utf8Error"],"<ext_vec::FromUtf8Error as std::error::Error>::description":["ext_vec::FromUtf8Error","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","utf8::Utf8Error"],"<ext_vec::FromUtf8Error as std::fmt::Debug>::fmt":["ext_vec::FromUtf8Error","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","utf8::Utf8Error"],"<ext_vec::FromUtf8Error as std::fmt::Display>::fmt":["ext_vec::FromUtf8Error","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","utf8::Utf8Error"],"<io::ByteLines<B> as std::fmt::Debug>::fmt":["io::ByteLines","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<io::ByteLines<B> as std::iter::Iterator>::next":["io::ByteLines","std::marker::Sized","std::option::Option"],"<io::ByteRecords<B> as std::fmt::Debug>::fmt":["io::ByteRecords","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<io::ByteRecords<B> as std::iter::Iterator>::next":["io::ByteRecords","std::marker::Sized","std::option::Option"],"<search::prefilter::Freqy as std::clone::Clone>::clone":["search::prefilter::Freqy"],"<search::prefilter::Freqy as std::fmt::Debug>::fmt":["search::prefilter::Freqy","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<search::prefilter::PrefilterState as std::clone::Clone>::clone":["search::prefilter::PrefilterState"],"<search::prefilter::PrefilterState as std::fmt::Debug>::fmt":["search::prefilter::PrefilterState","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<search::twoway::Shift as std::clone::Clone>::clone":["search::twoway::Shift"],"<search::twoway::Shift as std::fmt::Debug>::fmt":["search::twoway::Shift","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<search::twoway::Suffix as std::fmt::Debug>::fmt":["search::twoway::Suffix","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<search::twoway::SuffixKind as std::clone::Clone>::clone":["search::twoway::SuffixKind"],"<search::twoway::SuffixKind as std::fmt::Debug>::fmt":["search::twoway::SuffixKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<search::twoway::SuffixOrdering as std::clone::Clone>::clone":["search::twoway::SuffixOrdering"],"<search::twoway::SuffixOrdering as std::fmt::Debug>::fmt":["search::twoway::SuffixOrdering","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<search::twoway::TwoWay<'b> as std::clone::Clone>::clone":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"<search::twoway::TwoWay<'b> as std::fmt::Debug>::fmt":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<std::vec::Vec<u8> as ext_vec::ByteVec>::as_vec":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<std::vec::Vec<u8> as ext_vec::ByteVec>::as_vec_mut":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<std::vec::Vec<u8> as ext_vec::ByteVec>::into_vec":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::LazyStatic>::initialize":["unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized","unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref::__stability":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::LazyStatic>::initialize":["unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized","unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref::__stability":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref::__static_ref_initialize":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::LazyStatic>::initialize":["unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref":["bstr::BStr","regex_automata::DenseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized","unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref::__stability":["bstr::BStr","regex_automata::DenseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref::__static_ref_initialize":["bstr::BStr","regex_automata::DenseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::LazyStatic>::initialize":["unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized","unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref::__stability":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::LazyStatic>::initialize":["unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized","unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref::__stability":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::LazyStatic>::initialize":["unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref":["bstr::BStr","regex_automata::DenseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized","unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref::__stability":["bstr::BStr","regex_automata::DenseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["bstr::BStr","regex_automata::DenseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::LazyStatic>::initialize":["unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref":["bstr::BStr","regex_automata::DenseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized","unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref::__stability":["bstr::BStr","regex_automata::DenseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref::__static_ref_initialize":["bstr::BStr","regex_automata::DenseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::LazyStatic>::initialize":["unicode::fsm::word_break_fwd::WORD_BREAK_FWD"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized","unicode::fsm::word_break_fwd::WORD_BREAK_FWD"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref::__stability":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["bstr::BStr","regex_automata::SparseDFA","regex_automata::StateID","std::convert::AsRef","std::marker::Sized"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned"],"<unicode::grapheme::GraphemeIndices<'a> as std::clone::Clone>::clone":["unicode::grapheme::GraphemeIndices"],"<unicode::grapheme::GraphemeIndices<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","unicode::grapheme::GraphemeIndices"],"<unicode::grapheme::GraphemeIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["std::marker::Sized","std::option::Option","unicode::grapheme::GraphemeIndices"],"<unicode::grapheme::GraphemeIndices<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","unicode::grapheme::GraphemeIndices"],"<unicode::grapheme::Graphemes<'a> as std::clone::Clone>::clone":["unicode::grapheme::Graphemes"],"<unicode::grapheme::Graphemes<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","unicode::grapheme::Graphemes"],"<unicode::grapheme::Graphemes<'a> as std::iter::DoubleEndedIterator>::next_back":["std::marker::Sized","std::option::Option","unicode::grapheme::Graphemes"],"<unicode::grapheme::Graphemes<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","unicode::grapheme::Graphemes"],"<unicode::sentence::SentenceIndices<'a> as std::clone::Clone>::clone":["unicode::sentence::SentenceIndices"],"<unicode::sentence::SentenceIndices<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","unicode::sentence::SentenceIndices"],"<unicode::sentence::SentenceIndices<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","unicode::sentence::SentenceIndices"],"<unicode::sentence::Sentences<'a> as std::clone::Clone>::clone":["unicode::sentence::Sentences"],"<unicode::sentence::Sentences<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","unicode::sentence::Sentences"],"<unicode::sentence::Sentences<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","unicode::sentence::Sentences"],"<unicode::word::WordIndices<'a> as std::clone::Clone>::clone":["unicode::word::WordIndices","unicode::word::WordsWithBreakIndices"],"<unicode::word::WordIndices<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","unicode::word::WordIndices","unicode::word::WordsWithBreakIndices"],"<unicode::word::WordIndices<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","unicode::word::WordIndices","unicode::word::WordsWithBreakIndices"],"<unicode::word::Words<'a> as std::clone::Clone>::clone":["unicode::word::Words","unicode::word::WordsWithBreaks"],"<unicode::word::Words<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","unicode::word::Words","unicode::word::WordsWithBreaks"],"<unicode::word::Words<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","unicode::word::Words","unicode::word::WordsWithBreaks"],"<unicode::word::WordsWithBreakIndices<'a> as std::clone::Clone>::clone":["unicode::word::WordsWithBreakIndices"],"<unicode::word::WordsWithBreakIndices<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","unicode::word::WordsWithBreakIndices"],"<unicode::word::WordsWithBreakIndices<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","unicode::word::WordsWithBreakIndices"],"<unicode::word::WordsWithBreaks<'a> as std::clone::Clone>::clone":["unicode::word::WordsWithBreaks"],"<unicode::word::WordsWithBreaks<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","unicode::word::WordsWithBreaks"],"<unicode::word::WordsWithBreaks<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","unicode::word::WordsWithBreaks"],"<utf8::CharIndices<'a> as std::clone::Clone>::clone":["utf8::CharIndices"],"<utf8::CharIndices<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf8::CharIndices"],"<utf8::CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["std::marker::Sized","std::option::Option","utf8::CharIndices"],"<utf8::CharIndices<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","utf8::CharIndices"],"<utf8::Chars<'a> as std::clone::Clone>::clone":["utf8::Chars"],"<utf8::Chars<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf8::Chars"],"<utf8::Chars<'a> as std::iter::DoubleEndedIterator>::next_back":["std::marker::Sized","std::option::Option","utf8::Chars"],"<utf8::Chars<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","utf8::Chars"],"<utf8::Utf8Chunks<'a> as std::clone::Clone>::clone":["utf8::Utf8Chunks"],"<utf8::Utf8Chunks<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utf8::Utf8Chunks"],"<utf8::Utf8Chunks<'a> as std::iter::Iterator>::next":["std::marker::Sized","std::option::Option","utf8::Utf8Chunks"],"<utf8::Utf8Chunks<'a> as std::iter::Iterator>::size_hint":["std::marker::Sized","std::option::Option","utf8::Utf8Chunks"],"<utf8::Utf8Error as std::cmp::Eq>::assert_receiver_is_total_eq":["std::marker::Sized","std::option::Option","utf8::Utf8Error"],"<utf8::Utf8Error as std::cmp::PartialEq>::eq":["std::marker::Sized","std::option::Option","utf8::Utf8Error"],"<utf8::Utf8Error as std::error::Error>::description":["std::marker::Sized","std::option::Option","utf8::Utf8Error"],"<utf8::Utf8Error as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","utf8::Utf8Error"],"<utf8::Utf8Error as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","utf8::Utf8Error"],"ascii::first_non_ascii_byte":[],"ascii::first_non_ascii_byte_slow":[],"ascii::first_non_ascii_byte_sse2":[],"ascii::ptr_add":[],"ascii::ptr_sub":[],"ascii::sub":[],"bstr::BStr":["bstr::BStr"],"bstr::BStr::as_bytes":["bstr::BStr"],"bstr::BStr::from_boxed_bytes":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"bstr::BStr::from_bytes":["bstr::BStr"],"bstr::BStr::from_bytes_mut":["bstr::BStr"],"bstr::BStr::into_boxed_bytes":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"bstr::BStr::new":["bstr::BStr","std::convert::AsRef"],"bstr::BStr::new_mut":["bstr::BStr","std::convert::AsMut"],"bstring::BString":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"bstring::BString::as_bstr":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"bstring::BString::as_bytes":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"bstring::BString::as_mut_bstr":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"byteset::build_table":[],"byteset::find":["std::marker::Sized","std::option::Option"],"byteset::find_not":["std::marker::Sized","std::option::Option"],"byteset::rfind":["std::marker::Sized","std::option::Option"],"byteset::rfind_not":["std::marker::Sized","std::option::Option"],"byteset::scalar::forward_search":["std::marker::Sized","std::ops::Fn","std::option::Option"],"byteset::scalar::forward_search_bytes":["std::marker::Sized","std::ops::Fn","std::option::Option"],"byteset::scalar::inv_memchr":["std::marker::Sized","std::option::Option"],"byteset::scalar::inv_memrchr":["std::marker::Sized","std::option::Option"],"byteset::scalar::read_unaligned_usize":[],"byteset::scalar::repeat_byte":[],"byteset::scalar::reverse_search":["std::marker::Sized","std::ops::Fn","std::option::Option"],"byteset::scalar::reverse_search_bytes":["std::marker::Sized","std::ops::Fn","std::option::Option"],"byteset::scalar::sub":[],"cow::CowBytes":["bstr::BStr","cow::CowBytes","cow::Imp","std::borrow::Cow","std::borrow::ToOwned"],"cow::CowBytes::<'a>::as_slice":["bstr::BStr","cow::CowBytes","cow::Imp","std::borrow::Cow","std::borrow::ToOwned"],"cow::CowBytes::<'a>::into_owned":["bstr::BStr","cow::CowBytes","cow::Imp","std::borrow::Cow","std::borrow::ToOwned"],"cow::CowBytes::<'a>::new":["bstr::BStr","cow::CowBytes","cow::Imp","std::borrow::Cow","std::borrow::ToOwned","std::convert::AsRef"],"cow::CowBytes::<'a>::new_owned":["bstr::BStr","cow::CowBytes","cow::Imp","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::vec::Vec"],"cow::Imp":["bstr::BStr","cow::Imp","std::borrow::Cow","std::borrow::ToOwned"],"cow::Imp::<'a>::as_slice":["bstr::BStr","cow::Imp","std::borrow::Cow","std::borrow::ToOwned"],"cow::Imp::<'a>::new":["bstr::BStr","cow::Imp","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::B":["bstr::BStr","std::convert::AsRef"],"ext_slice::ByteSlice::as_bstr":["bstr::BStr"],"ext_slice::ByteSlice::as_bstr_mut":["bstr::BStr"],"ext_slice::ByteSlice::as_bytes":[],"ext_slice::ByteSlice::as_bytes_mut":[],"ext_slice::ByteSlice::bytes":["ext_slice::Bytes","std::marker::Sized","std::slice::Iter"],"ext_slice::ByteSlice::char_indices":["utf8::CharIndices"],"ext_slice::ByteSlice::chars":["utf8::Chars"],"ext_slice::ByteSlice::contains_str":["bstr::BStr","std::convert::AsRef","std::marker::Sized"],"ext_slice::ByteSlice::copy_within_str":["std::marker::Sized","std::ops::RangeBounds"],"ext_slice::ByteSlice::ends_with_str":["bstr::BStr","std::convert::AsRef","std::marker::Sized"],"ext_slice::ByteSlice::fields":["ext_slice::Fields","ext_slice::FieldsWith","std::marker::Sized","utf8::CharIndices"],"ext_slice::ByteSlice::fields_with":["ext_slice::FieldsWith","std::marker::Sized","std::ops::FnMut","utf8::CharIndices"],"ext_slice::ByteSlice::find":["bstr::BStr","std::convert::AsRef","std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::find_byte":["std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::find_byteset":["bstr::BStr","std::convert::AsRef","std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::find_char":["std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::find_iter":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::convert::AsRef"],"ext_slice::ByteSlice::find_non_ascii_byte":["std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::find_not_byteset":["bstr::BStr","std::convert::AsRef","std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::from_os_str":["std::ffi::OsStr","std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::from_os_str::imp":["std::ffi::OsStr","std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::from_path":["std::marker::Sized","std::option::Option","std::path::Path"],"ext_slice::ByteSlice::grapheme_indices":["unicode::grapheme::GraphemeIndices"],"ext_slice::ByteSlice::graphemes":["unicode::grapheme::Graphemes"],"ext_slice::ByteSlice::is_ascii":[],"ext_slice::ByteSlice::is_utf8":[],"ext_slice::ByteSlice::last_byte":["std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::lines":["ext_slice::Lines","ext_slice::LinesWithTerminator"],"ext_slice::ByteSlice::lines_with_terminator":["ext_slice::LinesWithTerminator"],"ext_slice::ByteSlice::make_ascii_lowercase":[],"ext_slice::ByteSlice::make_ascii_uppercase":[],"ext_slice::ByteSlice::repeatn":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ext_slice::ByteSlice::replace":["bstr::BStr","std::alloc::Allocator","std::convert::AsRef","std::marker::Sized","std::vec::Vec"],"ext_slice::ByteSlice::replace_into":["bstr::BStr","std::alloc::Allocator","std::convert::AsRef","std::marker::Sized","std::vec::Vec"],"ext_slice::ByteSlice::replacen":["bstr::BStr","std::alloc::Allocator","std::convert::AsRef","std::marker::Sized","std::vec::Vec"],"ext_slice::ByteSlice::replacen_into":["bstr::BStr","std::alloc::Allocator","std::convert::AsRef","std::marker::Sized","std::vec::Vec"],"ext_slice::ByteSlice::reverse_bytes":[],"ext_slice::ByteSlice::reverse_chars":[],"ext_slice::ByteSlice::reverse_graphemes":[],"ext_slice::ByteSlice::rfind":["bstr::BStr","std::convert::AsRef","std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::rfind_byte":["std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::rfind_byteset":["bstr::BStr","std::convert::AsRef","std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::rfind_char":["std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::rfind_iter":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::convert::AsRef","std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::rfind_not_byteset":["bstr::BStr","std::convert::AsRef","std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::rsplit_str":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","ext_slice::SplitReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::convert::AsRef","std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::rsplitn_str":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","ext_slice::SplitNReverse","ext_slice::SplitReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::convert::AsRef","std::marker::Sized","std::option::Option"],"ext_slice::ByteSlice::sentence_indices":["unicode::sentence::SentenceIndices"],"ext_slice::ByteSlice::sentences":["unicode::sentence::Sentences"],"ext_slice::ByteSlice::split_str":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","ext_slice::Split","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::convert::AsRef"],"ext_slice::ByteSlice::splitn_str":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","ext_slice::Split","ext_slice::SplitN","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::convert::AsRef"],"ext_slice::ByteSlice::starts_with_str":["bstr::BStr","std::convert::AsRef","std::marker::Sized"],"ext_slice::ByteSlice::to_ascii_lowercase":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ext_slice::ByteSlice::to_ascii_uppercase":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ext_slice::ByteSlice::to_lowercase":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ext_slice::ByteSlice::to_lowercase_into":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ext_slice::ByteSlice::to_os_str":["std::marker::Sized","std::result::Result"],"ext_slice::ByteSlice::to_os_str::imp":["std::marker::Sized","std::result::Result"],"ext_slice::ByteSlice::to_os_str_lossy":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::ByteSlice::to_os_str_lossy::imp":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::ByteSlice::to_path":["std::marker::Sized","std::result::Result"],"ext_slice::ByteSlice::to_path_lossy":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::ByteSlice::to_str":["std::marker::Sized","std::result::Result"],"ext_slice::ByteSlice::to_str_lossy":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::ByteSlice::to_str_lossy_into":["std::string::String"],"ext_slice::ByteSlice::to_str_unchecked":[],"ext_slice::ByteSlice::to_uppercase":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ext_slice::ByteSlice::to_uppercase_into":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ext_slice::ByteSlice::trim":[],"ext_slice::ByteSlice::trim_end":[],"ext_slice::ByteSlice::trim_end_with":["std::marker::Sized","std::ops::FnMut"],"ext_slice::ByteSlice::trim_start":[],"ext_slice::ByteSlice::trim_start_with":["std::marker::Sized","std::ops::FnMut"],"ext_slice::ByteSlice::trim_with":["std::marker::Sized","std::ops::FnMut"],"ext_slice::ByteSlice::utf8_chunks":["utf8::Utf8Chunks"],"ext_slice::ByteSlice::word_indices":["unicode::word::WordIndices","unicode::word::WordsWithBreakIndices"],"ext_slice::ByteSlice::words":["unicode::word::Words","unicode::word::WordsWithBreaks"],"ext_slice::ByteSlice::words_with_break_indices":["unicode::word::WordsWithBreakIndices"],"ext_slice::ByteSlice::words_with_breaks":["unicode::word::WordsWithBreaks"],"ext_slice::Bytes":["ext_slice::Bytes","std::marker::Sized","std::slice::Iter"],"ext_slice::Bytes::<'a>::as_slice":["ext_slice::Bytes","std::marker::Sized","std::slice::Iter"],"ext_slice::Fields":["ext_slice::Fields","ext_slice::FieldsWith","std::marker::Sized","utf8::CharIndices"],"ext_slice::Fields::<'a>::new":["ext_slice::Fields","ext_slice::FieldsWith","std::marker::Sized","utf8::CharIndices"],"ext_slice::FieldsWith":["ext_slice::FieldsWith","std::marker::Sized","utf8::CharIndices"],"ext_slice::FieldsWith::<'a, F>::new":["ext_slice::FieldsWith","std::marker::Sized","utf8::CharIndices"],"ext_slice::Find":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::Find::<'a>::new":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::FindReverse":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"ext_slice::FindReverse::<'a>::haystack":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"ext_slice::FindReverse::<'a>::needle":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"ext_slice::FindReverse::<'a>::new":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"ext_slice::Finder":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Finder","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::Finder::<'a>::find":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Finder","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::convert::AsRef","std::marker::Sized","std::option::Option"],"ext_slice::Finder::<'a>::into_owned":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Finder","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::Finder::<'a>::needle":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Finder","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::Finder::<'a>::new":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Finder","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::convert::AsRef"],"ext_slice::FinderReverse":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FinderReverse","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::FinderReverse::<'a>::into_owned":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FinderReverse","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::FinderReverse::<'a>::needle":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FinderReverse","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::FinderReverse::<'a>::new":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FinderReverse","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::convert::AsRef"],"ext_slice::FinderReverse::<'a>::rfind":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FinderReverse","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::convert::AsRef","std::marker::Sized","std::option::Option"],"ext_slice::Lines":["ext_slice::Lines","ext_slice::LinesWithTerminator"],"ext_slice::Lines::<'a>::new":["ext_slice::Lines","ext_slice::LinesWithTerminator"],"ext_slice::LinesWithTerminator":["ext_slice::LinesWithTerminator"],"ext_slice::LinesWithTerminator::<'a>::new":["ext_slice::LinesWithTerminator"],"ext_slice::Split":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","ext_slice::Split","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::Split::<'a>::new":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","ext_slice::Split","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::SplitN":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","ext_slice::Split","ext_slice::SplitN","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::SplitN::<'a>::new":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::Find","ext_slice::Split","ext_slice::SplitN","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"ext_slice::SplitNReverse":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","ext_slice::SplitNReverse","ext_slice::SplitReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"ext_slice::SplitNReverse::<'a>::new":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","ext_slice::SplitNReverse","ext_slice::SplitReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"ext_slice::SplitReverse":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","ext_slice::SplitReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"ext_slice::SplitReverse::<'a>::new":["bstr::BStr","cow::CowBytes","cow::Imp","ext_slice::FindReverse","ext_slice::SplitReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"ext_vec::ByteVec::as_vec":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ext_vec::ByteVec::as_vec_mut":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ext_vec::ByteVec::drain_bytes":["ext_vec::DrainBytes","std::alloc::Allocator","std::marker::Sized","std::ops::RangeBounds","std::vec::Drain"],"ext_vec::ByteVec::from_os_str_lossy":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned","std::ffi::OsStr"],"ext_vec::ByteVec::from_os_str_lossy::imp":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned","std::ffi::OsStr"],"ext_vec::ByteVec::from_os_string":["std::ffi::OsString","std::marker::Sized","std::result::Result"],"ext_vec::ByteVec::from_os_string::imp":["std::ffi::OsString","std::marker::Sized","std::result::Result"],"ext_vec::ByteVec::from_path_buf":["std::marker::Sized","std::path::PathBuf","std::result::Result"],"ext_vec::ByteVec::from_path_lossy":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned","std::path::Path"],"ext_vec::ByteVec::from_slice":["bstr::BStr","std::alloc::Allocator","std::convert::AsRef","std::marker::Sized","std::vec::Vec"],"ext_vec::ByteVec::insert_char":[],"ext_vec::ByteVec::insert_str":["bstr::BStr","std::convert::AsRef","std::marker::Sized"],"ext_vec::ByteVec::into_os_string":["std::marker::Sized","std::result::Result"],"ext_vec::ByteVec::into_os_string::imp":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"ext_vec::ByteVec::into_os_string_lossy":["std::ffi::OsString","std::marker::Sized"],"ext_vec::ByteVec::into_os_string_lossy::imp":["std::alloc::Allocator","std::ffi::OsString","std::marker::Sized","std::vec::Vec"],"ext_vec::ByteVec::into_path_buf":["std::marker::Sized","std::result::Result"],"ext_vec::ByteVec::into_path_buf_lossy":["std::marker::Sized","std::path::PathBuf"],"ext_vec::ByteVec::into_string":["std::marker::Sized","std::result::Result"],"ext_vec::ByteVec::into_string_lossy":["std::marker::Sized","std::string::String"],"ext_vec::ByteVec::into_string_unchecked":["std::marker::Sized","std::string::String"],"ext_vec::ByteVec::into_vec":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ext_vec::ByteVec::pop_byte":["std::marker::Sized","std::option::Option"],"ext_vec::ByteVec::pop_char":["std::marker::Sized","std::option::Option"],"ext_vec::ByteVec::push_byte":[],"ext_vec::ByteVec::push_char":[],"ext_vec::ByteVec::push_str":["bstr::BStr","std::convert::AsRef","std::marker::Sized"],"ext_vec::ByteVec::remove_char":[],"ext_vec::ByteVec::replace_range":["bstr::BStr","std::convert::AsRef","std::marker::Sized","std::ops::RangeBounds"],"ext_vec::DrainBytes":["ext_vec::DrainBytes","std::alloc::Allocator","std::marker::Sized","std::vec::Drain"],"ext_vec::FromUtf8Error":["ext_vec::FromUtf8Error","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","utf8::Utf8Error"],"ext_vec::FromUtf8Error::as_bytes":["ext_vec::FromUtf8Error","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","utf8::Utf8Error"],"ext_vec::FromUtf8Error::into_vec":["ext_vec::FromUtf8Error","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","utf8::Utf8Error"],"ext_vec::FromUtf8Error::utf8_error":["ext_vec::FromUtf8Error","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec","utf8::Utf8Error"],"ext_vec::concat":["bstr::BStr","std::alloc::Allocator","std::convert::AsRef","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"ext_vec::join":["bstr::BStr","std::alloc::Allocator","std::convert::AsRef","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"impls::bstr::<impl lazy_static::__Deref for bstr::BStr>::deref":["bstr::BStr"],"impls::bstr::<impl std::cmp::Ord for bstr::BStr>::cmp":["bstr::BStr","std::cmp::Ordering"],"impls::bstr::<impl std::cmp::PartialEq for bstr::BStr>::eq":["bstr::BStr"],"impls::bstr::<impl std::cmp::PartialEq<&'a [u8]> for bstr::BStr>::eq":["bstr::BStr"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::borrow::Cow<'a, [u8]>>::eq":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::borrow::Cow<'a, bstr::BStr>>::eq":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::borrow::Cow<'a, str>>::eq":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::string::String>::eq":["bstr::BStr","std::string::String"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::vec::Vec<u8>>::eq":["bstr::BStr","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstr::<impl std::cmp::PartialEq<&'a str> for bstr::BStr>::eq":["bstr::BStr"],"impls::bstr::<impl std::cmp::PartialEq<[u8]> for bstr::BStr>::eq":["bstr::BStr"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for &'a [u8]>::eq":["bstr::BStr"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for &'a str>::eq":["bstr::BStr"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for [u8]>::eq":["bstr::BStr"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for std::string::String>::eq":["bstr::BStr","std::string::String"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for std::vec::Vec<u8>>::eq":["bstr::BStr","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for str>::eq":["bstr::BStr"],"impls::bstr::<impl std::cmp::PartialEq<std::borrow::Cow<'a, [u8]>> for &'a bstr::BStr>::eq":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned"],"impls::bstr::<impl std::cmp::PartialEq<std::borrow::Cow<'a, bstr::BStr>> for &'a bstr::BStr>::eq":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned"],"impls::bstr::<impl std::cmp::PartialEq<std::borrow::Cow<'a, str>> for &'a bstr::BStr>::eq":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned"],"impls::bstr::<impl std::cmp::PartialEq<std::string::String> for &'a bstr::BStr>::eq":["bstr::BStr","std::string::String"],"impls::bstr::<impl std::cmp::PartialEq<std::string::String> for bstr::BStr>::eq":["bstr::BStr","std::string::String"],"impls::bstr::<impl std::cmp::PartialEq<std::vec::Vec<u8>> for &'a bstr::BStr>::eq":["bstr::BStr","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstr::<impl std::cmp::PartialEq<std::vec::Vec<u8>> for bstr::BStr>::eq":["bstr::BStr","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstr::<impl std::cmp::PartialEq<str> for bstr::BStr>::eq":["bstr::BStr"],"impls::bstr::<impl std::cmp::PartialOrd for bstr::BStr>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option"],"impls::bstr::<impl std::cmp::PartialOrd<&'a [u8]> for bstr::BStr>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option"],"impls::bstr::<impl std::cmp::PartialOrd<&'a bstr::BStr> for std::string::String>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option","std::string::String"],"impls::bstr::<impl std::cmp::PartialOrd<&'a bstr::BStr> for std::vec::Vec<u8>>::partial_cmp":["bstr::BStr","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstr::<impl std::cmp::PartialOrd<&'a str> for bstr::BStr>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option"],"impls::bstr::<impl std::cmp::PartialOrd<[u8]> for bstr::BStr>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for &'a [u8]>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for &'a str>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for [u8]>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for std::string::String>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option","std::string::String"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for std::vec::Vec<u8>>::partial_cmp":["bstr::BStr","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for str>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option"],"impls::bstr::<impl std::cmp::PartialOrd<std::string::String> for &'a bstr::BStr>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option","std::string::String"],"impls::bstr::<impl std::cmp::PartialOrd<std::string::String> for bstr::BStr>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option","std::string::String"],"impls::bstr::<impl std::cmp::PartialOrd<std::vec::Vec<u8>> for &'a bstr::BStr>::partial_cmp":["bstr::BStr","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstr::<impl std::cmp::PartialOrd<std::vec::Vec<u8>> for bstr::BStr>::partial_cmp":["bstr::BStr","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstr::<impl std::cmp::PartialOrd<str> for bstr::BStr>::partial_cmp":["bstr::BStr","std::marker::Sized","std::option::Option"],"impls::bstr::<impl std::convert::AsMut<[u8]> for bstr::BStr>::as_mut":["bstr::BStr"],"impls::bstr::<impl std::convert::AsMut<bstr::BStr> for [u8]>::as_mut":["bstr::BStr"],"impls::bstr::<impl std::convert::AsRef<[u8]> for bstr::BStr>::as_ref":["bstr::BStr"],"impls::bstr::<impl std::convert::AsRef<bstr::BStr> for [u8]>::as_ref":["bstr::BStr"],"impls::bstr::<impl std::convert::AsRef<bstr::BStr> for str>::as_ref":["bstr::BStr"],"impls::bstr::<impl std::convert::From<&'a [u8]> for &'a bstr::BStr>::from":["bstr::BStr"],"impls::bstr::<impl std::convert::From<&'a bstr::BStr> for std::borrow::Cow<'a, bstr::BStr>>::from":["bstr::BStr","std::borrow::Cow","std::borrow::ToOwned"],"impls::bstr::<impl std::convert::From<&'a str> for &'a bstr::BStr>::from":["bstr::BStr"],"impls::bstr::<impl std::convert::From<std::boxed::Box<[u8]>> for std::boxed::Box<bstr::BStr>>::from":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"impls::bstr::<impl std::convert::From<std::boxed::Box<bstr::BStr>> for std::boxed::Box<[u8]>>::from":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"impls::bstr::<impl std::default::Default for &'a bstr::BStr>::default":["bstr::BStr"],"impls::bstr::<impl std::default::Default for &'a mut bstr::BStr>::default":["bstr::BStr"],"impls::bstr::<impl std::fmt::Debug for bstr::BStr>::fmt":["bstr::BStr","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"impls::bstr::<impl std::fmt::Display for bstr::BStr>::fmt":["bstr::BStr","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"impls::bstr::<impl std::fmt::Display for bstr::BStr>::fmt::write_bstr":["bstr::BStr","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"impls::bstr::<impl std::fmt::Display for bstr::BStr>::fmt::write_pads":["std::fmt::Formatter","std::marker::Sized","std::result::Result"],"impls::bstr::<impl std::ops::DerefMut for bstr::BStr>::deref_mut":["bstr::BStr"],"impls::bstr::<impl std::ops::Index<std::ops::Range<usize>> for bstr::BStr>::index":["bstr::BStr","std::marker::Sized","std::ops::Range"],"impls::bstr::<impl std::ops::Index<std::ops::RangeFrom<usize>> for bstr::BStr>::index":["bstr::BStr","std::marker::Sized","std::ops::RangeFrom"],"impls::bstr::<impl std::ops::Index<std::ops::RangeFull> for bstr::BStr>::index":["bstr::BStr","std::ops::RangeFull"],"impls::bstr::<impl std::ops::Index<std::ops::RangeInclusive<usize>> for bstr::BStr>::index":["bstr::BStr","std::marker::Sized","std::ops::RangeInclusive"],"impls::bstr::<impl std::ops::Index<std::ops::RangeTo<usize>> for bstr::BStr>::index":["bstr::BStr","std::marker::Sized","std::ops::RangeTo"],"impls::bstr::<impl std::ops::Index<std::ops::RangeToInclusive<usize>> for bstr::BStr>::index":["bstr::BStr","std::marker::Sized","std::ops::RangeToInclusive"],"impls::bstr::<impl std::ops::Index<usize> for bstr::BStr>::index":["bstr::BStr"],"impls::bstr::<impl std::ops::IndexMut<std::ops::Range<usize>> for bstr::BStr>::index_mut":["bstr::BStr","std::marker::Sized","std::ops::Range"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeFrom<usize>> for bstr::BStr>::index_mut":["bstr::BStr","std::marker::Sized","std::ops::RangeFrom"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeFull> for bstr::BStr>::index_mut":["bstr::BStr","std::ops::RangeFull"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeInclusive<usize>> for bstr::BStr>::index_mut":["bstr::BStr","std::marker::Sized","std::ops::RangeInclusive"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeTo<usize>> for bstr::BStr>::index_mut":["bstr::BStr","std::marker::Sized","std::ops::RangeTo"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeToInclusive<usize>> for bstr::BStr>::index_mut":["bstr::BStr","std::marker::Sized","std::ops::RangeToInclusive"],"impls::bstr::<impl std::ops::IndexMut<usize> for bstr::BStr>::index_mut":["bstr::BStr"],"impls::bstring::<impl lazy_static::__Deref for bstring::BString>::deref":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::borrow::Borrow<bstr::BStr> for bstring::BString>::borrow":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::borrow::ToOwned for bstr::BStr>::to_owned":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::Ord for bstring::BString>::cmp":["bstring::BString","std::alloc::Allocator","std::cmp::Ordering","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq for bstring::BString>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<&'a [u8]> for bstring::BString>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<&'a bstr::BStr> for bstring::BString>::eq":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<&'a str> for bstring::BString>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<[u8]> for bstring::BString>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<bstr::BStr> for bstring::BString>::eq":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for &'a [u8]>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for &'a bstr::BStr>::eq":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for &'a str>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for [u8]>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for bstr::BStr>::eq":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for std::string::String>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for std::vec::Vec<u8>>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for str>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<std::string::String> for bstring::BString>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<std::vec::Vec<u8>> for bstring::BString>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialEq<str> for bstring::BString>::eq":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd for bstring::BString>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<&'a [u8]> for bstring::BString>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<&'a bstr::BStr> for bstring::BString>::partial_cmp":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<&'a str> for bstring::BString>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<[u8]> for bstring::BString>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<bstr::BStr> for bstring::BString>::partial_cmp":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for &'a [u8]>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for &'a bstr::BStr>::partial_cmp":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for &'a str>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for [u8]>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for bstr::BStr>::partial_cmp":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for std::string::String>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for std::vec::Vec<u8>>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for str>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<std::string::String> for bstring::BString>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<std::vec::Vec<u8>> for bstring::BString>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::cmp::PartialOrd<str> for bstring::BString>::partial_cmp":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"impls::bstring::<impl std::convert::AsMut<[u8]> for bstring::BString>::as_mut":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::convert::AsMut<bstr::BStr> for bstring::BString>::as_mut":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::convert::AsRef<[u8]> for bstring::BString>::as_ref":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::convert::AsRef<bstr::BStr> for bstring::BString>::as_ref":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::convert::From<&'a [u8]> for bstring::BString>::from":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::convert::From<&'a bstr::BStr> for bstring::BString>::from":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::convert::From<&'a str> for bstring::BString>::from":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::convert::From<bstring::BString> for std::borrow::Cow<'a, bstr::BStr>>::from":["bstr::BStr","bstring::BString","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::convert::From<bstring::BString> for std::vec::Vec<u8>>::from":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::convert::From<std::string::String> for bstring::BString>::from":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"impls::bstring::<impl std::convert::From<std::vec::Vec<u8>> for bstring::BString>::from":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::default::Default for bstring::BString>::default":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::fmt::Debug for bstring::BString>::fmt":["bstring::BString","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"impls::bstring::<impl std::fmt::Display for bstring::BString>::fmt":["bstring::BString","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"impls::bstring::<impl std::iter::FromIterator<&'a [u8]> for bstring::BString>::from_iter":["bstring::BString","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::iter::FromIterator<&'a bstr::BStr> for bstring::BString>::from_iter":["bstring::BString","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::iter::FromIterator<&'a str> for bstring::BString>::from_iter":["bstring::BString","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::iter::FromIterator<bstring::BString> for bstring::BString>::from_iter":["bstring::BString","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::iter::FromIterator<char> for bstring::BString>::from_iter":["bstring::BString","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::iter::FromIterator<u8> for bstring::BString>::from_iter":["bstring::BString","std::alloc::Allocator","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"impls::bstring::<impl std::ops::DerefMut for bstring::BString>::deref_mut":["bstring::BString","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"io::BufReadExt::byte_lines":["io::ByteLines","std::marker::Sized"],"io::BufReadExt::byte_records":["io::ByteRecords","std::marker::Sized"],"io::BufReadExt::for_byte_line":["std::marker::Sized","std::ops::FnMut","std::result::Result"],"io::BufReadExt::for_byte_line_with_terminator":["std::marker::Sized","std::ops::FnMut","std::result::Result"],"io::BufReadExt::for_byte_record":["std::marker::Sized","std::ops::FnMut","std::result::Result"],"io::BufReadExt::for_byte_record_with_terminator":["std::marker::Sized","std::ops::FnMut","std::result::Result"],"io::ByteLines":["io::ByteLines","std::marker::Sized"],"io::ByteRecords":["io::ByteRecords","std::marker::Sized"],"io::trim_line":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"io::trim_line_slice":[],"io::trim_record":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"io::trim_record_slice":[],"search::prefilter::Freqy":["search::prefilter::Freqy"],"search::prefilter::Freqy::find_candidate":["search::prefilter::Freqy","search::prefilter::PrefilterState","std::marker::Sized","std::option::Option"],"search::prefilter::Freqy::forward":["search::prefilter::Freqy"],"search::prefilter::Freqy::inert":["search::prefilter::Freqy"],"search::prefilter::Freqy::prefilter_state":["search::prefilter::Freqy","search::prefilter::PrefilterState"],"search::prefilter::Freqy::rank":[],"search::prefilter::Freqy::reverse":["search::prefilter::Freqy"],"search::prefilter::Freqy::rfind_candidate":["search::prefilter::Freqy","search::prefilter::PrefilterState","std::marker::Sized","std::option::Option"],"search::prefilter::PrefilterState":["search::prefilter::PrefilterState"],"search::prefilter::PrefilterState::inert":["search::prefilter::PrefilterState"],"search::prefilter::PrefilterState::is_effective":["search::prefilter::PrefilterState"],"search::prefilter::PrefilterState::new":["search::prefilter::PrefilterState"],"search::prefilter::PrefilterState::update":["search::prefilter::PrefilterState"],"search::twoway::Shift":["search::twoway::Shift"],"search::twoway::Shift::forward":["search::twoway::Shift"],"search::twoway::Shift::reverse":["search::twoway::Shift"],"search::twoway::Suffix":["search::twoway::Suffix"],"search::twoway::Suffix::forward":["search::twoway::Suffix","search::twoway::SuffixKind"],"search::twoway::Suffix::reverse":["search::twoway::Suffix","search::twoway::SuffixKind"],"search::twoway::SuffixKind":["search::twoway::SuffixKind"],"search::twoway::SuffixKind::cmp":["search::twoway::SuffixKind","search::twoway::SuffixOrdering"],"search::twoway::SuffixOrdering":["search::twoway::SuffixOrdering"],"search::twoway::TwoWay":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"search::twoway::TwoWay::<'b>::find":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"search::twoway::TwoWay::<'b>::find_large":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"search::twoway::TwoWay::<'b>::find_large_imp":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"search::twoway::TwoWay::<'b>::find_small":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"search::twoway::TwoWay::<'b>::find_small_imp":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"search::twoway::TwoWay::<'b>::find_with":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"search::twoway::TwoWay::<'b>::forward":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"search::twoway::TwoWay::<'b>::into_owned":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"search::twoway::TwoWay::<'b>::needle":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"search::twoway::TwoWay::<'b>::prefilter_state":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"search::twoway::TwoWay::<'b>::reverse":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned"],"search::twoway::TwoWay::<'b>::rfind":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"search::twoway::TwoWay::<'b>::rfind_large":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"search::twoway::TwoWay::<'b>::rfind_large_imp":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"search::twoway::TwoWay::<'b>::rfind_small":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"search::twoway::TwoWay::<'b>::rfind_small_imp":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"search::twoway::TwoWay::<'b>::rfind_with":["bstr::BStr","cow::CowBytes","cow::Imp","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::TwoWay","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD":["unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD"],"unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV":["unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV"],"unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV":["unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV"],"unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD":["unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD"],"unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD":["unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD"],"unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD":["unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD"],"unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV":["unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV"],"unicode::fsm::word_break_fwd::WORD_BREAK_FWD":["unicode::fsm::word_break_fwd::WORD_BREAK_FWD"],"unicode::grapheme::GraphemeIndices":["unicode::grapheme::GraphemeIndices"],"unicode::grapheme::GraphemeIndices::<'a>::as_bytes":["unicode::grapheme::GraphemeIndices"],"unicode::grapheme::GraphemeIndices::<'a>::new":["unicode::grapheme::GraphemeIndices"],"unicode::grapheme::Graphemes":["unicode::grapheme::Graphemes"],"unicode::grapheme::Graphemes::<'a>::as_bytes":["unicode::grapheme::Graphemes"],"unicode::grapheme::Graphemes::<'a>::new":["unicode::grapheme::Graphemes"],"unicode::grapheme::adjust_rev_for_regional_indicator":[],"unicode::grapheme::decode_grapheme":[],"unicode::grapheme::decode_last_grapheme":[],"unicode::sentence::SentenceIndices":["unicode::sentence::SentenceIndices"],"unicode::sentence::SentenceIndices::<'a>::as_bytes":["unicode::sentence::SentenceIndices"],"unicode::sentence::SentenceIndices::<'a>::new":["unicode::sentence::SentenceIndices"],"unicode::sentence::Sentences":["unicode::sentence::Sentences"],"unicode::sentence::Sentences::<'a>::as_bytes":["unicode::sentence::Sentences"],"unicode::sentence::Sentences::<'a>::new":["unicode::sentence::Sentences"],"unicode::sentence::decode_sentence":[],"unicode::whitespace::whitespace_len_fwd":[],"unicode::whitespace::whitespace_len_rev":[],"unicode::word::WordIndices":["unicode::word::WordIndices","unicode::word::WordsWithBreakIndices"],"unicode::word::WordIndices::<'a>::as_bytes":["unicode::word::WordIndices","unicode::word::WordsWithBreakIndices"],"unicode::word::WordIndices::<'a>::new":["unicode::word::WordIndices","unicode::word::WordsWithBreakIndices"],"unicode::word::Words":["unicode::word::Words","unicode::word::WordsWithBreaks"],"unicode::word::Words::<'a>::as_bytes":["unicode::word::Words","unicode::word::WordsWithBreaks"],"unicode::word::Words::<'a>::new":["unicode::word::Words","unicode::word::WordsWithBreaks"],"unicode::word::WordsWithBreakIndices":["unicode::word::WordsWithBreakIndices"],"unicode::word::WordsWithBreakIndices::<'a>::as_bytes":["unicode::word::WordsWithBreakIndices"],"unicode::word::WordsWithBreakIndices::<'a>::new":["unicode::word::WordsWithBreakIndices"],"unicode::word::WordsWithBreaks":["unicode::word::WordsWithBreaks"],"unicode::word::WordsWithBreaks::<'a>::as_bytes":["unicode::word::WordsWithBreaks"],"unicode::word::WordsWithBreaks::<'a>::new":["unicode::word::WordsWithBreaks"],"unicode::word::decode_word":[],"utf8::CharIndices":["utf8::CharIndices"],"utf8::CharIndices::<'a>::as_bytes":["utf8::CharIndices"],"utf8::CharIndices::<'a>::new":["utf8::CharIndices"],"utf8::Chars":["utf8::Chars"],"utf8::Chars::<'a>::as_bytes":["utf8::Chars"],"utf8::Chars::<'a>::new":["utf8::Chars"],"utf8::Utf8Chunk":["bstr::BStr","utf8::Utf8Chunk"],"utf8::Utf8Chunk::<'a>::incomplete":["bstr::BStr","utf8::Utf8Chunk"],"utf8::Utf8Chunk::<'a>::invalid":["bstr::BStr","utf8::Utf8Chunk"],"utf8::Utf8Chunk::<'a>::valid":["bstr::BStr","utf8::Utf8Chunk"],"utf8::Utf8Chunks":["utf8::Utf8Chunks"],"utf8::Utf8Error":["std::marker::Sized","std::option::Option","utf8::Utf8Error"],"utf8::Utf8Error::error_len":["std::marker::Sized","std::option::Option","utf8::Utf8Error"],"utf8::Utf8Error::valid_up_to":["std::marker::Sized","std::option::Option","utf8::Utf8Error"],"utf8::decode":["bstr::BStr","std::convert::AsRef","std::marker::Sized","std::option::Option"],"utf8::decode_last":["bstr::BStr","std::convert::AsRef","std::marker::Sized","std::option::Option"],"utf8::decode_last_lossy":["bstr::BStr","std::convert::AsRef","std::marker::Sized"],"utf8::decode_lossy":["bstr::BStr","std::convert::AsRef","std::marker::Sized"],"utf8::decode_step":[],"utf8::is_leading_or_invalid_utf8_byte":[],"utf8::validate":["std::marker::Sized","std::result::Result"],"utf8::validate::fast":["std::marker::Sized","std::result::Result"],"utf8::validate::find_valid_up_to":["std::marker::Sized","std::option::Option","utf8::Utf8Error"],"utf8::validate::slow":["std::marker::Sized","std::result::Result"],"utf8::validate::step":[]},"glob_path_import":{},"self_to_fn":{"<B as io::BufReadExt>::B":["impl<B: io::BufRead> BufReadExt for B {}"],"bstr::BStr":["Hash","impl AsMut<[u8]> for BStr {\n        #[inline]\n        fn as_mut(&mut self) -> &mut [u8] {\n            &mut self.bytes\n        }\n    }","impl AsRef<[u8]> for BStr {\n        #[inline]\n        fn as_ref(&self) -> &[u8] {\n            self.as_bytes()\n        }\n    }","impl BStr {\n    #[inline]\n    pub(crate) fn new<B: ?Sized + AsRef<[u8]>>(bytes: &B) -> &BStr {\n        BStr::from_bytes(bytes.as_ref())\n    }\n\n    #[inline]\n    pub(crate) fn new_mut<B: ?Sized + AsMut<[u8]>>(\n        bytes: &mut B,\n    ) -> &mut BStr {\n        BStr::from_bytes_mut(bytes.as_mut())\n    }\n\n    #[inline]\n    pub(crate) fn from_bytes(slice: &[u8]) -> &BStr {\n        unsafe { mem::transmute(slice) }\n    }\n\n    #[inline]\n    pub(crate) fn from_bytes_mut(slice: &mut [u8]) -> &mut BStr {\n        unsafe { mem::transmute(slice) }\n    }\n\n    #[inline]\n    #[cfg(feature = \"std\")]\n    pub(crate) fn from_boxed_bytes(slice: Box<[u8]>) -> Box<BStr> {\n        unsafe { Box::from_raw(Box::into_raw(slice) as _) }\n    }\n\n    #[inline]\n    #[cfg(feature = \"std\")]\n    pub(crate) fn into_boxed_bytes(slice: Box<BStr>) -> Box<[u8]> {\n        unsafe { Box::from_raw(Box::into_raw(slice) as _) }\n    }\n\n    #[inline]\n    pub(crate) fn as_bytes(&self) -> &[u8] {\n        &self.bytes\n    }\n}","impl Eq for BStr {}","impl Ord for BStr {\n        #[inline]\n        fn cmp(&self, other: &BStr) -> Ordering {\n            self.partial_cmp(other).unwrap()\n        }\n    }","impl PartialEq<BStr> for BStr {\n        #[inline]\n        fn eq(&self, other: &BStr) -> bool {\n            self.as_bytes() == other.as_bytes()\n        }\n    }","impl PartialOrd for BStr {\n        #[inline]\n        fn partial_cmp(&self, other: &BStr) -> Option<Ordering> {\n            PartialOrd::partial_cmp(self.as_bytes(), other.as_bytes())\n        }\n    }","impl ToOwned for BStr {\n        type Owned = BString;\n\n        #[inline]\n        fn to_owned(&self) -> BString {\n            BString::from(self)\n        }\n    }","impl fmt::Debug for BStr {\n        #[inline]\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            write!(f, \"\\\"\")?;\n            for (s, e, ch) in self.char_indices() {\n                match ch {\n                    '\\0' => write!(f, \"\\\\0\")?,\n                    '\\u{FFFD}' => {\n                        let bytes = self[s..e].as_bytes();\n                        if bytes == b\"\\xEF\\xBF\\xBD\" {\n                            write!(f, \"{}\", ch.escape_debug())?;\n                        } else {\n                            for &b in self[s..e].as_bytes() {\n                                write!(f, r\"\\x{:02X}\", b)?;\n                            }\n                        }\n                    }\n                    // ASCII control characters except \\0, \\n, \\r, \\t\n                    '\\x01'..='\\x08'\n                    | '\\x0b'\n                    | '\\x0c'\n                    | '\\x0e'..='\\x19'\n                    | '\\x7f' => {\n                        write!(f, \"\\\\x{:02x}\", ch as u32)?;\n                    }\n                    '\\n' | '\\r' | '\\t' | _ => {\n                        write!(f, \"{}\", ch.escape_debug())?;\n                    }\n                }\n            }\n            write!(f, \"\\\"\")?;\n            Ok(())\n        }\n    }","impl fmt::Display for BStr {\n        #[inline]\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            /// Write the given bstr (lossily) to the given formatter.\n            fn write_bstr(\n                f: &mut fmt::Formatter,\n                bstr: &BStr,\n            ) -> Result<(), fmt::Error> {\n                for chunk in bstr.utf8_chunks() {\n                    f.write_str(chunk.valid())?;\n                    if !chunk.invalid().is_empty() {\n                        f.write_str(\"\\u{FFFD}\")?;\n                    }\n                }\n                Ok(())\n            }\n\n            /// Write 'num' fill characters to the given formatter.\n            fn write_pads(f: &mut fmt::Formatter, num: usize) -> fmt::Result {\n                let fill = f.fill();\n                for _ in 0..num {\n                    f.write_fmt(format_args!(\"{}\", fill))?;\n                }\n                Ok(())\n            }\n\n            if let Some(align) = f.align() {\n                let width = f.width().unwrap_or(0);\n                let nchars = self.chars().count();\n                let remaining_pads = width.saturating_sub(nchars);\n                match align {\n                    fmt::Alignment::Left => {\n                        write_bstr(f, self)?;\n                        write_pads(f, remaining_pads)?;\n                    }\n                    fmt::Alignment::Right => {\n                        write_pads(f, remaining_pads)?;\n                        write_bstr(f, self)?;\n                    }\n                    fmt::Alignment::Center => {\n                        let half = remaining_pads / 2;\n                        let second_half = if remaining_pads % 2 == 0 {\n                            half\n                        } else {\n                            half + 1\n                        };\n                        write_pads(f, half)?;\n                        write_bstr(f, self)?;\n                        write_pads(f, second_half)?;\n                    }\n                }\n                Ok(())\n            } else {\n                write_bstr(f, self)?;\n                Ok(())\n            }\n        }\n    }","impl ops::Deref for BStr {\n        type Target = [u8];\n\n        #[inline]\n        fn deref(&self) -> &[u8] {\n            &self.bytes\n        }\n    }","impl ops::DerefMut for BStr {\n        #[inline]\n        fn deref_mut(&mut self) -> &mut [u8] {\n            &mut self.bytes\n        }\n    }","impl ops::Index<ops::Range<usize>> for BStr {\n        type Output = BStr;\n\n        #[inline]\n        fn index(&self, r: ops::Range<usize>) -> &BStr {\n            BStr::new(&self.as_bytes()[r.start..r.end])\n        }\n    }","impl ops::Index<ops::RangeFrom<usize>> for BStr {\n        type Output = BStr;\n\n        #[inline]\n        fn index(&self, r: ops::RangeFrom<usize>) -> &BStr {\n            BStr::new(&self.as_bytes()[r.start..])\n        }\n    }","impl ops::Index<ops::RangeFull> for BStr {\n        type Output = BStr;\n\n        #[inline]\n        fn index(&self, _: ops::RangeFull) -> &BStr {\n            self\n        }\n    }","impl ops::Index<ops::RangeInclusive<usize>> for BStr {\n        type Output = BStr;\n\n        #[inline]\n        fn index(&self, r: ops::RangeInclusive<usize>) -> &BStr {\n            BStr::new(&self.as_bytes()[*r.start()..=*r.end()])\n        }\n    }","impl ops::Index<ops::RangeTo<usize>> for BStr {\n        type Output = BStr;\n\n        #[inline]\n        fn index(&self, r: ops::RangeTo<usize>) -> &BStr {\n            BStr::new(&self.as_bytes()[..r.end])\n        }\n    }","impl ops::Index<ops::RangeToInclusive<usize>> for BStr {\n        type Output = BStr;\n\n        #[inline]\n        fn index(&self, r: ops::RangeToInclusive<usize>) -> &BStr {\n            BStr::new(&self.as_bytes()[..=r.end])\n        }\n    }","impl ops::Index<usize> for BStr {\n        type Output = u8;\n\n        #[inline]\n        fn index(&self, idx: usize) -> &u8 {\n            &self.as_bytes()[idx]\n        }\n    }","impl ops::IndexMut<ops::Range<usize>> for BStr {\n        #[inline]\n        fn index_mut(&mut self, r: ops::Range<usize>) -> &mut BStr {\n            BStr::from_bytes_mut(&mut self.bytes[r.start..r.end])\n        }\n    }","impl ops::IndexMut<ops::RangeFrom<usize>> for BStr {\n        #[inline]\n        fn index_mut(&mut self, r: ops::RangeFrom<usize>) -> &mut BStr {\n            BStr::from_bytes_mut(&mut self.bytes[r.start..])\n        }\n    }","impl ops::IndexMut<ops::RangeFull> for BStr {\n        #[inline]\n        fn index_mut(&mut self, _: ops::RangeFull) -> &mut BStr {\n            self\n        }\n    }","impl ops::IndexMut<ops::RangeInclusive<usize>> for BStr {\n        #[inline]\n        fn index_mut(&mut self, r: ops::RangeInclusive<usize>) -> &mut BStr {\n            BStr::from_bytes_mut(&mut self.bytes[*r.start()..=*r.end()])\n        }\n    }","impl ops::IndexMut<ops::RangeTo<usize>> for BStr {\n        #[inline]\n        fn index_mut(&mut self, r: ops::RangeTo<usize>) -> &mut BStr {\n            BStr::from_bytes_mut(&mut self.bytes[..r.end])\n        }\n    }","impl ops::IndexMut<ops::RangeToInclusive<usize>> for BStr {\n        #[inline]\n        fn index_mut(&mut self, r: ops::RangeToInclusive<usize>) -> &mut BStr {\n            BStr::from_bytes_mut(&mut self.bytes[..=r.end])\n        }\n    }","impl ops::IndexMut<usize> for BStr {\n        #[inline]\n        fn index_mut(&mut self, idx: usize) -> &mut u8 {\n            &mut self.bytes[idx]\n        }\n    }","impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool {\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }\n        }","impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool {\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }\n        }","impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$lhs) -> Option<Ordering> {\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }\n        }","impl<'a, 'b> PartialOrd<$rhs> for $lhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$rhs) -> Option<Ordering> {\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }\n        }"],"bstring::BString":["Clone","Hash","impl AsMut<BStr> for BString {\n        #[inline]\n        fn as_mut(&mut self) -> &mut BStr {\n            self.as_mut_bstr()\n        }\n    }","impl AsMut<[u8]> for BString {\n        #[inline]\n        fn as_mut(&mut self) -> &mut [u8] {\n            &mut self.bytes\n        }\n    }","impl AsRef<BStr> for BString {\n        #[inline]\n        fn as_ref(&self) -> &BStr {\n            self.as_bstr()\n        }\n    }","impl AsRef<[u8]> for BString {\n        #[inline]\n        fn as_ref(&self) -> &[u8] {\n            &self.bytes\n        }\n    }","impl BString {\n    #[inline]\n    pub(crate) fn as_bytes(&self) -> &[u8] {\n        &self.bytes\n    }\n\n    #[inline]\n    pub(crate) fn as_bstr(&self) -> &BStr {\n        BStr::new(&self.bytes)\n    }\n\n    #[inline]\n    pub(crate) fn as_mut_bstr(&mut self) -> &mut BStr {\n        BStr::new_mut(&mut self.bytes)\n    }\n}","impl Borrow<BStr> for BString {\n        #[inline]\n        fn borrow(&self) -> &BStr {\n            self.as_bstr()\n        }\n    }","impl Default for BString {\n        fn default() -> BString {\n            BString::from(vec![])\n        }\n    }","impl Eq for BString {}","impl From<String> for BString {\n        #[inline]\n        fn from(s: String) -> BString {\n            BString::from(s.into_bytes())\n        }\n    }","impl From<Vec<u8>> for BString {\n        #[inline]\n        fn from(s: Vec<u8>) -> BString {\n            BString { bytes: s }\n        }\n    }","impl FromIterator<BString> for BString {\n        #[inline]\n        fn from_iter<T: IntoIterator<Item = BString>>(iter: T) -> BString {\n            let mut buf = vec![];\n            for b in iter {\n                buf.push_str(b);\n            }\n            BString::from(buf)\n        }\n    }","impl FromIterator<char> for BString {\n        #[inline]\n        fn from_iter<T: IntoIterator<Item = char>>(iter: T) -> BString {\n            BString::from(iter.into_iter().collect::<String>())\n        }\n    }","impl FromIterator<u8> for BString {\n        #[inline]\n        fn from_iter<T: IntoIterator<Item = u8>>(iter: T) -> BString {\n            BString::from(iter.into_iter().collect::<Vec<u8>>())\n        }\n    }","impl Ord for BString {\n        #[inline]\n        fn cmp(&self, other: &BString) -> Ordering {\n            self.partial_cmp(other).unwrap()\n        }\n    }","impl PartialEq for BString {\n        #[inline]\n        fn eq(&self, other: &BString) -> bool {\n            &self[..] == &other[..]\n        }\n    }","impl PartialOrd for BString {\n        #[inline]\n        fn partial_cmp(&self, other: &BString) -> Option<Ordering> {\n            PartialOrd::partial_cmp(&self.bytes, &other.bytes)\n        }\n    }","impl fmt::Debug for BString {\n        #[inline]\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            fmt::Debug::fmt(self.as_bstr(), f)\n        }\n    }","impl fmt::Display for BString {\n        #[inline]\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            fmt::Display::fmt(self.as_bstr(), f)\n        }\n    }","impl ops::Deref for BString {\n        type Target = Vec<u8>;\n\n        #[inline]\n        fn deref(&self) -> &Vec<u8> {\n            &self.bytes\n        }\n    }","impl ops::DerefMut for BString {\n        #[inline]\n        fn deref_mut(&mut self) -> &mut Vec<u8> {\n            &mut self.bytes\n        }\n    }","impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool {\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }\n        }","impl<'a, 'b> PartialOrd<$rhs> for $lhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$rhs) -> Option<Ordering> {\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }\n        }","impl<'a> From<&'a BStr> for BString {\n        #[inline]\n        fn from(s: &'a BStr) -> BString {\n            BString::from(s.bytes.to_vec())\n        }\n    }","impl<'a> From<&'a [u8]> for BString {\n        #[inline]\n        fn from(s: &'a [u8]) -> BString {\n            BString::from(s.to_vec())\n        }\n    }","impl<'a> From<&'a str> for BString {\n        #[inline]\n        fn from(s: &'a str) -> BString {\n            BString::from(s.as_bytes().to_vec())\n        }\n    }","impl<'a> FromIterator<&'a BStr> for BString {\n        #[inline]\n        fn from_iter<T: IntoIterator<Item = &'a BStr>>(iter: T) -> BString {\n            let mut buf = vec![];\n            for b in iter {\n                buf.push_str(b);\n            }\n            BString::from(buf)\n        }\n    }","impl<'a> FromIterator<&'a [u8]> for BString {\n        #[inline]\n        fn from_iter<T: IntoIterator<Item = &'a [u8]>>(iter: T) -> BString {\n            let mut buf = vec![];\n            for b in iter {\n                buf.push_str(b);\n            }\n            BString::from(buf)\n        }\n    }","impl<'a> FromIterator<&'a str> for BString {\n        #[inline]\n        fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> BString {\n            let mut buf = vec![];\n            for b in iter {\n                buf.push_str(b);\n            }\n            BString::from(buf)\n        }\n    }"],"cow::CowBytes":["Clone","Debug","impl<'a> CowBytes<'a> {\n    /// Create a new borrowed CowBytes.\n    pub fn new<B: ?Sized + AsRef<[u8]>>(bytes: &'a B) -> CowBytes<'a> {\n        CowBytes(Imp::new(bytes.as_ref()))\n    }\n\n    /// Create a new owned CowBytes.\n    #[cfg(feature = \"std\")]\n    pub fn new_owned(bytes: Vec<u8>) -> CowBytes<'static> {\n        CowBytes(Imp(Cow::Owned(bytes)))\n    }\n\n    /// Return a borrowed byte string, regardless of whether this is an owned\n    /// or borrowed byte string internally.\n    pub fn as_slice(&self) -> &[u8] {\n        self.0.as_slice()\n    }\n\n    /// Return an owned version of this copy-on-write byte string.\n    ///\n    /// If this is already an owned byte string internally, then this is a\n    /// no-op. Otherwise, the internal byte string is copied.\n    #[cfg(feature = \"std\")]\n    pub fn into_owned(self) -> CowBytes<'static> {\n        match (self.0).0 {\n            Cow::Borrowed(b) => CowBytes::new_owned(b.to_vec()),\n            Cow::Owned(b) => CowBytes::new_owned(b),\n        }\n    }\n}","impl<'a> ops::Deref for CowBytes<'a> {\n    type Target = [u8];\n\n    fn deref(&self) -> &[u8] {\n        self.as_slice()\n    }\n}"],"cow::Imp":["Clone","Debug","impl<'a> Imp<'a> {\n    #[cfg(feature = \"std\")]\n    pub fn new(bytes: &'a [u8]) -> Imp<'a> {\n        Imp(Cow::Borrowed(bytes))\n    }\n\n    #[cfg(not(feature = \"std\"))]\n    pub fn new(bytes: &'a [u8]) -> Imp<'a> {\n        Imp(bytes)\n    }\n\n    #[cfg(feature = \"std\")]\n    pub fn as_slice(&self) -> &[u8] {\n        match self.0 {\n            Cow::Owned(ref x) => x,\n            Cow::Borrowed(x) => x,\n        }\n    }\n\n    #[cfg(not(feature = \"std\"))]\n    pub fn as_slice(&self) -> &[u8] {\n        self.0\n    }\n}"],"ext_slice::Bytes":["Clone","Debug","impl<'a> Bytes<'a> {\n    /// Views the remaining underlying data as a subslice of the original data.\n    /// This has the same lifetime as the original slice,\n    /// and so the iterator can continue to be used while this exists.\n    #[inline]\n    pub fn as_slice(&self) -> &'a [u8] {\n        self.it.as_slice()\n    }\n}","impl<'a> DoubleEndedIterator for Bytes<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<u8> {\n        self.it.next_back().map(|&b| b)\n    }\n}","impl<'a> ExactSizeIterator for Bytes<'a> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.it.len()\n    }\n}","impl<'a> Iterator for Bytes<'a> {\n    type Item = u8;\n\n    #[inline]\n    fn next(&mut self) -> Option<u8> {\n        self.it.next().map(|&b| b)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n}","impl<'a> iter::FusedIterator for Bytes<'a> {}"],"ext_slice::Fields":["Debug","impl<'a> Fields<'a> {\n    fn new(bytes: &'a [u8]) -> Fields<'a> {\n        Fields { it: bytes.fields_with(|ch| ch.is_whitespace()) }\n    }\n}","impl<'a> Iterator for Fields<'a> {\n    type Item = &'a [u8];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [u8]> {\n        self.it.next()\n    }\n}"],"ext_slice::FieldsWith":["Debug","impl<'a, F: FnMut(char) -> bool> FieldsWith<'a, F> {\n    fn new(bytes: &'a [u8], f: F) -> FieldsWith<'a, F> {\n        FieldsWith { f, bytes, chars: bytes.char_indices() }\n    }\n}","impl<'a, F: FnMut(char) -> bool> Iterator for FieldsWith<'a, F> {\n    type Item = &'a [u8];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [u8]> {\n        let (start, mut end);\n        loop {\n            match self.chars.next() {\n                None => return None,\n                Some((s, e, ch)) => {\n                    if !(self.f)(ch) {\n                        start = s;\n                        end = e;\n                        break;\n                    }\n                }\n            }\n        }\n        while let Some((_, e, ch)) = self.chars.next() {\n            if (self.f)(ch) {\n                break;\n            }\n            end = e;\n        }\n        Some(&self.bytes[start..end])\n    }\n}"],"ext_slice::Find":["Debug","impl<'a> Find<'a> {\n    fn new(haystack: &'a [u8], needle: &'a [u8]) -> Find<'a> {\n        let searcher = TwoWay::forward(needle);\n        let prestate = searcher.prefilter_state();\n        Find { haystack, prestate, searcher, pos: 0 }\n    }\n}","impl<'a> Iterator for Find<'a> {\n    type Item = usize;\n\n    #[inline]\n    fn next(&mut self) -> Option<usize> {\n        if self.pos > self.haystack.len() {\n            return None;\n        }\n        let result = self\n            .searcher\n            .find_with(&mut self.prestate, &self.haystack[self.pos..]);\n        match result {\n            None => None,\n            Some(i) => {\n                let pos = self.pos + i;\n                self.pos = pos + cmp::max(1, self.searcher.needle().len());\n                Some(pos)\n            }\n        }\n    }\n}"],"ext_slice::FindReverse":["Debug","impl<'a> FindReverse<'a> {\n    fn new(haystack: &'a [u8], needle: &'a [u8]) -> FindReverse<'a> {\n        let searcher = TwoWay::reverse(needle);\n        let prestate = searcher.prefilter_state();\n        let pos = Some(haystack.len());\n        FindReverse { haystack, prestate, searcher, pos }\n    }\n\n    fn haystack(&self) -> &'a [u8] {\n        self.haystack\n    }\n\n    fn needle(&self) -> &[u8] {\n        self.searcher.needle()\n    }\n}","impl<'a> Iterator for FindReverse<'a> {\n    type Item = usize;\n\n    #[inline]\n    fn next(&mut self) -> Option<usize> {\n        let pos = match self.pos {\n            None => return None,\n            Some(pos) => pos,\n        };\n        let result = self\n            .searcher\n            .rfind_with(&mut self.prestate, &self.haystack[..pos]);\n        match result {\n            None => None,\n            Some(i) => {\n                if pos == i {\n                    self.pos = pos.checked_sub(1);\n                } else {\n                    self.pos = Some(i);\n                }\n                Some(i)\n            }\n        }\n    }\n}"],"ext_slice::Finder":["Clone","Debug","impl<'a> Finder<'a> {\n    /// Create a new finder for the given needle.\n    #[inline]\n    pub fn new<B: ?Sized + AsRef<[u8]>>(needle: &'a B) -> Finder<'a> {\n        Finder { searcher: TwoWay::forward(needle.as_ref()) }\n    }\n\n    /// Convert this finder into its owned variant, such that it no longer\n    /// borrows the needle.\n    ///\n    /// If this is already an owned finder, then this is a no-op. Otherwise,\n    /// this copies the needle.\n    ///\n    /// This is only available when the `std` feature is enabled.\n    #[cfg(feature = \"std\")]\n    #[inline]\n    pub fn into_owned(self) -> Finder<'static> {\n        Finder { searcher: self.searcher.into_owned() }\n    }\n\n    /// Returns the needle that this finder searches for.\n    ///\n    /// Note that the lifetime of the needle returned is tied to the lifetime\n    /// of the finder, and may be shorter than the `'a` lifetime. Namely, a\n    /// finder's needle can be either borrowed or owned, so the lifetime of the\n    /// needle returned must necessarily be the shorter of the two.\n    #[inline]\n    pub fn needle(&self) -> &[u8] {\n        self.searcher.needle()\n    }\n\n    /// Returns the index of the first occurrence of this needle in the given\n    /// haystack.\n    ///\n    /// The haystack may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n    ///\n    /// # Complexity\n    ///\n    /// This routine is guaranteed to have worst case linear time complexity\n    /// with respect to both the needle and the haystack. That is, this runs\n    /// in `O(needle.len() + haystack.len())` time.\n    ///\n    /// This routine is also guaranteed to have worst case constant space\n    /// complexity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::Finder;\n    ///\n    /// let haystack = \"foo bar baz\";\n    /// assert_eq!(Some(0), Finder::new(\"foo\").find(haystack));\n    /// assert_eq!(Some(4), Finder::new(\"bar\").find(haystack));\n    /// assert_eq!(None, Finder::new(\"quux\").find(haystack));\n    /// ```\n    #[inline]\n    pub fn find<B: AsRef<[u8]>>(&self, haystack: B) -> Option<usize> {\n        self.searcher.find(haystack.as_ref())\n    }\n}"],"ext_slice::FinderReverse":["Clone","Debug","impl<'a> FinderReverse<'a> {\n    /// Create a new reverse finder for the given needle.\n    #[inline]\n    pub fn new<B: ?Sized + AsRef<[u8]>>(needle: &'a B) -> FinderReverse<'a> {\n        FinderReverse { searcher: TwoWay::reverse(needle.as_ref()) }\n    }\n\n    /// Convert this finder into its owned variant, such that it no longer\n    /// borrows the needle.\n    ///\n    /// If this is already an owned finder, then this is a no-op. Otherwise,\n    /// this copies the needle.\n    ///\n    /// This is only available when the `std` feature is enabled.\n    #[cfg(feature = \"std\")]\n    #[inline]\n    pub fn into_owned(self) -> FinderReverse<'static> {\n        FinderReverse { searcher: self.searcher.into_owned() }\n    }\n\n    /// Returns the needle that this finder searches for.\n    ///\n    /// Note that the lifetime of the needle returned is tied to the lifetime\n    /// of this finder, and may be shorter than the `'a` lifetime. Namely,\n    /// a finder's needle can be either borrowed or owned, so the lifetime of\n    /// the needle returned must necessarily be the shorter of the two.\n    #[inline]\n    pub fn needle(&self) -> &[u8] {\n        self.searcher.needle()\n    }\n\n    /// Returns the index of the last occurrence of this needle in the given\n    /// haystack.\n    ///\n    /// The haystack may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n    ///\n    /// # Complexity\n    ///\n    /// This routine is guaranteed to have worst case linear time complexity\n    /// with respect to both the needle and the haystack. That is, this runs\n    /// in `O(needle.len() + haystack.len())` time.\n    ///\n    /// This routine is also guaranteed to have worst case constant space\n    /// complexity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::FinderReverse;\n    ///\n    /// let haystack = \"foo bar baz\";\n    /// assert_eq!(Some(0), FinderReverse::new(\"foo\").rfind(haystack));\n    /// assert_eq!(Some(4), FinderReverse::new(\"bar\").rfind(haystack));\n    /// assert_eq!(None, FinderReverse::new(\"quux\").rfind(haystack));\n    /// ```\n    #[inline]\n    pub fn rfind<B: AsRef<[u8]>>(&self, haystack: B) -> Option<usize> {\n        self.searcher.rfind(haystack.as_ref())\n    }\n}"],"ext_slice::Lines":["impl<'a> Iterator for Lines<'a> {\n    type Item = &'a [u8];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [u8]> {\n        let mut line = self.it.next()?;\n        if line.last_byte() == Some(b'\\n') {\n            line = &line[..line.len() - 1];\n            if line.last_byte() == Some(b'\\r') {\n                line = &line[..line.len() - 1];\n            }\n        }\n        Some(line)\n    }\n}","impl<'a> Lines<'a> {\n    fn new(bytes: &'a [u8]) -> Lines<'a> {\n        Lines { it: LinesWithTerminator::new(bytes) }\n    }\n}"],"ext_slice::LinesWithTerminator":["impl<'a> Iterator for LinesWithTerminator<'a> {\n    type Item = &'a [u8];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [u8]> {\n        match self.bytes.find_byte(b'\\n') {\n            None if self.bytes.is_empty() => None,\n            None => {\n                let line = self.bytes;\n                self.bytes = b\"\";\n                Some(line)\n            }\n            Some(end) => {\n                let line = &self.bytes[..end + 1];\n                self.bytes = &self.bytes[end + 1..];\n                Some(line)\n            }\n        }\n    }\n}","impl<'a> LinesWithTerminator<'a> {\n    fn new(bytes: &'a [u8]) -> LinesWithTerminator<'a> {\n        LinesWithTerminator { bytes }\n    }\n}"],"ext_slice::Split":["Debug","impl<'a> Iterator for Split<'a> {\n    type Item = &'a [u8];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [u8]> {\n        let haystack = self.finder.haystack;\n        match self.finder.next() {\n            Some(start) => {\n                let next = &haystack[self.last..start];\n                self.last = start + self.finder.searcher.needle().len();\n                Some(next)\n            }\n            None => {\n                if self.last >= haystack.len() {\n                    if !self.done {\n                        self.done = true;\n                        Some(b\"\")\n                    } else {\n                        None\n                    }\n                } else {\n                    let s = &haystack[self.last..];\n                    self.last = haystack.len();\n                    self.done = true;\n                    Some(s)\n                }\n            }\n        }\n    }\n}","impl<'a> Split<'a> {\n    fn new(haystack: &'a [u8], splitter: &'a [u8]) -> Split<'a> {\n        let finder = haystack.find_iter(splitter);\n        Split { finder, last: 0, done: false }\n    }\n}"],"ext_slice::SplitN":["Debug","impl<'a> Iterator for SplitN<'a> {\n    type Item = &'a [u8];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [u8]> {\n        self.count += 1;\n        if self.count > self.limit || self.split.done {\n            None\n        } else if self.count == self.limit {\n            Some(&self.split.finder.haystack[self.split.last..])\n        } else {\n            self.split.next()\n        }\n    }\n}","impl<'a> SplitN<'a> {\n    fn new(\n        haystack: &'a [u8],\n        splitter: &'a [u8],\n        limit: usize,\n    ) -> SplitN<'a> {\n        let split = haystack.split_str(splitter);\n        SplitN { split, limit, count: 0 }\n    }\n}"],"ext_slice::SplitNReverse":["Debug","impl<'a> Iterator for SplitNReverse<'a> {\n    type Item = &'a [u8];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [u8]> {\n        self.count += 1;\n        if self.count > self.limit || self.split.done {\n            None\n        } else if self.count == self.limit {\n            Some(&self.split.finder.haystack()[..self.split.last])\n        } else {\n            self.split.next()\n        }\n    }\n}","impl<'a> SplitNReverse<'a> {\n    fn new(\n        haystack: &'a [u8],\n        splitter: &'a [u8],\n        limit: usize,\n    ) -> SplitNReverse<'a> {\n        let split = haystack.rsplit_str(splitter);\n        SplitNReverse { split, limit, count: 0 }\n    }\n}"],"ext_slice::SplitReverse":["Debug","impl<'a> Iterator for SplitReverse<'a> {\n    type Item = &'a [u8];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [u8]> {\n        let haystack = self.finder.haystack();\n        match self.finder.next() {\n            Some(start) => {\n                let nlen = self.finder.needle().len();\n                let next = &haystack[start + nlen..self.last];\n                self.last = start;\n                Some(next)\n            }\n            None => {\n                if self.last == 0 {\n                    if !self.done {\n                        self.done = true;\n                        Some(b\"\")\n                    } else {\n                        None\n                    }\n                } else {\n                    let s = &haystack[..self.last];\n                    self.last = 0;\n                    self.done = true;\n                    Some(s)\n                }\n            }\n        }\n    }\n}","impl<'a> SplitReverse<'a> {\n    fn new(haystack: &'a [u8], splitter: &'a [u8]) -> SplitReverse<'a> {\n        let finder = haystack.rfind_iter(splitter);\n        SplitReverse { finder, last: haystack.len(), done: false }\n    }\n}"],"ext_vec::DrainBytes":["Debug","impl<'a> DoubleEndedIterator for DrainBytes<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<u8> {\n        self.it.next_back()\n    }\n}","impl<'a> ExactSizeIterator for DrainBytes<'a> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.it.len()\n    }\n}","impl<'a> Iterator for DrainBytes<'a> {\n    type Item = u8;\n\n    #[inline]\n    fn next(&mut self) -> Option<u8> {\n        self.it.next()\n    }\n}","impl<'a> iter::FusedIterator for DrainBytes<'a> {}"],"ext_vec::FromUtf8Error":["Debug","Eq","PartialEq","impl FromUtf8Error {\n    /// Return the original bytes as a slice that failed to convert to a\n    /// `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteVec};\n    ///\n    /// let bytes = Vec::from_slice(b\"foo\\xFFbar\");\n    /// let err = bytes.into_string().unwrap_err();\n    ///\n    /// // At no point in this example is an allocation performed.\n    /// assert_eq!(err.as_bytes(), B(b\"foo\\xFFbar\"));\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8] {\n        &self.original\n    }\n\n    /// Consume this error and return the original byte string that failed to\n    /// convert to a `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteVec};\n    ///\n    /// let bytes = Vec::from_slice(b\"foo\\xFFbar\");\n    /// let err = bytes.into_string().unwrap_err();\n    /// let original = err.into_vec();\n    ///\n    /// // At no point in this example is an allocation performed.\n    /// assert_eq!(original, B(b\"foo\\xFFbar\"));\n    /// ```\n    #[inline]\n    pub fn into_vec(self) -> Vec<u8> {\n        self.original\n    }\n\n    /// Return the underlying UTF-8 error that occurred. This error provides\n    /// information on the nature and location of the invalid UTF-8 detected.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteVec};\n    ///\n    /// let bytes = Vec::from_slice(b\"foo\\xFFbar\");\n    /// let err = bytes.into_string().unwrap_err();\n    ///\n    /// assert_eq!(err.utf8_error().valid_up_to(), 3);\n    /// assert_eq!(err.utf8_error().error_len(), Some(1));\n    /// ```\n    #[inline]\n    pub fn utf8_error(&self) -> &Utf8Error {\n        &self.err\n    }\n}","impl error::Error for FromUtf8Error {\n    #[inline]\n    fn description(&self) -> &str {\n        \"invalid UTF-8 vector\"\n    }\n}","impl fmt::Display for FromUtf8Error {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.err)\n    }\n}"],"io::ByteLines":["Debug","impl<B: io::BufRead> Iterator for ByteLines<B> {\n    type Item = io::Result<Vec<u8>>;\n\n    fn next(&mut self) -> Option<io::Result<Vec<u8>>> {\n        let mut bytes = vec![];\n        match self.buf.read_until(b'\\n', &mut bytes) {\n            Err(e) => Some(Err(e)),\n            Ok(0) => None,\n            Ok(_) => {\n                trim_line(&mut bytes);\n                Some(Ok(bytes))\n            }\n        }\n    }\n}"],"io::ByteRecords":["Debug","impl<B: io::BufRead> Iterator for ByteRecords<B> {\n    type Item = io::Result<Vec<u8>>;\n\n    fn next(&mut self) -> Option<io::Result<Vec<u8>>> {\n        let mut bytes = vec![];\n        match self.buf.read_until(self.terminator, &mut bytes) {\n            Err(e) => Some(Err(e)),\n            Ok(0) => None,\n            Ok(_) => {\n                trim_record(&mut bytes, self.terminator);\n                Some(Ok(bytes))\n            }\n        }\n    }\n}"],"search::prefilter::Freqy":["Clone","Debug","impl Freqy {\n    /// The maximum frequency rank permitted. If the rarest byte in the needle\n    /// has a frequency rank above this value, then Freqy is not used.\n    const MAX_RANK: usize = 200;\n\n    /// Return a fresh prefilter state that can be used with this prefilter. A\n    /// prefilter state is used to track the effectiveness of a prefilter for\n    /// speeding up searches. Therefore, the prefilter state should generally\n    /// be reused on subsequent searches (such as in an iterator). For searches\n    /// on a different haystack, then a new prefilter state should be used.\n    pub fn prefilter_state(&self) -> PrefilterState {\n        if self.inert {\n            PrefilterState::inert()\n        } else {\n            PrefilterState::new(self.needle_len)\n        }\n    }\n\n    /// Returns a valid but inert prefilter. This is valid for both the forward\n    /// and reverse direction.\n    ///\n    /// It is never correct to use an inert prefilter. The results of finding\n    /// the next (or previous) candidate are unspecified.\n    fn inert() -> Freqy {\n        Freqy {\n            inert: true,\n            needle_len: 0,\n            rare1: 0,\n            rare1i: 0,\n            rare2: 0,\n            rare2i: 0,\n        }\n    }\n\n    /// Return search info for the given needle in the forward direction.\n    pub fn forward(needle: &[u8]) -> Freqy {\n        if needle.is_empty() {\n            return Freqy::inert();\n        }\n\n        // Find the rarest two bytes. Try to make them distinct (but it's not\n        // required).\n        let (mut rare1, mut rare1i) = (needle[0], 0);\n        let (mut rare2, mut rare2i) = (needle[0], 0);\n        if needle.len() >= 2 {\n            rare2 = needle[1];\n            rare2i = 1;\n        }\n        if Freqy::rank(rare2) < Freqy::rank(rare1) {\n            mem::swap(&mut rare1, &mut rare2);\n            mem::swap(&mut rare1i, &mut rare2i);\n        }\n        for (i, b) in needle.bytes().enumerate().skip(2) {\n            if Freqy::rank(b) < Freqy::rank(rare1) {\n                rare2 = rare1;\n                rare2i = rare1i;\n                rare1 = b;\n                rare1i = i;\n            } else if b != rare1 && Freqy::rank(b) < Freqy::rank(rare2) {\n                rare2 = b;\n                rare2i = i;\n            }\n        }\n        if Freqy::rank(rare1) > Freqy::MAX_RANK {\n            return Freqy::inert();\n        }\n        let needle_len = needle.len();\n        Freqy { inert: false, needle_len, rare1, rare1i, rare2, rare2i }\n    }\n\n    /// Return search info for the given needle in the reverse direction.\n    pub fn reverse(needle: &[u8]) -> Freqy {\n        if needle.is_empty() {\n            return Freqy::inert();\n        }\n\n        // Find the rarest two bytes. Try to make them distinct (but it's not\n        // required). In reverse, the offsets correspond to the number of bytes\n        // from the end of the needle. So `0` is the last byte in the needle.\n        let (mut rare1i, mut rare2i) = (0, 0);\n        if needle.len() >= 2 {\n            rare2i += 1;\n        }\n        let mut rare1 = needle[needle.len() - rare1i - 1];\n        let mut rare2 = needle[needle.len() - rare2i - 1];\n        if Freqy::rank(rare2) < Freqy::rank(rare1) {\n            mem::swap(&mut rare1, &mut rare2);\n            mem::swap(&mut rare1i, &mut rare2i);\n        }\n        for (i, b) in needle.bytes().rev().enumerate().skip(2) {\n            if Freqy::rank(b) < Freqy::rank(rare1) {\n                rare2 = rare1;\n                rare2i = rare1i;\n                rare1 = b;\n                rare1i = i;\n            } else if b != rare1 && Freqy::rank(b) < Freqy::rank(rare2) {\n                rare2 = b;\n                rare2i = i;\n            }\n        }\n        if Freqy::rank(rare1) > Freqy::MAX_RANK {\n            return Freqy::inert();\n        }\n        let needle_len = needle.len();\n        Freqy { inert: false, needle_len, rare1, rare1i, rare2, rare2i }\n    }\n\n    /// Look for a possible occurrence of needle. The position returned\n    /// corresponds to the beginning of the occurrence, if one exists.\n    ///\n    /// Callers may assume that this never returns false negatives (i.e., it\n    /// never misses an actual occurrence), but must check that the returned\n    /// position corresponds to a match. That is, it can return false\n    /// positives.\n    ///\n    /// This should only be used when Freqy is constructed for forward\n    /// searching.\n    pub fn find_candidate(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n    ) -> Option<usize> {\n        debug_assert!(!self.inert);\n\n        let mut i = 0;\n        while prestate.is_effective() {\n            // Use a fast vectorized implementation to skip to the next\n            // occurrence of the rarest byte (heuristically chosen) in the\n            // needle.\n            i += match haystack[i..].find_byte(self.rare1) {\n                None => return None,\n                Some(found) => {\n                    prestate.update(found);\n                    found\n                }\n            };\n\n            // If we can't align our first match with the haystack, then a\n            // match is impossible.\n            if i < self.rare1i {\n                i += 1;\n                continue;\n            }\n\n            // Align our rare2 byte with the haystack. A mismatch means that\n            // a match is impossible.\n            let aligned_rare2i = i - self.rare1i + self.rare2i;\n            if haystack.get(aligned_rare2i) != Some(&self.rare2) {\n                i += 1;\n                continue;\n            }\n\n            // We've done what we can. There might be a match here.\n            return Some(i - self.rare1i);\n        }\n        // The only way we get here is if we believe our skipping heuristic\n        // has become ineffective. We're allowed to return false positives,\n        // so return the position at which we advanced to, aligned to the\n        // haystack.\n        Some(i.saturating_sub(self.rare1i))\n    }\n\n    /// Look for a possible occurrence of needle, in reverse, starting from the\n    /// end of the given haystack. The position returned corresponds to the\n    /// position immediately after the end of the occurrence, if one exists.\n    ///\n    /// Callers may assume that this never returns false negatives (i.e., it\n    /// never misses an actual occurrence), but must check that the returned\n    /// position corresponds to a match. That is, it can return false\n    /// positives.\n    ///\n    /// This should only be used when Freqy is constructed for reverse\n    /// searching.\n    pub fn rfind_candidate(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n    ) -> Option<usize> {\n        debug_assert!(!self.inert);\n\n        let mut i = haystack.len();\n        while prestate.is_effective() {\n            // Use a fast vectorized implementation to skip to the next\n            // occurrence of the rarest byte (heuristically chosen) in the\n            // needle.\n            i = match haystack[..i].rfind_byte(self.rare1) {\n                None => return None,\n                Some(found) => {\n                    prestate.update(i - found);\n                    found\n                }\n            };\n\n            // If we can't align our first match with the haystack, then a\n            // match is impossible.\n            if i + self.rare1i + 1 > haystack.len() {\n                continue;\n            }\n\n            // Align our rare2 byte with the haystack. A mismatch means that\n            // a match is impossible.\n            let aligned = match (i + self.rare1i).checked_sub(self.rare2i) {\n                None => continue,\n                Some(aligned) => aligned,\n            };\n            if haystack.get(aligned) != Some(&self.rare2) {\n                continue;\n            }\n\n            // We've done what we can. There might be a match here.\n            return Some(i + self.rare1i + 1);\n        }\n        // The only way we get here is if we believe our skipping heuristic\n        // has become ineffective. We're allowed to return false positives,\n        // so return the position at which we advanced to, aligned to the\n        // haystack.\n        Some(i + self.rare1i + 1)\n    }\n\n    /// Return the heuristical frequency rank of the given byte. A lower rank\n    /// means the byte is believed to occur less frequently.\n    fn rank(b: u8) -> usize {\n        BYTE_FREQUENCIES[b as usize] as usize\n    }\n}"],"search::prefilter::PrefilterState":["Clone","Debug","impl PrefilterState {\n    /// The minimum number of skip attempts to try before considering whether\n    /// a prefilter is effective or not.\n    const MIN_SKIPS: usize = 50;\n\n    /// The minimum amount of bytes that skipping must average.\n    ///\n    /// This value was chosen based on varying it and checking the bstr/find/\n    /// microbenchmarks. In particular, this can impact the\n    /// pathological/repeated-{huge,small} benchmarks quite a bit if it's\n    /// set too low.\n    const MIN_SKIP_BYTES: usize = 8;\n\n    /// Create a fresh prefilter state.\n    pub fn new(max_match_len: usize) -> PrefilterState {\n        if max_match_len == 0 {\n            return PrefilterState::inert();\n        }\n        PrefilterState { skips: 0, skipped: 0, max_match_len, inert: false }\n    }\n\n    /// Create a fresh prefilter state that is always inert.\n    fn inert() -> PrefilterState {\n        PrefilterState { skips: 0, skipped: 0, max_match_len: 0, inert: true }\n    }\n\n    /// Update this state with the number of bytes skipped on the last\n    /// invocation of the prefilter.\n    #[inline]\n    pub fn update(&mut self, skipped: usize) {\n        self.skips += 1;\n        self.skipped += skipped;\n    }\n\n    /// Return true if and only if this state indicates that a prefilter is\n    /// still effective.\n    #[inline]\n    pub fn is_effective(&mut self) -> bool {\n        if self.inert {\n            return false;\n        }\n        if self.skips < PrefilterState::MIN_SKIPS {\n            return true;\n        }\n        if self.skipped >= PrefilterState::MIN_SKIP_BYTES * self.skips {\n            return true;\n        }\n\n        // We're inert.\n        self.inert = true;\n        false\n    }\n}"],"search::twoway::Shift":["Clone","Debug","impl Shift {\n    /// Compute the shift for a given needle in the forward direction.\n    ///\n    /// This requires a lower bound on the period and a critical position.\n    /// These can be computed by extracting both the minimal and maximal\n    /// lexicographic suffixes, and choosing the right-most starting position.\n    /// The lower bound on the period is then the period of the chosen suffix.\n    fn forward(\n        needle: &[u8],\n        period_lower_bound: usize,\n        critical_pos: usize,\n    ) -> Shift {\n        let large = cmp::max(critical_pos, needle.len() - critical_pos);\n        if critical_pos * 2 >= needle.len() {\n            return Shift::Large { shift: large };\n        }\n\n        let (u, v) = needle.split_at(critical_pos);\n        if !v[..period_lower_bound].ends_with(u) {\n            return Shift::Large { shift: large };\n        }\n        Shift::Small { period: period_lower_bound }\n    }\n\n    /// Compute the shift for a given needle in the reverse direction.\n    ///\n    /// This requires a lower bound on the period and a critical position.\n    /// These can be computed by extracting both the minimal and maximal\n    /// lexicographic suffixes, and choosing the left-most starting position.\n    /// The lower bound on the period is then the period of the chosen suffix.\n    fn reverse(\n        needle: &[u8],\n        period_lower_bound: usize,\n        critical_pos: usize,\n    ) -> Shift {\n        let large = cmp::max(critical_pos, needle.len() - critical_pos);\n        if (needle.len() - critical_pos) * 2 >= needle.len() {\n            return Shift::Large { shift: large };\n        }\n\n        let (v, u) = needle.split_at(critical_pos);\n        if !v[v.len() - period_lower_bound..].starts_with(u) {\n            return Shift::Large { shift: large };\n        }\n        Shift::Small { period: period_lower_bound }\n    }\n}"],"search::twoway::Suffix":["Debug","impl Suffix {\n    fn forward(needle: &[u8], kind: SuffixKind) -> Suffix {\n        debug_assert!(!needle.is_empty());\n\n        // suffix represents our maximal (or minimal) suffix, along with\n        // its period.\n        let mut suffix = Suffix { pos: 0, period: 1 };\n        // The start of a suffix in `needle` that we are considering as a\n        // more maximal (or minimal) suffix than what's in `suffix`.\n        let mut candidate_start = 1;\n        // The current offset of our suffixes that we're comparing.\n        //\n        // When the characters at this offset are the same, then we mush on\n        // to the next position since no decision is possible. When the\n        // candidate's character is greater (or lesser) than the corresponding\n        // character than our current maximal (or minimal) suffix, then the\n        // current suffix is changed over to the candidate and we restart our\n        // search. Otherwise, the candidate suffix is no good and we restart\n        // our search on the next candidate.\n        //\n        // The three cases above correspond to the three cases in the loop\n        // below.\n        let mut offset = 0;\n\n        while candidate_start + offset < needle.len() {\n            let current = needle[suffix.pos + offset];\n            let candidate = needle[candidate_start + offset];\n            match kind.cmp(current, candidate) {\n                SuffixOrdering::Accept => {\n                    suffix = Suffix { pos: candidate_start, period: 1 };\n                    candidate_start += 1;\n                    offset = 0;\n                }\n                SuffixOrdering::Skip => {\n                    candidate_start += offset + 1;\n                    offset = 0;\n                    suffix.period = candidate_start - suffix.pos;\n                }\n                SuffixOrdering::Push => {\n                    if offset + 1 == suffix.period {\n                        candidate_start += suffix.period;\n                        offset = 0;\n                    } else {\n                        offset += 1;\n                    }\n                }\n            }\n        }\n        suffix\n    }\n\n    fn reverse(needle: &[u8], kind: SuffixKind) -> Suffix {\n        debug_assert!(!needle.is_empty());\n\n        // See the comments in `forward` for how this works.\n        let mut suffix = Suffix { pos: needle.len(), period: 1 };\n        if needle.len() == 1 {\n            return suffix;\n        }\n        let mut candidate_start = needle.len() - 1;\n        let mut offset = 0;\n\n        while offset < candidate_start {\n            let current = needle[suffix.pos - offset - 1];\n            let candidate = needle[candidate_start - offset - 1];\n            match kind.cmp(current, candidate) {\n                SuffixOrdering::Accept => {\n                    suffix = Suffix { pos: candidate_start, period: 1 };\n                    candidate_start -= 1;\n                    offset = 0;\n                }\n                SuffixOrdering::Skip => {\n                    candidate_start -= offset + 1;\n                    offset = 0;\n                    suffix.period = suffix.pos - candidate_start;\n                }\n                SuffixOrdering::Push => {\n                    if offset + 1 == suffix.period {\n                        candidate_start -= suffix.period;\n                        offset = 0;\n                    } else {\n                        offset += 1;\n                    }\n                }\n            }\n        }\n        suffix\n    }\n}"],"search::twoway::SuffixKind":["Clone","Copy","Debug","impl SuffixKind {\n    /// Returns true if and only if the given candidate byte indicates that\n    /// it should replace the current suffix as the maximal (or minimal)\n    /// suffix.\n    fn cmp(self, current: u8, candidate: u8) -> SuffixOrdering {\n        use self::SuffixOrdering::*;\n\n        match self {\n            SuffixKind::Minimal if candidate < current => Accept,\n            SuffixKind::Minimal if candidate > current => Skip,\n            SuffixKind::Minimal => Push,\n            SuffixKind::Maximal if candidate > current => Accept,\n            SuffixKind::Maximal if candidate < current => Skip,\n            SuffixKind::Maximal => Push,\n        }\n    }\n}"],"search::twoway::SuffixOrdering":["Clone","Copy","Debug"],"search::twoway::TwoWay":["Clone","Debug","impl<'b> TwoWay<'b> {\n    /// Create a searcher that uses the Two-Way algorithm by searching forwards\n    /// through any haystack.\n    pub fn forward(needle: &'b [u8]) -> TwoWay<'b> {\n        let freqy = Freqy::forward(needle);\n        if needle.is_empty() {\n            return TwoWay {\n                needle: CowBytes::new(needle),\n                freqy,\n                critical_pos: 0,\n                shift: Shift::Large { shift: 0 },\n            };\n        }\n\n        let min_suffix = Suffix::forward(needle, SuffixKind::Minimal);\n        let max_suffix = Suffix::forward(needle, SuffixKind::Maximal);\n        let (period_lower_bound, critical_pos) =\n            if min_suffix.pos > max_suffix.pos {\n                (min_suffix.period, min_suffix.pos)\n            } else {\n                (max_suffix.period, max_suffix.pos)\n            };\n        let shift = Shift::forward(needle, period_lower_bound, critical_pos);\n        let needle = CowBytes::new(needle);\n        TwoWay { needle, freqy, critical_pos, shift }\n    }\n\n    /// Create a searcher that uses the Two-Way algorithm by searching in\n    /// reverse through any haystack.\n    pub fn reverse(needle: &'b [u8]) -> TwoWay<'b> {\n        let freqy = Freqy::reverse(needle);\n        if needle.is_empty() {\n            return TwoWay {\n                needle: CowBytes::new(needle),\n                freqy,\n                critical_pos: 0,\n                shift: Shift::Large { shift: 0 },\n            };\n        }\n\n        let min_suffix = Suffix::reverse(needle, SuffixKind::Minimal);\n        let max_suffix = Suffix::reverse(needle, SuffixKind::Maximal);\n        let (period_lower_bound, critical_pos) =\n            if min_suffix.pos < max_suffix.pos {\n                (min_suffix.period, min_suffix.pos)\n            } else {\n                (max_suffix.period, max_suffix.pos)\n            };\n        let shift = Shift::reverse(needle, period_lower_bound, critical_pos);\n        let needle = CowBytes::new(needle);\n        TwoWay { needle, freqy, critical_pos, shift }\n    }\n\n    /// Return a fresh prefilter state that can be used with this searcher.\n    /// A prefilter state is used to track the effectiveness of a searcher's\n    /// prefilter for speeding up searches. Therefore, the prefilter state\n    /// should generally be reused on subsequent searches (such as in an\n    /// iterator). For searches on a different haystack, then a new prefilter\n    /// state should be used.\n    ///\n    /// This always initializes a valid prefilter state even if this searcher\n    /// does not have a prefilter enabled.\n    pub fn prefilter_state(&self) -> PrefilterState {\n        self.freqy.prefilter_state()\n    }\n\n    /// Return the needle used by this searcher.\n    pub fn needle(&self) -> &[u8] {\n        self.needle.as_slice()\n    }\n\n    /// Convert this searched into an owned version, where the needle is\n    /// copied if it isn't already owned.\n    #[cfg(feature = \"std\")]\n    pub fn into_owned(self) -> TwoWay<'static> {\n        TwoWay {\n            needle: self.needle.into_owned(),\n            freqy: self.freqy,\n            critical_pos: self.critical_pos,\n            shift: self.shift,\n        }\n    }\n\n    /// Find the position of the first occurrence of this searcher's needle in\n    /// the given haystack. If one does not exist, then return None.\n    ///\n    /// This will automatically initialize prefilter state. This should only\n    /// be used for one-off searches.\n    pub fn find(&self, haystack: &[u8]) -> Option<usize> {\n        self.find_with(&mut self.prefilter_state(), haystack)\n    }\n\n    /// Find the position of the last occurrence of this searcher's needle\n    /// in the given haystack. If one does not exist, then return None.\n    ///\n    /// This will automatically initialize prefilter state. This should only\n    /// be used for one-off searches.\n    pub fn rfind(&self, haystack: &[u8]) -> Option<usize> {\n        self.rfind_with(&mut self.prefilter_state(), haystack)\n    }\n\n    /// Find the position of the first occurrence of this searcher's needle in\n    /// the given haystack. If one does not exist, then return None.\n    ///\n    /// This accepts prefilter state that is useful when using the same\n    /// searcher multiple times, such as in an iterator.\n    pub fn find_with(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n    ) -> Option<usize> {\n        if self.needle.is_empty() {\n            return Some(0);\n        } else if haystack.len() < self.needle.len() {\n            return None;\n        } else if self.needle.len() == 1 {\n            return haystack.find_byte(self.needle[0]);\n        }\n        match self.shift {\n            Shift::Small { period } => {\n                self.find_small(prestate, haystack, period)\n            }\n            Shift::Large { shift } => {\n                self.find_large(prestate, haystack, shift)\n            }\n        }\n    }\n\n    /// Find the position of the last occurrence of this searcher's needle\n    /// in the given haystack. If one does not exist, then return None.\n    ///\n    /// This accepts prefilter state that is useful when using the same\n    /// searcher multiple times, such as in an iterator.\n    pub fn rfind_with(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n    ) -> Option<usize> {\n        if self.needle.is_empty() {\n            return Some(haystack.len());\n        } else if haystack.len() < self.needle.len() {\n            return None;\n        } else if self.needle.len() == 1 {\n            return haystack.rfind_byte(self.needle[0]);\n        }\n        match self.shift {\n            Shift::Small { period } => {\n                self.rfind_small(prestate, haystack, period)\n            }\n            Shift::Large { shift } => {\n                self.rfind_large(prestate, haystack, shift)\n            }\n        }\n    }\n\n    // Below is the actual implementation of TwoWay searching, including both\n    // forwards and backwards searching. Each forward and reverse search has\n    // two fairly similar implementations, each handling the small and large\n    // period cases, for a total 4 different search routines.\n    //\n    // On top of that, each search implementation can be accelerated by a\n    // Freqy prefilter, but it is not always enabled. To avoid its overhead\n    // when its disabled, we explicitly inline each search implementation based\n    // on whether Freqy will be used or not. This brings us up to a total of\n    // 8 monomorphized versions of the search code.\n\n    #[inline(never)]\n    fn find_small(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n        period: usize,\n    ) -> Option<usize> {\n        if prestate.is_effective() {\n            self.find_small_imp(prestate, true, haystack, period)\n        } else {\n            self.find_small_imp(prestate, false, haystack, period)\n        }\n    }\n\n    #[inline(always)]\n    fn find_small_imp(\n        &self,\n        prestate: &mut PrefilterState,\n        prefilter: bool,\n        haystack: &[u8],\n        period: usize,\n    ) -> Option<usize> {\n        let needle = self.needle.as_slice();\n        let mut pos = 0;\n        let mut shift = 0;\n        while pos + needle.len() <= haystack.len() {\n            let mut i = cmp::max(self.critical_pos, shift);\n            if prefilter && prestate.is_effective() {\n                match self.freqy.find_candidate(prestate, &haystack[pos..]) {\n                    None => return None,\n                    Some(found) => {\n                        shift = 0;\n                        i = self.critical_pos;\n                        pos += found;\n                        if pos + needle.len() > haystack.len() {\n                            return None;\n                        }\n                    }\n                }\n            }\n            while i < needle.len() && needle[i] == haystack[pos + i] {\n                i += 1;\n            }\n            if i < needle.len() {\n                pos += i - self.critical_pos + 1;\n                shift = 0;\n            } else {\n                let mut j = self.critical_pos;\n                while j > shift && needle[j] == haystack[pos + j] {\n                    j -= 1;\n                }\n                if j <= shift && needle[shift] == haystack[pos + shift] {\n                    return Some(pos);\n                }\n                pos += period;\n                shift = needle.len() - period;\n            }\n        }\n        None\n    }\n\n    #[inline(never)]\n    fn find_large(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n        shift: usize,\n    ) -> Option<usize> {\n        if prestate.is_effective() {\n            self.find_large_imp(prestate, true, haystack, shift)\n        } else {\n            self.find_large_imp(prestate, false, haystack, shift)\n        }\n    }\n\n    #[inline(always)]\n    fn find_large_imp(\n        &self,\n        prestate: &mut PrefilterState,\n        prefilter: bool,\n        haystack: &[u8],\n        shift: usize,\n    ) -> Option<usize> {\n        let needle = self.needle.as_slice();\n        let mut pos = 0;\n        while pos + needle.len() <= haystack.len() {\n            let mut i = self.critical_pos;\n            if prefilter && prestate.is_effective() {\n                match self.freqy.find_candidate(prestate, &haystack[pos..]) {\n                    None => return None,\n                    Some(found) => {\n                        pos += found;\n                        if pos + needle.len() > haystack.len() {\n                            return None;\n                        }\n                    }\n                }\n            }\n            while i < needle.len() && needle[i] == haystack[pos + i] {\n                i += 1;\n            }\n            if i < needle.len() {\n                pos += i - self.critical_pos + 1;\n            } else {\n                let mut j = self.critical_pos;\n                while j > 0 && needle[j] == haystack[pos + j] {\n                    j -= 1;\n                }\n                if j == 0 && needle[0] == haystack[pos] {\n                    return Some(pos);\n                }\n                pos += shift;\n            }\n        }\n        None\n    }\n\n    #[inline(never)]\n    fn rfind_small(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n        period: usize,\n    ) -> Option<usize> {\n        if prestate.is_effective() {\n            self.rfind_small_imp(prestate, true, haystack, period)\n        } else {\n            self.rfind_small_imp(prestate, false, haystack, period)\n        }\n    }\n\n    #[inline(always)]\n    fn rfind_small_imp(\n        &self,\n        prestate: &mut PrefilterState,\n        prefilter: bool,\n        haystack: &[u8],\n        period: usize,\n    ) -> Option<usize> {\n        let needle = &*self.needle;\n        let nlen = needle.len();\n        let mut pos = haystack.len();\n        let mut shift = nlen;\n        while pos >= nlen {\n            let mut i = cmp::min(self.critical_pos, shift);\n            if prefilter && prestate.is_effective() {\n                match self.freqy.rfind_candidate(prestate, &haystack[..pos]) {\n                    None => return None,\n                    Some(found) => {\n                        shift = nlen;\n                        i = self.critical_pos;\n                        pos = found;\n                        if pos < nlen {\n                            return None;\n                        }\n                    }\n                }\n            }\n            while i > 0 && needle[i - 1] == haystack[pos - nlen + i - 1] {\n                i -= 1;\n            }\n            if i > 0 || needle[0] != haystack[pos - nlen] {\n                pos -= self.critical_pos - i + 1;\n                shift = nlen;\n            } else {\n                let mut j = self.critical_pos;\n                while j < shift && needle[j] == haystack[pos - nlen + j] {\n                    j += 1;\n                }\n                if j == shift {\n                    return Some(pos - nlen);\n                }\n                pos -= period;\n                shift = period;\n            }\n        }\n        None\n    }\n\n    #[inline(never)]\n    fn rfind_large(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n        shift: usize,\n    ) -> Option<usize> {\n        if prestate.is_effective() {\n            self.rfind_large_imp(prestate, true, haystack, shift)\n        } else {\n            self.rfind_large_imp(prestate, false, haystack, shift)\n        }\n    }\n\n    #[inline(always)]\n    fn rfind_large_imp(\n        &self,\n        prestate: &mut PrefilterState,\n        prefilter: bool,\n        haystack: &[u8],\n        shift: usize,\n    ) -> Option<usize> {\n        let needle = &*self.needle;\n        let nlen = needle.len();\n        let mut pos = haystack.len();\n        while pos >= nlen {\n            if prefilter && prestate.is_effective() {\n                match self.freqy.rfind_candidate(prestate, &haystack[..pos]) {\n                    None => return None,\n                    Some(found) => {\n                        pos = found;\n                        if pos < nlen {\n                            return None;\n                        }\n                    }\n                }\n            }\n\n            let mut i = self.critical_pos;\n            while i > 0 && needle[i - 1] == haystack[pos - nlen + i - 1] {\n                i -= 1;\n            }\n            if i > 0 || needle[0] != haystack[pos - nlen] {\n                pos -= self.critical_pos - i + 1;\n            } else {\n                let mut j = self.critical_pos;\n                while j < nlen && needle[j] == haystack[pos - nlen + j] {\n                    j += 1;\n                }\n                if j == nlen {\n                    return Some(pos - nlen);\n                }\n                pos -= shift;\n            }\n        }\n        None\n    }\n}"],"std::borrow::Cow":["impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool {\n                let this: &[u8] = (&**other).as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }\n        }","impl<'a> From<&'a BStr> for Cow<'a, BStr> {\n        #[inline]\n        fn from(s: &'a BStr) -> Cow<'a, BStr> {\n            Cow::Borrowed(s)\n        }\n    }","impl<'a> From<BString> for Cow<'a, BStr> {\n        #[inline]\n        fn from(s: BString) -> Cow<'a, BStr> {\n            Cow::Owned(s)\n        }\n    }"],"std::boxed::Box":["impl From<Box<BStr>> for Box<[u8]> {\n        #[inline]\n        fn from(s: Box<BStr>) -> Box<[u8]> {\n            BStr::into_boxed_bytes(s)\n        }\n    }","impl From<Box<[u8]>> for Box<BStr> {\n        #[inline]\n        fn from(s: Box<[u8]>) -> Box<BStr> {\n            BStr::from_boxed_bytes(s)\n        }\n    }"],"std::string::String":["impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool {\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }\n        }","impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$lhs) -> Option<Ordering> {\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }\n        }"],"std::vec::Vec":["impl ByteVec for Vec<u8> {\n    #[inline]\n    fn as_vec(&self) -> &Vec<u8> {\n        self\n    }\n\n    #[inline]\n    fn as_vec_mut(&mut self) -> &mut Vec<u8> {\n        self\n    }\n\n    #[inline]\n    fn into_vec(self) -> Vec<u8> {\n        self\n    }\n}","impl From<BString> for Vec<u8> {\n        #[inline]\n        fn from(s: BString) -> Vec<u8> {\n            s.bytes\n        }\n    }","impl Sealed for Vec<u8> {}","impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool {\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }\n        }","impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$lhs) -> Option<Ordering> {\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }\n        }"],"unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD":["impl $crate::LazyStatic for $N {\n            fn initialize(lazy: &Self) {\n                let _ = &**lazy;\n            }\n        }","impl $crate::__Deref for $N {\n            type Target = $T;\n            fn deref(&self) -> &$T {\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }\n        }"],"unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV":["impl $crate::LazyStatic for $N {\n            fn initialize(lazy: &Self) {\n                let _ = &**lazy;\n            }\n        }","impl $crate::__Deref for $N {\n            type Target = $T;\n            fn deref(&self) -> &$T {\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }\n        }"],"unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV":["impl $crate::LazyStatic for $N {\n            fn initialize(lazy: &Self) {\n                let _ = &**lazy;\n            }\n        }","impl $crate::__Deref for $N {\n            type Target = $T;\n            fn deref(&self) -> &$T {\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }\n        }"],"unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD":["impl $crate::LazyStatic for $N {\n            fn initialize(lazy: &Self) {\n                let _ = &**lazy;\n            }\n        }","impl $crate::__Deref for $N {\n            type Target = $T;\n            fn deref(&self) -> &$T {\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }\n        }"],"unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD":["impl $crate::LazyStatic for $N {\n            fn initialize(lazy: &Self) {\n                let _ = &**lazy;\n            }\n        }","impl $crate::__Deref for $N {\n            type Target = $T;\n            fn deref(&self) -> &$T {\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }\n        }"],"unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD":["impl $crate::LazyStatic for $N {\n            fn initialize(lazy: &Self) {\n                let _ = &**lazy;\n            }\n        }","impl $crate::__Deref for $N {\n            type Target = $T;\n            fn deref(&self) -> &$T {\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }\n        }"],"unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV":["impl $crate::LazyStatic for $N {\n            fn initialize(lazy: &Self) {\n                let _ = &**lazy;\n            }\n        }","impl $crate::__Deref for $N {\n            type Target = $T;\n            fn deref(&self) -> &$T {\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }\n        }"],"unicode::fsm::word_break_fwd::WORD_BREAK_FWD":["impl $crate::LazyStatic for $N {\n            fn initialize(lazy: &Self) {\n                let _ = &**lazy;\n            }\n        }","impl $crate::__Deref for $N {\n            type Target = $T;\n            fn deref(&self) -> &$T {\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }\n        }"],"unicode::grapheme::GraphemeIndices":["Clone","Debug","impl<'a> DoubleEndedIterator for GraphemeIndices<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<(usize, usize, &'a str)> {\n        let (grapheme, size) = decode_last_grapheme(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[..self.bs.len() - size];\n        self.reverse_index -= size;\n        Some((self.reverse_index, self.reverse_index + size, grapheme))\n    }\n}","impl<'a> GraphemeIndices<'a> {\n    pub(crate) fn new(bs: &'a [u8]) -> GraphemeIndices<'a> {\n        GraphemeIndices { bs: bs, forward_index: 0, reverse_index: bs.len() }\n    }\n\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// The slice returned has the same lifetime as the original slice, and so\n    /// the iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut it = b\"abc\".grapheme_indices();\n    ///\n    /// assert_eq!(b\"abc\", it.as_bytes());\n    /// it.next();\n    /// assert_eq!(b\"bc\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\"\", it.as_bytes());\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &'a [u8] {\n        self.bs\n    }\n}","impl<'a> Iterator for GraphemeIndices<'a> {\n    type Item = (usize, usize, &'a str);\n\n    #[inline]\n    fn next(&mut self) -> Option<(usize, usize, &'a str)> {\n        let index = self.forward_index;\n        let (grapheme, size) = decode_grapheme(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        self.forward_index += size;\n        Some((index, index + size, grapheme))\n    }\n}"],"unicode::grapheme::Graphemes":["Clone","Debug","impl<'a> DoubleEndedIterator for Graphemes<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a str> {\n        let (grapheme, size) = decode_last_grapheme(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[..self.bs.len() - size];\n        Some(grapheme)\n    }\n}","impl<'a> Graphemes<'a> {\n    pub(crate) fn new(bs: &'a [u8]) -> Graphemes<'a> {\n        Graphemes { bs }\n    }\n\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// The slice returned has the same lifetime as the original slice, and so\n    /// the iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut it = b\"abc\".graphemes();\n    ///\n    /// assert_eq!(b\"abc\", it.as_bytes());\n    /// it.next();\n    /// assert_eq!(b\"bc\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\"\", it.as_bytes());\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &'a [u8] {\n        self.bs\n    }\n}","impl<'a> Iterator for Graphemes<'a> {\n    type Item = &'a str;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a str> {\n        let (grapheme, size) = decode_grapheme(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        Some(grapheme)\n    }\n}"],"unicode::sentence::SentenceIndices":["Clone","Debug","impl<'a> Iterator for SentenceIndices<'a> {\n    type Item = (usize, usize, &'a str);\n\n    #[inline]\n    fn next(&mut self) -> Option<(usize, usize, &'a str)> {\n        let index = self.forward_index;\n        let (word, size) = decode_sentence(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        self.forward_index += size;\n        Some((index, index + size, word))\n    }\n}","impl<'a> SentenceIndices<'a> {\n    pub(crate) fn new(bs: &'a [u8]) -> SentenceIndices<'a> {\n        SentenceIndices { bs: bs, forward_index: 0 }\n    }\n\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// The slice returned has the same lifetime as the original slice, and so\n    /// the iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut it = b\"I want this. Not that. Right now.\".sentence_indices();\n    ///\n    /// assert_eq!(&b\"I want this. Not that. Right now.\"[..], it.as_bytes());\n    /// it.next();\n    /// assert_eq!(b\"Not that. Right now.\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\"\", it.as_bytes());\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &'a [u8] {\n        self.bs\n    }\n}"],"unicode::sentence::Sentences":["Clone","Debug","impl<'a> Iterator for Sentences<'a> {\n    type Item = &'a str;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a str> {\n        let (sentence, size) = decode_sentence(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        Some(sentence)\n    }\n}","impl<'a> Sentences<'a> {\n    pub(crate) fn new(bs: &'a [u8]) -> Sentences<'a> {\n        Sentences { bs }\n    }\n\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// The slice returned has the same lifetime as the original slice, and so\n    /// the iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut it = b\"I want this. Not that. Right now.\".sentences();\n    ///\n    /// assert_eq!(&b\"I want this. Not that. Right now.\"[..], it.as_bytes());\n    /// it.next();\n    /// assert_eq!(b\"Not that. Right now.\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\"\", it.as_bytes());\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &'a [u8] {\n        self.bs\n    }\n}"],"unicode::word::WordIndices":["Clone","Debug","impl<'a> Iterator for WordIndices<'a> {\n    type Item = (usize, usize, &'a str);\n\n    #[inline]\n    fn next(&mut self) -> Option<(usize, usize, &'a str)> {\n        while let Some((start, end, word)) = self.0.next() {\n            if SIMPLE_WORD_FWD.is_match(word.as_bytes()) {\n                return Some((start, end, word));\n            }\n        }\n        None\n    }\n}","impl<'a> WordIndices<'a> {\n    pub(crate) fn new(bs: &'a [u8]) -> WordIndices<'a> {\n        WordIndices(WordsWithBreakIndices::new(bs))\n    }\n\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// The slice returned has the same lifetime as the original slice, and so\n    /// the iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut it = b\"foo bar baz\".word_indices();\n    ///\n    /// assert_eq!(b\"foo bar baz\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\" baz\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\"\", it.as_bytes());\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &'a [u8] {\n        self.0.as_bytes()\n    }\n}"],"unicode::word::Words":["Clone","Debug","impl<'a> Iterator for Words<'a> {\n    type Item = &'a str;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a str> {\n        while let Some(word) = self.0.next() {\n            if SIMPLE_WORD_FWD.is_match(word.as_bytes()) {\n                return Some(word);\n            }\n        }\n        None\n    }\n}","impl<'a> Words<'a> {\n    pub(crate) fn new(bs: &'a [u8]) -> Words<'a> {\n        Words(WordsWithBreaks::new(bs))\n    }\n\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// The slice returned has the same lifetime as the original slice, and so\n    /// the iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut it = b\"foo bar baz\".words();\n    ///\n    /// assert_eq!(b\"foo bar baz\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\" baz\", it.as_bytes());\n    /// it.next();\n    /// assert_eq!(b\"\", it.as_bytes());\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &'a [u8] {\n        self.0.as_bytes()\n    }\n}"],"unicode::word::WordsWithBreakIndices":["Clone","Debug","impl<'a> Iterator for WordsWithBreakIndices<'a> {\n    type Item = (usize, usize, &'a str);\n\n    #[inline]\n    fn next(&mut self) -> Option<(usize, usize, &'a str)> {\n        let index = self.forward_index;\n        let (word, size) = decode_word(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        self.forward_index += size;\n        Some((index, index + size, word))\n    }\n}","impl<'a> WordsWithBreakIndices<'a> {\n    pub(crate) fn new(bs: &'a [u8]) -> WordsWithBreakIndices<'a> {\n        WordsWithBreakIndices { bs: bs, forward_index: 0 }\n    }\n\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// The slice returned has the same lifetime as the original slice, and so\n    /// the iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut it = b\"foo bar baz\".words_with_break_indices();\n    ///\n    /// assert_eq!(b\"foo bar baz\", it.as_bytes());\n    /// it.next();\n    /// assert_eq!(b\" bar baz\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\" baz\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\"\", it.as_bytes());\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &'a [u8] {\n        self.bs\n    }\n}"],"unicode::word::WordsWithBreaks":["Clone","Debug","impl<'a> Iterator for WordsWithBreaks<'a> {\n    type Item = &'a str;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a str> {\n        let (word, size) = decode_word(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        Some(word)\n    }\n}","impl<'a> WordsWithBreaks<'a> {\n    pub(crate) fn new(bs: &'a [u8]) -> WordsWithBreaks<'a> {\n        WordsWithBreaks { bs }\n    }\n\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// The slice returned has the same lifetime as the original slice, and so\n    /// the iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut it = b\"foo bar baz\".words_with_breaks();\n    ///\n    /// assert_eq!(b\"foo bar baz\", it.as_bytes());\n    /// it.next();\n    /// assert_eq!(b\" bar baz\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\" baz\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\"\", it.as_bytes());\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &'a [u8] {\n        self.bs\n    }\n}"],"utf8::CharIndices":["Clone","Debug","impl<'a> ::core::iter::FusedIterator for CharIndices<'a> {}","impl<'a> CharIndices<'a> {\n    pub(crate) fn new(bs: &'a [u8]) -> CharIndices<'a> {\n        CharIndices { bs: bs, forward_index: 0, reverse_index: bs.len() }\n    }\n\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// The slice returned has the same lifetime as the original slice, and so\n    /// the iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut it = b\"abc\".char_indices();\n    ///\n    /// assert_eq!(b\"abc\", it.as_bytes());\n    /// it.next();\n    /// assert_eq!(b\"bc\", it.as_bytes());\n    /// it.next();\n    /// it.next();\n    /// assert_eq!(b\"\", it.as_bytes());\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &'a [u8] {\n        self.bs\n    }\n}","impl<'a> DoubleEndedIterator for CharIndices<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<(usize, usize, char)> {\n        let (ch, size) = decode_last_lossy(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[..self.bs.len() - size];\n        self.reverse_index -= size;\n        Some((self.reverse_index, self.reverse_index + size, ch))\n    }\n}","impl<'a> Iterator for CharIndices<'a> {\n    type Item = (usize, usize, char);\n\n    #[inline]\n    fn next(&mut self) -> Option<(usize, usize, char)> {\n        let index = self.forward_index;\n        let (ch, size) = decode_lossy(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        self.forward_index += size;\n        Some((index, index + size, ch))\n    }\n}"],"utf8::Chars":["Clone","Debug","impl<'a> Chars<'a> {\n    pub(crate) fn new(bs: &'a [u8]) -> Chars<'a> {\n        Chars { bs }\n    }\n\n    /// View the underlying data as a subslice of the original data.\n    ///\n    /// The slice returned has the same lifetime as the original slice, and so\n    /// the iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut chars = b\"abc\".chars();\n    ///\n    /// assert_eq!(b\"abc\", chars.as_bytes());\n    /// chars.next();\n    /// assert_eq!(b\"bc\", chars.as_bytes());\n    /// chars.next();\n    /// chars.next();\n    /// assert_eq!(b\"\", chars.as_bytes());\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &'a [u8] {\n        self.bs\n    }\n}","impl<'a> DoubleEndedIterator for Chars<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<char> {\n        let (ch, size) = decode_last_lossy(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[..self.bs.len() - size];\n        Some(ch)\n    }\n}","impl<'a> Iterator for Chars<'a> {\n    type Item = char;\n\n    #[inline]\n    fn next(&mut self) -> Option<char> {\n        let (ch, size) = decode_lossy(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        Some(ch)\n    }\n}"],"utf8::Utf8Chunk":["impl<'a> Utf8Chunk<'a> {\n    /// Returns the (possibly empty) valid UTF-8 bytes in this chunk.\n    ///\n    /// This may be empty if there are consecutive sequences of invalid UTF-8\n    /// bytes.\n    #[inline]\n    pub fn valid(&self) -> &'a str {\n        self.valid\n    }\n\n    /// Returns the (possibly empty) invalid UTF-8 bytes in this chunk that\n    /// immediately follow the valid UTF-8 bytes in this chunk.\n    ///\n    /// This is only empty when this chunk corresponds to the last chunk in\n    /// the original bytes.\n    ///\n    /// The maximum length of this slice is 3. That is, invalid UTF-8 byte\n    /// sequences greater than 1 always correspond to a valid _prefix_ of\n    /// a valid UTF-8 encoded codepoint. This corresponds to the \"substitution\n    /// of maximal subparts\" strategy that is described in more detail in the\n    /// docs for the\n    /// [`ByteSlice::to_str_lossy`](trait.ByteSlice.html#method.to_str_lossy)\n    /// method.\n    #[inline]\n    pub fn invalid(&self) -> &'a [u8] {\n        self.invalid.as_bytes()\n    }\n\n    /// Returns whether the invalid sequence might still become valid if more\n    /// bytes are added.\n    ///\n    /// Returns true if the end of the input was reached unexpectedly,\n    /// without encountering an unexpected byte.\n    ///\n    /// This can only be the case for the last chunk.\n    #[inline]\n    pub fn incomplete(&self) -> bool {\n        self.incomplete\n    }\n}"],"utf8::Utf8Chunks":["Clone","Debug","impl<'a> ::core::iter::FusedIterator for Utf8Chunks<'a> {}","impl<'a> Iterator for Utf8Chunks<'a> {\n    type Item = Utf8Chunk<'a>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Utf8Chunk<'a>> {\n        if self.bytes.is_empty() {\n            return None;\n        }\n        match validate(self.bytes) {\n            Ok(()) => {\n                let valid = self.bytes;\n                self.bytes = &[];\n                Some(Utf8Chunk {\n                    // SAFETY: This is safe because of the guarantees provided\n                    // by utf8::validate.\n                    valid: unsafe { str::from_utf8_unchecked(valid) },\n                    invalid: [].as_bstr(),\n                    incomplete: false,\n                })\n            }\n            Err(e) => {\n                let (valid, rest) = self.bytes.split_at(e.valid_up_to());\n                // SAFETY: This is safe because of the guarantees provided by\n                // utf8::validate.\n                let valid = unsafe { str::from_utf8_unchecked(valid) };\n                let (invalid_len, incomplete) = match e.error_len() {\n                    Some(n) => (n, false),\n                    None => (rest.len(), true),\n                };\n                let (invalid, rest) = rest.split_at(invalid_len);\n                self.bytes = rest;\n                Some(Utf8Chunk {\n                    valid,\n                    invalid: invalid.as_bstr(),\n                    incomplete,\n                })\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.bytes.is_empty() {\n            (0, Some(0))\n        } else {\n            (1, Some(self.bytes.len()))\n        }\n    }\n}"],"utf8::Utf8Error":["Debug","Eq","PartialEq","impl Utf8Error {\n    /// Returns the byte index of the position immediately following the last\n    /// valid UTF-8 byte.\n    ///\n    /// # Example\n    ///\n    /// This examples shows how `valid_up_to` can be used to retrieve a\n    /// possibly empty prefix that is guaranteed to be valid UTF-8:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foobar\\xF1\\x80\\x80quux\";\n    /// let err = s.to_str().unwrap_err();\n    ///\n    /// // This is guaranteed to never panic.\n    /// let string = s[..err.valid_up_to()].to_str().unwrap();\n    /// assert_eq!(string, \"foobar\");\n    /// ```\n    #[inline]\n    pub fn valid_up_to(&self) -> usize {\n        self.valid_up_to\n    }\n\n    /// Returns the total number of invalid UTF-8 bytes immediately following\n    /// the position returned by `valid_up_to`. This value is always at least\n    /// `1`, but can be up to `3` if bytes form a valid prefix of some UTF-8\n    /// encoded codepoint.\n    ///\n    /// If the end of the original input was found before a valid UTF-8 encoded\n    /// codepoint could be completed, then this returns `None`. This is useful\n    /// when processing streams, where a `None` value signals that more input\n    /// might be needed.\n    #[inline]\n    pub fn error_len(&self) -> Option<usize> {\n        self.error_len\n    }\n}","impl error::Error for Utf8Error {\n    fn description(&self) -> &str {\n        \"invalid UTF-8\"\n    }\n}","impl fmt::Display for Utf8Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"invalid UTF-8 found at byte offset {}\", self.valid_up_to)\n    }\n}"]},"single_path_import":{"bstr::BStr":"BStr","bstring::BString":"BString","ext_slice::B":"B","ext_slice::ByteSlice":"ByteSlice","ext_slice::Bytes":"Bytes","ext_slice::Fields":"Fields","ext_slice::FieldsWith":"FieldsWith","ext_slice::Find":"Find","ext_slice::FindReverse":"FindReverse","ext_slice::Finder":"Finder","ext_slice::FinderReverse":"FinderReverse","ext_slice::Lines":"Lines","ext_slice::LinesWithTerminator":"LinesWithTerminator","ext_slice::Split":"Split","ext_slice::SplitN":"SplitN","ext_slice::SplitNReverse":"SplitNReverse","ext_slice::SplitReverse":"SplitReverse","ext_vec::ByteVec":"ByteVec","ext_vec::DrainBytes":"DrainBytes","ext_vec::FromUtf8Error":"FromUtf8Error","ext_vec::concat":"concat","ext_vec::join":"join","search::prefilter::PrefilterState":"search::PrefilterState","search::twoway::TwoWay":"search::TwoWay","unicode::grapheme::GraphemeIndices":"unicode::GraphemeIndices","unicode::grapheme::Graphemes":"unicode::Graphemes","unicode::grapheme::decode_grapheme":"unicode::decode_grapheme","unicode::sentence::SentenceIndices":"unicode::SentenceIndices","unicode::sentence::Sentences":"unicode::Sentences","unicode::whitespace::whitespace_len_fwd":"unicode::whitespace_len_fwd","unicode::whitespace::whitespace_len_rev":"unicode::whitespace_len_rev","unicode::word::WordIndices":"unicode::WordIndices","unicode::word::Words":"unicode::Words","unicode::word::WordsWithBreakIndices":"unicode::WordsWithBreakIndices","unicode::word::WordsWithBreaks":"unicode::WordsWithBreaks","utf8::CharIndices":"CharIndices","utf8::Chars":"Chars","utf8::Utf8Chunk":"Utf8Chunk","utf8::Utf8Chunks":"Utf8Chunks","utf8::Utf8Error":"Utf8Error","utf8::decode":"decode","utf8::decode_last":"decode_last"},"srcs":{"<[u8] as ext_slice::ByteSlice>::as_bytes":["#[inline]\nfn as_bytes(&self) -> &[u8]{\n        self\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<[u8] as ext_slice::ByteSlice>::as_bytes_mut":["#[inline]\nfn as_bytes_mut(&mut self) -> &mut [u8]{\n        self\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<cow::CowBytes<'a> as lazy_static::__Deref>::deref":["fn deref(&self) -> &[u8]{\n        self.as_slice()\n    }","Real(LocalPath(\"src/cow.rs\"))"],"<ext_slice::Bytes<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<u8>{\n        self.it.next_back().map(|&b| b)\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::Bytes<'a> as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n        self.it.len()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::Bytes<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<u8>{\n        self.it.next().map(|&b| b)\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::Bytes<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::Fields<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a [u8]>{\n        self.it.next()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::FieldsWith<'a, F> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a [u8]>{\n        let (start, mut end);\n        loop {\n            match self.chars.next() {\n                None => return None,\n                Some((s, e, ch)) => {\n                    if !(self.f)(ch) {\n                        start = s;\n                        end = e;\n                        break;\n                    }\n                }\n            }\n        }\n        while let Some((_, e, ch)) = self.chars.next() {\n            if (self.f)(ch) {\n                break;\n            }\n            end = e;\n        }\n        Some(&self.bytes[start..end])\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::Find<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<usize>{\n        if self.pos > self.haystack.len() {\n            return None;\n        }\n        let result = self\n            .searcher\n            .find_with(&mut self.prestate, &self.haystack[self.pos..]);\n        match result {\n            None => None,\n            Some(i) => {\n                let pos = self.pos + i;\n                self.pos = pos + cmp::max(1, self.searcher.needle().len());\n                Some(pos)\n            }\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::FindReverse<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<usize>{\n        let pos = match self.pos {\n            None => return None,\n            Some(pos) => pos,\n        };\n        let result = self\n            .searcher\n            .rfind_with(&mut self.prestate, &self.haystack[..pos]);\n        match result {\n            None => None,\n            Some(i) => {\n                if pos == i {\n                    self.pos = pos.checked_sub(1);\n                } else {\n                    self.pos = Some(i);\n                }\n                Some(i)\n            }\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::Lines<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a [u8]>{\n        let mut line = self.it.next()?;\n        if line.last_byte() == Some(b'\\n') {\n            line = &line[..line.len() - 1];\n            if line.last_byte() == Some(b'\\r') {\n                line = &line[..line.len() - 1];\n            }\n        }\n        Some(line)\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::LinesWithTerminator<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a [u8]>{\n        match self.bytes.find_byte(b'\\n') {\n            None if self.bytes.is_empty() => None,\n            None => {\n                let line = self.bytes;\n                self.bytes = b\"\";\n                Some(line)\n            }\n            Some(end) => {\n                let line = &self.bytes[..end + 1];\n                self.bytes = &self.bytes[end + 1..];\n                Some(line)\n            }\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::Split<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a [u8]>{\n        let haystack = self.finder.haystack;\n        match self.finder.next() {\n            Some(start) => {\n                let next = &haystack[self.last..start];\n                self.last = start + self.finder.searcher.needle().len();\n                Some(next)\n            }\n            None => {\n                if self.last >= haystack.len() {\n                    if !self.done {\n                        self.done = true;\n                        Some(b\"\")\n                    } else {\n                        None\n                    }\n                } else {\n                    let s = &haystack[self.last..];\n                    self.last = haystack.len();\n                    self.done = true;\n                    Some(s)\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::SplitN<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a [u8]>{\n        self.count += 1;\n        if self.count > self.limit || self.split.done {\n            None\n        } else if self.count == self.limit {\n            Some(&self.split.finder.haystack[self.split.last..])\n        } else {\n            self.split.next()\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::SplitNReverse<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a [u8]>{\n        self.count += 1;\n        if self.count > self.limit || self.split.done {\n            None\n        } else if self.count == self.limit {\n            Some(&self.split.finder.haystack()[..self.split.last])\n        } else {\n            self.split.next()\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_slice::SplitReverse<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a [u8]>{\n        let haystack = self.finder.haystack();\n        match self.finder.next() {\n            Some(start) => {\n                let nlen = self.finder.needle().len();\n                let next = &haystack[start + nlen..self.last];\n                self.last = start;\n                Some(next)\n            }\n            None => {\n                if self.last == 0 {\n                    if !self.done {\n                        self.done = true;\n                        Some(b\"\")\n                    } else {\n                        None\n                    }\n                } else {\n                    let s = &haystack[..self.last];\n                    self.last = 0;\n                    self.done = true;\n                    Some(s)\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"<ext_vec::DrainBytes<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<u8>{\n        self.it.next_back()\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"<ext_vec::DrainBytes<'a> as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n        self.it.len()\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"<ext_vec::DrainBytes<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<u8>{\n        self.it.next()\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"<ext_vec::FromUtf8Error as std::error::Error>::description":["#[inline]\nfn description(&self) -> &str{\n        \"invalid UTF-8 vector\"\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"<ext_vec::FromUtf8Error as std::fmt::Display>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"{}\", self.err)\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"<io::ByteLines<B> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<io::Result<Vec<u8>>>{\n        let mut bytes = vec![];\n        match self.buf.read_until(b'\\n', &mut bytes) {\n            Err(e) => Some(Err(e)),\n            Ok(0) => None,\n            Ok(_) => {\n                trim_line(&mut bytes);\n                Some(Ok(bytes))\n            }\n        }\n    }","Real(LocalPath(\"src/io.rs\"))"],"<io::ByteRecords<B> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<io::Result<Vec<u8>>>{\n        let mut bytes = vec![];\n        match self.buf.read_until(self.terminator, &mut bytes) {\n            Err(e) => Some(Err(e)),\n            Ok(0) => None,\n            Ok(_) => {\n                trim_record(&mut bytes, self.terminator);\n                Some(Ok(bytes))\n            }\n        }\n    }","Real(LocalPath(\"src/io.rs\"))"],"<std::vec::Vec<u8> as ext_vec::ByteVec>::as_vec":["#[inline]\nfn as_vec(&self) -> &Vec<u8>{\n        self\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"<std::vec::Vec<u8> as ext_vec::ByteVec>::as_vec_mut":["#[inline]\nfn as_vec_mut(&mut self) -> &mut Vec<u8>{\n        self\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"<std::vec::Vec<u8> as ext_vec::ByteVec>::into_vec":["#[inline]\nfn into_vec(self) -> Vec<u8>{\n        self\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::LazyStatic>::initialize":["fn initialize(lazy: &Self){\n                let _ = &**lazy;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref":["fn deref(&self) -> &$T{\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref::__stability":["#[inline(always)]\nfn __stability() -> &'static $T{\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["#[inline(always)]\nfn __static_ref_initialize() -> $T{ $e }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["#[repr(C)]\nstruct Aligned<B: ?Sized> {\n            _align: [u8; 0],\n            bytes: B,\n        }","Real(LocalPath(\"src/unicode/fsm/grapheme_break_fwd.rs\"))"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::LazyStatic>::initialize":["fn initialize(lazy: &Self){\n                let _ = &**lazy;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref":["fn deref(&self) -> &$T{\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref::__stability":["#[inline(always)]\nfn __stability() -> &'static $T{\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref::__static_ref_initialize":["#[inline(always)]\nfn __static_ref_initialize() -> $T{ $e }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["#[repr(C)]\nstruct Aligned<B: ?Sized> {\n            _align: [u8; 0],\n            bytes: B,\n        }","Real(LocalPath(\"src/unicode/fsm/grapheme_break_rev.rs\"))"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::LazyStatic>::initialize":["fn initialize(lazy: &Self){\n                let _ = &**lazy;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref":["fn deref(&self) -> &$T{\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref::__stability":["#[inline(always)]\nfn __stability() -> &'static $T{\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref::__static_ref_initialize":["#[inline(always)]\nfn __static_ref_initialize() -> $T{ $e }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["#[repr(C)]\nstruct Aligned<B: ?Sized> {\n            _align: [u8; 0],\n            bytes: B,\n        }","Real(LocalPath(\"src/unicode/fsm/regional_indicator_rev.rs\"))"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::LazyStatic>::initialize":["fn initialize(lazy: &Self){\n                let _ = &**lazy;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref":["fn deref(&self) -> &$T{\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref::__stability":["#[inline(always)]\nfn __stability() -> &'static $T{\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["#[inline(always)]\nfn __static_ref_initialize() -> $T{ $e }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["#[repr(C)]\nstruct Aligned<B: ?Sized> {\n            _align: [u8; 0],\n            bytes: B,\n        }","Real(LocalPath(\"src/unicode/fsm/sentence_break_fwd.rs\"))"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::LazyStatic>::initialize":["fn initialize(lazy: &Self){\n                let _ = &**lazy;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref":["fn deref(&self) -> &$T{\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref::__stability":["#[inline(always)]\nfn __stability() -> &'static $T{\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["#[inline(always)]\nfn __static_ref_initialize() -> $T{ $e }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["#[repr(C)]\nstruct Aligned<B: ?Sized> {\n            _align: [u8; 0],\n            bytes: B,\n        }","Real(LocalPath(\"src/unicode/fsm/simple_word_fwd.rs\"))"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::LazyStatic>::initialize":["fn initialize(lazy: &Self){\n                let _ = &**lazy;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref":["fn deref(&self) -> &$T{\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref::__stability":["#[inline(always)]\nfn __stability() -> &'static $T{\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["#[inline(always)]\nfn __static_ref_initialize() -> $T{ $e }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["#[repr(C)]\nstruct Aligned<B: ?Sized> {\n            _align: [u8; 0],\n            bytes: B,\n        }","Real(LocalPath(\"src/unicode/fsm/whitespace_anchored_fwd.rs\"))"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::LazyStatic>::initialize":["fn initialize(lazy: &Self){\n                let _ = &**lazy;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref":["fn deref(&self) -> &$T{\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref::__stability":["#[inline(always)]\nfn __stability() -> &'static $T{\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref::__static_ref_initialize":["#[inline(always)]\nfn __static_ref_initialize() -> $T{ $e }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["#[repr(C)]\nstruct Aligned<B: ?Sized> {\n            _align: [u8; 0],\n            bytes: B,\n        }","Real(LocalPath(\"src/unicode/fsm/whitespace_anchored_rev.rs\"))"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::LazyStatic>::initialize":["fn initialize(lazy: &Self){\n                let _ = &**lazy;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref":["fn deref(&self) -> &$T{\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref::__stability":["#[inline(always)]\nfn __stability() -> &'static $T{\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["#[inline(always)]\nfn __static_ref_initialize() -> $T{ $e }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned":["#[repr(C)]\nstruct Aligned<B: ?Sized> {\n            _align: [u8; 0],\n            bytes: B,\n        }","Real(LocalPath(\"src/unicode/fsm/word_break_fwd.rs\"))"],"<unicode::grapheme::GraphemeIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<(usize, usize, &'a str)>{\n        let (grapheme, size) = decode_last_grapheme(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[..self.bs.len() - size];\n        self.reverse_index -= size;\n        Some((self.reverse_index, self.reverse_index + size, grapheme))\n    }","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"<unicode::grapheme::GraphemeIndices<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<(usize, usize, &'a str)>{\n        let index = self.forward_index;\n        let (grapheme, size) = decode_grapheme(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        self.forward_index += size;\n        Some((index, index + size, grapheme))\n    }","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"<unicode::grapheme::Graphemes<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<&'a str>{\n        let (grapheme, size) = decode_last_grapheme(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[..self.bs.len() - size];\n        Some(grapheme)\n    }","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"<unicode::grapheme::Graphemes<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a str>{\n        let (grapheme, size) = decode_grapheme(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        Some(grapheme)\n    }","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"<unicode::sentence::SentenceIndices<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<(usize, usize, &'a str)>{\n        let index = self.forward_index;\n        let (word, size) = decode_sentence(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        self.forward_index += size;\n        Some((index, index + size, word))\n    }","Real(LocalPath(\"src/unicode/sentence.rs\"))"],"<unicode::sentence::Sentences<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a str>{\n        let (sentence, size) = decode_sentence(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        Some(sentence)\n    }","Real(LocalPath(\"src/unicode/sentence.rs\"))"],"<unicode::word::WordIndices<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<(usize, usize, &'a str)>{\n        while let Some((start, end, word)) = self.0.next() {\n            if SIMPLE_WORD_FWD.is_match(word.as_bytes()) {\n                return Some((start, end, word));\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"<unicode::word::Words<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a str>{\n        while let Some(word) = self.0.next() {\n            if SIMPLE_WORD_FWD.is_match(word.as_bytes()) {\n                return Some(word);\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"<unicode::word::WordsWithBreakIndices<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<(usize, usize, &'a str)>{\n        let index = self.forward_index;\n        let (word, size) = decode_word(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        self.forward_index += size;\n        Some((index, index + size, word))\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"<unicode::word::WordsWithBreaks<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<&'a str>{\n        let (word, size) = decode_word(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        Some(word)\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"<utf8::CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<(usize, usize, char)>{\n        let (ch, size) = decode_last_lossy(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[..self.bs.len() - size];\n        self.reverse_index -= size;\n        Some((self.reverse_index, self.reverse_index + size, ch))\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::CharIndices<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<(usize, usize, char)>{\n        let index = self.forward_index;\n        let (ch, size) = decode_lossy(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        self.forward_index += size;\n        Some((index, index + size, ch))\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Chars<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<char>{\n        let (ch, size) = decode_last_lossy(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[..self.bs.len() - size];\n        Some(ch)\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Chars<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<char>{\n        let (ch, size) = decode_lossy(self.bs);\n        if size == 0 {\n            return None;\n        }\n        self.bs = &self.bs[size..];\n        Some(ch)\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Utf8Chunks<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Utf8Chunk<'a>>{\n        if self.bytes.is_empty() {\n            return None;\n        }\n        match validate(self.bytes) {\n            Ok(()) => {\n                let valid = self.bytes;\n                self.bytes = &[];\n                Some(Utf8Chunk {\n                    // SAFETY: This is safe because of the guarantees provided\n                    // by utf8::validate.\n                    valid: unsafe { str::from_utf8_unchecked(valid) },\n                    invalid: [].as_bstr(),\n                    incomplete: false,\n                })\n            }\n            Err(e) => {\n                let (valid, rest) = self.bytes.split_at(e.valid_up_to());\n                // SAFETY: This is safe because of the guarantees provided by\n                // utf8::validate.\n                let valid = unsafe { str::from_utf8_unchecked(valid) };\n                let (invalid_len, incomplete) = match e.error_len() {\n                    Some(n) => (n, false),\n                    None => (rest.len(), true),\n                };\n                let (invalid, rest) = rest.split_at(invalid_len);\n                self.bytes = rest;\n                Some(Utf8Chunk {\n                    valid,\n                    invalid: invalid.as_bstr(),\n                    incomplete,\n                })\n            }\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Utf8Chunks<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        if self.bytes.is_empty() {\n            (0, Some(0))\n        } else {\n            (1, Some(self.bytes.len()))\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Utf8Error as std::error::Error>::description":["fn description(&self) -> &str{\n        \"invalid UTF-8\"\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Utf8Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"invalid UTF-8 found at byte offset {}\", self.valid_up_to)\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"ascii::first_non_ascii_byte":["/// Returns the index of the first non ASCII byte in the given slice.\n///\n/// If slice only contains ASCII bytes, then the length of the slice is\n/// returned.\npub fn first_non_ascii_byte(slice: &[u8]) -> usize{\n    #[cfg(not(target_arch = \"x86_64\"))]\n    {\n        first_non_ascii_byte_fallback(slice)\n    }\n\n    #[cfg(target_arch = \"x86_64\")]\n    {\n        first_non_ascii_byte_sse2(slice)\n    }\n}","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::first_non_ascii_byte_slow":["#[inline(always)]\nunsafe fn first_non_ascii_byte_slow(\n    start_ptr: *const u8,\n    end_ptr: *const u8,\n    mut ptr: *const u8,\n) -> usize{\n    debug_assert!(start_ptr <= ptr);\n    debug_assert!(ptr <= end_ptr);\n\n    while ptr < end_ptr {\n        if *ptr > 0x7F {\n            return sub(ptr, start_ptr);\n        }\n        ptr = ptr.offset(1);\n    }\n    sub(end_ptr, start_ptr)\n}","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::first_non_ascii_byte_sse2":["#[cfg(target_arch = \"x86_64\")]\nfn first_non_ascii_byte_sse2(slice: &[u8]) -> usize{\n    use core::arch::x86_64::*;\n\n    const VECTOR_SIZE: usize = mem::size_of::<__m128i>();\n    const VECTOR_ALIGN: usize = VECTOR_SIZE - 1;\n    const VECTOR_LOOP_SIZE: usize = 4 * VECTOR_SIZE;\n\n    let start_ptr = slice.as_ptr();\n    let end_ptr = slice[slice.len()..].as_ptr();\n    let mut ptr = start_ptr;\n\n    unsafe {\n        if slice.len() < VECTOR_SIZE {\n            return first_non_ascii_byte_slow(start_ptr, end_ptr, ptr);\n        }\n\n        let chunk = _mm_loadu_si128(ptr as *const __m128i);\n        let mask = _mm_movemask_epi8(chunk);\n        if mask != 0 {\n            return mask.trailing_zeros() as usize;\n        }\n\n        ptr = ptr.add(VECTOR_SIZE - (start_ptr as usize & VECTOR_ALIGN));\n        debug_assert!(ptr > start_ptr);\n        debug_assert!(end_ptr.sub(VECTOR_SIZE) >= start_ptr);\n        if slice.len() >= VECTOR_LOOP_SIZE {\n            while ptr <= ptr_sub(end_ptr, VECTOR_LOOP_SIZE) {\n                debug_assert_eq!(0, (ptr as usize) % VECTOR_SIZE);\n\n                let a = _mm_load_si128(ptr as *const __m128i);\n                let b = _mm_load_si128(ptr.add(VECTOR_SIZE) as *const __m128i);\n                let c =\n                    _mm_load_si128(ptr.add(2 * VECTOR_SIZE) as *const __m128i);\n                let d =\n                    _mm_load_si128(ptr.add(3 * VECTOR_SIZE) as *const __m128i);\n\n                let or1 = _mm_or_si128(a, b);\n                let or2 = _mm_or_si128(c, d);\n                let or3 = _mm_or_si128(or1, or2);\n                if _mm_movemask_epi8(or3) != 0 {\n                    let mut at = sub(ptr, start_ptr);\n                    let mask = _mm_movemask_epi8(a);\n                    if mask != 0 {\n                        return at + mask.trailing_zeros() as usize;\n                    }\n\n                    at += VECTOR_SIZE;\n                    let mask = _mm_movemask_epi8(b);\n                    if mask != 0 {\n                        return at + mask.trailing_zeros() as usize;\n                    }\n\n                    at += VECTOR_SIZE;\n                    let mask = _mm_movemask_epi8(c);\n                    if mask != 0 {\n                        return at + mask.trailing_zeros() as usize;\n                    }\n\n                    at += VECTOR_SIZE;\n                    let mask = _mm_movemask_epi8(d);\n                    debug_assert!(mask != 0);\n                    return at + mask.trailing_zeros() as usize;\n                }\n                ptr = ptr_add(ptr, VECTOR_LOOP_SIZE);\n            }\n        }\n        while ptr <= end_ptr.sub(VECTOR_SIZE) {\n            debug_assert!(sub(end_ptr, ptr) >= VECTOR_SIZE);\n\n            let chunk = _mm_loadu_si128(ptr as *const __m128i);\n            let mask = _mm_movemask_epi8(chunk);\n            if mask != 0 {\n                return sub(ptr, start_ptr) + mask.trailing_zeros() as usize;\n            }\n            ptr = ptr.add(VECTOR_SIZE);\n        }\n        first_non_ascii_byte_slow(start_ptr, end_ptr, ptr)\n    }\n}","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::ptr_add":["/// Increment the given pointer by the given amount.\nunsafe fn ptr_add(ptr: *const u8, amt: usize) -> *const u8{\n    debug_assert!(amt < ::core::isize::MAX as usize);\n    ptr.offset(amt as isize)\n}","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::ptr_sub":["/// Decrement the given pointer by the given amount.\nunsafe fn ptr_sub(ptr: *const u8, amt: usize) -> *const u8{\n    debug_assert!(amt < ::core::isize::MAX as usize);\n    ptr.offset((amt as isize).wrapping_neg())\n}","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::sub":["/// Subtract `b` from `a` and return the difference. `a` should be greater than\n/// or equal to `b`.\nfn sub(a: *const u8, b: *const u8) -> usize{\n    debug_assert!(a >= b);\n    (a as usize) - (b as usize)\n}","Real(LocalPath(\"src/ascii.rs\"))"],"bstr::BStr":["/// A wrapper for `&[u8]` that provides convenient string oriented trait impls.\n///\n/// If you need ownership or a growable byte string buffer, then use\n/// [`BString`](struct.BString.html).\n///\n/// Using a `&BStr` is just like using a `&[u8]`, since `BStr`\n/// implements `Deref` to `[u8]`. So all methods available on `[u8]`\n/// are also available on `BStr`.\n///\n/// # Representation\n///\n/// A `&BStr` has the same representation as a `&str`. That is, a `&BStr` is\n/// a fat pointer which consists of a pointer to some bytes and a length.\n///\n/// # Trait implementations\n///\n/// The `BStr` type has a number of trait implementations, and in particular,\n/// defines equality and ordinal comparisons between `&BStr`, `&str` and\n/// `&[u8]` for convenience.\n///\n/// The `Debug` implementation for `BStr` shows its bytes as a normal string.\n/// For invalid UTF-8, hex escape sequences are used.\n///\n/// The `Display` implementation behaves as if `BStr` were first lossily\n/// converted to a `str`. Invalid UTF-8 bytes are substituted with the Unicode\n/// replacement codepoint, which looks like this: �.\n#[repr(transparent)]\npub struct BStr {\n    pub(crate) bytes: [u8],\n}","Real(LocalPath(\"src/bstr.rs\"))"],"bstr::BStr::as_bytes":["#[inline]\npub(crate) fn as_bytes(&self) -> &[u8]{\n        &self.bytes\n    }","Real(LocalPath(\"src/bstr.rs\"))"],"bstr::BStr::from_boxed_bytes":["#[inline]\n#[cfg(feature = \"std\")]\npub(crate) fn from_boxed_bytes(slice: Box<[u8]>) -> Box<BStr>{\n        unsafe { Box::from_raw(Box::into_raw(slice) as _) }\n    }","Real(LocalPath(\"src/bstr.rs\"))"],"bstr::BStr::from_bytes":["#[inline]\npub(crate) fn from_bytes(slice: &[u8]) -> &BStr{\n        unsafe { mem::transmute(slice) }\n    }","Real(LocalPath(\"src/bstr.rs\"))"],"bstr::BStr::from_bytes_mut":["#[inline]\npub(crate) fn from_bytes_mut(slice: &mut [u8]) -> &mut BStr{\n        unsafe { mem::transmute(slice) }\n    }","Real(LocalPath(\"src/bstr.rs\"))"],"bstr::BStr::into_boxed_bytes":["#[inline]\n#[cfg(feature = \"std\")]\npub(crate) fn into_boxed_bytes(slice: Box<BStr>) -> Box<[u8]>{\n        unsafe { Box::from_raw(Box::into_raw(slice) as _) }\n    }","Real(LocalPath(\"src/bstr.rs\"))"],"bstr::BStr::new":["#[inline]\npub(crate) fn new<B: ?Sized + AsRef<[u8]>>(bytes: &B) -> &BStr{\n        BStr::from_bytes(bytes.as_ref())\n    }","Real(LocalPath(\"src/bstr.rs\"))"],"bstr::BStr::new_mut":["#[inline]\npub(crate) fn new_mut<B: ?Sized + AsMut<[u8]>>(\n        bytes: &mut B,\n    ) -> &mut BStr{\n        BStr::from_bytes_mut(bytes.as_mut())\n    }","Real(LocalPath(\"src/bstr.rs\"))"],"bstring::BString":["/// A wrapper for `Vec<u8>` that provides convenient string oriented trait\n/// impls.\n///\n/// A `BString` has ownership over its contents and corresponds to\n/// a growable or shrinkable buffer. Its borrowed counterpart is a\n/// [`BStr`](struct.BStr.html), called a byte string slice.\n///\n/// Using a `BString` is just like using a `Vec<u8>`, since `BString`\n/// implements `Deref` to `Vec<u8>`. So all methods available on `Vec<u8>`\n/// are also available on `BString`.\n///\n/// # Examples\n///\n/// You can create a new `BString` from a `Vec<u8>` via a `From` impl:\n///\n/// ```\n/// use bstr::BString;\n///\n/// let s = BString::from(\"Hello, world!\");\n/// ```\n///\n/// # Deref\n///\n/// The `BString` type implements `Deref` and `DerefMut`, where the target\n/// types are `&Vec<u8>` and `&mut Vec<u8>`, respectively. `Deref` permits all of the\n/// methods defined on `Vec<u8>` to be implicitly callable on any `BString`.\n///\n/// For more information about how deref works, see the documentation for the\n/// [`std::ops::Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)\n/// trait.\n///\n/// # Representation\n///\n/// A `BString` has the same representation as a `Vec<u8>` and a `String`.\n/// That is, it is made up of three word sized components: a pointer to a\n/// region of memory containing the bytes, a length and a capacity.\npub struct BString {\n    pub(crate) bytes: Vec<u8>,\n}","Real(LocalPath(\"src/bstring.rs\"))"],"bstring::BString::as_bstr":["#[inline]\npub(crate) fn as_bstr(&self) -> &BStr{\n        BStr::new(&self.bytes)\n    }","Real(LocalPath(\"src/bstring.rs\"))"],"bstring::BString::as_bytes":["#[inline]\npub(crate) fn as_bytes(&self) -> &[u8]{\n        &self.bytes\n    }","Real(LocalPath(\"src/bstring.rs\"))"],"bstring::BString::as_mut_bstr":["#[inline]\npub(crate) fn as_mut_bstr(&mut self) -> &mut BStr{\n        BStr::new_mut(&mut self.bytes)\n    }","Real(LocalPath(\"src/bstring.rs\"))"],"byteset::build_table":["#[inline]\nfn build_table(byteset: &[u8]) -> [u8; 256]{\n    let mut table = [0u8; 256];\n    for &b in byteset {\n        table[b as usize] = 1;\n    }\n    table\n}","Real(LocalPath(\"src/byteset/mod.rs\"))"],"byteset::find":["#[inline]\npub(crate) fn find(haystack: &[u8], byteset: &[u8]) -> Option<usize>{\n    match byteset.len() {\n        0 => return None,\n        1 => memchr(byteset[0], haystack),\n        2 => memchr2(byteset[0], byteset[1], haystack),\n        3 => memchr3(byteset[0], byteset[1], byteset[2], haystack),\n        _ => {\n            let table = build_table(byteset);\n            scalar::forward_search_bytes(haystack, |b| table[b as usize] != 0)\n        }\n    }\n}","Real(LocalPath(\"src/byteset/mod.rs\"))"],"byteset::find_not":["#[inline]\npub(crate) fn find_not(haystack: &[u8], byteset: &[u8]) -> Option<usize>{\n    if haystack.is_empty() {\n        return None;\n    }\n    match byteset.len() {\n        0 => return Some(0),\n        1 => scalar::inv_memchr(byteset[0], haystack),\n        2 => scalar::forward_search_bytes(haystack, |b| {\n            b != byteset[0] && b != byteset[1]\n        }),\n        3 => scalar::forward_search_bytes(haystack, |b| {\n            b != byteset[0] && b != byteset[1] && b != byteset[2]\n        }),\n        _ => {\n            let table = build_table(byteset);\n            scalar::forward_search_bytes(haystack, |b| table[b as usize] == 0)\n        }\n    }\n}","Real(LocalPath(\"src/byteset/mod.rs\"))"],"byteset::rfind":["#[inline]\npub(crate) fn rfind(haystack: &[u8], byteset: &[u8]) -> Option<usize>{\n    match byteset.len() {\n        0 => return None,\n        1 => memrchr(byteset[0], haystack),\n        2 => memrchr2(byteset[0], byteset[1], haystack),\n        3 => memrchr3(byteset[0], byteset[1], byteset[2], haystack),\n        _ => {\n            let table = build_table(byteset);\n            scalar::reverse_search_bytes(haystack, |b| table[b as usize] != 0)\n        }\n    }\n}","Real(LocalPath(\"src/byteset/mod.rs\"))"],"byteset::rfind_not":["#[inline]\npub(crate) fn rfind_not(haystack: &[u8], byteset: &[u8]) -> Option<usize>{\n    if haystack.is_empty() {\n        return None;\n    }\n    match byteset.len() {\n        0 => return Some(haystack.len() - 1),\n        1 => scalar::inv_memrchr(byteset[0], haystack),\n        2 => scalar::reverse_search_bytes(haystack, |b| {\n            b != byteset[0] && b != byteset[1]\n        }),\n        3 => scalar::reverse_search_bytes(haystack, |b| {\n            b != byteset[0] && b != byteset[1] && b != byteset[2]\n        }),\n        _ => {\n            let table = build_table(byteset);\n            scalar::reverse_search_bytes(haystack, |b| table[b as usize] == 0)\n        }\n    }\n}","Real(LocalPath(\"src/byteset/mod.rs\"))"],"byteset::scalar::forward_search":["#[inline(always)]\nunsafe fn forward_search<F: Fn(u8) -> bool>(\n    start_ptr: *const u8,\n    end_ptr: *const u8,\n    mut ptr: *const u8,\n    confirm: F,\n) -> Option<usize>{\n    debug_assert!(start_ptr <= ptr);\n    debug_assert!(ptr <= end_ptr);\n\n    while ptr < end_ptr {\n        if confirm(*ptr) {\n            return Some(sub(ptr, start_ptr));\n        }\n        ptr = ptr.offset(1);\n    }\n    None\n}","Real(LocalPath(\"src/byteset/scalar.rs\"))"],"byteset::scalar::forward_search_bytes":["/// Safe wrapper around `forward_search`\n#[inline]\npub(crate) fn forward_search_bytes<F: Fn(u8) -> bool>(\n    s: &[u8],\n    confirm: F,\n) -> Option<usize>{\n    unsafe {\n        let start = s.as_ptr();\n        let end = start.add(s.len());\n        forward_search(start, end, start, confirm)\n    }\n}","Real(LocalPath(\"src/byteset/scalar.rs\"))"],"byteset::scalar::inv_memchr":["pub fn inv_memchr(n1: u8, haystack: &[u8]) -> Option<usize>{\n    let vn1 = repeat_byte(n1);\n    let confirm = |byte| byte != n1;\n    let loop_size = cmp::min(LOOP_SIZE, haystack.len());\n    let align = USIZE_BYTES - 1;\n    let start_ptr = haystack.as_ptr();\n    let end_ptr = haystack[haystack.len()..].as_ptr();\n    let mut ptr = start_ptr;\n\n    unsafe {\n        if haystack.len() < USIZE_BYTES {\n            return forward_search(start_ptr, end_ptr, ptr, confirm);\n        }\n\n        let chunk = read_unaligned_usize(ptr);\n        if (chunk ^ vn1) != 0 {\n            return forward_search(start_ptr, end_ptr, ptr, confirm);\n        }\n\n        ptr = ptr.add(USIZE_BYTES - (start_ptr as usize & align));\n        debug_assert!(ptr > start_ptr);\n        debug_assert!(end_ptr.sub(USIZE_BYTES) >= start_ptr);\n        while loop_size == LOOP_SIZE && ptr <= end_ptr.sub(loop_size) {\n            debug_assert_eq!(0, (ptr as usize) % USIZE_BYTES);\n\n            let a = *(ptr as *const usize);\n            let b = *(ptr.add(USIZE_BYTES) as *const usize);\n            let eqa = (a ^ vn1) != 0;\n            let eqb = (b ^ vn1) != 0;\n            if eqa || eqb {\n                break;\n            }\n            ptr = ptr.add(LOOP_SIZE);\n        }\n        forward_search(start_ptr, end_ptr, ptr, confirm)\n    }\n}","Real(LocalPath(\"src/byteset/scalar.rs\"))"],"byteset::scalar::inv_memrchr":["/// Return the last index not matching the byte `x` in `text`.\npub fn inv_memrchr(n1: u8, haystack: &[u8]) -> Option<usize>{\n    let vn1 = repeat_byte(n1);\n    let confirm = |byte| byte != n1;\n    let loop_size = cmp::min(LOOP_SIZE, haystack.len());\n    let align = USIZE_BYTES - 1;\n    let start_ptr = haystack.as_ptr();\n    let end_ptr = haystack[haystack.len()..].as_ptr();\n    let mut ptr = end_ptr;\n\n    unsafe {\n        if haystack.len() < USIZE_BYTES {\n            return reverse_search(start_ptr, end_ptr, ptr, confirm);\n        }\n\n        let chunk = read_unaligned_usize(ptr.sub(USIZE_BYTES));\n        if (chunk ^ vn1) != 0 {\n            return reverse_search(start_ptr, end_ptr, ptr, confirm);\n        }\n\n        ptr = (end_ptr as usize & !align) as *const u8;\n        debug_assert!(start_ptr <= ptr && ptr <= end_ptr);\n        while loop_size == LOOP_SIZE && ptr >= start_ptr.add(loop_size) {\n            debug_assert_eq!(0, (ptr as usize) % USIZE_BYTES);\n\n            let a = *(ptr.sub(2 * USIZE_BYTES) as *const usize);\n            let b = *(ptr.sub(1 * USIZE_BYTES) as *const usize);\n            let eqa = (a ^ vn1) != 0;\n            let eqb = (b ^ vn1) != 0;\n            if eqa || eqb {\n                break;\n            }\n            ptr = ptr.sub(loop_size);\n        }\n        reverse_search(start_ptr, end_ptr, ptr, confirm)\n    }\n}","Real(LocalPath(\"src/byteset/scalar.rs\"))"],"byteset::scalar::read_unaligned_usize":["unsafe fn read_unaligned_usize(ptr: *const u8) -> usize{\n    (ptr as *const usize).read_unaligned()\n}","Real(LocalPath(\"src/byteset/scalar.rs\"))"],"byteset::scalar::repeat_byte":["/// Repeat the given byte into a word size number. That is, every 8 bits\n/// is equivalent to the given byte. For example, if `b` is `\\x4E` or\n/// `01001110` in binary, then the returned value on a 32-bit system would be:\n/// `01001110_01001110_01001110_01001110`.\n#[inline(always)]\nfn repeat_byte(b: u8) -> usize{\n    (b as usize) * (usize::MAX / 255)\n}","Real(LocalPath(\"src/byteset/scalar.rs\"))"],"byteset::scalar::reverse_search":["#[inline(always)]\nunsafe fn reverse_search<F: Fn(u8) -> bool>(\n    start_ptr: *const u8,\n    end_ptr: *const u8,\n    mut ptr: *const u8,\n    confirm: F,\n) -> Option<usize>{\n    debug_assert!(start_ptr <= ptr);\n    debug_assert!(ptr <= end_ptr);\n\n    while ptr > start_ptr {\n        ptr = ptr.offset(-1);\n        if confirm(*ptr) {\n            return Some(sub(ptr, start_ptr));\n        }\n    }\n    None\n}","Real(LocalPath(\"src/byteset/scalar.rs\"))"],"byteset::scalar::reverse_search_bytes":["/// Safe wrapper around `reverse_search`\n#[inline]\npub(crate) fn reverse_search_bytes<F: Fn(u8) -> bool>(\n    s: &[u8],\n    confirm: F,\n) -> Option<usize>{\n    unsafe {\n        let start = s.as_ptr();\n        let end = start.add(s.len());\n        reverse_search(start, end, end, confirm)\n    }\n}","Real(LocalPath(\"src/byteset/scalar.rs\"))"],"byteset::scalar::sub":["/// Subtract `b` from `a` and return the difference. `a` should be greater than\n/// or equal to `b`.\nfn sub(a: *const u8, b: *const u8) -> usize{\n    debug_assert!(a >= b);\n    (a as usize) - (b as usize)\n}","Real(LocalPath(\"src/byteset/scalar.rs\"))"],"cow::CowBytes":["/// A specialized copy-on-write byte string.\n///\n/// The purpose of this type is to permit usage of a \"borrowed or owned\n/// byte string\" in a way that keeps std/no-std compatibility. That is, in\n/// no-std mode, this type devolves into a simple &[u8] with no owned variant\n/// availble.\npub struct CowBytes<'a>(Imp<'a>);","Real(LocalPath(\"src/cow.rs\"))"],"cow::CowBytes::<'a>::as_slice":["/// Return a borrowed byte string, regardless of whether this is an owned\n/// or borrowed byte string internally.\npub fn as_slice(&self) -> &[u8]{\n        self.0.as_slice()\n    }","Real(LocalPath(\"src/cow.rs\"))"],"cow::CowBytes::<'a>::into_owned":["/// Return an owned version of this copy-on-write byte string.\n///\n/// If this is already an owned byte string internally, then this is a\n/// no-op. Otherwise, the internal byte string is copied.\n#[cfg(feature = \"std\")]\npub fn into_owned(self) -> CowBytes<'static>{\n        match (self.0).0 {\n            Cow::Borrowed(b) => CowBytes::new_owned(b.to_vec()),\n            Cow::Owned(b) => CowBytes::new_owned(b),\n        }\n    }","Real(LocalPath(\"src/cow.rs\"))"],"cow::CowBytes::<'a>::new":["/// Create a new borrowed CowBytes.\npub fn new<B: ?Sized + AsRef<[u8]>>(bytes: &'a B) -> CowBytes<'a>{\n        CowBytes(Imp::new(bytes.as_ref()))\n    }","Real(LocalPath(\"src/cow.rs\"))"],"cow::CowBytes::<'a>::new_owned":["/// Create a new owned CowBytes.\n#[cfg(feature = \"std\")]\npub fn new_owned(bytes: Vec<u8>) -> CowBytes<'static>{\n        CowBytes(Imp(Cow::Owned(bytes)))\n    }","Real(LocalPath(\"src/cow.rs\"))"],"cow::Imp":["#[cfg(feature = \"std\")]\nstruct Imp<'a>(Cow<'a, [u8]>);","Real(LocalPath(\"src/cow.rs\"))"],"cow::Imp::<'a>::as_slice":["#[cfg(feature = \"std\")]\npub fn as_slice(&self) -> &[u8]{\n        match self.0 {\n            Cow::Owned(ref x) => x,\n            Cow::Borrowed(x) => x,\n        }\n    }","Real(LocalPath(\"src/cow.rs\"))"],"cow::Imp::<'a>::new":["#[cfg(feature = \"std\")]\npub fn new(bytes: &'a [u8]) -> Imp<'a>{\n        Imp(Cow::Borrowed(bytes))\n    }","Real(LocalPath(\"src/cow.rs\"))"],"ext_slice::B":["/// A short-hand constructor for building a `&[u8]`.\n///\n/// This idiosyncratic constructor is useful for concisely building byte string\n/// slices. Its primary utility is in conveniently writing byte string literals\n/// in a uniform way. For example, consider this code that does not compile:\n///\n/// ```ignore\n/// let strs = vec![b\"a\", b\"xy\"];\n/// ```\n///\n/// The above code doesn't compile because the type of the byte string literal\n/// `b\"a\"` is `&'static [u8; 1]`, and the type of `b\"xy\"` is\n/// `&'static [u8; 2]`. Since their types aren't the same, they can't be stored\n/// in the same `Vec`. (This is dissimilar from normal Unicode string slices,\n/// where both `\"a\"` and `\"xy\"` have the same type of `&'static str`.)\n///\n/// One way of getting the above code to compile is to convert byte strings to\n/// slices. You might try this:\n///\n/// ```ignore\n/// let strs = vec![&b\"a\", &b\"xy\"];\n/// ```\n///\n/// But this just creates values with type `& &'static [u8; 1]` and\n/// `& &'static [u8; 2]`. Instead, you need to force the issue like so:\n///\n/// ```\n/// let strs = vec![&b\"a\"[..], &b\"xy\"[..]];\n/// // or\n/// let strs = vec![b\"a\".as_ref(), b\"xy\".as_ref()];\n/// ```\n///\n/// But neither of these are particularly convenient to type, especially when\n/// it's something as common as a string literal. Thus, this constructor\n/// permits writing the following instead:\n///\n/// ```\n/// use bstr::B;\n///\n/// let strs = vec![B(\"a\"), B(b\"xy\")];\n/// ```\n///\n/// Notice that this also lets you mix and match both string literals and byte\n/// string literals. This can be quite convenient!\n#[allow(non_snake_case)]\n#[inline]\npub fn B<'a, B: ?Sized + AsRef<[u8]>>(bytes: &'a B) -> &'a [u8]{\n    bytes.as_ref()\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice":["/// A trait that extends `&[u8]` with string oriented methods.\npub trait ByteSlice: Sealed {\n    /// A method for accessing the raw bytes of this type. This is always a\n    /// no-op and callers shouldn't care about it. This only exists for making\n    /// the extension trait work.\n    #[doc(hidden)]\n    fn as_bytes(&self) -> &[u8];\n\n    /// A method for accessing the raw bytes of this type, mutably. This is\n    /// always a no-op and callers shouldn't care about it. This only exists\n    /// for making the extension trait work.\n    #[doc(hidden)]\n    fn as_bytes_mut(&mut self) -> &mut [u8];\n\n    /// Return this byte slice as a `&BStr`.\n    ///\n    /// Use `&BStr` is useful because of its `fmt::Debug` representation\n    /// and various other trait implementations (such as `PartialEq` and\n    /// `PartialOrd`). In particular, the `Debug` implementation for `BStr`\n    /// shows its bytes as a normal string. For invalid UTF-8, hex escape\n    /// sequences are used.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// println!(\"{:?}\", b\"foo\\xFFbar\".as_bstr());\n    /// ```\n    #[inline]\n    fn as_bstr(&self) -> &BStr {\n        BStr::new(self.as_bytes())\n    }\n\n    /// Return this byte slice as a `&mut BStr`.\n    ///\n    /// Use `&mut BStr` is useful because of its `fmt::Debug` representation\n    /// and various other trait implementations (such as `PartialEq` and\n    /// `PartialOrd`). In particular, the `Debug` implementation for `BStr`\n    /// shows its bytes as a normal string. For invalid UTF-8, hex escape\n    /// sequences are used.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut bytes = *b\"foo\\xFFbar\";\n    /// println!(\"{:?}\", &mut bytes.as_bstr_mut());\n    /// ```\n    #[inline]\n    fn as_bstr_mut(&mut self) -> &mut BStr {\n        BStr::new_mut(self.as_bytes_mut())\n    }\n\n    /// Create an immutable byte string from an OS string slice.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this returns `None` if the given OS string is not valid UTF-8. (For\n    /// example, on Windows, file paths are allowed to be a sequence of\n    /// arbitrary 16-bit integers. Not all such sequences can be transcoded to\n    /// valid UTF-8.)\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// let bs = <[u8]>::from_os_str(os_str).expect(\"should be valid UTF-8\");\n    /// assert_eq!(bs, B(\"foo\"));\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn from_os_str(os_str: &OsStr) -> Option<&[u8]> {\n        #[cfg(unix)]\n        #[inline]\n        fn imp(os_str: &OsStr) -> Option<&[u8]> {\n            use std::os::unix::ffi::OsStrExt;\n\n            Some(os_str.as_bytes())\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(os_str: &OsStr) -> Option<&[u8]> {\n            os_str.to_str().map(|s| s.as_bytes())\n        }\n\n        imp(os_str)\n    }\n\n    /// Create an immutable byte string from a file path.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this returns `None` if the given path is not valid UTF-8. (For example,\n    /// on Windows, file paths are allowed to be a sequence of arbitrary 16-bit\n    /// integers. Not all such sequences can be transcoded to valid UTF-8.)\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let path = Path::new(\"foo\");\n    /// let bs = <[u8]>::from_path(path).expect(\"should be valid UTF-8\");\n    /// assert_eq!(bs, B(\"foo\"));\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn from_path(path: &Path) -> Option<&[u8]> {\n        Self::from_os_str(path.as_os_str())\n    }\n\n    /// Safely convert this byte string into a `&str` if it's valid UTF-8.\n    ///\n    /// If this byte string is not valid UTF-8, then an error is returned. The\n    /// error returned indicates the first invalid byte found and the length\n    /// of the error.\n    ///\n    /// In cases where a lossy conversion to `&str` is acceptable, then use one\n    /// of the [`to_str_lossy`](trait.ByteSlice.html#method.to_str_lossy) or\n    /// [`to_str_lossy_into`](trait.ByteSlice.html#method.to_str_lossy_into)\n    /// methods.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice, ByteVec};\n    ///\n    /// # fn example() -> Result<(), bstr::Utf8Error> {\n    /// let s = B(\"☃βツ\").to_str()?;\n    /// assert_eq!(\"☃βツ\", s);\n    ///\n    /// let mut bstring = <Vec<u8>>::from(\"☃βツ\");\n    /// bstring.push(b'\\xFF');\n    /// let err = bstring.to_str().unwrap_err();\n    /// assert_eq!(8, err.valid_up_to());\n    /// # Ok(()) }; example().unwrap()\n    /// ```\n    #[inline]\n    fn to_str(&self) -> Result<&str, Utf8Error> {\n        utf8::validate(self.as_bytes()).map(|_| {\n            // SAFETY: This is safe because of the guarantees provided by\n            // utf8::validate.\n            unsafe { str::from_utf8_unchecked(self.as_bytes()) }\n        })\n    }\n\n    /// Unsafely convert this byte string into a `&str`, without checking for\n    /// valid UTF-8.\n    ///\n    /// # Safety\n    ///\n    /// Callers *must* ensure that this byte string is valid UTF-8 before\n    /// calling this method. Converting a byte string into a `&str` that is\n    /// not valid UTF-8 is considered undefined behavior.\n    ///\n    /// This routine is useful in performance sensitive contexts where the\n    /// UTF-8 validity of the byte string is already known and it is\n    /// undesirable to pay the cost of an additional UTF-8 validation check\n    /// that [`to_str`](trait.ByteSlice.html#method.to_str) performs.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// // SAFETY: This is safe because string literals are guaranteed to be\n    /// // valid UTF-8 by the Rust compiler.\n    /// let s = unsafe { B(\"☃βツ\").to_str_unchecked() };\n    /// assert_eq!(\"☃βツ\", s);\n    /// ```\n    #[inline]\n    unsafe fn to_str_unchecked(&self) -> &str {\n        str::from_utf8_unchecked(self.as_bytes())\n    }\n\n    /// Convert this byte string to a valid UTF-8 string by replacing invalid\n    /// UTF-8 bytes with the Unicode replacement codepoint (`U+FFFD`).\n    ///\n    /// If the byte string is already valid UTF-8, then no copying or\n    /// allocation is performed and a borrrowed string slice is returned. If\n    /// the byte string is not valid UTF-8, then an owned string buffer is\n    /// returned with invalid bytes replaced by the replacement codepoint.\n    ///\n    /// This method uses the \"substitution of maximal subparts\" (Unicode\n    /// Standard, Chapter 3, Section 9) strategy for inserting the replacement\n    /// codepoint. Specifically, a replacement codepoint is inserted whenever a\n    /// byte is found that cannot possibly lead to a valid code unit sequence.\n    /// If there were previous bytes that represented a prefix of a well-formed\n    /// code unit sequence, then all of those bytes are substituted with a\n    /// single replacement codepoint. The \"substitution of maximal subparts\"\n    /// strategy is the same strategy used by\n    /// [W3C's Encoding standard](https://www.w3.org/TR/encoding/).\n    /// For a more precise description of the maximal subpart strategy, see\n    /// the Unicode Standard, Chapter 3, Section 9. See also\n    /// [Public Review Issue #121](http://www.unicode.org/review/pr-121.html).\n    ///\n    /// N.B. Rust's standard library also appears to use the same strategy,\n    /// but it does not appear to be an API guarantee.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    ///\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut bstring = <Vec<u8>>::from(\"☃βツ\");\n    /// assert_eq!(Cow::Borrowed(\"☃βツ\"), bstring.to_str_lossy());\n    ///\n    /// // Add a byte that makes the sequence invalid.\n    /// bstring.push(b'\\xFF');\n    /// assert_eq!(Cow::Borrowed(\"☃βツ\\u{FFFD}\"), bstring.to_str_lossy());\n    /// ```\n    ///\n    /// This demonstrates the \"maximal subpart\" substitution logic.\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// // \\x61 is the ASCII codepoint for 'a'.\n    /// // \\xF1\\x80\\x80 is a valid 3-byte code unit prefix.\n    /// // \\xE1\\x80 is a valid 2-byte code unit prefix.\n    /// // \\xC2 is a valid 1-byte code unit prefix.\n    /// // \\x62 is the ASCII codepoint for 'b'.\n    /// //\n    /// // In sum, each of the prefixes is replaced by a single replacement\n    /// // codepoint since none of the prefixes are properly completed. This\n    /// // is in contrast to other strategies that might insert a replacement\n    /// // codepoint for every single byte.\n    /// let bs = B(b\"\\x61\\xF1\\x80\\x80\\xE1\\x80\\xC2\\x62\");\n    /// assert_eq!(\"a\\u{FFFD}\\u{FFFD}\\u{FFFD}b\", bs.to_str_lossy());\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn to_str_lossy(&self) -> Cow<str> {\n        match utf8::validate(self.as_bytes()) {\n            Ok(()) => {\n                // SAFETY: This is safe because of the guarantees provided by\n                // utf8::validate.\n                unsafe {\n                    Cow::Borrowed(str::from_utf8_unchecked(self.as_bytes()))\n                }\n            }\n            Err(err) => {\n                let mut lossy = String::with_capacity(self.as_bytes().len());\n                let (valid, after) =\n                    self.as_bytes().split_at(err.valid_up_to());\n                // SAFETY: This is safe because utf8::validate guarantees\n                // that all of `valid` is valid UTF-8.\n                lossy.push_str(unsafe { str::from_utf8_unchecked(valid) });\n                lossy.push_str(\"\\u{FFFD}\");\n                if let Some(len) = err.error_len() {\n                    after[len..].to_str_lossy_into(&mut lossy);\n                }\n                Cow::Owned(lossy)\n            }\n        }\n    }\n\n    /// Copy the contents of this byte string into the given owned string\n    /// buffer, while replacing invalid UTF-8 code unit sequences with the\n    /// Unicode replacement codepoint (`U+FFFD`).\n    ///\n    /// This method uses the same \"substitution of maximal subparts\" strategy\n    /// for inserting the replacement codepoint as the\n    /// [`to_str_lossy`](trait.ByteSlice.html#method.to_str_lossy) method.\n    ///\n    /// This routine is useful for amortizing allocation. However, unlike\n    /// `to_str_lossy`, this routine will _always_ copy the contents of this\n    /// byte string into the destination buffer, even if this byte string is\n    /// valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    ///\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut bstring = <Vec<u8>>::from(\"☃βツ\");\n    /// // Add a byte that makes the sequence invalid.\n    /// bstring.push(b'\\xFF');\n    ///\n    /// let mut dest = String::new();\n    /// bstring.to_str_lossy_into(&mut dest);\n    /// assert_eq!(\"☃βツ\\u{FFFD}\", dest);\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn to_str_lossy_into(&self, dest: &mut String) {\n        let mut bytes = self.as_bytes();\n        dest.reserve(bytes.len());\n        loop {\n            match utf8::validate(bytes) {\n                Ok(()) => {\n                    // SAFETY: This is safe because utf8::validate guarantees\n                    // that all of `bytes` is valid UTF-8.\n                    dest.push_str(unsafe { str::from_utf8_unchecked(bytes) });\n                    break;\n                }\n                Err(err) => {\n                    let (valid, after) = bytes.split_at(err.valid_up_to());\n                    // SAFETY: This is safe because utf8::validate guarantees\n                    // that all of `valid` is valid UTF-8.\n                    dest.push_str(unsafe { str::from_utf8_unchecked(valid) });\n                    dest.push_str(\"\\u{FFFD}\");\n                    match err.error_len() {\n                        None => break,\n                        Some(len) => bytes = &after[len..],\n                    }\n                }\n            }\n        }\n    }\n\n    /// Create an OS string slice from this byte string.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this returns a UTF-8 decoding error if this byte string is not valid\n    /// UTF-8. (For example, on Windows, file paths are allowed to be a\n    /// sequence of arbitrary 16-bit integers. There is no obvious mapping from\n    /// an arbitrary sequence of 8-bit integers to an arbitrary sequence of\n    /// 16-bit integers.)\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let os_str = b\"foo\".to_os_str().expect(\"should be valid UTF-8\");\n    /// assert_eq!(os_str, \"foo\");\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn to_os_str(&self) -> Result<&OsStr, Utf8Error> {\n        #[cfg(unix)]\n        #[inline]\n        fn imp(bytes: &[u8]) -> Result<&OsStr, Utf8Error> {\n            use std::os::unix::ffi::OsStrExt;\n\n            Ok(OsStr::from_bytes(bytes))\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(bytes: &[u8]) -> Result<&OsStr, Utf8Error> {\n            bytes.to_str().map(OsStr::new)\n        }\n\n        imp(self.as_bytes())\n    }\n\n    /// Lossily create an OS string slice from this byte string.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this will perform a UTF-8 check and lossily convert this byte string\n    /// into valid UTF-8 using the Unicode replacement codepoint.\n    ///\n    /// Note that this can prevent the correct roundtripping of file paths on\n    /// non-Unix systems such as Windows, where file paths are an arbitrary\n    /// sequence of 16-bit integers.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let os_str = b\"foo\\xFFbar\".to_os_str_lossy();\n    /// assert_eq!(os_str.to_string_lossy(), \"foo\\u{FFFD}bar\");\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn to_os_str_lossy(&self) -> Cow<OsStr> {\n        #[cfg(unix)]\n        #[inline]\n        fn imp(bytes: &[u8]) -> Cow<OsStr> {\n            use std::os::unix::ffi::OsStrExt;\n\n            Cow::Borrowed(OsStr::from_bytes(bytes))\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(bytes: &[u8]) -> Cow<OsStr> {\n            use std::ffi::OsString;\n\n            match bytes.to_str_lossy() {\n                Cow::Borrowed(x) => Cow::Borrowed(OsStr::new(x)),\n                Cow::Owned(x) => Cow::Owned(OsString::from(x)),\n            }\n        }\n\n        imp(self.as_bytes())\n    }\n\n    /// Create a path slice from this byte string.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this returns a UTF-8 decoding error if this byte string is not valid\n    /// UTF-8. (For example, on Windows, file paths are allowed to be a\n    /// sequence of arbitrary 16-bit integers. There is no obvious mapping from\n    /// an arbitrary sequence of 8-bit integers to an arbitrary sequence of\n    /// 16-bit integers.)\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let path = b\"foo\".to_path().expect(\"should be valid UTF-8\");\n    /// assert_eq!(path.as_os_str(), \"foo\");\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn to_path(&self) -> Result<&Path, Utf8Error> {\n        self.to_os_str().map(Path::new)\n    }\n\n    /// Lossily create a path slice from this byte string.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this will perform a UTF-8 check and lossily convert this byte string\n    /// into valid UTF-8 using the Unicode replacement codepoint.\n    ///\n    /// Note that this can prevent the correct roundtripping of file paths on\n    /// non-Unix systems such as Windows, where file paths are an arbitrary\n    /// sequence of 16-bit integers.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = b\"foo\\xFFbar\";\n    /// let path = bs.to_path_lossy();\n    /// assert_eq!(path.to_string_lossy(), \"foo\\u{FFFD}bar\");\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn to_path_lossy(&self) -> Cow<Path> {\n        use std::path::PathBuf;\n\n        match self.to_os_str_lossy() {\n            Cow::Borrowed(x) => Cow::Borrowed(Path::new(x)),\n            Cow::Owned(x) => Cow::Owned(PathBuf::from(x)),\n        }\n    }\n\n    /// Create a new byte string by repeating this byte string `n` times.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the capacity of the new byte string would\n    /// overflow.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// assert_eq!(b\"foo\".repeatn(4), B(\"foofoofoofoo\"));\n    /// assert_eq!(b\"foo\".repeatn(0), B(\"\"));\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn repeatn(&self, n: usize) -> Vec<u8> {\n        let bs = self.as_bytes();\n        let mut dst = vec![0; bs.len() * n];\n        for i in 0..n {\n            dst[i * bs.len()..(i + 1) * bs.len()].copy_from_slice(bs);\n        }\n        dst\n    }\n\n    /// Returns true if and only if this byte string contains the given needle.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// assert!(b\"foo bar\".contains_str(\"foo\"));\n    /// assert!(b\"foo bar\".contains_str(\"bar\"));\n    /// assert!(!b\"foo\".contains_str(\"foobar\"));\n    /// ```\n    #[inline]\n    fn contains_str<B: AsRef<[u8]>>(&self, needle: B) -> bool {\n        self.find(needle).is_some()\n    }\n\n    /// Returns true if and only if this byte string has the given prefix.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// assert!(b\"foo bar\".starts_with_str(\"foo\"));\n    /// assert!(!b\"foo bar\".starts_with_str(\"bar\"));\n    /// assert!(!b\"foo\".starts_with_str(\"foobar\"));\n    /// ```\n    #[inline]\n    fn starts_with_str<B: AsRef<[u8]>>(&self, prefix: B) -> bool {\n        self.as_bytes().starts_with(prefix.as_ref())\n    }\n\n    /// Returns true if and only if this byte string has the given suffix.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// assert!(b\"foo bar\".ends_with_str(\"bar\"));\n    /// assert!(!b\"foo bar\".ends_with_str(\"foo\"));\n    /// assert!(!b\"bar\".ends_with_str(\"foobar\"));\n    /// ```\n    #[inline]\n    fn ends_with_str<B: AsRef<[u8]>>(&self, suffix: B) -> bool {\n        self.as_bytes().ends_with(suffix.as_ref())\n    }\n\n    /// Returns the index of the first occurrence of the given needle.\n    ///\n    /// The needle may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n    ///\n    /// Note that if you're are searching for the same needle in many\n    /// different small haystacks, it may be faster to initialize a\n    /// [`Finder`](struct.Finder.html) once, and reuse it for each search.\n    ///\n    /// # Complexity\n    ///\n    /// This routine is guaranteed to have worst case linear time complexity\n    /// with respect to both the needle and the haystack. That is, this runs\n    /// in `O(needle.len() + haystack.len())` time.\n    ///\n    /// This routine is also guaranteed to have worst case constant space\n    /// complexity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foo bar baz\";\n    /// assert_eq!(Some(0), s.find(\"foo\"));\n    /// assert_eq!(Some(4), s.find(\"bar\"));\n    /// assert_eq!(None, s.find(\"quux\"));\n    /// ```\n    #[inline]\n    fn find<B: AsRef<[u8]>>(&self, needle: B) -> Option<usize> {\n        Finder::new(needle.as_ref()).find(self.as_bytes())\n    }\n\n    /// Returns the index of the last occurrence of the given needle.\n    ///\n    /// The needle may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n    ///\n    /// Note that if you're are searching for the same needle in many\n    /// different small haystacks, it may be faster to initialize a\n    /// [`FinderReverse`](struct.FinderReverse.html) once, and reuse it for\n    /// each search.\n    ///\n    /// # Complexity\n    ///\n    /// This routine is guaranteed to have worst case linear time complexity\n    /// with respect to both the needle and the haystack. That is, this runs\n    /// in `O(needle.len() + haystack.len())` time.\n    ///\n    /// This routine is also guaranteed to have worst case constant space\n    /// complexity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foo bar baz\";\n    /// assert_eq!(Some(0), s.rfind(\"foo\"));\n    /// assert_eq!(Some(4), s.rfind(\"bar\"));\n    /// assert_eq!(Some(8), s.rfind(\"ba\"));\n    /// assert_eq!(None, s.rfind(\"quux\"));\n    /// ```\n    #[inline]\n    fn rfind<B: AsRef<[u8]>>(&self, needle: B) -> Option<usize> {\n        FinderReverse::new(needle.as_ref()).rfind(self.as_bytes())\n    }\n\n    /// Returns an iterator of the non-overlapping occurrences of the given\n    /// needle. The iterator yields byte offset positions indicating the start\n    /// of each match.\n    ///\n    /// # Complexity\n    ///\n    /// This routine is guaranteed to have worst case linear time complexity\n    /// with respect to both the needle and the haystack. That is, this runs\n    /// in `O(needle.len() + haystack.len())` time.\n    ///\n    /// This routine is also guaranteed to have worst case constant space\n    /// complexity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foo bar foo foo quux foo\";\n    /// let matches: Vec<usize> = s.find_iter(\"foo\").collect();\n    /// assert_eq!(matches, vec![0, 8, 12, 21]);\n    /// ```\n    ///\n    /// An empty string matches at every position, including the position\n    /// immediately following the last byte:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let matches: Vec<usize> = b\"foo\".find_iter(\"\").collect();\n    /// assert_eq!(matches, vec![0, 1, 2, 3]);\n    ///\n    /// let matches: Vec<usize> = b\"\".find_iter(\"\").collect();\n    /// assert_eq!(matches, vec![0]);\n    /// ```\n    #[inline]\n    fn find_iter<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        needle: &'a B,\n    ) -> Find<'a> {\n        Find::new(self.as_bytes(), needle.as_ref())\n    }\n\n    /// Returns an iterator of the non-overlapping occurrences of the given\n    /// needle in reverse. The iterator yields byte offset positions indicating\n    /// the start of each match.\n    ///\n    /// # Complexity\n    ///\n    /// This routine is guaranteed to have worst case linear time complexity\n    /// with respect to both the needle and the haystack. That is, this runs\n    /// in `O(needle.len() + haystack.len())` time.\n    ///\n    /// This routine is also guaranteed to have worst case constant space\n    /// complexity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foo bar foo foo quux foo\";\n    /// let matches: Vec<usize> = s.rfind_iter(\"foo\").collect();\n    /// assert_eq!(matches, vec![21, 12, 8, 0]);\n    /// ```\n    ///\n    /// An empty string matches at every position, including the position\n    /// immediately following the last byte:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let matches: Vec<usize> = b\"foo\".rfind_iter(\"\").collect();\n    /// assert_eq!(matches, vec![3, 2, 1, 0]);\n    ///\n    /// let matches: Vec<usize> = b\"\".rfind_iter(\"\").collect();\n    /// assert_eq!(matches, vec![0]);\n    /// ```\n    #[inline]\n    fn rfind_iter<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        needle: &'a B,\n    ) -> FindReverse<'a> {\n        FindReverse::new(self.as_bytes(), needle.as_ref())\n    }\n\n    /// Returns the index of the first occurrence of the given byte. If the\n    /// byte does not occur in this byte string, then `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// assert_eq!(Some(10), b\"foo bar baz\".find_byte(b'z'));\n    /// assert_eq!(None, b\"foo bar baz\".find_byte(b'y'));\n    /// ```\n    #[inline]\n    fn find_byte(&self, byte: u8) -> Option<usize> {\n        memchr(byte, self.as_bytes())\n    }\n\n    /// Returns the index of the last occurrence of the given byte. If the\n    /// byte does not occur in this byte string, then `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// assert_eq!(Some(10), b\"foo bar baz\".rfind_byte(b'z'));\n    /// assert_eq!(None, b\"foo bar baz\".rfind_byte(b'y'));\n    /// ```\n    #[inline]\n    fn rfind_byte(&self, byte: u8) -> Option<usize> {\n        memrchr(byte, self.as_bytes())\n    }\n\n    /// Returns the index of the first occurrence of the given codepoint.\n    /// If the codepoint does not occur in this byte string, then `None` is\n    /// returned.\n    ///\n    /// Note that if one searches for the replacement codepoint, `\\u{FFFD}`,\n    /// then only explicit occurrences of that encoding will be found. Invalid\n    /// UTF-8 sequences will not be matched.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// assert_eq!(Some(10), b\"foo bar baz\".find_char('z'));\n    /// assert_eq!(Some(4), B(\"αβγγδ\").find_char('γ'));\n    /// assert_eq!(None, b\"foo bar baz\".find_char('y'));\n    /// ```\n    #[inline]\n    fn find_char(&self, ch: char) -> Option<usize> {\n        self.find(ch.encode_utf8(&mut [0; 4]))\n    }\n\n    /// Returns the index of the last occurrence of the given codepoint.\n    /// If the codepoint does not occur in this byte string, then `None` is\n    /// returned.\n    ///\n    /// Note that if one searches for the replacement codepoint, `\\u{FFFD}`,\n    /// then only explicit occurrences of that encoding will be found. Invalid\n    /// UTF-8 sequences will not be matched.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// assert_eq!(Some(10), b\"foo bar baz\".rfind_char('z'));\n    /// assert_eq!(Some(6), B(\"αβγγδ\").rfind_char('γ'));\n    /// assert_eq!(None, b\"foo bar baz\".rfind_char('y'));\n    /// ```\n    #[inline]\n    fn rfind_char(&self, ch: char) -> Option<usize> {\n        self.rfind(ch.encode_utf8(&mut [0; 4]))\n    }\n\n    /// Returns the index of the first occurrence of any of the bytes in the\n    /// provided set.\n    ///\n    /// The `byteset` may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`, but\n    /// note that passing a `&str` which contains multibyte characters may not\n    /// behave as you expect: each byte in the `&str` is treated as an\n    /// individual member of the byte set.\n    ///\n    /// Note that order is irrelevant for the `byteset` parameter, and\n    /// duplicate bytes present in its body are ignored.\n    ///\n    /// # Complexity\n    ///\n    /// This routine is guaranteed to have worst case linear time complexity\n    /// with respect to both the set of bytes and the haystack. That is, this\n    /// runs in `O(byteset.len() + haystack.len())` time.\n    ///\n    /// This routine is also guaranteed to have worst case constant space\n    /// complexity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// assert_eq!(b\"foo bar baz\".find_byteset(b\"zr\"), Some(6));\n    /// assert_eq!(b\"foo baz bar\".find_byteset(b\"bzr\"), Some(4));\n    /// assert_eq!(None, b\"foo baz bar\".find_byteset(b\"\\t\\n\"));\n    /// ```\n    #[inline]\n    fn find_byteset<B: AsRef<[u8]>>(&self, byteset: B) -> Option<usize> {\n        byteset::find(self.as_bytes(), byteset.as_ref())\n    }\n\n    /// Returns the index of the first occurrence of a byte that is not a member\n    /// of the provided set.\n    ///\n    /// The `byteset` may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`, but\n    /// note that passing a `&str` which contains multibyte characters may not\n    /// behave as you expect: each byte in the `&str` is treated as an\n    /// individual member of the byte set.\n    ///\n    /// Note that order is irrelevant for the `byteset` parameter, and\n    /// duplicate bytes present in its body are ignored.\n    ///\n    /// # Complexity\n    ///\n    /// This routine is guaranteed to have worst case linear time complexity\n    /// with respect to both the set of bytes and the haystack. That is, this\n    /// runs in `O(byteset.len() + haystack.len())` time.\n    ///\n    /// This routine is also guaranteed to have worst case constant space\n    /// complexity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// assert_eq!(b\"foo bar baz\".find_not_byteset(b\"fo \"), Some(4));\n    /// assert_eq!(b\"\\t\\tbaz bar\".find_not_byteset(b\" \\t\\r\\n\"), Some(2));\n    /// assert_eq!(b\"foo\\nbaz\\tbar\".find_not_byteset(b\"\\t\\n\"), Some(0));\n    /// ```\n    #[inline]\n    fn find_not_byteset<B: AsRef<[u8]>>(&self, byteset: B) -> Option<usize> {\n        byteset::find_not(self.as_bytes(), byteset.as_ref())\n    }\n\n    /// Returns the index of the last occurrence of any of the bytes in the\n    /// provided set.\n    ///\n    /// The `byteset` may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`, but\n    /// note that passing a `&str` which contains multibyte characters may not\n    /// behave as you expect: each byte in the `&str` is treated as an\n    /// individual member of the byte set.\n    ///\n    /// Note that order is irrelevant for the `byteset` parameter, and duplicate\n    /// bytes present in its body are ignored.\n    ///\n    /// # Complexity\n    ///\n    /// This routine is guaranteed to have worst case linear time complexity\n    /// with respect to both the set of bytes and the haystack. That is, this\n    /// runs in `O(byteset.len() + haystack.len())` time.\n    ///\n    /// This routine is also guaranteed to have worst case constant space\n    /// complexity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// assert_eq!(b\"foo bar baz\".rfind_byteset(b\"agb\"), Some(9));\n    /// assert_eq!(b\"foo baz bar\".rfind_byteset(b\"rabz \"), Some(10));\n    /// assert_eq!(b\"foo baz bar\".rfind_byteset(b\"\\n123\"), None);\n    /// ```\n    #[inline]\n    fn rfind_byteset<B: AsRef<[u8]>>(&self, byteset: B) -> Option<usize> {\n        byteset::rfind(self.as_bytes(), byteset.as_ref())\n    }\n\n    /// Returns the index of the last occurrence of a byte that is not a member\n    /// of the provided set.\n    ///\n    /// The `byteset` may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`, but\n    /// note that passing a `&str` which contains multibyte characters may not\n    /// behave as you expect: each byte in the `&str` is treated as an\n    /// individual member of the byte set.\n    ///\n    /// Note that order is irrelevant for the `byteset` parameter, and\n    /// duplicate bytes present in its body are ignored.\n    ///\n    /// # Complexity\n    ///\n    /// This routine is guaranteed to have worst case linear time complexity\n    /// with respect to both the set of bytes and the haystack. That is, this\n    /// runs in `O(byteset.len() + haystack.len())` time.\n    ///\n    /// This routine is also guaranteed to have worst case constant space\n    /// complexity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// assert_eq!(b\"foo bar baz,\\t\".rfind_not_byteset(b\",\\t\"), Some(10));\n    /// assert_eq!(b\"foo baz bar\".rfind_not_byteset(b\"rabz \"), Some(2));\n    /// assert_eq!(None, b\"foo baz bar\".rfind_not_byteset(b\"barfoz \"));\n    /// ```\n    #[inline]\n    fn rfind_not_byteset<B: AsRef<[u8]>>(&self, byteset: B) -> Option<usize> {\n        byteset::rfind_not(self.as_bytes(), byteset.as_ref())\n    }\n\n    /// Returns an iterator over the fields in a byte string, separated by\n    /// contiguous whitespace.\n    ///\n    /// # Example\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\"  foo\\tbar\\t\\u{2003}\\nquux   \\n\");\n    /// let fields: Vec<&[u8]> = s.fields().collect();\n    /// assert_eq!(fields, vec![B(\"foo\"), B(\"bar\"), B(\"quux\")]);\n    /// ```\n    ///\n    /// A byte string consisting of just whitespace yields no elements:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// assert_eq!(0, B(\"  \\n\\t\\u{2003}\\n  \\t\").fields().count());\n    /// ```\n    #[inline]\n    fn fields(&self) -> Fields {\n        Fields::new(self.as_bytes())\n    }\n\n    /// Returns an iterator over the fields in a byte string, separated by\n    /// contiguous codepoints satisfying the given predicate.\n    ///\n    /// If this byte string is not valid UTF-8, then the given closure will\n    /// be called with a Unicode replacement codepoint when invalid UTF-8\n    /// bytes are seen.\n    ///\n    /// # Example\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = b\"123foo999999bar1quux123456\";\n    /// let fields: Vec<&[u8]> = s.fields_with(|c| c.is_numeric()).collect();\n    /// assert_eq!(fields, vec![B(\"foo\"), B(\"bar\"), B(\"quux\")]);\n    /// ```\n    ///\n    /// A byte string consisting of all codepoints satisfying the predicate\n    /// yields no elements:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// assert_eq!(0, b\"1911354563\".fields_with(|c| c.is_numeric()).count());\n    /// ```\n    #[inline]\n    fn fields_with<F: FnMut(char) -> bool>(&self, f: F) -> FieldsWith<F> {\n        FieldsWith::new(self.as_bytes(), f)\n    }\n\n    /// Returns an iterator over substrings of this byte string, separated\n    /// by the given byte string. Each element yielded is guaranteed not to\n    /// include the splitter substring.\n    ///\n    /// The splitter may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<&[u8]> = b\"Mary had a little lamb\".split_str(\" \").collect();\n    /// assert_eq!(x, vec![\n    ///     B(\"Mary\"), B(\"had\"), B(\"a\"), B(\"little\"), B(\"lamb\"),\n    /// ]);\n    ///\n    /// let x: Vec<&[u8]> = b\"\".split_str(\"X\").collect();\n    /// assert_eq!(x, vec![b\"\"]);\n    ///\n    /// let x: Vec<&[u8]> = b\"lionXXtigerXleopard\".split_str(\"X\").collect();\n    /// assert_eq!(x, vec![B(\"lion\"), B(\"\"), B(\"tiger\"), B(\"leopard\")]);\n    ///\n    /// let x: Vec<&[u8]> = b\"lion::tiger::leopard\".split_str(\"::\").collect();\n    /// assert_eq!(x, vec![B(\"lion\"), B(\"tiger\"), B(\"leopard\")]);\n    /// ```\n    ///\n    /// If a string contains multiple contiguous separators, you will end up\n    /// with empty strings yielded by the iterator:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<&[u8]> = b\"||||a||b|c\".split_str(\"|\").collect();\n    /// assert_eq!(x, vec![\n    ///     B(\"\"), B(\"\"), B(\"\"), B(\"\"), B(\"a\"), B(\"\"), B(\"b\"), B(\"c\"),\n    /// ]);\n    ///\n    /// let x: Vec<&[u8]> = b\"(///)\".split_str(\"/\").collect();\n    /// assert_eq!(x, vec![B(\"(\"), B(\"\"), B(\"\"), B(\")\")]);\n    /// ```\n    ///\n    /// Separators at the start or end of a string are neighbored by empty\n    /// strings.\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<&[u8]> = b\"010\".split_str(\"0\").collect();\n    /// assert_eq!(x, vec![B(\"\"), B(\"1\"), B(\"\")]);\n    /// ```\n    ///\n    /// When the empty string is used as a separator, it splits every **byte**\n    /// in the byte string, along with the beginning and end of the byte\n    /// string.\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<&[u8]> = b\"rust\".split_str(\"\").collect();\n    /// assert_eq!(x, vec![\n    ///     B(\"\"), B(\"r\"), B(\"u\"), B(\"s\"), B(\"t\"), B(\"\"),\n    /// ]);\n    ///\n    /// // Splitting by an empty string is not UTF-8 aware. Elements yielded\n    /// // may not be valid UTF-8!\n    /// let x: Vec<&[u8]> = B(\"☃\").split_str(\"\").collect();\n    /// assert_eq!(x, vec![\n    ///     B(\"\"), B(b\"\\xE2\"), B(b\"\\x98\"), B(b\"\\x83\"), B(\"\"),\n    /// ]);\n    /// ```\n    ///\n    /// Contiguous separators, especially whitespace, can lead to possibly\n    /// surprising behavior. For example, this code is correct:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<&[u8]> = b\"    a  b c\".split_str(\" \").collect();\n    /// assert_eq!(x, vec![\n    ///     B(\"\"), B(\"\"), B(\"\"), B(\"\"), B(\"a\"), B(\"\"), B(\"b\"), B(\"c\"),\n    /// ]);\n    /// ```\n    ///\n    /// It does *not* give you `[\"a\", \"b\", \"c\"]`. For that behavior, use\n    /// [`fields`](#method.fields) instead.\n    #[inline]\n    fn split_str<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        splitter: &'a B,\n    ) -> Split<'a> {\n        Split::new(self.as_bytes(), splitter.as_ref())\n    }\n\n    /// Returns an iterator over substrings of this byte string, separated by\n    /// the given byte string, in reverse. Each element yielded is guaranteed\n    /// not to include the splitter substring.\n    ///\n    /// The splitter may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<&[u8]> =\n    ///     b\"Mary had a little lamb\".rsplit_str(\" \").collect();\n    /// assert_eq!(x, vec![\n    ///     B(\"lamb\"), B(\"little\"), B(\"a\"), B(\"had\"), B(\"Mary\"),\n    /// ]);\n    ///\n    /// let x: Vec<&[u8]> = b\"\".rsplit_str(\"X\").collect();\n    /// assert_eq!(x, vec![b\"\"]);\n    ///\n    /// let x: Vec<&[u8]> = b\"lionXXtigerXleopard\".rsplit_str(\"X\").collect();\n    /// assert_eq!(x, vec![B(\"leopard\"), B(\"tiger\"), B(\"\"), B(\"lion\")]);\n    ///\n    /// let x: Vec<&[u8]> = b\"lion::tiger::leopard\".rsplit_str(\"::\").collect();\n    /// assert_eq!(x, vec![B(\"leopard\"), B(\"tiger\"), B(\"lion\")]);\n    /// ```\n    ///\n    /// If a string contains multiple contiguous separators, you will end up\n    /// with empty strings yielded by the iterator:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<&[u8]> = b\"||||a||b|c\".rsplit_str(\"|\").collect();\n    /// assert_eq!(x, vec![\n    ///     B(\"c\"), B(\"b\"), B(\"\"), B(\"a\"), B(\"\"), B(\"\"), B(\"\"), B(\"\"),\n    /// ]);\n    ///\n    /// let x: Vec<&[u8]> = b\"(///)\".rsplit_str(\"/\").collect();\n    /// assert_eq!(x, vec![B(\")\"), B(\"\"), B(\"\"), B(\"(\")]);\n    /// ```\n    ///\n    /// Separators at the start or end of a string are neighbored by empty\n    /// strings.\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<&[u8]> = b\"010\".rsplit_str(\"0\").collect();\n    /// assert_eq!(x, vec![B(\"\"), B(\"1\"), B(\"\")]);\n    /// ```\n    ///\n    /// When the empty string is used as a separator, it splits every **byte**\n    /// in the byte string, along with the beginning and end of the byte\n    /// string.\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<&[u8]> = b\"rust\".rsplit_str(\"\").collect();\n    /// assert_eq!(x, vec![\n    ///     B(\"\"), B(\"t\"), B(\"s\"), B(\"u\"), B(\"r\"), B(\"\"),\n    /// ]);\n    ///\n    /// // Splitting by an empty string is not UTF-8 aware. Elements yielded\n    /// // may not be valid UTF-8!\n    /// let x: Vec<&[u8]> = B(\"☃\").rsplit_str(\"\").collect();\n    /// assert_eq!(x, vec![B(\"\"), B(b\"\\x83\"), B(b\"\\x98\"), B(b\"\\xE2\"), B(\"\")]);\n    /// ```\n    ///\n    /// Contiguous separators, especially whitespace, can lead to possibly\n    /// surprising behavior. For example, this code is correct:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<&[u8]> = b\"    a  b c\".rsplit_str(\" \").collect();\n    /// assert_eq!(x, vec![\n    ///     B(\"c\"), B(\"b\"), B(\"\"), B(\"a\"), B(\"\"), B(\"\"), B(\"\"), B(\"\"),\n    /// ]);\n    /// ```\n    ///\n    /// It does *not* give you `[\"a\", \"b\", \"c\"]`.\n    #[inline]\n    fn rsplit_str<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        splitter: &'a B,\n    ) -> SplitReverse<'a> {\n        SplitReverse::new(self.as_bytes(), splitter.as_ref())\n    }\n\n    /// Returns an iterator of at most `limit` substrings of this byte string,\n    /// separated by the given byte string. If `limit` substrings are yielded,\n    /// then the last substring will contain the remainder of this byte string.\n    ///\n    /// The needle may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<_> = b\"Mary had a little lamb\".splitn_str(3, \" \").collect();\n    /// assert_eq!(x, vec![B(\"Mary\"), B(\"had\"), B(\"a little lamb\")]);\n    ///\n    /// let x: Vec<_> = b\"\".splitn_str(3, \"X\").collect();\n    /// assert_eq!(x, vec![b\"\"]);\n    ///\n    /// let x: Vec<_> = b\"lionXXtigerXleopard\".splitn_str(3, \"X\").collect();\n    /// assert_eq!(x, vec![B(\"lion\"), B(\"\"), B(\"tigerXleopard\")]);\n    ///\n    /// let x: Vec<_> = b\"lion::tiger::leopard\".splitn_str(2, \"::\").collect();\n    /// assert_eq!(x, vec![B(\"lion\"), B(\"tiger::leopard\")]);\n    ///\n    /// let x: Vec<_> = b\"abcXdef\".splitn_str(1, \"X\").collect();\n    /// assert_eq!(x, vec![B(\"abcXdef\")]);\n    ///\n    /// let x: Vec<_> = b\"abcdef\".splitn_str(2, \"X\").collect();\n    /// assert_eq!(x, vec![B(\"abcdef\")]);\n    ///\n    /// let x: Vec<_> = b\"abcXdef\".splitn_str(0, \"X\").collect();\n    /// assert!(x.is_empty());\n    /// ```\n    #[inline]\n    fn splitn_str<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        limit: usize,\n        splitter: &'a B,\n    ) -> SplitN<'a> {\n        SplitN::new(self.as_bytes(), splitter.as_ref(), limit)\n    }\n\n    /// Returns an iterator of at most `limit` substrings of this byte string,\n    /// separated by the given byte string, in reverse. If `limit` substrings\n    /// are yielded, then the last substring will contain the remainder of this\n    /// byte string.\n    ///\n    /// The needle may be any type that can be cheaply converted into a\n    /// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let x: Vec<_> =\n    ///     b\"Mary had a little lamb\".rsplitn_str(3, \" \").collect();\n    /// assert_eq!(x, vec![B(\"lamb\"), B(\"little\"), B(\"Mary had a\")]);\n    ///\n    /// let x: Vec<_> = b\"\".rsplitn_str(3, \"X\").collect();\n    /// assert_eq!(x, vec![b\"\"]);\n    ///\n    /// let x: Vec<_> = b\"lionXXtigerXleopard\".rsplitn_str(3, \"X\").collect();\n    /// assert_eq!(x, vec![B(\"leopard\"), B(\"tiger\"), B(\"lionX\")]);\n    ///\n    /// let x: Vec<_> = b\"lion::tiger::leopard\".rsplitn_str(2, \"::\").collect();\n    /// assert_eq!(x, vec![B(\"leopard\"), B(\"lion::tiger\")]);\n    ///\n    /// let x: Vec<_> = b\"abcXdef\".rsplitn_str(1, \"X\").collect();\n    /// assert_eq!(x, vec![B(\"abcXdef\")]);\n    ///\n    /// let x: Vec<_> = b\"abcdef\".rsplitn_str(2, \"X\").collect();\n    /// assert_eq!(x, vec![B(\"abcdef\")]);\n    ///\n    /// let x: Vec<_> = b\"abcXdef\".rsplitn_str(0, \"X\").collect();\n    /// assert!(x.is_empty());\n    /// ```\n    #[inline]\n    fn rsplitn_str<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        limit: usize,\n        splitter: &'a B,\n    ) -> SplitNReverse<'a> {\n        SplitNReverse::new(self.as_bytes(), splitter.as_ref(), limit)\n    }\n\n    /// Replace all matches of the given needle with the given replacement, and\n    /// the result as a new `Vec<u8>`.\n    ///\n    /// This routine is useful as a convenience. If you need to reuse an\n    /// allocation, use [`replace_into`](#method.replace_into) instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"this is old\".replace(\"old\", \"new\");\n    /// assert_eq!(s, \"this is new\".as_bytes());\n    /// ```\n    ///\n    /// When the pattern doesn't match:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"this is old\".replace(\"nada nada\", \"limonada\");\n    /// assert_eq!(s, \"this is old\".as_bytes());\n    /// ```\n    ///\n    /// When the needle is an empty string:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foo\".replace(\"\", \"Z\");\n    /// assert_eq!(s, \"ZfZoZoZ\".as_bytes());\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn replace<N: AsRef<[u8]>, R: AsRef<[u8]>>(\n        &self,\n        needle: N,\n        replacement: R,\n    ) -> Vec<u8> {\n        let mut dest = Vec::with_capacity(self.as_bytes().len());\n        self.replace_into(needle, replacement, &mut dest);\n        dest\n    }\n\n    /// Replace up to `limit` matches of the given needle with the given\n    /// replacement, and the result as a new `Vec<u8>`.\n    ///\n    /// This routine is useful as a convenience. If you need to reuse an\n    /// allocation, use [`replacen_into`](#method.replacen_into) instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foofoo\".replacen(\"o\", \"z\", 2);\n    /// assert_eq!(s, \"fzzfoo\".as_bytes());\n    /// ```\n    ///\n    /// When the pattern doesn't match:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foofoo\".replacen(\"a\", \"z\", 2);\n    /// assert_eq!(s, \"foofoo\".as_bytes());\n    /// ```\n    ///\n    /// When the needle is an empty string:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foo\".replacen(\"\", \"Z\", 2);\n    /// assert_eq!(s, \"ZfZoo\".as_bytes());\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn replacen<N: AsRef<[u8]>, R: AsRef<[u8]>>(\n        &self,\n        needle: N,\n        replacement: R,\n        limit: usize,\n    ) -> Vec<u8> {\n        let mut dest = Vec::with_capacity(self.as_bytes().len());\n        self.replacen_into(needle, replacement, limit, &mut dest);\n        dest\n    }\n\n    /// Replace all matches of the given needle with the given replacement,\n    /// and write the result into the provided `Vec<u8>`.\n    ///\n    /// This does **not** clear `dest` before writing to it.\n    ///\n    /// This routine is useful for reusing allocation. For a more convenient\n    /// API, use [`replace`](#method.replace) instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"this is old\";\n    ///\n    /// let mut dest = vec![];\n    /// s.replace_into(\"old\", \"new\", &mut dest);\n    /// assert_eq!(dest, \"this is new\".as_bytes());\n    /// ```\n    ///\n    /// When the pattern doesn't match:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"this is old\";\n    ///\n    /// let mut dest = vec![];\n    /// s.replace_into(\"nada nada\", \"limonada\", &mut dest);\n    /// assert_eq!(dest, \"this is old\".as_bytes());\n    /// ```\n    ///\n    /// When the needle is an empty string:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foo\";\n    ///\n    /// let mut dest = vec![];\n    /// s.replace_into(\"\", \"Z\", &mut dest);\n    /// assert_eq!(dest, \"ZfZoZoZ\".as_bytes());\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn replace_into<N: AsRef<[u8]>, R: AsRef<[u8]>>(\n        &self,\n        needle: N,\n        replacement: R,\n        dest: &mut Vec<u8>,\n    ) {\n        let (needle, replacement) = (needle.as_ref(), replacement.as_ref());\n\n        let mut last = 0;\n        for start in self.find_iter(needle) {\n            dest.push_str(&self.as_bytes()[last..start]);\n            dest.push_str(replacement);\n            last = start + needle.len();\n        }\n        dest.push_str(&self.as_bytes()[last..]);\n    }\n\n    /// Replace up to `limit` matches of the given needle with the given\n    /// replacement, and write the result into the provided `Vec<u8>`.\n    ///\n    /// This does **not** clear `dest` before writing to it.\n    ///\n    /// This routine is useful for reusing allocation. For a more convenient\n    /// API, use [`replacen`](#method.replacen) instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foofoo\";\n    ///\n    /// let mut dest = vec![];\n    /// s.replacen_into(\"o\", \"z\", 2, &mut dest);\n    /// assert_eq!(dest, \"fzzfoo\".as_bytes());\n    /// ```\n    ///\n    /// When the pattern doesn't match:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foofoo\";\n    ///\n    /// let mut dest = vec![];\n    /// s.replacen_into(\"a\", \"z\", 2, &mut dest);\n    /// assert_eq!(dest, \"foofoo\".as_bytes());\n    /// ```\n    ///\n    /// When the needle is an empty string:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let s = b\"foo\";\n    ///\n    /// let mut dest = vec![];\n    /// s.replacen_into(\"\", \"Z\", 2, &mut dest);\n    /// assert_eq!(dest, \"ZfZoo\".as_bytes());\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn replacen_into<N: AsRef<[u8]>, R: AsRef<[u8]>>(\n        &self,\n        needle: N,\n        replacement: R,\n        limit: usize,\n        dest: &mut Vec<u8>,\n    ) {\n        let (needle, replacement) = (needle.as_ref(), replacement.as_ref());\n\n        let mut last = 0;\n        for start in self.find_iter(needle).take(limit) {\n            dest.push_str(&self.as_bytes()[last..start]);\n            dest.push_str(replacement);\n            last = start + needle.len();\n        }\n        dest.push_str(&self.as_bytes()[last..]);\n    }\n\n    /// Returns an iterator over the bytes in this byte string.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = b\"foobar\";\n    /// let bytes: Vec<u8> = bs.bytes().collect();\n    /// assert_eq!(bytes, bs);\n    /// ```\n    #[inline]\n    fn bytes(&self) -> Bytes {\n        Bytes { it: self.as_bytes().iter() }\n    }\n\n    /// Returns an iterator over the Unicode scalar values in this byte string.\n    /// If invalid UTF-8 is encountered, then the Unicode replacement codepoint\n    /// is yielded instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\";\n    /// let chars: Vec<char> = bs.chars().collect();\n    /// assert_eq!(vec!['☃', '\\u{FFFD}', '𝞃', '\\u{FFFD}', 'a'], chars);\n    /// ```\n    ///\n    /// Codepoints can also be iterated over in reverse:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\";\n    /// let chars: Vec<char> = bs.chars().rev().collect();\n    /// assert_eq!(vec!['a', '\\u{FFFD}', '𝞃', '\\u{FFFD}', '☃'], chars);\n    /// ```\n    #[inline]\n    fn chars(&self) -> Chars {\n        Chars::new(self.as_bytes())\n    }\n\n    /// Returns an iterator over the Unicode scalar values in this byte string\n    /// along with their starting and ending byte index positions. If invalid\n    /// UTF-8 is encountered, then the Unicode replacement codepoint is yielded\n    /// instead.\n    ///\n    /// Note that this is slightly different from the `CharIndices` iterator\n    /// provided by the standard library. Aside from working on possibly\n    /// invalid UTF-8, this iterator provides both the corresponding starting\n    /// and ending byte indices of each codepoint yielded. The ending position\n    /// is necessary to slice the original byte string when invalid UTF-8 bytes\n    /// are converted into a Unicode replacement codepoint, since a single\n    /// replacement codepoint can substitute anywhere from 1 to 3 invalid bytes\n    /// (inclusive).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\";\n    /// let chars: Vec<(usize, usize, char)> = bs.char_indices().collect();\n    /// assert_eq!(chars, vec![\n    ///     (0, 3, '☃'),\n    ///     (3, 4, '\\u{FFFD}'),\n    ///     (4, 8, '𝞃'),\n    ///     (8, 10, '\\u{FFFD}'),\n    ///     (10, 11, 'a'),\n    /// ]);\n    /// ```\n    ///\n    /// Codepoints can also be iterated over in reverse:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\";\n    /// let chars: Vec<(usize, usize, char)> = bs\n    ///     .char_indices()\n    ///     .rev()\n    ///     .collect();\n    /// assert_eq!(chars, vec![\n    ///     (10, 11, 'a'),\n    ///     (8, 10, '\\u{FFFD}'),\n    ///     (4, 8, '𝞃'),\n    ///     (3, 4, '\\u{FFFD}'),\n    ///     (0, 3, '☃'),\n    /// ]);\n    /// ```\n    #[inline]\n    fn char_indices(&self) -> CharIndices {\n        CharIndices::new(self.as_bytes())\n    }\n\n    /// Iterate over chunks of valid UTF-8.\n    ///\n    /// The iterator returned yields chunks of valid UTF-8 separated by invalid\n    /// UTF-8 bytes, if they exist. Invalid UTF-8 bytes are always 1-3 bytes,\n    /// which are determined via the \"substitution of maximal subparts\"\n    /// strategy described in the docs for the\n    /// [`ByteSlice::to_str_lossy`](trait.ByteSlice.html#method.to_str_lossy)\n    /// method.\n    ///\n    /// # Examples\n    ///\n    /// This example shows how to gather all valid and invalid chunks from a\n    /// byte slice:\n    ///\n    /// ```\n    /// use bstr::{ByteSlice, Utf8Chunk};\n    ///\n    /// let bytes = b\"foo\\xFD\\xFEbar\\xFF\";\n    ///\n    /// let (mut valid_chunks, mut invalid_chunks) = (vec![], vec![]);\n    /// for chunk in bytes.utf8_chunks() {\n    ///     if !chunk.valid().is_empty() {\n    ///         valid_chunks.push(chunk.valid());\n    ///     }\n    ///     if !chunk.invalid().is_empty() {\n    ///         invalid_chunks.push(chunk.invalid());\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(valid_chunks, vec![\"foo\", \"bar\"]);\n    /// assert_eq!(invalid_chunks, vec![b\"\\xFD\", b\"\\xFE\", b\"\\xFF\"]);\n    /// ```\n    #[inline]\n    fn utf8_chunks(&self) -> Utf8Chunks {\n        Utf8Chunks { bytes: self.as_bytes() }\n    }\n\n    /// Returns an iterator over the grapheme clusters in this byte string.\n    /// If invalid UTF-8 is encountered, then the Unicode replacement codepoint\n    /// is yielded instead.\n    ///\n    /// # Examples\n    ///\n    /// This example shows how multiple codepoints can combine to form a\n    /// single grapheme cluster:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = \"a\\u{0300}\\u{0316}\\u{1F1FA}\\u{1F1F8}\".as_bytes();\n    /// let graphemes: Vec<&str> = bs.graphemes().collect();\n    /// assert_eq!(vec![\"à̖\", \"🇺🇸\"], graphemes);\n    /// ```\n    ///\n    /// This shows that graphemes can be iterated over in reverse:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = \"a\\u{0300}\\u{0316}\\u{1F1FA}\\u{1F1F8}\".as_bytes();\n    /// let graphemes: Vec<&str> = bs.graphemes().rev().collect();\n    /// assert_eq!(vec![\"🇺🇸\", \"à̖\"], graphemes);\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn graphemes(&self) -> Graphemes {\n        Graphemes::new(self.as_bytes())\n    }\n\n    /// Returns an iterator over the grapheme clusters in this byte string\n    /// along with their starting and ending byte index positions. If invalid\n    /// UTF-8 is encountered, then the Unicode replacement codepoint is yielded\n    /// instead.\n    ///\n    /// # Examples\n    ///\n    /// This example shows how to get the byte offsets of each individual\n    /// grapheme cluster:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = \"a\\u{0300}\\u{0316}\\u{1F1FA}\\u{1F1F8}\".as_bytes();\n    /// let graphemes: Vec<(usize, usize, &str)> =\n    ///     bs.grapheme_indices().collect();\n    /// assert_eq!(vec![(0, 5, \"à̖\"), (5, 13, \"🇺🇸\")], graphemes);\n    /// ```\n    ///\n    /// This example shows what happens when invalid UTF-8 is enountered. Note\n    /// that the offsets are valid indices into the original string, and do\n    /// not necessarily correspond to the length of the `&str` returned!\n    ///\n    /// ```\n    /// use bstr::{ByteSlice, ByteVec};\n    ///\n    /// let mut bytes = vec![];\n    /// bytes.push_str(\"a\\u{0300}\\u{0316}\");\n    /// bytes.push(b'\\xFF');\n    /// bytes.push_str(\"\\u{1F1FA}\\u{1F1F8}\");\n    ///\n    /// let graphemes: Vec<(usize, usize, &str)> =\n    ///     bytes.grapheme_indices().collect();\n    /// assert_eq!(\n    ///     graphemes,\n    ///     vec![(0, 5, \"à̖\"), (5, 6, \"\\u{FFFD}\"), (6, 14, \"🇺🇸\")]\n    /// );\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn grapheme_indices(&self) -> GraphemeIndices {\n        GraphemeIndices::new(self.as_bytes())\n    }\n\n    /// Returns an iterator over the words in this byte string. If invalid\n    /// UTF-8 is encountered, then the Unicode replacement codepoint is yielded\n    /// instead.\n    ///\n    /// This is similar to\n    /// [`words_with_breaks`](trait.ByteSlice.html#method.words_with_breaks),\n    /// except it only returns elements that contain a \"word\" character. A word\n    /// character is defined by UTS #18 (Annex C) to be the combination of the\n    /// `Alphabetic` and `Join_Control` properties, along with the\n    /// `Decimal_Number`, `Mark` and `Connector_Punctuation` general\n    /// categories.\n    ///\n    /// Since words are made up of one or more codepoints, this iterator\n    /// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n    /// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = br#\"The quick (\"brown\") fox can't jump 32.3 feet, right?\"#;\n    /// let words: Vec<&str> = bs.words().collect();\n    /// assert_eq!(words, vec![\n    ///     \"The\", \"quick\", \"brown\", \"fox\", \"can't\",\n    ///     \"jump\", \"32.3\", \"feet\", \"right\",\n    /// ]);\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn words(&self) -> Words {\n        Words::new(self.as_bytes())\n    }\n\n    /// Returns an iterator over the words in this byte string along with\n    /// their starting and ending byte index positions.\n    ///\n    /// This is similar to\n    /// [`words_with_break_indices`](trait.ByteSlice.html#method.words_with_break_indices),\n    /// except it only returns elements that contain a \"word\" character. A word\n    /// character is defined by UTS #18 (Annex C) to be the combination of the\n    /// `Alphabetic` and `Join_Control` properties, along with the\n    /// `Decimal_Number`, `Mark` and `Connector_Punctuation` general\n    /// categories.\n    ///\n    /// Since words are made up of one or more codepoints, this iterator\n    /// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n    /// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n    ///\n    /// # Examples\n    ///\n    /// This example shows how to get the byte offsets of each individual\n    /// word:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = b\"can't jump 32.3 feet\";\n    /// let words: Vec<(usize, usize, &str)> = bs.word_indices().collect();\n    /// assert_eq!(words, vec![\n    ///     (0, 5, \"can't\"),\n    ///     (6, 10, \"jump\"),\n    ///     (11, 15, \"32.3\"),\n    ///     (16, 20, \"feet\"),\n    /// ]);\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn word_indices(&self) -> WordIndices {\n        WordIndices::new(self.as_bytes())\n    }\n\n    /// Returns an iterator over the words in this byte string, along with\n    /// all breaks between the words. Concatenating all elements yielded by\n    /// the iterator results in the original string (modulo Unicode replacement\n    /// codepoint substitutions if invalid UTF-8 is encountered).\n    ///\n    /// Since words are made up of one or more codepoints, this iterator\n    /// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n    /// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = br#\"The quick (\"brown\") fox can't jump 32.3 feet, right?\"#;\n    /// let words: Vec<&str> = bs.words_with_breaks().collect();\n    /// assert_eq!(words, vec![\n    ///     \"The\", \" \", \"quick\", \" \", \"(\", \"\\\"\", \"brown\", \"\\\"\", \")\",\n    ///     \" \", \"fox\", \" \", \"can't\", \" \", \"jump\", \" \", \"32.3\", \" \", \"feet\",\n    ///     \",\", \" \", \"right\", \"?\",\n    /// ]);\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn words_with_breaks(&self) -> WordsWithBreaks {\n        WordsWithBreaks::new(self.as_bytes())\n    }\n\n    /// Returns an iterator over the words and their byte offsets in this\n    /// byte string, along with all breaks between the words. Concatenating\n    /// all elements yielded by the iterator results in the original string\n    /// (modulo Unicode replacement codepoint substitutions if invalid UTF-8 is\n    /// encountered).\n    ///\n    /// Since words are made up of one or more codepoints, this iterator\n    /// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n    /// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n    ///\n    /// # Examples\n    ///\n    /// This example shows how to get the byte offsets of each individual\n    /// word:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = b\"can't jump 32.3 feet\";\n    /// let words: Vec<(usize, usize, &str)> =\n    ///     bs.words_with_break_indices().collect();\n    /// assert_eq!(words, vec![\n    ///     (0, 5, \"can't\"),\n    ///     (5, 6, \" \"),\n    ///     (6, 10, \"jump\"),\n    ///     (10, 11, \" \"),\n    ///     (11, 15, \"32.3\"),\n    ///     (15, 16, \" \"),\n    ///     (16, 20, \"feet\"),\n    /// ]);\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn words_with_break_indices(&self) -> WordsWithBreakIndices {\n        WordsWithBreakIndices::new(self.as_bytes())\n    }\n\n    /// Returns an iterator over the sentences in this byte string.\n    ///\n    /// Typically, a sentence will include its trailing punctuation and\n    /// whitespace. Concatenating all elements yielded by the iterator\n    /// results in the original string (modulo Unicode replacement codepoint\n    /// substitutions if invalid UTF-8 is encountered).\n    ///\n    /// Since sentences are made up of one or more codepoints, this iterator\n    /// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n    /// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = b\"I want this. Not that. Right now.\";\n    /// let sentences: Vec<&str> = bs.sentences().collect();\n    /// assert_eq!(sentences, vec![\n    ///     \"I want this. \",\n    ///     \"Not that. \",\n    ///     \"Right now.\",\n    /// ]);\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn sentences(&self) -> Sentences {\n        Sentences::new(self.as_bytes())\n    }\n\n    /// Returns an iterator over the sentences in this byte string along with\n    /// their starting and ending byte index positions.\n    ///\n    /// Typically, a sentence will include its trailing punctuation and\n    /// whitespace. Concatenating all elements yielded by the iterator\n    /// results in the original string (modulo Unicode replacement codepoint\n    /// substitutions if invalid UTF-8 is encountered).\n    ///\n    /// Since sentences are made up of one or more codepoints, this iterator\n    /// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n    /// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let bs = b\"I want this. Not that. Right now.\";\n    /// let sentences: Vec<(usize, usize, &str)> =\n    ///     bs.sentence_indices().collect();\n    /// assert_eq!(sentences, vec![\n    ///     (0, 13, \"I want this. \"),\n    ///     (13, 23, \"Not that. \"),\n    ///     (23, 33, \"Right now.\"),\n    /// ]);\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn sentence_indices(&self) -> SentenceIndices {\n        SentenceIndices::new(self.as_bytes())\n    }\n\n    /// An iterator over all lines in a byte string, without their\n    /// terminators.\n    ///\n    /// For this iterator, the only line terminators recognized are `\\r\\n` and\n    /// `\\n`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = b\"\\\n    /// foo\n    ///\n    /// bar\\r\n    /// baz\n    ///\n    ///\n    /// quux\";\n    /// let lines: Vec<&[u8]> = s.lines().collect();\n    /// assert_eq!(lines, vec![\n    ///     B(\"foo\"), B(\"\"), B(\"bar\"), B(\"baz\"), B(\"\"), B(\"\"), B(\"quux\"),\n    /// ]);\n    /// ```\n    #[inline]\n    fn lines(&self) -> Lines {\n        Lines::new(self.as_bytes())\n    }\n\n    /// An iterator over all lines in a byte string, including their\n    /// terminators.\n    ///\n    /// For this iterator, the only line terminator recognized is `\\n`. (Since\n    /// line terminators are included, this also handles `\\r\\n` line endings.)\n    ///\n    /// Line terminators are only included if they are present in the original\n    /// byte string. For example, the last line in a byte string may not end\n    /// with a line terminator.\n    ///\n    /// Concatenating all elements yielded by this iterator is guaranteed to\n    /// yield the original byte string.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = b\"\\\n    /// foo\n    ///\n    /// bar\\r\n    /// baz\n    ///\n    ///\n    /// quux\";\n    /// let lines: Vec<&[u8]> = s.lines_with_terminator().collect();\n    /// assert_eq!(lines, vec![\n    ///     B(\"foo\\n\"),\n    ///     B(\"\\n\"),\n    ///     B(\"bar\\r\\n\"),\n    ///     B(\"baz\\n\"),\n    ///     B(\"\\n\"),\n    ///     B(\"\\n\"),\n    ///     B(\"quux\"),\n    /// ]);\n    /// ```\n    #[inline]\n    fn lines_with_terminator(&self) -> LinesWithTerminator {\n        LinesWithTerminator::new(self.as_bytes())\n    }\n\n    /// Return a byte string slice with leading and trailing whitespace\n    /// removed.\n    ///\n    /// Whitespace is defined according to the terms of the `White_Space`\n    /// Unicode property.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\" foo\\tbar\\t\\u{2003}\\n\");\n    /// assert_eq!(s.trim(), B(\"foo\\tbar\"));\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn trim(&self) -> &[u8] {\n        self.trim_start().trim_end()\n    }\n\n    /// Return a byte string slice with leading whitespace removed.\n    ///\n    /// Whitespace is defined according to the terms of the `White_Space`\n    /// Unicode property.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\" foo\\tbar\\t\\u{2003}\\n\");\n    /// assert_eq!(s.trim_start(), B(\"foo\\tbar\\t\\u{2003}\\n\"));\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn trim_start(&self) -> &[u8] {\n        let start = whitespace_len_fwd(self.as_bytes());\n        &self.as_bytes()[start..]\n    }\n\n    /// Return a byte string slice with trailing whitespace removed.\n    ///\n    /// Whitespace is defined according to the terms of the `White_Space`\n    /// Unicode property.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\" foo\\tbar\\t\\u{2003}\\n\");\n    /// assert_eq!(s.trim_end(), B(\" foo\\tbar\"));\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn trim_end(&self) -> &[u8] {\n        let end = whitespace_len_rev(self.as_bytes());\n        &self.as_bytes()[..end]\n    }\n\n    /// Return a byte string slice with leading and trailing characters\n    /// satisfying the given predicate removed.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = b\"123foo5bar789\";\n    /// assert_eq!(s.trim_with(|c| c.is_numeric()), B(\"foo5bar\"));\n    /// ```\n    #[inline]\n    fn trim_with<F: FnMut(char) -> bool>(&self, mut trim: F) -> &[u8] {\n        self.trim_start_with(&mut trim).trim_end_with(&mut trim)\n    }\n\n    /// Return a byte string slice with leading characters satisfying the given\n    /// predicate removed.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = b\"123foo5bar789\";\n    /// assert_eq!(s.trim_start_with(|c| c.is_numeric()), B(\"foo5bar789\"));\n    /// ```\n    #[inline]\n    fn trim_start_with<F: FnMut(char) -> bool>(&self, mut trim: F) -> &[u8] {\n        for (s, _, ch) in self.char_indices() {\n            if !trim(ch) {\n                return &self.as_bytes()[s..];\n            }\n        }\n        b\"\"\n    }\n\n    /// Return a byte string slice with trailing characters satisfying the\n    /// given predicate removed.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = b\"123foo5bar789\";\n    /// assert_eq!(s.trim_end_with(|c| c.is_numeric()), B(\"123foo5bar\"));\n    /// ```\n    #[inline]\n    fn trim_end_with<F: FnMut(char) -> bool>(&self, mut trim: F) -> &[u8] {\n        for (_, e, ch) in self.char_indices().rev() {\n            if !trim(ch) {\n                return &self.as_bytes()[..e];\n            }\n        }\n        b\"\"\n    }\n\n    /// Returns a new `Vec<u8>` containing the lowercase equivalent of this\n    /// byte string.\n    ///\n    /// In this case, lowercase is defined according to the `Lowercase` Unicode\n    /// property.\n    ///\n    /// If invalid UTF-8 is seen, or if a character has no lowercase variant,\n    /// then it is written to the given buffer unchanged.\n    ///\n    /// Note that some characters in this byte string may expand into multiple\n    /// characters when changing the case, so the number of bytes written to\n    /// the given byte string may not be equivalent to the number of bytes in\n    /// this byte string.\n    ///\n    /// If you'd like to reuse an allocation for performance reasons, then use\n    /// [`to_lowercase_into`](#method.to_lowercase_into) instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\"HELLO Β\");\n    /// assert_eq!(\"hello β\".as_bytes(), s.to_lowercase().as_bytes());\n    /// ```\n    ///\n    /// Scripts without case are not changed:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\"农历新年\");\n    /// assert_eq!(\"农历新年\".as_bytes(), s.to_lowercase().as_bytes());\n    /// ```\n    ///\n    /// Invalid UTF-8 remains as is:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\");\n    /// assert_eq!(B(b\"foo\\xFFbar\\xE2\\x98baz\"), s.to_lowercase().as_bytes());\n    /// ```\n    #[cfg(all(feature = \"std\", feature = \"unicode\"))]\n    #[inline]\n    fn to_lowercase(&self) -> Vec<u8> {\n        let mut buf = vec![];\n        self.to_lowercase_into(&mut buf);\n        buf\n    }\n\n    /// Writes the lowercase equivalent of this byte string into the given\n    /// buffer. The buffer is not cleared before written to.\n    ///\n    /// In this case, lowercase is defined according to the `Lowercase`\n    /// Unicode property.\n    ///\n    /// If invalid UTF-8 is seen, or if a character has no lowercase variant,\n    /// then it is written to the given buffer unchanged.\n    ///\n    /// Note that some characters in this byte string may expand into multiple\n    /// characters when changing the case, so the number of bytes written to\n    /// the given byte string may not be equivalent to the number of bytes in\n    /// this byte string.\n    ///\n    /// If you don't need to amortize allocation and instead prefer\n    /// convenience, then use [`to_lowercase`](#method.to_lowercase) instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\"HELLO Β\");\n    ///\n    /// let mut buf = vec![];\n    /// s.to_lowercase_into(&mut buf);\n    /// assert_eq!(\"hello β\".as_bytes(), buf.as_bytes());\n    /// ```\n    ///\n    /// Scripts without case are not changed:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\"农历新年\");\n    ///\n    /// let mut buf = vec![];\n    /// s.to_lowercase_into(&mut buf);\n    /// assert_eq!(\"农历新年\".as_bytes(), buf.as_bytes());\n    /// ```\n    ///\n    /// Invalid UTF-8 remains as is:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\");\n    ///\n    /// let mut buf = vec![];\n    /// s.to_lowercase_into(&mut buf);\n    /// assert_eq!(B(b\"foo\\xFFbar\\xE2\\x98baz\"), buf.as_bytes());\n    /// ```\n    #[cfg(all(feature = \"std\", feature = \"unicode\"))]\n    #[inline]\n    fn to_lowercase_into(&self, buf: &mut Vec<u8>) {\n        // TODO: This is the best we can do given what std exposes I think.\n        // If we roll our own case handling, then we might be able to do this\n        // a bit faster. We shouldn't roll our own case handling unless we\n        // need to, e.g., for doing caseless matching or case folding.\n\n        // TODO(BUG): This doesn't handle any special casing rules.\n\n        buf.reserve(self.as_bytes().len());\n        for (s, e, ch) in self.char_indices() {\n            if ch == '\\u{FFFD}' {\n                buf.push_str(&self.as_bytes()[s..e]);\n            } else if ch.is_ascii() {\n                buf.push_char(ch.to_ascii_lowercase());\n            } else {\n                for upper in ch.to_lowercase() {\n                    buf.push_char(upper);\n                }\n            }\n        }\n    }\n\n    /// Returns a new `Vec<u8>` containing the ASCII lowercase equivalent of\n    /// this byte string.\n    ///\n    /// In this case, lowercase is only defined in ASCII letters. Namely, the\n    /// letters `A-Z` are converted to `a-z`. All other bytes remain unchanged.\n    /// In particular, the length of the byte string returned is always\n    /// equivalent to the length of this byte string.\n    ///\n    /// If you'd like to reuse an allocation for performance reasons, then use\n    /// [`make_ascii_lowercase`](#method.make_ascii_lowercase) to perform\n    /// the conversion in place.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\"HELLO Β\");\n    /// assert_eq!(\"hello Β\".as_bytes(), s.to_ascii_lowercase().as_bytes());\n    /// ```\n    ///\n    /// Invalid UTF-8 remains as is:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\");\n    /// assert_eq!(s.to_ascii_lowercase(), B(b\"foo\\xFFbar\\xE2\\x98baz\"));\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn to_ascii_lowercase(&self) -> Vec<u8> {\n        self.as_bytes().to_ascii_lowercase()\n    }\n\n    /// Convert this byte string to its lowercase ASCII equivalent in place.\n    ///\n    /// In this case, lowercase is only defined in ASCII letters. Namely, the\n    /// letters `A-Z` are converted to `a-z`. All other bytes remain unchanged.\n    ///\n    /// If you don't need to do the conversion in\n    /// place and instead prefer convenience, then use\n    /// [`to_ascii_lowercase`](#method.to_ascii_lowercase) instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut s = <Vec<u8>>::from(\"HELLO Β\");\n    /// s.make_ascii_lowercase();\n    /// assert_eq!(s, \"hello Β\".as_bytes());\n    /// ```\n    ///\n    /// Invalid UTF-8 remains as is:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice, ByteVec};\n    ///\n    /// let mut s = <Vec<u8>>::from_slice(b\"FOO\\xFFBAR\\xE2\\x98BAZ\");\n    /// s.make_ascii_lowercase();\n    /// assert_eq!(s, B(b\"foo\\xFFbar\\xE2\\x98baz\"));\n    /// ```\n    #[inline]\n    fn make_ascii_lowercase(&mut self) {\n        self.as_bytes_mut().make_ascii_lowercase();\n    }\n\n    /// Returns a new `Vec<u8>` containing the uppercase equivalent of this\n    /// byte string.\n    ///\n    /// In this case, uppercase is defined according to the `Uppercase`\n    /// Unicode property.\n    ///\n    /// If invalid UTF-8 is seen, or if a character has no uppercase variant,\n    /// then it is written to the given buffer unchanged.\n    ///\n    /// Note that some characters in this byte string may expand into multiple\n    /// characters when changing the case, so the number of bytes written to\n    /// the given byte string may not be equivalent to the number of bytes in\n    /// this byte string.\n    ///\n    /// If you'd like to reuse an allocation for performance reasons, then use\n    /// [`to_uppercase_into`](#method.to_uppercase_into) instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\"hello β\");\n    /// assert_eq!(s.to_uppercase(), B(\"HELLO Β\"));\n    /// ```\n    ///\n    /// Scripts without case are not changed:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\"农历新年\");\n    /// assert_eq!(s.to_uppercase(), B(\"农历新年\"));\n    /// ```\n    ///\n    /// Invalid UTF-8 remains as is:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(b\"foo\\xFFbar\\xE2\\x98baz\");\n    /// assert_eq!(s.to_uppercase(), B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\"));\n    /// ```\n    #[cfg(all(feature = \"std\", feature = \"unicode\"))]\n    #[inline]\n    fn to_uppercase(&self) -> Vec<u8> {\n        let mut buf = vec![];\n        self.to_uppercase_into(&mut buf);\n        buf\n    }\n\n    /// Writes the uppercase equivalent of this byte string into the given\n    /// buffer. The buffer is not cleared before written to.\n    ///\n    /// In this case, uppercase is defined according to the `Uppercase`\n    /// Unicode property.\n    ///\n    /// If invalid UTF-8 is seen, or if a character has no uppercase variant,\n    /// then it is written to the given buffer unchanged.\n    ///\n    /// Note that some characters in this byte string may expand into multiple\n    /// characters when changing the case, so the number of bytes written to\n    /// the given byte string may not be equivalent to the number of bytes in\n    /// this byte string.\n    ///\n    /// If you don't need to amortize allocation and instead prefer\n    /// convenience, then use [`to_uppercase`](#method.to_uppercase) instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\"hello β\");\n    ///\n    /// let mut buf = vec![];\n    /// s.to_uppercase_into(&mut buf);\n    /// assert_eq!(buf, B(\"HELLO Β\"));\n    /// ```\n    ///\n    /// Scripts without case are not changed:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\"农历新年\");\n    ///\n    /// let mut buf = vec![];\n    /// s.to_uppercase_into(&mut buf);\n    /// assert_eq!(buf, B(\"农历新年\"));\n    /// ```\n    ///\n    /// Invalid UTF-8 remains as is:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(b\"foo\\xFFbar\\xE2\\x98baz\");\n    ///\n    /// let mut buf = vec![];\n    /// s.to_uppercase_into(&mut buf);\n    /// assert_eq!(buf, B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\"));\n    /// ```\n    #[cfg(all(feature = \"std\", feature = \"unicode\"))]\n    #[inline]\n    fn to_uppercase_into(&self, buf: &mut Vec<u8>) {\n        // TODO: This is the best we can do given what std exposes I think.\n        // If we roll our own case handling, then we might be able to do this\n        // a bit faster. We shouldn't roll our own case handling unless we\n        // need to, e.g., for doing caseless matching or case folding.\n        buf.reserve(self.as_bytes().len());\n        for (s, e, ch) in self.char_indices() {\n            if ch == '\\u{FFFD}' {\n                buf.push_str(&self.as_bytes()[s..e]);\n            } else if ch.is_ascii() {\n                buf.push_char(ch.to_ascii_uppercase());\n            } else {\n                for upper in ch.to_uppercase() {\n                    buf.push_char(upper);\n                }\n            }\n        }\n    }\n\n    /// Returns a new `Vec<u8>` containing the ASCII uppercase equivalent of\n    /// this byte string.\n    ///\n    /// In this case, uppercase is only defined in ASCII letters. Namely, the\n    /// letters `a-z` are converted to `A-Z`. All other bytes remain unchanged.\n    /// In particular, the length of the byte string returned is always\n    /// equivalent to the length of this byte string.\n    ///\n    /// If you'd like to reuse an allocation for performance reasons, then use\n    /// [`make_ascii_uppercase`](#method.make_ascii_uppercase) to perform\n    /// the conversion in place.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(\"hello β\");\n    /// assert_eq!(s.to_ascii_uppercase(), B(\"HELLO β\"));\n    /// ```\n    ///\n    /// Invalid UTF-8 remains as is:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let s = B(b\"foo\\xFFbar\\xE2\\x98baz\");\n    /// assert_eq!(s.to_ascii_uppercase(), B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\"));\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[inline]\n    fn to_ascii_uppercase(&self) -> Vec<u8> {\n        self.as_bytes().to_ascii_uppercase()\n    }\n\n    /// Convert this byte string to its uppercase ASCII equivalent in place.\n    ///\n    /// In this case, uppercase is only defined in ASCII letters. Namely, the\n    /// letters `a-z` are converted to `A-Z`. All other bytes remain unchanged.\n    ///\n    /// If you don't need to do the conversion in\n    /// place and instead prefer convenience, then use\n    /// [`to_ascii_uppercase`](#method.to_ascii_uppercase) instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let mut s = <Vec<u8>>::from(\"hello β\");\n    /// s.make_ascii_uppercase();\n    /// assert_eq!(s, B(\"HELLO β\"));\n    /// ```\n    ///\n    /// Invalid UTF-8 remains as is:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice, ByteVec};\n    ///\n    /// let mut s = <Vec<u8>>::from_slice(b\"foo\\xFFbar\\xE2\\x98baz\");\n    /// s.make_ascii_uppercase();\n    /// assert_eq!(s, B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\"));\n    /// ```\n    #[inline]\n    fn make_ascii_uppercase(&mut self) {\n        self.as_bytes_mut().make_ascii_uppercase();\n    }\n\n    /// Reverse the bytes in this string, in place.\n    ///\n    /// This is not necessarily a well formed operation! For example, if this\n    /// byte string contains valid UTF-8 that isn't ASCII, then reversing the\n    /// string will likely result in invalid UTF-8 and otherwise non-sensical\n    /// content.\n    ///\n    /// Note that this is equivalent to the generic `[u8]::reverse` method.\n    /// This method is provided to permit callers to explicitly differentiate\n    /// between reversing bytes, codepoints and graphemes.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut s = <Vec<u8>>::from(\"hello\");\n    /// s.reverse_bytes();\n    /// assert_eq!(s, \"olleh\".as_bytes());\n    /// ```\n    #[inline]\n    fn reverse_bytes(&mut self) {\n        self.as_bytes_mut().reverse();\n    }\n\n    /// Reverse the codepoints in this string, in place.\n    ///\n    /// If this byte string is valid UTF-8, then its reversal by codepoint\n    /// is also guaranteed to be valid UTF-8.\n    ///\n    /// This operation is equivalent to the following, but without allocating:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut s = <Vec<u8>>::from(\"foo☃bar\");\n    ///\n    /// let mut chars: Vec<char> = s.chars().collect();\n    /// chars.reverse();\n    ///\n    /// let reversed: String = chars.into_iter().collect();\n    /// assert_eq!(reversed, \"rab☃oof\");\n    /// ```\n    ///\n    /// Note that this is not necessarily a well formed operation. For example,\n    /// if this byte string contains grapheme clusters with more than one\n    /// codepoint, then those grapheme clusters will not necessarily be\n    /// preserved. If you'd like to preserve grapheme clusters, then use\n    /// [`reverse_graphemes`](#method.reverse_graphemes) instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut s = <Vec<u8>>::from(\"foo☃bar\");\n    /// s.reverse_chars();\n    /// assert_eq!(s, \"rab☃oof\".as_bytes());\n    /// ```\n    ///\n    /// This example shows that not all reversals lead to a well formed string.\n    /// For example, in this case, combining marks are used to put accents over\n    /// some letters, and those accent marks must appear after the codepoints\n    /// they modify.\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let mut s = <Vec<u8>>::from(\"résumé\");\n    /// s.reverse_chars();\n    /// assert_eq!(s, B(b\"\\xCC\\x81emus\\xCC\\x81er\"));\n    /// ```\n    ///\n    /// A word of warning: the above example relies on the fact that\n    /// `résumé` is in decomposed normal form, which means there are separate\n    /// codepoints for the accents above `e`. If it is instead in composed\n    /// normal form, then the example works:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let mut s = <Vec<u8>>::from(\"résumé\");\n    /// s.reverse_chars();\n    /// assert_eq!(s, B(\"émusér\"));\n    /// ```\n    ///\n    /// The point here is to be cautious and not assume that just because\n    /// `reverse_chars` works in one case, that it therefore works in all\n    /// cases.\n    #[inline]\n    fn reverse_chars(&mut self) {\n        let mut i = 0;\n        loop {\n            let (_, size) = utf8::decode(&self.as_bytes()[i..]);\n            if size == 0 {\n                break;\n            }\n            if size > 1 {\n                self.as_bytes_mut()[i..i + size].reverse_bytes();\n            }\n            i += size;\n        }\n        self.reverse_bytes();\n    }\n\n    /// Reverse the graphemes in this string, in place.\n    ///\n    /// If this byte string is valid UTF-8, then its reversal by grapheme\n    /// is also guaranteed to be valid UTF-8.\n    ///\n    /// This operation is equivalent to the following, but without allocating:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut s = <Vec<u8>>::from(\"foo☃bar\");\n    ///\n    /// let mut graphemes: Vec<&str> = s.graphemes().collect();\n    /// graphemes.reverse();\n    ///\n    /// let reversed = graphemes.concat();\n    /// assert_eq!(reversed, \"rab☃oof\");\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut s = <Vec<u8>>::from(\"foo☃bar\");\n    /// s.reverse_graphemes();\n    /// assert_eq!(s, \"rab☃oof\".as_bytes());\n    /// ```\n    ///\n    /// This example shows how this correctly handles grapheme clusters,\n    /// unlike `reverse_chars`.\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// let mut s = <Vec<u8>>::from(\"résumé\");\n    /// s.reverse_graphemes();\n    /// assert_eq!(s, \"émusér\".as_bytes());\n    /// ```\n    #[cfg(feature = \"unicode\")]\n    #[inline]\n    fn reverse_graphemes(&mut self) {\n        use unicode::decode_grapheme;\n\n        let mut i = 0;\n        loop {\n            let (_, size) = decode_grapheme(&self.as_bytes()[i..]);\n            if size == 0 {\n                break;\n            }\n            if size > 1 {\n                self.as_bytes_mut()[i..i + size].reverse_bytes();\n            }\n            i += size;\n        }\n        self.reverse_bytes();\n    }\n\n    /// Returns true if and only if every byte in this byte string is ASCII.\n    ///\n    /// ASCII is an encoding that defines 128 codepoints. A byte corresponds to\n    /// an ASCII codepoint if and only if it is in the inclusive range\n    /// `[0, 127]`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// assert!(B(\"abc\").is_ascii());\n    /// assert!(!B(\"☃βツ\").is_ascii());\n    /// assert!(!B(b\"\\xFF\").is_ascii());\n    /// ```\n    #[inline]\n    fn is_ascii(&self) -> bool {\n        ascii::first_non_ascii_byte(self.as_bytes()) == self.as_bytes().len()\n    }\n\n    /// Returns true if and only if the entire byte string is valid UTF-8.\n    ///\n    /// If you need location information about where a byte string's first\n    /// invalid UTF-8 byte is, then use the [`to_str`](#method.to_str) method.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// assert!(B(\"abc\").is_utf8());\n    /// assert!(B(\"☃βツ\").is_utf8());\n    /// // invalid bytes\n    /// assert!(!B(b\"abc\\xFF\").is_utf8());\n    /// // surrogate encoding\n    /// assert!(!B(b\"\\xED\\xA0\\x80\").is_utf8());\n    /// // incomplete sequence\n    /// assert!(!B(b\"\\xF0\\x9D\\x9Ca\").is_utf8());\n    /// // overlong sequence\n    /// assert!(!B(b\"\\xF0\\x82\\x82\\xAC\").is_utf8());\n    /// ```\n    #[inline]\n    fn is_utf8(&self) -> bool {\n        utf8::validate(self.as_bytes()).is_ok()\n    }\n\n    /// Returns the last byte in this byte string, if it's non-empty. If this\n    /// byte string is empty, this returns `None`.\n    ///\n    /// Note that this is like the generic `[u8]::last`, except this returns\n    /// the byte by value instead of a reference to the byte.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteSlice;\n    ///\n    /// assert_eq!(Some(b'z'), b\"baz\".last_byte());\n    /// assert_eq!(None, b\"\".last_byte());\n    /// ```\n    #[inline]\n    fn last_byte(&self) -> Option<u8> {\n        let bytes = self.as_bytes();\n        bytes.get(bytes.len().saturating_sub(1)).map(|&b| b)\n    }\n\n    /// Returns the index of the first non-ASCII byte in this byte string (if\n    /// any such indices exist). Specifically, it returns the index of the\n    /// first byte with a value greater than or equal to `0x80`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{ByteSlice, B};\n    ///\n    /// assert_eq!(Some(3), b\"abc\\xff\".find_non_ascii_byte());\n    /// assert_eq!(None, b\"abcde\".find_non_ascii_byte());\n    /// assert_eq!(Some(0), B(\"😀\").find_non_ascii_byte());\n    /// ```\n    #[inline]\n    fn find_non_ascii_byte(&self) -> Option<usize> {\n        let index = ascii::first_non_ascii_byte(self.as_bytes());\n        if index == self.as_bytes().len() {\n            None\n        } else {\n            Some(index)\n        }\n    }\n\n    /// Copies elements from one part of the slice to another part of itself,\n    /// where the parts may be overlapping.\n    ///\n    /// `src` is the range within this byte string to copy from, while `dest`\n    /// is the starting index of the range within this byte string to copy to.\n    /// The length indicated by `src` must be less than or equal to the number\n    /// of bytes from `dest` to the end of the byte string.\n    ///\n    /// # Panics\n    ///\n    /// Panics if either range is out of bounds, or if `src` is too big to fit\n    /// into `dest`, or if the end of `src` is before the start.\n    ///\n    /// # Examples\n    ///\n    /// Copying four bytes within a byte string:\n    ///\n    /// ```\n    /// use bstr::{B, ByteSlice};\n    ///\n    /// let mut buf = *b\"Hello, World!\";\n    /// let s = &mut buf;\n    /// s.copy_within_str(1..5, 8);\n    /// assert_eq!(s, B(\"Hello, Wello!\"));\n    /// ```\n    #[inline]\n    fn copy_within_str<R>(&mut self, src: R, dest: usize)\n    where\n        R: ops::RangeBounds<usize>,\n    {\n        // TODO: Deprecate this once slice::copy_within stabilizes.\n        let src_start = match src.start_bound() {\n            ops::Bound::Included(&n) => n,\n            ops::Bound::Excluded(&n) => {\n                n.checked_add(1).expect(\"attempted to index slice beyond max\")\n            }\n            ops::Bound::Unbounded => 0,\n        };\n        let src_end = match src.end_bound() {\n            ops::Bound::Included(&n) => {\n                n.checked_add(1).expect(\"attempted to index slice beyond max\")\n            }\n            ops::Bound::Excluded(&n) => n,\n            ops::Bound::Unbounded => self.as_bytes().len(),\n        };\n        assert!(src_start <= src_end, \"src end is before src start\");\n        assert!(src_end <= self.as_bytes().len(), \"src is out of bounds\");\n        let count = src_end - src_start;\n        assert!(\n            dest <= self.as_bytes().len() - count,\n            \"dest is out of bounds\",\n        );\n\n        // SAFETY: This is safe because we use ptr::copy to handle overlapping\n        // copies, and is also safe because we've checked all the bounds above.\n        // Finally, we are only dealing with u8 data, which is Copy, which\n        // means we can copy without worrying about ownership/destructors.\n        unsafe {\n            ptr::copy(\n                self.as_bytes().get_unchecked(src_start),\n                self.as_bytes_mut().get_unchecked_mut(dest),\n                count,\n            );\n        }\n    }\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::as_bstr":["/// Return this byte slice as a `&BStr`.\n///\n/// Use `&BStr` is useful because of its `fmt::Debug` representation\n/// and various other trait implementations (such as `PartialEq` and\n/// `PartialOrd`). In particular, the `Debug` implementation for `BStr`\n/// shows its bytes as a normal string. For invalid UTF-8, hex escape\n/// sequences are used.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// println!(\"{:?}\", b\"foo\\xFFbar\".as_bstr());\n/// ```\n#[inline]\nfn as_bstr(&self) -> &BStr{\n        BStr::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::as_bstr_mut":["/// Return this byte slice as a `&mut BStr`.\n///\n/// Use `&mut BStr` is useful because of its `fmt::Debug` representation\n/// and various other trait implementations (such as `PartialEq` and\n/// `PartialOrd`). In particular, the `Debug` implementation for `BStr`\n/// shows its bytes as a normal string. For invalid UTF-8, hex escape\n/// sequences are used.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut bytes = *b\"foo\\xFFbar\";\n/// println!(\"{:?}\", &mut bytes.as_bstr_mut());\n/// ```\n#[inline]\nfn as_bstr_mut(&mut self) -> &mut BStr{\n        BStr::new_mut(self.as_bytes_mut())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::bytes":["/// Returns an iterator over the bytes in this byte string.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = b\"foobar\";\n/// let bytes: Vec<u8> = bs.bytes().collect();\n/// assert_eq!(bytes, bs);\n/// ```\n#[inline]\nfn bytes(&self) -> Bytes{\n        Bytes { it: self.as_bytes().iter() }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::char_indices":["/// Returns an iterator over the Unicode scalar values in this byte string\n/// along with their starting and ending byte index positions. If invalid\n/// UTF-8 is encountered, then the Unicode replacement codepoint is yielded\n/// instead.\n///\n/// Note that this is slightly different from the `CharIndices` iterator\n/// provided by the standard library. Aside from working on possibly\n/// invalid UTF-8, this iterator provides both the corresponding starting\n/// and ending byte indices of each codepoint yielded. The ending position\n/// is necessary to slice the original byte string when invalid UTF-8 bytes\n/// are converted into a Unicode replacement codepoint, since a single\n/// replacement codepoint can substitute anywhere from 1 to 3 invalid bytes\n/// (inclusive).\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\";\n/// let chars: Vec<(usize, usize, char)> = bs.char_indices().collect();\n/// assert_eq!(chars, vec![\n///     (0, 3, '☃'),\n///     (3, 4, '\\u{FFFD}'),\n///     (4, 8, '𝞃'),\n///     (8, 10, '\\u{FFFD}'),\n///     (10, 11, 'a'),\n/// ]);\n/// ```\n///\n/// Codepoints can also be iterated over in reverse:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\";\n/// let chars: Vec<(usize, usize, char)> = bs\n///     .char_indices()\n///     .rev()\n///     .collect();\n/// assert_eq!(chars, vec![\n///     (10, 11, 'a'),\n///     (8, 10, '\\u{FFFD}'),\n///     (4, 8, '𝞃'),\n///     (3, 4, '\\u{FFFD}'),\n///     (0, 3, '☃'),\n/// ]);\n/// ```\n#[inline]\nfn char_indices(&self) -> CharIndices{\n        CharIndices::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::chars":["/// Returns an iterator over the Unicode scalar values in this byte string.\n/// If invalid UTF-8 is encountered, then the Unicode replacement codepoint\n/// is yielded instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\";\n/// let chars: Vec<char> = bs.chars().collect();\n/// assert_eq!(vec!['☃', '\\u{FFFD}', '𝞃', '\\u{FFFD}', 'a'], chars);\n/// ```\n///\n/// Codepoints can also be iterated over in reverse:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\";\n/// let chars: Vec<char> = bs.chars().rev().collect();\n/// assert_eq!(vec!['a', '\\u{FFFD}', '𝞃', '\\u{FFFD}', '☃'], chars);\n/// ```\n#[inline]\nfn chars(&self) -> Chars{\n        Chars::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::contains_str":["/// Returns true if and only if this byte string contains the given needle.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// assert!(b\"foo bar\".contains_str(\"foo\"));\n/// assert!(b\"foo bar\".contains_str(\"bar\"));\n/// assert!(!b\"foo\".contains_str(\"foobar\"));\n/// ```\n#[inline]\nfn contains_str<B: AsRef<[u8]>>(&self, needle: B) -> bool{\n        self.find(needle).is_some()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::copy_within_str":["/// Copies elements from one part of the slice to another part of itself,\n/// where the parts may be overlapping.\n///\n/// `src` is the range within this byte string to copy from, while `dest`\n/// is the starting index of the range within this byte string to copy to.\n/// The length indicated by `src` must be less than or equal to the number\n/// of bytes from `dest` to the end of the byte string.\n///\n/// # Panics\n///\n/// Panics if either range is out of bounds, or if `src` is too big to fit\n/// into `dest`, or if the end of `src` is before the start.\n///\n/// # Examples\n///\n/// Copying four bytes within a byte string:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let mut buf = *b\"Hello, World!\";\n/// let s = &mut buf;\n/// s.copy_within_str(1..5, 8);\n/// assert_eq!(s, B(\"Hello, Wello!\"));\n/// ```\n#[inline]\nfn copy_within_str<R>(&mut self, src: R, dest: usize)\n    where\n        R: ops::RangeBounds<usize>,{\n        // TODO: Deprecate this once slice::copy_within stabilizes.\n        let src_start = match src.start_bound() {\n            ops::Bound::Included(&n) => n,\n            ops::Bound::Excluded(&n) => {\n                n.checked_add(1).expect(\"attempted to index slice beyond max\")\n            }\n            ops::Bound::Unbounded => 0,\n        };\n        let src_end = match src.end_bound() {\n            ops::Bound::Included(&n) => {\n                n.checked_add(1).expect(\"attempted to index slice beyond max\")\n            }\n            ops::Bound::Excluded(&n) => n,\n            ops::Bound::Unbounded => self.as_bytes().len(),\n        };\n        assert!(src_start <= src_end, \"src end is before src start\");\n        assert!(src_end <= self.as_bytes().len(), \"src is out of bounds\");\n        let count = src_end - src_start;\n        assert!(\n            dest <= self.as_bytes().len() - count,\n            \"dest is out of bounds\",\n        );\n\n        // SAFETY: This is safe because we use ptr::copy to handle overlapping\n        // copies, and is also safe because we've checked all the bounds above.\n        // Finally, we are only dealing with u8 data, which is Copy, which\n        // means we can copy without worrying about ownership/destructors.\n        unsafe {\n            ptr::copy(\n                self.as_bytes().get_unchecked(src_start),\n                self.as_bytes_mut().get_unchecked_mut(dest),\n                count,\n            );\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::ends_with_str":["/// Returns true if and only if this byte string has the given suffix.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// assert!(b\"foo bar\".ends_with_str(\"bar\"));\n/// assert!(!b\"foo bar\".ends_with_str(\"foo\"));\n/// assert!(!b\"bar\".ends_with_str(\"foobar\"));\n/// ```\n#[inline]\nfn ends_with_str<B: AsRef<[u8]>>(&self, suffix: B) -> bool{\n        self.as_bytes().ends_with(suffix.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::fields":["/// Returns an iterator over the fields in a byte string, separated by\n/// contiguous whitespace.\n///\n/// # Example\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\"  foo\\tbar\\t\\u{2003}\\nquux   \\n\");\n/// let fields: Vec<&[u8]> = s.fields().collect();\n/// assert_eq!(fields, vec![B(\"foo\"), B(\"bar\"), B(\"quux\")]);\n/// ```\n///\n/// A byte string consisting of just whitespace yields no elements:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// assert_eq!(0, B(\"  \\n\\t\\u{2003}\\n  \\t\").fields().count());\n/// ```\n#[inline]\nfn fields(&self) -> Fields{\n        Fields::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::fields_with":["/// Returns an iterator over the fields in a byte string, separated by\n/// contiguous codepoints satisfying the given predicate.\n///\n/// If this byte string is not valid UTF-8, then the given closure will\n/// be called with a Unicode replacement codepoint when invalid UTF-8\n/// bytes are seen.\n///\n/// # Example\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = b\"123foo999999bar1quux123456\";\n/// let fields: Vec<&[u8]> = s.fields_with(|c| c.is_numeric()).collect();\n/// assert_eq!(fields, vec![B(\"foo\"), B(\"bar\"), B(\"quux\")]);\n/// ```\n///\n/// A byte string consisting of all codepoints satisfying the predicate\n/// yields no elements:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// assert_eq!(0, b\"1911354563\".fields_with(|c| c.is_numeric()).count());\n/// ```\n#[inline]\nfn fields_with<F: FnMut(char) -> bool>(&self, f: F) -> FieldsWith<F>{\n        FieldsWith::new(self.as_bytes(), f)\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::find":["/// Returns the index of the first occurrence of the given needle.\n///\n/// The needle may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n///\n/// Note that if you're are searching for the same needle in many\n/// different small haystacks, it may be faster to initialize a\n/// [`Finder`](struct.Finder.html) once, and reuse it for each search.\n///\n/// # Complexity\n///\n/// This routine is guaranteed to have worst case linear time complexity\n/// with respect to both the needle and the haystack. That is, this runs\n/// in `O(needle.len() + haystack.len())` time.\n///\n/// This routine is also guaranteed to have worst case constant space\n/// complexity.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foo bar baz\";\n/// assert_eq!(Some(0), s.find(\"foo\"));\n/// assert_eq!(Some(4), s.find(\"bar\"));\n/// assert_eq!(None, s.find(\"quux\"));\n/// ```\n#[inline]\nfn find<B: AsRef<[u8]>>(&self, needle: B) -> Option<usize>{\n        Finder::new(needle.as_ref()).find(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::find_byte":["/// Returns the index of the first occurrence of the given byte. If the\n/// byte does not occur in this byte string, then `None` is returned.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// assert_eq!(Some(10), b\"foo bar baz\".find_byte(b'z'));\n/// assert_eq!(None, b\"foo bar baz\".find_byte(b'y'));\n/// ```\n#[inline]\nfn find_byte(&self, byte: u8) -> Option<usize>{\n        memchr(byte, self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::find_byteset":["/// Returns the index of the first occurrence of any of the bytes in the\n/// provided set.\n///\n/// The `byteset` may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`, but\n/// note that passing a `&str` which contains multibyte characters may not\n/// behave as you expect: each byte in the `&str` is treated as an\n/// individual member of the byte set.\n///\n/// Note that order is irrelevant for the `byteset` parameter, and\n/// duplicate bytes present in its body are ignored.\n///\n/// # Complexity\n///\n/// This routine is guaranteed to have worst case linear time complexity\n/// with respect to both the set of bytes and the haystack. That is, this\n/// runs in `O(byteset.len() + haystack.len())` time.\n///\n/// This routine is also guaranteed to have worst case constant space\n/// complexity.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// assert_eq!(b\"foo bar baz\".find_byteset(b\"zr\"), Some(6));\n/// assert_eq!(b\"foo baz bar\".find_byteset(b\"bzr\"), Some(4));\n/// assert_eq!(None, b\"foo baz bar\".find_byteset(b\"\\t\\n\"));\n/// ```\n#[inline]\nfn find_byteset<B: AsRef<[u8]>>(&self, byteset: B) -> Option<usize>{\n        byteset::find(self.as_bytes(), byteset.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::find_char":["/// Returns the index of the first occurrence of the given codepoint.\n/// If the codepoint does not occur in this byte string, then `None` is\n/// returned.\n///\n/// Note that if one searches for the replacement codepoint, `\\u{FFFD}`,\n/// then only explicit occurrences of that encoding will be found. Invalid\n/// UTF-8 sequences will not be matched.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// assert_eq!(Some(10), b\"foo bar baz\".find_char('z'));\n/// assert_eq!(Some(4), B(\"αβγγδ\").find_char('γ'));\n/// assert_eq!(None, b\"foo bar baz\".find_char('y'));\n/// ```\n#[inline]\nfn find_char(&self, ch: char) -> Option<usize>{\n        self.find(ch.encode_utf8(&mut [0; 4]))\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::find_iter":["/// Returns an iterator of the non-overlapping occurrences of the given\n/// needle. The iterator yields byte offset positions indicating the start\n/// of each match.\n///\n/// # Complexity\n///\n/// This routine is guaranteed to have worst case linear time complexity\n/// with respect to both the needle and the haystack. That is, this runs\n/// in `O(needle.len() + haystack.len())` time.\n///\n/// This routine is also guaranteed to have worst case constant space\n/// complexity.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foo bar foo foo quux foo\";\n/// let matches: Vec<usize> = s.find_iter(\"foo\").collect();\n/// assert_eq!(matches, vec![0, 8, 12, 21]);\n/// ```\n///\n/// An empty string matches at every position, including the position\n/// immediately following the last byte:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let matches: Vec<usize> = b\"foo\".find_iter(\"\").collect();\n/// assert_eq!(matches, vec![0, 1, 2, 3]);\n///\n/// let matches: Vec<usize> = b\"\".find_iter(\"\").collect();\n/// assert_eq!(matches, vec![0]);\n/// ```\n#[inline]\nfn find_iter<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        needle: &'a B,\n    ) -> Find<'a>{\n        Find::new(self.as_bytes(), needle.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::find_non_ascii_byte":["/// Returns the index of the first non-ASCII byte in this byte string (if\n/// any such indices exist). Specifically, it returns the index of the\n/// first byte with a value greater than or equal to `0x80`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{ByteSlice, B};\n///\n/// assert_eq!(Some(3), b\"abc\\xff\".find_non_ascii_byte());\n/// assert_eq!(None, b\"abcde\".find_non_ascii_byte());\n/// assert_eq!(Some(0), B(\"😀\").find_non_ascii_byte());\n/// ```\n#[inline]\nfn find_non_ascii_byte(&self) -> Option<usize>{\n        let index = ascii::first_non_ascii_byte(self.as_bytes());\n        if index == self.as_bytes().len() {\n            None\n        } else {\n            Some(index)\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::find_not_byteset":["/// Returns the index of the first occurrence of a byte that is not a member\n/// of the provided set.\n///\n/// The `byteset` may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`, but\n/// note that passing a `&str` which contains multibyte characters may not\n/// behave as you expect: each byte in the `&str` is treated as an\n/// individual member of the byte set.\n///\n/// Note that order is irrelevant for the `byteset` parameter, and\n/// duplicate bytes present in its body are ignored.\n///\n/// # Complexity\n///\n/// This routine is guaranteed to have worst case linear time complexity\n/// with respect to both the set of bytes and the haystack. That is, this\n/// runs in `O(byteset.len() + haystack.len())` time.\n///\n/// This routine is also guaranteed to have worst case constant space\n/// complexity.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// assert_eq!(b\"foo bar baz\".find_not_byteset(b\"fo \"), Some(4));\n/// assert_eq!(b\"\\t\\tbaz bar\".find_not_byteset(b\" \\t\\r\\n\"), Some(2));\n/// assert_eq!(b\"foo\\nbaz\\tbar\".find_not_byteset(b\"\\t\\n\"), Some(0));\n/// ```\n#[inline]\nfn find_not_byteset<B: AsRef<[u8]>>(&self, byteset: B) -> Option<usize>{\n        byteset::find_not(self.as_bytes(), byteset.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::from_os_str":["/// Create an immutable byte string from an OS string slice.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this returns `None` if the given OS string is not valid UTF-8. (For\n/// example, on Windows, file paths are allowed to be a sequence of\n/// arbitrary 16-bit integers. Not all such sequences can be transcoded to\n/// valid UTF-8.)\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::ffi::OsStr;\n///\n/// use bstr::{B, ByteSlice};\n///\n/// let os_str = OsStr::new(\"foo\");\n/// let bs = <[u8]>::from_os_str(os_str).expect(\"should be valid UTF-8\");\n/// assert_eq!(bs, B(\"foo\"));\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn from_os_str(os_str: &OsStr) -> Option<&[u8]>{\n        #[cfg(unix)]\n        #[inline]\n        fn imp(os_str: &OsStr) -> Option<&[u8]> {\n            use std::os::unix::ffi::OsStrExt;\n\n            Some(os_str.as_bytes())\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(os_str: &OsStr) -> Option<&[u8]> {\n            os_str.to_str().map(|s| s.as_bytes())\n        }\n\n        imp(os_str)\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::from_os_str::imp":["#[cfg(unix)]\n#[inline]\nfn imp(os_str: &OsStr) -> Option<&[u8]>{\n            use std::os::unix::ffi::OsStrExt;\n\n            Some(os_str.as_bytes())\n        }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::from_path":["/// Create an immutable byte string from a file path.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this returns `None` if the given path is not valid UTF-8. (For example,\n/// on Windows, file paths are allowed to be a sequence of arbitrary 16-bit\n/// integers. Not all such sequences can be transcoded to valid UTF-8.)\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::path::Path;\n///\n/// use bstr::{B, ByteSlice};\n///\n/// let path = Path::new(\"foo\");\n/// let bs = <[u8]>::from_path(path).expect(\"should be valid UTF-8\");\n/// assert_eq!(bs, B(\"foo\"));\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn from_path(path: &Path) -> Option<&[u8]>{\n        Self::from_os_str(path.as_os_str())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::grapheme_indices":["/// Returns an iterator over the grapheme clusters in this byte string\n/// along with their starting and ending byte index positions. If invalid\n/// UTF-8 is encountered, then the Unicode replacement codepoint is yielded\n/// instead.\n///\n/// # Examples\n///\n/// This example shows how to get the byte offsets of each individual\n/// grapheme cluster:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = \"a\\u{0300}\\u{0316}\\u{1F1FA}\\u{1F1F8}\".as_bytes();\n/// let graphemes: Vec<(usize, usize, &str)> =\n///     bs.grapheme_indices().collect();\n/// assert_eq!(vec![(0, 5, \"à̖\"), (5, 13, \"🇺🇸\")], graphemes);\n/// ```\n///\n/// This example shows what happens when invalid UTF-8 is enountered. Note\n/// that the offsets are valid indices into the original string, and do\n/// not necessarily correspond to the length of the `&str` returned!\n///\n/// ```\n/// use bstr::{ByteSlice, ByteVec};\n///\n/// let mut bytes = vec![];\n/// bytes.push_str(\"a\\u{0300}\\u{0316}\");\n/// bytes.push(b'\\xFF');\n/// bytes.push_str(\"\\u{1F1FA}\\u{1F1F8}\");\n///\n/// let graphemes: Vec<(usize, usize, &str)> =\n///     bytes.grapheme_indices().collect();\n/// assert_eq!(\n///     graphemes,\n///     vec![(0, 5, \"à̖\"), (5, 6, \"\\u{FFFD}\"), (6, 14, \"🇺🇸\")]\n/// );\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn grapheme_indices(&self) -> GraphemeIndices{\n        GraphemeIndices::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::graphemes":["/// Returns an iterator over the grapheme clusters in this byte string.\n/// If invalid UTF-8 is encountered, then the Unicode replacement codepoint\n/// is yielded instead.\n///\n/// # Examples\n///\n/// This example shows how multiple codepoints can combine to form a\n/// single grapheme cluster:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = \"a\\u{0300}\\u{0316}\\u{1F1FA}\\u{1F1F8}\".as_bytes();\n/// let graphemes: Vec<&str> = bs.graphemes().collect();\n/// assert_eq!(vec![\"à̖\", \"🇺🇸\"], graphemes);\n/// ```\n///\n/// This shows that graphemes can be iterated over in reverse:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = \"a\\u{0300}\\u{0316}\\u{1F1FA}\\u{1F1F8}\".as_bytes();\n/// let graphemes: Vec<&str> = bs.graphemes().rev().collect();\n/// assert_eq!(vec![\"🇺🇸\", \"à̖\"], graphemes);\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn graphemes(&self) -> Graphemes{\n        Graphemes::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::is_ascii":["/// Returns true if and only if every byte in this byte string is ASCII.\n///\n/// ASCII is an encoding that defines 128 codepoints. A byte corresponds to\n/// an ASCII codepoint if and only if it is in the inclusive range\n/// `[0, 127]`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// assert!(B(\"abc\").is_ascii());\n/// assert!(!B(\"☃βツ\").is_ascii());\n/// assert!(!B(b\"\\xFF\").is_ascii());\n/// ```\n#[inline]\nfn is_ascii(&self) -> bool{\n        ascii::first_non_ascii_byte(self.as_bytes()) == self.as_bytes().len()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::is_utf8":["/// Returns true if and only if the entire byte string is valid UTF-8.\n///\n/// If you need location information about where a byte string's first\n/// invalid UTF-8 byte is, then use the [`to_str`](#method.to_str) method.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// assert!(B(\"abc\").is_utf8());\n/// assert!(B(\"☃βツ\").is_utf8());\n/// // invalid bytes\n/// assert!(!B(b\"abc\\xFF\").is_utf8());\n/// // surrogate encoding\n/// assert!(!B(b\"\\xED\\xA0\\x80\").is_utf8());\n/// // incomplete sequence\n/// assert!(!B(b\"\\xF0\\x9D\\x9Ca\").is_utf8());\n/// // overlong sequence\n/// assert!(!B(b\"\\xF0\\x82\\x82\\xAC\").is_utf8());\n/// ```\n#[inline]\nfn is_utf8(&self) -> bool{\n        utf8::validate(self.as_bytes()).is_ok()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::last_byte":["/// Returns the last byte in this byte string, if it's non-empty. If this\n/// byte string is empty, this returns `None`.\n///\n/// Note that this is like the generic `[u8]::last`, except this returns\n/// the byte by value instead of a reference to the byte.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// assert_eq!(Some(b'z'), b\"baz\".last_byte());\n/// assert_eq!(None, b\"\".last_byte());\n/// ```\n#[inline]\nfn last_byte(&self) -> Option<u8>{\n        let bytes = self.as_bytes();\n        bytes.get(bytes.len().saturating_sub(1)).map(|&b| b)\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::lines":["/// An iterator over all lines in a byte string, without their\n/// terminators.\n///\n/// For this iterator, the only line terminators recognized are `\\r\\n` and\n/// `\\n`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = b\"\\\n/// foo\n///\n/// bar\\r\n/// baz\n///\n///\n/// quux\";\n/// let lines: Vec<&[u8]> = s.lines().collect();\n/// assert_eq!(lines, vec![\n///     B(\"foo\"), B(\"\"), B(\"bar\"), B(\"baz\"), B(\"\"), B(\"\"), B(\"quux\"),\n/// ]);\n/// ```\n#[inline]\nfn lines(&self) -> Lines{\n        Lines::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::lines_with_terminator":["/// An iterator over all lines in a byte string, including their\n/// terminators.\n///\n/// For this iterator, the only line terminator recognized is `\\n`. (Since\n/// line terminators are included, this also handles `\\r\\n` line endings.)\n///\n/// Line terminators are only included if they are present in the original\n/// byte string. For example, the last line in a byte string may not end\n/// with a line terminator.\n///\n/// Concatenating all elements yielded by this iterator is guaranteed to\n/// yield the original byte string.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = b\"\\\n/// foo\n///\n/// bar\\r\n/// baz\n///\n///\n/// quux\";\n/// let lines: Vec<&[u8]> = s.lines_with_terminator().collect();\n/// assert_eq!(lines, vec![\n///     B(\"foo\\n\"),\n///     B(\"\\n\"),\n///     B(\"bar\\r\\n\"),\n///     B(\"baz\\n\"),\n///     B(\"\\n\"),\n///     B(\"\\n\"),\n///     B(\"quux\"),\n/// ]);\n/// ```\n#[inline]\nfn lines_with_terminator(&self) -> LinesWithTerminator{\n        LinesWithTerminator::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::make_ascii_lowercase":["/// Convert this byte string to its lowercase ASCII equivalent in place.\n///\n/// In this case, lowercase is only defined in ASCII letters. Namely, the\n/// letters `A-Z` are converted to `a-z`. All other bytes remain unchanged.\n///\n/// If you don't need to do the conversion in\n/// place and instead prefer convenience, then use\n/// [`to_ascii_lowercase`](#method.to_ascii_lowercase) instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut s = <Vec<u8>>::from(\"HELLO Β\");\n/// s.make_ascii_lowercase();\n/// assert_eq!(s, \"hello Β\".as_bytes());\n/// ```\n///\n/// Invalid UTF-8 remains as is:\n///\n/// ```\n/// use bstr::{B, ByteSlice, ByteVec};\n///\n/// let mut s = <Vec<u8>>::from_slice(b\"FOO\\xFFBAR\\xE2\\x98BAZ\");\n/// s.make_ascii_lowercase();\n/// assert_eq!(s, B(b\"foo\\xFFbar\\xE2\\x98baz\"));\n/// ```\n#[inline]\nfn make_ascii_lowercase(&mut self){\n        self.as_bytes_mut().make_ascii_lowercase();\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::make_ascii_uppercase":["/// Convert this byte string to its uppercase ASCII equivalent in place.\n///\n/// In this case, uppercase is only defined in ASCII letters. Namely, the\n/// letters `a-z` are converted to `A-Z`. All other bytes remain unchanged.\n///\n/// If you don't need to do the conversion in\n/// place and instead prefer convenience, then use\n/// [`to_ascii_uppercase`](#method.to_ascii_uppercase) instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let mut s = <Vec<u8>>::from(\"hello β\");\n/// s.make_ascii_uppercase();\n/// assert_eq!(s, B(\"HELLO β\"));\n/// ```\n///\n/// Invalid UTF-8 remains as is:\n///\n/// ```\n/// use bstr::{B, ByteSlice, ByteVec};\n///\n/// let mut s = <Vec<u8>>::from_slice(b\"foo\\xFFbar\\xE2\\x98baz\");\n/// s.make_ascii_uppercase();\n/// assert_eq!(s, B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\"));\n/// ```\n#[inline]\nfn make_ascii_uppercase(&mut self){\n        self.as_bytes_mut().make_ascii_uppercase();\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::repeatn":["/// Create a new byte string by repeating this byte string `n` times.\n///\n/// # Panics\n///\n/// This function panics if the capacity of the new byte string would\n/// overflow.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// assert_eq!(b\"foo\".repeatn(4), B(\"foofoofoofoo\"));\n/// assert_eq!(b\"foo\".repeatn(0), B(\"\"));\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn repeatn(&self, n: usize) -> Vec<u8>{\n        let bs = self.as_bytes();\n        let mut dst = vec![0; bs.len() * n];\n        for i in 0..n {\n            dst[i * bs.len()..(i + 1) * bs.len()].copy_from_slice(bs);\n        }\n        dst\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::replace":["/// Replace all matches of the given needle with the given replacement, and\n/// the result as a new `Vec<u8>`.\n///\n/// This routine is useful as a convenience. If you need to reuse an\n/// allocation, use [`replace_into`](#method.replace_into) instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"this is old\".replace(\"old\", \"new\");\n/// assert_eq!(s, \"this is new\".as_bytes());\n/// ```\n///\n/// When the pattern doesn't match:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"this is old\".replace(\"nada nada\", \"limonada\");\n/// assert_eq!(s, \"this is old\".as_bytes());\n/// ```\n///\n/// When the needle is an empty string:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foo\".replace(\"\", \"Z\");\n/// assert_eq!(s, \"ZfZoZoZ\".as_bytes());\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn replace<N: AsRef<[u8]>, R: AsRef<[u8]>>(\n        &self,\n        needle: N,\n        replacement: R,\n    ) -> Vec<u8>{\n        let mut dest = Vec::with_capacity(self.as_bytes().len());\n        self.replace_into(needle, replacement, &mut dest);\n        dest\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::replace_into":["/// Replace all matches of the given needle with the given replacement,\n/// and write the result into the provided `Vec<u8>`.\n///\n/// This does **not** clear `dest` before writing to it.\n///\n/// This routine is useful for reusing allocation. For a more convenient\n/// API, use [`replace`](#method.replace) instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"this is old\";\n///\n/// let mut dest = vec![];\n/// s.replace_into(\"old\", \"new\", &mut dest);\n/// assert_eq!(dest, \"this is new\".as_bytes());\n/// ```\n///\n/// When the pattern doesn't match:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"this is old\";\n///\n/// let mut dest = vec![];\n/// s.replace_into(\"nada nada\", \"limonada\", &mut dest);\n/// assert_eq!(dest, \"this is old\".as_bytes());\n/// ```\n///\n/// When the needle is an empty string:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foo\";\n///\n/// let mut dest = vec![];\n/// s.replace_into(\"\", \"Z\", &mut dest);\n/// assert_eq!(dest, \"ZfZoZoZ\".as_bytes());\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn replace_into<N: AsRef<[u8]>, R: AsRef<[u8]>>(\n        &self,\n        needle: N,\n        replacement: R,\n        dest: &mut Vec<u8>,\n    ){\n        let (needle, replacement) = (needle.as_ref(), replacement.as_ref());\n\n        let mut last = 0;\n        for start in self.find_iter(needle) {\n            dest.push_str(&self.as_bytes()[last..start]);\n            dest.push_str(replacement);\n            last = start + needle.len();\n        }\n        dest.push_str(&self.as_bytes()[last..]);\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::replacen":["/// Replace up to `limit` matches of the given needle with the given\n/// replacement, and the result as a new `Vec<u8>`.\n///\n/// This routine is useful as a convenience. If you need to reuse an\n/// allocation, use [`replacen_into`](#method.replacen_into) instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foofoo\".replacen(\"o\", \"z\", 2);\n/// assert_eq!(s, \"fzzfoo\".as_bytes());\n/// ```\n///\n/// When the pattern doesn't match:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foofoo\".replacen(\"a\", \"z\", 2);\n/// assert_eq!(s, \"foofoo\".as_bytes());\n/// ```\n///\n/// When the needle is an empty string:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foo\".replacen(\"\", \"Z\", 2);\n/// assert_eq!(s, \"ZfZoo\".as_bytes());\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn replacen<N: AsRef<[u8]>, R: AsRef<[u8]>>(\n        &self,\n        needle: N,\n        replacement: R,\n        limit: usize,\n    ) -> Vec<u8>{\n        let mut dest = Vec::with_capacity(self.as_bytes().len());\n        self.replacen_into(needle, replacement, limit, &mut dest);\n        dest\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::replacen_into":["/// Replace up to `limit` matches of the given needle with the given\n/// replacement, and write the result into the provided `Vec<u8>`.\n///\n/// This does **not** clear `dest` before writing to it.\n///\n/// This routine is useful for reusing allocation. For a more convenient\n/// API, use [`replacen`](#method.replacen) instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foofoo\";\n///\n/// let mut dest = vec![];\n/// s.replacen_into(\"o\", \"z\", 2, &mut dest);\n/// assert_eq!(dest, \"fzzfoo\".as_bytes());\n/// ```\n///\n/// When the pattern doesn't match:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foofoo\";\n///\n/// let mut dest = vec![];\n/// s.replacen_into(\"a\", \"z\", 2, &mut dest);\n/// assert_eq!(dest, \"foofoo\".as_bytes());\n/// ```\n///\n/// When the needle is an empty string:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foo\";\n///\n/// let mut dest = vec![];\n/// s.replacen_into(\"\", \"Z\", 2, &mut dest);\n/// assert_eq!(dest, \"ZfZoo\".as_bytes());\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn replacen_into<N: AsRef<[u8]>, R: AsRef<[u8]>>(\n        &self,\n        needle: N,\n        replacement: R,\n        limit: usize,\n        dest: &mut Vec<u8>,\n    ){\n        let (needle, replacement) = (needle.as_ref(), replacement.as_ref());\n\n        let mut last = 0;\n        for start in self.find_iter(needle).take(limit) {\n            dest.push_str(&self.as_bytes()[last..start]);\n            dest.push_str(replacement);\n            last = start + needle.len();\n        }\n        dest.push_str(&self.as_bytes()[last..]);\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::reverse_bytes":["/// Reverse the bytes in this string, in place.\n///\n/// This is not necessarily a well formed operation! For example, if this\n/// byte string contains valid UTF-8 that isn't ASCII, then reversing the\n/// string will likely result in invalid UTF-8 and otherwise non-sensical\n/// content.\n///\n/// Note that this is equivalent to the generic `[u8]::reverse` method.\n/// This method is provided to permit callers to explicitly differentiate\n/// between reversing bytes, codepoints and graphemes.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut s = <Vec<u8>>::from(\"hello\");\n/// s.reverse_bytes();\n/// assert_eq!(s, \"olleh\".as_bytes());\n/// ```\n#[inline]\nfn reverse_bytes(&mut self){\n        self.as_bytes_mut().reverse();\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::reverse_chars":["/// Reverse the codepoints in this string, in place.\n///\n/// If this byte string is valid UTF-8, then its reversal by codepoint\n/// is also guaranteed to be valid UTF-8.\n///\n/// This operation is equivalent to the following, but without allocating:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut s = <Vec<u8>>::from(\"foo☃bar\");\n///\n/// let mut chars: Vec<char> = s.chars().collect();\n/// chars.reverse();\n///\n/// let reversed: String = chars.into_iter().collect();\n/// assert_eq!(reversed, \"rab☃oof\");\n/// ```\n///\n/// Note that this is not necessarily a well formed operation. For example,\n/// if this byte string contains grapheme clusters with more than one\n/// codepoint, then those grapheme clusters will not necessarily be\n/// preserved. If you'd like to preserve grapheme clusters, then use\n/// [`reverse_graphemes`](#method.reverse_graphemes) instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut s = <Vec<u8>>::from(\"foo☃bar\");\n/// s.reverse_chars();\n/// assert_eq!(s, \"rab☃oof\".as_bytes());\n/// ```\n///\n/// This example shows that not all reversals lead to a well formed string.\n/// For example, in this case, combining marks are used to put accents over\n/// some letters, and those accent marks must appear after the codepoints\n/// they modify.\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let mut s = <Vec<u8>>::from(\"résumé\");\n/// s.reverse_chars();\n/// assert_eq!(s, B(b\"\\xCC\\x81emus\\xCC\\x81er\"));\n/// ```\n///\n/// A word of warning: the above example relies on the fact that\n/// `résumé` is in decomposed normal form, which means there are separate\n/// codepoints for the accents above `e`. If it is instead in composed\n/// normal form, then the example works:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let mut s = <Vec<u8>>::from(\"résumé\");\n/// s.reverse_chars();\n/// assert_eq!(s, B(\"émusér\"));\n/// ```\n///\n/// The point here is to be cautious and not assume that just because\n/// `reverse_chars` works in one case, that it therefore works in all\n/// cases.\n#[inline]\nfn reverse_chars(&mut self){\n        let mut i = 0;\n        loop {\n            let (_, size) = utf8::decode(&self.as_bytes()[i..]);\n            if size == 0 {\n                break;\n            }\n            if size > 1 {\n                self.as_bytes_mut()[i..i + size].reverse_bytes();\n            }\n            i += size;\n        }\n        self.reverse_bytes();\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::reverse_graphemes":["/// Reverse the graphemes in this string, in place.\n///\n/// If this byte string is valid UTF-8, then its reversal by grapheme\n/// is also guaranteed to be valid UTF-8.\n///\n/// This operation is equivalent to the following, but without allocating:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut s = <Vec<u8>>::from(\"foo☃bar\");\n///\n/// let mut graphemes: Vec<&str> = s.graphemes().collect();\n/// graphemes.reverse();\n///\n/// let reversed = graphemes.concat();\n/// assert_eq!(reversed, \"rab☃oof\");\n/// ```\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut s = <Vec<u8>>::from(\"foo☃bar\");\n/// s.reverse_graphemes();\n/// assert_eq!(s, \"rab☃oof\".as_bytes());\n/// ```\n///\n/// This example shows how this correctly handles grapheme clusters,\n/// unlike `reverse_chars`.\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut s = <Vec<u8>>::from(\"résumé\");\n/// s.reverse_graphemes();\n/// assert_eq!(s, \"émusér\".as_bytes());\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn reverse_graphemes(&mut self){\n        use unicode::decode_grapheme;\n\n        let mut i = 0;\n        loop {\n            let (_, size) = decode_grapheme(&self.as_bytes()[i..]);\n            if size == 0 {\n                break;\n            }\n            if size > 1 {\n                self.as_bytes_mut()[i..i + size].reverse_bytes();\n            }\n            i += size;\n        }\n        self.reverse_bytes();\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::rfind":["/// Returns the index of the last occurrence of the given needle.\n///\n/// The needle may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n///\n/// Note that if you're are searching for the same needle in many\n/// different small haystacks, it may be faster to initialize a\n/// [`FinderReverse`](struct.FinderReverse.html) once, and reuse it for\n/// each search.\n///\n/// # Complexity\n///\n/// This routine is guaranteed to have worst case linear time complexity\n/// with respect to both the needle and the haystack. That is, this runs\n/// in `O(needle.len() + haystack.len())` time.\n///\n/// This routine is also guaranteed to have worst case constant space\n/// complexity.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foo bar baz\";\n/// assert_eq!(Some(0), s.rfind(\"foo\"));\n/// assert_eq!(Some(4), s.rfind(\"bar\"));\n/// assert_eq!(Some(8), s.rfind(\"ba\"));\n/// assert_eq!(None, s.rfind(\"quux\"));\n/// ```\n#[inline]\nfn rfind<B: AsRef<[u8]>>(&self, needle: B) -> Option<usize>{\n        FinderReverse::new(needle.as_ref()).rfind(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::rfind_byte":["/// Returns the index of the last occurrence of the given byte. If the\n/// byte does not occur in this byte string, then `None` is returned.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// assert_eq!(Some(10), b\"foo bar baz\".rfind_byte(b'z'));\n/// assert_eq!(None, b\"foo bar baz\".rfind_byte(b'y'));\n/// ```\n#[inline]\nfn rfind_byte(&self, byte: u8) -> Option<usize>{\n        memrchr(byte, self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::rfind_byteset":["/// Returns the index of the last occurrence of any of the bytes in the\n/// provided set.\n///\n/// The `byteset` may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`, but\n/// note that passing a `&str` which contains multibyte characters may not\n/// behave as you expect: each byte in the `&str` is treated as an\n/// individual member of the byte set.\n///\n/// Note that order is irrelevant for the `byteset` parameter, and duplicate\n/// bytes present in its body are ignored.\n///\n/// # Complexity\n///\n/// This routine is guaranteed to have worst case linear time complexity\n/// with respect to both the set of bytes and the haystack. That is, this\n/// runs in `O(byteset.len() + haystack.len())` time.\n///\n/// This routine is also guaranteed to have worst case constant space\n/// complexity.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// assert_eq!(b\"foo bar baz\".rfind_byteset(b\"agb\"), Some(9));\n/// assert_eq!(b\"foo baz bar\".rfind_byteset(b\"rabz \"), Some(10));\n/// assert_eq!(b\"foo baz bar\".rfind_byteset(b\"\\n123\"), None);\n/// ```\n#[inline]\nfn rfind_byteset<B: AsRef<[u8]>>(&self, byteset: B) -> Option<usize>{\n        byteset::rfind(self.as_bytes(), byteset.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::rfind_char":["/// Returns the index of the last occurrence of the given codepoint.\n/// If the codepoint does not occur in this byte string, then `None` is\n/// returned.\n///\n/// Note that if one searches for the replacement codepoint, `\\u{FFFD}`,\n/// then only explicit occurrences of that encoding will be found. Invalid\n/// UTF-8 sequences will not be matched.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// assert_eq!(Some(10), b\"foo bar baz\".rfind_char('z'));\n/// assert_eq!(Some(6), B(\"αβγγδ\").rfind_char('γ'));\n/// assert_eq!(None, b\"foo bar baz\".rfind_char('y'));\n/// ```\n#[inline]\nfn rfind_char(&self, ch: char) -> Option<usize>{\n        self.rfind(ch.encode_utf8(&mut [0; 4]))\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::rfind_iter":["/// Returns an iterator of the non-overlapping occurrences of the given\n/// needle in reverse. The iterator yields byte offset positions indicating\n/// the start of each match.\n///\n/// # Complexity\n///\n/// This routine is guaranteed to have worst case linear time complexity\n/// with respect to both the needle and the haystack. That is, this runs\n/// in `O(needle.len() + haystack.len())` time.\n///\n/// This routine is also guaranteed to have worst case constant space\n/// complexity.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foo bar foo foo quux foo\";\n/// let matches: Vec<usize> = s.rfind_iter(\"foo\").collect();\n/// assert_eq!(matches, vec![21, 12, 8, 0]);\n/// ```\n///\n/// An empty string matches at every position, including the position\n/// immediately following the last byte:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let matches: Vec<usize> = b\"foo\".rfind_iter(\"\").collect();\n/// assert_eq!(matches, vec![3, 2, 1, 0]);\n///\n/// let matches: Vec<usize> = b\"\".rfind_iter(\"\").collect();\n/// assert_eq!(matches, vec![0]);\n/// ```\n#[inline]\nfn rfind_iter<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        needle: &'a B,\n    ) -> FindReverse<'a>{\n        FindReverse::new(self.as_bytes(), needle.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::rfind_not_byteset":["/// Returns the index of the last occurrence of a byte that is not a member\n/// of the provided set.\n///\n/// The `byteset` may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`, but\n/// note that passing a `&str` which contains multibyte characters may not\n/// behave as you expect: each byte in the `&str` is treated as an\n/// individual member of the byte set.\n///\n/// Note that order is irrelevant for the `byteset` parameter, and\n/// duplicate bytes present in its body are ignored.\n///\n/// # Complexity\n///\n/// This routine is guaranteed to have worst case linear time complexity\n/// with respect to both the set of bytes and the haystack. That is, this\n/// runs in `O(byteset.len() + haystack.len())` time.\n///\n/// This routine is also guaranteed to have worst case constant space\n/// complexity.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// assert_eq!(b\"foo bar baz,\\t\".rfind_not_byteset(b\",\\t\"), Some(10));\n/// assert_eq!(b\"foo baz bar\".rfind_not_byteset(b\"rabz \"), Some(2));\n/// assert_eq!(None, b\"foo baz bar\".rfind_not_byteset(b\"barfoz \"));\n/// ```\n#[inline]\nfn rfind_not_byteset<B: AsRef<[u8]>>(&self, byteset: B) -> Option<usize>{\n        byteset::rfind_not(self.as_bytes(), byteset.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::rsplit_str":["/// Returns an iterator over substrings of this byte string, separated by\n/// the given byte string, in reverse. Each element yielded is guaranteed\n/// not to include the splitter substring.\n///\n/// The splitter may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<&[u8]> =\n///     b\"Mary had a little lamb\".rsplit_str(\" \").collect();\n/// assert_eq!(x, vec![\n///     B(\"lamb\"), B(\"little\"), B(\"a\"), B(\"had\"), B(\"Mary\"),\n/// ]);\n///\n/// let x: Vec<&[u8]> = b\"\".rsplit_str(\"X\").collect();\n/// assert_eq!(x, vec![b\"\"]);\n///\n/// let x: Vec<&[u8]> = b\"lionXXtigerXleopard\".rsplit_str(\"X\").collect();\n/// assert_eq!(x, vec![B(\"leopard\"), B(\"tiger\"), B(\"\"), B(\"lion\")]);\n///\n/// let x: Vec<&[u8]> = b\"lion::tiger::leopard\".rsplit_str(\"::\").collect();\n/// assert_eq!(x, vec![B(\"leopard\"), B(\"tiger\"), B(\"lion\")]);\n/// ```\n///\n/// If a string contains multiple contiguous separators, you will end up\n/// with empty strings yielded by the iterator:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<&[u8]> = b\"||||a||b|c\".rsplit_str(\"|\").collect();\n/// assert_eq!(x, vec![\n///     B(\"c\"), B(\"b\"), B(\"\"), B(\"a\"), B(\"\"), B(\"\"), B(\"\"), B(\"\"),\n/// ]);\n///\n/// let x: Vec<&[u8]> = b\"(///)\".rsplit_str(\"/\").collect();\n/// assert_eq!(x, vec![B(\")\"), B(\"\"), B(\"\"), B(\"(\")]);\n/// ```\n///\n/// Separators at the start or end of a string are neighbored by empty\n/// strings.\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<&[u8]> = b\"010\".rsplit_str(\"0\").collect();\n/// assert_eq!(x, vec![B(\"\"), B(\"1\"), B(\"\")]);\n/// ```\n///\n/// When the empty string is used as a separator, it splits every **byte**\n/// in the byte string, along with the beginning and end of the byte\n/// string.\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<&[u8]> = b\"rust\".rsplit_str(\"\").collect();\n/// assert_eq!(x, vec![\n///     B(\"\"), B(\"t\"), B(\"s\"), B(\"u\"), B(\"r\"), B(\"\"),\n/// ]);\n///\n/// // Splitting by an empty string is not UTF-8 aware. Elements yielded\n/// // may not be valid UTF-8!\n/// let x: Vec<&[u8]> = B(\"☃\").rsplit_str(\"\").collect();\n/// assert_eq!(x, vec![B(\"\"), B(b\"\\x83\"), B(b\"\\x98\"), B(b\"\\xE2\"), B(\"\")]);\n/// ```\n///\n/// Contiguous separators, especially whitespace, can lead to possibly\n/// surprising behavior. For example, this code is correct:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<&[u8]> = b\"    a  b c\".rsplit_str(\" \").collect();\n/// assert_eq!(x, vec![\n///     B(\"c\"), B(\"b\"), B(\"\"), B(\"a\"), B(\"\"), B(\"\"), B(\"\"), B(\"\"),\n/// ]);\n/// ```\n///\n/// It does *not* give you `[\"a\", \"b\", \"c\"]`.\n#[inline]\nfn rsplit_str<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        splitter: &'a B,\n    ) -> SplitReverse<'a>{\n        SplitReverse::new(self.as_bytes(), splitter.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::rsplitn_str":["/// Returns an iterator of at most `limit` substrings of this byte string,\n/// separated by the given byte string, in reverse. If `limit` substrings\n/// are yielded, then the last substring will contain the remainder of this\n/// byte string.\n///\n/// The needle may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<_> =\n///     b\"Mary had a little lamb\".rsplitn_str(3, \" \").collect();\n/// assert_eq!(x, vec![B(\"lamb\"), B(\"little\"), B(\"Mary had a\")]);\n///\n/// let x: Vec<_> = b\"\".rsplitn_str(3, \"X\").collect();\n/// assert_eq!(x, vec![b\"\"]);\n///\n/// let x: Vec<_> = b\"lionXXtigerXleopard\".rsplitn_str(3, \"X\").collect();\n/// assert_eq!(x, vec![B(\"leopard\"), B(\"tiger\"), B(\"lionX\")]);\n///\n/// let x: Vec<_> = b\"lion::tiger::leopard\".rsplitn_str(2, \"::\").collect();\n/// assert_eq!(x, vec![B(\"leopard\"), B(\"lion::tiger\")]);\n///\n/// let x: Vec<_> = b\"abcXdef\".rsplitn_str(1, \"X\").collect();\n/// assert_eq!(x, vec![B(\"abcXdef\")]);\n///\n/// let x: Vec<_> = b\"abcdef\".rsplitn_str(2, \"X\").collect();\n/// assert_eq!(x, vec![B(\"abcdef\")]);\n///\n/// let x: Vec<_> = b\"abcXdef\".rsplitn_str(0, \"X\").collect();\n/// assert!(x.is_empty());\n/// ```\n#[inline]\nfn rsplitn_str<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        limit: usize,\n        splitter: &'a B,\n    ) -> SplitNReverse<'a>{\n        SplitNReverse::new(self.as_bytes(), splitter.as_ref(), limit)\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::sentence_indices":["/// Returns an iterator over the sentences in this byte string along with\n/// their starting and ending byte index positions.\n///\n/// Typically, a sentence will include its trailing punctuation and\n/// whitespace. Concatenating all elements yielded by the iterator\n/// results in the original string (modulo Unicode replacement codepoint\n/// substitutions if invalid UTF-8 is encountered).\n///\n/// Since sentences are made up of one or more codepoints, this iterator\n/// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n/// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = b\"I want this. Not that. Right now.\";\n/// let sentences: Vec<(usize, usize, &str)> =\n///     bs.sentence_indices().collect();\n/// assert_eq!(sentences, vec![\n///     (0, 13, \"I want this. \"),\n///     (13, 23, \"Not that. \"),\n///     (23, 33, \"Right now.\"),\n/// ]);\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn sentence_indices(&self) -> SentenceIndices{\n        SentenceIndices::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::sentences":["/// Returns an iterator over the sentences in this byte string.\n///\n/// Typically, a sentence will include its trailing punctuation and\n/// whitespace. Concatenating all elements yielded by the iterator\n/// results in the original string (modulo Unicode replacement codepoint\n/// substitutions if invalid UTF-8 is encountered).\n///\n/// Since sentences are made up of one or more codepoints, this iterator\n/// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n/// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = b\"I want this. Not that. Right now.\";\n/// let sentences: Vec<&str> = bs.sentences().collect();\n/// assert_eq!(sentences, vec![\n///     \"I want this. \",\n///     \"Not that. \",\n///     \"Right now.\",\n/// ]);\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn sentences(&self) -> Sentences{\n        Sentences::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::split_str":["/// Returns an iterator over substrings of this byte string, separated\n/// by the given byte string. Each element yielded is guaranteed not to\n/// include the splitter substring.\n///\n/// The splitter may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<&[u8]> = b\"Mary had a little lamb\".split_str(\" \").collect();\n/// assert_eq!(x, vec![\n///     B(\"Mary\"), B(\"had\"), B(\"a\"), B(\"little\"), B(\"lamb\"),\n/// ]);\n///\n/// let x: Vec<&[u8]> = b\"\".split_str(\"X\").collect();\n/// assert_eq!(x, vec![b\"\"]);\n///\n/// let x: Vec<&[u8]> = b\"lionXXtigerXleopard\".split_str(\"X\").collect();\n/// assert_eq!(x, vec![B(\"lion\"), B(\"\"), B(\"tiger\"), B(\"leopard\")]);\n///\n/// let x: Vec<&[u8]> = b\"lion::tiger::leopard\".split_str(\"::\").collect();\n/// assert_eq!(x, vec![B(\"lion\"), B(\"tiger\"), B(\"leopard\")]);\n/// ```\n///\n/// If a string contains multiple contiguous separators, you will end up\n/// with empty strings yielded by the iterator:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<&[u8]> = b\"||||a||b|c\".split_str(\"|\").collect();\n/// assert_eq!(x, vec![\n///     B(\"\"), B(\"\"), B(\"\"), B(\"\"), B(\"a\"), B(\"\"), B(\"b\"), B(\"c\"),\n/// ]);\n///\n/// let x: Vec<&[u8]> = b\"(///)\".split_str(\"/\").collect();\n/// assert_eq!(x, vec![B(\"(\"), B(\"\"), B(\"\"), B(\")\")]);\n/// ```\n///\n/// Separators at the start or end of a string are neighbored by empty\n/// strings.\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<&[u8]> = b\"010\".split_str(\"0\").collect();\n/// assert_eq!(x, vec![B(\"\"), B(\"1\"), B(\"\")]);\n/// ```\n///\n/// When the empty string is used as a separator, it splits every **byte**\n/// in the byte string, along with the beginning and end of the byte\n/// string.\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<&[u8]> = b\"rust\".split_str(\"\").collect();\n/// assert_eq!(x, vec![\n///     B(\"\"), B(\"r\"), B(\"u\"), B(\"s\"), B(\"t\"), B(\"\"),\n/// ]);\n///\n/// // Splitting by an empty string is not UTF-8 aware. Elements yielded\n/// // may not be valid UTF-8!\n/// let x: Vec<&[u8]> = B(\"☃\").split_str(\"\").collect();\n/// assert_eq!(x, vec![\n///     B(\"\"), B(b\"\\xE2\"), B(b\"\\x98\"), B(b\"\\x83\"), B(\"\"),\n/// ]);\n/// ```\n///\n/// Contiguous separators, especially whitespace, can lead to possibly\n/// surprising behavior. For example, this code is correct:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<&[u8]> = b\"    a  b c\".split_str(\" \").collect();\n/// assert_eq!(x, vec![\n///     B(\"\"), B(\"\"), B(\"\"), B(\"\"), B(\"a\"), B(\"\"), B(\"b\"), B(\"c\"),\n/// ]);\n/// ```\n///\n/// It does *not* give you `[\"a\", \"b\", \"c\"]`. For that behavior, use\n/// [`fields`](#method.fields) instead.\n#[inline]\nfn split_str<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        splitter: &'a B,\n    ) -> Split<'a>{\n        Split::new(self.as_bytes(), splitter.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::splitn_str":["/// Returns an iterator of at most `limit` substrings of this byte string,\n/// separated by the given byte string. If `limit` substrings are yielded,\n/// then the last substring will contain the remainder of this byte string.\n///\n/// The needle may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let x: Vec<_> = b\"Mary had a little lamb\".splitn_str(3, \" \").collect();\n/// assert_eq!(x, vec![B(\"Mary\"), B(\"had\"), B(\"a little lamb\")]);\n///\n/// let x: Vec<_> = b\"\".splitn_str(3, \"X\").collect();\n/// assert_eq!(x, vec![b\"\"]);\n///\n/// let x: Vec<_> = b\"lionXXtigerXleopard\".splitn_str(3, \"X\").collect();\n/// assert_eq!(x, vec![B(\"lion\"), B(\"\"), B(\"tigerXleopard\")]);\n///\n/// let x: Vec<_> = b\"lion::tiger::leopard\".splitn_str(2, \"::\").collect();\n/// assert_eq!(x, vec![B(\"lion\"), B(\"tiger::leopard\")]);\n///\n/// let x: Vec<_> = b\"abcXdef\".splitn_str(1, \"X\").collect();\n/// assert_eq!(x, vec![B(\"abcXdef\")]);\n///\n/// let x: Vec<_> = b\"abcdef\".splitn_str(2, \"X\").collect();\n/// assert_eq!(x, vec![B(\"abcdef\")]);\n///\n/// let x: Vec<_> = b\"abcXdef\".splitn_str(0, \"X\").collect();\n/// assert!(x.is_empty());\n/// ```\n#[inline]\nfn splitn_str<'a, B: ?Sized + AsRef<[u8]>>(\n        &'a self,\n        limit: usize,\n        splitter: &'a B,\n    ) -> SplitN<'a>{\n        SplitN::new(self.as_bytes(), splitter.as_ref(), limit)\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::starts_with_str":["/// Returns true if and only if this byte string has the given prefix.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// assert!(b\"foo bar\".starts_with_str(\"foo\"));\n/// assert!(!b\"foo bar\".starts_with_str(\"bar\"));\n/// assert!(!b\"foo\".starts_with_str(\"foobar\"));\n/// ```\n#[inline]\nfn starts_with_str<B: AsRef<[u8]>>(&self, prefix: B) -> bool{\n        self.as_bytes().starts_with(prefix.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_ascii_lowercase":["/// Returns a new `Vec<u8>` containing the ASCII lowercase equivalent of\n/// this byte string.\n///\n/// In this case, lowercase is only defined in ASCII letters. Namely, the\n/// letters `A-Z` are converted to `a-z`. All other bytes remain unchanged.\n/// In particular, the length of the byte string returned is always\n/// equivalent to the length of this byte string.\n///\n/// If you'd like to reuse an allocation for performance reasons, then use\n/// [`make_ascii_lowercase`](#method.make_ascii_lowercase) to perform\n/// the conversion in place.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\"HELLO Β\");\n/// assert_eq!(\"hello Β\".as_bytes(), s.to_ascii_lowercase().as_bytes());\n/// ```\n///\n/// Invalid UTF-8 remains as is:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\");\n/// assert_eq!(s.to_ascii_lowercase(), B(b\"foo\\xFFbar\\xE2\\x98baz\"));\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn to_ascii_lowercase(&self) -> Vec<u8>{\n        self.as_bytes().to_ascii_lowercase()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_ascii_uppercase":["/// Returns a new `Vec<u8>` containing the ASCII uppercase equivalent of\n/// this byte string.\n///\n/// In this case, uppercase is only defined in ASCII letters. Namely, the\n/// letters `a-z` are converted to `A-Z`. All other bytes remain unchanged.\n/// In particular, the length of the byte string returned is always\n/// equivalent to the length of this byte string.\n///\n/// If you'd like to reuse an allocation for performance reasons, then use\n/// [`make_ascii_uppercase`](#method.make_ascii_uppercase) to perform\n/// the conversion in place.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\"hello β\");\n/// assert_eq!(s.to_ascii_uppercase(), B(\"HELLO β\"));\n/// ```\n///\n/// Invalid UTF-8 remains as is:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(b\"foo\\xFFbar\\xE2\\x98baz\");\n/// assert_eq!(s.to_ascii_uppercase(), B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\"));\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn to_ascii_uppercase(&self) -> Vec<u8>{\n        self.as_bytes().to_ascii_uppercase()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_lowercase":["/// Returns a new `Vec<u8>` containing the lowercase equivalent of this\n/// byte string.\n///\n/// In this case, lowercase is defined according to the `Lowercase` Unicode\n/// property.\n///\n/// If invalid UTF-8 is seen, or if a character has no lowercase variant,\n/// then it is written to the given buffer unchanged.\n///\n/// Note that some characters in this byte string may expand into multiple\n/// characters when changing the case, so the number of bytes written to\n/// the given byte string may not be equivalent to the number of bytes in\n/// this byte string.\n///\n/// If you'd like to reuse an allocation for performance reasons, then use\n/// [`to_lowercase_into`](#method.to_lowercase_into) instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\"HELLO Β\");\n/// assert_eq!(\"hello β\".as_bytes(), s.to_lowercase().as_bytes());\n/// ```\n///\n/// Scripts without case are not changed:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\"农历新年\");\n/// assert_eq!(\"农历新年\".as_bytes(), s.to_lowercase().as_bytes());\n/// ```\n///\n/// Invalid UTF-8 remains as is:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\");\n/// assert_eq!(B(b\"foo\\xFFbar\\xE2\\x98baz\"), s.to_lowercase().as_bytes());\n/// ```\n#[cfg(all(feature = \"std\", feature = \"unicode\"))]\n#[inline]\nfn to_lowercase(&self) -> Vec<u8>{\n        let mut buf = vec![];\n        self.to_lowercase_into(&mut buf);\n        buf\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_lowercase_into":["/// Writes the lowercase equivalent of this byte string into the given\n/// buffer. The buffer is not cleared before written to.\n///\n/// In this case, lowercase is defined according to the `Lowercase`\n/// Unicode property.\n///\n/// If invalid UTF-8 is seen, or if a character has no lowercase variant,\n/// then it is written to the given buffer unchanged.\n///\n/// Note that some characters in this byte string may expand into multiple\n/// characters when changing the case, so the number of bytes written to\n/// the given byte string may not be equivalent to the number of bytes in\n/// this byte string.\n///\n/// If you don't need to amortize allocation and instead prefer\n/// convenience, then use [`to_lowercase`](#method.to_lowercase) instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\"HELLO Β\");\n///\n/// let mut buf = vec![];\n/// s.to_lowercase_into(&mut buf);\n/// assert_eq!(\"hello β\".as_bytes(), buf.as_bytes());\n/// ```\n///\n/// Scripts without case are not changed:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\"农历新年\");\n///\n/// let mut buf = vec![];\n/// s.to_lowercase_into(&mut buf);\n/// assert_eq!(\"农历新年\".as_bytes(), buf.as_bytes());\n/// ```\n///\n/// Invalid UTF-8 remains as is:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\");\n///\n/// let mut buf = vec![];\n/// s.to_lowercase_into(&mut buf);\n/// assert_eq!(B(b\"foo\\xFFbar\\xE2\\x98baz\"), buf.as_bytes());\n/// ```\n#[cfg(all(feature = \"std\", feature = \"unicode\"))]\n#[inline]\nfn to_lowercase_into(&self, buf: &mut Vec<u8>){\n        // TODO: This is the best we can do given what std exposes I think.\n        // If we roll our own case handling, then we might be able to do this\n        // a bit faster. We shouldn't roll our own case handling unless we\n        // need to, e.g., for doing caseless matching or case folding.\n\n        // TODO(BUG): This doesn't handle any special casing rules.\n\n        buf.reserve(self.as_bytes().len());\n        for (s, e, ch) in self.char_indices() {\n            if ch == '\\u{FFFD}' {\n                buf.push_str(&self.as_bytes()[s..e]);\n            } else if ch.is_ascii() {\n                buf.push_char(ch.to_ascii_lowercase());\n            } else {\n                for upper in ch.to_lowercase() {\n                    buf.push_char(upper);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_os_str":["/// Create an OS string slice from this byte string.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this returns a UTF-8 decoding error if this byte string is not valid\n/// UTF-8. (For example, on Windows, file paths are allowed to be a\n/// sequence of arbitrary 16-bit integers. There is no obvious mapping from\n/// an arbitrary sequence of 8-bit integers to an arbitrary sequence of\n/// 16-bit integers.)\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let os_str = b\"foo\".to_os_str().expect(\"should be valid UTF-8\");\n/// assert_eq!(os_str, \"foo\");\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn to_os_str(&self) -> Result<&OsStr, Utf8Error>{\n        #[cfg(unix)]\n        #[inline]\n        fn imp(bytes: &[u8]) -> Result<&OsStr, Utf8Error> {\n            use std::os::unix::ffi::OsStrExt;\n\n            Ok(OsStr::from_bytes(bytes))\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(bytes: &[u8]) -> Result<&OsStr, Utf8Error> {\n            bytes.to_str().map(OsStr::new)\n        }\n\n        imp(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_os_str::imp":["#[cfg(unix)]\n#[inline]\nfn imp(bytes: &[u8]) -> Result<&OsStr, Utf8Error>{\n            use std::os::unix::ffi::OsStrExt;\n\n            Ok(OsStr::from_bytes(bytes))\n        }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_os_str_lossy":["/// Lossily create an OS string slice from this byte string.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this will perform a UTF-8 check and lossily convert this byte string\n/// into valid UTF-8 using the Unicode replacement codepoint.\n///\n/// Note that this can prevent the correct roundtripping of file paths on\n/// non-Unix systems such as Windows, where file paths are an arbitrary\n/// sequence of 16-bit integers.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let os_str = b\"foo\\xFFbar\".to_os_str_lossy();\n/// assert_eq!(os_str.to_string_lossy(), \"foo\\u{FFFD}bar\");\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn to_os_str_lossy(&self) -> Cow<OsStr>{\n        #[cfg(unix)]\n        #[inline]\n        fn imp(bytes: &[u8]) -> Cow<OsStr> {\n            use std::os::unix::ffi::OsStrExt;\n\n            Cow::Borrowed(OsStr::from_bytes(bytes))\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(bytes: &[u8]) -> Cow<OsStr> {\n            use std::ffi::OsString;\n\n            match bytes.to_str_lossy() {\n                Cow::Borrowed(x) => Cow::Borrowed(OsStr::new(x)),\n                Cow::Owned(x) => Cow::Owned(OsString::from(x)),\n            }\n        }\n\n        imp(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_os_str_lossy::imp":["#[cfg(unix)]\n#[inline]\nfn imp(bytes: &[u8]) -> Cow<OsStr>{\n            use std::os::unix::ffi::OsStrExt;\n\n            Cow::Borrowed(OsStr::from_bytes(bytes))\n        }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_path":["/// Create a path slice from this byte string.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this returns a UTF-8 decoding error if this byte string is not valid\n/// UTF-8. (For example, on Windows, file paths are allowed to be a\n/// sequence of arbitrary 16-bit integers. There is no obvious mapping from\n/// an arbitrary sequence of 8-bit integers to an arbitrary sequence of\n/// 16-bit integers.)\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let path = b\"foo\".to_path().expect(\"should be valid UTF-8\");\n/// assert_eq!(path.as_os_str(), \"foo\");\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn to_path(&self) -> Result<&Path, Utf8Error>{\n        self.to_os_str().map(Path::new)\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_path_lossy":["/// Lossily create a path slice from this byte string.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this will perform a UTF-8 check and lossily convert this byte string\n/// into valid UTF-8 using the Unicode replacement codepoint.\n///\n/// Note that this can prevent the correct roundtripping of file paths on\n/// non-Unix systems such as Windows, where file paths are an arbitrary\n/// sequence of 16-bit integers.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = b\"foo\\xFFbar\";\n/// let path = bs.to_path_lossy();\n/// assert_eq!(path.to_string_lossy(), \"foo\\u{FFFD}bar\");\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn to_path_lossy(&self) -> Cow<Path>{\n        use std::path::PathBuf;\n\n        match self.to_os_str_lossy() {\n            Cow::Borrowed(x) => Cow::Borrowed(Path::new(x)),\n            Cow::Owned(x) => Cow::Owned(PathBuf::from(x)),\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_str":["/// Safely convert this byte string into a `&str` if it's valid UTF-8.\n///\n/// If this byte string is not valid UTF-8, then an error is returned. The\n/// error returned indicates the first invalid byte found and the length\n/// of the error.\n///\n/// In cases where a lossy conversion to `&str` is acceptable, then use one\n/// of the [`to_str_lossy`](trait.ByteSlice.html#method.to_str_lossy) or\n/// [`to_str_lossy_into`](trait.ByteSlice.html#method.to_str_lossy_into)\n/// methods.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice, ByteVec};\n///\n/// # fn example() -> Result<(), bstr::Utf8Error> {\n/// let s = B(\"☃βツ\").to_str()?;\n/// assert_eq!(\"☃βツ\", s);\n///\n/// let mut bstring = <Vec<u8>>::from(\"☃βツ\");\n/// bstring.push(b'\\xFF');\n/// let err = bstring.to_str().unwrap_err();\n/// assert_eq!(8, err.valid_up_to());\n/// # Ok(()) }; example().unwrap()\n/// ```\n#[inline]\nfn to_str(&self) -> Result<&str, Utf8Error>{\n        utf8::validate(self.as_bytes()).map(|_| {\n            // SAFETY: This is safe because of the guarantees provided by\n            // utf8::validate.\n            unsafe { str::from_utf8_unchecked(self.as_bytes()) }\n        })\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_str_lossy":["/// Convert this byte string to a valid UTF-8 string by replacing invalid\n/// UTF-8 bytes with the Unicode replacement codepoint (`U+FFFD`).\n///\n/// If the byte string is already valid UTF-8, then no copying or\n/// allocation is performed and a borrrowed string slice is returned. If\n/// the byte string is not valid UTF-8, then an owned string buffer is\n/// returned with invalid bytes replaced by the replacement codepoint.\n///\n/// This method uses the \"substitution of maximal subparts\" (Unicode\n/// Standard, Chapter 3, Section 9) strategy for inserting the replacement\n/// codepoint. Specifically, a replacement codepoint is inserted whenever a\n/// byte is found that cannot possibly lead to a valid code unit sequence.\n/// If there were previous bytes that represented a prefix of a well-formed\n/// code unit sequence, then all of those bytes are substituted with a\n/// single replacement codepoint. The \"substitution of maximal subparts\"\n/// strategy is the same strategy used by\n/// [W3C's Encoding standard](https://www.w3.org/TR/encoding/).\n/// For a more precise description of the maximal subpart strategy, see\n/// the Unicode Standard, Chapter 3, Section 9. See also\n/// [Public Review Issue #121](http://www.unicode.org/review/pr-121.html).\n///\n/// N.B. Rust's standard library also appears to use the same strategy,\n/// but it does not appear to be an API guarantee.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::borrow::Cow;\n///\n/// use bstr::ByteSlice;\n///\n/// let mut bstring = <Vec<u8>>::from(\"☃βツ\");\n/// assert_eq!(Cow::Borrowed(\"☃βツ\"), bstring.to_str_lossy());\n///\n/// // Add a byte that makes the sequence invalid.\n/// bstring.push(b'\\xFF');\n/// assert_eq!(Cow::Borrowed(\"☃βツ\\u{FFFD}\"), bstring.to_str_lossy());\n/// ```\n///\n/// This demonstrates the \"maximal subpart\" substitution logic.\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// // \\x61 is the ASCII codepoint for 'a'.\n/// // \\xF1\\x80\\x80 is a valid 3-byte code unit prefix.\n/// // \\xE1\\x80 is a valid 2-byte code unit prefix.\n/// // \\xC2 is a valid 1-byte code unit prefix.\n/// // \\x62 is the ASCII codepoint for 'b'.\n/// //\n/// // In sum, each of the prefixes is replaced by a single replacement\n/// // codepoint since none of the prefixes are properly completed. This\n/// // is in contrast to other strategies that might insert a replacement\n/// // codepoint for every single byte.\n/// let bs = B(b\"\\x61\\xF1\\x80\\x80\\xE1\\x80\\xC2\\x62\");\n/// assert_eq!(\"a\\u{FFFD}\\u{FFFD}\\u{FFFD}b\", bs.to_str_lossy());\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn to_str_lossy(&self) -> Cow<str>{\n        match utf8::validate(self.as_bytes()) {\n            Ok(()) => {\n                // SAFETY: This is safe because of the guarantees provided by\n                // utf8::validate.\n                unsafe {\n                    Cow::Borrowed(str::from_utf8_unchecked(self.as_bytes()))\n                }\n            }\n            Err(err) => {\n                let mut lossy = String::with_capacity(self.as_bytes().len());\n                let (valid, after) =\n                    self.as_bytes().split_at(err.valid_up_to());\n                // SAFETY: This is safe because utf8::validate guarantees\n                // that all of `valid` is valid UTF-8.\n                lossy.push_str(unsafe { str::from_utf8_unchecked(valid) });\n                lossy.push_str(\"\\u{FFFD}\");\n                if let Some(len) = err.error_len() {\n                    after[len..].to_str_lossy_into(&mut lossy);\n                }\n                Cow::Owned(lossy)\n            }\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_str_lossy_into":["/// Copy the contents of this byte string into the given owned string\n/// buffer, while replacing invalid UTF-8 code unit sequences with the\n/// Unicode replacement codepoint (`U+FFFD`).\n///\n/// This method uses the same \"substitution of maximal subparts\" strategy\n/// for inserting the replacement codepoint as the\n/// [`to_str_lossy`](trait.ByteSlice.html#method.to_str_lossy) method.\n///\n/// This routine is useful for amortizing allocation. However, unlike\n/// `to_str_lossy`, this routine will _always_ copy the contents of this\n/// byte string into the destination buffer, even if this byte string is\n/// valid UTF-8.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::borrow::Cow;\n///\n/// use bstr::ByteSlice;\n///\n/// let mut bstring = <Vec<u8>>::from(\"☃βツ\");\n/// // Add a byte that makes the sequence invalid.\n/// bstring.push(b'\\xFF');\n///\n/// let mut dest = String::new();\n/// bstring.to_str_lossy_into(&mut dest);\n/// assert_eq!(\"☃βツ\\u{FFFD}\", dest);\n/// ```\n#[cfg(feature = \"std\")]\n#[inline]\nfn to_str_lossy_into(&self, dest: &mut String){\n        let mut bytes = self.as_bytes();\n        dest.reserve(bytes.len());\n        loop {\n            match utf8::validate(bytes) {\n                Ok(()) => {\n                    // SAFETY: This is safe because utf8::validate guarantees\n                    // that all of `bytes` is valid UTF-8.\n                    dest.push_str(unsafe { str::from_utf8_unchecked(bytes) });\n                    break;\n                }\n                Err(err) => {\n                    let (valid, after) = bytes.split_at(err.valid_up_to());\n                    // SAFETY: This is safe because utf8::validate guarantees\n                    // that all of `valid` is valid UTF-8.\n                    dest.push_str(unsafe { str::from_utf8_unchecked(valid) });\n                    dest.push_str(\"\\u{FFFD}\");\n                    match err.error_len() {\n                        None => break,\n                        Some(len) => bytes = &after[len..],\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_str_unchecked":["/// Unsafely convert this byte string into a `&str`, without checking for\n/// valid UTF-8.\n///\n/// # Safety\n///\n/// Callers *must* ensure that this byte string is valid UTF-8 before\n/// calling this method. Converting a byte string into a `&str` that is\n/// not valid UTF-8 is considered undefined behavior.\n///\n/// This routine is useful in performance sensitive contexts where the\n/// UTF-8 validity of the byte string is already known and it is\n/// undesirable to pay the cost of an additional UTF-8 validation check\n/// that [`to_str`](trait.ByteSlice.html#method.to_str) performs.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// // SAFETY: This is safe because string literals are guaranteed to be\n/// // valid UTF-8 by the Rust compiler.\n/// let s = unsafe { B(\"☃βツ\").to_str_unchecked() };\n/// assert_eq!(\"☃βツ\", s);\n/// ```\n#[inline]\nunsafe fn to_str_unchecked(&self) -> &str{\n        str::from_utf8_unchecked(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_uppercase":["/// Returns a new `Vec<u8>` containing the uppercase equivalent of this\n/// byte string.\n///\n/// In this case, uppercase is defined according to the `Uppercase`\n/// Unicode property.\n///\n/// If invalid UTF-8 is seen, or if a character has no uppercase variant,\n/// then it is written to the given buffer unchanged.\n///\n/// Note that some characters in this byte string may expand into multiple\n/// characters when changing the case, so the number of bytes written to\n/// the given byte string may not be equivalent to the number of bytes in\n/// this byte string.\n///\n/// If you'd like to reuse an allocation for performance reasons, then use\n/// [`to_uppercase_into`](#method.to_uppercase_into) instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\"hello β\");\n/// assert_eq!(s.to_uppercase(), B(\"HELLO Β\"));\n/// ```\n///\n/// Scripts without case are not changed:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\"农历新年\");\n/// assert_eq!(s.to_uppercase(), B(\"农历新年\"));\n/// ```\n///\n/// Invalid UTF-8 remains as is:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(b\"foo\\xFFbar\\xE2\\x98baz\");\n/// assert_eq!(s.to_uppercase(), B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\"));\n/// ```\n#[cfg(all(feature = \"std\", feature = \"unicode\"))]\n#[inline]\nfn to_uppercase(&self) -> Vec<u8>{\n        let mut buf = vec![];\n        self.to_uppercase_into(&mut buf);\n        buf\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::to_uppercase_into":["/// Writes the uppercase equivalent of this byte string into the given\n/// buffer. The buffer is not cleared before written to.\n///\n/// In this case, uppercase is defined according to the `Uppercase`\n/// Unicode property.\n///\n/// If invalid UTF-8 is seen, or if a character has no uppercase variant,\n/// then it is written to the given buffer unchanged.\n///\n/// Note that some characters in this byte string may expand into multiple\n/// characters when changing the case, so the number of bytes written to\n/// the given byte string may not be equivalent to the number of bytes in\n/// this byte string.\n///\n/// If you don't need to amortize allocation and instead prefer\n/// convenience, then use [`to_uppercase`](#method.to_uppercase) instead.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\"hello β\");\n///\n/// let mut buf = vec![];\n/// s.to_uppercase_into(&mut buf);\n/// assert_eq!(buf, B(\"HELLO Β\"));\n/// ```\n///\n/// Scripts without case are not changed:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\"农历新年\");\n///\n/// let mut buf = vec![];\n/// s.to_uppercase_into(&mut buf);\n/// assert_eq!(buf, B(\"农历新年\"));\n/// ```\n///\n/// Invalid UTF-8 remains as is:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(b\"foo\\xFFbar\\xE2\\x98baz\");\n///\n/// let mut buf = vec![];\n/// s.to_uppercase_into(&mut buf);\n/// assert_eq!(buf, B(b\"FOO\\xFFBAR\\xE2\\x98BAZ\"));\n/// ```\n#[cfg(all(feature = \"std\", feature = \"unicode\"))]\n#[inline]\nfn to_uppercase_into(&self, buf: &mut Vec<u8>){\n        // TODO: This is the best we can do given what std exposes I think.\n        // If we roll our own case handling, then we might be able to do this\n        // a bit faster. We shouldn't roll our own case handling unless we\n        // need to, e.g., for doing caseless matching or case folding.\n        buf.reserve(self.as_bytes().len());\n        for (s, e, ch) in self.char_indices() {\n            if ch == '\\u{FFFD}' {\n                buf.push_str(&self.as_bytes()[s..e]);\n            } else if ch.is_ascii() {\n                buf.push_char(ch.to_ascii_uppercase());\n            } else {\n                for upper in ch.to_uppercase() {\n                    buf.push_char(upper);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::trim":["/// Return a byte string slice with leading and trailing whitespace\n/// removed.\n///\n/// Whitespace is defined according to the terms of the `White_Space`\n/// Unicode property.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\" foo\\tbar\\t\\u{2003}\\n\");\n/// assert_eq!(s.trim(), B(\"foo\\tbar\"));\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn trim(&self) -> &[u8]{\n        self.trim_start().trim_end()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::trim_end":["/// Return a byte string slice with trailing whitespace removed.\n///\n/// Whitespace is defined according to the terms of the `White_Space`\n/// Unicode property.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\" foo\\tbar\\t\\u{2003}\\n\");\n/// assert_eq!(s.trim_end(), B(\" foo\\tbar\"));\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn trim_end(&self) -> &[u8]{\n        let end = whitespace_len_rev(self.as_bytes());\n        &self.as_bytes()[..end]\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::trim_end_with":["/// Return a byte string slice with trailing characters satisfying the\n/// given predicate removed.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = b\"123foo5bar789\";\n/// assert_eq!(s.trim_end_with(|c| c.is_numeric()), B(\"123foo5bar\"));\n/// ```\n#[inline]\nfn trim_end_with<F: FnMut(char) -> bool>(&self, mut trim: F) -> &[u8]{\n        for (_, e, ch) in self.char_indices().rev() {\n            if !trim(ch) {\n                return &self.as_bytes()[..e];\n            }\n        }\n        b\"\"\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::trim_start":["/// Return a byte string slice with leading whitespace removed.\n///\n/// Whitespace is defined according to the terms of the `White_Space`\n/// Unicode property.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(\" foo\\tbar\\t\\u{2003}\\n\");\n/// assert_eq!(s.trim_start(), B(\"foo\\tbar\\t\\u{2003}\\n\"));\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn trim_start(&self) -> &[u8]{\n        let start = whitespace_len_fwd(self.as_bytes());\n        &self.as_bytes()[start..]\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::trim_start_with":["/// Return a byte string slice with leading characters satisfying the given\n/// predicate removed.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = b\"123foo5bar789\";\n/// assert_eq!(s.trim_start_with(|c| c.is_numeric()), B(\"foo5bar789\"));\n/// ```\n#[inline]\nfn trim_start_with<F: FnMut(char) -> bool>(&self, mut trim: F) -> &[u8]{\n        for (s, _, ch) in self.char_indices() {\n            if !trim(ch) {\n                return &self.as_bytes()[s..];\n            }\n        }\n        b\"\"\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::trim_with":["/// Return a byte string slice with leading and trailing characters\n/// satisfying the given predicate removed.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = b\"123foo5bar789\";\n/// assert_eq!(s.trim_with(|c| c.is_numeric()), B(\"foo5bar\"));\n/// ```\n#[inline]\nfn trim_with<F: FnMut(char) -> bool>(&self, mut trim: F) -> &[u8]{\n        self.trim_start_with(&mut trim).trim_end_with(&mut trim)\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::utf8_chunks":["/// Iterate over chunks of valid UTF-8.\n///\n/// The iterator returned yields chunks of valid UTF-8 separated by invalid\n/// UTF-8 bytes, if they exist. Invalid UTF-8 bytes are always 1-3 bytes,\n/// which are determined via the \"substitution of maximal subparts\"\n/// strategy described in the docs for the\n/// [`ByteSlice::to_str_lossy`](trait.ByteSlice.html#method.to_str_lossy)\n/// method.\n///\n/// # Examples\n///\n/// This example shows how to gather all valid and invalid chunks from a\n/// byte slice:\n///\n/// ```\n/// use bstr::{ByteSlice, Utf8Chunk};\n///\n/// let bytes = b\"foo\\xFD\\xFEbar\\xFF\";\n///\n/// let (mut valid_chunks, mut invalid_chunks) = (vec![], vec![]);\n/// for chunk in bytes.utf8_chunks() {\n///     if !chunk.valid().is_empty() {\n///         valid_chunks.push(chunk.valid());\n///     }\n///     if !chunk.invalid().is_empty() {\n///         invalid_chunks.push(chunk.invalid());\n///     }\n/// }\n///\n/// assert_eq!(valid_chunks, vec![\"foo\", \"bar\"]);\n/// assert_eq!(invalid_chunks, vec![b\"\\xFD\", b\"\\xFE\", b\"\\xFF\"]);\n/// ```\n#[inline]\nfn utf8_chunks(&self) -> Utf8Chunks{\n        Utf8Chunks { bytes: self.as_bytes() }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::word_indices":["/// Returns an iterator over the words in this byte string along with\n/// their starting and ending byte index positions.\n///\n/// This is similar to\n/// [`words_with_break_indices`](trait.ByteSlice.html#method.words_with_break_indices),\n/// except it only returns elements that contain a \"word\" character. A word\n/// character is defined by UTS #18 (Annex C) to be the combination of the\n/// `Alphabetic` and `Join_Control` properties, along with the\n/// `Decimal_Number`, `Mark` and `Connector_Punctuation` general\n/// categories.\n///\n/// Since words are made up of one or more codepoints, this iterator\n/// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n/// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n///\n/// # Examples\n///\n/// This example shows how to get the byte offsets of each individual\n/// word:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = b\"can't jump 32.3 feet\";\n/// let words: Vec<(usize, usize, &str)> = bs.word_indices().collect();\n/// assert_eq!(words, vec![\n///     (0, 5, \"can't\"),\n///     (6, 10, \"jump\"),\n///     (11, 15, \"32.3\"),\n///     (16, 20, \"feet\"),\n/// ]);\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn word_indices(&self) -> WordIndices{\n        WordIndices::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::words":["/// Returns an iterator over the words in this byte string. If invalid\n/// UTF-8 is encountered, then the Unicode replacement codepoint is yielded\n/// instead.\n///\n/// This is similar to\n/// [`words_with_breaks`](trait.ByteSlice.html#method.words_with_breaks),\n/// except it only returns elements that contain a \"word\" character. A word\n/// character is defined by UTS #18 (Annex C) to be the combination of the\n/// `Alphabetic` and `Join_Control` properties, along with the\n/// `Decimal_Number`, `Mark` and `Connector_Punctuation` general\n/// categories.\n///\n/// Since words are made up of one or more codepoints, this iterator\n/// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n/// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = br#\"The quick (\"brown\") fox can't jump 32.3 feet, right?\"#;\n/// let words: Vec<&str> = bs.words().collect();\n/// assert_eq!(words, vec![\n///     \"The\", \"quick\", \"brown\", \"fox\", \"can't\",\n///     \"jump\", \"32.3\", \"feet\", \"right\",\n/// ]);\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn words(&self) -> Words{\n        Words::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::words_with_break_indices":["/// Returns an iterator over the words and their byte offsets in this\n/// byte string, along with all breaks between the words. Concatenating\n/// all elements yielded by the iterator results in the original string\n/// (modulo Unicode replacement codepoint substitutions if invalid UTF-8 is\n/// encountered).\n///\n/// Since words are made up of one or more codepoints, this iterator\n/// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n/// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n///\n/// # Examples\n///\n/// This example shows how to get the byte offsets of each individual\n/// word:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = b\"can't jump 32.3 feet\";\n/// let words: Vec<(usize, usize, &str)> =\n///     bs.words_with_break_indices().collect();\n/// assert_eq!(words, vec![\n///     (0, 5, \"can't\"),\n///     (5, 6, \" \"),\n///     (6, 10, \"jump\"),\n///     (10, 11, \" \"),\n///     (11, 15, \"32.3\"),\n///     (15, 16, \" \"),\n///     (16, 20, \"feet\"),\n/// ]);\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn words_with_break_indices(&self) -> WordsWithBreakIndices{\n        WordsWithBreakIndices::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::ByteSlice::words_with_breaks":["/// Returns an iterator over the words in this byte string, along with\n/// all breaks between the words. Concatenating all elements yielded by\n/// the iterator results in the original string (modulo Unicode replacement\n/// codepoint substitutions if invalid UTF-8 is encountered).\n///\n/// Since words are made up of one or more codepoints, this iterator\n/// yields `&str` elements. When invalid UTF-8 is encountered, replacement\n/// codepoints are [substituted](index.html#handling-of-invalid-utf-8).\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let bs = br#\"The quick (\"brown\") fox can't jump 32.3 feet, right?\"#;\n/// let words: Vec<&str> = bs.words_with_breaks().collect();\n/// assert_eq!(words, vec![\n///     \"The\", \" \", \"quick\", \" \", \"(\", \"\\\"\", \"brown\", \"\\\"\", \")\",\n///     \" \", \"fox\", \" \", \"can't\", \" \", \"jump\", \" \", \"32.3\", \" \", \"feet\",\n///     \",\", \" \", \"right\", \"?\",\n/// ]);\n/// ```\n#[cfg(feature = \"unicode\")]\n#[inline]\nfn words_with_breaks(&self) -> WordsWithBreaks{\n        WordsWithBreaks::new(self.as_bytes())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Bytes":["/// An iterator over the bytes in a byte string.\n///\n/// `'a` is the lifetime of the byte string being traversed.\npub struct Bytes<'a> {\n    it: slice::Iter<'a, u8>,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Bytes::<'a>::as_slice":["/// Views the remaining underlying data as a subslice of the original data.\n/// This has the same lifetime as the original slice,\n/// and so the iterator can continue to be used while this exists.\n#[inline]\npub fn as_slice(&self) -> &'a [u8]{\n        self.it.as_slice()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Fields":["/// An iterator over the fields in a byte string, separated by whitespace.\n///\n/// This iterator splits on contiguous runs of whitespace, such that the fields\n/// in `foo\\t\\t\\n  \\nbar` are `foo` and `bar`.\n///\n/// `'a` is the lifetime of the byte string being split.\npub struct Fields<'a> {\n    it: FieldsWith<'a, fn(char) -> bool>,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Fields::<'a>::new":["fn new(bytes: &'a [u8]) -> Fields<'a>{\n        Fields { it: bytes.fields_with(|ch| ch.is_whitespace()) }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::FieldsWith":["/// An iterator over fields in the byte string, separated by a predicate over\n/// codepoints.\n///\n/// This iterator splits a byte string based on its predicate function such\n/// that the elements returned are separated by contiguous runs of codepoints\n/// for which the predicate returns true.\n///\n/// `'a` is the lifetime of the byte string being split, while `F` is the type\n/// of the predicate, i.e., `FnMut(char) -> bool`.\npub struct FieldsWith<'a, F> {\n    f: F,\n    bytes: &'a [u8],\n    chars: CharIndices<'a>,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::FieldsWith::<'a, F>::new":["fn new(bytes: &'a [u8], f: F) -> FieldsWith<'a, F>{\n        FieldsWith { f, bytes, chars: bytes.char_indices() }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Find":["/// An iterator over non-overlapping substring matches.\n///\n/// Matches are reported by the byte offset at which they begin.\n///\n/// `'a` is the shorter of two lifetimes: the byte string being searched or the\n/// byte string being looked for.\npub struct Find<'a> {\n    haystack: &'a [u8],\n    prestate: PrefilterState,\n    searcher: TwoWay<'a>,\n    pos: usize,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Find::<'a>::new":["fn new(haystack: &'a [u8], needle: &'a [u8]) -> Find<'a>{\n        let searcher = TwoWay::forward(needle);\n        let prestate = searcher.prefilter_state();\n        Find { haystack, prestate, searcher, pos: 0 }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::FindReverse":["/// An iterator over non-overlapping substring matches in reverse.\n///\n/// Matches are reported by the byte offset at which they begin.\n///\n/// `'a` is the shorter of two lifetimes: the byte string being searched or the\n/// byte string being looked for.\npub struct FindReverse<'a> {\n    haystack: &'a [u8],\n    prestate: PrefilterState,\n    searcher: TwoWay<'a>,\n    /// When searching with an empty needle, this gets set to `None` after\n    /// we've yielded the last element at `0`.\n    pos: Option<usize>,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::FindReverse::<'a>::haystack":["fn haystack(&self) -> &'a [u8]{\n        self.haystack\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::FindReverse::<'a>::needle":["fn needle(&self) -> &[u8]{\n        self.searcher.needle()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::FindReverse::<'a>::new":["fn new(haystack: &'a [u8], needle: &'a [u8]) -> FindReverse<'a>{\n        let searcher = TwoWay::reverse(needle);\n        let prestate = searcher.prefilter_state();\n        let pos = Some(haystack.len());\n        FindReverse { haystack, prestate, searcher, pos }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Finder":["/// A single substring searcher fixed to a particular needle.\n///\n/// The purpose of this type is to permit callers to construct a substring\n/// searcher that can be used to search haystacks without the overhead of\n/// constructing the searcher in the first place. This is a somewhat niche\n/// concern when it's necessary to re-use the same needle to search multiple\n/// different haystacks with as little overhead as possible. In general, using\n/// [`ByteSlice::find`](trait.ByteSlice.html#method.find)\n/// or\n/// [`ByteSlice::find_iter`](trait.ByteSlice.html#method.find_iter)\n/// is good enough, but `Finder` is useful when you can meaningfully observe\n/// searcher construction time in a profile.\n///\n/// When the `std` feature is enabled, then this type has an `into_owned`\n/// version which permits building a `Finder` that is not connected to the\n/// lifetime of its needle.\npub struct Finder<'a> {\n    searcher: TwoWay<'a>,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Finder::<'a>::find":["/// Returns the index of the first occurrence of this needle in the given\n/// haystack.\n///\n/// The haystack may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n///\n/// # Complexity\n///\n/// This routine is guaranteed to have worst case linear time complexity\n/// with respect to both the needle and the haystack. That is, this runs\n/// in `O(needle.len() + haystack.len())` time.\n///\n/// This routine is also guaranteed to have worst case constant space\n/// complexity.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::Finder;\n///\n/// let haystack = \"foo bar baz\";\n/// assert_eq!(Some(0), Finder::new(\"foo\").find(haystack));\n/// assert_eq!(Some(4), Finder::new(\"bar\").find(haystack));\n/// assert_eq!(None, Finder::new(\"quux\").find(haystack));\n/// ```\n#[inline]\npub fn find<B: AsRef<[u8]>>(&self, haystack: B) -> Option<usize>{\n        self.searcher.find(haystack.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Finder::<'a>::into_owned":["/// Convert this finder into its owned variant, such that it no longer\n/// borrows the needle.\n///\n/// If this is already an owned finder, then this is a no-op. Otherwise,\n/// this copies the needle.\n///\n/// This is only available when the `std` feature is enabled.\n#[cfg(feature = \"std\")]\n#[inline]\npub fn into_owned(self) -> Finder<'static>{\n        Finder { searcher: self.searcher.into_owned() }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Finder::<'a>::needle":["/// Returns the needle that this finder searches for.\n///\n/// Note that the lifetime of the needle returned is tied to the lifetime\n/// of the finder, and may be shorter than the `'a` lifetime. Namely, a\n/// finder's needle can be either borrowed or owned, so the lifetime of the\n/// needle returned must necessarily be the shorter of the two.\n#[inline]\npub fn needle(&self) -> &[u8]{\n        self.searcher.needle()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Finder::<'a>::new":["/// Create a new finder for the given needle.\n#[inline]\npub fn new<B: ?Sized + AsRef<[u8]>>(needle: &'a B) -> Finder<'a>{\n        Finder { searcher: TwoWay::forward(needle.as_ref()) }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::FinderReverse":["/// A single substring reverse searcher fixed to a particular needle.\n///\n/// The purpose of this type is to permit callers to construct a substring\n/// searcher that can be used to search haystacks without the overhead of\n/// constructing the searcher in the first place. This is a somewhat niche\n/// concern when it's necessary to re-use the same needle to search multiple\n/// different haystacks with as little overhead as possible. In general, using\n/// [`ByteSlice::rfind`](trait.ByteSlice.html#method.rfind)\n/// or\n/// [`ByteSlice::rfind_iter`](trait.ByteSlice.html#method.rfind_iter)\n/// is good enough, but `FinderReverse` is useful when you can meaningfully\n/// observe searcher construction time in a profile.\n///\n/// When the `std` feature is enabled, then this type has an `into_owned`\n/// version which permits building a `FinderReverse` that is not connected to\n/// the lifetime of its needle.\npub struct FinderReverse<'a> {\n    searcher: TwoWay<'a>,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::FinderReverse::<'a>::into_owned":["/// Convert this finder into its owned variant, such that it no longer\n/// borrows the needle.\n///\n/// If this is already an owned finder, then this is a no-op. Otherwise,\n/// this copies the needle.\n///\n/// This is only available when the `std` feature is enabled.\n#[cfg(feature = \"std\")]\n#[inline]\npub fn into_owned(self) -> FinderReverse<'static>{\n        FinderReverse { searcher: self.searcher.into_owned() }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::FinderReverse::<'a>::needle":["/// Returns the needle that this finder searches for.\n///\n/// Note that the lifetime of the needle returned is tied to the lifetime\n/// of this finder, and may be shorter than the `'a` lifetime. Namely,\n/// a finder's needle can be either borrowed or owned, so the lifetime of\n/// the needle returned must necessarily be the shorter of the two.\n#[inline]\npub fn needle(&self) -> &[u8]{\n        self.searcher.needle()\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::FinderReverse::<'a>::new":["/// Create a new reverse finder for the given needle.\n#[inline]\npub fn new<B: ?Sized + AsRef<[u8]>>(needle: &'a B) -> FinderReverse<'a>{\n        FinderReverse { searcher: TwoWay::reverse(needle.as_ref()) }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::FinderReverse::<'a>::rfind":["/// Returns the index of the last occurrence of this needle in the given\n/// haystack.\n///\n/// The haystack may be any type that can be cheaply converted into a\n/// `&[u8]`. This includes, but is not limited to, `&str` and `&[u8]`.\n///\n/// # Complexity\n///\n/// This routine is guaranteed to have worst case linear time complexity\n/// with respect to both the needle and the haystack. That is, this runs\n/// in `O(needle.len() + haystack.len())` time.\n///\n/// This routine is also guaranteed to have worst case constant space\n/// complexity.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::FinderReverse;\n///\n/// let haystack = \"foo bar baz\";\n/// assert_eq!(Some(0), FinderReverse::new(\"foo\").rfind(haystack));\n/// assert_eq!(Some(4), FinderReverse::new(\"bar\").rfind(haystack));\n/// assert_eq!(None, FinderReverse::new(\"quux\").rfind(haystack));\n/// ```\n#[inline]\npub fn rfind<B: AsRef<[u8]>>(&self, haystack: B) -> Option<usize>{\n        self.searcher.rfind(haystack.as_ref())\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Lines":["/// An iterator over all lines in a byte string, without their terminators.\n///\n/// For this iterator, the only line terminators recognized are `\\r\\n` and\n/// `\\n`.\n///\n/// `'a` is the lifetime of the byte string being iterated over.\npub struct Lines<'a> {\n    it: LinesWithTerminator<'a>,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Lines::<'a>::new":["fn new(bytes: &'a [u8]) -> Lines<'a>{\n        Lines { it: LinesWithTerminator::new(bytes) }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::LinesWithTerminator":["/// An iterator over all lines in a byte string, including their terminators.\n///\n/// For this iterator, the only line terminator recognized is `\\n`. (Since\n/// line terminators are included, this also handles `\\r\\n` line endings.)\n///\n/// Line terminators are only included if they are present in the original\n/// byte string. For example, the last line in a byte string may not end with\n/// a line terminator.\n///\n/// Concatenating all elements yielded by this iterator is guaranteed to yield\n/// the original byte string.\n///\n/// `'a` is the lifetime of the byte string being iterated over.\npub struct LinesWithTerminator<'a> {\n    bytes: &'a [u8],\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::LinesWithTerminator::<'a>::new":["fn new(bytes: &'a [u8]) -> LinesWithTerminator<'a>{\n        LinesWithTerminator { bytes }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Sealed":["/// Ensure that callers cannot implement `ByteSlice` by making an\n/// umplementable trait its super trait.\npub trait Sealed {}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Split":["/// An iterator over substrings in a byte string, split by a separator.\n///\n/// `'a` is the lifetime of the byte string being split.\npub struct Split<'a> {\n    finder: Find<'a>,\n    /// The end position of the previous match of our splitter. The element\n    /// we yield corresponds to the substring starting at `last` up to the\n    /// beginning of the next match of the splitter.\n    last: usize,\n    /// Only set when iteration is complete. A corner case here is when a\n    /// splitter is matched at the end of the haystack. At that point, we still\n    /// need to yield an empty string following it.\n    done: bool,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::Split::<'a>::new":["fn new(haystack: &'a [u8], splitter: &'a [u8]) -> Split<'a>{\n        let finder = haystack.find_iter(splitter);\n        Split { finder, last: 0, done: false }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::SplitN":["/// An iterator over at most `n` substrings in a byte string, split by a\n/// separator.\n///\n/// `'a` is the lifetime of the byte string being split, while `F` is the type\n/// of the predicate, i.e., `FnMut(char) -> bool`.\npub struct SplitN<'a> {\n    split: Split<'a>,\n    limit: usize,\n    count: usize,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::SplitN::<'a>::new":["fn new(\n        haystack: &'a [u8],\n        splitter: &'a [u8],\n        limit: usize,\n    ) -> SplitN<'a>{\n        let split = haystack.split_str(splitter);\n        SplitN { split, limit, count: 0 }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::SplitNReverse":["/// An iterator over at most `n` substrings in a byte string, split by a\n/// separator, in reverse.\n///\n/// `'a` is the lifetime of the byte string being split, while `F` is the type\n/// of the predicate, i.e., `FnMut(char) -> bool`.\npub struct SplitNReverse<'a> {\n    split: SplitReverse<'a>,\n    limit: usize,\n    count: usize,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::SplitNReverse::<'a>::new":["fn new(\n        haystack: &'a [u8],\n        splitter: &'a [u8],\n        limit: usize,\n    ) -> SplitNReverse<'a>{\n        let split = haystack.rsplit_str(splitter);\n        SplitNReverse { split, limit, count: 0 }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::SplitReverse":["/// An iterator over substrings in a byte string, split by a separator, in\n/// reverse.\n///\n/// `'a` is the lifetime of the byte string being split, while `F` is the type\n/// of the predicate, i.e., `FnMut(char) -> bool`.\npub struct SplitReverse<'a> {\n    finder: FindReverse<'a>,\n    /// The end position of the previous match of our splitter. The element\n    /// we yield corresponds to the substring starting at `last` up to the\n    /// beginning of the next match of the splitter.\n    last: usize,\n    /// Only set when iteration is complete. A corner case here is when a\n    /// splitter is matched at the end of the haystack. At that point, we still\n    /// need to yield an empty string following it.\n    done: bool,\n}","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_slice::SplitReverse::<'a>::new":["fn new(haystack: &'a [u8], splitter: &'a [u8]) -> SplitReverse<'a>{\n        let finder = haystack.rfind_iter(splitter);\n        SplitReverse { finder, last: haystack.len(), done: false }\n    }","Real(LocalPath(\"src/ext_slice.rs\"))"],"ext_vec::ByteVec":["/// A trait that extends `Vec<u8>` with string oriented methods.\n///\n/// Note that when using the constructor methods, such as\n/// `ByteVec::from_slice`, one should actually call them using the concrete\n/// type. For example:\n///\n/// ```\n/// use bstr::{B, ByteVec};\n///\n/// let s = Vec::from_slice(b\"abc\"); // NOT ByteVec::from_slice(\"...\")\n/// assert_eq!(s, B(\"abc\"));\n/// ```\npub trait ByteVec: Sealed {\n    /// A method for accessing the raw vector bytes of this type. This is\n    /// always a no-op and callers shouldn't care about it. This only exists\n    /// for making the extension trait work.\n    #[doc(hidden)]\n    fn as_vec(&self) -> &Vec<u8>;\n\n    /// A method for accessing the raw vector bytes of this type, mutably. This\n    /// is always a no-op and callers shouldn't care about it. This only exists\n    /// for making the extension trait work.\n    #[doc(hidden)]\n    fn as_vec_mut(&mut self) -> &mut Vec<u8>;\n\n    /// A method for consuming ownership of this vector. This is always a no-op\n    /// and callers shouldn't care about it. This only exists for making the\n    /// extension trait work.\n    #[doc(hidden)]\n    fn into_vec(self) -> Vec<u8>\n    where\n        Self: Sized;\n\n    /// Create a new owned byte string from the given byte slice.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::{B, ByteVec};\n    ///\n    /// let s = Vec::from_slice(b\"abc\");\n    /// assert_eq!(s, B(\"abc\"));\n    /// ```\n    #[inline]\n    fn from_slice<B: AsRef<[u8]>>(bytes: B) -> Vec<u8> {\n        bytes.as_ref().to_vec()\n    }\n\n    /// Create a new byte string from an owned OS string.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this returns the original OS string if it is not valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// use bstr::{B, ByteVec};\n    ///\n    /// let os_str = OsString::from(\"foo\");\n    /// let bs = Vec::from_os_string(os_str).expect(\"valid UTF-8\");\n    /// assert_eq!(bs, B(\"foo\"));\n    /// ```\n    #[inline]\n    fn from_os_string(os_str: OsString) -> Result<Vec<u8>, OsString> {\n        #[cfg(unix)]\n        #[inline]\n        fn imp(os_str: OsString) -> Result<Vec<u8>, OsString> {\n            use std::os::unix::ffi::OsStringExt;\n\n            Ok(Vec::from(os_str.into_vec()))\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(os_str: OsString) -> Result<Vec<u8>, OsString> {\n            os_str.into_string().map(Vec::from)\n        }\n\n        imp(os_str)\n    }\n\n    /// Lossily create a new byte string from an OS string slice.\n    ///\n    /// On Unix, this always succeeds, is zero cost and always returns a slice.\n    /// On non-Unix systems, this does a UTF-8 check. If the given OS string\n    /// slice is not valid UTF-8, then it is lossily decoded into valid UTF-8\n    /// (with invalid bytes replaced by the Unicode replacement codepoint).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// use bstr::{B, ByteVec};\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// let bs = Vec::from_os_str_lossy(os_str);\n    /// assert_eq!(bs, B(\"foo\"));\n    /// ```\n    #[inline]\n    fn from_os_str_lossy<'a>(os_str: &'a OsStr) -> Cow<'a, [u8]> {\n        #[cfg(unix)]\n        #[inline]\n        fn imp<'a>(os_str: &'a OsStr) -> Cow<'a, [u8]> {\n            use std::os::unix::ffi::OsStrExt;\n\n            Cow::Borrowed(os_str.as_bytes())\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp<'a>(os_str: &'a OsStr) -> Cow<'a, [u8]> {\n            match os_str.to_string_lossy() {\n                Cow::Borrowed(x) => Cow::Borrowed(x.as_bytes()),\n                Cow::Owned(x) => Cow::Owned(Vec::from(x)),\n            }\n        }\n\n        imp(os_str)\n    }\n\n    /// Create a new byte string from an owned file path.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this returns the original path if it is not valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// use bstr::{B, ByteVec};\n    ///\n    /// let path = PathBuf::from(\"foo\");\n    /// let bs = Vec::from_path_buf(path).expect(\"must be valid UTF-8\");\n    /// assert_eq!(bs, B(\"foo\"));\n    /// ```\n    #[inline]\n    fn from_path_buf(path: PathBuf) -> Result<Vec<u8>, PathBuf> {\n        Vec::from_os_string(path.into_os_string()).map_err(PathBuf::from)\n    }\n\n    /// Lossily create a new byte string from a file path.\n    ///\n    /// On Unix, this always succeeds, is zero cost and always returns a slice.\n    /// On non-Unix systems, this does a UTF-8 check. If the given path is not\n    /// valid UTF-8, then it is lossily decoded into valid UTF-8 (with invalid\n    /// bytes replaced by the Unicode replacement codepoint).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// use bstr::{B, ByteVec};\n    ///\n    /// let path = Path::new(\"foo\");\n    /// let bs = Vec::from_path_lossy(path);\n    /// assert_eq!(bs, B(\"foo\"));\n    /// ```\n    #[inline]\n    fn from_path_lossy<'a>(path: &'a Path) -> Cow<'a, [u8]> {\n        Vec::from_os_str_lossy(path.as_os_str())\n    }\n\n    /// Appends the given byte to the end of this byte string.\n    ///\n    /// Note that this is equivalent to the generic `Vec::push` method. This\n    /// method is provided to permit callers to explicitly differentiate\n    /// between pushing bytes, codepoints and strings.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = <Vec<u8>>::from(\"abc\");\n    /// s.push_byte(b'\\xE2');\n    /// s.push_byte(b'\\x98');\n    /// s.push_byte(b'\\x83');\n    /// assert_eq!(s, \"abc☃\".as_bytes());\n    /// ```\n    #[inline]\n    fn push_byte(&mut self, byte: u8) {\n        self.as_vec_mut().push(byte);\n    }\n\n    /// Appends the given `char` to the end of this byte string.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = <Vec<u8>>::from(\"abc\");\n    /// s.push_char('1');\n    /// s.push_char('2');\n    /// s.push_char('3');\n    /// assert_eq!(s, \"abc123\".as_bytes());\n    /// ```\n    #[inline]\n    fn push_char(&mut self, ch: char) {\n        if ch.len_utf8() == 1 {\n            self.push_byte(ch as u8);\n            return;\n        }\n        self.as_vec_mut()\n            .extend_from_slice(ch.encode_utf8(&mut [0; 4]).as_bytes());\n    }\n\n    /// Appends the given slice to the end of this byte string. This accepts\n    /// any type that be converted to a `&[u8]`. This includes, but is not\n    /// limited to, `&str`, `&BStr`, and of course, `&[u8]` itself.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = <Vec<u8>>::from(\"abc\");\n    /// s.push_str(b\"123\");\n    /// assert_eq!(s, \"abc123\".as_bytes());\n    /// ```\n    #[inline]\n    fn push_str<B: AsRef<[u8]>>(&mut self, bytes: B) {\n        self.as_vec_mut().extend_from_slice(bytes.as_ref());\n    }\n\n    /// Converts a `Vec<u8>` into a `String` if and only if this byte string is\n    /// valid UTF-8.\n    ///\n    /// If it is not valid UTF-8, then a\n    /// [`FromUtf8Error`](struct.FromUtf8Error.html)\n    /// is returned. (This error can be used to examine why UTF-8 validation\n    /// failed, or to regain the original byte string.)\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// # fn example() -> Result<(), Box<dyn std::error::Error>> {\n    /// let bytes = Vec::from(\"hello\");\n    /// let string = bytes.into_string()?;\n    ///\n    /// assert_eq!(\"hello\", string);\n    /// # Ok(()) }; example().unwrap()\n    /// ```\n    ///\n    /// If this byte string is not valid UTF-8, then an error will be returned.\n    /// That error can then be used to inspect the location at which invalid\n    /// UTF-8 was found, or to regain the original byte string:\n    ///\n    /// ```\n    /// use bstr::{B, ByteVec};\n    ///\n    /// let bytes = Vec::from_slice(b\"foo\\xFFbar\");\n    /// let err = bytes.into_string().unwrap_err();\n    ///\n    /// assert_eq!(err.utf8_error().valid_up_to(), 3);\n    /// assert_eq!(err.utf8_error().error_len(), Some(1));\n    ///\n    /// // At no point in this example is an allocation performed.\n    /// let bytes = Vec::from(err.into_vec());\n    /// assert_eq!(bytes, B(b\"foo\\xFFbar\"));\n    /// ```\n    #[inline]\n    fn into_string(self) -> Result<String, FromUtf8Error>\n    where\n        Self: Sized,\n    {\n        match utf8::validate(self.as_vec()) {\n            Err(err) => Err(FromUtf8Error { original: self.into_vec(), err }),\n            Ok(()) => {\n                // SAFETY: This is safe because of the guarantees provided by\n                // utf8::validate.\n                unsafe { Ok(self.into_string_unchecked()) }\n            }\n        }\n    }\n\n    /// Lossily converts a `Vec<u8>` into a `String`. If this byte string\n    /// contains invalid UTF-8, then the invalid bytes are replaced with the\n    /// Unicode replacement codepoint.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let bytes = Vec::from_slice(b\"foo\\xFFbar\");\n    /// let string = bytes.into_string_lossy();\n    /// assert_eq!(string, \"foo\\u{FFFD}bar\");\n    /// ```\n    #[inline]\n    fn into_string_lossy(self) -> String\n    where\n        Self: Sized,\n    {\n        match self.as_vec().to_str_lossy() {\n            Cow::Borrowed(_) => {\n                // SAFETY: to_str_lossy() returning a Cow::Borrowed guarantees\n                // the entire string is valid utf8.\n                unsafe { self.into_string_unchecked() }\n            }\n            Cow::Owned(s) => s,\n        }\n    }\n\n    /// Unsafely convert this byte string into a `String`, without checking for\n    /// valid UTF-8.\n    ///\n    /// # Safety\n    ///\n    /// Callers *must* ensure that this byte string is valid UTF-8 before\n    /// calling this method. Converting a byte string into a `String` that is\n    /// not valid UTF-8 is considered undefined behavior.\n    ///\n    /// This routine is useful in performance sensitive contexts where the\n    /// UTF-8 validity of the byte string is already known and it is\n    /// undesirable to pay the cost of an additional UTF-8 validation check\n    /// that [`into_string`](#method.into_string) performs.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// // SAFETY: This is safe because string literals are guaranteed to be\n    /// // valid UTF-8 by the Rust compiler.\n    /// let s = unsafe { Vec::from(\"☃βツ\").into_string_unchecked() };\n    /// assert_eq!(\"☃βツ\", s);\n    /// ```\n    #[inline]\n    unsafe fn into_string_unchecked(self) -> String\n    where\n        Self: Sized,\n    {\n        String::from_utf8_unchecked(self.into_vec())\n    }\n\n    /// Converts this byte string into an OS string, in place.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this returns the original byte string if it is not valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// use bstr::ByteVec;\n    ///\n    /// let bs = Vec::from(\"foo\");\n    /// let os_str = bs.into_os_string().expect(\"should be valid UTF-8\");\n    /// assert_eq!(os_str, OsStr::new(\"foo\"));\n    /// ```\n    #[inline]\n    fn into_os_string(self) -> Result<OsString, Vec<u8>>\n    where\n        Self: Sized,\n    {\n        #[cfg(unix)]\n        #[inline]\n        fn imp(v: Vec<u8>) -> Result<OsString, Vec<u8>> {\n            use std::os::unix::ffi::OsStringExt;\n\n            Ok(OsString::from_vec(v))\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(v: Vec<u8>) -> Result<OsString, Vec<u8>> {\n            match v.into_string() {\n                Ok(s) => Ok(OsString::from(s)),\n                Err(err) => Err(err.into_vec()),\n            }\n        }\n\n        imp(self.into_vec())\n    }\n\n    /// Lossily converts this byte string into an OS string, in place.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this will perform a UTF-8 check and lossily convert this byte string\n    /// into valid UTF-8 using the Unicode replacement codepoint.\n    ///\n    /// Note that this can prevent the correct roundtripping of file paths on\n    /// non-Unix systems such as Windows, where file paths are an arbitrary\n    /// sequence of 16-bit integers.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let bs = Vec::from_slice(b\"foo\\xFFbar\");\n    /// let os_str = bs.into_os_string_lossy();\n    /// assert_eq!(os_str.to_string_lossy(), \"foo\\u{FFFD}bar\");\n    /// ```\n    #[inline]\n    fn into_os_string_lossy(self) -> OsString\n    where\n        Self: Sized,\n    {\n        #[cfg(unix)]\n        #[inline]\n        fn imp(v: Vec<u8>) -> OsString {\n            use std::os::unix::ffi::OsStringExt;\n\n            OsString::from_vec(v)\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(v: Vec<u8>) -> OsString {\n            OsString::from(v.into_string_lossy())\n        }\n\n        imp(self.into_vec())\n    }\n\n    /// Converts this byte string into an owned file path, in place.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this returns the original byte string if it is not valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let bs = Vec::from(\"foo\");\n    /// let path = bs.into_path_buf().expect(\"should be valid UTF-8\");\n    /// assert_eq!(path.as_os_str(), \"foo\");\n    /// ```\n    #[inline]\n    fn into_path_buf(self) -> Result<PathBuf, Vec<u8>>\n    where\n        Self: Sized,\n    {\n        self.into_os_string().map(PathBuf::from)\n    }\n\n    /// Lossily converts this byte string into an owned file path, in place.\n    ///\n    /// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n    /// this will perform a UTF-8 check and lossily convert this byte string\n    /// into valid UTF-8 using the Unicode replacement codepoint.\n    ///\n    /// Note that this can prevent the correct roundtripping of file paths on\n    /// non-Unix systems such as Windows, where file paths are an arbitrary\n    /// sequence of 16-bit integers.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let bs = Vec::from_slice(b\"foo\\xFFbar\");\n    /// let path = bs.into_path_buf_lossy();\n    /// assert_eq!(path.to_string_lossy(), \"foo\\u{FFFD}bar\");\n    /// ```\n    #[inline]\n    fn into_path_buf_lossy(self) -> PathBuf\n    where\n        Self: Sized,\n    {\n        PathBuf::from(self.into_os_string_lossy())\n    }\n\n    /// Removes the last byte from this `Vec<u8>` and returns it.\n    ///\n    /// If this byte string is empty, then `None` is returned.\n    ///\n    /// If the last codepoint in this byte string is not ASCII, then removing\n    /// the last byte could make this byte string contain invalid UTF-8.\n    ///\n    /// Note that this is equivalent to the generic `Vec::pop` method. This\n    /// method is provided to permit callers to explicitly differentiate\n    /// between popping bytes and codepoints.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = Vec::from(\"foo\");\n    /// assert_eq!(s.pop_byte(), Some(b'o'));\n    /// assert_eq!(s.pop_byte(), Some(b'o'));\n    /// assert_eq!(s.pop_byte(), Some(b'f'));\n    /// assert_eq!(s.pop_byte(), None);\n    /// ```\n    #[inline]\n    fn pop_byte(&mut self) -> Option<u8> {\n        self.as_vec_mut().pop()\n    }\n\n    /// Removes the last codepoint from this `Vec<u8>` and returns it.\n    ///\n    /// If this byte string is empty, then `None` is returned. If the last\n    /// bytes of this byte string do not correspond to a valid UTF-8 code unit\n    /// sequence, then the Unicode replacement codepoint is yielded instead in\n    /// accordance with the\n    /// [replacement codepoint substitution policy](index.html#handling-of-invalid-utf8-8).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = Vec::from(\"foo\");\n    /// assert_eq!(s.pop_char(), Some('o'));\n    /// assert_eq!(s.pop_char(), Some('o'));\n    /// assert_eq!(s.pop_char(), Some('f'));\n    /// assert_eq!(s.pop_char(), None);\n    /// ```\n    ///\n    /// This shows the replacement codepoint substitution policy. Note that\n    /// the first pop yields a replacement codepoint but actually removes two\n    /// bytes. This is in contrast with subsequent pops when encountering\n    /// `\\xFF` since `\\xFF` is never a valid prefix for any valid UTF-8\n    /// code unit sequence.\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = Vec::from_slice(b\"f\\xFF\\xFF\\xFFoo\\xE2\\x98\");\n    /// assert_eq!(s.pop_char(), Some('\\u{FFFD}'));\n    /// assert_eq!(s.pop_char(), Some('o'));\n    /// assert_eq!(s.pop_char(), Some('o'));\n    /// assert_eq!(s.pop_char(), Some('\\u{FFFD}'));\n    /// assert_eq!(s.pop_char(), Some('\\u{FFFD}'));\n    /// assert_eq!(s.pop_char(), Some('\\u{FFFD}'));\n    /// assert_eq!(s.pop_char(), Some('f'));\n    /// assert_eq!(s.pop_char(), None);\n    /// ```\n    #[inline]\n    fn pop_char(&mut self) -> Option<char> {\n        let (ch, size) = utf8::decode_last_lossy(self.as_vec());\n        if size == 0 {\n            return None;\n        }\n        let new_len = self.as_vec().len() - size;\n        self.as_vec_mut().truncate(new_len);\n        Some(ch)\n    }\n\n    /// Removes a `char` from this `Vec<u8>` at the given byte position and\n    /// returns it.\n    ///\n    /// If the bytes at the given position do not lead to a valid UTF-8 code\n    /// unit sequence, then a\n    /// [replacement codepoint is returned instead](index.html#handling-of-invalid-utf8-8).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at` is larger than or equal to this byte string's length.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = Vec::from(\"foo☃bar\");\n    /// assert_eq!(s.remove_char(3), '☃');\n    /// assert_eq!(s, b\"foobar\");\n    /// ```\n    ///\n    /// This example shows how the Unicode replacement codepoint policy is\n    /// used:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = Vec::from_slice(b\"foo\\xFFbar\");\n    /// assert_eq!(s.remove_char(3), '\\u{FFFD}');\n    /// assert_eq!(s, b\"foobar\");\n    /// ```\n    #[inline]\n    fn remove_char(&mut self, at: usize) -> char {\n        let (ch, size) = utf8::decode_lossy(&self.as_vec()[at..]);\n        assert!(\n            size > 0,\n            \"expected {} to be less than {}\",\n            at,\n            self.as_vec().len(),\n        );\n        self.as_vec_mut().drain(at..at + size);\n        ch\n    }\n\n    /// Inserts the given codepoint into this `Vec<u8>` at a particular byte\n    /// position.\n    ///\n    /// This is an `O(n)` operation as it may copy a number of elements in this\n    /// byte string proportional to its length.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at` is larger than the byte string's length.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = Vec::from(\"foobar\");\n    /// s.insert_char(3, '☃');\n    /// assert_eq!(s, \"foo☃bar\".as_bytes());\n    /// ```\n    #[inline]\n    fn insert_char(&mut self, at: usize, ch: char) {\n        self.insert_str(at, ch.encode_utf8(&mut [0; 4]).as_bytes());\n    }\n\n    /// Inserts the given byte string into this byte string at a particular\n    /// byte position.\n    ///\n    /// This is an `O(n)` operation as it may copy a number of elements in this\n    /// byte string proportional to its length.\n    ///\n    /// The given byte string may be any type that can be cheaply converted\n    /// into a `&[u8]`. This includes, but is not limited to, `&str` and\n    /// `&[u8]`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at` is larger than the byte string's length.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = Vec::from(\"foobar\");\n    /// s.insert_str(3, \"☃☃☃\");\n    /// assert_eq!(s, \"foo☃☃☃bar\".as_bytes());\n    /// ```\n    #[inline]\n    fn insert_str<B: AsRef<[u8]>>(&mut self, at: usize, bytes: B) {\n        let bytes = bytes.as_ref();\n        let len = self.as_vec().len();\n        assert!(at <= len, \"expected {} to be <= {}\", at, len);\n\n        // SAFETY: We'd like to efficiently splice in the given bytes into\n        // this byte string. Since we are only working with `u8` elements here,\n        // we only need to consider whether our bounds are correct and whether\n        // our byte string has enough space.\n        self.as_vec_mut().reserve(bytes.len());\n        unsafe {\n            // Shift bytes after `at` over by the length of `bytes` to make\n            // room for it. This requires referencing two regions of memory\n            // that may overlap, so we use ptr::copy.\n            ptr::copy(\n                self.as_vec().as_ptr().add(at),\n                self.as_vec_mut().as_mut_ptr().add(at + bytes.len()),\n                len - at,\n            );\n            // Now copy the bytes given into the room we made above. In this\n            // case, we know that the given bytes cannot possibly overlap\n            // with this byte string since we have a mutable borrow of the\n            // latter. Thus, we can use a nonoverlapping copy.\n            ptr::copy_nonoverlapping(\n                bytes.as_ptr(),\n                self.as_vec_mut().as_mut_ptr().add(at),\n                bytes.len(),\n            );\n            self.as_vec_mut().set_len(len + bytes.len());\n        }\n    }\n\n    /// Removes the specified range in this byte string and replaces it with\n    /// the given bytes. The given bytes do not need to have the same length\n    /// as the range provided.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the given range is invalid.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = Vec::from(\"foobar\");\n    /// s.replace_range(2..4, \"xxxxx\");\n    /// assert_eq!(s, \"foxxxxxar\".as_bytes());\n    /// ```\n    #[inline]\n    fn replace_range<R, B>(&mut self, range: R, replace_with: B)\n    where\n        R: ops::RangeBounds<usize>,\n        B: AsRef<[u8]>,\n    {\n        self.as_vec_mut().splice(range, replace_with.as_ref().iter().cloned());\n    }\n\n    /// Creates a draining iterator that removes the specified range in this\n    /// `Vec<u8>` and yields each of the removed bytes.\n    ///\n    /// Note that the elements specified by the given range are removed\n    /// regardless of whether the returned iterator is fully exhausted.\n    ///\n    /// Also note that is is unspecified how many bytes are removed from the\n    /// `Vec<u8>` if the `DrainBytes` iterator is leaked.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the given range is not valid.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use bstr::ByteVec;\n    ///\n    /// let mut s = Vec::from(\"foobar\");\n    /// {\n    ///     let mut drainer = s.drain_bytes(2..4);\n    ///     assert_eq!(drainer.next(), Some(b'o'));\n    ///     assert_eq!(drainer.next(), Some(b'b'));\n    ///     assert_eq!(drainer.next(), None);\n    /// }\n    /// assert_eq!(s, \"foar\".as_bytes());\n    /// ```\n    #[inline]\n    fn drain_bytes<R>(&mut self, range: R) -> DrainBytes\n    where\n        R: ops::RangeBounds<usize>,\n    {\n        DrainBytes { it: self.as_vec_mut().drain(range) }\n    }\n}","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::drain_bytes":["/// Creates a draining iterator that removes the specified range in this\n/// `Vec<u8>` and yields each of the removed bytes.\n///\n/// Note that the elements specified by the given range are removed\n/// regardless of whether the returned iterator is fully exhausted.\n///\n/// Also note that is is unspecified how many bytes are removed from the\n/// `Vec<u8>` if the `DrainBytes` iterator is leaked.\n///\n/// # Panics\n///\n/// Panics if the given range is not valid.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = Vec::from(\"foobar\");\n/// {\n///     let mut drainer = s.drain_bytes(2..4);\n///     assert_eq!(drainer.next(), Some(b'o'));\n///     assert_eq!(drainer.next(), Some(b'b'));\n///     assert_eq!(drainer.next(), None);\n/// }\n/// assert_eq!(s, \"foar\".as_bytes());\n/// ```\n#[inline]\nfn drain_bytes<R>(&mut self, range: R) -> DrainBytes\n    where\n        R: ops::RangeBounds<usize>,{\n        DrainBytes { it: self.as_vec_mut().drain(range) }\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::from_os_str_lossy":["/// Lossily create a new byte string from an OS string slice.\n///\n/// On Unix, this always succeeds, is zero cost and always returns a slice.\n/// On non-Unix systems, this does a UTF-8 check. If the given OS string\n/// slice is not valid UTF-8, then it is lossily decoded into valid UTF-8\n/// (with invalid bytes replaced by the Unicode replacement codepoint).\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::ffi::OsStr;\n///\n/// use bstr::{B, ByteVec};\n///\n/// let os_str = OsStr::new(\"foo\");\n/// let bs = Vec::from_os_str_lossy(os_str);\n/// assert_eq!(bs, B(\"foo\"));\n/// ```\n#[inline]\nfn from_os_str_lossy<'a>(os_str: &'a OsStr) -> Cow<'a, [u8]>{\n        #[cfg(unix)]\n        #[inline]\n        fn imp<'a>(os_str: &'a OsStr) -> Cow<'a, [u8]> {\n            use std::os::unix::ffi::OsStrExt;\n\n            Cow::Borrowed(os_str.as_bytes())\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp<'a>(os_str: &'a OsStr) -> Cow<'a, [u8]> {\n            match os_str.to_string_lossy() {\n                Cow::Borrowed(x) => Cow::Borrowed(x.as_bytes()),\n                Cow::Owned(x) => Cow::Owned(Vec::from(x)),\n            }\n        }\n\n        imp(os_str)\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::from_os_str_lossy::imp":["#[cfg(unix)]\n#[inline]\nfn imp<'a>(os_str: &'a OsStr) -> Cow<'a, [u8]>{\n            use std::os::unix::ffi::OsStrExt;\n\n            Cow::Borrowed(os_str.as_bytes())\n        }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::from_os_string":["/// Create a new byte string from an owned OS string.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this returns the original OS string if it is not valid UTF-8.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::ffi::OsString;\n///\n/// use bstr::{B, ByteVec};\n///\n/// let os_str = OsString::from(\"foo\");\n/// let bs = Vec::from_os_string(os_str).expect(\"valid UTF-8\");\n/// assert_eq!(bs, B(\"foo\"));\n/// ```\n#[inline]\nfn from_os_string(os_str: OsString) -> Result<Vec<u8>, OsString>{\n        #[cfg(unix)]\n        #[inline]\n        fn imp(os_str: OsString) -> Result<Vec<u8>, OsString> {\n            use std::os::unix::ffi::OsStringExt;\n\n            Ok(Vec::from(os_str.into_vec()))\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(os_str: OsString) -> Result<Vec<u8>, OsString> {\n            os_str.into_string().map(Vec::from)\n        }\n\n        imp(os_str)\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::from_os_string::imp":["#[cfg(unix)]\n#[inline]\nfn imp(os_str: OsString) -> Result<Vec<u8>, OsString>{\n            use std::os::unix::ffi::OsStringExt;\n\n            Ok(Vec::from(os_str.into_vec()))\n        }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::from_path_buf":["/// Create a new byte string from an owned file path.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this returns the original path if it is not valid UTF-8.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::path::PathBuf;\n///\n/// use bstr::{B, ByteVec};\n///\n/// let path = PathBuf::from(\"foo\");\n/// let bs = Vec::from_path_buf(path).expect(\"must be valid UTF-8\");\n/// assert_eq!(bs, B(\"foo\"));\n/// ```\n#[inline]\nfn from_path_buf(path: PathBuf) -> Result<Vec<u8>, PathBuf>{\n        Vec::from_os_string(path.into_os_string()).map_err(PathBuf::from)\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::from_path_lossy":["/// Lossily create a new byte string from a file path.\n///\n/// On Unix, this always succeeds, is zero cost and always returns a slice.\n/// On non-Unix systems, this does a UTF-8 check. If the given path is not\n/// valid UTF-8, then it is lossily decoded into valid UTF-8 (with invalid\n/// bytes replaced by the Unicode replacement codepoint).\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::path::Path;\n///\n/// use bstr::{B, ByteVec};\n///\n/// let path = Path::new(\"foo\");\n/// let bs = Vec::from_path_lossy(path);\n/// assert_eq!(bs, B(\"foo\"));\n/// ```\n#[inline]\nfn from_path_lossy<'a>(path: &'a Path) -> Cow<'a, [u8]>{\n        Vec::from_os_str_lossy(path.as_os_str())\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::from_slice":["/// Create a new owned byte string from the given byte slice.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteVec};\n///\n/// let s = Vec::from_slice(b\"abc\");\n/// assert_eq!(s, B(\"abc\"));\n/// ```\n#[inline]\nfn from_slice<B: AsRef<[u8]>>(bytes: B) -> Vec<u8>{\n        bytes.as_ref().to_vec()\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::insert_char":["/// Inserts the given codepoint into this `Vec<u8>` at a particular byte\n/// position.\n///\n/// This is an `O(n)` operation as it may copy a number of elements in this\n/// byte string proportional to its length.\n///\n/// # Panics\n///\n/// Panics if `at` is larger than the byte string's length.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = Vec::from(\"foobar\");\n/// s.insert_char(3, '☃');\n/// assert_eq!(s, \"foo☃bar\".as_bytes());\n/// ```\n#[inline]\nfn insert_char(&mut self, at: usize, ch: char){\n        self.insert_str(at, ch.encode_utf8(&mut [0; 4]).as_bytes());\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::insert_str":["/// Inserts the given byte string into this byte string at a particular\n/// byte position.\n///\n/// This is an `O(n)` operation as it may copy a number of elements in this\n/// byte string proportional to its length.\n///\n/// The given byte string may be any type that can be cheaply converted\n/// into a `&[u8]`. This includes, but is not limited to, `&str` and\n/// `&[u8]`.\n///\n/// # Panics\n///\n/// Panics if `at` is larger than the byte string's length.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = Vec::from(\"foobar\");\n/// s.insert_str(3, \"☃☃☃\");\n/// assert_eq!(s, \"foo☃☃☃bar\".as_bytes());\n/// ```\n#[inline]\nfn insert_str<B: AsRef<[u8]>>(&mut self, at: usize, bytes: B){\n        let bytes = bytes.as_ref();\n        let len = self.as_vec().len();\n        assert!(at <= len, \"expected {} to be <= {}\", at, len);\n\n        // SAFETY: We'd like to efficiently splice in the given bytes into\n        // this byte string. Since we are only working with `u8` elements here,\n        // we only need to consider whether our bounds are correct and whether\n        // our byte string has enough space.\n        self.as_vec_mut().reserve(bytes.len());\n        unsafe {\n            // Shift bytes after `at` over by the length of `bytes` to make\n            // room for it. This requires referencing two regions of memory\n            // that may overlap, so we use ptr::copy.\n            ptr::copy(\n                self.as_vec().as_ptr().add(at),\n                self.as_vec_mut().as_mut_ptr().add(at + bytes.len()),\n                len - at,\n            );\n            // Now copy the bytes given into the room we made above. In this\n            // case, we know that the given bytes cannot possibly overlap\n            // with this byte string since we have a mutable borrow of the\n            // latter. Thus, we can use a nonoverlapping copy.\n            ptr::copy_nonoverlapping(\n                bytes.as_ptr(),\n                self.as_vec_mut().as_mut_ptr().add(at),\n                bytes.len(),\n            );\n            self.as_vec_mut().set_len(len + bytes.len());\n        }\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::into_os_string":["/// Converts this byte string into an OS string, in place.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this returns the original byte string if it is not valid UTF-8.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::ffi::OsStr;\n///\n/// use bstr::ByteVec;\n///\n/// let bs = Vec::from(\"foo\");\n/// let os_str = bs.into_os_string().expect(\"should be valid UTF-8\");\n/// assert_eq!(os_str, OsStr::new(\"foo\"));\n/// ```\n#[inline]\nfn into_os_string(self) -> Result<OsString, Vec<u8>>\n    where\n        Self: Sized,{\n        #[cfg(unix)]\n        #[inline]\n        fn imp(v: Vec<u8>) -> Result<OsString, Vec<u8>> {\n            use std::os::unix::ffi::OsStringExt;\n\n            Ok(OsString::from_vec(v))\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(v: Vec<u8>) -> Result<OsString, Vec<u8>> {\n            match v.into_string() {\n                Ok(s) => Ok(OsString::from(s)),\n                Err(err) => Err(err.into_vec()),\n            }\n        }\n\n        imp(self.into_vec())\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::into_os_string::imp":["#[cfg(unix)]\n#[inline]\nfn imp(v: Vec<u8>) -> Result<OsString, Vec<u8>>{\n            use std::os::unix::ffi::OsStringExt;\n\n            Ok(OsString::from_vec(v))\n        }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::into_os_string_lossy":["/// Lossily converts this byte string into an OS string, in place.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this will perform a UTF-8 check and lossily convert this byte string\n/// into valid UTF-8 using the Unicode replacement codepoint.\n///\n/// Note that this can prevent the correct roundtripping of file paths on\n/// non-Unix systems such as Windows, where file paths are an arbitrary\n/// sequence of 16-bit integers.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let bs = Vec::from_slice(b\"foo\\xFFbar\");\n/// let os_str = bs.into_os_string_lossy();\n/// assert_eq!(os_str.to_string_lossy(), \"foo\\u{FFFD}bar\");\n/// ```\n#[inline]\nfn into_os_string_lossy(self) -> OsString\n    where\n        Self: Sized,{\n        #[cfg(unix)]\n        #[inline]\n        fn imp(v: Vec<u8>) -> OsString {\n            use std::os::unix::ffi::OsStringExt;\n\n            OsString::from_vec(v)\n        }\n\n        #[cfg(not(unix))]\n        #[inline]\n        fn imp(v: Vec<u8>) -> OsString {\n            OsString::from(v.into_string_lossy())\n        }\n\n        imp(self.into_vec())\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::into_os_string_lossy::imp":["#[cfg(unix)]\n#[inline]\nfn imp(v: Vec<u8>) -> OsString{\n            use std::os::unix::ffi::OsStringExt;\n\n            OsString::from_vec(v)\n        }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::into_path_buf":["/// Converts this byte string into an owned file path, in place.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this returns the original byte string if it is not valid UTF-8.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let bs = Vec::from(\"foo\");\n/// let path = bs.into_path_buf().expect(\"should be valid UTF-8\");\n/// assert_eq!(path.as_os_str(), \"foo\");\n/// ```\n#[inline]\nfn into_path_buf(self) -> Result<PathBuf, Vec<u8>>\n    where\n        Self: Sized,{\n        self.into_os_string().map(PathBuf::from)\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::into_path_buf_lossy":["/// Lossily converts this byte string into an owned file path, in place.\n///\n/// On Unix, this always succeeds and is zero cost. On non-Unix systems,\n/// this will perform a UTF-8 check and lossily convert this byte string\n/// into valid UTF-8 using the Unicode replacement codepoint.\n///\n/// Note that this can prevent the correct roundtripping of file paths on\n/// non-Unix systems such as Windows, where file paths are an arbitrary\n/// sequence of 16-bit integers.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let bs = Vec::from_slice(b\"foo\\xFFbar\");\n/// let path = bs.into_path_buf_lossy();\n/// assert_eq!(path.to_string_lossy(), \"foo\\u{FFFD}bar\");\n/// ```\n#[inline]\nfn into_path_buf_lossy(self) -> PathBuf\n    where\n        Self: Sized,{\n        PathBuf::from(self.into_os_string_lossy())\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::into_string":["/// Converts a `Vec<u8>` into a `String` if and only if this byte string is\n/// valid UTF-8.\n///\n/// If it is not valid UTF-8, then a\n/// [`FromUtf8Error`](struct.FromUtf8Error.html)\n/// is returned. (This error can be used to examine why UTF-8 validation\n/// failed, or to regain the original byte string.)\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// # fn example() -> Result<(), Box<dyn std::error::Error>> {\n/// let bytes = Vec::from(\"hello\");\n/// let string = bytes.into_string()?;\n///\n/// assert_eq!(\"hello\", string);\n/// # Ok(()) }; example().unwrap()\n/// ```\n///\n/// If this byte string is not valid UTF-8, then an error will be returned.\n/// That error can then be used to inspect the location at which invalid\n/// UTF-8 was found, or to regain the original byte string:\n///\n/// ```\n/// use bstr::{B, ByteVec};\n///\n/// let bytes = Vec::from_slice(b\"foo\\xFFbar\");\n/// let err = bytes.into_string().unwrap_err();\n///\n/// assert_eq!(err.utf8_error().valid_up_to(), 3);\n/// assert_eq!(err.utf8_error().error_len(), Some(1));\n///\n/// // At no point in this example is an allocation performed.\n/// let bytes = Vec::from(err.into_vec());\n/// assert_eq!(bytes, B(b\"foo\\xFFbar\"));\n/// ```\n#[inline]\nfn into_string(self) -> Result<String, FromUtf8Error>\n    where\n        Self: Sized,{\n        match utf8::validate(self.as_vec()) {\n            Err(err) => Err(FromUtf8Error { original: self.into_vec(), err }),\n            Ok(()) => {\n                // SAFETY: This is safe because of the guarantees provided by\n                // utf8::validate.\n                unsafe { Ok(self.into_string_unchecked()) }\n            }\n        }\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::into_string_lossy":["/// Lossily converts a `Vec<u8>` into a `String`. If this byte string\n/// contains invalid UTF-8, then the invalid bytes are replaced with the\n/// Unicode replacement codepoint.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let bytes = Vec::from_slice(b\"foo\\xFFbar\");\n/// let string = bytes.into_string_lossy();\n/// assert_eq!(string, \"foo\\u{FFFD}bar\");\n/// ```\n#[inline]\nfn into_string_lossy(self) -> String\n    where\n        Self: Sized,{\n        match self.as_vec().to_str_lossy() {\n            Cow::Borrowed(_) => {\n                // SAFETY: to_str_lossy() returning a Cow::Borrowed guarantees\n                // the entire string is valid utf8.\n                unsafe { self.into_string_unchecked() }\n            }\n            Cow::Owned(s) => s,\n        }\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::into_string_unchecked":["/// Unsafely convert this byte string into a `String`, without checking for\n/// valid UTF-8.\n///\n/// # Safety\n///\n/// Callers *must* ensure that this byte string is valid UTF-8 before\n/// calling this method. Converting a byte string into a `String` that is\n/// not valid UTF-8 is considered undefined behavior.\n///\n/// This routine is useful in performance sensitive contexts where the\n/// UTF-8 validity of the byte string is already known and it is\n/// undesirable to pay the cost of an additional UTF-8 validation check\n/// that [`into_string`](#method.into_string) performs.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// // SAFETY: This is safe because string literals are guaranteed to be\n/// // valid UTF-8 by the Rust compiler.\n/// let s = unsafe { Vec::from(\"☃βツ\").into_string_unchecked() };\n/// assert_eq!(\"☃βツ\", s);\n/// ```\n#[inline]\nunsafe fn into_string_unchecked(self) -> String\n    where\n        Self: Sized,{\n        String::from_utf8_unchecked(self.into_vec())\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::pop_byte":["/// Removes the last byte from this `Vec<u8>` and returns it.\n///\n/// If this byte string is empty, then `None` is returned.\n///\n/// If the last codepoint in this byte string is not ASCII, then removing\n/// the last byte could make this byte string contain invalid UTF-8.\n///\n/// Note that this is equivalent to the generic `Vec::pop` method. This\n/// method is provided to permit callers to explicitly differentiate\n/// between popping bytes and codepoints.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = Vec::from(\"foo\");\n/// assert_eq!(s.pop_byte(), Some(b'o'));\n/// assert_eq!(s.pop_byte(), Some(b'o'));\n/// assert_eq!(s.pop_byte(), Some(b'f'));\n/// assert_eq!(s.pop_byte(), None);\n/// ```\n#[inline]\nfn pop_byte(&mut self) -> Option<u8>{\n        self.as_vec_mut().pop()\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::pop_char":["/// Removes the last codepoint from this `Vec<u8>` and returns it.\n///\n/// If this byte string is empty, then `None` is returned. If the last\n/// bytes of this byte string do not correspond to a valid UTF-8 code unit\n/// sequence, then the Unicode replacement codepoint is yielded instead in\n/// accordance with the\n/// [replacement codepoint substitution policy](index.html#handling-of-invalid-utf8-8).\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = Vec::from(\"foo\");\n/// assert_eq!(s.pop_char(), Some('o'));\n/// assert_eq!(s.pop_char(), Some('o'));\n/// assert_eq!(s.pop_char(), Some('f'));\n/// assert_eq!(s.pop_char(), None);\n/// ```\n///\n/// This shows the replacement codepoint substitution policy. Note that\n/// the first pop yields a replacement codepoint but actually removes two\n/// bytes. This is in contrast with subsequent pops when encountering\n/// `\\xFF` since `\\xFF` is never a valid prefix for any valid UTF-8\n/// code unit sequence.\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = Vec::from_slice(b\"f\\xFF\\xFF\\xFFoo\\xE2\\x98\");\n/// assert_eq!(s.pop_char(), Some('\\u{FFFD}'));\n/// assert_eq!(s.pop_char(), Some('o'));\n/// assert_eq!(s.pop_char(), Some('o'));\n/// assert_eq!(s.pop_char(), Some('\\u{FFFD}'));\n/// assert_eq!(s.pop_char(), Some('\\u{FFFD}'));\n/// assert_eq!(s.pop_char(), Some('\\u{FFFD}'));\n/// assert_eq!(s.pop_char(), Some('f'));\n/// assert_eq!(s.pop_char(), None);\n/// ```\n#[inline]\nfn pop_char(&mut self) -> Option<char>{\n        let (ch, size) = utf8::decode_last_lossy(self.as_vec());\n        if size == 0 {\n            return None;\n        }\n        let new_len = self.as_vec().len() - size;\n        self.as_vec_mut().truncate(new_len);\n        Some(ch)\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::push_byte":["/// Appends the given byte to the end of this byte string.\n///\n/// Note that this is equivalent to the generic `Vec::push` method. This\n/// method is provided to permit callers to explicitly differentiate\n/// between pushing bytes, codepoints and strings.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = <Vec<u8>>::from(\"abc\");\n/// s.push_byte(b'\\xE2');\n/// s.push_byte(b'\\x98');\n/// s.push_byte(b'\\x83');\n/// assert_eq!(s, \"abc☃\".as_bytes());\n/// ```\n#[inline]\nfn push_byte(&mut self, byte: u8){\n        self.as_vec_mut().push(byte);\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::push_char":["/// Appends the given `char` to the end of this byte string.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = <Vec<u8>>::from(\"abc\");\n/// s.push_char('1');\n/// s.push_char('2');\n/// s.push_char('3');\n/// assert_eq!(s, \"abc123\".as_bytes());\n/// ```\n#[inline]\nfn push_char(&mut self, ch: char){\n        if ch.len_utf8() == 1 {\n            self.push_byte(ch as u8);\n            return;\n        }\n        self.as_vec_mut()\n            .extend_from_slice(ch.encode_utf8(&mut [0; 4]).as_bytes());\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::push_str":["/// Appends the given slice to the end of this byte string. This accepts\n/// any type that be converted to a `&[u8]`. This includes, but is not\n/// limited to, `&str`, `&BStr`, and of course, `&[u8]` itself.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = <Vec<u8>>::from(\"abc\");\n/// s.push_str(b\"123\");\n/// assert_eq!(s, \"abc123\".as_bytes());\n/// ```\n#[inline]\nfn push_str<B: AsRef<[u8]>>(&mut self, bytes: B){\n        self.as_vec_mut().extend_from_slice(bytes.as_ref());\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::remove_char":["/// Removes a `char` from this `Vec<u8>` at the given byte position and\n/// returns it.\n///\n/// If the bytes at the given position do not lead to a valid UTF-8 code\n/// unit sequence, then a\n/// [replacement codepoint is returned instead](index.html#handling-of-invalid-utf8-8).\n///\n/// # Panics\n///\n/// Panics if `at` is larger than or equal to this byte string's length.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = Vec::from(\"foo☃bar\");\n/// assert_eq!(s.remove_char(3), '☃');\n/// assert_eq!(s, b\"foobar\");\n/// ```\n///\n/// This example shows how the Unicode replacement codepoint policy is\n/// used:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = Vec::from_slice(b\"foo\\xFFbar\");\n/// assert_eq!(s.remove_char(3), '\\u{FFFD}');\n/// assert_eq!(s, b\"foobar\");\n/// ```\n#[inline]\nfn remove_char(&mut self, at: usize) -> char{\n        let (ch, size) = utf8::decode_lossy(&self.as_vec()[at..]);\n        assert!(\n            size > 0,\n            \"expected {} to be less than {}\",\n            at,\n            self.as_vec().len(),\n        );\n        self.as_vec_mut().drain(at..at + size);\n        ch\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::ByteVec::replace_range":["/// Removes the specified range in this byte string and replaces it with\n/// the given bytes. The given bytes do not need to have the same length\n/// as the range provided.\n///\n/// # Panics\n///\n/// Panics if the given range is invalid.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = Vec::from(\"foobar\");\n/// s.replace_range(2..4, \"xxxxx\");\n/// assert_eq!(s, \"foxxxxxar\".as_bytes());\n/// ```\n#[inline]\nfn replace_range<R, B>(&mut self, range: R, replace_with: B)\n    where\n        R: ops::RangeBounds<usize>,\n        B: AsRef<[u8]>,{\n        self.as_vec_mut().splice(range, replace_with.as_ref().iter().cloned());\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::DrainBytes":["/// A draining byte oriented iterator for `Vec<u8>`.\n///\n/// This iterator is created by\n/// [`ByteVec::drain_bytes`](trait.ByteVec.html#method.drain_bytes).\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::ByteVec;\n///\n/// let mut s = Vec::from(\"foobar\");\n/// {\n///     let mut drainer = s.drain_bytes(2..4);\n///     assert_eq!(drainer.next(), Some(b'o'));\n///     assert_eq!(drainer.next(), Some(b'b'));\n///     assert_eq!(drainer.next(), None);\n/// }\n/// assert_eq!(s, \"foar\".as_bytes());\n/// ```\npub struct DrainBytes<'a> {\n    it: vec::Drain<'a, u8>,\n}","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::FromUtf8Error":["/// An error that may occur when converting a `Vec<u8>` to a `String`.\n///\n/// This error includes the original `Vec<u8>` that failed to convert to a\n/// `String`. This permits callers to recover the allocation used even if it\n/// it not valid UTF-8.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteVec};\n///\n/// let bytes = Vec::from_slice(b\"foo\\xFFbar\");\n/// let err = bytes.into_string().unwrap_err();\n///\n/// assert_eq!(err.utf8_error().valid_up_to(), 3);\n/// assert_eq!(err.utf8_error().error_len(), Some(1));\n///\n/// // At no point in this example is an allocation performed.\n/// let bytes = Vec::from(err.into_vec());\n/// assert_eq!(bytes, B(b\"foo\\xFFbar\"));\n/// ```\npub struct FromUtf8Error {\n    original: Vec<u8>,\n    err: Utf8Error,\n}","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::FromUtf8Error::as_bytes":["/// Return the original bytes as a slice that failed to convert to a\n/// `String`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteVec};\n///\n/// let bytes = Vec::from_slice(b\"foo\\xFFbar\");\n/// let err = bytes.into_string().unwrap_err();\n///\n/// // At no point in this example is an allocation performed.\n/// assert_eq!(err.as_bytes(), B(b\"foo\\xFFbar\"));\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &[u8]{\n        &self.original\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::FromUtf8Error::into_vec":["/// Consume this error and return the original byte string that failed to\n/// convert to a `String`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteVec};\n///\n/// let bytes = Vec::from_slice(b\"foo\\xFFbar\");\n/// let err = bytes.into_string().unwrap_err();\n/// let original = err.into_vec();\n///\n/// // At no point in this example is an allocation performed.\n/// assert_eq!(original, B(b\"foo\\xFFbar\"));\n/// ```\n#[inline]\npub fn into_vec(self) -> Vec<u8>{\n        self.original\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::FromUtf8Error::utf8_error":["/// Return the underlying UTF-8 error that occurred. This error provides\n/// information on the nature and location of the invalid UTF-8 detected.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::{B, ByteVec};\n///\n/// let bytes = Vec::from_slice(b\"foo\\xFFbar\");\n/// let err = bytes.into_string().unwrap_err();\n///\n/// assert_eq!(err.utf8_error().valid_up_to(), 3);\n/// assert_eq!(err.utf8_error().error_len(), Some(1));\n/// ```\n#[inline]\npub fn utf8_error(&self) -> &Utf8Error{\n        &self.err\n    }","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::Sealed":["/// Ensure that callers cannot implement `ByteSlice` by making an\n/// umplementable trait its super trait.\npub trait Sealed {}","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::concat":["/// Concatenate the elements given by the iterator together into a single\n/// `Vec<u8>`.\n///\n/// The elements may be any type that can be cheaply converted into an `&[u8]`.\n/// This includes, but is not limited to, `&str`, `&BStr` and `&[u8]` itself.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr;\n///\n/// let s = bstr::concat(&[\"foo\", \"bar\", \"baz\"]);\n/// assert_eq!(s, \"foobarbaz\".as_bytes());\n/// ```\n#[inline]\npub fn concat<T, I>(elements: I) -> Vec<u8>\nwhere\n    T: AsRef<[u8]>,\n    I: IntoIterator<Item = T>,{\n    let mut dest = vec![];\n    for element in elements {\n        dest.push_str(element);\n    }\n    dest\n}","Real(LocalPath(\"src/ext_vec.rs\"))"],"ext_vec::join":["/// Join the elements given by the iterator with the given separator into a\n/// single `Vec<u8>`.\n///\n/// Both the separator and the elements may be any type that can be cheaply\n/// converted into an `&[u8]`. This includes, but is not limited to,\n/// `&str`, `&BStr` and `&[u8]` itself.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr;\n///\n/// let s = bstr::join(\",\", &[\"foo\", \"bar\", \"baz\"]);\n/// assert_eq!(s, \"foo,bar,baz\".as_bytes());\n/// ```\n#[inline]\npub fn join<B, T, I>(separator: B, elements: I) -> Vec<u8>\nwhere\n    B: AsRef<[u8]>,\n    T: AsRef<[u8]>,\n    I: IntoIterator<Item = T>,{\n    let mut it = elements.into_iter();\n    let mut dest = vec![];\n    match it.next() {\n        None => return dest,\n        Some(first) => {\n            dest.push_str(first);\n        }\n    }\n    for element in it {\n        dest.push_str(&separator);\n        dest.push_str(element);\n    }\n    dest\n}","Real(LocalPath(\"src/ext_vec.rs\"))"],"impls::bstr::<impl lazy_static::__Deref for bstr::BStr>::deref":["#[inline]\nfn deref(&self) -> &[u8]{\n            &self.bytes\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::Ord for bstr::BStr>::cmp":["#[inline]\nfn cmp(&self, other: &BStr) -> Ordering{\n            self.partial_cmp(other).unwrap()\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq for bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &BStr) -> bool{\n            self.as_bytes() == other.as_bytes()\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<&'a [u8]> for bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::borrow::Cow<'a, [u8]>>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = (&**other).as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::borrow::Cow<'a, bstr::BStr>>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = (&**other).as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::borrow::Cow<'a, str>>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = (&**other).as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::string::String>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::vec::Vec<u8>>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<&'a str> for bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<[u8]> for bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for &'a [u8]>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for &'a str>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for [u8]>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for std::string::String>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for std::vec::Vec<u8>>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for str>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<std::borrow::Cow<'a, [u8]>> for &'a bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = (&**other).as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<std::borrow::Cow<'a, bstr::BStr>> for &'a bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = (&**other).as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<std::borrow::Cow<'a, str>> for &'a bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = (&**other).as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<std::string::String> for &'a bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<std::string::String> for bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<std::vec::Vec<u8>> for &'a bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<std::vec::Vec<u8>> for bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialEq<str> for bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd for bstr::BStr>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &BStr) -> Option<Ordering>{\n            PartialOrd::partial_cmp(self.as_bytes(), other.as_bytes())\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<&'a [u8]> for bstr::BStr>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<&'a bstr::BStr> for std::string::String>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<&'a bstr::BStr> for std::vec::Vec<u8>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<&'a str> for bstr::BStr>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<[u8]> for bstr::BStr>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for &'a [u8]>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for &'a str>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for [u8]>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for std::string::String>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for std::vec::Vec<u8>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for str>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<std::string::String> for &'a bstr::BStr>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<std::string::String> for bstr::BStr>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<std::vec::Vec<u8>> for &'a bstr::BStr>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<std::vec::Vec<u8>> for bstr::BStr>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::cmp::PartialOrd<str> for bstr::BStr>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::convert::AsMut<[u8]> for bstr::BStr>::as_mut":["#[inline]\nfn as_mut(&mut self) -> &mut [u8]{\n            &mut self.bytes\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::convert::AsMut<bstr::BStr> for [u8]>::as_mut":["#[inline]\nfn as_mut(&mut self) -> &mut BStr{\n            BStr::new_mut(self)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::convert::AsRef<[u8]> for bstr::BStr>::as_ref":["#[inline]\nfn as_ref(&self) -> &[u8]{\n            self.as_bytes()\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::convert::AsRef<bstr::BStr> for [u8]>::as_ref":["#[inline]\nfn as_ref(&self) -> &BStr{\n            BStr::new(self)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::convert::AsRef<bstr::BStr> for str>::as_ref":["#[inline]\nfn as_ref(&self) -> &BStr{\n            BStr::new(self)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::convert::From<&'a [u8]> for &'a bstr::BStr>::from":["#[inline]\nfn from(s: &'a [u8]) -> &'a BStr{\n            BStr::from_bytes(s)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::convert::From<&'a bstr::BStr> for std::borrow::Cow<'a, bstr::BStr>>::from":["#[inline]\nfn from(s: &'a BStr) -> Cow<'a, BStr>{\n            Cow::Borrowed(s)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::convert::From<&'a str> for &'a bstr::BStr>::from":["#[inline]\nfn from(s: &'a str) -> &'a BStr{\n            BStr::from_bytes(s.as_bytes())\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::convert::From<std::boxed::Box<[u8]>> for std::boxed::Box<bstr::BStr>>::from":["#[inline]\nfn from(s: Box<[u8]>) -> Box<BStr>{\n            BStr::from_boxed_bytes(s)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::convert::From<std::boxed::Box<bstr::BStr>> for std::boxed::Box<[u8]>>::from":["#[inline]\nfn from(s: Box<BStr>) -> Box<[u8]>{\n            BStr::into_boxed_bytes(s)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::default::Default for &'a bstr::BStr>::default":["fn default() -> &'a BStr{\n            BStr::from_bytes(b\"\")\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::default::Default for &'a mut bstr::BStr>::default":["fn default() -> &'a mut BStr{\n            BStr::from_bytes_mut(&mut [])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::fmt::Debug for bstr::BStr>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n            write!(f, \"\\\"\")?;\n            for (s, e, ch) in self.char_indices() {\n                match ch {\n                    '\\0' => write!(f, \"\\\\0\")?,\n                    '\\u{FFFD}' => {\n                        let bytes = self[s..e].as_bytes();\n                        if bytes == b\"\\xEF\\xBF\\xBD\" {\n                            write!(f, \"{}\", ch.escape_debug())?;\n                        } else {\n                            for &b in self[s..e].as_bytes() {\n                                write!(f, r\"\\x{:02X}\", b)?;\n                            }\n                        }\n                    }\n                    // ASCII control characters except \\0, \\n, \\r, \\t\n                    '\\x01'..='\\x08'\n                    | '\\x0b'\n                    | '\\x0c'\n                    | '\\x0e'..='\\x19'\n                    | '\\x7f' => {\n                        write!(f, \"\\\\x{:02x}\", ch as u32)?;\n                    }\n                    '\\n' | '\\r' | '\\t' | _ => {\n                        write!(f, \"{}\", ch.escape_debug())?;\n                    }\n                }\n            }\n            write!(f, \"\\\"\")?;\n            Ok(())\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::fmt::Display for bstr::BStr>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n            /// Write the given bstr (lossily) to the given formatter.\n            fn write_bstr(\n                f: &mut fmt::Formatter,\n                bstr: &BStr,\n            ) -> Result<(), fmt::Error> {\n                for chunk in bstr.utf8_chunks() {\n                    f.write_str(chunk.valid())?;\n                    if !chunk.invalid().is_empty() {\n                        f.write_str(\"\\u{FFFD}\")?;\n                    }\n                }\n                Ok(())\n            }\n\n            /// Write 'num' fill characters to the given formatter.\n            fn write_pads(f: &mut fmt::Formatter, num: usize) -> fmt::Result {\n                let fill = f.fill();\n                for _ in 0..num {\n                    f.write_fmt(format_args!(\"{}\", fill))?;\n                }\n                Ok(())\n            }\n\n            if let Some(align) = f.align() {\n                let width = f.width().unwrap_or(0);\n                let nchars = self.chars().count();\n                let remaining_pads = width.saturating_sub(nchars);\n                match align {\n                    fmt::Alignment::Left => {\n                        write_bstr(f, self)?;\n                        write_pads(f, remaining_pads)?;\n                    }\n                    fmt::Alignment::Right => {\n                        write_pads(f, remaining_pads)?;\n                        write_bstr(f, self)?;\n                    }\n                    fmt::Alignment::Center => {\n                        let half = remaining_pads / 2;\n                        let second_half = if remaining_pads % 2 == 0 {\n                            half\n                        } else {\n                            half + 1\n                        };\n                        write_pads(f, half)?;\n                        write_bstr(f, self)?;\n                        write_pads(f, second_half)?;\n                    }\n                }\n                Ok(())\n            } else {\n                write_bstr(f, self)?;\n                Ok(())\n            }\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::fmt::Display for bstr::BStr>::fmt::write_bstr":["/// Write the given bstr (lossily) to the given formatter.\nfn write_bstr(\n                f: &mut fmt::Formatter,\n                bstr: &BStr,\n            ) -> Result<(), fmt::Error>{\n                for chunk in bstr.utf8_chunks() {\n                    f.write_str(chunk.valid())?;\n                    if !chunk.invalid().is_empty() {\n                        f.write_str(\"\\u{FFFD}\")?;\n                    }\n                }\n                Ok(())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::fmt::Display for bstr::BStr>::fmt::write_pads":["/// Write 'num' fill characters to the given formatter.\nfn write_pads(f: &mut fmt::Formatter, num: usize) -> fmt::Result{\n                let fill = f.fill();\n                for _ in 0..num {\n                    f.write_fmt(format_args!(\"{}\", fill))?;\n                }\n                Ok(())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::DerefMut for bstr::BStr>::deref_mut":["#[inline]\nfn deref_mut(&mut self) -> &mut [u8]{\n            &mut self.bytes\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::Index<std::ops::Range<usize>> for bstr::BStr>::index":["#[inline]\nfn index(&self, r: ops::Range<usize>) -> &BStr{\n            BStr::new(&self.as_bytes()[r.start..r.end])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::Index<std::ops::RangeFrom<usize>> for bstr::BStr>::index":["#[inline]\nfn index(&self, r: ops::RangeFrom<usize>) -> &BStr{\n            BStr::new(&self.as_bytes()[r.start..])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::Index<std::ops::RangeFull> for bstr::BStr>::index":["#[inline]\nfn index(&self, _: ops::RangeFull) -> &BStr{\n            self\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::Index<std::ops::RangeInclusive<usize>> for bstr::BStr>::index":["#[inline]\nfn index(&self, r: ops::RangeInclusive<usize>) -> &BStr{\n            BStr::new(&self.as_bytes()[*r.start()..=*r.end()])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::Index<std::ops::RangeTo<usize>> for bstr::BStr>::index":["#[inline]\nfn index(&self, r: ops::RangeTo<usize>) -> &BStr{\n            BStr::new(&self.as_bytes()[..r.end])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::Index<std::ops::RangeToInclusive<usize>> for bstr::BStr>::index":["#[inline]\nfn index(&self, r: ops::RangeToInclusive<usize>) -> &BStr{\n            BStr::new(&self.as_bytes()[..=r.end])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::Index<usize> for bstr::BStr>::index":["#[inline]\nfn index(&self, idx: usize) -> &u8{\n            &self.as_bytes()[idx]\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::IndexMut<std::ops::Range<usize>> for bstr::BStr>::index_mut":["#[inline]\nfn index_mut(&mut self, r: ops::Range<usize>) -> &mut BStr{\n            BStr::from_bytes_mut(&mut self.bytes[r.start..r.end])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeFrom<usize>> for bstr::BStr>::index_mut":["#[inline]\nfn index_mut(&mut self, r: ops::RangeFrom<usize>) -> &mut BStr{\n            BStr::from_bytes_mut(&mut self.bytes[r.start..])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeFull> for bstr::BStr>::index_mut":["#[inline]\nfn index_mut(&mut self, _: ops::RangeFull) -> &mut BStr{\n            self\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeInclusive<usize>> for bstr::BStr>::index_mut":["#[inline]\nfn index_mut(&mut self, r: ops::RangeInclusive<usize>) -> &mut BStr{\n            BStr::from_bytes_mut(&mut self.bytes[*r.start()..=*r.end()])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeTo<usize>> for bstr::BStr>::index_mut":["#[inline]\nfn index_mut(&mut self, r: ops::RangeTo<usize>) -> &mut BStr{\n            BStr::from_bytes_mut(&mut self.bytes[..r.end])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeToInclusive<usize>> for bstr::BStr>::index_mut":["#[inline]\nfn index_mut(&mut self, r: ops::RangeToInclusive<usize>) -> &mut BStr{\n            BStr::from_bytes_mut(&mut self.bytes[..=r.end])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstr::<impl std::ops::IndexMut<usize> for bstr::BStr>::index_mut":["#[inline]\nfn index_mut(&mut self, idx: usize) -> &mut u8{\n            &mut self.bytes[idx]\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl lazy_static::__Deref for bstring::BString>::deref":["#[inline]\nfn deref(&self) -> &Vec<u8>{\n            &self.bytes\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::borrow::Borrow<bstr::BStr> for bstring::BString>::borrow":["#[inline]\nfn borrow(&self) -> &BStr{\n            self.as_bstr()\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::borrow::ToOwned for bstr::BStr>::to_owned":["#[inline]\nfn to_owned(&self) -> BString{\n            BString::from(self)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::Ord for bstring::BString>::cmp":["#[inline]\nfn cmp(&self, other: &BString) -> Ordering{\n            self.partial_cmp(other).unwrap()\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq for bstring::BString>::eq":["#[inline]\nfn eq(&self, other: &BString) -> bool{\n            &self[..] == &other[..]\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<&'a [u8]> for bstring::BString>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<&'a bstr::BStr> for bstring::BString>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<&'a str> for bstring::BString>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<[u8]> for bstring::BString>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<bstr::BStr> for bstring::BString>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for &'a [u8]>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for &'a bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for &'a str>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for [u8]>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for bstr::BStr>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for std::string::String>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for std::vec::Vec<u8>>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for str>::eq":["#[inline]\nfn eq(&self, other: &$lhs) -> bool{\n                let this: &[u8] = self.as_ref();\n                PartialEq::eq(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<std::string::String> for bstring::BString>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<std::vec::Vec<u8>> for bstring::BString>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialEq<str> for bstring::BString>::eq":["#[inline]\nfn eq(&self, other: &$rhs) -> bool{\n                let other: &[u8] = other.as_ref();\n                PartialEq::eq(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd for bstring::BString>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &BString) -> Option<Ordering>{\n            PartialOrd::partial_cmp(&self.bytes, &other.bytes)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<&'a [u8]> for bstring::BString>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<&'a bstr::BStr> for bstring::BString>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<&'a str> for bstring::BString>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<[u8]> for bstring::BString>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<bstr::BStr> for bstring::BString>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for &'a [u8]>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for &'a bstr::BStr>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for &'a str>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for [u8]>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for bstr::BStr>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for std::string::String>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for std::vec::Vec<u8>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for str>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$lhs) -> Option<Ordering>{\n                let this: &[u8] = self.as_ref();\n                PartialOrd::partial_cmp(this, other.as_bytes())\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<std::string::String> for bstring::BString>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<std::vec::Vec<u8>> for bstring::BString>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::cmp::PartialOrd<str> for bstring::BString>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &$rhs) -> Option<Ordering>{\n                let other: &[u8] = other.as_ref();\n                PartialOrd::partial_cmp(self.as_bytes(), other)\n            }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::convert::AsMut<[u8]> for bstring::BString>::as_mut":["#[inline]\nfn as_mut(&mut self) -> &mut [u8]{\n            &mut self.bytes\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::convert::AsMut<bstr::BStr> for bstring::BString>::as_mut":["#[inline]\nfn as_mut(&mut self) -> &mut BStr{\n            self.as_mut_bstr()\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::convert::AsRef<[u8]> for bstring::BString>::as_ref":["#[inline]\nfn as_ref(&self) -> &[u8]{\n            &self.bytes\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::convert::AsRef<bstr::BStr> for bstring::BString>::as_ref":["#[inline]\nfn as_ref(&self) -> &BStr{\n            self.as_bstr()\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::convert::From<&'a [u8]> for bstring::BString>::from":["#[inline]\nfn from(s: &'a [u8]) -> BString{\n            BString::from(s.to_vec())\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::convert::From<&'a bstr::BStr> for bstring::BString>::from":["#[inline]\nfn from(s: &'a BStr) -> BString{\n            BString::from(s.bytes.to_vec())\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::convert::From<&'a str> for bstring::BString>::from":["#[inline]\nfn from(s: &'a str) -> BString{\n            BString::from(s.as_bytes().to_vec())\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::convert::From<bstring::BString> for std::borrow::Cow<'a, bstr::BStr>>::from":["#[inline]\nfn from(s: BString) -> Cow<'a, BStr>{\n            Cow::Owned(s)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::convert::From<bstring::BString> for std::vec::Vec<u8>>::from":["#[inline]\nfn from(s: BString) -> Vec<u8>{\n            s.bytes\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::convert::From<std::string::String> for bstring::BString>::from":["#[inline]\nfn from(s: String) -> BString{\n            BString::from(s.into_bytes())\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::convert::From<std::vec::Vec<u8>> for bstring::BString>::from":["#[inline]\nfn from(s: Vec<u8>) -> BString{\n            BString { bytes: s }\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::default::Default for bstring::BString>::default":["fn default() -> BString{\n            BString::from(vec![])\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::fmt::Debug for bstring::BString>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n            fmt::Debug::fmt(self.as_bstr(), f)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::fmt::Display for bstring::BString>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n            fmt::Display::fmt(self.as_bstr(), f)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::iter::FromIterator<&'a [u8]> for bstring::BString>::from_iter":["#[inline]\nfn from_iter<T: IntoIterator<Item = &'a [u8]>>(iter: T) -> BString{\n            let mut buf = vec![];\n            for b in iter {\n                buf.push_str(b);\n            }\n            BString::from(buf)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::iter::FromIterator<&'a bstr::BStr> for bstring::BString>::from_iter":["#[inline]\nfn from_iter<T: IntoIterator<Item = &'a BStr>>(iter: T) -> BString{\n            let mut buf = vec![];\n            for b in iter {\n                buf.push_str(b);\n            }\n            BString::from(buf)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::iter::FromIterator<&'a str> for bstring::BString>::from_iter":["#[inline]\nfn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> BString{\n            let mut buf = vec![];\n            for b in iter {\n                buf.push_str(b);\n            }\n            BString::from(buf)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::iter::FromIterator<bstring::BString> for bstring::BString>::from_iter":["#[inline]\nfn from_iter<T: IntoIterator<Item = BString>>(iter: T) -> BString{\n            let mut buf = vec![];\n            for b in iter {\n                buf.push_str(b);\n            }\n            BString::from(buf)\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::iter::FromIterator<char> for bstring::BString>::from_iter":["#[inline]\nfn from_iter<T: IntoIterator<Item = char>>(iter: T) -> BString{\n            BString::from(iter.into_iter().collect::<String>())\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::iter::FromIterator<u8> for bstring::BString>::from_iter":["#[inline]\nfn from_iter<T: IntoIterator<Item = u8>>(iter: T) -> BString{\n            BString::from(iter.into_iter().collect::<Vec<u8>>())\n        }","Real(LocalPath(\"src/impls.rs\"))"],"impls::bstring::<impl std::ops::DerefMut for bstring::BString>::deref_mut":["#[inline]\nfn deref_mut(&mut self) -> &mut Vec<u8>{\n            &mut self.bytes\n        }","Real(LocalPath(\"src/impls.rs\"))"],"io::BufReadExt":["/// An extention trait for\n/// [`std::io::BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html)\n/// which provides convenience APIs for dealing with byte strings.\npub trait BufReadExt: io::BufRead {\n    /// Returns an iterator over the lines of this reader, where each line\n    /// is represented as a byte string.\n    ///\n    /// Each item yielded by this iterator is a `io::Result<Vec<u8>>`, where\n    /// an error is yielded if there was a problem reading from the underlying\n    /// reader.\n    ///\n    /// On success, the next line in the iterator is returned. The line does\n    /// *not* contain a trailing `\\n` or `\\r\\n`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::io;\n    ///\n    /// use bstr::io::BufReadExt;\n    ///\n    /// # fn example() -> Result<(), io::Error> {\n    /// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n    ///\n    /// let mut lines = vec![];\n    /// for result in cursor.byte_lines() {\n    ///     let line = result?;\n    ///     lines.push(line);\n    /// }\n    /// assert_eq!(lines.len(), 3);\n    /// assert_eq!(lines[0], \"lorem\".as_bytes());\n    /// assert_eq!(lines[1], \"ipsum\".as_bytes());\n    /// assert_eq!(lines[2], \"dolor\".as_bytes());\n    /// # Ok(()) }; example().unwrap()\n    /// ```\n    fn byte_lines(self) -> ByteLines<Self>\n    where\n        Self: Sized,\n    {\n        ByteLines { buf: self }\n    }\n\n    /// Returns an iterator over byte-terminated records of this reader, where\n    /// each record is represented as a byte string.\n    ///\n    /// Each item yielded by this iterator is a `io::Result<Vec<u8>>`, where\n    /// an error is yielded if there was a problem reading from the underlying\n    /// reader.\n    ///\n    /// On success, the next record in the iterator is returned. The record\n    /// does *not* contain its trailing terminator.\n    ///\n    /// Note that calling `byte_records(b'\\n')` differs from `byte_lines()` in\n    /// that it has no special handling for `\\r`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::io;\n    ///\n    /// use bstr::io::BufReadExt;\n    ///\n    /// # fn example() -> Result<(), io::Error> {\n    /// let cursor = io::Cursor::new(b\"lorem\\x00ipsum\\x00dolor\");\n    ///\n    /// let mut records = vec![];\n    /// for result in cursor.byte_records(b'\\x00') {\n    ///     let record = result?;\n    ///     records.push(record);\n    /// }\n    /// assert_eq!(records.len(), 3);\n    /// assert_eq!(records[0], \"lorem\".as_bytes());\n    /// assert_eq!(records[1], \"ipsum\".as_bytes());\n    /// assert_eq!(records[2], \"dolor\".as_bytes());\n    /// # Ok(()) }; example().unwrap()\n    /// ```\n    fn byte_records(self, terminator: u8) -> ByteRecords<Self>\n    where\n        Self: Sized,\n    {\n        ByteRecords { terminator, buf: self }\n    }\n\n    /// Executes the given closure on each line in the underlying reader.\n    ///\n    /// If the closure returns an error (or if the underlying reader returns an\n    /// error), then iteration is stopped and the error is returned. If false\n    /// is returned, then iteration is stopped and no error is returned.\n    ///\n    /// The closure given is called on exactly the same values as yielded by\n    /// the [`byte_lines`](trait.BufReadExt.html#method.byte_lines)\n    /// iterator. Namely, lines do _not_ contain trailing `\\n` or `\\r\\n` bytes.\n    ///\n    /// This routine is useful for iterating over lines as quickly as\n    /// possible. Namely, a single allocation is reused for each line.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::io;\n    ///\n    /// use bstr::io::BufReadExt;\n    ///\n    /// # fn example() -> Result<(), io::Error> {\n    /// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n    ///\n    /// let mut lines = vec![];\n    /// cursor.for_byte_line(|line| {\n    ///     lines.push(line.to_vec());\n    ///     Ok(true)\n    /// })?;\n    /// assert_eq!(lines.len(), 3);\n    /// assert_eq!(lines[0], \"lorem\".as_bytes());\n    /// assert_eq!(lines[1], \"ipsum\".as_bytes());\n    /// assert_eq!(lines[2], \"dolor\".as_bytes());\n    /// # Ok(()) }; example().unwrap()\n    /// ```\n    fn for_byte_line<F>(self, mut for_each_line: F) -> io::Result<()>\n    where\n        Self: Sized,\n        F: FnMut(&[u8]) -> io::Result<bool>,\n    {\n        self.for_byte_line_with_terminator(|line| {\n            for_each_line(&trim_line_slice(&line))\n        })\n    }\n\n    /// Executes the given closure on each byte-terminated record in the\n    /// underlying reader.\n    ///\n    /// If the closure returns an error (or if the underlying reader returns an\n    /// error), then iteration is stopped and the error is returned. If false\n    /// is returned, then iteration is stopped and no error is returned.\n    ///\n    /// The closure given is called on exactly the same values as yielded by\n    /// the [`byte_records`](trait.BufReadExt.html#method.byte_records)\n    /// iterator. Namely, records do _not_ contain a trailing terminator byte.\n    ///\n    /// This routine is useful for iterating over records as quickly as\n    /// possible. Namely, a single allocation is reused for each record.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::io;\n    ///\n    /// use bstr::io::BufReadExt;\n    ///\n    /// # fn example() -> Result<(), io::Error> {\n    /// let cursor = io::Cursor::new(b\"lorem\\x00ipsum\\x00dolor\");\n    ///\n    /// let mut records = vec![];\n    /// cursor.for_byte_record(b'\\x00', |record| {\n    ///     records.push(record.to_vec());\n    ///     Ok(true)\n    /// })?;\n    /// assert_eq!(records.len(), 3);\n    /// assert_eq!(records[0], \"lorem\".as_bytes());\n    /// assert_eq!(records[1], \"ipsum\".as_bytes());\n    /// assert_eq!(records[2], \"dolor\".as_bytes());\n    /// # Ok(()) }; example().unwrap()\n    /// ```\n    fn for_byte_record<F>(\n        self,\n        terminator: u8,\n        mut for_each_record: F,\n    ) -> io::Result<()>\n    where\n        Self: Sized,\n        F: FnMut(&[u8]) -> io::Result<bool>,\n    {\n        self.for_byte_record_with_terminator(terminator, |chunk| {\n            for_each_record(&trim_record_slice(&chunk, terminator))\n        })\n    }\n\n    /// Executes the given closure on each line in the underlying reader.\n    ///\n    /// If the closure returns an error (or if the underlying reader returns an\n    /// error), then iteration is stopped and the error is returned. If false\n    /// is returned, then iteration is stopped and no error is returned.\n    ///\n    /// Unlike\n    /// [`for_byte_line`](trait.BufReadExt.html#method.for_byte_line),\n    /// the lines given to the closure *do* include the line terminator, if one\n    /// exists.\n    ///\n    /// This routine is useful for iterating over lines as quickly as\n    /// possible. Namely, a single allocation is reused for each line.\n    ///\n    /// This is identical to `for_byte_record_with_terminator` with a\n    /// terminator of `\\n`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::io;\n    ///\n    /// use bstr::io::BufReadExt;\n    ///\n    /// # fn example() -> Result<(), io::Error> {\n    /// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n    ///\n    /// let mut lines = vec![];\n    /// cursor.for_byte_line_with_terminator(|line| {\n    ///     lines.push(line.to_vec());\n    ///     Ok(true)\n    /// })?;\n    /// assert_eq!(lines.len(), 3);\n    /// assert_eq!(lines[0], \"lorem\\n\".as_bytes());\n    /// assert_eq!(lines[1], \"ipsum\\r\\n\".as_bytes());\n    /// assert_eq!(lines[2], \"dolor\".as_bytes());\n    /// # Ok(()) }; example().unwrap()\n    /// ```\n    fn for_byte_line_with_terminator<F>(\n        self,\n        for_each_line: F,\n    ) -> io::Result<()>\n    where\n        Self: Sized,\n        F: FnMut(&[u8]) -> io::Result<bool>,\n    {\n        self.for_byte_record_with_terminator(b'\\n', for_each_line)\n    }\n\n    /// Executes the given closure on each byte-terminated record in the\n    /// underlying reader.\n    ///\n    /// If the closure returns an error (or if the underlying reader returns an\n    /// error), then iteration is stopped and the error is returned. If false\n    /// is returned, then iteration is stopped and no error is returned.\n    ///\n    /// Unlike\n    /// [`for_byte_record`](trait.BufReadExt.html#method.for_byte_record),\n    /// the lines given to the closure *do* include the record terminator, if\n    /// one exists.\n    ///\n    /// This routine is useful for iterating over records as quickly as\n    /// possible. Namely, a single allocation is reused for each record.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::io;\n    ///\n    /// use bstr::B;\n    /// use bstr::io::BufReadExt;\n    ///\n    /// # fn example() -> Result<(), io::Error> {\n    /// let cursor = io::Cursor::new(b\"lorem\\x00ipsum\\x00dolor\");\n    ///\n    /// let mut records = vec![];\n    /// cursor.for_byte_record_with_terminator(b'\\x00', |record| {\n    ///     records.push(record.to_vec());\n    ///     Ok(true)\n    /// })?;\n    /// assert_eq!(records.len(), 3);\n    /// assert_eq!(records[0], B(b\"lorem\\x00\"));\n    /// assert_eq!(records[1], B(\"ipsum\\x00\"));\n    /// assert_eq!(records[2], B(\"dolor\"));\n    /// # Ok(()) }; example().unwrap()\n    /// ```\n    fn for_byte_record_with_terminator<F>(\n        mut self,\n        terminator: u8,\n        mut for_each_record: F,\n    ) -> io::Result<()>\n    where\n        Self: Sized,\n        F: FnMut(&[u8]) -> io::Result<bool>,\n    {\n        let mut bytes = vec![];\n        let mut res = Ok(());\n        let mut consumed = 0;\n        'outer: loop {\n            // Lend out complete record slices from our buffer\n            {\n                let mut buf = self.fill_buf()?;\n                while let Some(index) = buf.find_byte(terminator) {\n                    let (record, rest) = buf.split_at(index + 1);\n                    buf = rest;\n                    consumed += record.len();\n                    match for_each_record(&record) {\n                        Ok(false) => break 'outer,\n                        Err(err) => {\n                            res = Err(err);\n                            break 'outer;\n                        }\n                        _ => (),\n                    }\n                }\n\n                // Copy the final record fragment to our local buffer. This\n                // saves read_until() from re-scanning a buffer we know\n                // contains no remaining terminators.\n                bytes.extend_from_slice(&buf);\n                consumed += buf.len();\n            }\n\n            self.consume(consumed);\n            consumed = 0;\n\n            // N.B. read_until uses a different version of memchr that may\n            // be slower than the memchr crate that bstr uses. However, this\n            // should only run for a fairly small number of records, assuming a\n            // decent buffer size.\n            self.read_until(terminator, &mut bytes)?;\n            if bytes.is_empty() || !for_each_record(&bytes)? {\n                break;\n            }\n            bytes.clear();\n        }\n        self.consume(consumed);\n        res\n    }\n}","Real(LocalPath(\"src/io.rs\"))"],"io::BufReadExt::byte_lines":["/// Returns an iterator over the lines of this reader, where each line\n/// is represented as a byte string.\n///\n/// Each item yielded by this iterator is a `io::Result<Vec<u8>>`, where\n/// an error is yielded if there was a problem reading from the underlying\n/// reader.\n///\n/// On success, the next line in the iterator is returned. The line does\n/// *not* contain a trailing `\\n` or `\\r\\n`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::io;\n///\n/// use bstr::io::BufReadExt;\n///\n/// # fn example() -> Result<(), io::Error> {\n/// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n///\n/// let mut lines = vec![];\n/// for result in cursor.byte_lines() {\n///     let line = result?;\n///     lines.push(line);\n/// }\n/// assert_eq!(lines.len(), 3);\n/// assert_eq!(lines[0], \"lorem\".as_bytes());\n/// assert_eq!(lines[1], \"ipsum\".as_bytes());\n/// assert_eq!(lines[2], \"dolor\".as_bytes());\n/// # Ok(()) }; example().unwrap()\n/// ```\nfn byte_lines(self) -> ByteLines<Self>\n    where\n        Self: Sized,{\n        ByteLines { buf: self }\n    }","Real(LocalPath(\"src/io.rs\"))"],"io::BufReadExt::byte_records":["/// Returns an iterator over byte-terminated records of this reader, where\n/// each record is represented as a byte string.\n///\n/// Each item yielded by this iterator is a `io::Result<Vec<u8>>`, where\n/// an error is yielded if there was a problem reading from the underlying\n/// reader.\n///\n/// On success, the next record in the iterator is returned. The record\n/// does *not* contain its trailing terminator.\n///\n/// Note that calling `byte_records(b'\\n')` differs from `byte_lines()` in\n/// that it has no special handling for `\\r`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::io;\n///\n/// use bstr::io::BufReadExt;\n///\n/// # fn example() -> Result<(), io::Error> {\n/// let cursor = io::Cursor::new(b\"lorem\\x00ipsum\\x00dolor\");\n///\n/// let mut records = vec![];\n/// for result in cursor.byte_records(b'\\x00') {\n///     let record = result?;\n///     records.push(record);\n/// }\n/// assert_eq!(records.len(), 3);\n/// assert_eq!(records[0], \"lorem\".as_bytes());\n/// assert_eq!(records[1], \"ipsum\".as_bytes());\n/// assert_eq!(records[2], \"dolor\".as_bytes());\n/// # Ok(()) }; example().unwrap()\n/// ```\nfn byte_records(self, terminator: u8) -> ByteRecords<Self>\n    where\n        Self: Sized,{\n        ByteRecords { terminator, buf: self }\n    }","Real(LocalPath(\"src/io.rs\"))"],"io::BufReadExt::for_byte_line":["/// Executes the given closure on each line in the underlying reader.\n///\n/// If the closure returns an error (or if the underlying reader returns an\n/// error), then iteration is stopped and the error is returned. If false\n/// is returned, then iteration is stopped and no error is returned.\n///\n/// The closure given is called on exactly the same values as yielded by\n/// the [`byte_lines`](trait.BufReadExt.html#method.byte_lines)\n/// iterator. Namely, lines do _not_ contain trailing `\\n` or `\\r\\n` bytes.\n///\n/// This routine is useful for iterating over lines as quickly as\n/// possible. Namely, a single allocation is reused for each line.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::io;\n///\n/// use bstr::io::BufReadExt;\n///\n/// # fn example() -> Result<(), io::Error> {\n/// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n///\n/// let mut lines = vec![];\n/// cursor.for_byte_line(|line| {\n///     lines.push(line.to_vec());\n///     Ok(true)\n/// })?;\n/// assert_eq!(lines.len(), 3);\n/// assert_eq!(lines[0], \"lorem\".as_bytes());\n/// assert_eq!(lines[1], \"ipsum\".as_bytes());\n/// assert_eq!(lines[2], \"dolor\".as_bytes());\n/// # Ok(()) }; example().unwrap()\n/// ```\nfn for_byte_line<F>(self, mut for_each_line: F) -> io::Result<()>\n    where\n        Self: Sized,\n        F: FnMut(&[u8]) -> io::Result<bool>,{\n        self.for_byte_line_with_terminator(|line| {\n            for_each_line(&trim_line_slice(&line))\n        })\n    }","Real(LocalPath(\"src/io.rs\"))"],"io::BufReadExt::for_byte_line_with_terminator":["/// Executes the given closure on each line in the underlying reader.\n///\n/// If the closure returns an error (or if the underlying reader returns an\n/// error), then iteration is stopped and the error is returned. If false\n/// is returned, then iteration is stopped and no error is returned.\n///\n/// Unlike\n/// [`for_byte_line`](trait.BufReadExt.html#method.for_byte_line),\n/// the lines given to the closure *do* include the line terminator, if one\n/// exists.\n///\n/// This routine is useful for iterating over lines as quickly as\n/// possible. Namely, a single allocation is reused for each line.\n///\n/// This is identical to `for_byte_record_with_terminator` with a\n/// terminator of `\\n`.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::io;\n///\n/// use bstr::io::BufReadExt;\n///\n/// # fn example() -> Result<(), io::Error> {\n/// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n///\n/// let mut lines = vec![];\n/// cursor.for_byte_line_with_terminator(|line| {\n///     lines.push(line.to_vec());\n///     Ok(true)\n/// })?;\n/// assert_eq!(lines.len(), 3);\n/// assert_eq!(lines[0], \"lorem\\n\".as_bytes());\n/// assert_eq!(lines[1], \"ipsum\\r\\n\".as_bytes());\n/// assert_eq!(lines[2], \"dolor\".as_bytes());\n/// # Ok(()) }; example().unwrap()\n/// ```\nfn for_byte_line_with_terminator<F>(\n        self,\n        for_each_line: F,\n    ) -> io::Result<()>\n    where\n        Self: Sized,\n        F: FnMut(&[u8]) -> io::Result<bool>,{\n        self.for_byte_record_with_terminator(b'\\n', for_each_line)\n    }","Real(LocalPath(\"src/io.rs\"))"],"io::BufReadExt::for_byte_record":["/// Executes the given closure on each byte-terminated record in the\n/// underlying reader.\n///\n/// If the closure returns an error (or if the underlying reader returns an\n/// error), then iteration is stopped and the error is returned. If false\n/// is returned, then iteration is stopped and no error is returned.\n///\n/// The closure given is called on exactly the same values as yielded by\n/// the [`byte_records`](trait.BufReadExt.html#method.byte_records)\n/// iterator. Namely, records do _not_ contain a trailing terminator byte.\n///\n/// This routine is useful for iterating over records as quickly as\n/// possible. Namely, a single allocation is reused for each record.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::io;\n///\n/// use bstr::io::BufReadExt;\n///\n/// # fn example() -> Result<(), io::Error> {\n/// let cursor = io::Cursor::new(b\"lorem\\x00ipsum\\x00dolor\");\n///\n/// let mut records = vec![];\n/// cursor.for_byte_record(b'\\x00', |record| {\n///     records.push(record.to_vec());\n///     Ok(true)\n/// })?;\n/// assert_eq!(records.len(), 3);\n/// assert_eq!(records[0], \"lorem\".as_bytes());\n/// assert_eq!(records[1], \"ipsum\".as_bytes());\n/// assert_eq!(records[2], \"dolor\".as_bytes());\n/// # Ok(()) }; example().unwrap()\n/// ```\nfn for_byte_record<F>(\n        self,\n        terminator: u8,\n        mut for_each_record: F,\n    ) -> io::Result<()>\n    where\n        Self: Sized,\n        F: FnMut(&[u8]) -> io::Result<bool>,{\n        self.for_byte_record_with_terminator(terminator, |chunk| {\n            for_each_record(&trim_record_slice(&chunk, terminator))\n        })\n    }","Real(LocalPath(\"src/io.rs\"))"],"io::BufReadExt::for_byte_record_with_terminator":["/// Executes the given closure on each byte-terminated record in the\n/// underlying reader.\n///\n/// If the closure returns an error (or if the underlying reader returns an\n/// error), then iteration is stopped and the error is returned. If false\n/// is returned, then iteration is stopped and no error is returned.\n///\n/// Unlike\n/// [`for_byte_record`](trait.BufReadExt.html#method.for_byte_record),\n/// the lines given to the closure *do* include the record terminator, if\n/// one exists.\n///\n/// This routine is useful for iterating over records as quickly as\n/// possible. Namely, a single allocation is reused for each record.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::io;\n///\n/// use bstr::B;\n/// use bstr::io::BufReadExt;\n///\n/// # fn example() -> Result<(), io::Error> {\n/// let cursor = io::Cursor::new(b\"lorem\\x00ipsum\\x00dolor\");\n///\n/// let mut records = vec![];\n/// cursor.for_byte_record_with_terminator(b'\\x00', |record| {\n///     records.push(record.to_vec());\n///     Ok(true)\n/// })?;\n/// assert_eq!(records.len(), 3);\n/// assert_eq!(records[0], B(b\"lorem\\x00\"));\n/// assert_eq!(records[1], B(\"ipsum\\x00\"));\n/// assert_eq!(records[2], B(\"dolor\"));\n/// # Ok(()) }; example().unwrap()\n/// ```\nfn for_byte_record_with_terminator<F>(\n        mut self,\n        terminator: u8,\n        mut for_each_record: F,\n    ) -> io::Result<()>\n    where\n        Self: Sized,\n        F: FnMut(&[u8]) -> io::Result<bool>,{\n        let mut bytes = vec![];\n        let mut res = Ok(());\n        let mut consumed = 0;\n        'outer: loop {\n            // Lend out complete record slices from our buffer\n            {\n                let mut buf = self.fill_buf()?;\n                while let Some(index) = buf.find_byte(terminator) {\n                    let (record, rest) = buf.split_at(index + 1);\n                    buf = rest;\n                    consumed += record.len();\n                    match for_each_record(&record) {\n                        Ok(false) => break 'outer,\n                        Err(err) => {\n                            res = Err(err);\n                            break 'outer;\n                        }\n                        _ => (),\n                    }\n                }\n\n                // Copy the final record fragment to our local buffer. This\n                // saves read_until() from re-scanning a buffer we know\n                // contains no remaining terminators.\n                bytes.extend_from_slice(&buf);\n                consumed += buf.len();\n            }\n\n            self.consume(consumed);\n            consumed = 0;\n\n            // N.B. read_until uses a different version of memchr that may\n            // be slower than the memchr crate that bstr uses. However, this\n            // should only run for a fairly small number of records, assuming a\n            // decent buffer size.\n            self.read_until(terminator, &mut bytes)?;\n            if bytes.is_empty() || !for_each_record(&bytes)? {\n                break;\n            }\n            bytes.clear();\n        }\n        self.consume(consumed);\n        res\n    }","Real(LocalPath(\"src/io.rs\"))"],"io::ByteLines":["/// An iterator over lines from an instance of\n/// [`std::io::BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html).\n///\n/// This iterator is generally created by calling the\n/// [`byte_lines`](trait.BufReadExt.html#method.byte_lines)\n/// method on the\n/// [`BufReadExt`](trait.BufReadExt.html)\n/// trait.\npub struct ByteLines<B> {\n    buf: B,\n}","Real(LocalPath(\"src/io.rs\"))"],"io::ByteRecords":["/// An iterator over records from an instance of\n/// [`std::io::BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html).\n///\n/// A byte record is any sequence of bytes terminated by a particular byte\n/// chosen by the caller. For example, NUL separated byte strings are said to\n/// be NUL-terminated byte records.\n///\n/// This iterator is generally created by calling the\n/// [`byte_records`](trait.BufReadExt.html#method.byte_records)\n/// method on the\n/// [`BufReadExt`](trait.BufReadExt.html)\n/// trait.\npub struct ByteRecords<B> {\n    buf: B,\n    terminator: u8,\n}","Real(LocalPath(\"src/io.rs\"))"],"io::trim_line":["fn trim_line(line: &mut Vec<u8>){\n    if line.last_byte() == Some(b'\\n') {\n        line.pop_byte();\n        if line.last_byte() == Some(b'\\r') {\n            line.pop_byte();\n        }\n    }\n}","Real(LocalPath(\"src/io.rs\"))"],"io::trim_line_slice":["fn trim_line_slice(mut line: &[u8]) -> &[u8]{\n    if line.last_byte() == Some(b'\\n') {\n        line = &line[..line.len() - 1];\n        if line.last_byte() == Some(b'\\r') {\n            line = &line[..line.len() - 1];\n        }\n    }\n    line\n}","Real(LocalPath(\"src/io.rs\"))"],"io::trim_record":["fn trim_record(record: &mut Vec<u8>, terminator: u8){\n    if record.last_byte() == Some(terminator) {\n        record.pop_byte();\n    }\n}","Real(LocalPath(\"src/io.rs\"))"],"io::trim_record_slice":["fn trim_record_slice(mut record: &[u8], terminator: u8) -> &[u8]{\n    if record.last_byte() == Some(terminator) {\n        record = &record[..record.len() - 1];\n    }\n    record\n}","Real(LocalPath(\"src/io.rs\"))"],"search::prefilter::Freqy":["/// A heuristic frequency based prefilter for searching a single needle.\n///\n/// This prefilter attempts to pick out the byte in a needle that is predicted\n/// to occur least frequently, and search for that using fast vectorized\n/// routines. If a rare enough byte could not be found, then this prefilter's\n/// constructors will return `None`.\n///\n/// This can be combined with `PrefilterState` to dynamically render this\n/// prefilter inert if it proves to ineffective.\npub struct Freqy {\n    /// Whether this prefilter should be used or not.\n    inert: bool,\n    /// The length of the needle we're searching for.\n    needle_len: usize,\n    /// The rarest byte in the needle, according to pre-computed frequency\n    /// analysis.\n    rare1: u8,\n    /// The leftmost offset of the rarest byte in the needle.\n    rare1i: usize,\n    /// The second rarest byte in the needle, according to pre-computed\n    /// frequency analysis. (This may be equivalent to the rarest byte.)\n    ///\n    /// The second rarest byte is used as a type of guard for quickly detecting\n    /// a mismatch after memchr locates an instance of the rarest byte. This\n    /// is a hedge against pathological cases where the pre-computed frequency\n    /// analysis may be off. (But of course, does not prevent *all*\n    /// pathological cases.)\n    rare2: u8,\n    /// The leftmost offset of the second rarest byte in the needle.\n    rare2i: usize,\n}","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::Freqy::find_candidate":["/// Look for a possible occurrence of needle. The position returned\n/// corresponds to the beginning of the occurrence, if one exists.\n///\n/// Callers may assume that this never returns false negatives (i.e., it\n/// never misses an actual occurrence), but must check that the returned\n/// position corresponds to a match. That is, it can return false\n/// positives.\n///\n/// This should only be used when Freqy is constructed for forward\n/// searching.\npub fn find_candidate(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n    ) -> Option<usize>{\n        debug_assert!(!self.inert);\n\n        let mut i = 0;\n        while prestate.is_effective() {\n            // Use a fast vectorized implementation to skip to the next\n            // occurrence of the rarest byte (heuristically chosen) in the\n            // needle.\n            i += match haystack[i..].find_byte(self.rare1) {\n                None => return None,\n                Some(found) => {\n                    prestate.update(found);\n                    found\n                }\n            };\n\n            // If we can't align our first match with the haystack, then a\n            // match is impossible.\n            if i < self.rare1i {\n                i += 1;\n                continue;\n            }\n\n            // Align our rare2 byte with the haystack. A mismatch means that\n            // a match is impossible.\n            let aligned_rare2i = i - self.rare1i + self.rare2i;\n            if haystack.get(aligned_rare2i) != Some(&self.rare2) {\n                i += 1;\n                continue;\n            }\n\n            // We've done what we can. There might be a match here.\n            return Some(i - self.rare1i);\n        }\n        // The only way we get here is if we believe our skipping heuristic\n        // has become ineffective. We're allowed to return false positives,\n        // so return the position at which we advanced to, aligned to the\n        // haystack.\n        Some(i.saturating_sub(self.rare1i))\n    }","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::Freqy::forward":["/// Return search info for the given needle in the forward direction.\npub fn forward(needle: &[u8]) -> Freqy{\n        if needle.is_empty() {\n            return Freqy::inert();\n        }\n\n        // Find the rarest two bytes. Try to make them distinct (but it's not\n        // required).\n        let (mut rare1, mut rare1i) = (needle[0], 0);\n        let (mut rare2, mut rare2i) = (needle[0], 0);\n        if needle.len() >= 2 {\n            rare2 = needle[1];\n            rare2i = 1;\n        }\n        if Freqy::rank(rare2) < Freqy::rank(rare1) {\n            mem::swap(&mut rare1, &mut rare2);\n            mem::swap(&mut rare1i, &mut rare2i);\n        }\n        for (i, b) in needle.bytes().enumerate().skip(2) {\n            if Freqy::rank(b) < Freqy::rank(rare1) {\n                rare2 = rare1;\n                rare2i = rare1i;\n                rare1 = b;\n                rare1i = i;\n            } else if b != rare1 && Freqy::rank(b) < Freqy::rank(rare2) {\n                rare2 = b;\n                rare2i = i;\n            }\n        }\n        if Freqy::rank(rare1) > Freqy::MAX_RANK {\n            return Freqy::inert();\n        }\n        let needle_len = needle.len();\n        Freqy { inert: false, needle_len, rare1, rare1i, rare2, rare2i }\n    }","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::Freqy::inert":["/// Returns a valid but inert prefilter. This is valid for both the forward\n/// and reverse direction.\n///\n/// It is never correct to use an inert prefilter. The results of finding\n/// the next (or previous) candidate are unspecified.\nfn inert() -> Freqy{\n        Freqy {\n            inert: true,\n            needle_len: 0,\n            rare1: 0,\n            rare1i: 0,\n            rare2: 0,\n            rare2i: 0,\n        }\n    }","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::Freqy::prefilter_state":["/// Return a fresh prefilter state that can be used with this prefilter. A\n/// prefilter state is used to track the effectiveness of a prefilter for\n/// speeding up searches. Therefore, the prefilter state should generally\n/// be reused on subsequent searches (such as in an iterator). For searches\n/// on a different haystack, then a new prefilter state should be used.\npub fn prefilter_state(&self) -> PrefilterState{\n        if self.inert {\n            PrefilterState::inert()\n        } else {\n            PrefilterState::new(self.needle_len)\n        }\n    }","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::Freqy::rank":["/// Return the heuristical frequency rank of the given byte. A lower rank\n/// means the byte is believed to occur less frequently.\nfn rank(b: u8) -> usize{\n        BYTE_FREQUENCIES[b as usize] as usize\n    }","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::Freqy::reverse":["/// Return search info for the given needle in the reverse direction.\npub fn reverse(needle: &[u8]) -> Freqy{\n        if needle.is_empty() {\n            return Freqy::inert();\n        }\n\n        // Find the rarest two bytes. Try to make them distinct (but it's not\n        // required). In reverse, the offsets correspond to the number of bytes\n        // from the end of the needle. So `0` is the last byte in the needle.\n        let (mut rare1i, mut rare2i) = (0, 0);\n        if needle.len() >= 2 {\n            rare2i += 1;\n        }\n        let mut rare1 = needle[needle.len() - rare1i - 1];\n        let mut rare2 = needle[needle.len() - rare2i - 1];\n        if Freqy::rank(rare2) < Freqy::rank(rare1) {\n            mem::swap(&mut rare1, &mut rare2);\n            mem::swap(&mut rare1i, &mut rare2i);\n        }\n        for (i, b) in needle.bytes().rev().enumerate().skip(2) {\n            if Freqy::rank(b) < Freqy::rank(rare1) {\n                rare2 = rare1;\n                rare2i = rare1i;\n                rare1 = b;\n                rare1i = i;\n            } else if b != rare1 && Freqy::rank(b) < Freqy::rank(rare2) {\n                rare2 = b;\n                rare2i = i;\n            }\n        }\n        if Freqy::rank(rare1) > Freqy::MAX_RANK {\n            return Freqy::inert();\n        }\n        let needle_len = needle.len();\n        Freqy { inert: false, needle_len, rare1, rare1i, rare2, rare2i }\n    }","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::Freqy::rfind_candidate":["/// Look for a possible occurrence of needle, in reverse, starting from the\n/// end of the given haystack. The position returned corresponds to the\n/// position immediately after the end of the occurrence, if one exists.\n///\n/// Callers may assume that this never returns false negatives (i.e., it\n/// never misses an actual occurrence), but must check that the returned\n/// position corresponds to a match. That is, it can return false\n/// positives.\n///\n/// This should only be used when Freqy is constructed for reverse\n/// searching.\npub fn rfind_candidate(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n    ) -> Option<usize>{\n        debug_assert!(!self.inert);\n\n        let mut i = haystack.len();\n        while prestate.is_effective() {\n            // Use a fast vectorized implementation to skip to the next\n            // occurrence of the rarest byte (heuristically chosen) in the\n            // needle.\n            i = match haystack[..i].rfind_byte(self.rare1) {\n                None => return None,\n                Some(found) => {\n                    prestate.update(i - found);\n                    found\n                }\n            };\n\n            // If we can't align our first match with the haystack, then a\n            // match is impossible.\n            if i + self.rare1i + 1 > haystack.len() {\n                continue;\n            }\n\n            // Align our rare2 byte with the haystack. A mismatch means that\n            // a match is impossible.\n            let aligned = match (i + self.rare1i).checked_sub(self.rare2i) {\n                None => continue,\n                Some(aligned) => aligned,\n            };\n            if haystack.get(aligned) != Some(&self.rare2) {\n                continue;\n            }\n\n            // We've done what we can. There might be a match here.\n            return Some(i + self.rare1i + 1);\n        }\n        // The only way we get here is if we believe our skipping heuristic\n        // has become ineffective. We're allowed to return false positives,\n        // so return the position at which we advanced to, aligned to the\n        // haystack.\n        Some(i + self.rare1i + 1)\n    }","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::PrefilterState":["/// PrefilterState tracks state associated with the effectiveness of a\n/// prefilter. It is used to track how many bytes, on average, are skipped by\n/// the prefilter. If this average dips below a certain threshold over time,\n/// then the state renders the prefilter inert and stops using it.\n///\n/// A prefilter state should be created for each search. (Where creating an\n/// iterator via, e.g., `find_iter`, is treated as a single search.)\npub struct PrefilterState {\n    /// The number of skips that has been executed.\n    skips: usize,\n    /// The total number of bytes that have been skipped.\n    skipped: usize,\n    /// The maximum length of a match. This is used to help determine how many\n    /// bytes on average should be skipped in order for a prefilter to be\n    /// effective.\n    max_match_len: usize,\n    /// Once this heuristic has been deemed ineffective, it will be inert\n    /// throughout the rest of its lifetime. This serves as a cheap way to\n    /// check inertness.\n    inert: bool,\n}","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::PrefilterState::inert":["/// Create a fresh prefilter state that is always inert.\nfn inert() -> PrefilterState{\n        PrefilterState { skips: 0, skipped: 0, max_match_len: 0, inert: true }\n    }","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::PrefilterState::is_effective":["/// Return true if and only if this state indicates that a prefilter is\n/// still effective.\n#[inline]\npub fn is_effective(&mut self) -> bool{\n        if self.inert {\n            return false;\n        }\n        if self.skips < PrefilterState::MIN_SKIPS {\n            return true;\n        }\n        if self.skipped >= PrefilterState::MIN_SKIP_BYTES * self.skips {\n            return true;\n        }\n\n        // We're inert.\n        self.inert = true;\n        false\n    }","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::PrefilterState::new":["/// Create a fresh prefilter state.\npub fn new(max_match_len: usize) -> PrefilterState{\n        if max_match_len == 0 {\n            return PrefilterState::inert();\n        }\n        PrefilterState { skips: 0, skipped: 0, max_match_len, inert: false }\n    }","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::prefilter::PrefilterState::update":["/// Update this state with the number of bytes skipped on the last\n/// invocation of the prefilter.\n#[inline]\npub fn update(&mut self, skipped: usize){\n        self.skips += 1;\n        self.skipped += skipped;\n    }","Real(LocalPath(\"src/search/prefilter.rs\"))"],"search::twoway::Shift":["/// A representation of the amount we're allowed to shift by during Two-Way\n/// search.\n///\n/// When computing a critical factorization of the needle, we find the position\n/// of the critical factorization by finding the needle's maximal (or minimal)\n/// suffix, along with the period of that suffix. It turns out that the period\n/// of that suffix is a lower bound on the period of the needle itself.\n///\n/// This lower bound is equivalent to the actual period of the needle in\n/// some cases. To describe that case, we denote the needle as `x` where\n/// `x = uv` and `v` is the lexicographic maximal suffix of `v`. The lower\n/// bound given here is always the period of `v`, which is `<= period(x)`. The\n/// case where `period(v) == period(x)` occurs when `len(u) < (len(x) / 2)` and\n/// where `u` is a suffix of `v[0..period(v)]`.\n///\n/// This case is important because the search algorithm for when the\n/// periods are equivalent is slightly different than the search algorithm\n/// for when the periods are not equivalent. In particular, when they aren't\n/// equivalent, we know that the period of the needle is no less than half its\n/// length. In this case, we shift by an amount less than or equal to the\n/// period of the needle (determined by the maximum length of the components\n/// of the critical factorization of `x`, i.e., `max(len(u), len(v))`)..\n///\n/// The above two cases are represented by the variants below. Each entails\n/// a different instantiation of the Two-Way search algorithm.\n///\n/// N.B. If we could find a way to compute the exact period in all cases,\n/// then we could collapse this case analysis and simplify the algorithm. The\n/// Two-Way paper suggests this is possible, but more reading is required to\n/// grok why the authors didn't pursue that path.\nenum Shift {\n    Small { period: usize },\n    Large { shift: usize },\n}","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::Shift::forward":["/// Compute the shift for a given needle in the forward direction.\n///\n/// This requires a lower bound on the period and a critical position.\n/// These can be computed by extracting both the minimal and maximal\n/// lexicographic suffixes, and choosing the right-most starting position.\n/// The lower bound on the period is then the period of the chosen suffix.\nfn forward(\n        needle: &[u8],\n        period_lower_bound: usize,\n        critical_pos: usize,\n    ) -> Shift{\n        let large = cmp::max(critical_pos, needle.len() - critical_pos);\n        if critical_pos * 2 >= needle.len() {\n            return Shift::Large { shift: large };\n        }\n\n        let (u, v) = needle.split_at(critical_pos);\n        if !v[..period_lower_bound].ends_with(u) {\n            return Shift::Large { shift: large };\n        }\n        Shift::Small { period: period_lower_bound }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::Shift::reverse":["/// Compute the shift for a given needle in the reverse direction.\n///\n/// This requires a lower bound on the period and a critical position.\n/// These can be computed by extracting both the minimal and maximal\n/// lexicographic suffixes, and choosing the left-most starting position.\n/// The lower bound on the period is then the period of the chosen suffix.\nfn reverse(\n        needle: &[u8],\n        period_lower_bound: usize,\n        critical_pos: usize,\n    ) -> Shift{\n        let large = cmp::max(critical_pos, needle.len() - critical_pos);\n        if (needle.len() - critical_pos) * 2 >= needle.len() {\n            return Shift::Large { shift: large };\n        }\n\n        let (v, u) = needle.split_at(critical_pos);\n        if !v[v.len() - period_lower_bound..].starts_with(u) {\n            return Shift::Large { shift: large };\n        }\n        Shift::Small { period: period_lower_bound }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::Suffix":["/// A suffix extracted from a needle along with its period.\nstruct Suffix {\n    /// The starting position of this suffix.\n    ///\n    /// If this is a forward suffix, then `&bytes[pos..]` can be used. If this\n    /// is a reverse suffix, then `&bytes[..pos]` can be used. That is, for\n    /// forward suffixes, this is an inclusive starting position, where as for\n    /// reverse suffixes, this is an exclusive ending position.\n    pos: usize,\n    /// The period of this suffix.\n    ///\n    /// Note that this is NOT necessarily the period of the string from which\n    /// this suffix comes from. (It is always less than or equal to the period\n    /// of the original string.)\n    period: usize,\n}","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::Suffix::forward":["fn forward(needle: &[u8], kind: SuffixKind) -> Suffix{\n        debug_assert!(!needle.is_empty());\n\n        // suffix represents our maximal (or minimal) suffix, along with\n        // its period.\n        let mut suffix = Suffix { pos: 0, period: 1 };\n        // The start of a suffix in `needle` that we are considering as a\n        // more maximal (or minimal) suffix than what's in `suffix`.\n        let mut candidate_start = 1;\n        // The current offset of our suffixes that we're comparing.\n        //\n        // When the characters at this offset are the same, then we mush on\n        // to the next position since no decision is possible. When the\n        // candidate's character is greater (or lesser) than the corresponding\n        // character than our current maximal (or minimal) suffix, then the\n        // current suffix is changed over to the candidate and we restart our\n        // search. Otherwise, the candidate suffix is no good and we restart\n        // our search on the next candidate.\n        //\n        // The three cases above correspond to the three cases in the loop\n        // below.\n        let mut offset = 0;\n\n        while candidate_start + offset < needle.len() {\n            let current = needle[suffix.pos + offset];\n            let candidate = needle[candidate_start + offset];\n            match kind.cmp(current, candidate) {\n                SuffixOrdering::Accept => {\n                    suffix = Suffix { pos: candidate_start, period: 1 };\n                    candidate_start += 1;\n                    offset = 0;\n                }\n                SuffixOrdering::Skip => {\n                    candidate_start += offset + 1;\n                    offset = 0;\n                    suffix.period = candidate_start - suffix.pos;\n                }\n                SuffixOrdering::Push => {\n                    if offset + 1 == suffix.period {\n                        candidate_start += suffix.period;\n                        offset = 0;\n                    } else {\n                        offset += 1;\n                    }\n                }\n            }\n        }\n        suffix\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::Suffix::reverse":["fn reverse(needle: &[u8], kind: SuffixKind) -> Suffix{\n        debug_assert!(!needle.is_empty());\n\n        // See the comments in `forward` for how this works.\n        let mut suffix = Suffix { pos: needle.len(), period: 1 };\n        if needle.len() == 1 {\n            return suffix;\n        }\n        let mut candidate_start = needle.len() - 1;\n        let mut offset = 0;\n\n        while offset < candidate_start {\n            let current = needle[suffix.pos - offset - 1];\n            let candidate = needle[candidate_start - offset - 1];\n            match kind.cmp(current, candidate) {\n                SuffixOrdering::Accept => {\n                    suffix = Suffix { pos: candidate_start, period: 1 };\n                    candidate_start -= 1;\n                    offset = 0;\n                }\n                SuffixOrdering::Skip => {\n                    candidate_start -= offset + 1;\n                    offset = 0;\n                    suffix.period = suffix.pos - candidate_start;\n                }\n                SuffixOrdering::Push => {\n                    if offset + 1 == suffix.period {\n                        candidate_start -= suffix.period;\n                        offset = 0;\n                    } else {\n                        offset += 1;\n                    }\n                }\n            }\n        }\n        suffix\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::SuffixKind":["/// The kind of suffix to extract.\nenum SuffixKind {\n    /// Extract the smallest lexicographic suffix from a string.\n    ///\n    /// Technically, this doesn't actually pick the smallest lexicographic\n    /// suffix. e.g., Given the choice between `a` and `aa`, this will choose\n    /// the latter over the former, even though `a < aa`. The reasoning for\n    /// this isn't clear from the paper, but it still smells like a minimal\n    /// suffix.\n    Minimal,\n    /// Extract the largest lexicographic suffix from a string.\n    ///\n    /// Unlike `Minimal`, this really does pick the maximum suffix. e.g., Given\n    /// the choice between `z` and `zz`, this will choose the latter over the\n    /// former.\n    Maximal,\n}","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::SuffixKind::cmp":["/// Returns true if and only if the given candidate byte indicates that\n/// it should replace the current suffix as the maximal (or minimal)\n/// suffix.\nfn cmp(self, current: u8, candidate: u8) -> SuffixOrdering{\n        use self::SuffixOrdering::*;\n\n        match self {\n            SuffixKind::Minimal if candidate < current => Accept,\n            SuffixKind::Minimal if candidate > current => Skip,\n            SuffixKind::Minimal => Push,\n            SuffixKind::Maximal if candidate > current => Accept,\n            SuffixKind::Maximal if candidate < current => Skip,\n            SuffixKind::Maximal => Push,\n        }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::SuffixOrdering":["/// The result of comparing corresponding bytes between two suffixes.\nenum SuffixOrdering {\n    /// This occurs when the given candidate byte indicates that the candidate\n    /// suffix is better than the current maximal (or minimal) suffix. That is,\n    /// the current candidate suffix should supplant the current maximal (or\n    /// minimal) suffix.\n    Accept,\n    /// This occurs when the given candidate byte excludes the candidate suffix\n    /// from being better than the current maximal (or minimal) suffix. That\n    /// is, the current candidate suffix should be dropped and the next one\n    /// should be considered.\n    Skip,\n    /// This occurs when no decision to accept or skip the candidate suffix\n    /// can be made, e.g., when corresponding bytes are equivalent. In this\n    /// case, the next corresponding bytes should be compared.\n    Push,\n}","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay":["/// An implementation of the TwoWay substring search algorithm, with heuristics\n/// for accelerating search based on frequency analysis.\n///\n/// This searcher supports forward and reverse search, although not\n/// simultaneously. It runs in O(n + m) time and O(1) space, where\n/// `n ~ len(needle)` and `m ~ len(haystack)`.\n///\n/// The implementation here roughly matches that which was developed by\n/// Crochemore and Perrin in their 1991 paper \"Two-way string-matching.\" The\n/// only change in this implementation is the use of zero-based indices and\n/// the addition of heuristics for a fast skip loop. That is, this will detect\n/// bytes that are believed to be rare in the needle and use fast vectorized\n/// instructions to find their occurrences quickly. The Two-Way algorithm is\n/// then used to confirm whether a match at that location occurred.\n///\n/// The heuristic for fast skipping is automatically shut off if it's\n/// detected to be ineffective at search time. Generally, this only occurs in\n/// pathological cases. But this is generally necessary in order to preserve\n/// a `O(n + m)` time bound.\n///\n/// The code below is fairly complex and not obviously correct at all. It's\n/// likely necessary to read the Two-Way paper cited above in order to fully\n/// grok this code.\npub struct TwoWay<'b> {\n    /// The needle that we're looking for.\n    needle: CowBytes<'b>,\n    /// An implementation of a fast skip loop based on hard-coded frequency\n    /// data. This is only used when conditions are deemed favorable.\n    freqy: Freqy,\n    /// A critical position in needle. Specifically, this position corresponds\n    /// to beginning of either the minimal or maximal suffix in needle. (N.B.\n    /// See SuffixType below for why \"minimal\" isn't quite the correct word\n    /// here.)\n    ///\n    /// This is the position at which every search begins. Namely, search\n    /// starts by scanning text to the right of this position, and only if\n    /// there's a match does the text to the left of this position get scanned.\n    critical_pos: usize,\n    /// The amount we shift by in the Two-Way search algorithm. This\n    /// corresponds to the \"small period\" and \"large period\" cases.\n    shift: Shift,\n}","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::find":["/// Find the position of the first occurrence of this searcher's needle in\n/// the given haystack. If one does not exist, then return None.\n///\n/// This will automatically initialize prefilter state. This should only\n/// be used for one-off searches.\npub fn find(&self, haystack: &[u8]) -> Option<usize>{\n        self.find_with(&mut self.prefilter_state(), haystack)\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::find_large":["#[inline(never)]\nfn find_large(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n        shift: usize,\n    ) -> Option<usize>{\n        if prestate.is_effective() {\n            self.find_large_imp(prestate, true, haystack, shift)\n        } else {\n            self.find_large_imp(prestate, false, haystack, shift)\n        }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::find_large_imp":["#[inline(always)]\nfn find_large_imp(\n        &self,\n        prestate: &mut PrefilterState,\n        prefilter: bool,\n        haystack: &[u8],\n        shift: usize,\n    ) -> Option<usize>{\n        let needle = self.needle.as_slice();\n        let mut pos = 0;\n        while pos + needle.len() <= haystack.len() {\n            let mut i = self.critical_pos;\n            if prefilter && prestate.is_effective() {\n                match self.freqy.find_candidate(prestate, &haystack[pos..]) {\n                    None => return None,\n                    Some(found) => {\n                        pos += found;\n                        if pos + needle.len() > haystack.len() {\n                            return None;\n                        }\n                    }\n                }\n            }\n            while i < needle.len() && needle[i] == haystack[pos + i] {\n                i += 1;\n            }\n            if i < needle.len() {\n                pos += i - self.critical_pos + 1;\n            } else {\n                let mut j = self.critical_pos;\n                while j > 0 && needle[j] == haystack[pos + j] {\n                    j -= 1;\n                }\n                if j == 0 && needle[0] == haystack[pos] {\n                    return Some(pos);\n                }\n                pos += shift;\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::find_small":["#[inline(never)]\nfn find_small(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n        period: usize,\n    ) -> Option<usize>{\n        if prestate.is_effective() {\n            self.find_small_imp(prestate, true, haystack, period)\n        } else {\n            self.find_small_imp(prestate, false, haystack, period)\n        }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::find_small_imp":["#[inline(always)]\nfn find_small_imp(\n        &self,\n        prestate: &mut PrefilterState,\n        prefilter: bool,\n        haystack: &[u8],\n        period: usize,\n    ) -> Option<usize>{\n        let needle = self.needle.as_slice();\n        let mut pos = 0;\n        let mut shift = 0;\n        while pos + needle.len() <= haystack.len() {\n            let mut i = cmp::max(self.critical_pos, shift);\n            if prefilter && prestate.is_effective() {\n                match self.freqy.find_candidate(prestate, &haystack[pos..]) {\n                    None => return None,\n                    Some(found) => {\n                        shift = 0;\n                        i = self.critical_pos;\n                        pos += found;\n                        if pos + needle.len() > haystack.len() {\n                            return None;\n                        }\n                    }\n                }\n            }\n            while i < needle.len() && needle[i] == haystack[pos + i] {\n                i += 1;\n            }\n            if i < needle.len() {\n                pos += i - self.critical_pos + 1;\n                shift = 0;\n            } else {\n                let mut j = self.critical_pos;\n                while j > shift && needle[j] == haystack[pos + j] {\n                    j -= 1;\n                }\n                if j <= shift && needle[shift] == haystack[pos + shift] {\n                    return Some(pos);\n                }\n                pos += period;\n                shift = needle.len() - period;\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::find_with":["/// Find the position of the first occurrence of this searcher's needle in\n/// the given haystack. If one does not exist, then return None.\n///\n/// This accepts prefilter state that is useful when using the same\n/// searcher multiple times, such as in an iterator.\npub fn find_with(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n    ) -> Option<usize>{\n        if self.needle.is_empty() {\n            return Some(0);\n        } else if haystack.len() < self.needle.len() {\n            return None;\n        } else if self.needle.len() == 1 {\n            return haystack.find_byte(self.needle[0]);\n        }\n        match self.shift {\n            Shift::Small { period } => {\n                self.find_small(prestate, haystack, period)\n            }\n            Shift::Large { shift } => {\n                self.find_large(prestate, haystack, shift)\n            }\n        }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::forward":["/// Create a searcher that uses the Two-Way algorithm by searching forwards\n/// through any haystack.\npub fn forward(needle: &'b [u8]) -> TwoWay<'b>{\n        let freqy = Freqy::forward(needle);\n        if needle.is_empty() {\n            return TwoWay {\n                needle: CowBytes::new(needle),\n                freqy,\n                critical_pos: 0,\n                shift: Shift::Large { shift: 0 },\n            };\n        }\n\n        let min_suffix = Suffix::forward(needle, SuffixKind::Minimal);\n        let max_suffix = Suffix::forward(needle, SuffixKind::Maximal);\n        let (period_lower_bound, critical_pos) =\n            if min_suffix.pos > max_suffix.pos {\n                (min_suffix.period, min_suffix.pos)\n            } else {\n                (max_suffix.period, max_suffix.pos)\n            };\n        let shift = Shift::forward(needle, period_lower_bound, critical_pos);\n        let needle = CowBytes::new(needle);\n        TwoWay { needle, freqy, critical_pos, shift }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::into_owned":["/// Convert this searched into an owned version, where the needle is\n/// copied if it isn't already owned.\n#[cfg(feature = \"std\")]\npub fn into_owned(self) -> TwoWay<'static>{\n        TwoWay {\n            needle: self.needle.into_owned(),\n            freqy: self.freqy,\n            critical_pos: self.critical_pos,\n            shift: self.shift,\n        }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::needle":["/// Return the needle used by this searcher.\npub fn needle(&self) -> &[u8]{\n        self.needle.as_slice()\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::prefilter_state":["/// Return a fresh prefilter state that can be used with this searcher.\n/// A prefilter state is used to track the effectiveness of a searcher's\n/// prefilter for speeding up searches. Therefore, the prefilter state\n/// should generally be reused on subsequent searches (such as in an\n/// iterator). For searches on a different haystack, then a new prefilter\n/// state should be used.\n///\n/// This always initializes a valid prefilter state even if this searcher\n/// does not have a prefilter enabled.\npub fn prefilter_state(&self) -> PrefilterState{\n        self.freqy.prefilter_state()\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::reverse":["/// Create a searcher that uses the Two-Way algorithm by searching in\n/// reverse through any haystack.\npub fn reverse(needle: &'b [u8]) -> TwoWay<'b>{\n        let freqy = Freqy::reverse(needle);\n        if needle.is_empty() {\n            return TwoWay {\n                needle: CowBytes::new(needle),\n                freqy,\n                critical_pos: 0,\n                shift: Shift::Large { shift: 0 },\n            };\n        }\n\n        let min_suffix = Suffix::reverse(needle, SuffixKind::Minimal);\n        let max_suffix = Suffix::reverse(needle, SuffixKind::Maximal);\n        let (period_lower_bound, critical_pos) =\n            if min_suffix.pos < max_suffix.pos {\n                (min_suffix.period, min_suffix.pos)\n            } else {\n                (max_suffix.period, max_suffix.pos)\n            };\n        let shift = Shift::reverse(needle, period_lower_bound, critical_pos);\n        let needle = CowBytes::new(needle);\n        TwoWay { needle, freqy, critical_pos, shift }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::rfind":["/// Find the position of the last occurrence of this searcher's needle\n/// in the given haystack. If one does not exist, then return None.\n///\n/// This will automatically initialize prefilter state. This should only\n/// be used for one-off searches.\npub fn rfind(&self, haystack: &[u8]) -> Option<usize>{\n        self.rfind_with(&mut self.prefilter_state(), haystack)\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::rfind_large":["#[inline(never)]\nfn rfind_large(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n        shift: usize,\n    ) -> Option<usize>{\n        if prestate.is_effective() {\n            self.rfind_large_imp(prestate, true, haystack, shift)\n        } else {\n            self.rfind_large_imp(prestate, false, haystack, shift)\n        }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::rfind_large_imp":["#[inline(always)]\nfn rfind_large_imp(\n        &self,\n        prestate: &mut PrefilterState,\n        prefilter: bool,\n        haystack: &[u8],\n        shift: usize,\n    ) -> Option<usize>{\n        let needle = &*self.needle;\n        let nlen = needle.len();\n        let mut pos = haystack.len();\n        while pos >= nlen {\n            if prefilter && prestate.is_effective() {\n                match self.freqy.rfind_candidate(prestate, &haystack[..pos]) {\n                    None => return None,\n                    Some(found) => {\n                        pos = found;\n                        if pos < nlen {\n                            return None;\n                        }\n                    }\n                }\n            }\n\n            let mut i = self.critical_pos;\n            while i > 0 && needle[i - 1] == haystack[pos - nlen + i - 1] {\n                i -= 1;\n            }\n            if i > 0 || needle[0] != haystack[pos - nlen] {\n                pos -= self.critical_pos - i + 1;\n            } else {\n                let mut j = self.critical_pos;\n                while j < nlen && needle[j] == haystack[pos - nlen + j] {\n                    j += 1;\n                }\n                if j == nlen {\n                    return Some(pos - nlen);\n                }\n                pos -= shift;\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::rfind_small":["#[inline(never)]\nfn rfind_small(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n        period: usize,\n    ) -> Option<usize>{\n        if prestate.is_effective() {\n            self.rfind_small_imp(prestate, true, haystack, period)\n        } else {\n            self.rfind_small_imp(prestate, false, haystack, period)\n        }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::rfind_small_imp":["#[inline(always)]\nfn rfind_small_imp(\n        &self,\n        prestate: &mut PrefilterState,\n        prefilter: bool,\n        haystack: &[u8],\n        period: usize,\n    ) -> Option<usize>{\n        let needle = &*self.needle;\n        let nlen = needle.len();\n        let mut pos = haystack.len();\n        let mut shift = nlen;\n        while pos >= nlen {\n            let mut i = cmp::min(self.critical_pos, shift);\n            if prefilter && prestate.is_effective() {\n                match self.freqy.rfind_candidate(prestate, &haystack[..pos]) {\n                    None => return None,\n                    Some(found) => {\n                        shift = nlen;\n                        i = self.critical_pos;\n                        pos = found;\n                        if pos < nlen {\n                            return None;\n                        }\n                    }\n                }\n            }\n            while i > 0 && needle[i - 1] == haystack[pos - nlen + i - 1] {\n                i -= 1;\n            }\n            if i > 0 || needle[0] != haystack[pos - nlen] {\n                pos -= self.critical_pos - i + 1;\n                shift = nlen;\n            } else {\n                let mut j = self.critical_pos;\n                while j < shift && needle[j] == haystack[pos - nlen + j] {\n                    j += 1;\n                }\n                if j == shift {\n                    return Some(pos - nlen);\n                }\n                pos -= period;\n                shift = period;\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"search::twoway::TwoWay::<'b>::rfind_with":["/// Find the position of the last occurrence of this searcher's needle\n/// in the given haystack. If one does not exist, then return None.\n///\n/// This accepts prefilter state that is useful when using the same\n/// searcher multiple times, such as in an iterator.\npub fn rfind_with(\n        &self,\n        prestate: &mut PrefilterState,\n        haystack: &[u8],\n    ) -> Option<usize>{\n        if self.needle.is_empty() {\n            return Some(haystack.len());\n        } else if haystack.len() < self.needle.len() {\n            return None;\n        } else if self.needle.len() == 1 {\n            return haystack.rfind_byte(self.needle[0]);\n        }\n        match self.shift {\n            Shift::Small { period } => {\n                self.rfind_small(prestate, haystack, period)\n            }\n            Shift::Large { shift } => {\n                self.rfind_large(prestate, haystack, shift)\n            }\n        }\n    }","Real(LocalPath(\"src/search/twoway.rs\"))"],"unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD":["#[allow(missing_copy_implementations)]\n#[allow(non_camel_case_types)]\n#[allow(dead_code)]\n}\n        #[doc(hidden)]\n        $($vis)* static $N: $N = $N {__private_field: ()};\n    };\n    () => ()\n}\n\n#[macro_export(local_inner_macros)]\nmacro_rules! lazy_static {\n    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        // use `()` to explicitly forward the information about private items\n        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);\n    };\n    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        __lazy_static_internal!($(#[$attr])* (pub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV":["#[allow(missing_copy_implementations)]\n#[allow(non_camel_case_types)]\n#[allow(dead_code)]\n}\n        #[doc(hidden)]\n        $($vis)* static $N: $N = $N {__private_field: ()};\n    };\n    () => ()\n}\n\n#[macro_export(local_inner_macros)]\nmacro_rules! lazy_static {\n    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        // use `()` to explicitly forward the information about private items\n        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);\n    };\n    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        __lazy_static_internal!($(#[$attr])* (pub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV":["#[allow(missing_copy_implementations)]\n#[allow(non_camel_case_types)]\n#[allow(dead_code)]\n}\n        #[doc(hidden)]\n        $($vis)* static $N: $N = $N {__private_field: ()};\n    };\n    () => ()\n}\n\n#[macro_export(local_inner_macros)]\nmacro_rules! lazy_static {\n    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        // use `()` to explicitly forward the information about private items\n        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);\n    };\n    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        __lazy_static_internal!($(#[$attr])* (pub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD":["#[allow(missing_copy_implementations)]\n#[allow(non_camel_case_types)]\n#[allow(dead_code)]\n}\n        #[doc(hidden)]\n        $($vis)* static $N: $N = $N {__private_field: ()};\n    };\n    () => ()\n}\n\n#[macro_export(local_inner_macros)]\nmacro_rules! lazy_static {\n    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        // use `()` to explicitly forward the information about private items\n        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);\n    };\n    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        __lazy_static_internal!($(#[$attr])* (pub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD":["#[allow(missing_copy_implementations)]\n#[allow(non_camel_case_types)]\n#[allow(dead_code)]\n}\n        #[doc(hidden)]\n        $($vis)* static $N: $N = $N {__private_field: ()};\n    };\n    () => ()\n}\n\n#[macro_export(local_inner_macros)]\nmacro_rules! lazy_static {\n    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        // use `()` to explicitly forward the information about private items\n        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);\n    };\n    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        __lazy_static_internal!($(#[$attr])* (pub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD":["#[allow(missing_copy_implementations)]\n#[allow(non_camel_case_types)]\n#[allow(dead_code)]\n}\n        #[doc(hidden)]\n        $($vis)* static $N: $N = $N {__private_field: ()};\n    };\n    () => ()\n}\n\n#[macro_export(local_inner_macros)]\nmacro_rules! lazy_static {\n    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        // use `()` to explicitly forward the information about private items\n        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);\n    };\n    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        __lazy_static_internal!($(#[$attr])* (pub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV":["#[allow(missing_copy_implementations)]\n#[allow(non_camel_case_types)]\n#[allow(dead_code)]\n}\n        #[doc(hidden)]\n        $($vis)* static $N: $N = $N {__private_field: ()};\n    };\n    () => ()\n}\n\n#[macro_export(local_inner_macros)]\nmacro_rules! lazy_static {\n    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        // use `()` to explicitly forward the information about private items\n        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);\n    };\n    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        __lazy_static_internal!($(#[$attr])* (pub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"unicode::fsm::word_break_fwd::WORD_BREAK_FWD":["#[allow(missing_copy_implementations)]\n#[allow(non_camel_case_types)]\n#[allow(dead_code)]\n}\n        #[doc(hidden)]\n        $($vis)* static $N: $N = $N {__private_field: ()};\n    };\n    () => ()\n}\n\n#[macro_export(local_inner_macros)]\nmacro_rules! lazy_static {\n    ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        // use `()` to explicitly forward the information about private items\n        __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);\n    };\n    ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) => {\n        __lazy_static_internal!($(#[$attr])* (pub","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"unicode::grapheme::GraphemeIndices":["/// An iterator over grapheme clusters in a byte string and their byte index\n/// positions.\n///\n/// This iterator is typically constructed by\n/// [`ByteSlice::grapheme_indices`](trait.ByteSlice.html#method.grapheme_indices).\n///\n/// Unicode defines a grapheme cluster as an *approximation* to a single user\n/// visible character. A grapheme cluster, or just \"grapheme,\" is made up of\n/// one or more codepoints. For end user oriented tasks, one should generally\n/// prefer using graphemes instead of [`Chars`](struct.Chars.html), which\n/// always yields one codepoint at a time.\n///\n/// Since graphemes are made up of one or more codepoints, this iterator\n/// yields `&str` elements (along with their start and end byte offsets).\n/// When invalid UTF-8 is encountered, replacement codepoints are\n/// [substituted](index.html#handling-of-invalid-utf-8). Because of this, the\n/// indices yielded by this iterator may not correspond to the length of the\n/// grapheme cluster yielded with those indices. For example, when this\n/// iterator encounters `\\xFF` in the byte string, then it will yield a pair\n/// of indices ranging over a single byte, but will provide an `&str`\n/// equivalent to `\"\\u{FFFD}\"`, which is three bytes in length. However, when\n/// given only valid UTF-8, then all indices are in exact correspondence with\n/// their paired grapheme cluster.\n///\n/// This iterator can be used in reverse. When reversed, exactly the same\n/// set of grapheme clusters are yielded, but in reverse order.\n///\n/// This iterator only yields *extended* grapheme clusters, in accordance with\n/// [UAX #29](https://www.unicode.org/reports/tr29/tr29-33.html#Grapheme_Cluster_Boundaries).\npub struct GraphemeIndices<'a> {\n    bs: &'a [u8],\n    forward_index: usize,\n    reverse_index: usize,\n}","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"unicode::grapheme::GraphemeIndices::<'a>::as_bytes":["/// View the underlying data as a subslice of the original data.\n///\n/// The slice returned has the same lifetime as the original slice, and so\n/// the iterator can continue to be used while this exists.\n///\n/// # Examples\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut it = b\"abc\".grapheme_indices();\n///\n/// assert_eq!(b\"abc\", it.as_bytes());\n/// it.next();\n/// assert_eq!(b\"bc\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\"\", it.as_bytes());\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &'a [u8]{\n        self.bs\n    }","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"unicode::grapheme::GraphemeIndices::<'a>::new":["pub(crate) fn new(bs: &'a [u8]) -> GraphemeIndices<'a>{\n        GraphemeIndices { bs: bs, forward_index: 0, reverse_index: bs.len() }\n    }","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"unicode::grapheme::Graphemes":["/// An iterator over grapheme clusters in a byte string.\n///\n/// This iterator is typically constructed by\n/// [`ByteSlice::graphemes`](trait.ByteSlice.html#method.graphemes).\n///\n/// Unicode defines a grapheme cluster as an *approximation* to a single user\n/// visible character. A grapheme cluster, or just \"grapheme,\" is made up of\n/// one or more codepoints. For end user oriented tasks, one should generally\n/// prefer using graphemes instead of [`Chars`](struct.Chars.html), which\n/// always yields one codepoint at a time.\n///\n/// Since graphemes are made up of one or more codepoints, this iterator yields\n/// `&str` elements. When invalid UTF-8 is encountered, replacement codepoints\n/// are [substituted](index.html#handling-of-invalid-utf-8).\n///\n/// This iterator can be used in reverse. When reversed, exactly the same\n/// set of grapheme clusters are yielded, but in reverse order.\n///\n/// This iterator only yields *extended* grapheme clusters, in accordance with\n/// [UAX #29](https://www.unicode.org/reports/tr29/tr29-33.html#Grapheme_Cluster_Boundaries).\npub struct Graphemes<'a> {\n    bs: &'a [u8],\n}","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"unicode::grapheme::Graphemes::<'a>::as_bytes":["/// View the underlying data as a subslice of the original data.\n///\n/// The slice returned has the same lifetime as the original slice, and so\n/// the iterator can continue to be used while this exists.\n///\n/// # Examples\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut it = b\"abc\".graphemes();\n///\n/// assert_eq!(b\"abc\", it.as_bytes());\n/// it.next();\n/// assert_eq!(b\"bc\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\"\", it.as_bytes());\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &'a [u8]{\n        self.bs\n    }","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"unicode::grapheme::Graphemes::<'a>::new":["pub(crate) fn new(bs: &'a [u8]) -> Graphemes<'a>{\n        Graphemes { bs }\n    }","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"unicode::grapheme::adjust_rev_for_regional_indicator":["/// Return the correct offset for the next grapheme decoded at the end of the\n/// given byte string, where `i` is the initial guess. In particular,\n/// `&bs[i..]` represents the candidate grapheme.\n///\n/// `i` is returned by this function in all cases except when `&bs[i..]` is\n/// a pair of regional indicator codepoints. In that case, if an odd number of\n/// additional regional indicator codepoints precedes `i`, then `i` is\n/// adjusted such that it points to only a single regional indicator.\n///\n/// This \"fixing\" is necessary to handle the requirement that a break cannot\n/// occur between regional indicators where it would cause an odd number of\n/// regional indicators to exist before the break from the *start* of the\n/// string. A reverse regex cannot detect this case easily without look-around.\nfn adjust_rev_for_regional_indicator(mut bs: &[u8], i: usize) -> usize{\n    // All regional indicators use a 4 byte encoding, and we only care about\n    // the case where we found a pair of regional indicators.\n    if bs.len() - i != 8 {\n        return i;\n    }\n    // Count all contiguous occurrences of regional indicators. If there's an\n    // even number of them, then we can accept the pair we found. Otherwise,\n    // we can only take one of them.\n    //\n    // FIXME: This is quadratic in the worst case, e.g., a string of just\n    // regional indicator codepoints. A fix probably requires refactoring this\n    // code a bit such that we don't rescan regional indicators.\n    let mut count = 0;\n    while let Some(start) = REGIONAL_INDICATOR_REV.rfind(bs) {\n        bs = &bs[..start];\n        count += 1;\n    }\n    if count % 2 == 0 {\n        i\n    } else {\n        i + 4\n    }\n}","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"unicode::grapheme::decode_grapheme":["/// Decode a grapheme from the given byte string.\n///\n/// This returns the resulting grapheme (which may be a Unicode replacement\n/// codepoint if invalid UTF-8 was found), along with the number of bytes\n/// decoded in the byte string. The number of bytes decoded may not be the\n/// same as the length of grapheme in the case where invalid UTF-8 is found.\npub fn decode_grapheme(bs: &[u8]) -> (&str, usize){\n    if bs.is_empty() {\n        (\"\", 0)\n    } else if let Some(end) = GRAPHEME_BREAK_FWD.find(bs) {\n        // Safe because a match can only occur for valid UTF-8.\n        let grapheme = unsafe { bs[..end].to_str_unchecked() };\n        (grapheme, grapheme.len())\n    } else {\n        const INVALID: &'static str = \"\\u{FFFD}\";\n        // No match on non-empty bytes implies we found invalid UTF-8.\n        let (_, size) = utf8::decode_lossy(bs);\n        (INVALID, size)\n    }\n}","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"unicode::grapheme::decode_last_grapheme":["fn decode_last_grapheme(bs: &[u8]) -> (&str, usize){\n    if bs.is_empty() {\n        (\"\", 0)\n    } else if let Some(mut start) = GRAPHEME_BREAK_REV.rfind(bs) {\n        start = adjust_rev_for_regional_indicator(bs, start);\n        // Safe because a match can only occur for valid UTF-8.\n        let grapheme = unsafe { bs[start..].to_str_unchecked() };\n        (grapheme, grapheme.len())\n    } else {\n        const INVALID: &'static str = \"\\u{FFFD}\";\n        // No match on non-empty bytes implies we found invalid UTF-8.\n        let (_, size) = utf8::decode_last_lossy(bs);\n        (INVALID, size)\n    }\n}","Real(LocalPath(\"src/unicode/grapheme.rs\"))"],"unicode::sentence::SentenceIndices":["/// An iterator over sentences in a byte string, along with their byte offsets.\n///\n/// This iterator is typically constructed by\n/// [`ByteSlice::sentence_indices`](trait.ByteSlice.html#method.sentence_indices).\n///\n/// Sentences typically include their trailing punctuation and whitespace.\n///\n/// Since sentences are made up of one or more codepoints, this iterator\n/// yields `&str` elements (along with their start and end byte offsets).\n/// When invalid UTF-8 is encountered, replacement codepoints are\n/// [substituted](index.html#handling-of-invalid-utf-8). Because of this, the\n/// indices yielded by this iterator may not correspond to the length of the\n/// sentence yielded with those indices. For example, when this iterator\n/// encounters `\\xFF` in the byte string, then it will yield a pair of indices\n/// ranging over a single byte, but will provide an `&str` equivalent to\n/// `\"\\u{FFFD}\"`, which is three bytes in length. However, when given only\n/// valid UTF-8, then all indices are in exact correspondence with their paired\n/// word.\n///\n/// This iterator yields words in accordance with the default sentence boundary\n/// rules specified in\n/// [UAX #29](https://www.unicode.org/reports/tr29/tr29-33.html#Sentence_Boundaries).\npub struct SentenceIndices<'a> {\n    bs: &'a [u8],\n    forward_index: usize,\n}","Real(LocalPath(\"src/unicode/sentence.rs\"))"],"unicode::sentence::SentenceIndices::<'a>::as_bytes":["/// View the underlying data as a subslice of the original data.\n///\n/// The slice returned has the same lifetime as the original slice, and so\n/// the iterator can continue to be used while this exists.\n///\n/// # Examples\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut it = b\"I want this. Not that. Right now.\".sentence_indices();\n///\n/// assert_eq!(&b\"I want this. Not that. Right now.\"[..], it.as_bytes());\n/// it.next();\n/// assert_eq!(b\"Not that. Right now.\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\"\", it.as_bytes());\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &'a [u8]{\n        self.bs\n    }","Real(LocalPath(\"src/unicode/sentence.rs\"))"],"unicode::sentence::SentenceIndices::<'a>::new":["pub(crate) fn new(bs: &'a [u8]) -> SentenceIndices<'a>{\n        SentenceIndices { bs: bs, forward_index: 0 }\n    }","Real(LocalPath(\"src/unicode/sentence.rs\"))"],"unicode::sentence::Sentences":["/// An iterator over sentences in a byte string.\n///\n/// This iterator is typically constructed by\n/// [`ByteSlice::sentences`](trait.ByteSlice.html#method.sentences).\n///\n/// Sentences typically include their trailing punctuation and whitespace.\n///\n/// Since sentences are made up of one or more codepoints, this iterator yields\n/// `&str` elements. When invalid UTF-8 is encountered, replacement codepoints\n/// are [substituted](index.html#handling-of-invalid-utf-8).\n///\n/// This iterator yields words in accordance with the default sentence boundary\n/// rules specified in\n/// [UAX #29](https://www.unicode.org/reports/tr29/tr29-33.html#Sentence_Boundaries).\npub struct Sentences<'a> {\n    bs: &'a [u8],\n}","Real(LocalPath(\"src/unicode/sentence.rs\"))"],"unicode::sentence::Sentences::<'a>::as_bytes":["/// View the underlying data as a subslice of the original data.\n///\n/// The slice returned has the same lifetime as the original slice, and so\n/// the iterator can continue to be used while this exists.\n///\n/// # Examples\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut it = b\"I want this. Not that. Right now.\".sentences();\n///\n/// assert_eq!(&b\"I want this. Not that. Right now.\"[..], it.as_bytes());\n/// it.next();\n/// assert_eq!(b\"Not that. Right now.\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\"\", it.as_bytes());\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &'a [u8]{\n        self.bs\n    }","Real(LocalPath(\"src/unicode/sentence.rs\"))"],"unicode::sentence::Sentences::<'a>::new":["pub(crate) fn new(bs: &'a [u8]) -> Sentences<'a>{\n        Sentences { bs }\n    }","Real(LocalPath(\"src/unicode/sentence.rs\"))"],"unicode::sentence::decode_sentence":["fn decode_sentence(bs: &[u8]) -> (&str, usize){\n    if bs.is_empty() {\n        (\"\", 0)\n    } else if let Some(end) = SENTENCE_BREAK_FWD.find(bs) {\n        // Safe because a match can only occur for valid UTF-8.\n        let sentence = unsafe { bs[..end].to_str_unchecked() };\n        (sentence, sentence.len())\n    } else {\n        const INVALID: &'static str = \"\\u{FFFD}\";\n        // No match on non-empty bytes implies we found invalid UTF-8.\n        let (_, size) = utf8::decode_lossy(bs);\n        (INVALID, size)\n    }\n}","Real(LocalPath(\"src/unicode/sentence.rs\"))"],"unicode::whitespace::whitespace_len_fwd":["/// Return the first position of a non-whitespace character.\npub fn whitespace_len_fwd(slice: &[u8]) -> usize{\n    WHITESPACE_ANCHORED_FWD.find(slice).unwrap_or(0)\n}","Real(LocalPath(\"src/unicode/whitespace.rs\"))"],"unicode::whitespace::whitespace_len_rev":["/// Return the last position of a non-whitespace character.\npub fn whitespace_len_rev(slice: &[u8]) -> usize{\n    WHITESPACE_ANCHORED_REV.rfind(slice).unwrap_or(slice.len())\n}","Real(LocalPath(\"src/unicode/whitespace.rs\"))"],"unicode::word::WordIndices":["/// An iterator over words in a byte string and their byte index positions.\n///\n/// This iterator is typically constructed by\n/// [`ByteSlice::word_indices`](trait.ByteSlice.html#method.word_indices).\n///\n/// This is similar to the\n/// [`WordsWithBreakIndices`](struct.WordsWithBreakIndices.html) iterator,\n/// except it only returns elements that contain a \"word\" character. A\n/// word character is defined by UTS #18 (Annex C) to be the combination\n/// of the `Alphabetic` and `Join_Control` properties, along with the\n/// `Decimal_Number`, `Mark` and `Connector_Punctuation` general categories.\n///\n/// Since words are made up of one or more codepoints, this iterator\n/// yields `&str` elements (along with their start and end byte offsets).\n/// When invalid UTF-8 is encountered, replacement codepoints are\n/// [substituted](index.html#handling-of-invalid-utf-8). Because of this, the\n/// indices yielded by this iterator may not correspond to the length of the\n/// word yielded with those indices. For example, when this iterator encounters\n/// `\\xFF` in the byte string, then it will yield a pair of indices ranging\n/// over a single byte, but will provide an `&str` equivalent to `\"\\u{FFFD}\"`,\n/// which is three bytes in length. However, when given only valid UTF-8, then\n/// all indices are in exact correspondence with their paired word.\n///\n/// This iterator yields words in accordance with the default word boundary\n/// rules specified in\n/// [UAX #29](https://www.unicode.org/reports/tr29/tr29-33.html#Word_Boundaries).\n/// In particular, this may not be suitable for Japanese and Chinese scripts\n/// that do not use spaces between words.\npub struct WordIndices<'a>(WordsWithBreakIndices<'a>);","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::WordIndices::<'a>::as_bytes":["/// View the underlying data as a subslice of the original data.\n///\n/// The slice returned has the same lifetime as the original slice, and so\n/// the iterator can continue to be used while this exists.\n///\n/// # Examples\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut it = b\"foo bar baz\".word_indices();\n///\n/// assert_eq!(b\"foo bar baz\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\" baz\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\"\", it.as_bytes());\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &'a [u8]{\n        self.0.as_bytes()\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::WordIndices::<'a>::new":["pub(crate) fn new(bs: &'a [u8]) -> WordIndices<'a>{\n        WordIndices(WordsWithBreakIndices::new(bs))\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::Words":["/// An iterator over words in a byte string.\n///\n/// This iterator is typically constructed by\n/// [`ByteSlice::words`](trait.ByteSlice.html#method.words).\n///\n/// This is similar to the [`WordsWithBreaks`](struct.WordsWithBreaks.html)\n/// iterator, except it only returns elements that contain a \"word\" character.\n/// A word character is defined by UTS #18 (Annex C) to be the combination\n/// of the `Alphabetic` and `Join_Control` properties, along with the\n/// `Decimal_Number`, `Mark` and `Connector_Punctuation` general categories.\n///\n/// Since words are made up of one or more codepoints, this iterator yields\n/// `&str` elements. When invalid UTF-8 is encountered, replacement codepoints\n/// are [substituted](index.html#handling-of-invalid-utf-8).\n///\n/// This iterator yields words in accordance with the default word boundary\n/// rules specified in\n/// [UAX #29](https://www.unicode.org/reports/tr29/tr29-33.html#Word_Boundaries).\n/// In particular, this may not be suitable for Japanese and Chinese scripts\n/// that do not use spaces between words.\npub struct Words<'a>(WordsWithBreaks<'a>);","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::Words::<'a>::as_bytes":["/// View the underlying data as a subslice of the original data.\n///\n/// The slice returned has the same lifetime as the original slice, and so\n/// the iterator can continue to be used while this exists.\n///\n/// # Examples\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut it = b\"foo bar baz\".words();\n///\n/// assert_eq!(b\"foo bar baz\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\" baz\", it.as_bytes());\n/// it.next();\n/// assert_eq!(b\"\", it.as_bytes());\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &'a [u8]{\n        self.0.as_bytes()\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::Words::<'a>::new":["pub(crate) fn new(bs: &'a [u8]) -> Words<'a>{\n        Words(WordsWithBreaks::new(bs))\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::WordsWithBreakIndices":["/// An iterator over all word breaks in a byte string, along with their byte\n/// index positions.\n///\n/// This iterator is typically constructed by\n/// [`ByteSlice::words_with_break_indices`](trait.ByteSlice.html#method.words_with_break_indices).\n///\n/// This iterator yields not only all words, but the content that comes between\n/// words. In particular, if all elements yielded by this iterator are\n/// concatenated, then the result is the original string (subject to Unicode\n/// replacement codepoint substitutions).\n///\n/// Since words are made up of one or more codepoints, this iterator\n/// yields `&str` elements (along with their start and end byte offsets).\n/// When invalid UTF-8 is encountered, replacement codepoints are\n/// [substituted](index.html#handling-of-invalid-utf-8). Because of this, the\n/// indices yielded by this iterator may not correspond to the length of the\n/// word yielded with those indices. For example, when this iterator encounters\n/// `\\xFF` in the byte string, then it will yield a pair of indices ranging\n/// over a single byte, but will provide an `&str` equivalent to `\"\\u{FFFD}\"`,\n/// which is three bytes in length. However, when given only valid UTF-8, then\n/// all indices are in exact correspondence with their paired word.\n///\n/// This iterator yields words in accordance with the default word boundary\n/// rules specified in\n/// [UAX #29](https://www.unicode.org/reports/tr29/tr29-33.html#Word_Boundaries).\n/// In particular, this may not be suitable for Japanese and Chinese scripts\n/// that do not use spaces between words.\npub struct WordsWithBreakIndices<'a> {\n    bs: &'a [u8],\n    forward_index: usize,\n}","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::WordsWithBreakIndices::<'a>::as_bytes":["/// View the underlying data as a subslice of the original data.\n///\n/// The slice returned has the same lifetime as the original slice, and so\n/// the iterator can continue to be used while this exists.\n///\n/// # Examples\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut it = b\"foo bar baz\".words_with_break_indices();\n///\n/// assert_eq!(b\"foo bar baz\", it.as_bytes());\n/// it.next();\n/// assert_eq!(b\" bar baz\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\" baz\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\"\", it.as_bytes());\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &'a [u8]{\n        self.bs\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::WordsWithBreakIndices::<'a>::new":["pub(crate) fn new(bs: &'a [u8]) -> WordsWithBreakIndices<'a>{\n        WordsWithBreakIndices { bs: bs, forward_index: 0 }\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::WordsWithBreaks":["/// An iterator over all word breaks in a byte string.\n///\n/// This iterator is typically constructed by\n/// [`ByteSlice::words_with_breaks`](trait.ByteSlice.html#method.words_with_breaks).\n///\n/// This iterator yields not only all words, but the content that comes between\n/// words. In particular, if all elements yielded by this iterator are\n/// concatenated, then the result is the original string (subject to Unicode\n/// replacement codepoint substitutions).\n///\n/// Since words are made up of one or more codepoints, this iterator yields\n/// `&str` elements. When invalid UTF-8 is encountered, replacement codepoints\n/// are [substituted](index.html#handling-of-invalid-utf-8).\n///\n/// This iterator yields words in accordance with the default word boundary\n/// rules specified in\n/// [UAX #29](https://www.unicode.org/reports/tr29/tr29-33.html#Word_Boundaries).\n/// In particular, this may not be suitable for Japanese and Chinese scripts\n/// that do not use spaces between words.\npub struct WordsWithBreaks<'a> {\n    bs: &'a [u8],\n}","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::WordsWithBreaks::<'a>::as_bytes":["/// View the underlying data as a subslice of the original data.\n///\n/// The slice returned has the same lifetime as the original slice, and so\n/// the iterator can continue to be used while this exists.\n///\n/// # Examples\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut it = b\"foo bar baz\".words_with_breaks();\n///\n/// assert_eq!(b\"foo bar baz\", it.as_bytes());\n/// it.next();\n/// assert_eq!(b\" bar baz\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\" baz\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\"\", it.as_bytes());\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &'a [u8]{\n        self.bs\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::WordsWithBreaks::<'a>::new":["pub(crate) fn new(bs: &'a [u8]) -> WordsWithBreaks<'a>{\n        WordsWithBreaks { bs }\n    }","Real(LocalPath(\"src/unicode/word.rs\"))"],"unicode::word::decode_word":["fn decode_word(bs: &[u8]) -> (&str, usize){\n    if bs.is_empty() {\n        (\"\", 0)\n    } else if let Some(end) = WORD_BREAK_FWD.find(bs) {\n        // Safe because a match can only occur for valid UTF-8.\n        let word = unsafe { bs[..end].to_str_unchecked() };\n        (word, word.len())\n    } else {\n        const INVALID: &'static str = \"\\u{FFFD}\";\n        // No match on non-empty bytes implies we found invalid UTF-8.\n        let (_, size) = utf8::decode_lossy(bs);\n        (INVALID, size)\n    }\n}","Real(LocalPath(\"src/unicode/word.rs\"))"],"utf8::CharIndices":["/// An iterator over Unicode scalar values in a byte string and their\n/// byte index positions.\n///\n/// When invalid UTF-8 byte sequences are found, they are substituted with the\n/// Unicode replacement codepoint (`U+FFFD`) using the\n/// [\"maximal subpart\" strategy](http://www.unicode.org/review/pr-121.html).\n///\n/// Note that this is slightly different from the `CharIndices` iterator\n/// provided by the standard library. Aside from working on possibly invalid\n/// UTF-8, this iterator provides both the corresponding starting and ending\n/// byte indices of each codepoint yielded. The ending position is necessary to\n/// slice the original byte string when invalid UTF-8 bytes are converted into\n/// a Unicode replacement codepoint, since a single replacement codepoint can\n/// substitute anywhere from 1 to 3 invalid bytes (inclusive).\n///\n/// This iterator is created by the\n/// [`char_indices`](trait.ByteSlice.html#method.char_indices) method provided\n/// by the [`ByteSlice`](trait.ByteSlice.html) extension trait for `&[u8]`.\npub struct CharIndices<'a> {\n    bs: &'a [u8],\n    forward_index: usize,\n    reverse_index: usize,\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::CharIndices::<'a>::as_bytes":["/// View the underlying data as a subslice of the original data.\n///\n/// The slice returned has the same lifetime as the original slice, and so\n/// the iterator can continue to be used while this exists.\n///\n/// # Examples\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut it = b\"abc\".char_indices();\n///\n/// assert_eq!(b\"abc\", it.as_bytes());\n/// it.next();\n/// assert_eq!(b\"bc\", it.as_bytes());\n/// it.next();\n/// it.next();\n/// assert_eq!(b\"\", it.as_bytes());\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &'a [u8]{\n        self.bs\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::CharIndices::<'a>::new":["pub(crate) fn new(bs: &'a [u8]) -> CharIndices<'a>{\n        CharIndices { bs: bs, forward_index: 0, reverse_index: bs.len() }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Chars":["/// An iterator over Unicode scalar values in a byte string.\n///\n/// When invalid UTF-8 byte sequences are found, they are substituted with the\n/// Unicode replacement codepoint (`U+FFFD`) using the\n/// [\"maximal subpart\" strategy](http://www.unicode.org/review/pr-121.html).\n///\n/// This iterator is created by the\n/// [`chars`](trait.ByteSlice.html#method.chars) method provided by the\n/// [`ByteSlice`](trait.ByteSlice.html) extension trait for `&[u8]`.\npub struct Chars<'a> {\n    bs: &'a [u8],\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Chars::<'a>::as_bytes":["/// View the underlying data as a subslice of the original data.\n///\n/// The slice returned has the same lifetime as the original slice, and so\n/// the iterator can continue to be used while this exists.\n///\n/// # Examples\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let mut chars = b\"abc\".chars();\n///\n/// assert_eq!(b\"abc\", chars.as_bytes());\n/// chars.next();\n/// assert_eq!(b\"bc\", chars.as_bytes());\n/// chars.next();\n/// chars.next();\n/// assert_eq!(b\"\", chars.as_bytes());\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &'a [u8]{\n        self.bs\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Chars::<'a>::new":["pub(crate) fn new(bs: &'a [u8]) -> Chars<'a>{\n        Chars { bs }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Chunk":["/// A chunk of valid UTF-8, possibly followed by invalid UTF-8 bytes.\n///\n/// This is yielded by the\n/// [`Utf8Chunks`](struct.Utf8Chunks.html)\n/// iterator, which can be created via the\n/// [`ByteSlice::utf8_chunks`](trait.ByteSlice.html#method.utf8_chunks)\n/// method.\n///\n/// The `'a` lifetime parameter corresponds to the lifetime of the bytes that\n/// are being iterated over.\npub struct Utf8Chunk<'a> {\n    /// A valid UTF-8 piece, at the start, end, or between invalid UTF-8 bytes.\n    ///\n    /// This is empty between adjacent invalid UTF-8 byte sequences.\n    valid: &'a str,\n    /// A sequence of invalid UTF-8 bytes.\n    ///\n    /// Can only be empty in the last chunk.\n    ///\n    /// Should be replaced by a single unicode replacement character, if not\n    /// empty.\n    invalid: &'a BStr,\n    /// Indicates whether the invalid sequence could've been valid if there\n    /// were more bytes.\n    ///\n    /// Can only be true in the last chunk.\n    incomplete: bool,\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Chunk::<'a>::incomplete":["/// Returns whether the invalid sequence might still become valid if more\n/// bytes are added.\n///\n/// Returns true if the end of the input was reached unexpectedly,\n/// without encountering an unexpected byte.\n///\n/// This can only be the case for the last chunk.\n#[inline]\npub fn incomplete(&self) -> bool{\n        self.incomplete\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Chunk::<'a>::invalid":["/// Returns the (possibly empty) invalid UTF-8 bytes in this chunk that\n/// immediately follow the valid UTF-8 bytes in this chunk.\n///\n/// This is only empty when this chunk corresponds to the last chunk in\n/// the original bytes.\n///\n/// The maximum length of this slice is 3. That is, invalid UTF-8 byte\n/// sequences greater than 1 always correspond to a valid _prefix_ of\n/// a valid UTF-8 encoded codepoint. This corresponds to the \"substitution\n/// of maximal subparts\" strategy that is described in more detail in the\n/// docs for the\n/// [`ByteSlice::to_str_lossy`](trait.ByteSlice.html#method.to_str_lossy)\n/// method.\n#[inline]\npub fn invalid(&self) -> &'a [u8]{\n        self.invalid.as_bytes()\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Chunk::<'a>::valid":["/// Returns the (possibly empty) valid UTF-8 bytes in this chunk.\n///\n/// This may be empty if there are consecutive sequences of invalid UTF-8\n/// bytes.\n#[inline]\npub fn valid(&self) -> &'a str{\n        self.valid\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Chunks":["/// An iterator over chunks of valid UTF-8 in a byte slice.\n///\n/// See [`utf8_chunks`](trait.ByteSlice.html#method.utf8_chunks).\npub struct Utf8Chunks<'a> {\n    pub(super) bytes: &'a [u8],\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Error":["/// An error that occurs when UTF-8 decoding fails.\n///\n/// This error occurs when attempting to convert a non-UTF-8 byte\n/// string to a Rust string that must be valid UTF-8. For example,\n/// [`to_str`](trait.ByteSlice.html#method.to_str) is one such method.\n///\n/// # Example\n///\n/// This example shows what happens when a given byte sequence is invalid,\n/// but ends with a sequence that is a possible prefix of valid UTF-8.\n///\n/// ```\n/// use bstr::{B, ByteSlice};\n///\n/// let s = B(b\"foobar\\xF1\\x80\\x80\");\n/// let err = s.to_str().unwrap_err();\n/// assert_eq!(err.valid_up_to(), 6);\n/// assert_eq!(err.error_len(), None);\n/// ```\n///\n/// This example shows what happens when a given byte sequence contains\n/// invalid UTF-8.\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foobar\\xF1\\x80\\x80quux\";\n/// let err = s.to_str().unwrap_err();\n/// assert_eq!(err.valid_up_to(), 6);\n/// // The error length reports the maximum number of bytes that correspond to\n/// // a valid prefix of a UTF-8 encoded codepoint.\n/// assert_eq!(err.error_len(), Some(3));\n///\n/// // In contrast to the above which contains a single invalid prefix,\n/// // consider the case of multiple individal bytes that are never valid\n/// // prefixes. Note how the value of error_len changes!\n/// let s = b\"foobar\\xFF\\xFFquux\";\n/// let err = s.to_str().unwrap_err();\n/// assert_eq!(err.valid_up_to(), 6);\n/// assert_eq!(err.error_len(), Some(1));\n///\n/// // The fact that it's an invalid prefix does not change error_len even\n/// // when it immediately precedes the end of the string.\n/// let s = b\"foobar\\xFF\";\n/// let err = s.to_str().unwrap_err();\n/// assert_eq!(err.valid_up_to(), 6);\n/// assert_eq!(err.error_len(), Some(1));\n/// ```\npub struct Utf8Error {\n    valid_up_to: usize,\n    error_len: Option<usize>,\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Error::error_len":["/// Returns the total number of invalid UTF-8 bytes immediately following\n/// the position returned by `valid_up_to`. This value is always at least\n/// `1`, but can be up to `3` if bytes form a valid prefix of some UTF-8\n/// encoded codepoint.\n///\n/// If the end of the original input was found before a valid UTF-8 encoded\n/// codepoint could be completed, then this returns `None`. This is useful\n/// when processing streams, where a `None` value signals that more input\n/// might be needed.\n#[inline]\npub fn error_len(&self) -> Option<usize>{\n        self.error_len\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Error::valid_up_to":["/// Returns the byte index of the position immediately following the last\n/// valid UTF-8 byte.\n///\n/// # Example\n///\n/// This examples shows how `valid_up_to` can be used to retrieve a\n/// possibly empty prefix that is guaranteed to be valid UTF-8:\n///\n/// ```\n/// use bstr::ByteSlice;\n///\n/// let s = b\"foobar\\xF1\\x80\\x80quux\";\n/// let err = s.to_str().unwrap_err();\n///\n/// // This is guaranteed to never panic.\n/// let string = s[..err.valid_up_to()].to_str().unwrap();\n/// assert_eq!(string, \"foobar\");\n/// ```\n#[inline]\npub fn valid_up_to(&self) -> usize{\n        self.valid_up_to\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::decode":["/// UTF-8 decode a single Unicode scalar value from the beginning of a slice.\n///\n/// When successful, the corresponding Unicode scalar value is returned along\n/// with the number of bytes it was encoded with. The number of bytes consumed\n/// for a successful decode is always between 1 and 4, inclusive.\n///\n/// When unsuccessful, `None` is returned along with the number of bytes that\n/// make up a maximal prefix of a valid UTF-8 code unit sequence. In this case,\n/// the number of bytes consumed is always between 0 and 3, inclusive, where\n/// 0 is only returned when `slice` is empty.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::decode_utf8;\n///\n/// // Decoding a valid codepoint.\n/// let (ch, size) = decode_utf8(b\"\\xE2\\x98\\x83\");\n/// assert_eq!(Some('☃'), ch);\n/// assert_eq!(3, size);\n///\n/// // Decoding an incomplete codepoint.\n/// let (ch, size) = decode_utf8(b\"\\xE2\\x98\");\n/// assert_eq!(None, ch);\n/// assert_eq!(2, size);\n/// ```\n///\n/// This example shows how to iterate over all codepoints in UTF-8 encoded\n/// bytes, while replacing invalid UTF-8 sequences with the replacement\n/// codepoint:\n///\n/// ```\n/// use bstr::{B, decode_utf8};\n///\n/// let mut bytes = B(b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\");\n/// let mut chars = vec![];\n/// while !bytes.is_empty() {\n///     let (ch, size) = decode_utf8(bytes);\n///     bytes = &bytes[size..];\n///     chars.push(ch.unwrap_or('\\u{FFFD}'));\n/// }\n/// assert_eq!(vec!['☃', '\\u{FFFD}', '𝞃', '\\u{FFFD}', 'a'], chars);\n/// ```\n#[inline]\npub fn decode<B: AsRef<[u8]>>(slice: B) -> (Option<char>, usize){\n    let slice = slice.as_ref();\n    match slice.get(0) {\n        None => return (None, 0),\n        Some(&b) if b <= 0x7F => return (Some(b as char), 1),\n        _ => {}\n    }\n\n    let (mut state, mut cp, mut i) = (ACCEPT, 0, 0);\n    while i < slice.len() {\n        decode_step(&mut state, &mut cp, slice[i]);\n        i += 1;\n\n        if state == ACCEPT {\n            // SAFETY: This is safe because `decode_step` guarantees that\n            // `cp` is a valid Unicode scalar value in an ACCEPT state.\n            let ch = unsafe { char::from_u32_unchecked(cp) };\n            return (Some(ch), i);\n        } else if state == REJECT {\n            // At this point, we always want to advance at least one byte.\n            return (None, cmp::max(1, i.saturating_sub(1)));\n        }\n    }\n    (None, i)\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::decode_last":["/// UTF-8 decode a single Unicode scalar value from the end of a slice.\n///\n/// When successful, the corresponding Unicode scalar value is returned along\n/// with the number of bytes it was encoded with. The number of bytes consumed\n/// for a successful decode is always between 1 and 4, inclusive.\n///\n/// When unsuccessful, `None` is returned along with the number of bytes that\n/// make up a maximal prefix of a valid UTF-8 code unit sequence. In this case,\n/// the number of bytes consumed is always between 0 and 3, inclusive, where\n/// 0 is only returned when `slice` is empty.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use bstr::decode_last_utf8;\n///\n/// // Decoding a valid codepoint.\n/// let (ch, size) = decode_last_utf8(b\"\\xE2\\x98\\x83\");\n/// assert_eq!(Some('☃'), ch);\n/// assert_eq!(3, size);\n///\n/// // Decoding an incomplete codepoint.\n/// let (ch, size) = decode_last_utf8(b\"\\xE2\\x98\");\n/// assert_eq!(None, ch);\n/// assert_eq!(2, size);\n/// ```\n///\n/// This example shows how to iterate over all codepoints in UTF-8 encoded\n/// bytes in reverse, while replacing invalid UTF-8 sequences with the\n/// replacement codepoint:\n///\n/// ```\n/// use bstr::{B, decode_last_utf8};\n///\n/// let mut bytes = B(b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\");\n/// let mut chars = vec![];\n/// while !bytes.is_empty() {\n///     let (ch, size) = decode_last_utf8(bytes);\n///     bytes = &bytes[..bytes.len()-size];\n///     chars.push(ch.unwrap_or('\\u{FFFD}'));\n/// }\n/// assert_eq!(vec!['a', '\\u{FFFD}', '𝞃', '\\u{FFFD}', '☃'], chars);\n/// ```\n#[inline]\npub fn decode_last<B: AsRef<[u8]>>(slice: B) -> (Option<char>, usize){\n    // TODO: We could implement this by reversing the UTF-8 automaton, but for\n    // now, we do it the slow way by using the forward automaton.\n\n    let slice = slice.as_ref();\n    if slice.is_empty() {\n        return (None, 0);\n    }\n    let mut start = slice.len() - 1;\n    let limit = slice.len().saturating_sub(4);\n    while start > limit && !is_leading_or_invalid_utf8_byte(slice[start]) {\n        start -= 1;\n    }\n    let (ch, size) = decode(&slice[start..]);\n    // If we didn't consume all of the bytes, then that means there's at least\n    // one stray byte that never occurs in a valid code unit prefix, so we can\n    // advance by one byte.\n    if start + size != slice.len() {\n        (None, 1)\n    } else {\n        (ch, size)\n    }\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::decode_last_lossy":["/// Lossily UTF-8 decode a single Unicode scalar value from the end of a slice.\n///\n/// When successful, the corresponding Unicode scalar value is returned along\n/// with the number of bytes it was encoded with. The number of bytes consumed\n/// for a successful decode is always between 1 and 4, inclusive.\n///\n/// When unsuccessful, the Unicode replacement codepoint (`U+FFFD`) is returned\n/// along with the number of bytes that make up a maximal prefix of a valid\n/// UTF-8 code unit sequence. In this case, the number of bytes consumed is\n/// always between 0 and 3, inclusive, where 0 is only returned when `slice` is\n/// empty.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```ignore\n/// use bstr::decode_last_utf8_lossy;\n///\n/// // Decoding a valid codepoint.\n/// let (ch, size) = decode_last_utf8_lossy(b\"\\xE2\\x98\\x83\");\n/// assert_eq!('☃', ch);\n/// assert_eq!(3, size);\n///\n/// // Decoding an incomplete codepoint.\n/// let (ch, size) = decode_last_utf8_lossy(b\"\\xE2\\x98\");\n/// assert_eq!('\\u{FFFD}', ch);\n/// assert_eq!(2, size);\n/// ```\n///\n/// This example shows how to iterate over all codepoints in UTF-8 encoded\n/// bytes in reverse, while replacing invalid UTF-8 sequences with the\n/// replacement codepoint:\n///\n/// ```ignore\n/// use bstr::decode_last_utf8_lossy;\n///\n/// let mut bytes = B(b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\");\n/// let mut chars = vec![];\n/// while !bytes.is_empty() {\n///     let (ch, size) = decode_last_utf8_lossy(bytes);\n///     bytes = &bytes[..bytes.len()-size];\n///     chars.push(ch);\n/// }\n/// assert_eq!(vec!['a', '\\u{FFFD}', '𝞃', '\\u{FFFD}', '☃'], chars);\n/// ```\n#[inline]\npub fn decode_last_lossy<B: AsRef<[u8]>>(slice: B) -> (char, usize){\n    match decode_last(slice) {\n        (Some(ch), size) => (ch, size),\n        (None, size) => ('\\u{FFFD}', size),\n    }\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::decode_lossy":["/// Lossily UTF-8 decode a single Unicode scalar value from the beginning of a\n/// slice.\n///\n/// When successful, the corresponding Unicode scalar value is returned along\n/// with the number of bytes it was encoded with. The number of bytes consumed\n/// for a successful decode is always between 1 and 4, inclusive.\n///\n/// When unsuccessful, the Unicode replacement codepoint (`U+FFFD`) is returned\n/// along with the number of bytes that make up a maximal prefix of a valid\n/// UTF-8 code unit sequence. In this case, the number of bytes consumed is\n/// always between 0 and 3, inclusive, where 0 is only returned when `slice` is\n/// empty.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```ignore\n/// use bstr::decode_utf8_lossy;\n///\n/// // Decoding a valid codepoint.\n/// let (ch, size) = decode_utf8_lossy(b\"\\xE2\\x98\\x83\");\n/// assert_eq!('☃', ch);\n/// assert_eq!(3, size);\n///\n/// // Decoding an incomplete codepoint.\n/// let (ch, size) = decode_utf8_lossy(b\"\\xE2\\x98\");\n/// assert_eq!('\\u{FFFD}', ch);\n/// assert_eq!(2, size);\n/// ```\n///\n/// This example shows how to iterate over all codepoints in UTF-8 encoded\n/// bytes, while replacing invalid UTF-8 sequences with the replacement\n/// codepoint:\n///\n/// ```ignore\n/// use bstr::{B, decode_utf8_lossy};\n///\n/// let mut bytes = B(b\"\\xE2\\x98\\x83\\xFF\\xF0\\x9D\\x9E\\x83\\xE2\\x98\\x61\");\n/// let mut chars = vec![];\n/// while !bytes.is_empty() {\n///     let (ch, size) = decode_utf8_lossy(bytes);\n///     bytes = &bytes[size..];\n///     chars.push(ch);\n/// }\n/// assert_eq!(vec!['☃', '\\u{FFFD}', '𝞃', '\\u{FFFD}', 'a'], chars);\n/// ```\n#[inline]\npub fn decode_lossy<B: AsRef<[u8]>>(slice: B) -> (char, usize){\n    match decode(slice) {\n        (Some(ch), size) => (ch, size),\n        (None, size) => ('\\u{FFFD}', size),\n    }\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::decode_step":["/// SAFETY: The decode function relies on state being equal to ACCEPT only if\n/// cp is a valid Unicode scalar value.\n#[inline]\npub fn decode_step(state: &mut usize, cp: &mut u32, b: u8){\n    let class = CLASSES[b as usize];\n    if *state == ACCEPT {\n        *cp = (0xFF >> class) & (b as u32);\n    } else {\n        *cp = (b as u32 & 0b111111) | (*cp << 6);\n    }\n    *state = STATES_FORWARD[*state + class as usize] as usize;\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::is_leading_or_invalid_utf8_byte":["/// Returns true if and only if the given byte is either a valid leading UTF-8\n/// byte, or is otherwise an invalid byte that can never appear anywhere in a\n/// valid UTF-8 sequence.\nfn is_leading_or_invalid_utf8_byte(b: u8) -> bool{\n    // In the ASCII case, the most significant bit is never set. The leading\n    // byte of a 2/3/4-byte sequence always has the top two most significant\n    // bits set. For bytes that can never appear anywhere in valid UTF-8, this\n    // also returns true, since every such byte has its two most significant\n    // bits set:\n    //\n    //     \\xC0 :: 11000000\n    //     \\xC1 :: 11000001\n    //     \\xF5 :: 11110101\n    //     \\xF6 :: 11110110\n    //     \\xF7 :: 11110111\n    //     \\xF8 :: 11111000\n    //     \\xF9 :: 11111001\n    //     \\xFA :: 11111010\n    //     \\xFB :: 11111011\n    //     \\xFC :: 11111100\n    //     \\xFD :: 11111101\n    //     \\xFE :: 11111110\n    //     \\xFF :: 11111111\n    (b & 0b1100_0000) != 0b1000_0000\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::validate":["/// Returns OK if and only if the given slice is completely valid UTF-8.\n///\n/// If the slice isn't valid UTF-8, then an error is returned that explains\n/// the first location at which invalid UTF-8 was detected.\npub fn validate(slice: &[u8]) -> Result<(), Utf8Error>{\n    // The fast path for validating UTF-8. It steps through a UTF-8 automaton\n    // and uses a SIMD accelerated ASCII fast path on x86_64. If an error is\n    // detected, it backs up and runs the slower version of the UTF-8 automaton\n    // to determine correct error information.\n    fn fast(slice: &[u8]) -> Result<(), Utf8Error> {\n        let mut state = ACCEPT;\n        let mut i = 0;\n\n        while i < slice.len() {\n            let b = slice[i];\n\n            // ASCII fast path. If we see two consecutive ASCII bytes, then try\n            // to validate as much ASCII as possible very quickly.\n            if state == ACCEPT\n                && b <= 0x7F\n                && slice.get(i + 1).map_or(false, |&b| b <= 0x7F)\n            {\n                i += ascii::first_non_ascii_byte(&slice[i..]);\n                continue;\n            }\n\n            state = step(state, b);\n            if state == REJECT {\n                return Err(find_valid_up_to(slice, i));\n            }\n            i += 1;\n        }\n        if state != ACCEPT {\n            Err(find_valid_up_to(slice, slice.len()))\n        } else {\n            Ok(())\n        }\n    }\n\n    // Given the first position at which a UTF-8 sequence was determined to be\n    // invalid, return an error that correctly reports the position at which\n    // the last complete UTF-8 sequence ends.\n    #[inline(never)]\n    fn find_valid_up_to(slice: &[u8], rejected_at: usize) -> Utf8Error {\n        // In order to find the last valid byte, we need to back up an amount\n        // that guarantees every preceding byte is part of a valid UTF-8\n        // code unit sequence. To do this, we simply locate the last leading\n        // byte that occurs before rejected_at.\n        let mut backup = rejected_at.saturating_sub(1);\n        while backup > 0 && !is_leading_or_invalid_utf8_byte(slice[backup]) {\n            backup -= 1;\n        }\n        let upto = cmp::min(slice.len(), rejected_at.saturating_add(1));\n        let mut err = slow(&slice[backup..upto]).unwrap_err();\n        err.valid_up_to += backup;\n        err\n    }\n\n    // Like top-level UTF-8 decoding, except it correctly reports a UTF-8 error\n    // when an invalid sequence is found. This is split out from validate so\n    // that the fast path doesn't need to keep track of the position of the\n    // last valid UTF-8 byte. In particular, tracking this requires checking\n    // for an ACCEPT state on each byte, which degrades throughput pretty\n    // badly.\n    fn slow(slice: &[u8]) -> Result<(), Utf8Error> {\n        let mut state = ACCEPT;\n        let mut valid_up_to = 0;\n        for (i, &b) in slice.iter().enumerate() {\n            state = step(state, b);\n            if state == ACCEPT {\n                valid_up_to = i + 1;\n            } else if state == REJECT {\n                // Our error length must always be at least 1.\n                let error_len = Some(cmp::max(1, i - valid_up_to));\n                return Err(Utf8Error { valid_up_to, error_len });\n            }\n        }\n        if state != ACCEPT {\n            Err(Utf8Error { valid_up_to, error_len: None })\n        } else {\n            Ok(())\n        }\n    }\n\n    // Advance to the next state given the current state and current byte.\n    fn step(state: usize, b: u8) -> usize {\n        let class = CLASSES[b as usize];\n        // SAFETY: This is safe because 'class' is always <=11 and 'state' is\n        // always <=96. Therefore, the maximal index is 96+11 = 107, where\n        // STATES_FORWARD.len() = 108 such that every index is guaranteed to be\n        // valid by construction of the state machine and the byte equivalence\n        // classes.\n        unsafe {\n            *STATES_FORWARD.get_unchecked(state + class as usize) as usize\n        }\n    }\n\n    fast(slice)\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::validate::fast":["fn fast(slice: &[u8]) -> Result<(), Utf8Error>{\n        let mut state = ACCEPT;\n        let mut i = 0;\n\n        while i < slice.len() {\n            let b = slice[i];\n\n            // ASCII fast path. If we see two consecutive ASCII bytes, then try\n            // to validate as much ASCII as possible very quickly.\n            if state == ACCEPT\n                && b <= 0x7F\n                && slice.get(i + 1).map_or(false, |&b| b <= 0x7F)\n            {\n                i += ascii::first_non_ascii_byte(&slice[i..]);\n                continue;\n            }\n\n            state = step(state, b);\n            if state == REJECT {\n                return Err(find_valid_up_to(slice, i));\n            }\n            i += 1;\n        }\n        if state != ACCEPT {\n            Err(find_valid_up_to(slice, slice.len()))\n        } else {\n            Ok(())\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::validate::find_valid_up_to":["#[inline(never)]\nfn find_valid_up_to(slice: &[u8], rejected_at: usize) -> Utf8Error{\n        // In order to find the last valid byte, we need to back up an amount\n        // that guarantees every preceding byte is part of a valid UTF-8\n        // code unit sequence. To do this, we simply locate the last leading\n        // byte that occurs before rejected_at.\n        let mut backup = rejected_at.saturating_sub(1);\n        while backup > 0 && !is_leading_or_invalid_utf8_byte(slice[backup]) {\n            backup -= 1;\n        }\n        let upto = cmp::min(slice.len(), rejected_at.saturating_add(1));\n        let mut err = slow(&slice[backup..upto]).unwrap_err();\n        err.valid_up_to += backup;\n        err\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::validate::slow":["fn slow(slice: &[u8]) -> Result<(), Utf8Error>{\n        let mut state = ACCEPT;\n        let mut valid_up_to = 0;\n        for (i, &b) in slice.iter().enumerate() {\n            state = step(state, b);\n            if state == ACCEPT {\n                valid_up_to = i + 1;\n            } else if state == REJECT {\n                // Our error length must always be at least 1.\n                let error_len = Some(cmp::max(1, i - valid_up_to));\n                return Err(Utf8Error { valid_up_to, error_len });\n            }\n        }\n        if state != ACCEPT {\n            Err(Utf8Error { valid_up_to, error_len: None })\n        } else {\n            Ok(())\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::validate::step":["fn step(state: usize, b: u8) -> usize{\n        let class = CLASSES[b as usize];\n        // SAFETY: This is safe because 'class' is always <=11 and 'state' is\n        // always <=96. Therefore, the maximal index is 96+11 = 107, where\n        // STATES_FORWARD.len() = 108 such that every index is guaranteed to be\n        // valid by construction of the state machine and the byte equivalence\n        // classes.\n        unsafe {\n            *STATES_FORWARD.get_unchecked(state + class as usize) as usize\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"]},"struct_constructor":{"&'a [u8]":["B","as_bytes","as_slice","haystack","invalid","next"],"&'a bstr::BStr":["default","from"],"&'a mut bstr::BStr":["default"],"&'a str":["next","next_back","valid"],"&[u8]":["as_bytes","as_ref","as_slice","deref","from_os_str","from_path","imp","needle","trim","trim_end","trim_end_with","trim_start","trim_start_with","trim_with"],"&bstr::BStr":["as_bstr","as_ref","borrow","from_bytes","new"],"&mut [u8]":["as_bytes_mut","as_mut","deref_mut"],"&mut bstr::BStr":["as_bstr_mut","as_mut","as_mut_bstr","from_bytes_mut","new_mut"],"&mut u8":["index_mut"],"&std::ffi::OsStr":["imp","to_os_str"],"&std::path::Path":["to_path"],"&str":["description","to_str","to_str_unchecked"],"&u8":["index"],"&utf8::Utf8Error":["utf8_error"],"(&str, usize)":["decode_grapheme","decode_last_grapheme","decode_sentence","decode_word"],"(char, usize)":["decode_last_lossy","decode_lossy"],"(std::option::Option<char>, usize)":["decode","decode_last"],"(usize, std::option::Option<usize>)":["size_hint"],"(usize, usize, &'a str)":["next","next_back"],"(usize, usize, char)":["next","next_back"],"[u8; 256]":["build_table"],"bool":["contains_str","ends_with_str","eq","incomplete","is_ascii","is_effective","is_leading_or_invalid_utf8_byte","is_utf8","starts_with_str"],"bstring::BString":["clone","default","from","from_iter","to_owned"],"char":["next","next_back","pop_char","remove_char"],"cow::CowBytes":["clone","new","new_owned"],"cow::Imp":["clone","new"],"ext_slice::Bytes":["bytes","clone"],"ext_slice::Fields":["fields","new"],"ext_slice::FieldsWith":["fields_with","new"],"ext_slice::Find":["find_iter","new"],"ext_slice::FindReverse":["new","rfind_iter"],"ext_slice::Finder":["clone","new"],"ext_slice::FinderReverse":["clone","new"],"ext_slice::Lines":["lines","new"],"ext_slice::LinesWithTerminator":["lines_with_terminator","new"],"ext_slice::Split":["new","split_str"],"ext_slice::SplitN":["new","splitn_str"],"ext_slice::SplitNReverse":["new","rsplitn_str"],"ext_slice::SplitReverse":["new","rsplit_str"],"ext_vec::DrainBytes":["drain_bytes"],"io::ByteLines":["byte_lines"],"io::ByteRecords":["byte_records"],"regex_automata::DenseDFA":["__static_ref_initialize"],"regex_automata::SparseDFA":["__static_ref_initialize"],"search::prefilter::Freqy":["clone","forward","inert","reverse"],"search::prefilter::PrefilterState":["clone","inert","new","prefilter_state"],"search::twoway::Shift":["clone","forward","reverse"],"search::twoway::Suffix":["forward","reverse"],"search::twoway::SuffixKind":["clone"],"search::twoway::SuffixOrdering":["clone","cmp"],"search::twoway::TwoWay":["clone","forward","reverse"],"std::borrow::Cow":["from","from_os_str_lossy","from_path_lossy","imp","to_os_str_lossy","to_path_lossy","to_str_lossy"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::ffi::OsString":["imp","into_os_string","into_os_string_lossy"],"std::path::PathBuf":["into_path_buf","into_path_buf_lossy"],"std::string::String":["into_string","into_string_lossy","into_string_unchecked"],"std::vec::Vec":["concat","from","from_os_string","from_path_buf","from_slice","imp","into_vec","join","next","repeatn","replace","replacen","to_ascii_lowercase","to_ascii_uppercase","to_lowercase","to_uppercase"],"u8":["last_byte","next","next_back","pop_byte"],"unicode::grapheme::GraphemeIndices":["clone","grapheme_indices","new"],"unicode::grapheme::Graphemes":["clone","graphemes","new"],"unicode::sentence::SentenceIndices":["clone","new","sentence_indices"],"unicode::sentence::Sentences":["clone","new","sentences"],"unicode::word::WordIndices":["clone","new","word_indices"],"unicode::word::Words":["clone","new","words"],"unicode::word::WordsWithBreakIndices":["clone","new","words_with_break_indices"],"unicode::word::WordsWithBreaks":["clone","new","words_with_breaks"],"usize":["error_len","find","find_byte","find_byteset","find_candidate","find_char","find_non_ascii_byte","find_not","find_not_byteset","find_with","first_non_ascii_byte","first_non_ascii_byte_slow","first_non_ascii_byte_sse2","forward_search","forward_search_bytes","inv_memchr","inv_memrchr","len","next","rank","read_unaligned_usize","repeat_byte","reverse_search","reverse_search_bytes","rfind","rfind_byte","rfind_byteset","rfind_candidate","rfind_char","rfind_not","rfind_not_byteset","rfind_with","sub","valid_up_to","whitespace_len_fwd","whitespace_len_rev"],"utf8::CharIndices":["char_indices","clone","new"],"utf8::Chars":["chars","clone","new"],"utf8::Utf8Chunk":["next"],"utf8::Utf8Chunks":["clone","utf8_chunks"],"utf8::Utf8Error":["find_valid_up_to"]},"struct_to_trait":{"<B as io::BufReadExt>::B":["io::BufReadExt"],"bstr::BStr":["lazy_static::__Deref","std::borrow::ToOwned","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsMut","std::convert::AsRef","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::ops::DerefMut","std::ops::Index","std::ops::IndexMut"],"bstring::BString":["lazy_static::__Deref","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsMut","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::iter::FromIterator","std::ops::DerefMut"],"cow::CowBytes":["lazy_static::__Deref","std::clone::Clone","std::fmt::Debug"],"cow::Imp":["std::clone::Clone","std::fmt::Debug"],"ext_slice::Bytes":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"ext_slice::Fields":["std::fmt::Debug","std::iter::Iterator"],"ext_slice::FieldsWith":["std::fmt::Debug","std::iter::Iterator"],"ext_slice::Find":["std::fmt::Debug","std::iter::Iterator"],"ext_slice::FindReverse":["std::fmt::Debug","std::iter::Iterator"],"ext_slice::Finder":["std::clone::Clone","std::fmt::Debug"],"ext_slice::FinderReverse":["std::clone::Clone","std::fmt::Debug"],"ext_slice::Lines":["std::iter::Iterator"],"ext_slice::LinesWithTerminator":["std::iter::Iterator"],"ext_slice::Split":["std::fmt::Debug","std::iter::Iterator"],"ext_slice::SplitN":["std::fmt::Debug","std::iter::Iterator"],"ext_slice::SplitNReverse":["std::fmt::Debug","std::iter::Iterator"],"ext_slice::SplitReverse":["std::fmt::Debug","std::iter::Iterator"],"ext_vec::DrainBytes":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"ext_vec::FromUtf8Error":["std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"io::ByteLines":["std::fmt::Debug","std::iter::Iterator"],"io::ByteRecords":["std::fmt::Debug","std::iter::Iterator"],"search::prefilter::Freqy":["std::clone::Clone","std::fmt::Debug"],"search::prefilter::PrefilterState":["std::clone::Clone","std::fmt::Debug"],"search::twoway::Shift":["std::clone::Clone","std::fmt::Debug"],"search::twoway::Suffix":["std::fmt::Debug"],"search::twoway::SuffixKind":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"search::twoway::SuffixOrdering":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"search::twoway::TwoWay":["std::clone::Clone","std::fmt::Debug"],"std::borrow::Cow":["std::cmp::PartialEq","std::convert::From"],"std::boxed::Box":["std::convert::From"],"std::string::String":["std::cmp::PartialEq","std::cmp::PartialOrd"],"std::vec::Vec":["ext_vec::ByteVec","ext_vec::Sealed","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From"],"unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD":["lazy_static::LazyStatic","lazy_static::__Deref"],"unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV":["lazy_static::LazyStatic","lazy_static::__Deref"],"unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV":["lazy_static::LazyStatic","lazy_static::__Deref"],"unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD":["lazy_static::LazyStatic","lazy_static::__Deref"],"unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD":["lazy_static::LazyStatic","lazy_static::__Deref"],"unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD":["lazy_static::LazyStatic","lazy_static::__Deref"],"unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV":["lazy_static::LazyStatic","lazy_static::__Deref"],"unicode::fsm::word_break_fwd::WORD_BREAK_FWD":["lazy_static::LazyStatic","lazy_static::__Deref"],"unicode::grapheme::GraphemeIndices":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"unicode::grapheme::Graphemes":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"unicode::sentence::SentenceIndices":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"unicode::sentence::Sentences":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"unicode::word::WordIndices":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"unicode::word::Words":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"unicode::word::WordsWithBreakIndices":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"unicode::word::WordsWithBreaks":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"utf8::CharIndices":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::FusedIterator","std::iter::Iterator"],"utf8::Chars":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::Iterator"],"utf8::Utf8Chunks":["std::clone::Clone","std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"utf8::Utf8Error":["std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"]},"targets":{"<[u8] as ext_slice::ByteSlice>::as_bytes":["as_bytes","Real(LocalPath(\"src/ext_slice.rs\"))","ext_slice::ByteSlice"],"<[u8] as ext_slice::ByteSlice>::as_bytes_mut":["as_bytes_mut","Real(LocalPath(\"src/ext_slice.rs\"))","ext_slice::ByteSlice"],"<cow::CowBytes<'a> as lazy_static::__Deref>::deref":["deref","Real(LocalPath(\"src/cow.rs\"))","lazy_static::__Deref"],"<ext_slice::Bytes<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::DoubleEndedIterator"],"<ext_slice::Bytes<'a> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::ExactSizeIterator"],"<ext_slice::Bytes<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_slice::Bytes<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_slice::Fields<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_slice::FieldsWith<'a, F> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_slice::Find<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_slice::FindReverse<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_slice::Lines<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_slice::LinesWithTerminator<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_slice::Split<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_slice::SplitN<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_slice::SplitNReverse<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_slice::SplitReverse<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_slice.rs\"))","std::iter::Iterator"],"<ext_vec::DrainBytes<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/ext_vec.rs\"))","std::iter::DoubleEndedIterator"],"<ext_vec::DrainBytes<'a> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/ext_vec.rs\"))","std::iter::ExactSizeIterator"],"<ext_vec::DrainBytes<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ext_vec.rs\"))","std::iter::Iterator"],"<ext_vec::FromUtf8Error as std::error::Error>::description":["description","Real(LocalPath(\"src/ext_vec.rs\"))","std::error::Error"],"<ext_vec::FromUtf8Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/ext_vec.rs\"))","std::fmt::Display"],"<io::ByteLines<B> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/io.rs\"))","std::iter::Iterator"],"<io::ByteRecords<B> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/io.rs\"))","std::iter::Iterator"],"<std::vec::Vec<u8> as ext_vec::ByteVec>::as_vec":["as_vec","Real(LocalPath(\"src/ext_vec.rs\"))","ext_vec::ByteVec"],"<std::vec::Vec<u8> as ext_vec::ByteVec>::as_vec_mut":["as_vec_mut","Real(LocalPath(\"src/ext_vec.rs\"))","ext_vec::ByteVec"],"<std::vec::Vec<u8> as ext_vec::ByteVec>::into_vec":["into_vec","Real(LocalPath(\"src/ext_vec.rs\"))","ext_vec::ByteVec"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::LazyStatic>::initialize":["initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::LazyStatic"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref":["deref","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::__Deref"],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref::__stability":["__stability","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["__static_ref_initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::LazyStatic>::initialize":["initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::LazyStatic"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref":["deref","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::__Deref"],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref::__stability":["__stability","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref::__static_ref_initialize":["__static_ref_initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::LazyStatic>::initialize":["initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::LazyStatic"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref":["deref","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::__Deref"],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref::__stability":["__stability","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref::__static_ref_initialize":["__static_ref_initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::LazyStatic>::initialize":["initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::LazyStatic"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref":["deref","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::__Deref"],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref::__stability":["__stability","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["__static_ref_initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::LazyStatic>::initialize":["initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::LazyStatic"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref":["deref","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::__Deref"],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref::__stability":["__stability","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["__static_ref_initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::LazyStatic>::initialize":["initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::LazyStatic"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref":["deref","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::__Deref"],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref::__stability":["__stability","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["__static_ref_initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::LazyStatic>::initialize":["initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::LazyStatic"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref":["deref","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::__Deref"],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref::__stability":["__stability","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref::__static_ref_initialize":["__static_ref_initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::LazyStatic>::initialize":["initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::LazyStatic"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref":["deref","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::__Deref"],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref::__stability":["__stability","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize":["__static_ref_initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<unicode::grapheme::GraphemeIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/unicode/grapheme.rs\"))","std::iter::DoubleEndedIterator"],"<unicode::grapheme::GraphemeIndices<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/unicode/grapheme.rs\"))","std::iter::Iterator"],"<unicode::grapheme::Graphemes<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/unicode/grapheme.rs\"))","std::iter::DoubleEndedIterator"],"<unicode::grapheme::Graphemes<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/unicode/grapheme.rs\"))","std::iter::Iterator"],"<unicode::sentence::SentenceIndices<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/unicode/sentence.rs\"))","std::iter::Iterator"],"<unicode::sentence::Sentences<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/unicode/sentence.rs\"))","std::iter::Iterator"],"<unicode::word::WordIndices<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/unicode/word.rs\"))","std::iter::Iterator"],"<unicode::word::Words<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/unicode/word.rs\"))","std::iter::Iterator"],"<unicode::word::WordsWithBreakIndices<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/unicode/word.rs\"))","std::iter::Iterator"],"<unicode::word::WordsWithBreaks<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/unicode/word.rs\"))","std::iter::Iterator"],"<utf8::CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/utf8.rs\"))","std::iter::DoubleEndedIterator"],"<utf8::CharIndices<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf8.rs\"))","std::iter::Iterator"],"<utf8::Chars<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/utf8.rs\"))","std::iter::DoubleEndedIterator"],"<utf8::Chars<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf8.rs\"))","std::iter::Iterator"],"<utf8::Utf8Chunks<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf8.rs\"))","std::iter::Iterator"],"<utf8::Utf8Chunks<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/utf8.rs\"))","std::iter::Iterator"],"<utf8::Utf8Error as std::error::Error>::description":["description","Real(LocalPath(\"src/utf8.rs\"))","std::error::Error"],"<utf8::Utf8Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/utf8.rs\"))","std::fmt::Display"],"ascii::first_non_ascii_byte":["first_non_ascii_byte","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::first_non_ascii_byte_slow":["first_non_ascii_byte_slow","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::first_non_ascii_byte_sse2":["first_non_ascii_byte_sse2","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::ptr_add":["ptr_add","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::ptr_sub":["ptr_sub","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::sub":["sub","Real(LocalPath(\"src/ascii.rs\"))",""],"bstr::BStr::as_bytes":["as_bytes","Real(LocalPath(\"src/bstr.rs\"))",""],"bstr::BStr::from_boxed_bytes":["from_boxed_bytes","Real(LocalPath(\"src/bstr.rs\"))",""],"bstr::BStr::from_bytes":["from_bytes","Real(LocalPath(\"src/bstr.rs\"))",""],"bstr::BStr::from_bytes_mut":["from_bytes_mut","Real(LocalPath(\"src/bstr.rs\"))",""],"bstr::BStr::into_boxed_bytes":["into_boxed_bytes","Real(LocalPath(\"src/bstr.rs\"))",""],"bstr::BStr::new":["new","Real(LocalPath(\"src/bstr.rs\"))",""],"bstr::BStr::new_mut":["new_mut","Real(LocalPath(\"src/bstr.rs\"))",""],"bstring::BString::as_bstr":["as_bstr","Real(LocalPath(\"src/bstring.rs\"))",""],"bstring::BString::as_bytes":["as_bytes","Real(LocalPath(\"src/bstring.rs\"))",""],"bstring::BString::as_mut_bstr":["as_mut_bstr","Real(LocalPath(\"src/bstring.rs\"))",""],"byteset::build_table":["build_table","Real(LocalPath(\"src/byteset/mod.rs\"))",""],"byteset::find":["find","Real(LocalPath(\"src/byteset/mod.rs\"))",""],"byteset::find_not":["find_not","Real(LocalPath(\"src/byteset/mod.rs\"))",""],"byteset::rfind":["rfind","Real(LocalPath(\"src/byteset/mod.rs\"))",""],"byteset::rfind_not":["rfind_not","Real(LocalPath(\"src/byteset/mod.rs\"))",""],"byteset::scalar::forward_search":["forward_search","Real(LocalPath(\"src/byteset/scalar.rs\"))",""],"byteset::scalar::forward_search_bytes":["forward_search_bytes","Real(LocalPath(\"src/byteset/scalar.rs\"))",""],"byteset::scalar::inv_memchr":["inv_memchr","Real(LocalPath(\"src/byteset/scalar.rs\"))",""],"byteset::scalar::inv_memrchr":["inv_memrchr","Real(LocalPath(\"src/byteset/scalar.rs\"))",""],"byteset::scalar::read_unaligned_usize":["read_unaligned_usize","Real(LocalPath(\"src/byteset/scalar.rs\"))",""],"byteset::scalar::repeat_byte":["repeat_byte","Real(LocalPath(\"src/byteset/scalar.rs\"))",""],"byteset::scalar::reverse_search":["reverse_search","Real(LocalPath(\"src/byteset/scalar.rs\"))",""],"byteset::scalar::reverse_search_bytes":["reverse_search_bytes","Real(LocalPath(\"src/byteset/scalar.rs\"))",""],"byteset::scalar::sub":["sub","Real(LocalPath(\"src/byteset/scalar.rs\"))",""],"cow::CowBytes::<'a>::as_slice":["as_slice","Real(LocalPath(\"src/cow.rs\"))",""],"cow::CowBytes::<'a>::into_owned":["into_owned","Real(LocalPath(\"src/cow.rs\"))",""],"cow::CowBytes::<'a>::new":["new","Real(LocalPath(\"src/cow.rs\"))",""],"cow::CowBytes::<'a>::new_owned":["new_owned","Real(LocalPath(\"src/cow.rs\"))",""],"cow::Imp::<'a>::as_slice":["as_slice","Real(LocalPath(\"src/cow.rs\"))",""],"cow::Imp::<'a>::new":["new","Real(LocalPath(\"src/cow.rs\"))",""],"ext_slice::B":["B","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::as_bstr":["as_bstr","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::as_bstr_mut":["as_bstr_mut","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::bytes":["bytes","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::char_indices":["char_indices","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::chars":["chars","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::contains_str":["contains_str","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::copy_within_str":["copy_within_str","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::ends_with_str":["ends_with_str","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::fields":["fields","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::fields_with":["fields_with","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::find":["find","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::find_byte":["find_byte","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::find_byteset":["find_byteset","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::find_char":["find_char","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::find_iter":["find_iter","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::find_non_ascii_byte":["find_non_ascii_byte","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::find_not_byteset":["find_not_byteset","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::from_os_str":["from_os_str","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::from_os_str::imp":["imp","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::from_path":["from_path","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::grapheme_indices":["grapheme_indices","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::graphemes":["graphemes","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::is_ascii":["is_ascii","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::is_utf8":["is_utf8","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::last_byte":["last_byte","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::lines":["lines","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::lines_with_terminator":["lines_with_terminator","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::make_ascii_lowercase":["make_ascii_lowercase","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::make_ascii_uppercase":["make_ascii_uppercase","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::repeatn":["repeatn","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::replace":["replace","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::replace_into":["replace_into","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::replacen":["replacen","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::replacen_into":["replacen_into","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::reverse_bytes":["reverse_bytes","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::reverse_chars":["reverse_chars","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::reverse_graphemes":["reverse_graphemes","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::rfind":["rfind","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::rfind_byte":["rfind_byte","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::rfind_byteset":["rfind_byteset","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::rfind_char":["rfind_char","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::rfind_iter":["rfind_iter","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::rfind_not_byteset":["rfind_not_byteset","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::rsplit_str":["rsplit_str","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::rsplitn_str":["rsplitn_str","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::sentence_indices":["sentence_indices","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::sentences":["sentences","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::split_str":["split_str","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::splitn_str":["splitn_str","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::starts_with_str":["starts_with_str","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_ascii_lowercase":["to_ascii_lowercase","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_ascii_uppercase":["to_ascii_uppercase","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_lowercase":["to_lowercase","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_lowercase_into":["to_lowercase_into","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_os_str":["to_os_str","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_os_str::imp":["imp","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_os_str_lossy":["to_os_str_lossy","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_os_str_lossy::imp":["imp","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_path":["to_path","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_path_lossy":["to_path_lossy","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_str":["to_str","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_str_lossy":["to_str_lossy","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_str_lossy_into":["to_str_lossy_into","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_str_unchecked":["to_str_unchecked","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_uppercase":["to_uppercase","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::to_uppercase_into":["to_uppercase_into","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::trim":["trim","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::trim_end":["trim_end","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::trim_end_with":["trim_end_with","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::trim_start":["trim_start","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::trim_start_with":["trim_start_with","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::trim_with":["trim_with","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::utf8_chunks":["utf8_chunks","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::word_indices":["word_indices","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::words":["words","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::words_with_break_indices":["words_with_break_indices","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::ByteSlice::words_with_breaks":["words_with_breaks","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::Bytes::<'a>::as_slice":["as_slice","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::Fields::<'a>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::FieldsWith::<'a, F>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::Find::<'a>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::FindReverse::<'a>::haystack":["haystack","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::FindReverse::<'a>::needle":["needle","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::FindReverse::<'a>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::Finder::<'a>::find":["find","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::Finder::<'a>::into_owned":["into_owned","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::Finder::<'a>::needle":["needle","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::Finder::<'a>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::FinderReverse::<'a>::into_owned":["into_owned","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::FinderReverse::<'a>::needle":["needle","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::FinderReverse::<'a>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::FinderReverse::<'a>::rfind":["rfind","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::Lines::<'a>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::LinesWithTerminator::<'a>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::Split::<'a>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::SplitN::<'a>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::SplitNReverse::<'a>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_slice::SplitReverse::<'a>::new":["new","Real(LocalPath(\"src/ext_slice.rs\"))",""],"ext_vec::ByteVec::drain_bytes":["drain_bytes","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::from_os_str_lossy":["from_os_str_lossy","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::from_os_str_lossy::imp":["imp","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::from_os_string":["from_os_string","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::from_os_string::imp":["imp","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::from_path_buf":["from_path_buf","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::from_path_lossy":["from_path_lossy","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::from_slice":["from_slice","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::insert_char":["insert_char","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::insert_str":["insert_str","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::into_os_string":["into_os_string","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::into_os_string::imp":["imp","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::into_os_string_lossy":["into_os_string_lossy","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::into_os_string_lossy::imp":["imp","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::into_path_buf":["into_path_buf","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::into_path_buf_lossy":["into_path_buf_lossy","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::into_string":["into_string","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::into_string_lossy":["into_string_lossy","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::into_string_unchecked":["into_string_unchecked","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::pop_byte":["pop_byte","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::pop_char":["pop_char","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::push_byte":["push_byte","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::push_char":["push_char","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::push_str":["push_str","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::remove_char":["remove_char","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::ByteVec::replace_range":["replace_range","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::FromUtf8Error::as_bytes":["as_bytes","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::FromUtf8Error::into_vec":["into_vec","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::FromUtf8Error::utf8_error":["utf8_error","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::concat":["concat","Real(LocalPath(\"src/ext_vec.rs\"))",""],"ext_vec::join":["join","Real(LocalPath(\"src/ext_vec.rs\"))",""],"impls::bstr::<impl lazy_static::__Deref for bstr::BStr>::deref":["deref","Real(LocalPath(\"src/impls.rs\"))","lazy_static::__Deref"],"impls::bstr::<impl std::cmp::Ord for bstr::BStr>::cmp":["cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::Ord"],"impls::bstr::<impl std::cmp::PartialEq for bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<&'a [u8]> for bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::borrow::Cow<'a, [u8]>>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::borrow::Cow<'a, bstr::BStr>>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::borrow::Cow<'a, str>>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::string::String>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<&'a bstr::BStr> for std::vec::Vec<u8>>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<&'a str> for bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<[u8]> for bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for &'a [u8]>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for &'a str>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for [u8]>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for std::string::String>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for std::vec::Vec<u8>>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<bstr::BStr> for str>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<std::borrow::Cow<'a, [u8]>> for &'a bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<std::borrow::Cow<'a, bstr::BStr>> for &'a bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<std::borrow::Cow<'a, str>> for &'a bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<std::string::String> for &'a bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<std::string::String> for bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<std::vec::Vec<u8>> for &'a bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<std::vec::Vec<u8>> for bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialEq<str> for bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstr::<impl std::cmp::PartialOrd for bstr::BStr>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<&'a [u8]> for bstr::BStr>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<&'a bstr::BStr> for std::string::String>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<&'a bstr::BStr> for std::vec::Vec<u8>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<&'a str> for bstr::BStr>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<[u8]> for bstr::BStr>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for &'a [u8]>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for &'a str>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for [u8]>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for std::string::String>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for std::vec::Vec<u8>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<bstr::BStr> for str>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<std::string::String> for &'a bstr::BStr>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<std::string::String> for bstr::BStr>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<std::vec::Vec<u8>> for &'a bstr::BStr>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<std::vec::Vec<u8>> for bstr::BStr>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::cmp::PartialOrd<str> for bstr::BStr>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstr::<impl std::convert::AsMut<[u8]> for bstr::BStr>::as_mut":["as_mut","Real(LocalPath(\"src/impls.rs\"))","std::convert::AsMut"],"impls::bstr::<impl std::convert::AsMut<bstr::BStr> for [u8]>::as_mut":["as_mut","Real(LocalPath(\"src/impls.rs\"))","std::convert::AsMut"],"impls::bstr::<impl std::convert::AsRef<[u8]> for bstr::BStr>::as_ref":["as_ref","Real(LocalPath(\"src/impls.rs\"))","std::convert::AsRef"],"impls::bstr::<impl std::convert::AsRef<bstr::BStr> for [u8]>::as_ref":["as_ref","Real(LocalPath(\"src/impls.rs\"))","std::convert::AsRef"],"impls::bstr::<impl std::convert::AsRef<bstr::BStr> for str>::as_ref":["as_ref","Real(LocalPath(\"src/impls.rs\"))","std::convert::AsRef"],"impls::bstr::<impl std::convert::From<&'a [u8]> for &'a bstr::BStr>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstr::<impl std::convert::From<&'a bstr::BStr> for std::borrow::Cow<'a, bstr::BStr>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstr::<impl std::convert::From<&'a str> for &'a bstr::BStr>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstr::<impl std::convert::From<std::boxed::Box<[u8]>> for std::boxed::Box<bstr::BStr>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstr::<impl std::convert::From<std::boxed::Box<bstr::BStr>> for std::boxed::Box<[u8]>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstr::<impl std::default::Default for &'a bstr::BStr>::default":["default","Real(LocalPath(\"src/impls.rs\"))","std::default::Default"],"impls::bstr::<impl std::default::Default for &'a mut bstr::BStr>::default":["default","Real(LocalPath(\"src/impls.rs\"))","std::default::Default"],"impls::bstr::<impl std::fmt::Debug for bstr::BStr>::fmt":["fmt","Real(LocalPath(\"src/impls.rs\"))","std::fmt::Debug"],"impls::bstr::<impl std::fmt::Display for bstr::BStr>::fmt":["fmt","Real(LocalPath(\"src/impls.rs\"))","std::fmt::Display"],"impls::bstr::<impl std::fmt::Display for bstr::BStr>::fmt::write_bstr":["write_bstr","Real(LocalPath(\"src/impls.rs\"))",""],"impls::bstr::<impl std::fmt::Display for bstr::BStr>::fmt::write_pads":["write_pads","Real(LocalPath(\"src/impls.rs\"))",""],"impls::bstr::<impl std::ops::DerefMut for bstr::BStr>::deref_mut":["deref_mut","Real(LocalPath(\"src/impls.rs\"))","std::ops::DerefMut"],"impls::bstr::<impl std::ops::Index<std::ops::Range<usize>> for bstr::BStr>::index":["index","Real(LocalPath(\"src/impls.rs\"))","std::ops::Index"],"impls::bstr::<impl std::ops::Index<std::ops::RangeFrom<usize>> for bstr::BStr>::index":["index","Real(LocalPath(\"src/impls.rs\"))","std::ops::Index"],"impls::bstr::<impl std::ops::Index<std::ops::RangeFull> for bstr::BStr>::index":["index","Real(LocalPath(\"src/impls.rs\"))","std::ops::Index"],"impls::bstr::<impl std::ops::Index<std::ops::RangeInclusive<usize>> for bstr::BStr>::index":["index","Real(LocalPath(\"src/impls.rs\"))","std::ops::Index"],"impls::bstr::<impl std::ops::Index<std::ops::RangeTo<usize>> for bstr::BStr>::index":["index","Real(LocalPath(\"src/impls.rs\"))","std::ops::Index"],"impls::bstr::<impl std::ops::Index<std::ops::RangeToInclusive<usize>> for bstr::BStr>::index":["index","Real(LocalPath(\"src/impls.rs\"))","std::ops::Index"],"impls::bstr::<impl std::ops::Index<usize> for bstr::BStr>::index":["index","Real(LocalPath(\"src/impls.rs\"))","std::ops::Index"],"impls::bstr::<impl std::ops::IndexMut<std::ops::Range<usize>> for bstr::BStr>::index_mut":["index_mut","Real(LocalPath(\"src/impls.rs\"))","std::ops::IndexMut"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeFrom<usize>> for bstr::BStr>::index_mut":["index_mut","Real(LocalPath(\"src/impls.rs\"))","std::ops::IndexMut"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeFull> for bstr::BStr>::index_mut":["index_mut","Real(LocalPath(\"src/impls.rs\"))","std::ops::IndexMut"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeInclusive<usize>> for bstr::BStr>::index_mut":["index_mut","Real(LocalPath(\"src/impls.rs\"))","std::ops::IndexMut"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeTo<usize>> for bstr::BStr>::index_mut":["index_mut","Real(LocalPath(\"src/impls.rs\"))","std::ops::IndexMut"],"impls::bstr::<impl std::ops::IndexMut<std::ops::RangeToInclusive<usize>> for bstr::BStr>::index_mut":["index_mut","Real(LocalPath(\"src/impls.rs\"))","std::ops::IndexMut"],"impls::bstr::<impl std::ops::IndexMut<usize> for bstr::BStr>::index_mut":["index_mut","Real(LocalPath(\"src/impls.rs\"))","std::ops::IndexMut"],"impls::bstring::<impl lazy_static::__Deref for bstring::BString>::deref":["deref","Real(LocalPath(\"src/impls.rs\"))","lazy_static::__Deref"],"impls::bstring::<impl std::borrow::Borrow<bstr::BStr> for bstring::BString>::borrow":["borrow","Real(LocalPath(\"src/impls.rs\"))","std::borrow::Borrow"],"impls::bstring::<impl std::borrow::ToOwned for bstr::BStr>::to_owned":["to_owned","Real(LocalPath(\"src/impls.rs\"))","std::borrow::ToOwned"],"impls::bstring::<impl std::cmp::Ord for bstring::BString>::cmp":["cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::Ord"],"impls::bstring::<impl std::cmp::PartialEq for bstring::BString>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<&'a [u8]> for bstring::BString>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<&'a bstr::BStr> for bstring::BString>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<&'a str> for bstring::BString>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<[u8]> for bstring::BString>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<bstr::BStr> for bstring::BString>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for &'a [u8]>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for &'a bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for &'a str>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for [u8]>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for bstr::BStr>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for std::string::String>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for std::vec::Vec<u8>>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<bstring::BString> for str>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<std::string::String> for bstring::BString>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<std::vec::Vec<u8>> for bstring::BString>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialEq<str> for bstring::BString>::eq":["eq","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialEq"],"impls::bstring::<impl std::cmp::PartialOrd for bstring::BString>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<&'a [u8]> for bstring::BString>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<&'a bstr::BStr> for bstring::BString>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<&'a str> for bstring::BString>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<[u8]> for bstring::BString>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<bstr::BStr> for bstring::BString>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for &'a [u8]>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for &'a bstr::BStr>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for &'a str>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for [u8]>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for bstr::BStr>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for std::string::String>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for std::vec::Vec<u8>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<bstring::BString> for str>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<std::string::String> for bstring::BString>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<std::vec::Vec<u8>> for bstring::BString>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::cmp::PartialOrd<str> for bstring::BString>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/impls.rs\"))","std::cmp::PartialOrd"],"impls::bstring::<impl std::convert::AsMut<[u8]> for bstring::BString>::as_mut":["as_mut","Real(LocalPath(\"src/impls.rs\"))","std::convert::AsMut"],"impls::bstring::<impl std::convert::AsMut<bstr::BStr> for bstring::BString>::as_mut":["as_mut","Real(LocalPath(\"src/impls.rs\"))","std::convert::AsMut"],"impls::bstring::<impl std::convert::AsRef<[u8]> for bstring::BString>::as_ref":["as_ref","Real(LocalPath(\"src/impls.rs\"))","std::convert::AsRef"],"impls::bstring::<impl std::convert::AsRef<bstr::BStr> for bstring::BString>::as_ref":["as_ref","Real(LocalPath(\"src/impls.rs\"))","std::convert::AsRef"],"impls::bstring::<impl std::convert::From<&'a [u8]> for bstring::BString>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstring::<impl std::convert::From<&'a bstr::BStr> for bstring::BString>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstring::<impl std::convert::From<&'a str> for bstring::BString>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstring::<impl std::convert::From<bstring::BString> for std::borrow::Cow<'a, bstr::BStr>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstring::<impl std::convert::From<bstring::BString> for std::vec::Vec<u8>>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstring::<impl std::convert::From<std::string::String> for bstring::BString>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstring::<impl std::convert::From<std::vec::Vec<u8>> for bstring::BString>::from":["from","Real(LocalPath(\"src/impls.rs\"))","std::convert::From"],"impls::bstring::<impl std::default::Default for bstring::BString>::default":["default","Real(LocalPath(\"src/impls.rs\"))","std::default::Default"],"impls::bstring::<impl std::fmt::Debug for bstring::BString>::fmt":["fmt","Real(LocalPath(\"src/impls.rs\"))","std::fmt::Debug"],"impls::bstring::<impl std::fmt::Display for bstring::BString>::fmt":["fmt","Real(LocalPath(\"src/impls.rs\"))","std::fmt::Display"],"impls::bstring::<impl std::iter::FromIterator<&'a [u8]> for bstring::BString>::from_iter":["from_iter","Real(LocalPath(\"src/impls.rs\"))","std::iter::FromIterator"],"impls::bstring::<impl std::iter::FromIterator<&'a bstr::BStr> for bstring::BString>::from_iter":["from_iter","Real(LocalPath(\"src/impls.rs\"))","std::iter::FromIterator"],"impls::bstring::<impl std::iter::FromIterator<&'a str> for bstring::BString>::from_iter":["from_iter","Real(LocalPath(\"src/impls.rs\"))","std::iter::FromIterator"],"impls::bstring::<impl std::iter::FromIterator<bstring::BString> for bstring::BString>::from_iter":["from_iter","Real(LocalPath(\"src/impls.rs\"))","std::iter::FromIterator"],"impls::bstring::<impl std::iter::FromIterator<char> for bstring::BString>::from_iter":["from_iter","Real(LocalPath(\"src/impls.rs\"))","std::iter::FromIterator"],"impls::bstring::<impl std::iter::FromIterator<u8> for bstring::BString>::from_iter":["from_iter","Real(LocalPath(\"src/impls.rs\"))","std::iter::FromIterator"],"impls::bstring::<impl std::ops::DerefMut for bstring::BString>::deref_mut":["deref_mut","Real(LocalPath(\"src/impls.rs\"))","std::ops::DerefMut"],"io::BufReadExt::byte_lines":["byte_lines","Real(LocalPath(\"src/io.rs\"))",""],"io::BufReadExt::byte_records":["byte_records","Real(LocalPath(\"src/io.rs\"))",""],"io::BufReadExt::for_byte_line":["for_byte_line","Real(LocalPath(\"src/io.rs\"))",""],"io::BufReadExt::for_byte_line_with_terminator":["for_byte_line_with_terminator","Real(LocalPath(\"src/io.rs\"))",""],"io::BufReadExt::for_byte_record":["for_byte_record","Real(LocalPath(\"src/io.rs\"))",""],"io::BufReadExt::for_byte_record_with_terminator":["for_byte_record_with_terminator","Real(LocalPath(\"src/io.rs\"))",""],"io::trim_line":["trim_line","Real(LocalPath(\"src/io.rs\"))",""],"io::trim_line_slice":["trim_line_slice","Real(LocalPath(\"src/io.rs\"))",""],"io::trim_record":["trim_record","Real(LocalPath(\"src/io.rs\"))",""],"io::trim_record_slice":["trim_record_slice","Real(LocalPath(\"src/io.rs\"))",""],"search::prefilter::Freqy::find_candidate":["find_candidate","Real(LocalPath(\"src/search/prefilter.rs\"))",""],"search::prefilter::Freqy::forward":["forward","Real(LocalPath(\"src/search/prefilter.rs\"))",""],"search::prefilter::Freqy::inert":["inert","Real(LocalPath(\"src/search/prefilter.rs\"))",""],"search::prefilter::Freqy::prefilter_state":["prefilter_state","Real(LocalPath(\"src/search/prefilter.rs\"))",""],"search::prefilter::Freqy::rank":["rank","Real(LocalPath(\"src/search/prefilter.rs\"))",""],"search::prefilter::Freqy::reverse":["reverse","Real(LocalPath(\"src/search/prefilter.rs\"))",""],"search::prefilter::Freqy::rfind_candidate":["rfind_candidate","Real(LocalPath(\"src/search/prefilter.rs\"))",""],"search::prefilter::PrefilterState::inert":["inert","Real(LocalPath(\"src/search/prefilter.rs\"))",""],"search::prefilter::PrefilterState::is_effective":["is_effective","Real(LocalPath(\"src/search/prefilter.rs\"))",""],"search::prefilter::PrefilterState::new":["new","Real(LocalPath(\"src/search/prefilter.rs\"))",""],"search::prefilter::PrefilterState::update":["update","Real(LocalPath(\"src/search/prefilter.rs\"))",""],"search::twoway::Shift::forward":["forward","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::Shift::reverse":["reverse","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::Suffix::forward":["forward","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::Suffix::reverse":["reverse","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::SuffixKind::cmp":["cmp","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::find":["find","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::find_large":["find_large","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::find_large_imp":["find_large_imp","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::find_small":["find_small","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::find_small_imp":["find_small_imp","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::find_with":["find_with","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::forward":["forward","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::into_owned":["into_owned","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::needle":["needle","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::prefilter_state":["prefilter_state","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::reverse":["reverse","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::rfind":["rfind","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::rfind_large":["rfind_large","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::rfind_large_imp":["rfind_large_imp","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::rfind_small":["rfind_small","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::rfind_small_imp":["rfind_small_imp","Real(LocalPath(\"src/search/twoway.rs\"))",""],"search::twoway::TwoWay::<'b>::rfind_with":["rfind_with","Real(LocalPath(\"src/search/twoway.rs\"))",""],"unicode::grapheme::GraphemeIndices::<'a>::as_bytes":["as_bytes","Real(LocalPath(\"src/unicode/grapheme.rs\"))",""],"unicode::grapheme::GraphemeIndices::<'a>::new":["new","Real(LocalPath(\"src/unicode/grapheme.rs\"))",""],"unicode::grapheme::Graphemes::<'a>::as_bytes":["as_bytes","Real(LocalPath(\"src/unicode/grapheme.rs\"))",""],"unicode::grapheme::Graphemes::<'a>::new":["new","Real(LocalPath(\"src/unicode/grapheme.rs\"))",""],"unicode::grapheme::adjust_rev_for_regional_indicator":["adjust_rev_for_regional_indicator","Real(LocalPath(\"src/unicode/grapheme.rs\"))",""],"unicode::grapheme::decode_grapheme":["decode_grapheme","Real(LocalPath(\"src/unicode/grapheme.rs\"))",""],"unicode::grapheme::decode_last_grapheme":["decode_last_grapheme","Real(LocalPath(\"src/unicode/grapheme.rs\"))",""],"unicode::sentence::SentenceIndices::<'a>::as_bytes":["as_bytes","Real(LocalPath(\"src/unicode/sentence.rs\"))",""],"unicode::sentence::SentenceIndices::<'a>::new":["new","Real(LocalPath(\"src/unicode/sentence.rs\"))",""],"unicode::sentence::Sentences::<'a>::as_bytes":["as_bytes","Real(LocalPath(\"src/unicode/sentence.rs\"))",""],"unicode::sentence::Sentences::<'a>::new":["new","Real(LocalPath(\"src/unicode/sentence.rs\"))",""],"unicode::sentence::decode_sentence":["decode_sentence","Real(LocalPath(\"src/unicode/sentence.rs\"))",""],"unicode::whitespace::whitespace_len_fwd":["whitespace_len_fwd","Real(LocalPath(\"src/unicode/whitespace.rs\"))",""],"unicode::whitespace::whitespace_len_rev":["whitespace_len_rev","Real(LocalPath(\"src/unicode/whitespace.rs\"))",""],"unicode::word::WordIndices::<'a>::as_bytes":["as_bytes","Real(LocalPath(\"src/unicode/word.rs\"))",""],"unicode::word::WordIndices::<'a>::new":["new","Real(LocalPath(\"src/unicode/word.rs\"))",""],"unicode::word::Words::<'a>::as_bytes":["as_bytes","Real(LocalPath(\"src/unicode/word.rs\"))",""],"unicode::word::Words::<'a>::new":["new","Real(LocalPath(\"src/unicode/word.rs\"))",""],"unicode::word::WordsWithBreakIndices::<'a>::as_bytes":["as_bytes","Real(LocalPath(\"src/unicode/word.rs\"))",""],"unicode::word::WordsWithBreakIndices::<'a>::new":["new","Real(LocalPath(\"src/unicode/word.rs\"))",""],"unicode::word::WordsWithBreaks::<'a>::as_bytes":["as_bytes","Real(LocalPath(\"src/unicode/word.rs\"))",""],"unicode::word::WordsWithBreaks::<'a>::new":["new","Real(LocalPath(\"src/unicode/word.rs\"))",""],"unicode::word::decode_word":["decode_word","Real(LocalPath(\"src/unicode/word.rs\"))",""],"utf8::CharIndices::<'a>::as_bytes":["as_bytes","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::CharIndices::<'a>::new":["new","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Chars::<'a>::as_bytes":["as_bytes","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Chars::<'a>::new":["new","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Chunk::<'a>::incomplete":["incomplete","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Chunk::<'a>::invalid":["invalid","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Chunk::<'a>::valid":["valid","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Error::error_len":["error_len","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Error::valid_up_to":["valid_up_to","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::decode":["decode","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::decode_last":["decode_last","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::decode_last_lossy":["decode_last_lossy","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::decode_lossy":["decode_lossy","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::decode_step":["decode_step","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::is_leading_or_invalid_utf8_byte":["is_leading_or_invalid_utf8_byte","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::validate":["validate","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::validate::fast":["fast","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::validate::find_valid_up_to":["find_valid_up_to","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::validate::slow":["slow","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::validate::step":["step","Real(LocalPath(\"src/utf8.rs\"))",""]},"trait_to_struct":{"ext_vec::ByteVec":["std::vec::Vec"],"ext_vec::Sealed":["std::vec::Vec"],"io::BufReadExt":["<B as io::BufReadExt>::B"],"lazy_static::LazyStatic":["unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD","unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV","unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV","unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD","unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD","unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD","unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV","unicode::fsm::word_break_fwd::WORD_BREAK_FWD"],"lazy_static::__Deref":["bstr::BStr","bstring::BString","cow::CowBytes","unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD","unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV","unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV","unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD","unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD","unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD","unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV","unicode::fsm::word_break_fwd::WORD_BREAK_FWD"],"std::borrow::Borrow":["bstring::BString"],"std::borrow::ToOwned":["bstr::BStr"],"std::clone::Clone":["bstring::BString","cow::CowBytes","cow::Imp","ext_slice::Bytes","ext_slice::Finder","ext_slice::FinderReverse","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::SuffixKind","search::twoway::SuffixOrdering","search::twoway::TwoWay","unicode::grapheme::GraphemeIndices","unicode::grapheme::Graphemes","unicode::sentence::SentenceIndices","unicode::sentence::Sentences","unicode::word::WordIndices","unicode::word::Words","unicode::word::WordsWithBreakIndices","unicode::word::WordsWithBreaks","utf8::CharIndices","utf8::Chars","utf8::Utf8Chunks"],"std::cmp::Eq":["bstr::BStr","bstring::BString","ext_vec::FromUtf8Error","utf8::Utf8Error"],"std::cmp::Ord":["bstr::BStr","bstring::BString"],"std::cmp::PartialEq":["bstr::BStr","bstring::BString","ext_vec::FromUtf8Error","std::borrow::Cow","std::string::String","std::vec::Vec","utf8::Utf8Error"],"std::cmp::PartialOrd":["bstr::BStr","bstring::BString","std::string::String","std::vec::Vec"],"std::convert::AsMut":["bstr::BStr","bstring::BString"],"std::convert::AsRef":["bstr::BStr","bstring::BString"],"std::convert::From":["bstring::BString","std::borrow::Cow","std::boxed::Box","std::vec::Vec"],"std::default::Default":["bstring::BString"],"std::error::Error":["ext_vec::FromUtf8Error","utf8::Utf8Error"],"std::fmt::Debug":["bstr::BStr","bstring::BString","cow::CowBytes","cow::Imp","ext_slice::Bytes","ext_slice::Fields","ext_slice::FieldsWith","ext_slice::Find","ext_slice::FindReverse","ext_slice::Finder","ext_slice::FinderReverse","ext_slice::Split","ext_slice::SplitN","ext_slice::SplitNReverse","ext_slice::SplitReverse","ext_vec::DrainBytes","ext_vec::FromUtf8Error","io::ByteLines","io::ByteRecords","search::prefilter::Freqy","search::prefilter::PrefilterState","search::twoway::Shift","search::twoway::Suffix","search::twoway::SuffixKind","search::twoway::SuffixOrdering","search::twoway::TwoWay","unicode::grapheme::GraphemeIndices","unicode::grapheme::Graphemes","unicode::sentence::SentenceIndices","unicode::sentence::Sentences","unicode::word::WordIndices","unicode::word::Words","unicode::word::WordsWithBreakIndices","unicode::word::WordsWithBreaks","utf8::CharIndices","utf8::Chars","utf8::Utf8Chunks","utf8::Utf8Error"],"std::fmt::Display":["bstr::BStr","bstring::BString","ext_vec::FromUtf8Error","utf8::Utf8Error"],"std::hash::Hash":["bstr::BStr","bstring::BString"],"std::iter::DoubleEndedIterator":["ext_slice::Bytes","ext_vec::DrainBytes","unicode::grapheme::GraphemeIndices","unicode::grapheme::Graphemes","utf8::CharIndices","utf8::Chars"],"std::iter::ExactSizeIterator":["ext_slice::Bytes","ext_vec::DrainBytes"],"std::iter::FromIterator":["bstring::BString"],"std::iter::FusedIterator":["ext_slice::Bytes","ext_vec::DrainBytes","utf8::CharIndices","utf8::Utf8Chunks"],"std::iter::Iterator":["ext_slice::Bytes","ext_slice::Fields","ext_slice::FieldsWith","ext_slice::Find","ext_slice::FindReverse","ext_slice::Lines","ext_slice::LinesWithTerminator","ext_slice::Split","ext_slice::SplitN","ext_slice::SplitNReverse","ext_slice::SplitReverse","ext_vec::DrainBytes","io::ByteLines","io::ByteRecords","unicode::grapheme::GraphemeIndices","unicode::grapheme::Graphemes","unicode::sentence::SentenceIndices","unicode::sentence::Sentences","unicode::word::WordIndices","unicode::word::Words","unicode::word::WordsWithBreakIndices","unicode::word::WordsWithBreaks","utf8::CharIndices","utf8::Chars","utf8::Utf8Chunks"],"std::marker::Copy":["search::twoway::SuffixKind","search::twoway::SuffixOrdering"],"std::marker::StructuralEq":["ext_vec::FromUtf8Error","utf8::Utf8Error"],"std::marker::StructuralPartialEq":["ext_vec::FromUtf8Error","utf8::Utf8Error"],"std::ops::DerefMut":["bstr::BStr","bstring::BString"],"std::ops::Index":["bstr::BStr"],"std::ops::IndexMut":["bstr::BStr"]},"type_to_def_path":{"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned<B>":"<unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned","<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned<B>":"<unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned","<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned<B>":"<unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned","<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned<B>":"<unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned","<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned<B>":"<unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned","<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned<B>":"<unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned","<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned<B>":"<unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned","<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned<B>":"<unicode::fsm::word_break_fwd::WORD_BREAK_FWD as lazy_static::__Deref>::deref::__static_ref_initialize::Aligned","bstr::BStr":"bstr::BStr","bstring::BString":"bstring::BString","cow::CowBytes<'a>":"cow::CowBytes","cow::Imp<'a>":"cow::Imp","ext_slice::Bytes<'a>":"ext_slice::Bytes","ext_slice::Fields<'a>":"ext_slice::Fields","ext_slice::FieldsWith<'a, F>":"ext_slice::FieldsWith","ext_slice::Find<'a>":"ext_slice::Find","ext_slice::FindReverse<'a>":"ext_slice::FindReverse","ext_slice::Finder<'a>":"ext_slice::Finder","ext_slice::FinderReverse<'a>":"ext_slice::FinderReverse","ext_slice::Lines<'a>":"ext_slice::Lines","ext_slice::LinesWithTerminator<'a>":"ext_slice::LinesWithTerminator","ext_slice::Split<'a>":"ext_slice::Split","ext_slice::SplitN<'a>":"ext_slice::SplitN","ext_slice::SplitNReverse<'a>":"ext_slice::SplitNReverse","ext_slice::SplitReverse<'a>":"ext_slice::SplitReverse","ext_vec::DrainBytes<'a>":"ext_vec::DrainBytes","ext_vec::FromUtf8Error":"ext_vec::FromUtf8Error","io::ByteLines<B>":"io::ByteLines","io::ByteRecords<B>":"io::ByteRecords","search::prefilter::Freqy":"search::prefilter::Freqy","search::prefilter::PrefilterState":"search::prefilter::PrefilterState","search::twoway::Shift":"search::twoway::Shift","search::twoway::Suffix":"search::twoway::Suffix","search::twoway::SuffixKind":"search::twoway::SuffixKind","search::twoway::SuffixOrdering":"search::twoway::SuffixOrdering","search::twoway::TwoWay<'b>":"search::twoway::TwoWay","unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD":"unicode::fsm::grapheme_break_fwd::GRAPHEME_BREAK_FWD","unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV":"unicode::fsm::grapheme_break_rev::GRAPHEME_BREAK_REV","unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV":"unicode::fsm::regional_indicator_rev::REGIONAL_INDICATOR_REV","unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD":"unicode::fsm::sentence_break_fwd::SENTENCE_BREAK_FWD","unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD":"unicode::fsm::simple_word_fwd::SIMPLE_WORD_FWD","unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD":"unicode::fsm::whitespace_anchored_fwd::WHITESPACE_ANCHORED_FWD","unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV":"unicode::fsm::whitespace_anchored_rev::WHITESPACE_ANCHORED_REV","unicode::fsm::word_break_fwd::WORD_BREAK_FWD":"unicode::fsm::word_break_fwd::WORD_BREAK_FWD","unicode::grapheme::GraphemeIndices<'a>":"unicode::grapheme::GraphemeIndices","unicode::grapheme::Graphemes<'a>":"unicode::grapheme::Graphemes","unicode::sentence::SentenceIndices<'a>":"unicode::sentence::SentenceIndices","unicode::sentence::Sentences<'a>":"unicode::sentence::Sentences","unicode::word::WordIndices<'a>":"unicode::word::WordIndices","unicode::word::Words<'a>":"unicode::word::Words","unicode::word::WordsWithBreakIndices<'a>":"unicode::word::WordsWithBreakIndices","unicode::word::WordsWithBreaks<'a>":"unicode::word::WordsWithBreaks","utf8::CharIndices<'a>":"utf8::CharIndices","utf8::Chars<'a>":"utf8::Chars","utf8::Utf8Chunk<'a>":"utf8::Utf8Chunk","utf8::Utf8Chunks<'a>":"utf8::Utf8Chunks","utf8::Utf8Error":"utf8::Utf8Error"}}