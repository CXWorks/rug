{"dependencies":{"<BomHandling as std::clone::Clone>::clone":["BomHandling"],"<BomHandling as std::fmt::Debug>::fmt":["BomHandling","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<CoderResult as std::cmp::Eq>::assert_receiver_is_total_eq":["CoderResult"],"<CoderResult as std::cmp::PartialEq>::eq":["CoderResult"],"<CoderResult as std::fmt::Debug>::fmt":["CoderResult","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<DecoderLifeCycle as std::clone::Clone>::clone":["DecoderLifeCycle"],"<DecoderLifeCycle as std::cmp::PartialEq>::eq":["DecoderLifeCycle"],"<DecoderLifeCycle as std::fmt::Debug>::fmt":["DecoderLifeCycle","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<DecoderResult as std::cmp::Eq>::assert_receiver_is_total_eq":["DecoderResult"],"<DecoderResult as std::cmp::PartialEq>::eq":["DecoderResult"],"<DecoderResult as std::fmt::Debug>::fmt":["DecoderResult","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<EncoderResult as std::cmp::Eq>::assert_receiver_is_total_eq":["EncoderResult"],"<EncoderResult as std::cmp::PartialEq>::eq":["EncoderResult"],"<EncoderResult as std::fmt::Debug>::fmt":["EncoderResult","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<Encoding as std::cmp::PartialEq>::eq":["Encoding","variant::VariantEncoding"],"<Encoding as std::fmt::Debug>::fmt":["Encoding","std::fmt::Formatter","std::marker::Sized","std::result::Result","variant::VariantEncoding"],"<Encoding as std::hash::Hash>::hash":["Encoding","std::hash::Hasher","std::marker::Sized","variant::VariantEncoding"],"<handles::UnalignedU16Slice as std::clone::Clone>::clone":["handles::UnalignedU16Slice"],"<handles::UnalignedU16Slice as std::fmt::Debug>::fmt":["handles::UnalignedU16Slice","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<iso_2022_jp::Iso2022JpDecoderState as std::clone::Clone>::clone":["iso_2022_jp::Iso2022JpDecoderState"],"<iso_2022_jp::Iso2022JpDecoderState as std::cmp::PartialEq>::eq":["iso_2022_jp::Iso2022JpDecoderState"],"<mem::Latin1Bidi as std::cmp::Eq>::assert_receiver_is_total_eq":["mem::Latin1Bidi"],"<mem::Latin1Bidi as std::cmp::PartialEq>::eq":["mem::Latin1Bidi"],"<mem::Latin1Bidi as std::fmt::Debug>::fmt":["mem::Latin1Bidi","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"BomHandling":["BomHandling"],"CoderResult":["CoderResult"],"Decoder":["Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_str":["CoderResult","Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_str_without_replacement":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_string":["CoderResult","Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","std::string::String","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_string_without_replacement":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","std::string::String","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf16":["CoderResult","Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf16_after_one_potential_bom_byte":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf16_after_two_potential_bom_bytes":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf16_checking_end":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf16_checking_end_with_offset":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf16_without_replacement":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf8":["CoderResult","Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf8_after_one_potential_bom_byte":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf8_after_two_potential_bom_bytes":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf8_checking_end":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf8_checking_end_with_offset":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::decode_to_utf8_without_replacement":["Decoder","DecoderLifeCycle","DecoderResult","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::encoding":["Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::latin1_byte_compatible_up_to":["Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::max_utf16_buffer_length":["Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::max_utf8_buffer_length":["Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::max_utf8_buffer_length_without_replacement":["Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Decoder::new":["BomHandling","Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"DecoderLifeCycle":["DecoderLifeCycle"],"DecoderResult":["DecoderResult"],"Encoder":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::encode_from_utf16":["CoderResult","Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::encode_from_utf16_without_replacement":["Encoder","EncoderResult","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::encode_from_utf8":["CoderResult","Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::encode_from_utf8_to_vec":["CoderResult","Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::encode_from_utf8_to_vec_without_replacement":["Encoder","EncoderResult","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::encode_from_utf8_without_replacement":["Encoder","EncoderResult","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::encoding":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::has_pending_state":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::max_buffer_length_from_utf16_if_no_unmappables":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","std::marker::Sized","std::option::Option","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::max_buffer_length_from_utf16_without_replacement":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","std::marker::Sized","std::option::Option","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::max_buffer_length_from_utf8_if_no_unmappables":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","std::marker::Sized","std::option::Option","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::max_buffer_length_from_utf8_without_replacement":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","std::marker::Sized","std::option::Option","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoder::new":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"EncoderResult":["EncoderResult"],"EncoderResult::unmappable_from_bmp":["EncoderResult"],"Encoding":["Encoding","variant::VariantEncoding"],"Encoding::ascii_valid_up_to":[],"Encoding::can_encode_everything":["Encoding","variant::VariantEncoding"],"Encoding::decode":["Encoding","std::borrow::Cow","std::borrow::ToOwned","variant::VariantEncoding"],"Encoding::decode_with_bom_removal":["Encoding","std::borrow::Cow","std::borrow::ToOwned","variant::VariantEncoding"],"Encoding::decode_without_bom_handling":["Encoding","std::borrow::Cow","std::borrow::ToOwned","variant::VariantEncoding"],"Encoding::decode_without_bom_handling_and_without_replacement":["Encoding","std::marker::Sized","std::option::Option","variant::VariantEncoding"],"Encoding::encode":["Encoding","std::borrow::Cow","std::borrow::ToOwned","variant::VariantEncoding"],"Encoding::for_bom":["std::marker::Sized","std::option::Option"],"Encoding::for_label":["std::marker::Sized","std::option::Option"],"Encoding::for_label_no_replacement":["std::marker::Sized","std::option::Option"],"Encoding::is_ascii_compatible":["Encoding","variant::VariantEncoding"],"Encoding::is_potentially_borrowable":["Encoding","variant::VariantEncoding"],"Encoding::is_single_byte":["Encoding","variant::VariantEncoding"],"Encoding::iso_2022_jp_ascii_valid_up_to":[],"Encoding::name":["Encoding","variant::VariantEncoding"],"Encoding::new_decoder":["Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Encoding::new_decoder_with_bom_removal":["Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Encoding::new_decoder_without_bom_handling":["Decoder","DecoderLifeCycle","Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Encoding::new_encoder":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"Encoding::new_variant_decoder":["Encoding","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"Encoding::output_encoding":["Encoding","variant::VariantEncoding"],"Encoding::utf8_valid_up_to":[],"ascii::ascii_to_ascii":["std::marker::Sized","std::option::Option"],"ascii::ascii_to_ascii_stride":["std::marker::Sized","std::option::Option"],"ascii::ascii_to_basic_latin":["std::marker::Sized","std::option::Option"],"ascii::ascii_to_basic_latin_stride_alu":[],"ascii::ascii_valid_up_to":[],"ascii::basic_latin_to_ascii":["std::marker::Sized","std::option::Option"],"ascii::basic_latin_to_ascii_stride_alu":[],"ascii::count_zeros":[],"ascii::find_non_ascii":["std::marker::Sized","std::option::Option"],"ascii::iso_2022_jp_ascii_valid_up_to":[],"ascii::likely":[],"ascii::pack_alu":[],"ascii::pack_latin1":[],"ascii::pack_latin1_stride_alu":[],"ascii::unlikely":[],"ascii::unpack_alu":[],"ascii::unpack_latin1":[],"ascii::unpack_latin1_stride_alu":[],"ascii::validate_ascii":["std::marker::Sized","std::option::Option"],"ascii::validate_ascii_stride":["std::marker::Sized","std::option::Option"],"big5::Big5Decoder":["big5::Big5Decoder","std::marker::Sized","std::option::Option"],"big5::Big5Decoder::decode_to_utf16_raw":["DecoderResult","big5::Big5Decoder","std::marker::Sized","std::option::Option"],"big5::Big5Decoder::decode_to_utf8_raw":["DecoderResult","big5::Big5Decoder","std::marker::Sized","std::option::Option"],"big5::Big5Decoder::in_neutral_state":["big5::Big5Decoder","std::marker::Sized","std::option::Option"],"big5::Big5Decoder::max_utf16_buffer_length":["big5::Big5Decoder","std::marker::Sized","std::option::Option"],"big5::Big5Decoder::max_utf8_buffer_length":["big5::Big5Decoder","std::marker::Sized","std::option::Option"],"big5::Big5Decoder::max_utf8_buffer_length_without_replacement":["big5::Big5Decoder","std::marker::Sized","std::option::Option"],"big5::Big5Decoder::new":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"big5::Big5Decoder::plus_one_if_lead":["big5::Big5Decoder","std::marker::Sized","std::option::Option"],"big5::Big5Encoder":["big5::Big5Encoder"],"big5::Big5Encoder::encode_from_utf16_raw":["EncoderResult","big5::Big5Encoder"],"big5::Big5Encoder::encode_from_utf8_raw":["EncoderResult","big5::Big5Encoder"],"big5::Big5Encoder::max_buffer_length_from_utf16_without_replacement":["big5::Big5Encoder","std::marker::Sized","std::option::Option"],"big5::Big5Encoder::max_buffer_length_from_utf8_without_replacement":["big5::Big5Encoder","std::marker::Sized","std::option::Option"],"big5::Big5Encoder::new":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"checked_add":["std::marker::Sized","std::option::Option"],"checked_add_opt":["std::marker::Sized","std::option::Option"],"checked_div":["std::marker::Sized","std::option::Option"],"checked_min":["std::marker::Sized","std::option::Option"],"checked_mul":["std::marker::Sized","std::option::Option"],"checked_next_power_of_two":["std::marker::Sized","std::option::Option"],"data::SingleByteData":["data::SingleByteData"],"data::big5_astral_encode":["std::marker::Sized","std::option::Option"],"data::big5_box_encode":["std::marker::Sized","std::option::Option"],"data::big5_is_astral":[],"data::big5_level1_hanzi_encode":["std::marker::Sized","std::option::Option"],"data::big5_low_bits":[],"data::big5_other_encode":["std::marker::Sized","std::option::Option"],"data::cp949_left_hangul_decode":[],"data::cp949_left_hangul_encode":[],"data::cp949_top_hangul_decode":[],"data::cp949_top_hangul_encode":[],"data::gb18030_range_decode":[],"data::gb18030_range_encode":[],"data::gb2312_level1_hanzi_encode":["std::marker::Sized","std::option::Option"],"data::gb2312_level2_hanzi_encode":["std::marker::Sized","std::option::Option"],"data::gb2312_other_decode":[],"data::gb2312_other_encode":["std::marker::Sized","std::option::Option"],"data::gbk_left_ideograph_decode":[],"data::gbk_left_ideograph_encode":[],"data::gbk_other_decode":[],"data::gbk_other_encode":["std::marker::Sized","std::option::Option"],"data::gbk_top_ideograph_decode":[],"data::gbk_top_ideograph_encode":[],"data::ibm_symbol_encode":["std::marker::Sized","std::option::Option"],"data::jis0208_level1_kanji_euc_jp_encode":["std::marker::Sized","std::option::Option"],"data::jis0208_level1_kanji_iso_2022_jp_encode":["std::marker::Sized","std::option::Option"],"data::jis0208_level1_kanji_shift_jis_encode":["std::marker::Sized","std::option::Option"],"data::jis0208_level2_and_additional_kanji_encode":["std::marker::Sized","std::option::Option"],"data::jis0208_range_decode":["std::marker::Sized","std::option::Option"],"data::jis0208_range_encode":["std::marker::Sized","std::option::Option"],"data::jis0208_symbol_decode":["std::marker::Sized","std::option::Option"],"data::jis0208_symbol_encode":["std::marker::Sized","std::option::Option"],"data::jis0212_accented_decode":["std::marker::Sized","std::option::Option"],"data::ksx1001_other_decode":[],"data::ksx1001_other_encode":["std::marker::Sized","std::option::Option"],"data::map_with_ranges":[],"data::map_with_unsorted_ranges":["std::marker::Sized","std::option::Option"],"data::mul_94":[],"data::position":["std::marker::Sized","std::option::Option"],"euc_jp::EucJpDecoder":["euc_jp::EucJpDecoder","euc_jp::EucJpPending"],"euc_jp::EucJpDecoder::decode_to_utf16_raw":["DecoderResult","euc_jp::EucJpDecoder","euc_jp::EucJpPending"],"euc_jp::EucJpDecoder::decode_to_utf8_raw":["DecoderResult","euc_jp::EucJpDecoder","euc_jp::EucJpPending"],"euc_jp::EucJpDecoder::in_neutral_state":["euc_jp::EucJpDecoder","euc_jp::EucJpPending"],"euc_jp::EucJpDecoder::max_utf16_buffer_length":["euc_jp::EucJpDecoder","euc_jp::EucJpPending","std::marker::Sized","std::option::Option"],"euc_jp::EucJpDecoder::max_utf8_buffer_length":["euc_jp::EucJpDecoder","euc_jp::EucJpPending","std::marker::Sized","std::option::Option"],"euc_jp::EucJpDecoder::max_utf8_buffer_length_without_replacement":["euc_jp::EucJpDecoder","euc_jp::EucJpPending","std::marker::Sized","std::option::Option"],"euc_jp::EucJpDecoder::new":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"euc_jp::EucJpDecoder::plus_one_if_lead":["euc_jp::EucJpDecoder","euc_jp::EucJpPending","std::marker::Sized","std::option::Option"],"euc_jp::EucJpEncoder":["euc_jp::EucJpEncoder"],"euc_jp::EucJpEncoder::encode_from_utf16_raw":["EncoderResult","euc_jp::EucJpEncoder"],"euc_jp::EucJpEncoder::encode_from_utf8_raw":["EncoderResult","euc_jp::EucJpEncoder"],"euc_jp::EucJpEncoder::max_buffer_length_from_utf16_without_replacement":["euc_jp::EucJpEncoder","std::marker::Sized","std::option::Option"],"euc_jp::EucJpEncoder::max_buffer_length_from_utf8_without_replacement":["euc_jp::EucJpEncoder","std::marker::Sized","std::option::Option"],"euc_jp::EucJpEncoder::new":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"euc_jp::EucJpPending":["euc_jp::EucJpPending"],"euc_jp::EucJpPending::count":["euc_jp::EucJpPending"],"euc_jp::EucJpPending::is_none":["euc_jp::EucJpPending"],"euc_jp::encode_kanji":["std::marker::Sized","std::option::Option"],"euc_kr::EucKrDecoder":["euc_kr::EucKrDecoder","std::marker::Sized","std::option::Option"],"euc_kr::EucKrDecoder::decode_to_utf16_raw":["DecoderResult","euc_kr::EucKrDecoder","std::marker::Sized","std::option::Option"],"euc_kr::EucKrDecoder::decode_to_utf8_raw":["DecoderResult","euc_kr::EucKrDecoder","std::marker::Sized","std::option::Option"],"euc_kr::EucKrDecoder::in_neutral_state":["euc_kr::EucKrDecoder","std::marker::Sized","std::option::Option"],"euc_kr::EucKrDecoder::max_utf16_buffer_length":["euc_kr::EucKrDecoder","std::marker::Sized","std::option::Option"],"euc_kr::EucKrDecoder::max_utf8_buffer_length":["euc_kr::EucKrDecoder","std::marker::Sized","std::option::Option"],"euc_kr::EucKrDecoder::max_utf8_buffer_length_without_replacement":["euc_kr::EucKrDecoder","std::marker::Sized","std::option::Option"],"euc_kr::EucKrDecoder::new":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"euc_kr::EucKrDecoder::plus_one_if_lead":["euc_kr::EucKrDecoder","std::marker::Sized","std::option::Option"],"euc_kr::EucKrEncoder":["euc_kr::EucKrEncoder"],"euc_kr::EucKrEncoder::encode_from_utf16_raw":["EncoderResult","euc_kr::EucKrEncoder"],"euc_kr::EucKrEncoder::encode_from_utf8_raw":["EncoderResult","euc_kr::EucKrEncoder"],"euc_kr::EucKrEncoder::max_buffer_length_from_utf16_without_replacement":["euc_kr::EucKrEncoder","std::marker::Sized","std::option::Option"],"euc_kr::EucKrEncoder::max_buffer_length_from_utf8_without_replacement":["euc_kr::EucKrEncoder","std::marker::Sized","std::option::Option"],"euc_kr::EucKrEncoder::new":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"euc_kr::ksx1001_encode_hangul":[],"euc_kr::ksx1001_encode_hanja":["std::marker::Sized","std::option::Option"],"euc_kr::ksx1001_encode_misc":["std::marker::Sized","std::option::Option"],"gb18030::Gb18030Decoder":["gb18030::Gb18030Decoder","gb18030::Gb18030Pending","std::marker::Sized","std::option::Option"],"gb18030::Gb18030Decoder::decode_to_utf16_raw":["DecoderResult","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","std::marker::Sized","std::option::Option"],"gb18030::Gb18030Decoder::decode_to_utf8_raw":["DecoderResult","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","std::marker::Sized","std::option::Option"],"gb18030::Gb18030Decoder::extra_from_state":["gb18030::Gb18030Decoder","gb18030::Gb18030Pending","std::marker::Sized","std::option::Option"],"gb18030::Gb18030Decoder::in_neutral_state":["gb18030::Gb18030Decoder","gb18030::Gb18030Pending","std::marker::Sized","std::option::Option"],"gb18030::Gb18030Decoder::max_utf16_buffer_length":["gb18030::Gb18030Decoder","gb18030::Gb18030Pending","std::marker::Sized","std::option::Option"],"gb18030::Gb18030Decoder::max_utf8_buffer_length":["gb18030::Gb18030Decoder","gb18030::Gb18030Pending","std::marker::Sized","std::option::Option"],"gb18030::Gb18030Decoder::max_utf8_buffer_length_without_replacement":["gb18030::Gb18030Decoder","gb18030::Gb18030Pending","std::marker::Sized","std::option::Option"],"gb18030::Gb18030Decoder::new":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"gb18030::Gb18030Encoder":["gb18030::Gb18030Encoder"],"gb18030::Gb18030Encoder::encode_from_utf16_raw":["EncoderResult","gb18030::Gb18030Encoder"],"gb18030::Gb18030Encoder::encode_from_utf8_raw":["EncoderResult","gb18030::Gb18030Encoder"],"gb18030::Gb18030Encoder::max_buffer_length_from_utf16_without_replacement":["gb18030::Gb18030Encoder","std::marker::Sized","std::option::Option"],"gb18030::Gb18030Encoder::max_buffer_length_from_utf8_without_replacement":["gb18030::Gb18030Encoder","std::marker::Sized","std::option::Option"],"gb18030::Gb18030Encoder::new":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"gb18030::Gb18030Pending":["gb18030::Gb18030Pending"],"gb18030::Gb18030Pending::count":["gb18030::Gb18030Pending"],"gb18030::Gb18030Pending::is_none":["gb18030::Gb18030Pending"],"gb18030::encode_hanzi":[],"gb18030::gbk_encode_non_unified":["std::marker::Sized","std::option::Option"],"handles::BigEndian":["handles::BigEndian"],"handles::ByteDestination":["handles::ByteDestination"],"handles::ByteDestination::<'a>::check_space_four":["handles::ByteDestination","handles::Space","std::marker::Sized"],"handles::ByteDestination::<'a>::check_space_one":["handles::ByteDestination","handles::Space","std::marker::Sized"],"handles::ByteDestination::<'a>::check_space_three":["handles::ByteDestination","handles::Space","std::marker::Sized"],"handles::ByteDestination::<'a>::check_space_two":["handles::ByteDestination","handles::Space","std::marker::Sized"],"handles::ByteDestination::<'a>::new":["handles::ByteDestination"],"handles::ByteDestination::<'a>::write_four":["handles::ByteDestination"],"handles::ByteDestination::<'a>::write_one":["handles::ByteDestination"],"handles::ByteDestination::<'a>::write_three":["handles::ByteDestination"],"handles::ByteDestination::<'a>::write_two":["handles::ByteDestination"],"handles::ByteDestination::<'a>::written":["handles::ByteDestination"],"handles::ByteFourHandle":["handles::ByteDestination","handles::ByteFourHandle"],"handles::ByteFourHandle::<'a, 'b>::new":["handles::ByteDestination","handles::ByteFourHandle"],"handles::ByteFourHandle::<'a, 'b>::write_four":["handles::ByteDestination","handles::ByteFourHandle"],"handles::ByteFourHandle::<'a, 'b>::write_one":["handles::ByteDestination","handles::ByteFourHandle"],"handles::ByteFourHandle::<'a, 'b>::write_two":["handles::ByteDestination","handles::ByteFourHandle"],"handles::ByteFourHandle::<'a, 'b>::written":["handles::ByteDestination","handles::ByteFourHandle"],"handles::ByteOneHandle":["handles::ByteDestination","handles::ByteOneHandle"],"handles::ByteOneHandle::<'a, 'b>::new":["handles::ByteDestination","handles::ByteOneHandle"],"handles::ByteOneHandle::<'a, 'b>::write_one":["handles::ByteDestination","handles::ByteOneHandle"],"handles::ByteOneHandle::<'a, 'b>::written":["handles::ByteDestination","handles::ByteOneHandle"],"handles::ByteReadHandle":["handles::ByteReadHandle","handles::ByteSource"],"handles::ByteReadHandle::<'a, 'b>::consumed":["handles::ByteReadHandle","handles::ByteSource"],"handles::ByteReadHandle::<'a, 'b>::new":["handles::ByteReadHandle","handles::ByteSource"],"handles::ByteReadHandle::<'a, 'b>::read":["handles::ByteReadHandle","handles::ByteSource","handles::ByteUnreadHandle"],"handles::ByteSource":["handles::ByteSource"],"handles::ByteSource::<'a>::check_available":["handles::ByteSource","handles::Space","std::marker::Sized"],"handles::ByteSource::<'a>::consumed":["handles::ByteSource"],"handles::ByteSource::<'a>::new":["handles::ByteSource"],"handles::ByteSource::<'a>::read":["handles::ByteSource"],"handles::ByteSource::<'a>::unread":["handles::ByteSource"],"handles::ByteThreeHandle":["handles::ByteDestination","handles::ByteThreeHandle"],"handles::ByteThreeHandle::<'a, 'b>::new":["handles::ByteDestination","handles::ByteThreeHandle"],"handles::ByteThreeHandle::<'a, 'b>::write_one":["handles::ByteDestination","handles::ByteThreeHandle"],"handles::ByteThreeHandle::<'a, 'b>::write_three":["handles::ByteDestination","handles::ByteThreeHandle"],"handles::ByteThreeHandle::<'a, 'b>::write_three_return_written":["handles::ByteDestination","handles::ByteThreeHandle"],"handles::ByteThreeHandle::<'a, 'b>::write_two":["handles::ByteDestination","handles::ByteThreeHandle"],"handles::ByteThreeHandle::<'a, 'b>::written":["handles::ByteDestination","handles::ByteThreeHandle"],"handles::ByteTwoHandle":["handles::ByteDestination","handles::ByteTwoHandle"],"handles::ByteTwoHandle::<'a, 'b>::new":["handles::ByteDestination","handles::ByteTwoHandle"],"handles::ByteTwoHandle::<'a, 'b>::write_one":["handles::ByteDestination","handles::ByteTwoHandle"],"handles::ByteTwoHandle::<'a, 'b>::write_two":["handles::ByteDestination","handles::ByteTwoHandle"],"handles::ByteTwoHandle::<'a, 'b>::written":["handles::ByteDestination","handles::ByteTwoHandle"],"handles::ByteUnreadHandle":["handles::ByteSource","handles::ByteUnreadHandle"],"handles::ByteUnreadHandle::<'a, 'b>::commit":["handles::ByteSource","handles::ByteUnreadHandle"],"handles::ByteUnreadHandle::<'a, 'b>::consumed":["handles::ByteSource","handles::ByteUnreadHandle"],"handles::ByteUnreadHandle::<'a, 'b>::new":["handles::ByteSource","handles::ByteUnreadHandle"],"handles::ByteUnreadHandle::<'a, 'b>::unread":["handles::ByteSource","handles::ByteUnreadHandle"],"handles::CopyAsciiResult":["handles::CopyAsciiResult","std::marker::Sized"],"handles::LittleEndian":["handles::LittleEndian"],"handles::NonAscii":["handles::NonAscii"],"handles::Space":["handles::Space","std::marker::Sized"],"handles::UnalignedU16Slice":["handles::UnalignedU16Slice"],"handles::UnalignedU16Slice::at":["handles::UnalignedU16Slice"],"handles::UnalignedU16Slice::copy_bmp_to":["handles::BigEndian","handles::Endian","handles::UnalignedU16Slice","std::marker::Sized","std::option::Option"],"handles::UnalignedU16Slice::len":["handles::UnalignedU16Slice"],"handles::UnalignedU16Slice::new":["handles::UnalignedU16Slice"],"handles::UnalignedU16Slice::tail":["handles::UnalignedU16Slice"],"handles::UnalignedU16Slice::trim_last":["handles::UnalignedU16Slice"],"handles::Unicode":["handles::NonAscii","handles::Unicode"],"handles::Utf16AstralHandle":["handles::Utf16AstralHandle","handles::Utf16Destination"],"handles::Utf16AstralHandle::<'a, 'b>::commit":["handles::Utf16AstralHandle","handles::Utf16Destination"],"handles::Utf16AstralHandle::<'a, 'b>::new":["handles::Utf16AstralHandle","handles::Utf16Destination"],"handles::Utf16AstralHandle::<'a, 'b>::write_ascii":["handles::Utf16AstralHandle","handles::Utf16Destination"],"handles::Utf16AstralHandle::<'a, 'b>::write_astral":["handles::Utf16AstralHandle","handles::Utf16Destination"],"handles::Utf16AstralHandle::<'a, 'b>::write_big5_combination":["handles::Utf16AstralHandle","handles::Utf16Destination"],"handles::Utf16AstralHandle::<'a, 'b>::write_bmp":["handles::Utf16AstralHandle","handles::Utf16Destination"],"handles::Utf16AstralHandle::<'a, 'b>::write_bmp_excl_ascii":["handles::Utf16AstralHandle","handles::Utf16Destination"],"handles::Utf16AstralHandle::<'a, 'b>::write_surrogate_pair":["handles::Utf16AstralHandle","handles::Utf16Destination"],"handles::Utf16AstralHandle::<'a, 'b>::write_upper_bmp":["handles::Utf16AstralHandle","handles::Utf16Destination"],"handles::Utf16AstralHandle::<'a, 'b>::written":["handles::Utf16AstralHandle","handles::Utf16Destination"],"handles::Utf16BmpHandle":["handles::Utf16BmpHandle","handles::Utf16Destination"],"handles::Utf16BmpHandle::<'a, 'b>::commit":["handles::Utf16BmpHandle","handles::Utf16Destination"],"handles::Utf16BmpHandle::<'a, 'b>::new":["handles::Utf16BmpHandle","handles::Utf16Destination"],"handles::Utf16BmpHandle::<'a, 'b>::write_ascii":["handles::Utf16BmpHandle","handles::Utf16Destination"],"handles::Utf16BmpHandle::<'a, 'b>::write_bmp":["handles::Utf16BmpHandle","handles::Utf16Destination"],"handles::Utf16BmpHandle::<'a, 'b>::write_bmp_excl_ascii":["handles::Utf16BmpHandle","handles::Utf16Destination"],"handles::Utf16BmpHandle::<'a, 'b>::write_mid_bmp":["handles::Utf16BmpHandle","handles::Utf16Destination"],"handles::Utf16BmpHandle::<'a, 'b>::write_upper_bmp":["handles::Utf16BmpHandle","handles::Utf16Destination"],"handles::Utf16BmpHandle::<'a, 'b>::written":["handles::Utf16BmpHandle","handles::Utf16Destination"],"handles::Utf16Destination":["handles::Utf16Destination"],"handles::Utf16Destination::<'a>::check_space_astral":["handles::Space","handles::Utf16Destination","std::marker::Sized"],"handles::Utf16Destination::<'a>::check_space_bmp":["handles::Space","handles::Utf16Destination","std::marker::Sized"],"handles::Utf16Destination::<'a>::copy_ascii_from_check_space_astral":["handles::ByteSource","handles::CopyAsciiResult","handles::Utf16Destination","std::marker::Sized"],"handles::Utf16Destination::<'a>::copy_ascii_from_check_space_bmp":["handles::ByteSource","handles::CopyAsciiResult","handles::Utf16Destination","std::marker::Sized"],"handles::Utf16Destination::<'a>::copy_utf16_from":["handles::BigEndian","handles::ByteSource","handles::Endian","handles::Utf16Destination","std::marker::Sized","std::option::Option"],"handles::Utf16Destination::<'a>::copy_utf8_up_to_invalid_from":["handles::ByteSource","handles::Utf16Destination"],"handles::Utf16Destination::<'a>::new":["handles::Utf16Destination"],"handles::Utf16Destination::<'a>::write_ascii":["handles::Utf16Destination"],"handles::Utf16Destination::<'a>::write_astral":["handles::Utf16Destination"],"handles::Utf16Destination::<'a>::write_big5_combination":["handles::Utf16Destination"],"handles::Utf16Destination::<'a>::write_bmp":["handles::Utf16Destination"],"handles::Utf16Destination::<'a>::write_bmp_excl_ascii":["handles::Utf16Destination"],"handles::Utf16Destination::<'a>::write_code_unit":["handles::Utf16Destination"],"handles::Utf16Destination::<'a>::write_mid_bmp":["handles::Utf16Destination"],"handles::Utf16Destination::<'a>::write_surrogate_pair":["handles::Utf16Destination"],"handles::Utf16Destination::<'a>::write_upper_bmp":["handles::Utf16Destination"],"handles::Utf16Destination::<'a>::written":["handles::Utf16Destination"],"handles::Utf16ReadHandle":["handles::Utf16ReadHandle","handles::Utf16Source"],"handles::Utf16ReadHandle::<'a, 'b>::consumed":["handles::Utf16ReadHandle","handles::Utf16Source"],"handles::Utf16ReadHandle::<'a, 'b>::new":["handles::Utf16ReadHandle","handles::Utf16Source"],"handles::Utf16ReadHandle::<'a, 'b>::read":["handles::Utf16ReadHandle","handles::Utf16Source","handles::Utf16UnreadHandle"],"handles::Utf16ReadHandle::<'a, 'b>::read_enum":["handles::NonAscii","handles::Unicode","handles::Utf16ReadHandle","handles::Utf16Source","handles::Utf16UnreadHandle"],"handles::Utf16Source":["handles::Utf16Source"],"handles::Utf16Source::<'a>::check_available":["handles::Space","handles::Utf16Source","std::marker::Sized"],"handles::Utf16Source::<'a>::consumed":["handles::Utf16Source"],"handles::Utf16Source::<'a>::copy_ascii_to_check_space_four":["handles::ByteDestination","handles::CopyAsciiResult","handles::Utf16Source","std::marker::Sized"],"handles::Utf16Source::<'a>::copy_ascii_to_check_space_two":["handles::ByteDestination","handles::CopyAsciiResult","handles::Utf16Source","std::marker::Sized"],"handles::Utf16Source::<'a>::new":["handles::Utf16Source"],"handles::Utf16Source::<'a>::read":["handles::Utf16Source"],"handles::Utf16Source::<'a>::read_enum":["handles::NonAscii","handles::Unicode","handles::Utf16Source"],"handles::Utf16Source::<'a>::unread":["handles::Utf16Source"],"handles::Utf16UnreadHandle":["handles::Utf16Source","handles::Utf16UnreadHandle"],"handles::Utf16UnreadHandle::<'a, 'b>::commit":["handles::Utf16Source","handles::Utf16UnreadHandle"],"handles::Utf16UnreadHandle::<'a, 'b>::consumed":["handles::Utf16Source","handles::Utf16UnreadHandle"],"handles::Utf16UnreadHandle::<'a, 'b>::new":["handles::Utf16Source","handles::Utf16UnreadHandle"],"handles::Utf16UnreadHandle::<'a, 'b>::unread":["handles::Utf16Source","handles::Utf16UnreadHandle"],"handles::Utf8AstralHandle":["handles::Utf8AstralHandle","handles::Utf8Destination"],"handles::Utf8AstralHandle::<'a, 'b>::commit":["handles::Utf8AstralHandle","handles::Utf8Destination"],"handles::Utf8AstralHandle::<'a, 'b>::new":["handles::Utf8AstralHandle","handles::Utf8Destination"],"handles::Utf8AstralHandle::<'a, 'b>::write_ascii":["handles::Utf8AstralHandle","handles::Utf8Destination"],"handles::Utf8AstralHandle::<'a, 'b>::write_astral":["handles::Utf8AstralHandle","handles::Utf8Destination"],"handles::Utf8AstralHandle::<'a, 'b>::write_big5_combination":["handles::Utf8AstralHandle","handles::Utf8Destination"],"handles::Utf8AstralHandle::<'a, 'b>::write_bmp":["handles::Utf8AstralHandle","handles::Utf8Destination"],"handles::Utf8AstralHandle::<'a, 'b>::write_bmp_excl_ascii":["handles::Utf8AstralHandle","handles::Utf8Destination"],"handles::Utf8AstralHandle::<'a, 'b>::write_surrogate_pair":["handles::Utf8AstralHandle","handles::Utf8Destination"],"handles::Utf8AstralHandle::<'a, 'b>::write_upper_bmp":["handles::Utf8AstralHandle","handles::Utf8Destination"],"handles::Utf8AstralHandle::<'a, 'b>::written":["handles::Utf8AstralHandle","handles::Utf8Destination"],"handles::Utf8BmpHandle":["handles::Utf8BmpHandle","handles::Utf8Destination"],"handles::Utf8BmpHandle::<'a, 'b>::commit":["handles::Utf8BmpHandle","handles::Utf8Destination"],"handles::Utf8BmpHandle::<'a, 'b>::new":["handles::Utf8BmpHandle","handles::Utf8Destination"],"handles::Utf8BmpHandle::<'a, 'b>::write_ascii":["handles::Utf8BmpHandle","handles::Utf8Destination"],"handles::Utf8BmpHandle::<'a, 'b>::write_bmp":["handles::Utf8BmpHandle","handles::Utf8Destination"],"handles::Utf8BmpHandle::<'a, 'b>::write_bmp_excl_ascii":["handles::Utf8BmpHandle","handles::Utf8Destination"],"handles::Utf8BmpHandle::<'a, 'b>::write_mid_bmp":["handles::Utf8BmpHandle","handles::Utf8Destination"],"handles::Utf8BmpHandle::<'a, 'b>::write_upper_bmp":["handles::Utf8BmpHandle","handles::Utf8Destination"],"handles::Utf8BmpHandle::<'a, 'b>::written":["handles::Utf8BmpHandle","handles::Utf8Destination"],"handles::Utf8Destination":["handles::Utf8Destination"],"handles::Utf8Destination::<'a>::check_space_astral":["handles::Space","handles::Utf8Destination","std::marker::Sized"],"handles::Utf8Destination::<'a>::check_space_bmp":["handles::Space","handles::Utf8Destination","std::marker::Sized"],"handles::Utf8Destination::<'a>::copy_ascii_from_check_space_astral":["handles::ByteSource","handles::CopyAsciiResult","handles::Utf8Destination","std::marker::Sized"],"handles::Utf8Destination::<'a>::copy_ascii_from_check_space_bmp":["handles::ByteSource","handles::CopyAsciiResult","handles::Utf8Destination","std::marker::Sized"],"handles::Utf8Destination::<'a>::copy_utf16_from":["handles::BigEndian","handles::ByteSource","handles::Endian","handles::Utf8Destination","std::marker::Sized","std::option::Option"],"handles::Utf8Destination::<'a>::copy_utf8_up_to_invalid_from":["handles::ByteSource","handles::Utf8Destination"],"handles::Utf8Destination::<'a>::new":["handles::Utf8Destination"],"handles::Utf8Destination::<'a>::write_ascii":["handles::Utf8Destination"],"handles::Utf8Destination::<'a>::write_astral":["handles::Utf8Destination"],"handles::Utf8Destination::<'a>::write_big5_combination":["handles::Utf8Destination"],"handles::Utf8Destination::<'a>::write_bmp":["handles::Utf8Destination"],"handles::Utf8Destination::<'a>::write_bmp_excl_ascii":["handles::Utf8Destination"],"handles::Utf8Destination::<'a>::write_code_unit":["handles::Utf8Destination"],"handles::Utf8Destination::<'a>::write_mid_bmp":["handles::Utf8Destination"],"handles::Utf8Destination::<'a>::write_surrogate_pair":["handles::Utf8Destination"],"handles::Utf8Destination::<'a>::write_upper_bmp":["handles::Utf8Destination"],"handles::Utf8Destination::<'a>::written":["handles::Utf8Destination"],"handles::Utf8ReadHandle":["handles::Utf8ReadHandle","handles::Utf8Source"],"handles::Utf8ReadHandle::<'a, 'b>::consumed":["handles::Utf8ReadHandle","handles::Utf8Source"],"handles::Utf8ReadHandle::<'a, 'b>::new":["handles::Utf8ReadHandle","handles::Utf8Source"],"handles::Utf8ReadHandle::<'a, 'b>::read":["handles::Utf8ReadHandle","handles::Utf8Source","handles::Utf8UnreadHandle"],"handles::Utf8ReadHandle::<'a, 'b>::read_enum":["handles::NonAscii","handles::Unicode","handles::Utf8ReadHandle","handles::Utf8Source","handles::Utf8UnreadHandle"],"handles::Utf8Source":["handles::Utf8Source"],"handles::Utf8Source::<'a>::check_available":["handles::Space","handles::Utf8Source","std::marker::Sized"],"handles::Utf8Source::<'a>::consumed":["handles::Utf8Source"],"handles::Utf8Source::<'a>::copy_ascii_to_check_space_four":["handles::ByteDestination","handles::CopyAsciiResult","handles::Utf8Source","std::marker::Sized"],"handles::Utf8Source::<'a>::copy_ascii_to_check_space_one":["handles::ByteDestination","handles::CopyAsciiResult","handles::Utf8Source","std::marker::Sized"],"handles::Utf8Source::<'a>::copy_ascii_to_check_space_two":["handles::ByteDestination","handles::CopyAsciiResult","handles::Utf8Source","std::marker::Sized"],"handles::Utf8Source::<'a>::new":["handles::Utf8Source"],"handles::Utf8Source::<'a>::read":["handles::Utf8Source"],"handles::Utf8Source::<'a>::read_enum":["handles::NonAscii","handles::Unicode","handles::Utf8Source"],"handles::Utf8Source::<'a>::unread":["handles::Utf8Source"],"handles::Utf8UnreadHandle":["handles::Utf8Source","handles::Utf8UnreadHandle"],"handles::Utf8UnreadHandle::<'a, 'b>::commit":["handles::Utf8Source","handles::Utf8UnreadHandle"],"handles::Utf8UnreadHandle::<'a, 'b>::consumed":["handles::Utf8Source","handles::Utf8UnreadHandle"],"handles::Utf8UnreadHandle::<'a, 'b>::new":["handles::Utf8Source","handles::Utf8UnreadHandle"],"handles::Utf8UnreadHandle::<'a, 'b>::unread":["handles::Utf8Source","handles::Utf8UnreadHandle"],"handles::convert_unaligned_utf16_to_utf8":["handles::BigEndian","handles::Endian","handles::UnalignedU16Slice","std::marker::Sized"],"handles::copy_unaligned_basic_latin_to_ascii":["handles::BigEndian","handles::CopyAsciiResult","handles::Endian","handles::UnalignedU16Slice","std::marker::Sized"],"handles::copy_unaligned_basic_latin_to_ascii_alu":["handles::BigEndian","handles::CopyAsciiResult","handles::Endian","handles::UnalignedU16Slice","std::marker::Sized"],"handles::swap_if_opposite_endian":["handles::BigEndian","handles::Endian","std::marker::Sized"],"in_inclusive_range":[],"in_inclusive_range16":[],"in_inclusive_range32":[],"in_inclusive_range8":[],"in_range16":[],"in_range32":[],"iso_2022_jp::Iso2022JpDecoder":["iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState"],"iso_2022_jp::Iso2022JpDecoder::decode_to_utf16_raw":["DecoderResult","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState"],"iso_2022_jp::Iso2022JpDecoder::decode_to_utf8_raw":["DecoderResult","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState"],"iso_2022_jp::Iso2022JpDecoder::extra_to_input_from_state":["iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","std::marker::Sized","std::option::Option"],"iso_2022_jp::Iso2022JpDecoder::extra_to_output_from_state":["iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState"],"iso_2022_jp::Iso2022JpDecoder::in_neutral_state":["iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState"],"iso_2022_jp::Iso2022JpDecoder::max_utf16_buffer_length":["iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","std::marker::Sized","std::option::Option"],"iso_2022_jp::Iso2022JpDecoder::max_utf8_buffer_length":["iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","std::marker::Sized","std::option::Option"],"iso_2022_jp::Iso2022JpDecoder::max_utf8_buffer_length_without_replacement":["iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","std::marker::Sized","std::option::Option"],"iso_2022_jp::Iso2022JpDecoder::new":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"iso_2022_jp::Iso2022JpDecoderState":["iso_2022_jp::Iso2022JpDecoderState"],"iso_2022_jp::Iso2022JpEncoder":["iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState"],"iso_2022_jp::Iso2022JpEncoder::encode_from_utf16_raw":["EncoderResult","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState"],"iso_2022_jp::Iso2022JpEncoder::encode_from_utf8_raw":["EncoderResult","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState"],"iso_2022_jp::Iso2022JpEncoder::has_pending_state":["iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState"],"iso_2022_jp::Iso2022JpEncoder::max_buffer_length_from_utf16_without_replacement":["iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","std::marker::Sized","std::option::Option"],"iso_2022_jp::Iso2022JpEncoder::max_buffer_length_from_utf8_without_replacement":["iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","std::marker::Sized","std::option::Option"],"iso_2022_jp::Iso2022JpEncoder::new":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"iso_2022_jp::Iso2022JpEncoderState":["iso_2022_jp::Iso2022JpEncoderState"],"iso_2022_jp::encode_kanji":["std::marker::Sized","std::option::Option"],"iso_2022_jp::is_kanji_mapped":[],"iso_2022_jp::is_mapped_for_two_byte_encode":[],"mem::Latin1Bidi":["mem::Latin1Bidi"],"mem::check_str_for_latin1_and_bidi":["mem::Latin1Bidi"],"mem::check_utf16_for_latin1_and_bidi":["mem::Latin1Bidi"],"mem::check_utf16_for_latin1_and_bidi_impl":["mem::Latin1Bidi"],"mem::check_utf8_for_latin1_and_bidi":["mem::Latin1Bidi"],"mem::convert_latin1_to_str":[],"mem::convert_latin1_to_str_partial":[],"mem::convert_latin1_to_utf16":[],"mem::convert_latin1_to_utf8":[],"mem::convert_latin1_to_utf8_partial":[],"mem::convert_str_to_utf16":[],"mem::convert_utf16_to_latin1_lossy":[],"mem::convert_utf16_to_str":[],"mem::convert_utf16_to_str_partial":[],"mem::convert_utf16_to_utf8":[],"mem::convert_utf16_to_utf8_partial":[],"mem::convert_utf8_to_latin1_lossy":[],"mem::convert_utf8_to_utf16":[],"mem::convert_utf8_to_utf16_without_replacement":["std::marker::Sized","std::option::Option"],"mem::copy_ascii_to_ascii":[],"mem::copy_ascii_to_basic_latin":[],"mem::copy_basic_latin_to_ascii":[],"mem::decode_latin1":["std::borrow::Cow","std::borrow::ToOwned"],"mem::encode_latin1_lossy":["std::borrow::Cow","std::borrow::ToOwned"],"mem::ensure_utf16_validity":[],"mem::is_ascii":[],"mem::is_ascii_impl":[],"mem::is_basic_latin":[],"mem::is_basic_latin_impl":[],"mem::is_char_bidi":[],"mem::is_str_bidi":[],"mem::is_str_latin1":[],"mem::is_str_latin1_impl":["std::marker::Sized","std::option::Option"],"mem::is_utf16_bidi":[],"mem::is_utf16_bidi_impl":[],"mem::is_utf16_code_unit_bidi":[],"mem::is_utf16_latin1":[],"mem::is_utf16_latin1_impl":[],"mem::is_utf8_bidi":[],"mem::is_utf8_latin1":[],"mem::is_utf8_latin1_impl":["std::marker::Sized","std::option::Option"],"mem::likely":[],"mem::str_latin1_up_to":[],"mem::unlikely":[],"mem::utf16_valid_up_to":[],"mem::utf16_valid_up_to_alu":[],"mem::utf16_valid_up_to_impl":[],"mem::utf8_latin1_up_to":[],"replacement::ReplacementDecoder":["replacement::ReplacementDecoder"],"replacement::ReplacementDecoder::decode_to_utf16_raw":["DecoderResult","replacement::ReplacementDecoder"],"replacement::ReplacementDecoder::decode_to_utf8_raw":["DecoderResult","replacement::ReplacementDecoder"],"replacement::ReplacementDecoder::max_utf16_buffer_length":["replacement::ReplacementDecoder","std::marker::Sized","std::option::Option"],"replacement::ReplacementDecoder::max_utf8_buffer_length":["replacement::ReplacementDecoder","std::marker::Sized","std::option::Option"],"replacement::ReplacementDecoder::max_utf8_buffer_length_without_replacement":["replacement::ReplacementDecoder","std::marker::Sized","std::option::Option"],"replacement::ReplacementDecoder::new":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"shift_jis::ShiftJisDecoder":["shift_jis::ShiftJisDecoder","std::marker::Sized","std::option::Option"],"shift_jis::ShiftJisDecoder::decode_to_utf16_raw":["DecoderResult","shift_jis::ShiftJisDecoder","std::marker::Sized","std::option::Option"],"shift_jis::ShiftJisDecoder::decode_to_utf8_raw":["DecoderResult","shift_jis::ShiftJisDecoder","std::marker::Sized","std::option::Option"],"shift_jis::ShiftJisDecoder::in_neutral_state":["shift_jis::ShiftJisDecoder","std::marker::Sized","std::option::Option"],"shift_jis::ShiftJisDecoder::max_utf16_buffer_length":["shift_jis::ShiftJisDecoder","std::marker::Sized","std::option::Option"],"shift_jis::ShiftJisDecoder::max_utf8_buffer_length":["shift_jis::ShiftJisDecoder","std::marker::Sized","std::option::Option"],"shift_jis::ShiftJisDecoder::max_utf8_buffer_length_without_replacement":["shift_jis::ShiftJisDecoder","std::marker::Sized","std::option::Option"],"shift_jis::ShiftJisDecoder::new":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"shift_jis::ShiftJisDecoder::plus_one_if_lead":["shift_jis::ShiftJisDecoder","std::marker::Sized","std::option::Option"],"shift_jis::ShiftJisEncoder":["shift_jis::ShiftJisEncoder"],"shift_jis::ShiftJisEncoder::encode_from_utf16_raw":["EncoderResult","shift_jis::ShiftJisEncoder"],"shift_jis::ShiftJisEncoder::encode_from_utf8_raw":["EncoderResult","shift_jis::ShiftJisEncoder"],"shift_jis::ShiftJisEncoder::max_buffer_length_from_utf16_without_replacement":["shift_jis::ShiftJisEncoder","std::marker::Sized","std::option::Option"],"shift_jis::ShiftJisEncoder::max_buffer_length_from_utf8_without_replacement":["shift_jis::ShiftJisEncoder","std::marker::Sized","std::option::Option"],"shift_jis::ShiftJisEncoder::new":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"shift_jis::encode_kanji":["std::marker::Sized","std::option::Option"],"single_byte::SingleByteDecoder":["single_byte::SingleByteDecoder"],"single_byte::SingleByteDecoder::decode_to_utf16_raw":["DecoderResult","single_byte::SingleByteDecoder"],"single_byte::SingleByteDecoder::decode_to_utf8_raw":["DecoderResult","single_byte::SingleByteDecoder"],"single_byte::SingleByteDecoder::latin1_byte_compatible_up_to":["single_byte::SingleByteDecoder"],"single_byte::SingleByteDecoder::max_utf16_buffer_length":["single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option"],"single_byte::SingleByteDecoder::max_utf8_buffer_length":["single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option"],"single_byte::SingleByteDecoder::max_utf8_buffer_length_without_replacement":["single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option"],"single_byte::SingleByteDecoder::new":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"single_byte::SingleByteEncoder":["single_byte::SingleByteEncoder"],"single_byte::SingleByteEncoder::encode_from_utf16_raw":["EncoderResult","single_byte::SingleByteEncoder"],"single_byte::SingleByteEncoder::encode_from_utf8_raw":["EncoderResult","single_byte::SingleByteEncoder"],"single_byte::SingleByteEncoder::encode_u16":["single_byte::SingleByteEncoder","std::marker::Sized","std::option::Option"],"single_byte::SingleByteEncoder::max_buffer_length_from_utf16_without_replacement":["single_byte::SingleByteEncoder","std::marker::Sized","std::option::Option"],"single_byte::SingleByteEncoder::max_buffer_length_from_utf8_without_replacement":["single_byte::SingleByteEncoder","std::marker::Sized","std::option::Option"],"single_byte::SingleByteEncoder::new":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"utf_16::Utf16Decoder":["std::marker::Sized","std::option::Option","utf_16::Utf16Decoder"],"utf_16::Utf16Decoder::additional_from_state":["std::marker::Sized","std::option::Option","utf_16::Utf16Decoder"],"utf_16::Utf16Decoder::decode_to_utf16_raw":["DecoderResult","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder"],"utf_16::Utf16Decoder::decode_to_utf8_raw":["DecoderResult","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder"],"utf_16::Utf16Decoder::max_utf16_buffer_length":["std::marker::Sized","std::option::Option","utf_16::Utf16Decoder"],"utf_16::Utf16Decoder::max_utf8_buffer_length":["std::marker::Sized","std::option::Option","utf_16::Utf16Decoder"],"utf_16::Utf16Decoder::max_utf8_buffer_length_without_replacement":["std::marker::Sized","std::option::Option","utf_16::Utf16Decoder"],"utf_16::Utf16Decoder::new":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"utf_8::Utf8Data":["utf_8::Utf8Data"],"utf_8::Utf8Decoder":["utf_8::Utf8Decoder"],"utf_8::Utf8Decoder::decode_to_utf16_raw":["DecoderResult","utf_8::Utf8Decoder"],"utf_8::Utf8Decoder::decode_to_utf8_raw":["DecoderResult","utf_8::Utf8Decoder"],"utf_8::Utf8Decoder::extra_from_state":["utf_8::Utf8Decoder"],"utf_8::Utf8Decoder::in_neutral_state":["utf_8::Utf8Decoder"],"utf_8::Utf8Decoder::max_utf16_buffer_length":["std::marker::Sized","std::option::Option","utf_8::Utf8Decoder"],"utf_8::Utf8Decoder::max_utf8_buffer_length":["std::marker::Sized","std::option::Option","utf_8::Utf8Decoder"],"utf_8::Utf8Decoder::max_utf8_buffer_length_without_replacement":["std::marker::Sized","std::option::Option","utf_8::Utf8Decoder"],"utf_8::Utf8Decoder::new":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"utf_8::Utf8Decoder::new_inner":["utf_8::Utf8Decoder"],"utf_8::Utf8Encoder":["utf_8::Utf8Encoder"],"utf_8::Utf8Encoder::encode_from_utf16_raw":["EncoderResult","utf_8::Utf8Encoder"],"utf_8::Utf8Encoder::encode_from_utf8_raw":["EncoderResult","utf_8::Utf8Encoder"],"utf_8::Utf8Encoder::max_buffer_length_from_utf16_without_replacement":["std::marker::Sized","std::option::Option","utf_8::Utf8Encoder"],"utf_8::Utf8Encoder::max_buffer_length_from_utf8_without_replacement":["std::marker::Sized","std::option::Option","utf_8::Utf8Encoder"],"utf_8::Utf8Encoder::new":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"utf_8::convert_utf16_to_utf8_partial_inner":[],"utf_8::convert_utf16_to_utf8_partial_tail":[],"utf_8::convert_utf8_to_utf16_up_to_invalid":[],"utf_8::likely":[],"utf_8::unlikely":[],"utf_8::utf8_valid_up_to":[],"variant::VariantDecoder":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"variant::VariantDecoder::decode_to_utf16_raw":["DecoderResult","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"variant::VariantDecoder::decode_to_utf8_raw":["DecoderResult","big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"variant::VariantDecoder::latin1_byte_compatible_up_to":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"variant::VariantDecoder::max_utf16_buffer_length":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"variant::VariantDecoder::max_utf8_buffer_length":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"variant::VariantDecoder::max_utf8_buffer_length_without_replacement":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"variant::VariantEncoder":["big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","x_user_defined::UserDefinedEncoder"],"variant::VariantEncoder::encode_from_utf16_raw":["EncoderResult","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","x_user_defined::UserDefinedEncoder"],"variant::VariantEncoder::encode_from_utf8_raw":["EncoderResult","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","x_user_defined::UserDefinedEncoder"],"variant::VariantEncoder::has_pending_state":["big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","x_user_defined::UserDefinedEncoder"],"variant::VariantEncoder::max_buffer_length_from_utf16_without_replacement":["big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","std::marker::Sized","std::option::Option","utf_8::Utf8Encoder","variant::VariantEncoder","x_user_defined::UserDefinedEncoder"],"variant::VariantEncoder::max_buffer_length_from_utf8_without_replacement":["big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","std::marker::Sized","std::option::Option","utf_8::Utf8Encoder","variant::VariantEncoder","x_user_defined::UserDefinedEncoder"],"variant::VariantEncoding":["variant::VariantEncoding"],"variant::VariantEncoding::is_single_byte":["variant::VariantEncoding"],"variant::VariantEncoding::new_encoder":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"],"variant::VariantEncoding::new_variant_decoder":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","variant::VariantEncoding","x_user_defined::UserDefinedDecoder"],"write_ncr":[],"x_user_defined::UserDefinedDecoder":["x_user_defined::UserDefinedDecoder"],"x_user_defined::UserDefinedDecoder::decode_to_utf16_raw":["DecoderResult","x_user_defined::UserDefinedDecoder"],"x_user_defined::UserDefinedDecoder::decode_to_utf8_raw":["DecoderResult","x_user_defined::UserDefinedDecoder"],"x_user_defined::UserDefinedDecoder::max_utf16_buffer_length":["std::marker::Sized","std::option::Option","x_user_defined::UserDefinedDecoder"],"x_user_defined::UserDefinedDecoder::max_utf8_buffer_length":["std::marker::Sized","std::option::Option","x_user_defined::UserDefinedDecoder"],"x_user_defined::UserDefinedDecoder::max_utf8_buffer_length_without_replacement":["std::marker::Sized","std::option::Option","x_user_defined::UserDefinedDecoder"],"x_user_defined::UserDefinedDecoder::new":["big5::Big5Decoder","euc_jp::EucJpDecoder","euc_jp::EucJpPending","euc_kr::EucKrDecoder","gb18030::Gb18030Decoder","gb18030::Gb18030Pending","iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState","replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder","single_byte::SingleByteDecoder","std::marker::Sized","std::option::Option","utf_16::Utf16Decoder","utf_8::Utf8Decoder","variant::VariantDecoder","x_user_defined::UserDefinedDecoder"],"x_user_defined::UserDefinedEncoder":["x_user_defined::UserDefinedEncoder"],"x_user_defined::UserDefinedEncoder::encode_from_utf16_raw":["EncoderResult","x_user_defined::UserDefinedEncoder"],"x_user_defined::UserDefinedEncoder::encode_from_utf8_raw":["EncoderResult","x_user_defined::UserDefinedEncoder"],"x_user_defined::UserDefinedEncoder::max_buffer_length_from_utf16_without_replacement":["std::marker::Sized","std::option::Option","x_user_defined::UserDefinedEncoder"],"x_user_defined::UserDefinedEncoder::max_buffer_length_from_utf8_without_replacement":["std::marker::Sized","std::option::Option","x_user_defined::UserDefinedEncoder"],"x_user_defined::UserDefinedEncoder::new":["Encoder","Encoding","big5::Big5Encoder","euc_jp::EucJpEncoder","euc_kr::EucKrEncoder","gb18030::Gb18030Encoder","iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState","shift_jis::ShiftJisEncoder","single_byte::SingleByteEncoder","utf_8::Utf8Encoder","variant::VariantEncoder","variant::VariantEncoding","x_user_defined::UserDefinedEncoder"]},"glob_path_import":{},"self_to_fn":{"BomHandling":["Clone","Copy","Debug"],"CoderResult":["Debug","Eq","PartialEq"],"Decoder":["impl Decoder {\n    fn new(enc: &'static Encoding, decoder: VariantDecoder, sniffing: BomHandling) -> Decoder {\n        Decoder {\n            encoding: enc,\n            variant: decoder,\n            life_cycle: match sniffing {\n                BomHandling::Off => DecoderLifeCycle::Converting,\n                BomHandling::Sniff => DecoderLifeCycle::AtStart,\n                BomHandling::Remove => {\n                    if enc == UTF_8 {\n                        DecoderLifeCycle::AtUtf8Start\n                    } else if enc == UTF_16BE {\n                        DecoderLifeCycle::AtUtf16BeStart\n                    } else if enc == UTF_16LE {\n                        DecoderLifeCycle::AtUtf16LeStart\n                    } else {\n                        DecoderLifeCycle::Converting\n                    }\n                }\n            },\n        }\n    }\n\n    /// The `Encoding` this `Decoder` is for.\n    ///\n    /// BOM sniffing can change the return value of this method during the life\n    /// of the decoder.\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn encoding(&self) -> &'static Encoding {\n        self.encoding\n    }\n\n    /// Query the worst-case UTF-8 output size _with replacement_.\n    ///\n    /// Returns the size of the output buffer in UTF-8 code units (`u8`)\n    /// that will not overflow given the current state of the decoder and\n    /// `byte_length` number of additional input bytes when decoding with\n    /// errors handled by outputting a REPLACEMENT CHARACTER for each malformed\n    /// sequence or `None` if `usize` would overflow.\n    ///\n    /// Available via the C wrapper.\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        // Need to consider a) the decoder morphing due to the BOM and b) a partial\n        // BOM getting pushed to the underlying decoder.\n        match self.life_cycle {\n            DecoderLifeCycle::Converting\n            | DecoderLifeCycle::AtUtf8Start\n            | DecoderLifeCycle::AtUtf16LeStart\n            | DecoderLifeCycle::AtUtf16BeStart => {\n                return self.variant.max_utf8_buffer_length(byte_length);\n            }\n            DecoderLifeCycle::AtStart => {\n                if let Some(utf8_bom) = checked_add(3, byte_length.checked_mul(3)) {\n                    if let Some(utf16_bom) = checked_add(\n                        1,\n                        checked_mul(3, checked_div(byte_length.checked_add(1), 2)),\n                    ) {\n                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);\n                        let encoding = self.encoding();\n                        if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf_bom);\n                        } else if let Some(non_bom) =\n                            self.variant.max_utf8_buffer_length(byte_length)\n                        {\n                            return Some(std::cmp::max(utf_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::SeenUtf8First | DecoderLifeCycle::SeenUtf8Second => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf8_bom) = checked_add(3, sum.checked_mul(3)) {\n                        if self.encoding() == UTF_8 {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf8_bom);\n                        } else if let Some(non_bom) = self.variant.max_utf8_buffer_length(sum) {\n                            return Some(std::cmp::max(utf8_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::ConvertingWithPendingBB => {\n                if let Some(sum) = byte_length.checked_add(2) {\n                    return self.variant.max_utf8_buffer_length(sum);\n                }\n            }\n            DecoderLifeCycle::SeenUtf16LeFirst | DecoderLifeCycle::SeenUtf16BeFirst => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf16_bom) =\n                        checked_add(1, checked_mul(3, checked_div(sum.checked_add(1), 2)))\n                    {\n                        let encoding = self.encoding();\n                        if encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf16_bom);\n                        } else if let Some(non_bom) = self.variant.max_utf8_buffer_length(sum) {\n                            return Some(std::cmp::max(utf16_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::Finished => panic!(\"Must not use a decoder that has finished.\"),\n        }\n        None\n    }\n\n    /// Query the worst-case UTF-8 output size _without replacement_.\n    ///\n    /// Returns the size of the output buffer in UTF-8 code units (`u8`)\n    /// that will not overflow given the current state of the decoder and\n    /// `byte_length` number of additional input bytes when decoding without\n    /// replacement error handling or `None` if `usize` would overflow.\n    ///\n    /// Note that this value may be too small for the `_with_replacement` case.\n    /// Use `max_utf8_buffer_length()` for that case.\n    ///\n    /// Available via the C wrapper.\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        // Need to consider a) the decoder morphing due to the BOM and b) a partial\n        // BOM getting pushed to the underlying decoder.\n        match self.life_cycle {\n            DecoderLifeCycle::Converting\n            | DecoderLifeCycle::AtUtf8Start\n            | DecoderLifeCycle::AtUtf16LeStart\n            | DecoderLifeCycle::AtUtf16BeStart => {\n                return self\n                    .variant\n                    .max_utf8_buffer_length_without_replacement(byte_length);\n            }\n            DecoderLifeCycle::AtStart => {\n                if let Some(utf8_bom) = byte_length.checked_add(3) {\n                    if let Some(utf16_bom) = checked_add(\n                        1,\n                        checked_mul(3, checked_div(byte_length.checked_add(1), 2)),\n                    ) {\n                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);\n                        let encoding = self.encoding();\n                        if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf_bom);\n                        } else if let Some(non_bom) = self\n                            .variant\n                            .max_utf8_buffer_length_without_replacement(byte_length)\n                        {\n                            return Some(std::cmp::max(utf_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::SeenUtf8First | DecoderLifeCycle::SeenUtf8Second => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf8_bom) = sum.checked_add(3) {\n                        if self.encoding() == UTF_8 {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf8_bom);\n                        } else if let Some(non_bom) =\n                            self.variant.max_utf8_buffer_length_without_replacement(sum)\n                        {\n                            return Some(std::cmp::max(utf8_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::ConvertingWithPendingBB => {\n                if let Some(sum) = byte_length.checked_add(2) {\n                    return self.variant.max_utf8_buffer_length_without_replacement(sum);\n                }\n            }\n            DecoderLifeCycle::SeenUtf16LeFirst | DecoderLifeCycle::SeenUtf16BeFirst => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf16_bom) =\n                        checked_add(1, checked_mul(3, checked_div(sum.checked_add(1), 2)))\n                    {\n                        let encoding = self.encoding();\n                        if encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf16_bom);\n                        } else if let Some(non_bom) =\n                            self.variant.max_utf8_buffer_length_without_replacement(sum)\n                        {\n                            return Some(std::cmp::max(utf16_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::Finished => panic!(\"Must not use a decoder that has finished.\"),\n        }\n        None\n    }\n\n    /// Incrementally decode a byte stream into UTF-8 with malformed sequences\n    /// replaced with the REPLACEMENT CHARACTER.\n    ///\n    /// See the documentation of the struct for documentation for `decode_*`\n    /// methods collectively.\n    ///\n    /// Available via the C wrapper.\n    pub fn decode_to_utf8(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u8],\n        last: bool,\n    ) -> (CoderResult, usize, usize, bool) {\n        let mut had_errors = false;\n        let mut total_read = 0usize;\n        let mut total_written = 0usize;\n        loop {\n            let (result, read, written) = self.decode_to_utf8_without_replacement(\n                &src[total_read..],\n                &mut dst[total_written..],\n                last,\n            );\n            total_read += read;\n            total_written += written;\n            match result {\n                DecoderResult::InputEmpty => {\n                    return (\n                        CoderResult::InputEmpty,\n                        total_read,\n                        total_written,\n                        had_errors,\n                    );\n                }\n                DecoderResult::OutputFull => {\n                    return (\n                        CoderResult::OutputFull,\n                        total_read,\n                        total_written,\n                        had_errors,\n                    );\n                }\n                DecoderResult::Malformed(_, _) => {\n                    had_errors = true;\n                    // There should always be space for the U+FFFD, because\n                    // otherwise we'd have gotten OutputFull already.\n                    // XXX: is the above comment actually true for UTF-8 itself?\n                    // TODO: Consider having fewer bound checks here.\n                    dst[total_written] = 0xEFu8;\n                    total_written += 1;\n                    dst[total_written] = 0xBFu8;\n                    total_written += 1;\n                    dst[total_written] = 0xBDu8;\n                    total_written += 1;\n                }\n            }\n        }\n    }\n\n    /// Incrementally decode a byte stream into UTF-8 with malformed sequences\n    /// replaced with the REPLACEMENT CHARACTER with type system signaling\n    /// of UTF-8 validity.\n    ///\n    /// This methods calls `decode_to_utf8` and then zeroes\n    /// out up to three bytes that aren't logically part of the write in order\n    /// to retain the UTF-8 validity even for the unwritten part of the buffer.\n    ///\n    /// See the documentation of the struct for documentation for `decode_*`\n    /// methods collectively.\n    ///\n    /// Available to Rust only.\n    pub fn decode_to_str(\n        &mut self,\n        src: &[u8],\n        dst: &mut str,\n        last: bool,\n    ) -> (CoderResult, usize, usize, bool) {\n        let bytes: &mut [u8] = unsafe { dst.as_bytes_mut() };\n        let (result, read, written, replaced) = self.decode_to_utf8(src, bytes, last);\n        let len = bytes.len();\n        let mut trail = written;\n        // Non-UTF-8 ASCII-compatible decoders may write up to `MAX_STRIDE_SIZE`\n        // bytes of trailing garbage. No need to optimize non-ASCII-compatible\n        // encodings to avoid overwriting here.\n        if self.encoding != UTF_8 {\n            let max = std::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);\n            while trail < max {\n                bytes[trail] = 0;\n                trail += 1;\n            }\n        }\n        while trail < len && ((bytes[trail] & 0xC0) == 0x80) {\n            bytes[trail] = 0;\n            trail += 1;\n        }\n        (result, read, written, replaced)\n    }\n\n    /// Incrementally decode a byte stream into UTF-8 with malformed sequences\n    /// replaced with the REPLACEMENT CHARACTER using a `String` receiver.\n    ///\n    /// Like the others, this method follows the logic that the output buffer is\n    /// caller-allocated. This method treats the capacity of the `String` as\n    /// the output limit. That is, this method guarantees not to cause a\n    /// reallocation of the backing buffer of `String`.\n    ///\n    /// The return value is a tuple that contains the `DecoderResult`, the\n    /// number of bytes read and a boolean indicating whether replacements\n    /// were done. The number of bytes written is signaled via the length of\n    /// the `String` changing.\n    ///\n    /// See the documentation of the struct for documentation for `decode_*`\n    /// methods collectively.\n    ///\n    /// Available to Rust only.\n    pub fn decode_to_string(\n        &mut self,\n        src: &[u8],\n        dst: &mut String,\n        last: bool,\n    ) -> (CoderResult, usize, bool) {\n        unsafe {\n            let vec = dst.as_mut_vec();\n            let old_len = vec.len();\n            let capacity = vec.capacity();\n            vec.set_len(capacity);\n            let (result, read, written, replaced) =\n                self.decode_to_utf8(src, &mut vec[old_len..], last);\n            vec.set_len(old_len + written);\n            (result, read, replaced)\n        }\n    }\n\n    public_decode_function!(/// Incrementally decode a byte stream into UTF-8\n                            /// _without replacement_.\n                            ///\n                            /// See the documentation of the struct for\n                            /// documentation for `decode_*` methods\n                            /// collectively.\n                            ///\n                            /// Available via the C wrapper.\n                            ,\n                            decode_to_utf8_without_replacement,\n                            decode_to_utf8_raw,\n                            decode_to_utf8_checking_end,\n                            decode_to_utf8_after_one_potential_bom_byte,\n                            decode_to_utf8_after_two_potential_bom_bytes,\n                            decode_to_utf8_checking_end_with_offset,\n                            u8);\n\n    /// Incrementally decode a byte stream into UTF-8 with type system signaling\n    /// of UTF-8 validity.\n    ///\n    /// This methods calls `decode_to_utf8` and then zeroes out up to three\n    /// bytes that aren't logically part of the write in order to retain the\n    /// UTF-8 validity even for the unwritten part of the buffer.\n    ///\n    /// See the documentation of the struct for documentation for `decode_*`\n    /// methods collectively.\n    ///\n    /// Available to Rust only.\n    pub fn decode_to_str_without_replacement(\n        &mut self,\n        src: &[u8],\n        dst: &mut str,\n        last: bool,\n    ) -> (DecoderResult, usize, usize) {\n        let bytes: &mut [u8] = unsafe { dst.as_bytes_mut() };\n        let (result, read, written) = self.decode_to_utf8_without_replacement(src, bytes, last);\n        let len = bytes.len();\n        let mut trail = written;\n        // Non-UTF-8 ASCII-compatible decoders may write up to `MAX_STRIDE_SIZE`\n        // bytes of trailing garbage. No need to optimize non-ASCII-compatible\n        // encodings to avoid overwriting here.\n        if self.encoding != UTF_8 {\n            let max = std::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);\n            while trail < max {\n                bytes[trail] = 0;\n                trail += 1;\n            }\n        }\n        while trail < len && ((bytes[trail] & 0xC0) == 0x80) {\n            bytes[trail] = 0;\n            trail += 1;\n        }\n        (result, read, written)\n    }\n\n    /// Incrementally decode a byte stream into UTF-8 using a `String` receiver.\n    ///\n    /// Like the others, this method follows the logic that the output buffer is\n    /// caller-allocated. This method treats the capacity of the `String` as\n    /// the output limit. That is, this method guarantees not to cause a\n    /// reallocation of the backing buffer of `String`.\n    ///\n    /// The return value is a pair that contains the `DecoderResult` and the\n    /// number of bytes read. The number of bytes written is signaled via\n    /// the length of the `String` changing.\n    ///\n    /// See the documentation of the struct for documentation for `decode_*`\n    /// methods collectively.\n    ///\n    /// Available to Rust only.\n    pub fn decode_to_string_without_replacement(\n        &mut self,\n        src: &[u8],\n        dst: &mut String,\n        last: bool,\n    ) -> (DecoderResult, usize) {\n        unsafe {\n            let vec = dst.as_mut_vec();\n            let old_len = vec.len();\n            let capacity = vec.capacity();\n            vec.set_len(capacity);\n            let (result, read, written) =\n                self.decode_to_utf8_without_replacement(src, &mut vec[old_len..], last);\n            vec.set_len(old_len + written);\n            (result, read)\n        }\n    }\n\n    /// Query the worst-case UTF-16 output size (with or without replacement).\n    ///\n    /// Returns the size of the output buffer in UTF-16 code units (`u16`)\n    /// that will not overflow given the current state of the decoder and\n    /// `byte_length` number of additional input bytes or `None` if `usize`\n    /// would overflow.\n    ///\n    /// Since the REPLACEMENT CHARACTER fits into one UTF-16 code unit, the\n    /// return value of this method applies also in the\n    /// `_without_replacement` case.\n    ///\n    /// Available via the C wrapper.\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        // Need to consider a) the decoder morphing due to the BOM and b) a partial\n        // BOM getting pushed to the underlying decoder.\n        match self.life_cycle {\n            DecoderLifeCycle::Converting\n            | DecoderLifeCycle::AtUtf8Start\n            | DecoderLifeCycle::AtUtf16LeStart\n            | DecoderLifeCycle::AtUtf16BeStart => {\n                return self.variant.max_utf16_buffer_length(byte_length);\n            }\n            DecoderLifeCycle::AtStart => {\n                if let Some(utf8_bom) = byte_length.checked_add(1) {\n                    if let Some(utf16_bom) =\n                        checked_add(1, checked_div(byte_length.checked_add(1), 2))\n                    {\n                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);\n                        let encoding = self.encoding();\n                        if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf_bom);\n                        } else if let Some(non_bom) =\n                            self.variant.max_utf16_buffer_length(byte_length)\n                        {\n                            return Some(std::cmp::max(utf_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::SeenUtf8First | DecoderLifeCycle::SeenUtf8Second => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf8_bom) = sum.checked_add(1) {\n                        if self.encoding() == UTF_8 {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf8_bom);\n                        } else if let Some(non_bom) = self.variant.max_utf16_buffer_length(sum) {\n                            return Some(std::cmp::max(utf8_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::ConvertingWithPendingBB => {\n                if let Some(sum) = byte_length.checked_add(2) {\n                    return self.variant.max_utf16_buffer_length(sum);\n                }\n            }\n            DecoderLifeCycle::SeenUtf16LeFirst | DecoderLifeCycle::SeenUtf16BeFirst => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf16_bom) = checked_add(1, checked_div(sum.checked_add(1), 2)) {\n                        let encoding = self.encoding();\n                        if encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf16_bom);\n                        } else if let Some(non_bom) = self.variant.max_utf16_buffer_length(sum) {\n                            return Some(std::cmp::max(utf16_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::Finished => panic!(\"Must not use a decoder that has finished.\"),\n        }\n        None\n    }\n\n    /// Incrementally decode a byte stream into UTF-16 with malformed sequences\n    /// replaced with the REPLACEMENT CHARACTER.\n    ///\n    /// See the documentation of the struct for documentation for `decode_*`\n    /// methods collectively.\n    ///\n    /// Available via the C wrapper.\n    pub fn decode_to_utf16(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u16],\n        last: bool,\n    ) -> (CoderResult, usize, usize, bool) {\n        let mut had_errors = false;\n        let mut total_read = 0usize;\n        let mut total_written = 0usize;\n        loop {\n            let (result, read, written) = self.decode_to_utf16_without_replacement(\n                &src[total_read..],\n                &mut dst[total_written..],\n                last,\n            );\n            total_read += read;\n            total_written += written;\n            match result {\n                DecoderResult::InputEmpty => {\n                    return (\n                        CoderResult::InputEmpty,\n                        total_read,\n                        total_written,\n                        had_errors,\n                    );\n                }\n                DecoderResult::OutputFull => {\n                    return (\n                        CoderResult::OutputFull,\n                        total_read,\n                        total_written,\n                        had_errors,\n                    );\n                }\n                DecoderResult::Malformed(_, _) => {\n                    had_errors = true;\n                    // There should always be space for the U+FFFD, because\n                    // otherwise we'd have gotten OutputFull already.\n                    dst[total_written] = 0xFFFD;\n                    total_written += 1;\n                }\n            }\n        }\n    }\n\n    public_decode_function!(/// Incrementally decode a byte stream into UTF-16\n                            /// _without replacement_.\n                            ///\n                            /// See the documentation of the struct for\n                            /// documentation for `decode_*` methods\n                            /// collectively.\n                            ///\n                            /// Available via the C wrapper.\n                            ,\n                            decode_to_utf16_without_replacement,\n                            decode_to_utf16_raw,\n                            decode_to_utf16_checking_end,\n                            decode_to_utf16_after_one_potential_bom_byte,\n                            decode_to_utf16_after_two_potential_bom_bytes,\n                            decode_to_utf16_checking_end_with_offset,\n                            u16);\n\n    /// Checks for compatibility with storing Unicode scalar values as unsigned\n    /// bytes taking into account the state of the decoder.\n    ///\n    /// Returns `None` if the decoder is not in a neutral state, including waiting\n    /// for the BOM, or if the encoding is never Latin1-byte-compatible.\n    ///\n    /// Otherwise returns the index of the first byte whose unsigned value doesn't\n    /// directly correspond to the decoded Unicode scalar value, or the length\n    /// of the input if all bytes in the input decode directly to scalar values\n    /// corresponding to the unsigned byte values.\n    ///\n    /// Does not change the state of the decoder.\n    ///\n    /// Do not use this unless you are supporting SpiderMonkey/V8-style string\n    /// storage optimizations.\n    ///\n    /// Available via the C wrapper.\n    pub fn latin1_byte_compatible_up_to(&self, bytes: &[u8]) -> Option<usize> {\n        match self.life_cycle {\n            DecoderLifeCycle::Converting => {\n                return self.variant.latin1_byte_compatible_up_to(bytes);\n            }\n            DecoderLifeCycle::Finished => panic!(\"Must not use a decoder that has finished.\"),\n            _ => None,\n        }\n    }\n}"],"DecoderLifeCycle":["Clone","Copy","Debug","PartialEq"],"DecoderResult":["Debug","Eq","PartialEq"],"Encoder":["impl Encoder {\n    fn new(enc: &'static Encoding, encoder: VariantEncoder) -> Encoder {\n        Encoder {\n            encoding: enc,\n            variant: encoder,\n        }\n    }\n\n    /// The `Encoding` this `Encoder` is for.\n    #[inline]\n    pub fn encoding(&self) -> &'static Encoding {\n        self.encoding\n    }\n\n    /// Returns `true` if this is an ISO-2022-JP encoder that's not in the\n    /// ASCII state and `false` otherwise.\n    #[inline]\n    pub fn has_pending_state(&self) -> bool {\n        self.variant.has_pending_state()\n    }\n\n    /// Query the worst-case output size when encoding from UTF-8 with\n    /// replacement.\n    ///\n    /// Returns the size of the output buffer in bytes that will not overflow\n    /// given the current state of the encoder and `byte_length` number of\n    /// additional input code units if there are no unmappable characters in\n    /// the input or `None` if `usize` would overflow.\n    ///\n    /// Available via the C wrapper.\n    pub fn max_buffer_length_from_utf8_if_no_unmappables(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        checked_add(\n            if self.encoding().can_encode_everything() {\n                0\n            } else {\n                NCR_EXTRA\n            },\n            self.max_buffer_length_from_utf8_without_replacement(byte_length),\n        )\n    }\n\n    /// Query the worst-case output size when encoding from UTF-8 without\n    /// replacement.\n    ///\n    /// Returns the size of the output buffer in bytes that will not overflow\n    /// given the current state of the encoder and `byte_length` number of\n    /// additional input code units or `None` if `usize` would overflow.\n    ///\n    /// Available via the C wrapper.\n    pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        self.variant\n            .max_buffer_length_from_utf8_without_replacement(byte_length)\n    }\n\n    /// Incrementally encode into byte stream from UTF-8 with unmappable\n    /// characters replaced with HTML (decimal) numeric character references.\n    ///\n    /// See the documentation of the struct for documentation for `encode_*`\n    /// methods collectively.\n    ///\n    /// Available via the C wrapper.\n    pub fn encode_from_utf8(\n        &mut self,\n        src: &str,\n        dst: &mut [u8],\n        last: bool,\n    ) -> (CoderResult, usize, usize, bool) {\n        let dst_len = dst.len();\n        let effective_dst_len = if self.encoding().can_encode_everything() {\n            dst_len\n        } else {\n            if dst_len < NCR_EXTRA {\n                if src.is_empty() && !(last && self.has_pending_state()) {\n                    return (CoderResult::InputEmpty, 0, 0, false);\n                }\n                return (CoderResult::OutputFull, 0, 0, false);\n            }\n            dst_len - NCR_EXTRA\n        };\n        let mut had_unmappables = false;\n        let mut total_read = 0usize;\n        let mut total_written = 0usize;\n        loop {\n            let (result, read, written) = self.encode_from_utf8_without_replacement(\n                &src[total_read..],\n                &mut dst[total_written..effective_dst_len],\n                last,\n            );\n            total_read += read;\n            total_written += written;\n            match result {\n                EncoderResult::InputEmpty => {\n                    return (\n                        CoderResult::InputEmpty,\n                        total_read,\n                        total_written,\n                        had_unmappables,\n                    );\n                }\n                EncoderResult::OutputFull => {\n                    return (\n                        CoderResult::OutputFull,\n                        total_read,\n                        total_written,\n                        had_unmappables,\n                    );\n                }\n                EncoderResult::Unmappable(unmappable) => {\n                    had_unmappables = true;\n                    debug_assert!(dst.len() - total_written >= NCR_EXTRA);\n                    debug_assert_ne!(self.encoding(), UTF_16BE);\n                    debug_assert_ne!(self.encoding(), UTF_16LE);\n                    // Additionally, Iso2022JpEncoder is responsible for\n                    // transitioning to ASCII when returning with Unmappable.\n                    total_written += write_ncr(unmappable, &mut dst[total_written..]);\n                    if total_written >= effective_dst_len {\n                        if total_read == src.len() && !(last && self.has_pending_state()) {\n                            return (\n                                CoderResult::InputEmpty,\n                                total_read,\n                                total_written,\n                                had_unmappables,\n                            );\n                        }\n                        return (\n                            CoderResult::OutputFull,\n                            total_read,\n                            total_written,\n                            had_unmappables,\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    /// Incrementally encode into byte stream from UTF-8 with unmappable\n    /// characters replaced with HTML (decimal) numeric character references.\n    ///\n    /// See the documentation of the struct for documentation for `encode_*`\n    /// methods collectively.\n    ///\n    /// Available to Rust only.\n    pub fn encode_from_utf8_to_vec(\n        &mut self,\n        src: &str,\n        dst: &mut Vec<u8>,\n        last: bool,\n    ) -> (CoderResult, usize, bool) {\n        unsafe {\n            let old_len = dst.len();\n            let capacity = dst.capacity();\n            dst.set_len(capacity);\n            let (result, read, written, replaced) =\n                self.encode_from_utf8(src, &mut dst[old_len..], last);\n            dst.set_len(old_len + written);\n            (result, read, replaced)\n        }\n    }\n\n    /// Incrementally encode into byte stream from UTF-8 _without replacement_.\n    ///\n    /// See the documentation of the struct for documentation for `encode_*`\n    /// methods collectively.\n    ///\n    /// Available via the C wrapper.\n    pub fn encode_from_utf8_without_replacement(\n        &mut self,\n        src: &str,\n        dst: &mut [u8],\n        last: bool,\n    ) -> (EncoderResult, usize, usize) {\n        self.variant.encode_from_utf8_raw(src, dst, last)\n    }\n\n    /// Incrementally encode into byte stream from UTF-8 _without replacement_.\n    ///\n    /// See the documentation of the struct for documentation for `encode_*`\n    /// methods collectively.\n    ///\n    /// Available to Rust only.\n    pub fn encode_from_utf8_to_vec_without_replacement(\n        &mut self,\n        src: &str,\n        dst: &mut Vec<u8>,\n        last: bool,\n    ) -> (EncoderResult, usize) {\n        unsafe {\n            let old_len = dst.len();\n            let capacity = dst.capacity();\n            dst.set_len(capacity);\n            let (result, read, written) =\n                self.encode_from_utf8_without_replacement(src, &mut dst[old_len..], last);\n            dst.set_len(old_len + written);\n            (result, read)\n        }\n    }\n\n    /// Query the worst-case output size when encoding from UTF-16 with\n    /// replacement.\n    ///\n    /// Returns the size of the output buffer in bytes that will not overflow\n    /// given the current state of the encoder and `u16_length` number of\n    /// additional input code units if there are no unmappable characters in\n    /// the input or `None` if `usize` would overflow.\n    ///\n    /// Available via the C wrapper.\n    pub fn max_buffer_length_from_utf16_if_no_unmappables(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        checked_add(\n            if self.encoding().can_encode_everything() {\n                0\n            } else {\n                NCR_EXTRA\n            },\n            self.max_buffer_length_from_utf16_without_replacement(u16_length),\n        )\n    }\n\n    /// Query the worst-case output size when encoding from UTF-16 without\n    /// replacement.\n    ///\n    /// Returns the size of the output buffer in bytes that will not overflow\n    /// given the current state of the encoder and `u16_length` number of\n    /// additional input code units or `None` if `usize` would overflow.\n    ///\n    /// Available via the C wrapper.\n    pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        self.variant\n            .max_buffer_length_from_utf16_without_replacement(u16_length)\n    }\n\n    /// Incrementally encode into byte stream from UTF-16 with unmappable\n    /// characters replaced with HTML (decimal) numeric character references.\n    ///\n    /// See the documentation of the struct for documentation for `encode_*`\n    /// methods collectively.\n    ///\n    /// Available via the C wrapper.\n    pub fn encode_from_utf16(\n        &mut self,\n        src: &[u16],\n        dst: &mut [u8],\n        last: bool,\n    ) -> (CoderResult, usize, usize, bool) {\n        let dst_len = dst.len();\n        let effective_dst_len = if self.encoding().can_encode_everything() {\n            dst_len\n        } else {\n            if dst_len < NCR_EXTRA {\n                if src.is_empty() && !(last && self.has_pending_state()) {\n                    return (CoderResult::InputEmpty, 0, 0, false);\n                }\n                return (CoderResult::OutputFull, 0, 0, false);\n            }\n            dst_len - NCR_EXTRA\n        };\n        let mut had_unmappables = false;\n        let mut total_read = 0usize;\n        let mut total_written = 0usize;\n        loop {\n            let (result, read, written) = self.encode_from_utf16_without_replacement(\n                &src[total_read..],\n                &mut dst[total_written..effective_dst_len],\n                last,\n            );\n            total_read += read;\n            total_written += written;\n            match result {\n                EncoderResult::InputEmpty => {\n                    return (\n                        CoderResult::InputEmpty,\n                        total_read,\n                        total_written,\n                        had_unmappables,\n                    );\n                }\n                EncoderResult::OutputFull => {\n                    return (\n                        CoderResult::OutputFull,\n                        total_read,\n                        total_written,\n                        had_unmappables,\n                    );\n                }\n                EncoderResult::Unmappable(unmappable) => {\n                    had_unmappables = true;\n                    debug_assert!(dst.len() - total_written >= NCR_EXTRA);\n                    // There are no UTF-16 encoders and even if there were,\n                    // they'd never have unmappables.\n                    debug_assert_ne!(self.encoding(), UTF_16BE);\n                    debug_assert_ne!(self.encoding(), UTF_16LE);\n                    // Additionally, Iso2022JpEncoder is responsible for\n                    // transitioning to ASCII when returning with Unmappable\n                    // from the jis0208 state. That is, when we encode\n                    // ISO-2022-JP and come here, the encoder is in either the\n                    // ASCII or the Roman state. We are allowed to generate any\n                    // printable ASCII excluding \\ and ~.\n                    total_written += write_ncr(unmappable, &mut dst[total_written..]);\n                    if total_written >= effective_dst_len {\n                        if total_read == src.len() && !(last && self.has_pending_state()) {\n                            return (\n                                CoderResult::InputEmpty,\n                                total_read,\n                                total_written,\n                                had_unmappables,\n                            );\n                        }\n                        return (\n                            CoderResult::OutputFull,\n                            total_read,\n                            total_written,\n                            had_unmappables,\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    /// Incrementally encode into byte stream from UTF-16 _without replacement_.\n    ///\n    /// See the documentation of the struct for documentation for `encode_*`\n    /// methods collectively.\n    ///\n    /// Available via the C wrapper.\n    pub fn encode_from_utf16_without_replacement(\n        &mut self,\n        src: &[u16],\n        dst: &mut [u8],\n        last: bool,\n    ) -> (EncoderResult, usize, usize) {\n        self.variant.encode_from_utf16_raw(src, dst, last)\n    }\n}"],"EncoderResult":["Debug","Eq","PartialEq","impl EncoderResult {\n    fn unmappable_from_bmp(bmp: u16) -> EncoderResult {\n        EncoderResult::Unmappable(::std::char::from_u32(u32::from(bmp)).unwrap())\n    }\n}"],"Encoding":["impl Encoding {\n    /// Implements the\n    /// [_get an encoding_](https://encoding.spec.whatwg.org/#concept-encoding-get)\n    /// algorithm.\n    ///\n    /// If, after ASCII-lowercasing and removing leading and trailing\n    /// whitespace, the argument matches a label defined in the Encoding\n    /// Standard, `Some(&'static Encoding)` representing the corresponding\n    /// encoding is returned. If there is no match, `None` is returned.\n    ///\n    /// This is the right method to use if the action upon the method returning\n    /// `None` is to use a fallback encoding (e.g. `WINDOWS_1252`) instead.\n    /// When the action upon the method returning `None` is not to proceed with\n    /// a fallback but to refuse processing, `for_label_no_replacement()` is more\n    /// appropriate.\n    ///\n    /// The argument is of type `&[u8]` instead of `&str` to save callers\n    /// that are extracting the label from a non-UTF-8 protocol the trouble\n    /// of conversion to UTF-8. (If you have a `&str`, just call `.as_bytes()`\n    /// on it.)\n    ///\n    /// Available via the C wrapper.\n    pub fn for_label(label: &[u8]) -> Option<&'static Encoding> {\n        let mut trimmed = [0u8; LONGEST_LABEL_LENGTH];\n        let mut trimmed_pos = 0usize;\n        let mut iter = label.into_iter();\n        // before\n        loop {\n            match iter.next() {\n                None => {\n                    return None;\n                }\n                Some(byte) => {\n                    // The characters used in labels are:\n                    // a-z (except q, but excluding it below seems excessive)\n                    // 0-9\n                    // . _ - :\n                    match *byte {\n                        0x09u8 | 0x0Au8 | 0x0Cu8 | 0x0Du8 | 0x20u8 => {\n                            continue;\n                        }\n                        b'A'...b'Z' => {\n                            trimmed[trimmed_pos] = *byte + 0x20u8;\n                            trimmed_pos = 1usize;\n                            break;\n                        }\n                        b'a'...b'z' | b'0'...b'9' | b'-' | b'_' | b':' | b'.' => {\n                            trimmed[trimmed_pos] = *byte;\n                            trimmed_pos = 1usize;\n                            break;\n                        }\n                        _ => {\n                            return None;\n                        }\n                    }\n                }\n            }\n        }\n        // inside\n        loop {\n            match iter.next() {\n                None => {\n                    break;\n                }\n                Some(byte) => {\n                    match *byte {\n                        0x09u8 | 0x0Au8 | 0x0Cu8 | 0x0Du8 | 0x20u8 => {\n                            break;\n                        }\n                        b'A'...b'Z' => {\n                            if trimmed_pos == LONGEST_LABEL_LENGTH {\n                                // There's no encoding with a label this long\n                                return None;\n                            }\n                            trimmed[trimmed_pos] = *byte + 0x20u8;\n                            trimmed_pos += 1usize;\n                            continue;\n                        }\n                        b'a'...b'z' | b'0'...b'9' | b'-' | b'_' | b':' | b'.' => {\n                            if trimmed_pos == LONGEST_LABEL_LENGTH {\n                                // There's no encoding with a label this long\n                                return None;\n                            }\n                            trimmed[trimmed_pos] = *byte;\n                            trimmed_pos += 1usize;\n                            continue;\n                        }\n                        _ => {\n                            return None;\n                        }\n                    }\n                }\n            }\n        }\n        // after\n        loop {\n            match iter.next() {\n                None => {\n                    break;\n                }\n                Some(byte) => {\n                    match *byte {\n                        0x09u8 | 0x0Au8 | 0x0Cu8 | 0x0Du8 | 0x20u8 => {\n                            continue;\n                        }\n                        _ => {\n                            // There's no label with space in the middle\n                            return None;\n                        }\n                    }\n                }\n            }\n        }\n        let candidate = &trimmed[..trimmed_pos];\n        match LABELS_SORTED.binary_search_by(|probe| {\n            let bytes = probe.as_bytes();\n            let c = bytes.len().cmp(&candidate.len());\n            if c != Ordering::Equal {\n                return c;\n            }\n            let probe_iter = bytes.iter().rev();\n            let candidate_iter = candidate.iter().rev();\n            probe_iter.cmp(candidate_iter)\n        }) {\n            Ok(i) => Some(ENCODINGS_IN_LABEL_SORT[i]),\n            Err(_) => None,\n        }\n    }\n\n    /// This method behaves the same as `for_label()`, except when `for_label()`\n    /// would return `Some(REPLACEMENT)`, this method returns `None` instead.\n    ///\n    /// This method is useful in scenarios where a fatal error is required\n    /// upon invalid label, because in those cases the caller typically wishes\n    /// to treat the labels that map to the replacement encoding as fatal\n    /// errors, too.\n    ///\n    /// It is not OK to use this method when the action upon the method returning\n    /// `None` is to use a fallback encoding (e.g. `WINDOWS_1252`). In such a\n    /// case, the `for_label()` method should be used instead in order to avoid\n    /// unsafe fallback for labels that `for_label()` maps to `Some(REPLACEMENT)`.\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn for_label_no_replacement(label: &[u8]) -> Option<&'static Encoding> {\n        match Encoding::for_label(label) {\n            None => None,\n            Some(encoding) => {\n                if encoding == REPLACEMENT {\n                    None\n                } else {\n                    Some(encoding)\n                }\n            }\n        }\n    }\n\n    /// Performs non-incremental BOM sniffing.\n    ///\n    /// The argument must either be a buffer representing the entire input\n    /// stream (non-streaming case) or a buffer representing at least the first\n    /// three bytes of the input stream (streaming case).\n    ///\n    /// Returns `Some((UTF_8, 3))`, `Some((UTF_16LE, 2))` or\n    /// `Some((UTF_16BE, 2))` if the argument starts with the UTF-8, UTF-16LE\n    /// or UTF-16BE BOM or `None` otherwise.\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn for_bom(buffer: &[u8]) -> Option<(&'static Encoding, usize)> {\n        if buffer.starts_with(b\"\\xEF\\xBB\\xBF\") {\n            Some((UTF_8, 3))\n        } else if buffer.starts_with(b\"\\xFF\\xFE\") {\n            Some((UTF_16LE, 2))\n        } else if buffer.starts_with(b\"\\xFE\\xFF\") {\n            Some((UTF_16BE, 2))\n        } else {\n            None\n        }\n    }\n\n    /// Returns the name of this encoding.\n    ///\n    /// This name is appropriate to return as-is from the DOM\n    /// `document.characterSet` property.\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn name(&'static self) -> &'static str {\n        self.name\n    }\n\n    /// Checks whether the _output encoding_ of this encoding can encode every\n    /// `char`. (Only true if the output encoding is UTF-8.)\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn can_encode_everything(&'static self) -> bool {\n        self.output_encoding() == UTF_8\n    }\n\n    /// Checks whether the bytes 0x00...0x7F map exclusively to the characters\n    /// U+0000...U+007F and vice versa.\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn is_ascii_compatible(&'static self) -> bool {\n        !(self == REPLACEMENT || self == UTF_16BE || self == UTF_16LE || self == ISO_2022_JP)\n    }\n\n    /// Checks whether this encoding maps one byte to one Basic Multilingual\n    /// Plane code point (i.e. byte length equals decoded UTF-16 length) and\n    /// vice versa (for mappable characters).\n    ///\n    /// `true` iff this encoding is on the list of [Legacy single-byte\n    /// encodings](https://encoding.spec.whatwg.org/#legacy-single-byte-encodings)\n    /// in the spec or x-user-defined.\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn is_single_byte(&'static self) -> bool {\n        self.variant.is_single_byte()\n    }\n\n    /// Checks whether the bytes 0x00...0x7F map mostly to the characters\n    /// U+0000...U+007F and vice versa.\n    #[inline]\n    fn is_potentially_borrowable(&'static self) -> bool {\n        !(self == REPLACEMENT || self == UTF_16BE || self == UTF_16LE)\n    }\n\n    /// Returns the _output encoding_ of this encoding. This is UTF-8 for\n    /// UTF-16BE, UTF-16LE and replacement and the encoding itself otherwise.\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn output_encoding(&'static self) -> &'static Encoding {\n        if self == REPLACEMENT || self == UTF_16BE || self == UTF_16LE {\n            UTF_8\n        } else {\n            self\n        }\n    }\n\n    /// Decode complete input to `Cow<'a, str>` _with BOM sniffing_ and with\n    /// malformed sequences replaced with the REPLACEMENT CHARACTER when the\n    /// entire input is available as a single buffer (i.e. the end of the\n    /// buffer marks the end of the stream).\n    ///\n    /// This method implements the (non-streaming version of) the\n    /// [_decode_](https://encoding.spec.whatwg.org/#decode) spec concept.\n    ///\n    /// The second item in the returned tuple is the encoding that was actually\n    /// used (which may differ from this encoding thanks to BOM sniffing).\n    ///\n    /// The third item in the returned tuple indicates whether there were\n    /// malformed sequences (that were replaced with the REPLACEMENT CHARACTER).\n    ///\n    /// _Note:_ It is wrong to use this when the input buffer represents only\n    /// a segment of the input instead of the whole input. Use `new_decoder()`\n    /// when decoding segmented input.\n    ///\n    /// This method performs a one or two heap allocations for the backing\n    /// buffer of the `String` when unable to borrow. (One allocation if not\n    /// errors and potentially another one in the presence of errors.) The\n    /// first allocation assumes jemalloc and may not be optimal with\n    /// allocators that do not use power-of-two buckets. A borrow is performed\n    /// if decoding UTF-8 and the input is valid UTF-8, if decoding an\n    /// ASCII-compatible encoding and the input is ASCII-only, or when decoding\n    /// ISO-2022-JP and the input is entirely in the ASCII state without state\n    /// transitions.\n    ///\n    /// # Panics\n    ///\n    /// If the size calculation for a heap-allocated backing buffer overflows\n    /// `usize`.\n    ///\n    /// Available to Rust only.\n    #[inline]\n    pub fn decode<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, &'static Encoding, bool) {\n        let (encoding, without_bom) = match Encoding::for_bom(bytes) {\n            Some((encoding, bom_length)) => (encoding, &bytes[bom_length..]),\n            None => (self, bytes),\n        };\n        let (cow, had_errors) = encoding.decode_without_bom_handling(without_bom);\n        (cow, encoding, had_errors)\n    }\n\n    /// Decode complete input to `Cow<'a, str>` _with BOM removal_ and with\n    /// malformed sequences replaced with the REPLACEMENT CHARACTER when the\n    /// entire input is available as a single buffer (i.e. the end of the\n    /// buffer marks the end of the stream).\n    ///\n    /// When invoked on `UTF_8`, this method implements the (non-streaming\n    /// version of) the\n    /// [_UTF-8 decode_](https://encoding.spec.whatwg.org/#utf-8-decode) spec\n    /// concept.\n    ///\n    /// The second item in the returned pair indicates whether there were\n    /// malformed sequences (that were replaced with the REPLACEMENT CHARACTER).\n    ///\n    /// _Note:_ It is wrong to use this when the input buffer represents only\n    /// a segment of the input instead of the whole input. Use\n    /// `new_decoder_with_bom_removal()` when decoding segmented input.\n    ///\n    /// This method performs a one or two heap allocations for the backing\n    /// buffer of the `String` when unable to borrow. (One allocation if not\n    /// errors and potentially another one in the presence of errors.) The\n    /// first allocation assumes jemalloc and may not be optimal with\n    /// allocators that do not use power-of-two buckets. A borrow is performed\n    /// if decoding UTF-8 and the input is valid UTF-8, if decoding an\n    /// ASCII-compatible encoding and the input is ASCII-only, or when decoding\n    /// ISO-2022-JP and the input is entirely in the ASCII state without state\n    /// transitions.\n    ///\n    /// # Panics\n    ///\n    /// If the size calculation for a heap-allocated backing buffer overflows\n    /// `usize`.\n    ///\n    /// Available to Rust only.\n    #[inline]\n    pub fn decode_with_bom_removal<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, bool) {\n        let without_bom = if self == UTF_8 && bytes.starts_with(b\"\\xEF\\xBB\\xBF\") {\n            &bytes[3..]\n        } else if (self == UTF_16LE && bytes.starts_with(b\"\\xFF\\xFE\"))\n            || (self == UTF_16BE && bytes.starts_with(b\"\\xFE\\xFF\"))\n        {\n            &bytes[2..]\n        } else {\n            bytes\n        };\n        self.decode_without_bom_handling(without_bom)\n    }\n\n    /// Decode complete input to `Cow<'a, str>` _without BOM handling_ and\n    /// with malformed sequences replaced with the REPLACEMENT CHARACTER when\n    /// the entire input is available as a single buffer (i.e. the end of the\n    /// buffer marks the end of the stream).\n    ///\n    /// When invoked on `UTF_8`, this method implements the (non-streaming\n    /// version of) the\n    /// [_UTF-8 decode without BOM_](https://encoding.spec.whatwg.org/#utf-8-decode-without-bom)\n    /// spec concept.\n    ///\n    /// The second item in the returned pair indicates whether there were\n    /// malformed sequences (that were replaced with the REPLACEMENT CHARACTER).\n    ///\n    /// _Note:_ It is wrong to use this when the input buffer represents only\n    /// a segment of the input instead of the whole input. Use\n    /// `new_decoder_without_bom_handling()` when decoding segmented input.\n    ///\n    /// This method performs a one or two heap allocations for the backing\n    /// buffer of the `String` when unable to borrow. (One allocation if not\n    /// errors and potentially another one in the presence of errors.) The\n    /// first allocation assumes jemalloc and may not be optimal with\n    /// allocators that do not use power-of-two buckets. A borrow is performed\n    /// if decoding UTF-8 and the input is valid UTF-8, if decoding an\n    /// ASCII-compatible encoding and the input is ASCII-only, or when decoding\n    /// ISO-2022-JP and the input is entirely in the ASCII state without state\n    /// transitions.\n    ///\n    /// # Panics\n    ///\n    /// If the size calculation for a heap-allocated backing buffer overflows\n    /// `usize`.\n    ///\n    /// Available to Rust only.\n    pub fn decode_without_bom_handling<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, bool) {\n        let (mut decoder, mut string, mut total_read) = if self.is_potentially_borrowable() {\n            let valid_up_to = if self == UTF_8 {\n                utf8_valid_up_to(bytes)\n            } else if self == ISO_2022_JP {\n                iso_2022_jp_ascii_valid_up_to(bytes)\n            } else {\n                ascii_valid_up_to(bytes)\n            };\n            if valid_up_to == bytes.len() {\n                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };\n                return (Cow::Borrowed(str), false);\n            }\n            let decoder = self.new_decoder_without_bom_handling();\n\n            let rounded_without_replacement = checked_next_power_of_two(checked_add(\n                valid_up_to,\n                decoder.max_utf8_buffer_length_without_replacement(bytes.len() - valid_up_to),\n            ));\n            let with_replacement = checked_add(\n                valid_up_to,\n                decoder.max_utf8_buffer_length(bytes.len() - valid_up_to),\n            );\n            let mut string = String::with_capacity(\n                checked_min(rounded_without_replacement, with_replacement).unwrap(),\n            );\n            unsafe {\n                let vec = string.as_mut_vec();\n                vec.set_len(valid_up_to);\n                std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);\n            }\n            (decoder, string, valid_up_to)\n        } else {\n            let decoder = self.new_decoder_without_bom_handling();\n            let rounded_without_replacement = checked_next_power_of_two(\n                decoder.max_utf8_buffer_length_without_replacement(bytes.len()),\n            );\n            let with_replacement = decoder.max_utf8_buffer_length(bytes.len());\n            let string = String::with_capacity(\n                checked_min(rounded_without_replacement, with_replacement).unwrap(),\n            );\n            (decoder, string, 0)\n        };\n\n        let mut total_had_errors = false;\n        loop {\n            let (result, read, had_errors) =\n                decoder.decode_to_string(&bytes[total_read..], &mut string, true);\n            total_read += read;\n            total_had_errors |= had_errors;\n            match result {\n                CoderResult::InputEmpty => {\n                    debug_assert_eq!(total_read, bytes.len());\n                    return (Cow::Owned(string), total_had_errors);\n                }\n                CoderResult::OutputFull => {\n                    // Allocate for the worst case. That is, we should come\n                    // here at most once per invocation of this method.\n                    let needed = decoder.max_utf8_buffer_length(bytes.len() - total_read);\n                    string.reserve(needed.unwrap());\n                }\n            }\n        }\n    }\n\n    /// Decode complete input to `Cow<'a, str>` _without BOM handling_ and\n    /// _with malformed sequences treated as fatal_ when the entire input is\n    /// available as a single buffer (i.e. the end of the buffer marks the end\n    /// of the stream).\n    ///\n    /// When invoked on `UTF_8`, this method implements the (non-streaming\n    /// version of) the\n    /// [_UTF-8 decode without BOM or fail_](https://encoding.spec.whatwg.org/#utf-8-decode-without-bom-or-fail)\n    /// spec concept.\n    ///\n    /// Returns `None` if a malformed sequence was encountered and the result\n    /// of the decode as `Some(String)` otherwise.\n    ///\n    /// _Note:_ It is wrong to use this when the input buffer represents only\n    /// a segment of the input instead of the whole input. Use\n    /// `new_decoder_without_bom_handling()` when decoding segmented input.\n    ///\n    /// This method performs a single heap allocation for the backing\n    /// buffer of the `String` when unable to borrow. A borrow is performed if\n    /// decoding UTF-8 and the input is valid UTF-8, if decoding an\n    /// ASCII-compatible encoding and the input is ASCII-only, or when decoding\n    /// ISO-2022-JP and the input is entirely in the ASCII state without state\n    /// transitions.\n    ///\n    /// # Panics\n    ///\n    /// If the size calculation for a heap-allocated backing buffer overflows\n    /// `usize`.\n    ///\n    /// Available to Rust only.\n    pub fn decode_without_bom_handling_and_without_replacement<'a>(\n        &'static self,\n        bytes: &'a [u8],\n    ) -> Option<Cow<'a, str>> {\n        if self == UTF_8 {\n            let valid_up_to = utf8_valid_up_to(bytes);\n            if valid_up_to == bytes.len() {\n                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };\n                return Some(Cow::Borrowed(str));\n            }\n            return None;\n        }\n        let (mut decoder, mut string, input) = if self.is_potentially_borrowable() {\n            let valid_up_to = if self == ISO_2022_JP {\n                iso_2022_jp_ascii_valid_up_to(bytes)\n            } else {\n                ascii_valid_up_to(bytes)\n            };\n            if valid_up_to == bytes.len() {\n                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };\n                return Some(Cow::Borrowed(str));\n            }\n            let decoder = self.new_decoder_without_bom_handling();\n            let mut string = String::with_capacity(\n                checked_add(\n                    valid_up_to,\n                    decoder.max_utf8_buffer_length_without_replacement(bytes.len() - valid_up_to),\n                )\n                .unwrap(),\n            );\n            unsafe {\n                let vec = string.as_mut_vec();\n                vec.set_len(valid_up_to);\n                std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);\n            }\n            (decoder, string, &bytes[valid_up_to..])\n        } else {\n            let decoder = self.new_decoder_without_bom_handling();\n            let string = String::with_capacity(\n                decoder\n                    .max_utf8_buffer_length_without_replacement(bytes.len())\n                    .unwrap(),\n            );\n            (decoder, string, bytes)\n        };\n        let (result, read) = decoder.decode_to_string_without_replacement(input, &mut string, true);\n        match result {\n            DecoderResult::InputEmpty => {\n                debug_assert_eq!(read, input.len());\n                Some(Cow::Owned(string))\n            }\n            DecoderResult::Malformed(_, _) => None,\n            DecoderResult::OutputFull => unreachable!(),\n        }\n    }\n\n    /// Encode complete input to `Cow<'a, [u8]>` with unmappable characters\n    /// replaced with decimal numeric character references when the entire input\n    /// is available as a single buffer (i.e. the end of the buffer marks the\n    /// end of the stream).\n    ///\n    /// This method implements the (non-streaming version of) the\n    /// [_encode_](https://encoding.spec.whatwg.org/#encode) spec concept. For\n    /// the [_UTF-8 encode_](https://encoding.spec.whatwg.org/#utf-8-encode)\n    /// spec concept, it is slightly more efficient to use\n    /// <code><var>string</var>.as_bytes()</code> instead of invoking this\n    /// method on `UTF_8`.\n    ///\n    /// The second item in the returned tuple is the encoding that was actually\n    /// used (which may differ from this encoding thanks to some encodings\n    /// having UTF-8 as their output encoding).\n    ///\n    /// The third item in the returned tuple indicates whether there were\n    /// unmappable characters (that were replaced with HTML numeric character\n    /// references).\n    ///\n    /// _Note:_ It is wrong to use this when the input buffer represents only\n    /// a segment of the input instead of the whole input. Use `new_encoder()`\n    /// when encoding segmented output.\n    ///\n    /// When encoding to UTF-8 or when encoding an ASCII-only input to a\n    /// ASCII-compatible encoding, this method returns a borrow of the input\n    /// without a heap allocation. Otherwise, this method performs a single\n    /// heap allocation for the backing buffer of the `Vec<u8>` if there are no\n    /// unmappable characters and potentially multiple heap allocations if\n    /// there are. These allocations are tuned for jemalloc and may not be\n    /// optimal when using a different allocator that doesn't use power-of-two\n    /// buckets.\n    ///\n    /// # Panics\n    ///\n    /// If the size calculation for a heap-allocated backing buffer overflows\n    /// `usize`.\n    ///\n    /// Available to Rust only.\n    pub fn encode<'a>(&'static self, string: &'a str) -> (Cow<'a, [u8]>, &'static Encoding, bool) {\n        let output_encoding = self.output_encoding();\n        if output_encoding == UTF_8 {\n            return (Cow::Borrowed(string.as_bytes()), output_encoding, false);\n        }\n        debug_assert!(output_encoding.is_potentially_borrowable());\n        let bytes = string.as_bytes();\n        let valid_up_to = if output_encoding == ISO_2022_JP {\n            iso_2022_jp_ascii_valid_up_to(bytes)\n        } else {\n            ascii_valid_up_to(bytes)\n        };\n        if valid_up_to == bytes.len() {\n            return (Cow::Borrowed(bytes), output_encoding, false);\n        }\n        let mut encoder = output_encoding.new_encoder();\n        let mut vec: Vec<u8> = Vec::with_capacity(\n            (checked_add(\n                valid_up_to,\n                encoder.max_buffer_length_from_utf8_if_no_unmappables(string.len() - valid_up_to),\n            ))\n            .unwrap()\n            .next_power_of_two(),\n        );\n        unsafe {\n            vec.set_len(valid_up_to);\n            std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);\n        }\n        let mut total_read = valid_up_to;\n        let mut total_had_errors = false;\n        loop {\n            let (result, read, had_errors) =\n                encoder.encode_from_utf8_to_vec(&string[total_read..], &mut vec, true);\n            total_read += read;\n            total_had_errors |= had_errors;\n            match result {\n                CoderResult::InputEmpty => {\n                    debug_assert_eq!(total_read, string.len());\n                    return (Cow::Owned(vec), output_encoding, total_had_errors);\n                }\n                CoderResult::OutputFull => {\n                    // reserve_exact wants to know how much more on top of current\n                    // length--not current capacity.\n                    let needed = encoder\n                        .max_buffer_length_from_utf8_if_no_unmappables(string.len() - total_read);\n                    let rounded = (checked_add(vec.capacity(), needed))\n                        .unwrap()\n                        .next_power_of_two();\n                    let additional = rounded - vec.len();\n                    vec.reserve_exact(additional);\n                }\n            }\n        }\n    }\n\n    fn new_variant_decoder(&'static self) -> VariantDecoder {\n        self.variant.new_variant_decoder()\n    }\n\n    /// Instantiates a new decoder for this encoding with BOM sniffing enabled.\n    ///\n    /// BOM sniffing may cause the returned decoder to morph into a decoder\n    /// for UTF-8, UTF-16LE or UTF-16BE instead of this encoding.\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn new_decoder(&'static self) -> Decoder {\n        Decoder::new(self, self.new_variant_decoder(), BomHandling::Sniff)\n    }\n\n    /// Instantiates a new decoder for this encoding with BOM removal.\n    ///\n    /// If the input starts with bytes that are the BOM for this encoding,\n    /// those bytes are removed. However, the decoder never morphs into a\n    /// decoder for another encoding: A BOM for another encoding is treated as\n    /// (potentially malformed) input to the decoding algorithm for this\n    /// encoding.\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn new_decoder_with_bom_removal(&'static self) -> Decoder {\n        Decoder::new(self, self.new_variant_decoder(), BomHandling::Remove)\n    }\n\n    /// Instantiates a new decoder for this encoding with BOM handling disabled.\n    ///\n    /// If the input starts with bytes that look like a BOM, those bytes are\n    /// not treated as a BOM. (Hence, the decoder never morphs into a decoder\n    /// for another encoding.)\n    ///\n    /// _Note:_ If the caller has performed BOM sniffing on its own but has not\n    /// removed the BOM, the caller should use `new_decoder_with_bom_removal()`\n    /// instead of this method to cause the BOM to be removed.\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn new_decoder_without_bom_handling(&'static self) -> Decoder {\n        Decoder::new(self, self.new_variant_decoder(), BomHandling::Off)\n    }\n\n    /// Instantiates a new encoder for the output encoding of this encoding.\n    ///\n    /// Available via the C wrapper.\n    #[inline]\n    pub fn new_encoder(&'static self) -> Encoder {\n        let enc = self.output_encoding();\n        enc.variant.new_encoder(enc)\n    }\n\n    /// Validates UTF-8.\n    ///\n    /// Returns the index of the first byte that makes the input malformed as\n    /// UTF-8 or the length of the slice if the slice is entirely valid.\n    ///\n    /// This is currently faster than the corresponding standard library\n    /// functionality. If this implementation gets upstreamed to the standard\n    /// library, this method may be removed in the future.\n    ///\n    /// Available via the C wrapper.\n    pub fn utf8_valid_up_to(bytes: &[u8]) -> usize {\n        utf8_valid_up_to(bytes)\n    }\n\n    /// Validates ASCII.\n    ///\n    /// Returns the index of the first byte that makes the input malformed as\n    /// ASCII or the length of the slice if the slice is entirely valid.\n    ///\n    /// Available via the C wrapper.\n    pub fn ascii_valid_up_to(bytes: &[u8]) -> usize {\n        ascii_valid_up_to(bytes)\n    }\n\n    /// Validates ISO-2022-JP ASCII-state data.\n    ///\n    /// Returns the index of the first byte that makes the input not\n    /// representable in the ASCII state of ISO-2022-JP or the length of the\n    /// slice if the slice is entirely representable in the ASCII state of\n    /// ISO-2022-JP.\n    ///\n    /// Available via the C wrapper.\n    pub fn iso_2022_jp_ascii_valid_up_to(bytes: &[u8]) -> usize {\n        iso_2022_jp_ascii_valid_up_to(bytes)\n    }\n}","impl Eq for Encoding {}","impl Hash for Encoding {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        (self as *const Encoding).hash(state);\n    }\n}","impl PartialEq for Encoding {\n    #[inline]\n    fn eq(&self, other: &Encoding) -> bool {\n        (self as *const Encoding) == (other as *const Encoding)\n    }\n}","impl std::fmt::Debug for Encoding {\n    #[inline]\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"Encoding {{ {} }}\", self.name)\n    }\n}"],"big5::Big5Decoder":["impl Big5Decoder {\n    pub fn new() -> VariantDecoder {\n        VariantDecoder::Big5(Big5Decoder { lead: None })\n    }\n\n    pub fn in_neutral_state(&self) -> bool {\n        self.lead.is_none()\n    }\n\n    fn plus_one_if_lead(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_add(match self.lead {\n            None => 0,\n            Some(_) => 1,\n        })\n    }\n\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        // If there is a lead but the next byte isn't a valid trail, an\n        // error is generated for the lead (+1). Then another iteration checks\n        // space, which needs +1 to account for the possibility of astral\n        // output or combining pair.\n        checked_add(1, self.plus_one_if_lead(byte_length))\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        // No need to account for REPLACEMENT CHARACTERS.\n        // Cases:\n        // ASCII: 1 to 1\n        // Valid pair: 2 to 2, 2 to 3 or 2 to 4, i.e. worst case 2 to 4\n        // lead set and first byte is trail: 1 to 4 worst case\n        //\n        // When checking for space for the last byte:\n        // no lead: the last byte must be ASCII (or fatal error): 1 to 1\n        // lead set: space for 4 bytes was already checked when reading the\n        // lead, hence the last lead and the last trail together are worst\n        // case 2 to 4.\n        //\n        // If lead set and the input is a single trail byte, the worst-case\n        // output is 4, so we need to add one before multiplying if lead is\n        // set.\n        //\n        // Finally, add two so that if input is non-zero, the output is at\n        // least 4.\n        checked_add(2, checked_mul(2, self.plus_one_if_lead(byte_length)))\n    }\n\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        // If there is a lead but the next byte isn't a valid trail, an\n        // error is generated for the lead (+(1*3)). Then another iteration\n        // checks space, which needs +3 to account for the possibility of astral\n        // output or combining pair. In between start and end, the worst case\n        // is that every byte is bad: *3.\n        checked_add(3, checked_mul(3, self.plus_one_if_lead(byte_length)))\n    }\n\n    ascii_compatible_two_byte_decoder_functions!(\n        {\n            // If lead is between 0x81 and 0xFE, inclusive,\n            // subtract offset 0x81.\n            let non_ascii_minus_offset =\n                non_ascii.wrapping_sub(0x81);\n            if non_ascii_minus_offset > (0xFE - 0x81) {\n                return (DecoderResult::Malformed(1, 0),\n                        source.consumed(),\n                        handle.written());\n            }\n            non_ascii_minus_offset\n        },\n        {\n            // If trail is between 0x40 and 0x7E, inclusive,\n            // subtract offset 0x40. Else if trail is\n            // between 0xA1 and 0xFE, inclusive, subtract\n            // offset 0x62.\n            // TODO: Find out which range is more probable.\n            let mut trail_minus_offset =\n                byte.wrapping_sub(0x40);\n            if trail_minus_offset > (0x7E - 0x40) {\n                let trail_minus_range_start =\n                    byte.wrapping_sub(0xA1);\n                if trail_minus_range_start >\n                   (0xFE - 0xA1) {\n                    if byte < 0x80 {\n                        return (DecoderResult::Malformed(1, 0),\n                                unread_handle_trail.unread(),\n                                handle.written());\n                    }\n                    return (DecoderResult::Malformed(2, 0),\n                            unread_handle_trail.consumed(),\n                            handle.written());\n                }\n                trail_minus_offset = byte - 0x62;\n            }\n            let pointer = lead_minus_offset as usize *\n                          157usize +\n                          trail_minus_offset as usize;\n            let rebased_pointer = pointer.wrapping_sub(942);\n            let low_bits = big5_low_bits(rebased_pointer);\n            if low_bits == 0 {\n                match pointer {\n                    1133 => {\n                        handle.write_big5_combination(0x00CAu16,\n                                                      0x0304u16)\n                    }\n                    1135 => {\n                        handle.write_big5_combination(0x00CAu16,\n                                                      0x030Cu16)\n                    }\n                    1164 => {\n                        handle.write_big5_combination(0x00EAu16,\n                                                      0x0304u16)\n                    }\n                    1166 => {\n                        handle.write_big5_combination(0x00EAu16,\n                                                      0x030Cu16)\n                    }\n                    _ => {\n                        if byte < 0x80 {\n                            return (DecoderResult::Malformed(1, 0),\n                                    unread_handle_trail.unread(),\n                                    handle.written());\n                        }\n                        return (DecoderResult::Malformed(2, 0),\n                                unread_handle_trail.consumed(),\n                                handle.written());\n                    }\n                }\n            } else if big5_is_astral(rebased_pointer) {\n                handle.write_astral(u32::from(low_bits) |\n                                    0x20000u32)\n            } else {\n                handle.write_bmp_excl_ascii(low_bits)\n            }\n        },\n        self,\n        non_ascii,\n        byte,\n        lead_minus_offset,\n        unread_handle_trail,\n        source,\n        handle,\n        'outermost,\n        copy_ascii_from_check_space_astral,\n        check_space_astral,\n        false);\n}"],"big5::Big5Encoder":["impl Big5Encoder {\n    pub fn new(encoding: &'static Encoding) -> Encoder {\n        Encoder::new(encoding, VariantEncoder::Big5(Big5Encoder))\n    }\n\n    pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        // Astral: 2 to 2\n        // ASCII: 1 to 1\n        // Other: 1 to 2\n        u16_length.checked_mul(2)\n    }\n\n    pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        // Astral: 4 to 2\n        // Upper BMP: 3 to 2\n        // Lower BMP: 2 to 2\n        // ASCII: 1 to 1\n        byte_length.checked_add(1)\n    }\n\n    ascii_compatible_encoder_functions!(\n        {\n            // For simplicity, unified ideographs\n            // in the pointer range 11206...11212 are handled\n            // as Level 1 Hanzi.\n            if let Some((lead, trail)) = big5_level1_hanzi_encode(bmp) {\n                handle.write_two(lead, trail)\n            } else {\n                let pointer = if let Some(pointer) = big5_box_encode(bmp) {\n                    pointer\n                } else if let Some(pointer) = big5_other_encode(bmp) {\n                    pointer\n                } else {\n                    return (\n                        EncoderResult::unmappable_from_bmp(bmp),\n                        source.consumed(),\n                        handle.written(),\n                    );\n                };\n                let lead = pointer / 157 + 0x81;\n                let remainder = pointer % 157;\n                let trail = if remainder < 0x3F {\n                    remainder + 0x40\n                } else {\n                    remainder + 0x62\n                };\n                handle.write_two(lead as u8, trail as u8)\n            }\n        },\n        {\n            if in_inclusive_range32(astral as u32, 0x2008A, 0x2F8A6) {\n                if let Some(rebased_pointer) = big5_astral_encode(astral as u16) {\n                    // big5_astral_encode returns rebased pointer,\n                    // so adding 0x87 instead of 0x81.\n                    let lead = rebased_pointer / 157 + 0x87;\n                    let remainder = rebased_pointer % 157;\n                    let trail = if remainder < 0x3F {\n                        remainder + 0x40\n                    } else {\n                        remainder + 0x62\n                    };\n                    handle.write_two(lead as u8, trail as u8)\n                } else {\n                    return (\n                        EncoderResult::Unmappable(astral),\n                        source.consumed(),\n                        handle.written(),\n                    );\n                }\n            } else {\n                return (\n                    EncoderResult::Unmappable(astral),\n                    source.consumed(),\n                    handle.written(),\n                );\n            }\n        },\n        bmp,\n        astral,\n        self,\n        source,\n        handle,\n        copy_ascii_to_check_space_two,\n        check_space_two,\n        false\n    );\n}"],"euc_jp::EucJpDecoder":["impl EucJpDecoder {\n    pub fn new() -> VariantDecoder {\n        VariantDecoder::EucJp(EucJpDecoder {\n            pending: EucJpPending::None,\n        })\n    }\n\n    pub fn in_neutral_state(&self) -> bool {\n        self.pending.is_none()\n    }\n\n    fn plus_one_if_lead(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_add(if self.pending.is_none() { 0 } else { 1 })\n    }\n\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        self.plus_one_if_lead(byte_length)\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        // worst case: 2 to 3\n        let len = self.plus_one_if_lead(byte_length);\n        checked_add(2, checked_add_opt(len, checked_div(checked_add(1, len), 2)))\n    }\n\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        checked_mul(3, self.plus_one_if_lead(byte_length))\n    }\n\n    euc_jp_decoder_functions!(\n        {\n            let trail_minus_offset = byte.wrapping_sub(0xA1);\n            // Fast-track Hiragana (60% according to Lunde)\n            // and Katakana (10% acconding to Lunde).\n            if jis0208_lead_minus_offset == 0x03 && trail_minus_offset < 0x53 {\n                // Hiragana\n                handle.write_upper_bmp(0x3041 + u16::from(trail_minus_offset))\n            } else if jis0208_lead_minus_offset == 0x04 && trail_minus_offset < 0x56 {\n                // Katakana\n                handle.write_upper_bmp(0x30A1 + u16::from(trail_minus_offset))\n            } else if trail_minus_offset > (0xFE - 0xA1) {\n                if byte < 0x80 {\n                    return (\n                        DecoderResult::Malformed(1, 0),\n                        unread_handle_trail.unread(),\n                        handle.written(),\n                    );\n                }\n                return (\n                    DecoderResult::Malformed(2, 0),\n                    unread_handle_trail.consumed(),\n                    handle.written(),\n                );\n            } else {\n                let pointer = mul_94(jis0208_lead_minus_offset) + usize::from(trail_minus_offset);\n                let level1_pointer = pointer.wrapping_sub(1410);\n                if level1_pointer < JIS0208_LEVEL1_KANJI.len() {\n                    handle.write_upper_bmp(JIS0208_LEVEL1_KANJI[level1_pointer])\n                } else {\n                    let level2_pointer = pointer.wrapping_sub(4418);\n                    if level2_pointer < JIS0208_LEVEL2_AND_ADDITIONAL_KANJI.len() {\n                        handle.write_upper_bmp(JIS0208_LEVEL2_AND_ADDITIONAL_KANJI[level2_pointer])\n                    } else {\n                        let ibm_pointer = pointer.wrapping_sub(8272);\n                        if ibm_pointer < IBM_KANJI.len() {\n                            handle.write_upper_bmp(IBM_KANJI[ibm_pointer])\n                        } else if let Some(bmp) = jis0208_symbol_decode(pointer) {\n                            handle.write_bmp_excl_ascii(bmp)\n                        } else if let Some(bmp) = jis0208_range_decode(pointer) {\n                            handle.write_bmp_excl_ascii(bmp)\n                        } else {\n                            return (\n                                DecoderResult::Malformed(2, 0),\n                                unread_handle_trail.consumed(),\n                                handle.written(),\n                            );\n                        }\n                    }\n                }\n            }\n        },\n        {\n            // If lead is between 0xA1 and 0xFE, inclusive,\n            // subtract 0xA1.\n            let jis0212_lead_minus_offset = lead.wrapping_sub(0xA1);\n            if jis0212_lead_minus_offset > (0xFE - 0xA1) {\n                if lead < 0x80 {\n                    return (\n                        DecoderResult::Malformed(1, 0),\n                        unread_handle_jis0212.unread(),\n                        handle.written(),\n                    );\n                }\n                return (\n                    DecoderResult::Malformed(2, 0),\n                    unread_handle_jis0212.consumed(),\n                    handle.written(),\n                );\n            }\n            jis0212_lead_minus_offset\n        },\n        {\n            // If trail is between 0xA1 and 0xFE, inclusive,\n            // subtract 0xA1.\n            let trail_minus_offset = byte.wrapping_sub(0xA1);\n            if trail_minus_offset > (0xFE - 0xA1) {\n                if byte < 0x80 {\n                    return (\n                        DecoderResult::Malformed(2, 0),\n                        unread_handle_trail.unread(),\n                        handle.written(),\n                    );\n                }\n                return (\n                    DecoderResult::Malformed(3, 0),\n                    unread_handle_trail.consumed(),\n                    handle.written(),\n                );\n            }\n            let pointer = mul_94(jis0212_lead_minus_offset) + usize::from(trail_minus_offset);\n            let pointer_minus_kanji = pointer.wrapping_sub(1410);\n            if pointer_minus_kanji < JIS0212_KANJI.len() {\n                handle.write_upper_bmp(JIS0212_KANJI[pointer_minus_kanji])\n            } else if let Some(bmp) = jis0212_accented_decode(pointer) {\n                handle.write_bmp_excl_ascii(bmp)\n            } else {\n                let pointer_minus_upper_cyrillic = pointer.wrapping_sub(597);\n                if pointer_minus_upper_cyrillic <= (607 - 597) {\n                    handle.write_mid_bmp(0x0402 + pointer_minus_upper_cyrillic as u16)\n                } else {\n                    let pointer_minus_lower_cyrillic = pointer.wrapping_sub(645);\n                    if pointer_minus_lower_cyrillic <= (655 - 645) {\n                        handle.write_mid_bmp(0x0452 + pointer_minus_lower_cyrillic as u16)\n                    } else {\n                        return (\n                            DecoderResult::Malformed(3, 0),\n                            unread_handle_trail.consumed(),\n                            handle.written(),\n                        );\n                    }\n                }\n            }\n        },\n        {\n            // If trail is between 0xA1 and 0xDF, inclusive,\n            // subtract 0xA1 and map to half-width Katakana.\n            let trail_minus_offset = byte.wrapping_sub(0xA1);\n            if trail_minus_offset > (0xDF - 0xA1) {\n                if byte < 0x80 {\n                    return (\n                        DecoderResult::Malformed(1, 0),\n                        unread_handle_trail.unread(),\n                        handle.written(),\n                    );\n                }\n                return (\n                    DecoderResult::Malformed(2, 0),\n                    unread_handle_trail.consumed(),\n                    handle.written(),\n                );\n            }\n            handle.write_upper_bmp(0xFF61 + u16::from(trail_minus_offset))\n        },\n        self,\n        non_ascii,\n        jis0208_lead_minus_offset,\n        byte,\n        unread_handle_trail,\n        jis0212_lead_minus_offset,\n        lead,\n        unread_handle_jis0212,\n        source,\n        handle\n    );\n}"],"euc_jp::EucJpEncoder":["impl EucJpEncoder {\n    pub fn new(encoding: &'static Encoding) -> Encoder {\n        Encoder::new(encoding, VariantEncoder::EucJp(EucJpEncoder))\n    }\n\n    pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        u16_length.checked_mul(2)\n    }\n\n    pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        byte_length.checked_add(1)\n    }\n\n    ascii_compatible_bmp_encoder_functions!(\n        {\n            // Lunde says 60% Hiragana, 30% Kanji, 10% Katakana\n            let bmp_minus_hiragana = bmp.wrapping_sub(0x3041);\n            if bmp_minus_hiragana < 0x53 {\n                handle.write_two(0xA4, 0xA1 + bmp_minus_hiragana as u8)\n            } else if in_inclusive_range16(bmp, 0x4E00, 0x9FA0) {\n                if let Some((lead, trail)) = encode_kanji(bmp) {\n                    handle.write_two(lead, trail)\n                } else {\n                    return (\n                        EncoderResult::unmappable_from_bmp(bmp),\n                        source.consumed(),\n                        handle.written(),\n                    );\n                }\n            } else {\n                let bmp_minus_katakana = bmp.wrapping_sub(0x30A1);\n                if bmp_minus_katakana < 0x56 {\n                    handle.write_two(0xA5, 0xA1 + bmp_minus_katakana as u8)\n                } else {\n                    let bmp_minus_space = bmp.wrapping_sub(0x3000);\n                    if bmp_minus_space < 3 {\n                        // fast-track common punctuation\n                        handle.write_two(0xA1, 0xA1 + bmp_minus_space as u8)\n                    } else if bmp == 0xA5 {\n                        handle.write_one(0x5Cu8)\n                    } else if bmp == 0x203E {\n                        handle.write_one(0x7Eu8)\n                    } else if in_inclusive_range16(bmp, 0xFF61, 0xFF9F) {\n                        handle.write_two(0x8Eu8, (bmp - (0xFF61 - 0xA1)) as u8)\n                    } else if bmp == 0x2212 {\n                        handle.write_two(0xA1u8, 0xDDu8)\n                    } else if let Some(pointer) = jis0208_range_encode(bmp) {\n                        let lead = (pointer / 94) + 0xA1;\n                        let trail = (pointer % 94) + 0xA1;\n                        handle.write_two(lead as u8, trail as u8)\n                    } else if in_inclusive_range16(bmp, 0xFA0E, 0xFA2D)\n                        || bmp == 0xF929\n                        || bmp == 0xF9DC\n                    {\n                        // Guaranteed to be found in IBM_KANJI\n                        let pos = position(&IBM_KANJI[..], bmp).unwrap();\n                        let lead = (pos / 94) + 0xF9;\n                        let trail = (pos % 94) + 0xA1;\n                        handle.write_two(lead as u8, trail as u8)\n                    } else if let Some(pointer) = ibm_symbol_encode(bmp) {\n                        let lead = (pointer / 94) + 0xA1;\n                        let trail = (pointer % 94) + 0xA1;\n                        handle.write_two(lead as u8, trail as u8)\n                    } else if let Some(pointer) = jis0208_symbol_encode(bmp) {\n                        let lead = (pointer / 94) + 0xA1;\n                        let trail = (pointer % 94) + 0xA1;\n                        handle.write_two(lead as u8, trail as u8)\n                    } else {\n                        return (\n                            EncoderResult::unmappable_from_bmp(bmp),\n                            source.consumed(),\n                            handle.written(),\n                        );\n                    }\n                }\n            }\n        },\n        bmp,\n        self,\n        source,\n        handle,\n        copy_ascii_to_check_space_two,\n        check_space_two,\n        false\n    );\n}"],"euc_jp::EucJpPending":["impl EucJpPending {\n    fn is_none(&self) -> bool {\n        match *self {\n            EucJpPending::None => true,\n            _ => false,\n        }\n    }\n\n    fn count(&self) -> usize {\n        match *self {\n            EucJpPending::None => 0,\n            EucJpPending::Jis0208Lead(_)\n            | EucJpPending::Jis0212Shift\n            | EucJpPending::HalfWidthKatakana => 1,\n            EucJpPending::Jis0212Lead(_) => 2,\n        }\n    }\n}"],"euc_kr::EucKrDecoder":["impl EucKrDecoder {\n    pub fn new() -> VariantDecoder {\n        VariantDecoder::EucKr(EucKrDecoder { lead: None })\n    }\n\n    pub fn in_neutral_state(&self) -> bool {\n        self.lead.is_none()\n    }\n\n    fn plus_one_if_lead(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_add(match self.lead {\n            None => 0,\n            Some(_) => 1,\n        })\n    }\n\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        self.plus_one_if_lead(byte_length)\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        // worst case: 2 to 3\n        let len = self.plus_one_if_lead(byte_length);\n        checked_add(2, checked_add_opt(len, checked_div(checked_add(1, len), 2)))\n    }\n\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        checked_mul(3, self.plus_one_if_lead(byte_length))\n    }\n\n    ascii_compatible_two_byte_decoder_functions!(\n        {\n            // If lead is between 0x81 and 0xFE, inclusive,\n            // subtract offset 0x81.\n            let non_ascii_minus_offset =\n                non_ascii.wrapping_sub(0x81);\n            if non_ascii_minus_offset > (0xFE - 0x81) {\n                return (DecoderResult::Malformed(1, 0),\n                        source.consumed(),\n                        handle.written());\n            }\n            non_ascii_minus_offset\n        },\n        {\n            if lead_minus_offset >= 0x20 {\n                // Not the extension range above KS X 1001\n                let trail_minus_offset =\n                    byte.wrapping_sub(0xA1);\n                if trail_minus_offset <= (0xFE - 0xA1) {\n                    // KS X 1001\n                    let ksx_pointer = mul_94(lead_minus_offset - 0x20) + trail_minus_offset as usize;\n                    let hangul_pointer = ksx_pointer.wrapping_sub((0x2F - 0x20) * 94);\n                    if hangul_pointer < KSX1001_HANGUL.len() {\n                        let upper_bmp = KSX1001_HANGUL[hangul_pointer];\n                        handle.write_upper_bmp(upper_bmp)\n                    } else if ksx_pointer < KSX1001_SYMBOLS.len() {\n                        let bmp = KSX1001_SYMBOLS[ksx_pointer];\n                        handle.write_bmp_excl_ascii(bmp)\n                    } else {\n                        let hanja_pointer = ksx_pointer.wrapping_sub((0x49 - 0x20) * 94);\n                        if hanja_pointer < KSX1001_HANJA.len() {\n                            let upper_bmp = KSX1001_HANJA[hanja_pointer];\n                            handle.write_upper_bmp(upper_bmp)\n                        } else if (lead_minus_offset == 0x27) && ((trail_minus_offset as usize) < KSX1001_UPPERCASE.len()) {\n                            let mid_bmp = KSX1001_UPPERCASE[trail_minus_offset as usize];\n                            if mid_bmp == 0 {\n                                return (DecoderResult::Malformed(2, 0),\n                                        unread_handle_trail.consumed(),\n                                        handle.written());\n                            }\n                            handle.write_mid_bmp(mid_bmp)\n                        } else if (lead_minus_offset == 0x28) && ((trail_minus_offset as usize) < KSX1001_LOWERCASE.len()) {\n                            let mid_bmp = KSX1001_LOWERCASE[trail_minus_offset as usize];\n                            handle.write_mid_bmp(mid_bmp)\n                        } else if (lead_minus_offset == 0x25) && ((trail_minus_offset as usize) < KSX1001_BOX.len()) {\n                            let upper_bmp = KSX1001_BOX[trail_minus_offset as usize];\n                            handle.write_upper_bmp(upper_bmp)\n                        } else {\n                            let other_pointer = ksx_pointer.wrapping_sub(2 * 94);\n                            if other_pointer < 0x039F {\n                                let bmp = ksx1001_other_decode(other_pointer as u16);\n                                // ASCII range means unassigned\n                                if bmp < 0x80 {\n                                    return (DecoderResult::Malformed(2, 0),\n                                            unread_handle_trail.consumed(),\n                                            handle.written());\n                                }\n                                handle.write_bmp_excl_ascii(bmp)\n                            } else {\n                                return (DecoderResult::Malformed(2, 0),\n                                        unread_handle_trail.consumed(),\n                                        handle.written());\n                            }\n                        }\n                    }\n                } else {\n                    // Extension range to the left of\n                    // KS X 1001\n                    let left_lead = lead_minus_offset - 0x20;\n                    let left_trail = if byte.wrapping_sub(0x40 + 0x41) < (0x60 - 0x40) {\n                        byte - (12 + 0x41)\n                    } else if byte.wrapping_sub(0x20 + 0x41) < (0x3A - 0x20) {\n                        byte - (6 + 0x41)\n                    } else if byte.wrapping_sub(0x41) < 0x1A {\n                        byte - 0x41\n                    } else {\n                        if byte < 0x80 {\n                            return (DecoderResult::Malformed(1, 0),\n                                    unread_handle_trail.unread(),\n                                    handle.written());\n                        }\n                        return (DecoderResult::Malformed(2, 0),\n                                unread_handle_trail.consumed(),\n                                handle.written());\n                    };\n                    let left_pointer = ((left_lead as usize) * (190 - 94 - 12)) + left_trail as usize;\n                    if left_pointer < (0x45 - 0x20) * (190 - 94 - 12) + 0x12 {\n                        let upper_bmp = cp949_left_hangul_decode(left_pointer as u16);\n                        handle.write_upper_bmp(upper_bmp)\n                    } else {\n                        if byte < 0x80 {\n                            return (DecoderResult::Malformed(1, 0),\n                                    unread_handle_trail.unread(),\n                                    handle.written());\n                        }\n                        return (DecoderResult::Malformed(2, 0),\n                                unread_handle_trail.consumed(),\n                                handle.written());\n                    }\n                }\n            } else {\n                // Extension range above KS X 1001\n                let top_trail = if byte.wrapping_sub(0x40 + 0x41) < (0xBE - 0x40) {\n                    byte - (12 + 0x41)\n                } else if byte.wrapping_sub(0x20 + 0x41) < (0x3A - 0x20) {\n                    byte - (6 + 0x41)\n                } else if byte.wrapping_sub(0x41) < 0x1A {\n                    byte - 0x41\n                } else {\n                    if byte < 0x80 {\n                        return (DecoderResult::Malformed(1, 0),\n                                unread_handle_trail.unread(),\n                                handle.written());\n                    }\n                    return (DecoderResult::Malformed(2, 0),\n                            unread_handle_trail.consumed(),\n                            handle.written());\n                };\n                let top_pointer = ((lead_minus_offset as usize) * (190 - 12)) + top_trail as usize;\n                let upper_bmp = cp949_top_hangul_decode(top_pointer as u16);\n                handle.write_upper_bmp(upper_bmp)\n            }\n        },\n        self,\n        non_ascii,\n        byte,\n        lead_minus_offset,\n        unread_handle_trail,\n        source,\n        handle,\n        'outermost,\n        copy_ascii_from_check_space_bmp,\n        check_space_bmp,\n        true);\n}"],"euc_kr::EucKrEncoder":["impl EucKrEncoder {\n    pub fn new(encoding: &'static Encoding) -> Encoder {\n        Encoder::new(encoding, VariantEncoder::EucKr(EucKrEncoder))\n    }\n\n    pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        u16_length.checked_mul(2)\n    }\n\n    pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        byte_length.checked_add(1)\n    }\n\n    ascii_compatible_bmp_encoder_functions!(\n        {\n            let bmp_minus_hangul_start = bmp.wrapping_sub(0xAC00);\n            let (lead, trail) = if bmp_minus_hangul_start < (0xD7A4 - 0xAC00) {\n                // Hangul\n                ksx1001_encode_hangul(bmp, bmp_minus_hangul_start)\n            } else if in_range16(bmp, 0x33DE, 0xFF01) {\n                // Vast range that includes no other\n                // mappables except Hangul (already\n                // processed) and Hanja.\n                // Narrow the range further to Unified and\n                // Compatibility ranges of Hanja.\n                if in_range16(bmp, 0x4E00, 0x9F9D) || in_range16(bmp, 0xF900, 0xFA0C) {\n                    if let Some((hanja_lead, hanja_trail)) = ksx1001_encode_hanja(bmp) {\n                        (hanja_lead, hanja_trail)\n                    } else {\n                        return (\n                            EncoderResult::unmappable_from_bmp(bmp),\n                            source.consumed(),\n                            handle.written(),\n                        );\n                    }\n                } else {\n                    return (\n                        EncoderResult::unmappable_from_bmp(bmp),\n                        source.consumed(),\n                        handle.written(),\n                    );\n                }\n            } else if let Some((lead, trail)) = ksx1001_encode_misc(bmp) {\n                (lead as u8, trail as u8)\n            } else {\n                return (\n                    EncoderResult::unmappable_from_bmp(bmp),\n                    source.consumed(),\n                    handle.written(),\n                );\n            };\n            handle.write_two(lead, trail)\n        },\n        bmp,\n        self,\n        source,\n        handle,\n        copy_ascii_to_check_space_two,\n        check_space_two,\n        true\n    );\n}"],"gb18030::Gb18030Decoder":["impl Gb18030Decoder {\n    pub fn new() -> VariantDecoder {\n        VariantDecoder::Gb18030(Gb18030Decoder {\n            first: None,\n            second: None,\n            third: None,\n            pending: Gb18030Pending::None,\n            pending_ascii: None,\n        })\n    }\n\n    pub fn in_neutral_state(&self) -> bool {\n        self.first.is_none()\n            && self.second.is_none()\n            && self.third.is_none()\n            && self.pending.is_none()\n            && self.pending_ascii.is_none()\n    }\n\n    fn extra_from_state(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_add(\n            self.pending.count()\n                + match self.first {\n                    None => 0,\n                    Some(_) => 1,\n                }\n                + match self.second {\n                    None => 0,\n                    Some(_) => 1,\n                }\n                + match self.third {\n                    None => 0,\n                    Some(_) => 1,\n                }\n                + match self.pending_ascii {\n                    None => 0,\n                    Some(_) => 1,\n                },\n        )\n    }\n\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        // ASCII: 1 to 1 (worst case)\n        // gbk: 2 to 1\n        // ranges: 4 to 1 or 4 to 2\n        checked_add(1, self.extra_from_state(byte_length))\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        // ASCII: 1 to 1\n        // gbk: 2 to 2 or 2 to 3\n        // ranges: 4 to 2, 4 to 3 or 4 to 4\n        // 0x80: 1 to 3 (worst case)\n        self.max_utf8_buffer_length(byte_length)\n    }\n\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        checked_add(1, checked_mul(3, self.extra_from_state(byte_length)))\n    }\n\n    gb18030_decoder_functions!(\n        {\n            // If first is between 0x81 and 0xFE, inclusive,\n            // subtract offset 0x81.\n            let non_ascii_minus_offset = non_ascii.wrapping_sub(0x81);\n            if non_ascii_minus_offset > (0xFE - 0x81) {\n                if non_ascii == 0x80 {\n                    handle.write_upper_bmp(0x20ACu16);\n                    continue 'outermost;\n                }\n                return (DecoderResult::Malformed(1, 0),\n                        source.consumed(),\n                        handle.written());\n            }\n            non_ascii_minus_offset\n        },\n        {\n            // Two-byte (or error)\n            if first_minus_offset >= 0x20 {\n                // Not the gbk ideograph range above GB2312\n                let trail_minus_offset = second.wrapping_sub(0xA1);\n                if trail_minus_offset <= (0xFE - 0xA1) {\n                    // GB2312\n                    let hanzi_lead = first_minus_offset.wrapping_sub(0x2F);\n                    if hanzi_lead < (0x77 - 0x2F) {\n                        // Level 1 Hanzi, Level 2 Hanzi\n                        // or one of the 5 PUA code\n                        // points in between.\n                        let hanzi_pointer = mul_94(hanzi_lead) + trail_minus_offset as usize;\n                        let upper_bmp = GB2312_HANZI[hanzi_pointer];\n                        handle.write_upper_bmp(upper_bmp)\n                    } else if first_minus_offset == 0x20 {\n                        // Symbols (starting with ideographic space)\n                        let bmp = GB2312_SYMBOLS[trail_minus_offset as usize];\n                        handle.write_bmp_excl_ascii(bmp)\n                    } else if first_minus_offset == 0x25 && ((trail_minus_offset.wrapping_sub(63) as usize) < GB2312_SYMBOLS_AFTER_GREEK.len()) {\n                        handle.write_bmp_excl_ascii(GB2312_SYMBOLS_AFTER_GREEK[trail_minus_offset.wrapping_sub(63) as usize])\n                    } else if first_minus_offset == 0x27 && (trail_minus_offset as usize) < GB2312_PINYIN.len() {\n                        handle.write_bmp_excl_ascii(GB2312_PINYIN[trail_minus_offset as usize])\n                    } else if first_minus_offset > 0x76 {\n                        // Bottom PUA\n                        let pua = (0xE234 + mul_94(first_minus_offset - 0x77) + trail_minus_offset as usize) as u16;\n                        handle.write_upper_bmp(pua)\n                    } else {\n                        let bmp = gb2312_other_decode((mul_94(first_minus_offset - 0x21) + (trail_minus_offset as usize)) as u16);\n                        handle.write_bmp_excl_ascii(bmp)\n                    }\n                } else {\n                    // gbk range on the left\n                    let mut trail_minus_offset = second.wrapping_sub(0x40);\n                    if trail_minus_offset > (0x7E - 0x40) {\n                        let trail_minus_range_start = second.wrapping_sub(0x80);\n                        if trail_minus_range_start > (0xA0 - 0x80) {\n                            if second < 0x80 {\n                                return (DecoderResult::Malformed(1, 0),\n                                        unread_handle_second.unread(),\n                                        handle.written());\n                            }\n                            return (DecoderResult::Malformed(2, 0),\n                                    unread_handle_second.consumed(),\n                                    handle.written());\n                        }\n                        trail_minus_offset = second - 0x41;\n                    }\n                    // Zero-base lead\n                    let left_lead = first_minus_offset - 0x20;\n                    let left_pointer = left_lead as usize * (190 - 94) +\n                                       trail_minus_offset as usize;\n                    let gbk_left_ideograph_pointer = left_pointer.wrapping_sub((0x29 - 0x20) * (190 - 94));\n                    if gbk_left_ideograph_pointer < (((0x7D - 0x29) * (190 - 94)) - 5) {\n                        let upper_bmp = gbk_left_ideograph_decode(gbk_left_ideograph_pointer as u16);\n                        handle.write_upper_bmp(upper_bmp)\n                    } else if left_pointer < ((0x29 - 0x20) * (190 - 94)) {\n                        let bmp = gbk_other_decode(left_pointer as u16);\n                        handle.write_bmp_excl_ascii(bmp)\n                    } else {\n                        let bottom_pointer = left_pointer - (((0x7D - 0x20) * (190 - 94)) - 5);\n                        let upper_bmp = GBK_BOTTOM[bottom_pointer];\n                        handle.write_upper_bmp(upper_bmp)\n                    }\n                }\n            } else {\n                // gbk ideograph range above GB2312\n                let mut trail_minus_offset = second.wrapping_sub(0x40);\n                if trail_minus_offset > (0x7E - 0x40) {\n                    let trail_minus_range_start = second.wrapping_sub(0x80);\n                    if trail_minus_range_start > (0xFE - 0x80) {\n                        if second < 0x80 {\n                            return (DecoderResult::Malformed(1, 0),\n                                    unread_handle_second.unread(),\n                                    handle.written());\n                        }\n                        return (DecoderResult::Malformed(2, 0),\n                                unread_handle_second.consumed(),\n                                handle.written());\n                    }\n                    trail_minus_offset = second - 0x41;\n                }\n                let pointer = first_minus_offset as usize * 190usize +\n                              trail_minus_offset as usize;\n                let upper_bmp = gbk_top_ideograph_decode(pointer as u16);\n                handle.write_upper_bmp(upper_bmp)\n            }\n        },\n        {\n            // If third is between 0x81 and 0xFE, inclusive,\n            // subtract offset 0x81.\n            let third_minus_offset = third.wrapping_sub(0x81);\n            if third_minus_offset > (0xFE - 0x81) {\n                // We have an error. Let's inline what's going\n                // to happen when `second` is\n                // reprocessed. (`third` gets unread.)\n                // `second` is guaranteed ASCII, so let's\n                // put it in `pending_ascii`. Recompute\n                // `second` from `second_minus_offset`.\n                self.pending_ascii = Some(second_minus_offset + 0x30);\n                // Now unread `third` and designate the previous\n                // `first` as being in error.\n                return (DecoderResult::Malformed(1, 1),\n                        unread_handle_third.unread(),\n                        handle.written());\n            }\n            third_minus_offset\n        },\n        {\n            // If fourth is between 0x30 and 0x39, inclusive,\n            // subtract offset 0x30.\n            //\n            // If we have an error, we'll inline what's going\n            // to happen when `second` and `third` are\n            // reprocessed. (`fourth` gets unread.)\n            // `second` is guaranteed ASCII, so let's\n            // put it in `pending_ascii`. Recompute\n            // `second` from `second_minus_offset` to\n            // make this block reusable when `second`\n            // is not in scope.\n            //\n            // `third` is guaranteed to be in the range\n            // that makes it become the new `self.first`.\n            //\n            // `fourth` gets unread and the previous\n            // `first` gets designates as being in error.\n            let fourth_minus_offset = fourth.wrapping_sub(0x30);\n            if fourth_minus_offset > (0x39 - 0x30) {\n                self.pending_ascii = Some(second_minus_offset + 0x30);\n                self.pending = Gb18030Pending::One(third_minus_offset);\n                return (DecoderResult::Malformed(1, 2),\n                        unread_handle_fourth.unread(),\n                        handle.written());\n            }\n            let pointer = (first_minus_offset as usize * (10 * 126 * 10)) +\n                          (second_minus_offset as usize * (10 * 126)) +\n                          (third_minus_offset as usize * 10) +\n                          fourth_minus_offset as usize;\n            if pointer <= 39419 {\n                // BMP\n                if pointer == 7457 {\n                    handle.write_upper_bmp(0xE7C7)\n                } else {\n                    handle.write_bmp_excl_ascii(gb18030_range_decode(pointer as u16))\n                }\n            } else if pointer >= 189_000 && pointer <= 1_237_575 {\n                // Astral\n                handle.write_astral((pointer - (189_000usize - 0x1_0000usize)) as u32)\n            } else {\n                return (DecoderResult::Malformed(4, 0),\n                        unread_handle_fourth.consumed(),\n                        handle.written());\n            }\n        },\n        self,\n        non_ascii,\n        first_minus_offset,\n        second,\n        second_minus_offset,\n        unread_handle_second,\n        third,\n        third_minus_offset,\n        unread_handle_third,\n        fourth,\n        fourth_minus_offset,\n        unread_handle_fourth,\n        source,\n        handle,\n        'outermost);\n}"],"gb18030::Gb18030Encoder":["impl Gb18030Encoder {\n    pub fn new(encoding: &'static Encoding, extended_range: bool) -> Encoder {\n        Encoder::new(\n            encoding,\n            VariantEncoder::Gb18030(Gb18030Encoder {\n                extended: extended_range,\n            }),\n        )\n    }\n\n    pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        if self.extended {\n            u16_length.checked_mul(4)\n        } else {\n            // Need to add, because space check is done with the four-byte\n            // assumption.\n            checked_add(2, u16_length.checked_mul(2))\n        }\n    }\n\n    pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        if self.extended {\n            // 1 to 1\n            // 2 to 2\n            // 3 to 2\n            // 2 to 4 (worst)\n            // 3 to 4\n            // 4 to 4\n            checked_add(2, byte_length.checked_mul(2))\n        } else {\n            // 1 to 1\n            // 2 to 2\n            // 3 to 2\n            // Need to add, because space check is done with the four-byte\n            // assumption.\n            byte_length.checked_add(3)\n        }\n    }\n\n    ascii_compatible_encoder_functions!(\n        {\n            let bmp_minus_unified_start = bmp.wrapping_sub(0x4E00);\n            if bmp_minus_unified_start < (0x9FA6 - 0x4E00) {\n                // CJK Unified Ideographs\n                // Can't fail now, since all are\n                // mapped.\n                let (lead, trail) = encode_hanzi(bmp, bmp_minus_unified_start);\n                handle.write_two(lead, trail)\n            } else if bmp == 0xE5E5 {\n                // It's not optimal to check for the unmappable\n                // and for euro at this stage, but getting\n                // the out of the way makes the rest of the\n                // code less messy.\n                return (\n                    EncoderResult::unmappable_from_bmp(bmp),\n                    source.consumed(),\n                    handle.written(),\n                );\n            } else if bmp == 0x20AC && !self.extended {\n                handle.write_one(0x80u8)\n            } else {\n                match gbk_encode_non_unified(bmp) {\n                    Some((lead, trail)) => handle.write_two(lead as u8, trail as u8),\n                    None => {\n                        if !self.extended {\n                            return (\n                                EncoderResult::unmappable_from_bmp(bmp),\n                                source.consumed(),\n                                handle.written(),\n                            );\n                        }\n                        let range_pointer = gb18030_range_encode(bmp);\n                        let first = range_pointer / (10 * 126 * 10);\n                        let rem_first = range_pointer % (10 * 126 * 10);\n                        let second = rem_first / (10 * 126);\n                        let rem_second = rem_first % (10 * 126);\n                        let third = rem_second / 10;\n                        let fourth = rem_second % 10;\n                        handle.write_four(\n                            (first + 0x81) as u8,\n                            (second + 0x30) as u8,\n                            (third + 0x81) as u8,\n                            (fourth + 0x30) as u8,\n                        )\n                    }\n                }\n            }\n        },\n        {\n            if !self.extended {\n                return (\n                    EncoderResult::Unmappable(astral),\n                    source.consumed(),\n                    handle.written(),\n                );\n            }\n            let range_pointer = astral as usize + (189_000usize - 0x1_0000usize);\n            let first = range_pointer / (10 * 126 * 10);\n            let rem_first = range_pointer % (10 * 126 * 10);\n            let second = rem_first / (10 * 126);\n            let rem_second = rem_first % (10 * 126);\n            let third = rem_second / 10;\n            let fourth = rem_second % 10;\n            handle.write_four(\n                (first + 0x81) as u8,\n                (second + 0x30) as u8,\n                (third + 0x81) as u8,\n                (fourth + 0x30) as u8,\n            )\n        },\n        bmp,\n        astral,\n        self,\n        source,\n        handle,\n        copy_ascii_to_check_space_four,\n        check_space_four,\n        false\n    );\n}"],"gb18030::Gb18030Pending":["impl Gb18030Pending {\n    fn is_none(&self) -> bool {\n        match *self {\n            Gb18030Pending::None => true,\n            _ => false,\n        }\n    }\n\n    fn count(&self) -> usize {\n        match *self {\n            Gb18030Pending::None => 0,\n            Gb18030Pending::One(_) => 1,\n            Gb18030Pending::Two(_, _) => 2,\n            Gb18030Pending::Three(_, _, _) => 3,\n        }\n    }\n}"],"handles::BigEndian":["impl Endian for BigEndian {\n    #[cfg(target_endian = \"little\")]\n    const OPPOSITE_ENDIAN: bool = true;\n\n    #[cfg(target_endian = \"big\")]\n    const OPPOSITE_ENDIAN: bool = false;\n}"],"handles::ByteDestination":["impl<'a> ByteDestination<'a> {\n    #[inline(always)]\n    pub fn new(dst: &mut [u8]) -> ByteDestination {\n        ByteDestination { slice: dst, pos: 0 }\n    }\n    #[inline(always)]\n    pub fn check_space_one<'b>(&'b mut self) -> Space<ByteOneHandle<'b, 'a>> {\n        if self.pos < self.slice.len() {\n            Space::Available(ByteOneHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }\n    #[inline(always)]\n    pub fn check_space_two<'b>(&'b mut self) -> Space<ByteTwoHandle<'b, 'a>> {\n        if self.pos + 1 < self.slice.len() {\n            Space::Available(ByteTwoHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }\n    #[inline(always)]\n    pub fn check_space_three<'b>(&'b mut self) -> Space<ByteThreeHandle<'b, 'a>> {\n        if self.pos + 2 < self.slice.len() {\n            Space::Available(ByteThreeHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }\n    #[inline(always)]\n    pub fn check_space_four<'b>(&'b mut self) -> Space<ByteFourHandle<'b, 'a>> {\n        if self.pos + 3 < self.slice.len() {\n            Space::Available(ByteFourHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }\n    #[inline(always)]\n    pub fn written(&self) -> usize {\n        self.pos\n    }\n    #[inline(always)]\n    fn write_one(&mut self, first: u8) {\n        self.slice[self.pos] = first;\n        self.pos += 1;\n    }\n    #[inline(always)]\n    fn write_two(&mut self, first: u8, second: u8) {\n        self.slice[self.pos] = first;\n        self.slice[self.pos + 1] = second;\n        self.pos += 2;\n    }\n    #[inline(always)]\n    fn write_three(&mut self, first: u8, second: u8, third: u8) {\n        self.slice[self.pos] = first;\n        self.slice[self.pos + 1] = second;\n        self.slice[self.pos + 2] = third;\n        self.pos += 3;\n    }\n    #[inline(always)]\n    fn write_four(&mut self, first: u8, second: u8, third: u8, fourth: u8) {\n        self.slice[self.pos] = first;\n        self.slice[self.pos + 1] = second;\n        self.slice[self.pos + 2] = third;\n        self.slice[self.pos + 3] = fourth;\n        self.pos += 4;\n    }\n}"],"handles::ByteFourHandle":["impl<'a, 'b> ByteFourHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(dst: &'a mut ByteDestination<'b>) -> ByteFourHandle<'a, 'b> {\n        ByteFourHandle { dest: dst }\n    }\n    #[inline(always)]\n    pub fn written(&self) -> usize {\n        self.dest.written()\n    }\n    #[inline(always)]\n    pub fn write_one(self, first: u8) -> &'a mut ByteDestination<'b> {\n        self.dest.write_one(first);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_two(self, first: u8, second: u8) -> &'a mut ByteDestination<'b> {\n        self.dest.write_two(first, second);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_four(\n        self,\n        first: u8,\n        second: u8,\n        third: u8,\n        fourth: u8,\n    ) -> &'a mut ByteDestination<'b> {\n        self.dest.write_four(first, second, third, fourth);\n        self.dest\n    }\n}"],"handles::ByteOneHandle":["impl<'a, 'b> ByteOneHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(dst: &'a mut ByteDestination<'b>) -> ByteOneHandle<'a, 'b> {\n        ByteOneHandle { dest: dst }\n    }\n    #[inline(always)]\n    pub fn written(&self) -> usize {\n        self.dest.written()\n    }\n    #[inline(always)]\n    pub fn write_one(self, first: u8) -> &'a mut ByteDestination<'b> {\n        self.dest.write_one(first);\n        self.dest\n    }\n}"],"handles::ByteReadHandle":["impl<'a, 'b> ByteReadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(src: &'a mut ByteSource<'b>) -> ByteReadHandle<'a, 'b> {\n        ByteReadHandle { source: src }\n    }\n    #[inline(always)]\n    pub fn read(self) -> (u8, ByteUnreadHandle<'a, 'b>) {\n        let byte = self.source.read();\n        let handle = ByteUnreadHandle::new(self.source);\n        (byte, handle)\n    }\n    #[inline(always)]\n    pub fn consumed(&self) -> usize {\n        self.source.consumed()\n    }\n}"],"handles::ByteSource":["impl<'a> ByteSource<'a> {\n    #[inline(always)]\n    pub fn new(src: &[u8]) -> ByteSource {\n        ByteSource { slice: src, pos: 0 }\n    }\n    #[inline(always)]\n    pub fn check_available<'b>(&'b mut self) -> Space<ByteReadHandle<'b, 'a>> {\n        if self.pos < self.slice.len() {\n            Space::Available(ByteReadHandle::new(self))\n        } else {\n            Space::Full(self.consumed())\n        }\n    }\n    #[inline(always)]\n    fn read(&mut self) -> u8 {\n        let ret = self.slice[self.pos];\n        self.pos += 1;\n        ret\n    }\n    #[inline(always)]\n    fn unread(&mut self) -> usize {\n        self.pos -= 1;\n        self.pos\n    }\n    #[inline(always)]\n    pub fn consumed(&self) -> usize {\n        self.pos\n    }\n}"],"handles::ByteThreeHandle":["impl<'a, 'b> ByteThreeHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(dst: &'a mut ByteDestination<'b>) -> ByteThreeHandle<'a, 'b> {\n        ByteThreeHandle { dest: dst }\n    }\n    #[inline(always)]\n    pub fn written(&self) -> usize {\n        self.dest.written()\n    }\n    #[inline(always)]\n    pub fn write_one(self, first: u8) -> &'a mut ByteDestination<'b> {\n        self.dest.write_one(first);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_two(self, first: u8, second: u8) -> &'a mut ByteDestination<'b> {\n        self.dest.write_two(first, second);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_three(self, first: u8, second: u8, third: u8) -> &'a mut ByteDestination<'b> {\n        self.dest.write_three(first, second, third);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_three_return_written(self, first: u8, second: u8, third: u8) -> usize {\n        self.dest.write_three(first, second, third);\n        self.dest.written()\n    }\n}"],"handles::ByteTwoHandle":["impl<'a, 'b> ByteTwoHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(dst: &'a mut ByteDestination<'b>) -> ByteTwoHandle<'a, 'b> {\n        ByteTwoHandle { dest: dst }\n    }\n    #[inline(always)]\n    pub fn written(&self) -> usize {\n        self.dest.written()\n    }\n    #[inline(always)]\n    pub fn write_one(self, first: u8) -> &'a mut ByteDestination<'b> {\n        self.dest.write_one(first);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_two(self, first: u8, second: u8) -> &'a mut ByteDestination<'b> {\n        self.dest.write_two(first, second);\n        self.dest\n    }\n}"],"handles::ByteUnreadHandle":["impl<'a, 'b> ByteUnreadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(src: &'a mut ByteSource<'b>) -> ByteUnreadHandle<'a, 'b> {\n        ByteUnreadHandle { source: src }\n    }\n    #[inline(always)]\n    pub fn unread(self) -> usize {\n        self.source.unread()\n    }\n    #[inline(always)]\n    pub fn consumed(&self) -> usize {\n        self.source.consumed()\n    }\n    #[inline(always)]\n    pub fn commit(self) -> &'a mut ByteSource<'b> {\n        self.source\n    }\n}"],"handles::LittleEndian":["impl Endian for LittleEndian {\n    #[cfg(target_endian = \"little\")]\n    const OPPOSITE_ENDIAN: bool = false;\n\n    #[cfg(target_endian = \"big\")]\n    const OPPOSITE_ENDIAN: bool = true;\n}"],"handles::UnalignedU16Slice":["Clone","Copy","Debug","impl UnalignedU16Slice {\n    #[inline(always)]\n    pub unsafe fn new(ptr: *const u8, len: usize) -> UnalignedU16Slice {\n        UnalignedU16Slice { ptr, len }\n    }\n\n    #[inline(always)]\n    pub fn trim_last(&mut self) {\n        assert!(self.len > 0);\n        self.len -= 1;\n    }\n\n    #[inline(always)]\n    pub fn at(&self, i: usize) -> u16 {\n        assert!(i < self.len);\n        unsafe {\n            let mut u: u16 = ::std::mem::uninitialized();\n            ::std::ptr::copy_nonoverlapping(self.ptr.add(i * 2), &mut u as *mut u16 as *mut u8, 2);\n            u\n        }\n    }\n\n    #[cfg(feature = \"simd-accel\")]\n    #[inline(always)]\n    pub fn simd_at(&self, i: usize) -> u16x8 {\n        assert!(i + SIMD_STRIDE_SIZE / 2 <= self.len);\n        let byte_index = i * 2;\n        unsafe { to_u16_lanes(load16_unaligned(self.ptr.add(byte_index))) }\n    }\n\n    #[inline(always)]\n    pub fn len(&self) -> usize {\n        self.len\n    }\n\n    #[inline(always)]\n    pub fn tail(&self, from: usize) -> UnalignedU16Slice {\n        // XXX the return value should be restricted not to\n        // outlive self.\n        assert!(from <= self.len);\n        unsafe { UnalignedU16Slice::new(self.ptr.add(from * 2), self.len - from) }\n    }\n\n    #[cfg(feature = \"simd-accel\")]\n    #[inline(always)]\n    pub fn copy_bmp_to<E: Endian>(&self, other: &mut [u16]) -> Option<(u16, usize)> {\n        assert!(self.len <= other.len());\n        let mut offset = 0;\n        if SIMD_STRIDE_SIZE / 2 <= self.len {\n            let len_minus_stride = self.len - SIMD_STRIDE_SIZE / 2;\n            loop {\n                let mut simd = self.simd_at(offset);\n                if E::OPPOSITE_ENDIAN {\n                    simd = simd_byte_swap(simd);\n                }\n                unsafe {\n                    store8_unaligned(other.as_mut_ptr().add(offset), simd);\n                }\n                if contains_surrogates(simd) {\n                    break;\n                }\n                offset += SIMD_STRIDE_SIZE / 2;\n                if offset > len_minus_stride {\n                    break;\n                }\n            }\n        }\n        while offset < self.len {\n            let unit = swap_if_opposite_endian::<E>(self.at(offset));\n            other[offset] = unit;\n            if super::in_range16(unit, 0xD800, 0xE000) {\n                return Some((unit, offset));\n            }\n            offset += 1;\n        }\n        None\n    }\n\n    #[cfg(not(feature = \"simd-accel\"))]\n    #[inline(always)]\n    fn copy_bmp_to<E: Endian>(&self, other: &mut [u16]) -> Option<(u16, usize)> {\n        assert!(self.len <= other.len());\n        for (i, target) in other.iter_mut().enumerate().take(self.len) {\n            let unit = swap_if_opposite_endian::<E>(self.at(i));\n            *target = unit;\n            if super::in_range16(unit, 0xD800, 0xE000) {\n                return Some((unit, i));\n            }\n        }\n        None\n    }\n}"],"handles::Utf16AstralHandle":["impl<'a, 'b> Utf16AstralHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(dst: &'a mut Utf16Destination<'b>) -> Utf16AstralHandle<'a, 'b> {\n        Utf16AstralHandle { dest: dst }\n    }\n    #[inline(always)]\n    pub fn written(&self) -> usize {\n        self.dest.written()\n    }\n    #[inline(always)]\n    pub fn write_ascii(self, ascii: u8) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_ascii(ascii);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_bmp(self, bmp: u16) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_bmp(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_bmp_excl_ascii(self, bmp: u16) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_bmp_excl_ascii(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_upper_bmp(self, bmp: u16) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_upper_bmp(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_astral(self, astral: u32) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_astral(astral);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_surrogate_pair(self, high: u16, low: u16) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_surrogate_pair(high, low);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_big5_combination(\n        self,\n        combined: u16,\n        combining: u16,\n    ) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_big5_combination(combined, combining);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn commit(self) -> &'a mut Utf16Destination<'b> {\n        self.dest\n    }\n}"],"handles::Utf16BmpHandle":["impl<'a, 'b> Utf16BmpHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(dst: &'a mut Utf16Destination<'b>) -> Utf16BmpHandle<'a, 'b> {\n        Utf16BmpHandle { dest: dst }\n    }\n    #[inline(always)]\n    pub fn written(&self) -> usize {\n        self.dest.written()\n    }\n    #[inline(always)]\n    pub fn write_ascii(self, ascii: u8) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_ascii(ascii);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_bmp(self, bmp: u16) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_bmp(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_bmp_excl_ascii(self, bmp: u16) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_bmp_excl_ascii(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_mid_bmp(self, bmp: u16) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_mid_bmp(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_upper_bmp(self, bmp: u16) -> &'a mut Utf16Destination<'b> {\n        self.dest.write_upper_bmp(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn commit(self) -> &'a mut Utf16Destination<'b> {\n        self.dest\n    }\n}"],"handles::Utf16Destination":["impl<'a> Utf16Destination<'a> {\n    #[inline(always)]\n    pub fn new(dst: &mut [u16]) -> Utf16Destination {\n        Utf16Destination { slice: dst, pos: 0 }\n    }\n    #[inline(always)]\n    pub fn check_space_bmp<'b>(&'b mut self) -> Space<Utf16BmpHandle<'b, 'a>> {\n        if self.pos < self.slice.len() {\n            Space::Available(Utf16BmpHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }\n    #[inline(always)]\n    pub fn check_space_astral<'b>(&'b mut self) -> Space<Utf16AstralHandle<'b, 'a>> {\n        if self.pos + 1 < self.slice.len() {\n            Space::Available(Utf16AstralHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }\n    #[inline(always)]\n    pub fn written(&self) -> usize {\n        self.pos\n    }\n    #[inline(always)]\n    fn write_code_unit(&mut self, u: u16) {\n        unsafe {\n            // OK, because we checked before handing out a handle.\n            *(self.slice.get_unchecked_mut(self.pos)) = u;\n        }\n        self.pos += 1;\n    }\n    #[inline(always)]\n    fn write_ascii(&mut self, ascii: u8) {\n        debug_assert!(ascii < 0x80);\n        self.write_code_unit(u16::from(ascii));\n    }\n    #[inline(always)]\n    fn write_bmp(&mut self, bmp: u16) {\n        self.write_code_unit(bmp);\n    }\n    #[inline(always)]\n    fn write_bmp_excl_ascii(&mut self, bmp: u16) {\n        debug_assert!(bmp >= 0x80);\n        self.write_code_unit(bmp);\n    }\n    #[inline(always)]\n    fn write_mid_bmp(&mut self, bmp: u16) {\n        debug_assert!(bmp >= 0x80); // XXX\n        self.write_code_unit(bmp);\n    }\n    #[inline(always)]\n    fn write_upper_bmp(&mut self, bmp: u16) {\n        debug_assert!(bmp >= 0x80);\n        self.write_code_unit(bmp);\n    }\n    #[inline(always)]\n    fn write_astral(&mut self, astral: u32) {\n        debug_assert!(astral > 0xFFFF);\n        debug_assert!(astral <= 0x10_FFFF);\n        self.write_code_unit((0xD7C0 + (astral >> 10)) as u16);\n        self.write_code_unit((0xDC00 + (astral & 0x3FF)) as u16);\n    }\n    #[inline(always)]\n    pub fn write_surrogate_pair(&mut self, high: u16, low: u16) {\n        self.write_code_unit(high);\n        self.write_code_unit(low);\n    }\n    #[inline(always)]\n    fn write_big5_combination(&mut self, combined: u16, combining: u16) {\n        self.write_bmp_excl_ascii(combined);\n        self.write_bmp_excl_ascii(combining);\n    }\n    #[inline(always)]\n    pub fn copy_ascii_from_check_space_bmp<'b>(\n        &'b mut self,\n        source: &mut ByteSource,\n    ) -> CopyAsciiResult<(DecoderResult, usize, usize), (u8, Utf16BmpHandle<'b, 'a>)> {\n        let non_ascii_ret = {\n            let src_remaining = &source.slice[source.pos..];\n            let dst_remaining = &mut self.slice[self.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (DecoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (DecoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_basic_latin(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    source.pos += length;\n                    self.pos += length;\n                    return CopyAsciiResult::Stop((pending, source.pos, self.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    source.pos += consumed;\n                    self.pos += consumed;\n                    source.pos += 1; // +1 for non_ascii\n                    non_ascii\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, Utf16BmpHandle::new(self)))\n    }\n    #[inline(always)]\n    pub fn copy_ascii_from_check_space_astral<'b>(\n        &'b mut self,\n        source: &mut ByteSource,\n    ) -> CopyAsciiResult<(DecoderResult, usize, usize), (u8, Utf16AstralHandle<'b, 'a>)> {\n        let non_ascii_ret = {\n            let dst_len = self.slice.len();\n            let src_remaining = &source.slice[source.pos..];\n            let dst_remaining = &mut self.slice[self.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (DecoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (DecoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_basic_latin(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    source.pos += length;\n                    self.pos += length;\n                    return CopyAsciiResult::Stop((pending, source.pos, self.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    source.pos += consumed;\n                    self.pos += consumed;\n                    if self.pos + 1 < dst_len {\n                        source.pos += 1; // +1 for non_ascii\n                        non_ascii\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            DecoderResult::OutputFull,\n                            source.pos,\n                            self.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, Utf16AstralHandle::new(self)))\n    }\n    #[inline(always)]\n    pub fn copy_utf8_up_to_invalid_from(&mut self, source: &mut ByteSource) {\n        let src_remaining = &source.slice[source.pos..];\n        let dst_remaining = &mut self.slice[self.pos..];\n        let (read, written) = convert_utf8_to_utf16_up_to_invalid(src_remaining, dst_remaining);\n        source.pos += read;\n        self.pos += written;\n    }\n    #[inline(always)]\n    pub fn copy_utf16_from<E: Endian>(\n        &mut self,\n        source: &mut ByteSource,\n    ) -> Option<(usize, usize)> {\n        let src_remaining = &source.slice[source.pos..];\n        let dst_remaining = &mut self.slice[self.pos..];\n\n        let mut src_unaligned = unsafe {\n            UnalignedU16Slice::new(\n                src_remaining.as_ptr(),\n                ::std::cmp::min(src_remaining.len() / 2, dst_remaining.len()),\n            )\n        };\n        if src_unaligned.len() == 0 {\n            return None;\n        }\n        let last_unit = swap_if_opposite_endian::<E>(src_unaligned.at(src_unaligned.len() - 1));\n        if super::in_range16(last_unit, 0xD800, 0xDC00) {\n            // Last code unit is a high surrogate. It might\n            // legitimately form a pair later, so let's not\n            // include it.\n            src_unaligned.trim_last();\n        }\n        let mut offset = 0usize;\n        loop {\n            if let Some((surrogate, bmp_len)) = {\n                let src_left = src_unaligned.tail(offset);\n                let dst_left = &mut dst_remaining[offset..src_unaligned.len()];\n                src_left.copy_bmp_to::<E>(dst_left)\n            } {\n                offset += bmp_len; // surrogate has not been consumed yet\n                let second_pos = offset + 1;\n                if surrogate > 0xDBFF || second_pos == src_unaligned.len() {\n                    // Unpaired surrogate\n                    source.pos += second_pos * 2;\n                    self.pos += offset;\n                    return Some((source.pos, self.pos));\n                }\n                let second = swap_if_opposite_endian::<E>(src_unaligned.at(second_pos));\n                if !super::in_range16(second, 0xDC00, 0xE000) {\n                    // Unpaired surrogate\n                    source.pos += second_pos * 2;\n                    self.pos += offset;\n                    return Some((source.pos, self.pos));\n                }\n                // `surrogate` was already speculatively written\n                dst_remaining[second_pos] = second;\n                offset += 2;\n                continue;\n            } else {\n                source.pos += src_unaligned.len() * 2;\n                self.pos += src_unaligned.len();\n                return None;\n            }\n        }\n    }\n}"],"handles::Utf16ReadHandle":["impl<'a, 'b> Utf16ReadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(src: &'a mut Utf16Source<'b>) -> Utf16ReadHandle<'a, 'b> {\n        Utf16ReadHandle { source: src }\n    }\n    #[inline(always)]\n    pub fn read(self) -> (char, Utf16UnreadHandle<'a, 'b>) {\n        let character = self.source.read();\n        let handle = Utf16UnreadHandle::new(self.source);\n        (character, handle)\n    }\n    #[inline(always)]\n    pub fn read_enum(self) -> (Unicode, Utf16UnreadHandle<'a, 'b>) {\n        let character = self.source.read_enum();\n        let handle = Utf16UnreadHandle::new(self.source);\n        (character, handle)\n    }\n    #[inline(always)]\n    pub fn consumed(&self) -> usize {\n        self.source.consumed()\n    }\n}"],"handles::Utf16Source":["impl<'a> Utf16Source<'a> {\n    #[inline(always)]\n    pub fn new(src: &[u16]) -> Utf16Source {\n        Utf16Source {\n            slice: src,\n            pos: 0,\n            old_pos: 0,\n        }\n    }\n    #[inline(always)]\n    pub fn check_available<'b>(&'b mut self) -> Space<Utf16ReadHandle<'b, 'a>> {\n        if self.pos < self.slice.len() {\n            Space::Available(Utf16ReadHandle::new(self))\n        } else {\n            Space::Full(self.consumed())\n        }\n    }\n    #[cfg_attr(feature = \"cargo-clippy\", allow(collapsible_if))]\n    #[inline(always)]\n    fn read(&mut self) -> char {\n        self.old_pos = self.pos;\n        let unit = self.slice[self.pos];\n        self.pos += 1;\n        let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);\n        if unit_minus_surrogate_start > (0xDFFF - 0xD800) {\n            return unsafe { ::std::char::from_u32_unchecked(u32::from(unit)) };\n        }\n        if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {\n            // high surrogate\n            if self.pos < self.slice.len() {\n                let second = self.slice[self.pos];\n                let second_minus_low_surrogate_start = second.wrapping_sub(0xDC00);\n                if second_minus_low_surrogate_start <= (0xDFFF - 0xDC00) {\n                    // The next code unit is a low surrogate. Advance position.\n                    self.pos += 1;\n                    return unsafe {\n                        ::std::char::from_u32_unchecked(\n                            (u32::from(unit) << 10) + u32::from(second)\n                                - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),\n                        )\n                    };\n                }\n                // The next code unit is not a low surrogate. Don't advance\n                // position and treat the high surrogate as unpaired.\n                // fall through\n            }\n            // Unpaired surrogate at the end of buffer, fall through\n        }\n        // Unpaired low surrogate\n        '\\u{FFFD}'\n    }\n    #[cfg_attr(feature = \"cargo-clippy\", allow(collapsible_if))]\n    #[inline(always)]\n    fn read_enum(&mut self) -> Unicode {\n        self.old_pos = self.pos;\n        let unit = self.slice[self.pos];\n        self.pos += 1;\n        if unit < 0x80 {\n            return Unicode::Ascii(unit as u8);\n        }\n        let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);\n        if unit_minus_surrogate_start > (0xDFFF - 0xD800) {\n            return Unicode::NonAscii(NonAscii::BmpExclAscii(unit));\n        }\n        if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {\n            // high surrogate\n            if self.pos < self.slice.len() {\n                let second = self.slice[self.pos];\n                let second_minus_low_surrogate_start = second.wrapping_sub(0xDC00);\n                if second_minus_low_surrogate_start <= (0xDFFF - 0xDC00) {\n                    // The next code unit is a low surrogate. Advance position.\n                    self.pos += 1;\n                    return Unicode::NonAscii(NonAscii::Astral(unsafe {\n                        ::std::char::from_u32_unchecked(\n                            (u32::from(unit) << 10) + u32::from(second)\n                                - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),\n                        )\n                    }));\n                }\n                // The next code unit is not a low surrogate. Don't advance\n                // position and treat the high surrogate as unpaired.\n                // fall through\n            }\n            // Unpaired surrogate at the end of buffer, fall through\n        }\n        // Unpaired low surrogate\n        Unicode::NonAscii(NonAscii::BmpExclAscii(0xFFFDu16))\n    }\n    #[inline(always)]\n    fn unread(&mut self) -> usize {\n        self.pos = self.old_pos;\n        self.pos\n    }\n    #[inline(always)]\n    pub fn consumed(&self) -> usize {\n        self.pos\n    }\n    #[inline(always)]\n    pub fn copy_ascii_to_check_space_two<'b>(\n        &mut self,\n        dest: &'b mut ByteDestination<'a>,\n    ) -> CopyAsciiResult<(EncoderResult, usize, usize), (NonAscii, ByteTwoHandle<'b, 'a>)> {\n        let non_ascii_ret = {\n            let dst_len = dest.slice.len();\n            let src_remaining = &self.slice[self.pos..];\n            let dst_remaining = &mut dest.slice[dest.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (EncoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (EncoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                basic_latin_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    self.pos += length;\n                    dest.pos += length;\n                    return CopyAsciiResult::Stop((pending, self.pos, dest.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    self.pos += consumed;\n                    dest.pos += consumed;\n                    if dest.pos + 1 < dst_len {\n                        self.pos += 1; // commit to reading `non_ascii`\n                        let unit = non_ascii;\n                        let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);\n                        if unit_minus_surrogate_start > (0xDFFF - 0xD800) {\n                            NonAscii::BmpExclAscii(unit)\n                        } else if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {\n                            // high surrogate\n                            if self.pos < self.slice.len() {\n                                let second = self.slice[self.pos];\n                                let second_minus_low_surrogate_start = second.wrapping_sub(0xDC00);\n                                if second_minus_low_surrogate_start <= (0xDFFF - 0xDC00) {\n                                    // The next code unit is a low surrogate. Advance position.\n                                    self.pos += 1;\n                                    NonAscii::Astral(unsafe {\n                                        ::std::char::from_u32_unchecked(\n                                            (u32::from(unit) << 10) + u32::from(second)\n                                                - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),\n                                        )\n                                    })\n                                } else {\n                                    // The next code unit is not a low surrogate. Don't advance\n                                    // position and treat the high surrogate as unpaired.\n                                    NonAscii::BmpExclAscii(0xFFFDu16)\n                                }\n                            } else {\n                                // Unpaired surrogate at the end of the buffer.\n                                NonAscii::BmpExclAscii(0xFFFDu16)\n                            }\n                        } else {\n                            // Unpaired low surrogate\n                            NonAscii::BmpExclAscii(0xFFFDu16)\n                        }\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            EncoderResult::OutputFull,\n                            self.pos,\n                            dest.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, ByteTwoHandle::new(dest)))\n    }\n    #[inline(always)]\n    pub fn copy_ascii_to_check_space_four<'b>(\n        &mut self,\n        dest: &'b mut ByteDestination<'a>,\n    ) -> CopyAsciiResult<(EncoderResult, usize, usize), (NonAscii, ByteFourHandle<'b, 'a>)> {\n        let non_ascii_ret = {\n            let dst_len = dest.slice.len();\n            let src_remaining = &self.slice[self.pos..];\n            let dst_remaining = &mut dest.slice[dest.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (EncoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (EncoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                basic_latin_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    self.pos += length;\n                    dest.pos += length;\n                    return CopyAsciiResult::Stop((pending, self.pos, dest.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    self.pos += consumed;\n                    dest.pos += consumed;\n                    if dest.pos + 3 < dst_len {\n                        self.pos += 1; // commit to reading `non_ascii`\n                        let unit = non_ascii;\n                        let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);\n                        if unit_minus_surrogate_start > (0xDFFF - 0xD800) {\n                            NonAscii::BmpExclAscii(unit)\n                        } else if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {\n                            // high surrogate\n                            if self.pos == self.slice.len() {\n                                // Unpaired surrogate at the end of the buffer.\n                                NonAscii::BmpExclAscii(0xFFFDu16)\n                            } else {\n                                let second = self.slice[self.pos];\n                                let second_minus_low_surrogate_start = second.wrapping_sub(0xDC00);\n                                if second_minus_low_surrogate_start <= (0xDFFF - 0xDC00) {\n                                    // The next code unit is a low surrogate. Advance position.\n                                    self.pos += 1;\n                                    NonAscii::Astral(unsafe {\n                                        ::std::char::from_u32_unchecked(\n                                            (u32::from(unit) << 10) + u32::from(second)\n                                                - (((0xD800u32 << 10) - 0x1_0000u32) + 0xDC00u32),\n                                        )\n                                    })\n                                } else {\n                                    // The next code unit is not a low surrogate. Don't advance\n                                    // position and treat the high surrogate as unpaired.\n                                    NonAscii::BmpExclAscii(0xFFFDu16)\n                                }\n                            }\n                        } else {\n                            // Unpaired low surrogate\n                            NonAscii::BmpExclAscii(0xFFFDu16)\n                        }\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            EncoderResult::OutputFull,\n                            self.pos,\n                            dest.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, ByteFourHandle::new(dest)))\n    }\n}"],"handles::Utf16UnreadHandle":["impl<'a, 'b> Utf16UnreadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(src: &'a mut Utf16Source<'b>) -> Utf16UnreadHandle<'a, 'b> {\n        Utf16UnreadHandle { source: src }\n    }\n    #[inline(always)]\n    pub fn unread(self) -> usize {\n        self.source.unread()\n    }\n    #[inline(always)]\n    pub fn consumed(&self) -> usize {\n        self.source.consumed()\n    }\n    #[inline(always)]\n    pub fn commit(self) -> &'a mut Utf16Source<'b> {\n        self.source\n    }\n}"],"handles::Utf8AstralHandle":["impl<'a, 'b> Utf8AstralHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(dst: &'a mut Utf8Destination<'b>) -> Utf8AstralHandle<'a, 'b> {\n        Utf8AstralHandle { dest: dst }\n    }\n    #[inline(always)]\n    pub fn written(&self) -> usize {\n        self.dest.written()\n    }\n    #[inline(always)]\n    pub fn write_ascii(self, ascii: u8) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_ascii(ascii);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_bmp(self, bmp: u16) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_bmp(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_bmp_excl_ascii(self, bmp: u16) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_bmp_excl_ascii(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_upper_bmp(self, bmp: u16) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_upper_bmp(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_astral(self, astral: u32) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_astral(astral);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_surrogate_pair(self, high: u16, low: u16) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_surrogate_pair(high, low);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_big5_combination(\n        self,\n        combined: u16,\n        combining: u16,\n    ) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_big5_combination(combined, combining);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn commit(self) -> &'a mut Utf8Destination<'b> {\n        self.dest\n    }\n}"],"handles::Utf8BmpHandle":["impl<'a, 'b> Utf8BmpHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(dst: &'a mut Utf8Destination<'b>) -> Utf8BmpHandle<'a, 'b> {\n        Utf8BmpHandle { dest: dst }\n    }\n    #[inline(always)]\n    pub fn written(&self) -> usize {\n        self.dest.written()\n    }\n    #[inline(always)]\n    pub fn write_ascii(self, ascii: u8) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_ascii(ascii);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_bmp(self, bmp: u16) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_bmp(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_bmp_excl_ascii(self, bmp: u16) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_bmp_excl_ascii(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_mid_bmp(self, bmp: u16) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_mid_bmp(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn write_upper_bmp(self, bmp: u16) -> &'a mut Utf8Destination<'b> {\n        self.dest.write_upper_bmp(bmp);\n        self.dest\n    }\n    #[inline(always)]\n    pub fn commit(self) -> &'a mut Utf8Destination<'b> {\n        self.dest\n    }\n}"],"handles::Utf8Destination":["impl<'a> Utf8Destination<'a> {\n    #[inline(always)]\n    pub fn new(dst: &mut [u8]) -> Utf8Destination {\n        Utf8Destination { slice: dst, pos: 0 }\n    }\n    #[inline(always)]\n    pub fn check_space_bmp<'b>(&'b mut self) -> Space<Utf8BmpHandle<'b, 'a>> {\n        if self.pos + 2 < self.slice.len() {\n            Space::Available(Utf8BmpHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }\n    #[inline(always)]\n    pub fn check_space_astral<'b>(&'b mut self) -> Space<Utf8AstralHandle<'b, 'a>> {\n        if self.pos + 3 < self.slice.len() {\n            Space::Available(Utf8AstralHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }\n    #[inline(always)]\n    pub fn written(&self) -> usize {\n        self.pos\n    }\n    #[inline(always)]\n    fn write_code_unit(&mut self, u: u8) {\n        unsafe {\n            // OK, because we checked before handing out a handle.\n            *(self.slice.get_unchecked_mut(self.pos)) = u;\n        }\n        self.pos += 1;\n    }\n    #[inline(always)]\n    fn write_ascii(&mut self, ascii: u8) {\n        debug_assert!(ascii < 0x80);\n        self.write_code_unit(ascii);\n    }\n    #[inline(always)]\n    fn write_bmp(&mut self, bmp: u16) {\n        if bmp < 0x80u16 {\n            self.write_ascii(bmp as u8);\n        } else if bmp < 0x800u16 {\n            self.write_mid_bmp(bmp);\n        } else {\n            self.write_upper_bmp(bmp);\n        }\n    }\n    #[inline(always)]\n    fn write_mid_bmp(&mut self, mid_bmp: u16) {\n        debug_assert!(mid_bmp >= 0x80);\n        debug_assert!(mid_bmp < 0x800);\n        self.write_code_unit(((mid_bmp >> 6) | 0xC0) as u8);\n        self.write_code_unit(((mid_bmp & 0x3F) | 0x80) as u8);\n    }\n    #[inline(always)]\n    fn write_upper_bmp(&mut self, upper_bmp: u16) {\n        debug_assert!(upper_bmp >= 0x800);\n        self.write_code_unit(((upper_bmp >> 12) | 0xE0) as u8);\n        self.write_code_unit((((upper_bmp & 0xFC0) >> 6) | 0x80) as u8);\n        self.write_code_unit(((upper_bmp & 0x3F) | 0x80) as u8);\n    }\n    #[inline(always)]\n    fn write_bmp_excl_ascii(&mut self, bmp: u16) {\n        if bmp < 0x800u16 {\n            self.write_mid_bmp(bmp);\n        } else {\n            self.write_upper_bmp(bmp);\n        }\n    }\n    #[inline(always)]\n    fn write_astral(&mut self, astral: u32) {\n        debug_assert!(astral > 0xFFFF);\n        debug_assert!(astral <= 0x10_FFFF);\n        self.write_code_unit(((astral >> 18) | 0xF0) as u8);\n        self.write_code_unit((((astral & 0x3F000) >> 12) | 0x80) as u8);\n        self.write_code_unit((((astral & 0xFC0) >> 6) | 0x80) as u8);\n        self.write_code_unit(((astral & 0x3F) | 0x80) as u8);\n    }\n    #[inline(always)]\n    pub fn write_surrogate_pair(&mut self, high: u16, low: u16) {\n        self.write_astral(\n            (u32::from(high) << 10) + u32::from(low)\n                - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),\n        );\n    }\n    #[inline(always)]\n    fn write_big5_combination(&mut self, combined: u16, combining: u16) {\n        self.write_mid_bmp(combined);\n        self.write_mid_bmp(combining);\n    }\n    #[inline(always)]\n    pub fn copy_ascii_from_check_space_bmp<'b>(\n        &'b mut self,\n        source: &mut ByteSource,\n    ) -> CopyAsciiResult<(DecoderResult, usize, usize), (u8, Utf8BmpHandle<'b, 'a>)> {\n        let non_ascii_ret = {\n            let dst_len = self.slice.len();\n            let src_remaining = &source.slice[source.pos..];\n            let dst_remaining = &mut self.slice[self.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (DecoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (DecoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    source.pos += length;\n                    self.pos += length;\n                    return CopyAsciiResult::Stop((pending, source.pos, self.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    source.pos += consumed;\n                    self.pos += consumed;\n                    if self.pos + 2 < dst_len {\n                        source.pos += 1; // +1 for non_ascii\n                        non_ascii\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            DecoderResult::OutputFull,\n                            source.pos,\n                            self.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, Utf8BmpHandle::new(self)))\n    }\n    #[inline(always)]\n    pub fn copy_ascii_from_check_space_astral<'b>(\n        &'b mut self,\n        source: &mut ByteSource,\n    ) -> CopyAsciiResult<(DecoderResult, usize, usize), (u8, Utf8AstralHandle<'b, 'a>)> {\n        let non_ascii_ret = {\n            let dst_len = self.slice.len();\n            let src_remaining = &source.slice[source.pos..];\n            let dst_remaining = &mut self.slice[self.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (DecoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (DecoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    source.pos += length;\n                    self.pos += length;\n                    return CopyAsciiResult::Stop((pending, source.pos, self.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    source.pos += consumed;\n                    self.pos += consumed;\n                    if self.pos + 3 < dst_len {\n                        source.pos += 1; // +1 for non_ascii\n                        non_ascii\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            DecoderResult::OutputFull,\n                            source.pos,\n                            self.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, Utf8AstralHandle::new(self)))\n    }\n    #[inline(always)]\n    pub fn copy_utf8_up_to_invalid_from(&mut self, source: &mut ByteSource) {\n        let src_remaining = &source.slice[source.pos..];\n        let dst_remaining = &mut self.slice[self.pos..];\n        let min_len = ::std::cmp::min(src_remaining.len(), dst_remaining.len());\n        // Validate first, then memcpy to let memcpy do its thing even for\n        // non-ASCII. (And potentially do something better than SSE2 for ASCII.)\n        let valid_len = utf8_valid_up_to(&src_remaining[..min_len]);\n        (&mut dst_remaining[..valid_len]).copy_from_slice(&src_remaining[..valid_len]);\n        source.pos += valid_len;\n        self.pos += valid_len;\n    }\n    #[inline(always)]\n    pub fn copy_utf16_from<E: Endian>(\n        &mut self,\n        source: &mut ByteSource,\n    ) -> Option<(usize, usize)> {\n        let src_remaining = &source.slice[source.pos..];\n        let dst_remaining = &mut self.slice[self.pos..];\n\n        let mut src_unaligned =\n            unsafe { UnalignedU16Slice::new(src_remaining.as_ptr(), src_remaining.len() / 2) };\n        if src_unaligned.len() == 0 {\n            return None;\n        }\n        let mut last_unit = src_unaligned.at(src_unaligned.len() - 1);\n        if E::OPPOSITE_ENDIAN {\n            last_unit = last_unit.swap_bytes();\n        }\n        if super::in_range16(last_unit, 0xD800, 0xDC00) {\n            // Last code unit is a high surrogate. It might\n            // legitimately form a pair later, so let's not\n            // include it.\n            src_unaligned.trim_last();\n        }\n        let (read, written, had_error) =\n            convert_unaligned_utf16_to_utf8::<E>(src_unaligned, dst_remaining);\n        source.pos += read * 2;\n        self.pos += written;\n        if had_error {\n            Some((source.pos, self.pos))\n        } else {\n            None\n        }\n    }\n}"],"handles::Utf8ReadHandle":["impl<'a, 'b> Utf8ReadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(src: &'a mut Utf8Source<'b>) -> Utf8ReadHandle<'a, 'b> {\n        Utf8ReadHandle { source: src }\n    }\n    #[inline(always)]\n    pub fn read(self) -> (char, Utf8UnreadHandle<'a, 'b>) {\n        let character = self.source.read();\n        let handle = Utf8UnreadHandle::new(self.source);\n        (character, handle)\n    }\n    #[inline(always)]\n    pub fn read_enum(self) -> (Unicode, Utf8UnreadHandle<'a, 'b>) {\n        let character = self.source.read_enum();\n        let handle = Utf8UnreadHandle::new(self.source);\n        (character, handle)\n    }\n    #[inline(always)]\n    pub fn consumed(&self) -> usize {\n        self.source.consumed()\n    }\n}"],"handles::Utf8Source":["impl<'a> Utf8Source<'a> {\n    #[inline(always)]\n    pub fn new(src: &str) -> Utf8Source {\n        Utf8Source {\n            slice: src.as_bytes(),\n            pos: 0,\n            old_pos: 0,\n        }\n    }\n    #[inline(always)]\n    pub fn check_available<'b>(&'b mut self) -> Space<Utf8ReadHandle<'b, 'a>> {\n        if self.pos < self.slice.len() {\n            Space::Available(Utf8ReadHandle::new(self))\n        } else {\n            Space::Full(self.consumed())\n        }\n    }\n    #[inline(always)]\n    fn read(&mut self) -> char {\n        self.old_pos = self.pos;\n        let unit = self.slice[self.pos];\n        if unit < 0x80 {\n            self.pos += 1;\n            return char::from(unit);\n        }\n        if unit < 0xE0 {\n            let point =\n                ((u32::from(unit) & 0x1F) << 6) | (u32::from(self.slice[self.pos + 1]) & 0x3F);\n            self.pos += 2;\n            return unsafe { ::std::char::from_u32_unchecked(point) };\n        }\n        if unit < 0xF0 {\n            let point = ((u32::from(unit) & 0xF) << 12)\n                | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 6)\n                | (u32::from(self.slice[self.pos + 2]) & 0x3F);\n            self.pos += 3;\n            return unsafe { ::std::char::from_u32_unchecked(point) };\n        }\n        let point = ((u32::from(unit) & 0x7) << 18)\n            | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)\n            | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)\n            | (u32::from(self.slice[self.pos + 3]) & 0x3F);\n        self.pos += 4;\n        unsafe { ::std::char::from_u32_unchecked(point) }\n    }\n    #[inline(always)]\n    fn read_enum(&mut self) -> Unicode {\n        self.old_pos = self.pos;\n        let unit = self.slice[self.pos];\n        if unit < 0x80 {\n            self.pos += 1;\n            return Unicode::Ascii(unit);\n        }\n        if unit < 0xE0 {\n            let point =\n                ((u16::from(unit) & 0x1F) << 6) | (u16::from(self.slice[self.pos + 1]) & 0x3F);\n            self.pos += 2;\n            return Unicode::NonAscii(NonAscii::BmpExclAscii(point));\n        }\n        if unit < 0xF0 {\n            let point = ((u16::from(unit) & 0xF) << 12)\n                | ((u16::from(self.slice[self.pos + 1]) & 0x3F) << 6)\n                | (u16::from(self.slice[self.pos + 2]) & 0x3F);\n            self.pos += 3;\n            return Unicode::NonAscii(NonAscii::BmpExclAscii(point));\n        }\n        let point = ((u32::from(unit) & 0x7) << 18)\n            | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)\n            | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)\n            | (u32::from(self.slice[self.pos + 3]) & 0x3F);\n        self.pos += 4;\n        Unicode::NonAscii(NonAscii::Astral(unsafe {\n            ::std::char::from_u32_unchecked(point)\n        }))\n    }\n    #[inline(always)]\n    fn unread(&mut self) -> usize {\n        self.pos = self.old_pos;\n        self.pos\n    }\n    #[inline(always)]\n    pub fn consumed(&self) -> usize {\n        self.pos\n    }\n    #[inline(always)]\n    pub fn copy_ascii_to_check_space_one<'b>(\n        &mut self,\n        dest: &'b mut ByteDestination<'a>,\n    ) -> CopyAsciiResult<(EncoderResult, usize, usize), (NonAscii, ByteOneHandle<'b, 'a>)> {\n        let non_ascii_ret = {\n            let src_remaining = &self.slice[self.pos..];\n            let dst_remaining = &mut dest.slice[dest.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (EncoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (EncoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    self.pos += length;\n                    dest.pos += length;\n                    return CopyAsciiResult::Stop((pending, self.pos, dest.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    self.pos += consumed;\n                    dest.pos += consumed;\n                    // We don't need to check space in destination, because\n                    // `ascii_to_ascii()` already did.\n                    if non_ascii < 0xE0 {\n                        let point = ((u16::from(non_ascii) & 0x1F) << 6)\n                            | (u16::from(self.slice[self.pos + 1]) & 0x3F);\n                        self.pos += 2;\n                        NonAscii::BmpExclAscii(point)\n                    } else if non_ascii < 0xF0 {\n                        let point = ((u16::from(non_ascii) & 0xF) << 12)\n                            | ((u16::from(self.slice[self.pos + 1]) & 0x3F) << 6)\n                            | (u16::from(self.slice[self.pos + 2]) & 0x3F);\n                        self.pos += 3;\n                        NonAscii::BmpExclAscii(point)\n                    } else {\n                        let point = ((u32::from(non_ascii) & 0x7) << 18)\n                            | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)\n                            | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)\n                            | (u32::from(self.slice[self.pos + 3]) & 0x3F);\n                        self.pos += 4;\n                        NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, ByteOneHandle::new(dest)))\n    }\n    #[inline(always)]\n    pub fn copy_ascii_to_check_space_two<'b>(\n        &mut self,\n        dest: &'b mut ByteDestination<'a>,\n    ) -> CopyAsciiResult<(EncoderResult, usize, usize), (NonAscii, ByteTwoHandle<'b, 'a>)> {\n        let non_ascii_ret = {\n            let dst_len = dest.slice.len();\n            let src_remaining = &self.slice[self.pos..];\n            let dst_remaining = &mut dest.slice[dest.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (EncoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (EncoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    self.pos += length;\n                    dest.pos += length;\n                    return CopyAsciiResult::Stop((pending, self.pos, dest.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    self.pos += consumed;\n                    dest.pos += consumed;\n                    if dest.pos + 1 < dst_len {\n                        if non_ascii < 0xE0 {\n                            let point = ((u16::from(non_ascii) & 0x1F) << 6)\n                                | (u16::from(self.slice[self.pos + 1]) & 0x3F);\n                            self.pos += 2;\n                            NonAscii::BmpExclAscii(point)\n                        } else if non_ascii < 0xF0 {\n                            let point = ((u16::from(non_ascii) & 0xF) << 12)\n                                | ((u16::from(self.slice[self.pos + 1]) & 0x3F) << 6)\n                                | (u16::from(self.slice[self.pos + 2]) & 0x3F);\n                            self.pos += 3;\n                            NonAscii::BmpExclAscii(point)\n                        } else {\n                            let point = ((u32::from(non_ascii) & 0x7) << 18)\n                                | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)\n                                | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)\n                                | (u32::from(self.slice[self.pos + 3]) & 0x3F);\n                            self.pos += 4;\n                            NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })\n                        }\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            EncoderResult::OutputFull,\n                            self.pos,\n                            dest.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, ByteTwoHandle::new(dest)))\n    }\n    #[inline(always)]\n    pub fn copy_ascii_to_check_space_four<'b>(\n        &mut self,\n        dest: &'b mut ByteDestination<'a>,\n    ) -> CopyAsciiResult<(EncoderResult, usize, usize), (NonAscii, ByteFourHandle<'b, 'a>)> {\n        let non_ascii_ret = {\n            let dst_len = dest.slice.len();\n            let src_remaining = &self.slice[self.pos..];\n            let dst_remaining = &mut dest.slice[dest.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (EncoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (EncoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    self.pos += length;\n                    dest.pos += length;\n                    return CopyAsciiResult::Stop((pending, self.pos, dest.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    self.pos += consumed;\n                    dest.pos += consumed;\n                    if dest.pos + 3 < dst_len {\n                        if non_ascii < 0xE0 {\n                            let point = ((u16::from(non_ascii) & 0x1F) << 6)\n                                | (u16::from(self.slice[self.pos + 1]) & 0x3F);\n                            self.pos += 2;\n                            NonAscii::BmpExclAscii(point)\n                        } else if non_ascii < 0xF0 {\n                            let point = ((u16::from(non_ascii) & 0xF) << 12)\n                                | ((u16::from(self.slice[self.pos + 1]) & 0x3F) << 6)\n                                | (u16::from(self.slice[self.pos + 2]) & 0x3F);\n                            self.pos += 3;\n                            NonAscii::BmpExclAscii(point)\n                        } else {\n                            let point = ((u32::from(non_ascii) & 0x7) << 18)\n                                | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)\n                                | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)\n                                | (u32::from(self.slice[self.pos + 3]) & 0x3F);\n                            self.pos += 4;\n                            NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })\n                        }\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            EncoderResult::OutputFull,\n                            self.pos,\n                            dest.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, ByteFourHandle::new(dest)))\n    }\n}"],"handles::Utf8UnreadHandle":["impl<'a, 'b> Utf8UnreadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    #[inline(always)]\n    fn new(src: &'a mut Utf8Source<'b>) -> Utf8UnreadHandle<'a, 'b> {\n        Utf8UnreadHandle { source: src }\n    }\n    #[inline(always)]\n    pub fn unread(self) -> usize {\n        self.source.unread()\n    }\n    #[inline(always)]\n    pub fn consumed(&self) -> usize {\n        self.source.consumed()\n    }\n    #[inline(always)]\n    pub fn commit(self) -> &'a mut Utf8Source<'b> {\n        self.source\n    }\n}"],"iso_2022_jp::Iso2022JpDecoder":["impl Iso2022JpDecoder {\n    pub fn new() -> VariantDecoder {\n        VariantDecoder::Iso2022Jp(Iso2022JpDecoder {\n            decoder_state: Iso2022JpDecoderState::Ascii,\n            output_state: Iso2022JpDecoderState::Ascii,\n            lead: 0u8,\n            output_flag: false,\n            pending_prepended: false,\n        })\n    }\n\n    pub fn in_neutral_state(&self) -> bool {\n        self.decoder_state == Iso2022JpDecoderState::Ascii\n            && self.output_state == Iso2022JpDecoderState::Ascii\n            && self.lead == 0u8\n            && !self.output_flag\n            && !self.pending_prepended\n    }\n\n    fn extra_to_input_from_state(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_add(\n            if self.lead == 0 || self.pending_prepended {\n                0\n            } else {\n                1\n            } + match self.decoder_state {\n                Iso2022JpDecoderState::Escape | Iso2022JpDecoderState::EscapeStart => 1,\n                _ => 0,\n            },\n        )\n    }\n\n    fn extra_to_output_from_state(&self) -> usize {\n        if self.lead != 0 && self.pending_prepended {\n            1 + self.output_flag as usize\n        } else {\n            self.output_flag as usize\n        }\n    }\n\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        checked_add(\n            self.extra_to_output_from_state(),\n            self.extra_to_input_from_state(byte_length),\n        )\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        // worst case: 1 to 3 (half-width katakana)\n        self.max_utf8_buffer_length(byte_length)\n    }\n\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        checked_mul(\n            3,\n            checked_add(\n                self.extra_to_output_from_state(),\n                self.extra_to_input_from_state(byte_length),\n            ),\n        )\n    }\n\n    decoder_functions!(\n        {\n            if self.pending_prepended {\n                // lead was set in EscapeStart and \"prepended\"\n                // in Escape.\n                debug_assert!(self.lead == 0x24u8 || self.lead == 0x28u8);\n                match dest.check_space_bmp() {\n                    Space::Full(_) => {\n                        return (DecoderResult::OutputFull, 0, 0);\n                    }\n                    Space::Available(destination_handle) => {\n                        self.pending_prepended = false;\n                        self.output_flag = false;\n                        match self.decoder_state {\n                            Iso2022JpDecoderState::Ascii | Iso2022JpDecoderState::Roman => {\n                                destination_handle.write_ascii(self.lead);\n                                self.lead = 0x0u8;\n                            }\n                            Iso2022JpDecoderState::Katakana => {\n                                destination_handle\n                                    .write_upper_bmp(u16::from(self.lead) - 0x21u16 + 0xFF61u16);\n                                self.lead = 0x0u8;\n                            }\n                            Iso2022JpDecoderState::LeadByte => {\n                                self.decoder_state = Iso2022JpDecoderState::TrailByte;\n                            }\n                            _ => unreachable!(),\n                        }\n                    }\n                }\n            }\n        },\n        {},\n        {\n            match self.decoder_state {\n                Iso2022JpDecoderState::TrailByte | Iso2022JpDecoderState::EscapeStart => {\n                    self.decoder_state = self.output_state;\n                    return (DecoderResult::Malformed(1, 0), src_consumed, dest.written());\n                }\n                Iso2022JpDecoderState::Escape => {\n                    self.pending_prepended = true;\n                    self.decoder_state = self.output_state;\n                    return (DecoderResult::Malformed(1, 1), src_consumed, dest.written());\n                }\n                _ => {}\n            }\n        },\n        {\n            match self.decoder_state {\n                Iso2022JpDecoderState::Ascii => {\n                    if b == 0x1Bu8 {\n                        self.decoder_state = Iso2022JpDecoderState::EscapeStart;\n                        continue;\n                    }\n                    self.output_flag = false;\n                    if b > 0x7Fu8 || b == 0x0Eu8 || b == 0x0Fu8 {\n                        return (\n                            DecoderResult::Malformed(1, 0),\n                            unread_handle.consumed(),\n                            destination_handle.written(),\n                        );\n                    }\n                    destination_handle.write_ascii(b);\n                    continue;\n                }\n                Iso2022JpDecoderState::Roman => {\n                    if b == 0x1Bu8 {\n                        self.decoder_state = Iso2022JpDecoderState::EscapeStart;\n                        continue;\n                    }\n                    self.output_flag = false;\n                    if b == 0x5Cu8 {\n                        destination_handle.write_mid_bmp(0x00A5u16);\n                        continue;\n                    }\n                    if b == 0x7Eu8 {\n                        destination_handle.write_upper_bmp(0x203Eu16);\n                        continue;\n                    }\n                    if b > 0x7Fu8 || b == 0x0Eu8 || b == 0x0Fu8 {\n                        return (\n                            DecoderResult::Malformed(1, 0),\n                            unread_handle.consumed(),\n                            destination_handle.written(),\n                        );\n                    }\n                    destination_handle.write_ascii(b);\n                    continue;\n                }\n                Iso2022JpDecoderState::Katakana => {\n                    if b == 0x1Bu8 {\n                        self.decoder_state = Iso2022JpDecoderState::EscapeStart;\n                        continue;\n                    }\n                    self.output_flag = false;\n                    if b >= 0x21u8 && b <= 0x5Fu8 {\n                        destination_handle.write_upper_bmp(u16::from(b) - 0x21u16 + 0xFF61u16);\n                        continue;\n                    }\n                    return (\n                        DecoderResult::Malformed(1, 0),\n                        unread_handle.consumed(),\n                        destination_handle.written(),\n                    );\n                }\n                Iso2022JpDecoderState::LeadByte => {\n                    if b == 0x1Bu8 {\n                        self.decoder_state = Iso2022JpDecoderState::EscapeStart;\n                        continue;\n                    }\n                    self.output_flag = false;\n                    if b >= 0x21u8 && b <= 0x7Eu8 {\n                        self.lead = b;\n                        self.decoder_state = Iso2022JpDecoderState::TrailByte;\n                        continue;\n                    }\n                    return (\n                        DecoderResult::Malformed(1, 0),\n                        unread_handle.consumed(),\n                        destination_handle.written(),\n                    );\n                }\n                Iso2022JpDecoderState::TrailByte => {\n                    if b == 0x1Bu8 {\n                        self.decoder_state = Iso2022JpDecoderState::EscapeStart;\n                        // The byte in error is the previous\n                        // lead byte.\n                        return (\n                            DecoderResult::Malformed(1, 1),\n                            unread_handle.consumed(),\n                            destination_handle.written(),\n                        );\n                    }\n                    self.decoder_state = Iso2022JpDecoderState::LeadByte;\n                    let jis0208_lead_minus_offset = self.lead - 0x21;\n                    let byte = b;\n                    let handle = destination_handle;\n                    // The code below uses else after continue in\n                    // order to retain the structure seen in EUC-JP.\n                    let trail_minus_offset = byte.wrapping_sub(0x21);\n                    // Fast-track Hiragana (60% according to Lunde)\n                    // and Katakana (10% acconding to Lunde).\n                    if jis0208_lead_minus_offset == 0x03 && trail_minus_offset < 0x53 {\n                        // Hiragana\n                        handle.write_upper_bmp(0x3041 + u16::from(trail_minus_offset));\n                        continue;\n                    } else if jis0208_lead_minus_offset == 0x04 && trail_minus_offset < 0x56 {\n                        // Katakana\n                        handle.write_upper_bmp(0x30A1 + u16::from(trail_minus_offset));\n                        continue;\n                    } else if trail_minus_offset > (0xFE - 0xA1) {\n                        return (\n                            DecoderResult::Malformed(2, 0),\n                            unread_handle.consumed(),\n                            handle.written(),\n                        );\n                    } else {\n                        let pointer =\n                            mul_94(jis0208_lead_minus_offset) + trail_minus_offset as usize;\n                        let level1_pointer = pointer.wrapping_sub(1410);\n                        if level1_pointer < JIS0208_LEVEL1_KANJI.len() {\n                            handle.write_upper_bmp(JIS0208_LEVEL1_KANJI[level1_pointer]);\n                            continue;\n                        } else {\n                            let level2_pointer = pointer.wrapping_sub(4418);\n                            if level2_pointer < JIS0208_LEVEL2_AND_ADDITIONAL_KANJI.len() {\n                                handle.write_upper_bmp(\n                                    JIS0208_LEVEL2_AND_ADDITIONAL_KANJI[level2_pointer],\n                                );\n                                continue;\n                            } else {\n                                let ibm_pointer = pointer.wrapping_sub(8272);\n                                if ibm_pointer < IBM_KANJI.len() {\n                                    handle.write_upper_bmp(IBM_KANJI[ibm_pointer]);\n                                    continue;\n                                } else if let Some(bmp) = jis0208_symbol_decode(pointer) {\n                                    handle.write_bmp_excl_ascii(bmp);\n                                    continue;\n                                } else if let Some(bmp) = jis0208_range_decode(pointer) {\n                                    handle.write_bmp_excl_ascii(bmp);\n                                    continue;\n                                } else {\n                                    return (\n                                        DecoderResult::Malformed(2, 0),\n                                        unread_handle.consumed(),\n                                        handle.written(),\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n                Iso2022JpDecoderState::EscapeStart => {\n                    if b == 0x24u8 || b == 0x28u8 {\n                        self.lead = b;\n                        self.decoder_state = Iso2022JpDecoderState::Escape;\n                        continue;\n                    }\n                    self.output_flag = false;\n                    self.decoder_state = self.output_state;\n                    return (\n                        DecoderResult::Malformed(1, 0),\n                        unread_handle.unread(),\n                        destination_handle.written(),\n                    );\n                }\n                Iso2022JpDecoderState::Escape => {\n                    let mut state: Option<Iso2022JpDecoderState> = None;\n                    if self.lead == 0x28u8 && b == 0x42u8 {\n                        state = Some(Iso2022JpDecoderState::Ascii);\n                    } else if self.lead == 0x28u8 && b == 0x4Au8 {\n                        state = Some(Iso2022JpDecoderState::Roman);\n                    } else if self.lead == 0x28u8 && b == 0x49u8 {\n                        state = Some(Iso2022JpDecoderState::Katakana);\n                    } else if self.lead == 0x24u8 && (b == 0x40u8 || b == 0x42u8) {\n                        state = Some(Iso2022JpDecoderState::LeadByte);\n                    }\n                    match state {\n                        Some(s) => {\n                            self.lead = 0x0u8;\n                            self.decoder_state = s;\n                            self.output_state = s;\n                            let flag = self.output_flag;\n                            self.output_flag = true;\n                            if flag {\n                                // We had an escape sequence\n                                // immediately following another\n                                // escape sequence. Therefore,\n                                // the first one of these was\n                                // useless.\n                                return (\n                                    DecoderResult::Malformed(3, 3),\n                                    unread_handle.consumed(),\n                                    destination_handle.written(),\n                                );\n                            }\n                            continue;\n                        }\n                        None => {\n                            // self.lead is still the previous\n                            // byte. It will be processed in\n                            // the preabmle upon next call.\n                            self.pending_prepended = true;\n                            self.output_flag = false;\n                            self.decoder_state = self.output_state;\n                            // The byte in error is not the\n                            // current or the previous byte but\n                            // the one before those (lone 0x1B).\n                            return (\n                                DecoderResult::Malformed(1, 1),\n                                unread_handle.unread(),\n                                destination_handle.written(),\n                            );\n                        }\n                    }\n                }\n            }\n        },\n        self,\n        src_consumed,\n        dest,\n        source,\n        b,\n        destination_handle,\n        unread_handle,\n        check_space_bmp\n    );\n}"],"iso_2022_jp::Iso2022JpDecoderState":["Clone","Copy","PartialEq"],"iso_2022_jp::Iso2022JpEncoder":["impl Iso2022JpEncoder {\n    pub fn new(encoding: &'static Encoding) -> Encoder {\n        Encoder::new(\n            encoding,\n            VariantEncoder::Iso2022Jp(Iso2022JpEncoder {\n                state: Iso2022JpEncoderState::Ascii,\n            }),\n        )\n    }\n\n    pub fn has_pending_state(&self) -> bool {\n        match self.state {\n            Iso2022JpEncoderState::Ascii => false,\n            _ => true,\n        }\n    }\n\n    pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        // Worst case: every other character is ASCII/Roman and every other\n        // JIS0208.\n        // Two UTF-16 input units:\n        // Transition to Roman: 3\n        // Roman/ASCII: 1\n        // Transition to JIS0208: 3\n        // JIS0208: 2\n        // End transition: 3\n        checked_add_opt(\n            checked_add(3, u16_length.checked_mul(4)),\n            checked_div(u16_length.checked_add(1), 2),\n        )\n    }\n\n    pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        // Worst case: every other character is ASCII/Roman and every other\n        // JIS0208.\n        // Three UTF-8 input units: 1 ASCII, 2 JIS0208\n        // Transition to ASCII: 3\n        // Roman/ASCII: 1\n        // Transition to JIS0208: 3\n        // JIS0208: 2\n        // End transition: 3\n        checked_add(3, byte_length.checked_mul(3))\n    }\n\n    encoder_functions!(\n        {\n            match self.state {\n                Iso2022JpEncoderState::Ascii => {}\n                _ => match dest.check_space_three() {\n                    Space::Full(dst_written) => {\n                        return (EncoderResult::OutputFull, src_consumed, dst_written);\n                    }\n                    Space::Available(destination_handle) => {\n                        self.state = Iso2022JpEncoderState::Ascii;\n                        destination_handle.write_three(0x1Bu8, 0x28u8, 0x42u8);\n                    }\n                },\n            }\n        },\n        {\n            match self.state {\n                Iso2022JpEncoderState::Ascii => {\n                    if c == '\\u{0E}' || c == '\\u{0F}' || c == '\\u{1B}' {\n                        return (\n                            EncoderResult::Unmappable('\\u{FFFD}'),\n                            unread_handle.consumed(),\n                            destination_handle.written(),\n                        );\n                    }\n                    if c <= '\\u{7F}' {\n                        destination_handle.write_one(c as u8);\n                        continue;\n                    }\n                    if c == '\\u{A5}' || c == '\\u{203E}' {\n                        self.state = Iso2022JpEncoderState::Roman;\n                        destination_handle.write_three(0x1Bu8, 0x28u8, 0x4Au8);\n                        unread_handle.unread();\n                        continue;\n                    }\n                    if c > '\\u{FFFF}' {\n                        return (\n                            EncoderResult::Unmappable(c),\n                            unread_handle.consumed(),\n                            destination_handle.written(),\n                        );\n                    }\n                    // Yes, if c is in index, we'll search\n                    // again in the Jis0208 state, but this\n                    // encoder is not worth optimizing.\n                    if is_mapped_for_two_byte_encode(c as u16) {\n                        self.state = Iso2022JpEncoderState::Jis0208;\n                        destination_handle.write_three(0x1Bu8, 0x24u8, 0x42u8);\n                        unread_handle.unread();\n                        continue;\n                    }\n                    return (\n                        EncoderResult::Unmappable(c),\n                        unread_handle.consumed(),\n                        destination_handle.written(),\n                    );\n                }\n                Iso2022JpEncoderState::Roman => {\n                    if c == '\\u{0E}' || c == '\\u{0F}' || c == '\\u{1B}' {\n                        return (\n                            EncoderResult::Unmappable('\\u{FFFD}'),\n                            unread_handle.consumed(),\n                            destination_handle.written(),\n                        );\n                    }\n                    if c == '\\u{5C}' || c == '\\u{7E}' {\n                        self.state = Iso2022JpEncoderState::Ascii;\n                        destination_handle.write_three(0x1Bu8, 0x28u8, 0x42u8);\n                        unread_handle.unread();\n                        continue;\n                    }\n                    if c <= '\\u{7F}' {\n                        destination_handle.write_one(c as u8);\n                        continue;\n                    }\n                    if c == '\\u{A5}' {\n                        destination_handle.write_one(0x5Cu8);\n                        continue;\n                    }\n                    if c == '\\u{203E}' {\n                        destination_handle.write_one(0x7Eu8);\n                        continue;\n                    }\n                    if c > '\\u{FFFF}' {\n                        return (\n                            EncoderResult::Unmappable(c),\n                            unread_handle.consumed(),\n                            destination_handle.written(),\n                        );\n                    }\n                    // Yes, if c is in index, we'll search\n                    // again in the Jis0208 state, but this\n                    // encoder is not worth optimizing.\n                    if is_mapped_for_two_byte_encode(c as u16) {\n                        self.state = Iso2022JpEncoderState::Jis0208;\n                        destination_handle.write_three(0x1Bu8, 0x24u8, 0x42u8);\n                        unread_handle.unread();\n                        continue;\n                    }\n                    return (\n                        EncoderResult::Unmappable(c),\n                        unread_handle.consumed(),\n                        destination_handle.written(),\n                    );\n                }\n                Iso2022JpEncoderState::Jis0208 => {\n                    if c <= '\\u{7F}' {\n                        self.state = Iso2022JpEncoderState::Ascii;\n                        destination_handle.write_three(0x1Bu8, 0x28u8, 0x42u8);\n                        unread_handle.unread();\n                        continue;\n                    }\n                    if c == '\\u{A5}' || c == '\\u{203E}' {\n                        self.state = Iso2022JpEncoderState::Roman;\n                        destination_handle.write_three(0x1Bu8, 0x28u8, 0x4Au8);\n                        unread_handle.unread();\n                        continue;\n                    }\n                    if c > '\\u{FFFF}' {\n                        // Transition to ASCII here in order\n                        // not to make it the responsibility\n                        // of the caller.\n                        self.state = Iso2022JpEncoderState::Ascii;\n                        return (\n                            EncoderResult::Unmappable(c),\n                            unread_handle.consumed(),\n                            destination_handle.write_three_return_written(0x1Bu8, 0x28u8, 0x42u8),\n                        );\n                    }\n                    let bmp = c as u16;\n                    let handle = destination_handle;\n                    // The code below uses else after continue to\n                    // keep the same structure as in EUC-JP.\n                    // Lunde says 60% Hiragana, 30% Kanji, 10% Katakana\n                    let bmp_minus_hiragana = bmp.wrapping_sub(0x3041);\n                    if bmp_minus_hiragana < 0x53 {\n                        handle.write_two(0x24, 0x21 + bmp_minus_hiragana as u8);\n                        continue;\n                    } else if in_inclusive_range16(bmp, 0x4E00, 0x9FA0) {\n                        if let Some((lead, trail)) = encode_kanji(bmp) {\n                            handle.write_two(lead, trail);\n                            continue;\n                        } else {\n                            self.state = Iso2022JpEncoderState::Ascii;\n                            return (\n                                EncoderResult::Unmappable(c),\n                                unread_handle.consumed(),\n                                handle.write_three_return_written(0x1Bu8, 0x28u8, 0x42u8),\n                            );\n                        }\n                    } else {\n                        let bmp_minus_katakana = bmp.wrapping_sub(0x30A1);\n                        if bmp_minus_katakana < 0x56 {\n                            handle.write_two(0x25, 0x21 + bmp_minus_katakana as u8);\n                            continue;\n                        } else {\n                            let bmp_minus_space = bmp.wrapping_sub(0x3000);\n                            if bmp_minus_space < 3 {\n                                // fast-track common punctuation\n                                handle.write_two(0x21, 0x21 + bmp_minus_space as u8);\n                                continue;\n                            }\n                            let bmp_minus_half_width = bmp.wrapping_sub(0xFF61);\n                            if bmp_minus_half_width <= (0xFF9F - 0xFF61) {\n                                // We have half-width katakana. The lead is either\n                                // row 1 or 5 of JIS X 0208, so the lookup table\n                                // only stores the trail.\n                                let lead =\n                                    if bmp != 0xFF70 && in_inclusive_range16(bmp, 0xFF66, 0xFF9D) {\n                                        0x25u8\n                                    } else {\n                                        0x21u8\n                                    };\n                                let trail =\n                                    ISO_2022_JP_HALF_WIDTH_TRAIL[bmp_minus_half_width as usize];\n                                handle.write_two(lead, trail);\n                                continue;\n                            } else if bmp == 0x2212 {\n                                handle.write_two(0x21, 0x5D);\n                                continue;\n                            } else if let Some(pointer) = jis0208_range_encode(bmp) {\n                                let lead = (pointer / 94) + 0x21;\n                                let trail = (pointer % 94) + 0x21;\n                                handle.write_two(lead as u8, trail as u8);\n                                continue;\n                            } else if in_inclusive_range16(bmp, 0xFA0E, 0xFA2D)\n                                || bmp == 0xF929\n                                || bmp == 0xF9DC\n                            {\n                                // Guaranteed to be found in IBM_KANJI\n                                let pos = position(&IBM_KANJI[..], bmp).unwrap();\n                                let lead = (pos / 94) + (0xF9 - 0x80);\n                                let trail = (pos % 94) + 0x21;\n                                handle.write_two(lead as u8, trail as u8);\n                                continue;\n                            } else if let Some(pointer) = ibm_symbol_encode(bmp) {\n                                let lead = (pointer / 94) + 0x21;\n                                let trail = (pointer % 94) + 0x21;\n                                handle.write_two(lead as u8, trail as u8);\n                                continue;\n                            } else if let Some(pointer) = jis0208_symbol_encode(bmp) {\n                                let lead = (pointer / 94) + 0x21;\n                                let trail = (pointer % 94) + 0x21;\n                                handle.write_two(lead as u8, trail as u8);\n                                continue;\n                            } else {\n                                self.state = Iso2022JpEncoderState::Ascii;\n                                return (\n                                    EncoderResult::Unmappable(c),\n                                    unread_handle.consumed(),\n                                    handle.write_three_return_written(0x1Bu8, 0x28u8, 0x42u8),\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        self,\n        src_consumed,\n        source,\n        dest,\n        c,\n        destination_handle,\n        unread_handle,\n        check_space_three\n    );\n}"],"mem::Latin1Bidi":["Debug","Eq","PartialEq"],"replacement::ReplacementDecoder":["impl ReplacementDecoder {\n    pub fn new() -> VariantDecoder {\n        VariantDecoder::Replacement(ReplacementDecoder { emitted: false })\n    }\n\n    pub fn max_utf16_buffer_length(&self, _u16_length: usize) -> Option<usize> {\n        Some(1)\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, _byte_length: usize) -> Option<usize> {\n        Some(3)\n    }\n\n    pub fn max_utf8_buffer_length(&self, _byte_length: usize) -> Option<usize> {\n        Some(3)\n    }\n\n    pub fn decode_to_utf16_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u16],\n        _last: bool,\n    ) -> (DecoderResult, usize, usize) {\n        // Don't err if the input stream is empty. See\n        // https://github.com/whatwg/encoding/issues/33\n        if self.emitted || src.is_empty() {\n            (DecoderResult::InputEmpty, src.len(), 0)\n        } else if dst.is_empty() {\n            // Make sure there's room for the replacement character.\n            (DecoderResult::OutputFull, 0, 0)\n        } else {\n            self.emitted = true;\n            (DecoderResult::Malformed(1, 0), 1, 0)\n        }\n    }\n\n    pub fn decode_to_utf8_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u8],\n        _last: bool,\n    ) -> (DecoderResult, usize, usize) {\n        // Don't err if the input stream is empty. See\n        // https://github.com/whatwg/encoding/issues/33\n        if self.emitted || src.is_empty() {\n            (DecoderResult::InputEmpty, src.len(), 0)\n        } else if dst.len() < 3 {\n            // Make sure there's room for the replacement character.\n            (DecoderResult::OutputFull, 0, 0)\n        } else {\n            self.emitted = true;\n            (DecoderResult::Malformed(1, 0), 1, 0)\n        }\n    }\n}"],"shift_jis::ShiftJisDecoder":["impl ShiftJisDecoder {\n    pub fn new() -> VariantDecoder {\n        VariantDecoder::ShiftJis(ShiftJisDecoder { lead: None })\n    }\n\n    pub fn in_neutral_state(&self) -> bool {\n        self.lead.is_none()\n    }\n\n    fn plus_one_if_lead(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_add(match self.lead {\n            None => 0,\n            Some(_) => 1,\n        })\n    }\n\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        self.plus_one_if_lead(byte_length)\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        // worst case: 1 to 3 (half-width katakana)\n        self.max_utf8_buffer_length(byte_length)\n    }\n\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        checked_mul(3, self.plus_one_if_lead(byte_length))\n    }\n\n    ascii_compatible_two_byte_decoder_functions!(\n        {\n           // If lead is between 0x81 and 0x9F, inclusive,\n           // subtract offset 0x81. Else if lead is\n           // between 0xE0 and 0xFC, inclusive, subtract\n           // offset 0xC1. Else if lead is between\n           // 0xA1 and 0xDF, inclusive, map to half-width\n           // Katakana. Else if lead is 0x80, pass through.\n            let mut non_ascii_minus_offset =\n                non_ascii.wrapping_sub(0x81);\n            if non_ascii_minus_offset > (0x9F - 0x81) {\n                let non_ascii_minus_range_start = non_ascii.wrapping_sub(0xE0);\n                if non_ascii_minus_range_start > (0xFC - 0xE0) {\n                    let non_ascii_minus_half_with_katakana_start = non_ascii.wrapping_sub(0xA1);\n                    if non_ascii_minus_half_with_katakana_start > (0xDF - 0xA1) {\n                        if non_ascii == 0x80 {\n                            handle.write_mid_bmp(0x80);\n                            // Not caring about optimizing subsequent non-ASCII\n                            continue 'outermost;\n                        }\n                        return (DecoderResult::Malformed(1, 0),\n                                source.consumed(),\n                                handle.written());\n                    }\n                    handle.write_upper_bmp(0xFF61 + u16::from(non_ascii_minus_half_with_katakana_start));\n                    // Not caring about optimizing subsequent non-ASCII\n                    continue 'outermost;\n                }\n                non_ascii_minus_offset = non_ascii - 0xC1;\n            }\n            non_ascii_minus_offset\n        },\n        {\n            // If trail is between 0x40 and 0x7E, inclusive,\n            // subtract offset 0x40. Else if trail is\n            // between 0x80 and 0xFC, inclusive, subtract\n            // offset 0x41.\n            // Fast-track Hiragana (60% according to Lunde)\n            // and Katakana (10% acconding to Lunde).\n            // Hiragana doesn't cross 0x7F, but Katakana does.\n            // We can check for Hiragana before normalizing\n            // trail.\n            let trail_minus_hiragana = byte.wrapping_sub(0x9F);\n            if lead_minus_offset == 0x01 && trail_minus_hiragana < 0x53 {\n            // Hiragana\n                handle.write_upper_bmp(0x3041 + u16::from(trail_minus_hiragana))\n            } else {\n                let mut trail_minus_offset =\n                    byte.wrapping_sub(0x40);\n                if trail_minus_offset > (0x7E - 0x40) {\n                    let trail_minus_range_start =\n                        byte.wrapping_sub(0x80);\n                    if trail_minus_range_start > (0xFC - 0x80) {\n                        if byte < 0x80 {\n                            return (DecoderResult::Malformed(1, 0),\n                                    unread_handle_trail.unread(),\n                                    handle.written());\n                        }\n                        return (DecoderResult::Malformed(2, 0),\n                                unread_handle_trail.consumed(),\n                                handle.written());\n                    }\n                    trail_minus_offset = byte - 0x41;\n                }\n                if lead_minus_offset == 0x02 &&\n                   trail_minus_offset < 0x56 {\n                    // Katakana\n                    handle.write_upper_bmp(0x30A1 + u16::from(trail_minus_offset))\n                } else {\n                    let pointer = lead_minus_offset as usize *\n                                  188usize +\n                                  trail_minus_offset as usize;\n                    let level1_pointer = pointer.wrapping_sub(1410);\n                    if level1_pointer < JIS0208_LEVEL1_KANJI.len() {\n                        handle.write_upper_bmp(JIS0208_LEVEL1_KANJI[level1_pointer])\n                    } else {\n                        let level2_pointer = pointer.wrapping_sub(4418);\n                        if level2_pointer <\n                           JIS0208_LEVEL2_AND_ADDITIONAL_KANJI.len() {\n                            handle.write_upper_bmp(JIS0208_LEVEL2_AND_ADDITIONAL_KANJI[level2_pointer])\n                        } else {\n                            let upper_ibm_pointer = pointer.wrapping_sub(10744);\n                            if upper_ibm_pointer < IBM_KANJI.len() {\n                                handle.write_upper_bmp(IBM_KANJI[upper_ibm_pointer])\n                            } else {\n                                let lower_ibm_pointer = pointer.wrapping_sub(8272);\n                                if lower_ibm_pointer < IBM_KANJI.len() {\n                                    handle.write_upper_bmp(IBM_KANJI[lower_ibm_pointer])\n                                } else if in_inclusive_range(pointer, 8836, 10715) {\n                                    handle.write_upper_bmp((0xE000 - 8836 + pointer) as u16)\n                                } else if let Some(bmp) = jis0208_symbol_decode(pointer) {\n                                    handle.write_bmp_excl_ascii(bmp)\n                                } else if let Some(bmp) = jis0208_range_decode(pointer) {\n                                    handle.write_bmp_excl_ascii(bmp)\n                                } else {\n                                    if byte < 0x80 {\n                                        return (DecoderResult::Malformed(1, 0),\n                                                unread_handle_trail.unread(),\n                                                handle.written());\n                                    }\n                                    return (DecoderResult::Malformed(2, 0),\n                                            unread_handle_trail.consumed(),\n                                            handle.written());\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        self,\n        non_ascii,\n        byte,\n        lead_minus_offset,\n        unread_handle_trail,\n        source,\n        handle,\n        'outermost,\n        copy_ascii_from_check_space_bmp,\n        check_space_bmp,\n        false);\n}"],"shift_jis::ShiftJisEncoder":["impl ShiftJisEncoder {\n    pub fn new(encoding: &'static Encoding) -> Encoder {\n        Encoder::new(encoding, VariantEncoder::ShiftJis(ShiftJisEncoder))\n    }\n\n    pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        u16_length.checked_mul(2)\n    }\n\n    pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        byte_length.checked_add(1)\n    }\n\n    ascii_compatible_bmp_encoder_functions!(\n        {\n            // Lunde says 60% Hiragana, 30% Kanji, 10% Katakana\n            let bmp_minus_hiragana = bmp.wrapping_sub(0x3041);\n            if bmp_minus_hiragana < 0x53 {\n                handle.write_two(0x82, 0x9F + bmp_minus_hiragana as u8)\n            } else if in_inclusive_range16(bmp, 0x4E00, 0x9FA0) {\n                if let Some((lead, trail)) = encode_kanji(bmp) {\n                    handle.write_two(lead, trail)\n                } else {\n                    return (\n                        EncoderResult::unmappable_from_bmp(bmp),\n                        source.consumed(),\n                        handle.written(),\n                    );\n                }\n            } else {\n                let bmp_minus_katakana = bmp.wrapping_sub(0x30A1);\n                if bmp_minus_katakana < 0x56 {\n                    let trail_offset = if bmp_minus_katakana < 0x3F {\n                        0x40\n                    } else {\n                        0x41\n                    };\n                    handle.write_two(0x83, (trail_offset + bmp_minus_katakana) as u8)\n                } else {\n                    let bmp_minus_space = bmp.wrapping_sub(0x3000);\n                    if bmp_minus_space < 3 {\n                        // fast-track common punctuation\n                        handle.write_two(0x81, 0x40 + bmp_minus_space as u8)\n                    } else if bmp == 0xA5 {\n                        handle.write_one(0x5Cu8)\n                    } else if bmp == 0x80 {\n                        handle.write_one(0x80u8)\n                    } else if bmp == 0x203E {\n                        handle.write_one(0x7Eu8)\n                    } else if in_inclusive_range16(bmp, 0xFF61, 0xFF9F) {\n                        handle.write_one((bmp - (0xFF61 - 0xA1)) as u8)\n                    } else if bmp == 0x2212 {\n                        handle.write_two(0x81u8, 0x7Cu8)\n                    } else {\n                        let bmp_minus_roman = bmp.wrapping_sub(0x2170);\n                        let pointer = if bmp_minus_roman <= (0x2179 - 0x2170) {\n                            10716 + bmp_minus_roman as usize\n                        } else if let Some(pointer) = jis0208_range_encode(bmp) {\n                            pointer\n                        } else if in_inclusive_range16(bmp, 0xFA0E, 0xFA2D)\n                            || bmp == 0xF929\n                            || bmp == 0xF9DC\n                        {\n                            // Guaranteed to be found in IBM_KANJI\n                            let pos = position(&IBM_KANJI[..], bmp).unwrap();\n                            10744 + pos\n                        } else if let Some(pointer) = jis0208_symbol_encode(bmp) {\n                            pointer\n                        } else {\n                            return (\n                                EncoderResult::unmappable_from_bmp(bmp),\n                                source.consumed(),\n                                handle.written(),\n                            );\n                        };\n                        let lead = pointer / 188;\n                        let lead_offset = if lead < 0x1F { 0x81usize } else { 0xC1usize };\n                        let trail = pointer % 188;\n                        let trail_offset = if trail < 0x3F { 0x40usize } else { 0x41usize };\n                        handle.write_two((lead + lead_offset) as u8, (trail + trail_offset) as u8)\n                    }\n                }\n            }\n        },\n        bmp,\n        self,\n        source,\n        handle,\n        copy_ascii_to_check_space_two,\n        check_space_two,\n        false\n    );\n}"],"single_byte::SingleByteDecoder":["impl SingleByteDecoder {\n    pub fn new(data: &'static [u16; 128]) -> VariantDecoder {\n        VariantDecoder::SingleByte(SingleByteDecoder { table: data })\n    }\n\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        Some(byte_length)\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_mul(3)\n    }\n\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_mul(3)\n    }\n\n    pub fn decode_to_utf8_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u8],\n        _last: bool,\n    ) -> (DecoderResult, usize, usize) {\n        let mut source = ByteSource::new(src);\n        let mut dest = Utf8Destination::new(dst);\n        'outermost: loop {\n            match dest.copy_ascii_from_check_space_bmp(&mut source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut handle)) => 'middle: loop {\n                    // Start non-boilerplate\n                    //\n                    // Since the non-ASCIIness of `non_ascii` is hidden from\n                    // the optimizer, it can't figure out that it's OK to\n                    // statically omit the bound check when accessing\n                    // `[u16; 128]` with an index\n                    // `non_ascii as usize - 0x80usize`.\n                    let mapped =\n                        unsafe { *(self.table.get_unchecked(non_ascii as usize - 0x80usize)) };\n                    // let mapped = self.table[non_ascii as usize - 0x80usize];\n                    if mapped == 0u16 {\n                        return (\n                            DecoderResult::Malformed(1, 0),\n                            source.consumed(),\n                            handle.written(),\n                        );\n                    }\n                    let dest_again = handle.write_bmp_excl_ascii(mapped);\n                    // End non-boilerplate\n                    match source.check_available() {\n                        Space::Full(src_consumed) => {\n                            return (\n                                DecoderResult::InputEmpty,\n                                src_consumed,\n                                dest_again.written(),\n                            );\n                        }\n                        Space::Available(source_handle) => {\n                            match dest_again.check_space_bmp() {\n                                Space::Full(dst_written) => {\n                                    return (\n                                        DecoderResult::OutputFull,\n                                        source_handle.consumed(),\n                                        dst_written,\n                                    );\n                                }\n                                Space::Available(mut destination_handle) => {\n                                    let (mut b, unread_handle) = source_handle.read();\n                                    let source_again = unread_handle.commit();\n                                    'innermost: loop {\n                                        if b > 127 {\n                                            non_ascii = b;\n                                            handle = destination_handle;\n                                            continue 'middle;\n                                        }\n                                        // Testing on Haswell says that we should write the\n                                        // byte unconditionally instead of trying to unread it\n                                        // to make it part of the next SIMD stride.\n                                        let dest_again_again = destination_handle.write_ascii(b);\n                                        if b < 60 {\n                                            // We've got punctuation\n                                            match source_again.check_available() {\n                                                Space::Full(src_consumed_again) => {\n                                                    return (\n                                                        DecoderResult::InputEmpty,\n                                                        src_consumed_again,\n                                                        dest_again_again.written(),\n                                                    );\n                                                }\n                                                Space::Available(source_handle_again) => {\n                                                    match dest_again_again.check_space_bmp() {\n                                                        Space::Full(dst_written_again) => {\n                                                            return (\n                                                                DecoderResult::OutputFull,\n                                                                source_handle_again.consumed(),\n                                                                dst_written_again,\n                                                            );\n                                                        }\n                                                        Space::Available(\n                                                            destination_handle_again,\n                                                        ) => {\n                                                            let (b_again, _unread_handle_again) =\n                                                                source_handle_again.read();\n                                                            b = b_again;\n                                                            destination_handle =\n                                                                destination_handle_again;\n                                                            continue 'innermost;\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        // We've got markup or ASCII text\n                                        continue 'outermost;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n            }\n        }\n    }\n\n    pub fn decode_to_utf16_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u16],\n        _last: bool,\n    ) -> (DecoderResult, usize, usize) {\n        let (pending, length) = if dst.len() < src.len() {\n            (DecoderResult::OutputFull, dst.len())\n        } else {\n            (DecoderResult::InputEmpty, src.len())\n        };\n        let mut converted = 0usize;\n        'outermost: loop {\n            match unsafe {\n                ascii_to_basic_latin(\n                    src.as_ptr().add(converted),\n                    dst.as_mut_ptr().add(converted),\n                    length - converted,\n                )\n            } {\n                None => {\n                    return (pending, length, length);\n                }\n                Some((mut non_ascii, consumed)) => {\n                    converted += consumed;\n                    'middle: loop {\n                        // `converted` doesn't count the reading of `non_ascii` yet.\n                        // Since the non-ASCIIness of `non_ascii` is hidden from\n                        // the optimizer, it can't figure out that it's OK to\n                        // statically omit the bound check when accessing\n                        // `[u16; 128]` with an index\n                        // `non_ascii as usize - 0x80usize`.\n                        let mapped =\n                            unsafe { *(self.table.get_unchecked(non_ascii as usize - 0x80usize)) };\n                        // let mapped = self.table[non_ascii as usize - 0x80usize];\n                        if mapped == 0u16 {\n                            return (\n                                DecoderResult::Malformed(1, 0),\n                                converted + 1, // +1 `for non_ascii`\n                                converted,\n                            );\n                        }\n                        unsafe {\n                            // The bound check has already been performed\n                            *(dst.get_unchecked_mut(converted)) = mapped;\n                        }\n                        converted += 1;\n                        // Next, handle ASCII punctuation and non-ASCII without\n                        // going back to ASCII acceleration. Non-ASCII scripts\n                        // use ASCII punctuation, so this avoid going to\n                        // acceleration just for punctuation/space and then\n                        // failing. This is a significant boost to non-ASCII\n                        // scripts.\n                        // TODO: Split out Latin converters without this part\n                        // this stuff makes Latin script-conversion slower.\n                        if converted == length {\n                            return (pending, length, length);\n                        }\n                        let mut b = unsafe { *(src.get_unchecked(converted)) };\n                        'innermost: loop {\n                            if b > 127 {\n                                non_ascii = b;\n                                continue 'middle;\n                            }\n                            // Testing on Haswell says that we should write the\n                            // byte unconditionally instead of trying to unread it\n                            // to make it part of the next SIMD stride.\n                            unsafe {\n                                *(dst.get_unchecked_mut(converted)) = u16::from(b);\n                            }\n                            converted += 1;\n                            if b < 60 {\n                                // We've got punctuation\n                                if converted == length {\n                                    return (pending, length, length);\n                                }\n                                b = unsafe { *(src.get_unchecked(converted)) };\n                                continue 'innermost;\n                            }\n                            // We've got markup or ASCII text\n                            continue 'outermost;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    pub fn latin1_byte_compatible_up_to(&self, buffer: &[u8]) -> usize {\n        let mut bytes = buffer;\n        let mut total = 0;\n        loop {\n            if let Some((non_ascii, offset)) = validate_ascii(bytes) {\n                total += offset;\n                let mapped = unsafe { *(self.table.get_unchecked(non_ascii as usize - 0x80usize)) };\n                if mapped != u16::from(non_ascii) {\n                    return total;\n                }\n                total += 1;\n                bytes = &bytes[offset + 1..];\n            } else {\n                return total;\n            }\n        }\n    }\n}"],"single_byte::SingleByteEncoder":["impl SingleByteEncoder {\n    pub fn new(\n        encoding: &'static Encoding,\n        data: &'static [u16; 128],\n        run_bmp_offset: u16,\n        run_byte_offset: u8,\n        run_length: u8,\n    ) -> Encoder {\n        Encoder::new(\n            encoding,\n            VariantEncoder::SingleByte(SingleByteEncoder {\n                table: data,\n                run_bmp_offset: run_bmp_offset as usize,\n                run_byte_offset: run_byte_offset as usize,\n                run_length: run_length as usize,\n            }),\n        )\n    }\n\n    pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        Some(u16_length)\n    }\n\n    pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        Some(byte_length)\n    }\n\n    #[inline(always)]\n    fn encode_u16(&self, code_unit: u16) -> Option<u8> {\n        // First, we see if the code unit falls into a run of consecutive\n        // code units that can be mapped by offset. This is very efficient\n        // for most non-Latin encodings as well as Latin1-ish encodings.\n        //\n        // For encodings that don't fit this pattern, the run (which may\n        // have the length of just one) just establishes the starting point\n        // for the next rule.\n        //\n        // Next, we do a forward linear search in the part of the index\n        // after the run. Even in non-Latin1-ish Latin encodings (except\n        // macintosh), the lower case letters are here.\n        //\n        // Next, we search the third quadrant up to the start of the run\n        // (upper case letters in Latin encodings except macintosh, in\n        // Greek and in KOI encodings) and then the second quadrant,\n        // except if the run stared before the third quadrant, we search\n        // the second quadrant up to the run.\n        //\n        // Last, we search the first quadrant, which has unused controls\n        // or punctuation in most encodings. This is bad for macintosh\n        // and IBM866, but those are rare.\n\n        // Run of consecutive units\n        let unit_as_usize = code_unit as usize;\n        let offset = unit_as_usize.wrapping_sub(self.run_bmp_offset);\n        if offset < self.run_length {\n            return Some((128 + self.run_byte_offset + offset) as u8);\n        }\n\n        // Search after the run\n        let tail_start = self.run_byte_offset + self.run_length;\n        if let Some(pos) = position(&self.table[tail_start..], code_unit) {\n            return Some((128 + tail_start + pos) as u8);\n        }\n\n        if self.run_byte_offset >= 64 {\n            // Search third quadrant before the run\n            if let Some(pos) = position(&self.table[64..self.run_byte_offset], code_unit) {\n                return Some(((128 + 64) + pos) as u8);\n            }\n\n            // Search second quadrant\n            if let Some(pos) = position(&self.table[32..64], code_unit) {\n                return Some(((128 + 32) + pos) as u8);\n            }\n        } else if let Some(pos) = position(&self.table[32..self.run_byte_offset], code_unit) {\n            // windows-1252, windows-874, ISO-8859-15 and ISO-8859-5\n            // Search second quadrant before the run\n            return Some(((128 + 32) + pos) as u8);\n        }\n\n        // Search first quadrant\n        if let Some(pos) = position(&self.table[..32], code_unit) {\n            return Some((128 + pos) as u8);\n        }\n\n        None\n    }\n\n    ascii_compatible_bmp_encoder_function!(\n        {\n            match self.encode_u16(bmp) {\n                Some(byte) => handle.write_one(byte),\n                None => {\n                    return (\n                        EncoderResult::unmappable_from_bmp(bmp),\n                        source.consumed(),\n                        handle.written(),\n                    );\n                }\n            }\n        },\n        bmp,\n        self,\n        source,\n        handle,\n        copy_ascii_to_check_space_one,\n        check_space_one,\n        encode_from_utf8_raw,\n        str,\n        Utf8Source,\n        true\n    );\n\n    pub fn encode_from_utf16_raw(\n        &mut self,\n        src: &[u16],\n        dst: &mut [u8],\n        _last: bool,\n    ) -> (EncoderResult, usize, usize) {\n        let (pending, length) = if dst.len() < src.len() {\n            (EncoderResult::OutputFull, dst.len())\n        } else {\n            (EncoderResult::InputEmpty, src.len())\n        };\n        let mut converted = 0usize;\n        'outermost: loop {\n            match unsafe {\n                basic_latin_to_ascii(\n                    src.as_ptr().add(converted),\n                    dst.as_mut_ptr().add(converted),\n                    length - converted,\n                )\n            } {\n                None => {\n                    return (pending, length, length);\n                }\n                Some((mut non_ascii, consumed)) => {\n                    converted += consumed;\n                    'middle: loop {\n                        // `converted` doesn't count the reading of `non_ascii` yet.\n                        match self.encode_u16(non_ascii) {\n                            Some(byte) => {\n                                unsafe {\n                                    *(dst.get_unchecked_mut(converted)) = byte;\n                                }\n                                converted += 1;\n                            }\n                            None => {\n                                // At this point, we need to know if we\n                                // have a surrogate.\n                                let high_bits = non_ascii & 0xFC00u16;\n                                if high_bits == 0xD800u16 {\n                                    // high surrogate\n                                    if converted + 1 == length {\n                                        // End of buffer. This surrogate is unpaired.\n                                        return (\n                                            EncoderResult::Unmappable('\\u{FFFD}'),\n                                            converted + 1, // +1 `for non_ascii`\n                                            converted,\n                                        );\n                                    }\n                                    let second =\n                                        u32::from(unsafe { *src.get_unchecked(converted + 1) });\n                                    if second & 0xFC00u32 != 0xDC00u32 {\n                                        return (\n                                            EncoderResult::Unmappable('\\u{FFFD}'),\n                                            converted + 1, // +1 `for non_ascii`\n                                            converted,\n                                        );\n                                    }\n                                    // The next code unit is a low surrogate.\n                                    let astral: char = unsafe {\n                                        ::std::char::from_u32_unchecked(\n                                            (u32::from(non_ascii) << 10) + second\n                                                - (((0xD800u32 << 10) - 0x1_0000u32) + 0xDC00u32),\n                                        )\n                                    };\n                                    return (\n                                        EncoderResult::Unmappable(astral),\n                                        converted + 2, // +2 `for non_ascii` and `second`\n                                        converted,\n                                    );\n                                }\n                                if high_bits == 0xDC00u16 {\n                                    // Unpaired low surrogate\n                                    return (\n                                        EncoderResult::Unmappable('\\u{FFFD}'),\n                                        converted + 1, // +1 `for non_ascii`\n                                        converted,\n                                    );\n                                }\n                                return (\n                                    EncoderResult::unmappable_from_bmp(non_ascii),\n                                    converted + 1, // +1 `for non_ascii`\n                                    converted,\n                                );\n                            }\n                        }\n                        // Next, handle ASCII punctuation and non-ASCII without\n                        // going back to ASCII acceleration. Non-ASCII scripts\n                        // use ASCII punctuation, so this avoid going to\n                        // acceleration just for punctuation/space and then\n                        // failing. This is a significant boost to non-ASCII\n                        // scripts.\n                        // TODO: Split out Latin converters without this part\n                        // this stuff makes Latin script-conversion slower.\n                        if converted == length {\n                            return (pending, length, length);\n                        }\n                        let mut unit = unsafe { *(src.get_unchecked(converted)) };\n                        'innermost: loop {\n                            if unit > 127 {\n                                non_ascii = unit;\n                                continue 'middle;\n                            }\n                            // Testing on Haswell says that we should write the\n                            // byte unconditionally instead of trying to unread it\n                            // to make it part of the next SIMD stride.\n                            unsafe {\n                                *(dst.get_unchecked_mut(converted)) = unit as u8;\n                            }\n                            converted += 1;\n                            if unit < 60 {\n                                // We've got punctuation\n                                if converted == length {\n                                    return (pending, length, length);\n                                }\n                                unit = unsafe { *(src.get_unchecked(converted)) };\n                                continue 'innermost;\n                            }\n                            // We've got markup or ASCII text\n                            continue 'outermost;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"],"utf_16::Utf16Decoder":["impl Utf16Decoder {\n    pub fn new(big_endian: bool) -> VariantDecoder {\n        VariantDecoder::Utf16(Utf16Decoder {\n            lead_surrogate: 0,\n            lead_byte: None,\n            be: big_endian,\n            pending_bmp: false,\n        })\n    }\n\n    pub fn additional_from_state(&self) -> usize {\n        1 + if self.lead_byte.is_some() { 1 } else { 0 }\n            + if self.lead_surrogate == 0 { 0 } else { 2 }\n    }\n\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        checked_add(\n            1,\n            checked_div(byte_length.checked_add(self.additional_from_state()), 2),\n        )\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        checked_add(\n            1,\n            checked_mul(\n                3,\n                checked_div(byte_length.checked_add(self.additional_from_state()), 2),\n            ),\n        )\n    }\n\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        checked_add(\n            1,\n            checked_mul(\n                3,\n                checked_div(byte_length.checked_add(self.additional_from_state()), 2),\n            ),\n        )\n    }\n\n    decoder_functions!(\n        {\n            if self.pending_bmp {\n                match dest.check_space_bmp() {\n                    Space::Full(_) => {\n                        return (DecoderResult::OutputFull, 0, 0);\n                    }\n                    Space::Available(destination_handle) => {\n                        destination_handle.write_bmp(self.lead_surrogate);\n                        self.pending_bmp = false;\n                        self.lead_surrogate = 0;\n                    }\n                }\n            }\n        },\n        {\n            // This is the fast path. The rest runs only at the\n            // start and end for partial sequences.\n            if self.lead_byte.is_none() && self.lead_surrogate == 0 {\n                if let Some((read, written)) = if self.be {\n                    dest.copy_utf16_from::<BigEndian>(&mut source)\n                } else {\n                    dest.copy_utf16_from::<LittleEndian>(&mut source)\n                } {\n                    return (DecoderResult::Malformed(2, 0), read, written);\n                }\n            }\n        },\n        {\n            debug_assert!(!self.pending_bmp);\n            if self.lead_surrogate != 0 || self.lead_byte.is_some() {\n                // We need to check space without intent to write in order to\n                // make sure that there is space for the replacement character.\n                match dest.check_space_bmp() {\n                    Space::Full(_) => {\n                        return (DecoderResult::OutputFull, 0, 0);\n                    }\n                    Space::Available(_) => {\n                        if self.lead_surrogate != 0 {\n                            self.lead_surrogate = 0;\n                            match self.lead_byte {\n                                None => {\n                                    return (\n                                        DecoderResult::Malformed(2, 0),\n                                        src_consumed,\n                                        dest.written(),\n                                    );\n                                }\n                                Some(_) => {\n                                    self.lead_byte = None;\n                                    return (\n                                        DecoderResult::Malformed(3, 0),\n                                        src_consumed,\n                                        dest.written(),\n                                    );\n                                }\n                            }\n                        }\n                        debug_assert!(self.lead_byte.is_some());\n                        self.lead_byte = None;\n                        return (DecoderResult::Malformed(1, 0), src_consumed, dest.written());\n                    }\n                }\n            }\n        },\n        {\n            match self.lead_byte {\n                None => {\n                    self.lead_byte = Some(b);\n                    continue;\n                }\n                Some(lead) => {\n                    self.lead_byte = None;\n                    let code_unit = if self.be {\n                        u16::from(lead) << 8 | u16::from(b)\n                    } else {\n                        u16::from(b) << 8 | u16::from(lead)\n                    };\n                    let high_bits = code_unit & 0xFC00u16;\n                    if high_bits == 0xD800u16 {\n                        // high surrogate\n                        if self.lead_surrogate != 0 {\n                            // The previous high surrogate was in\n                            // error and this one becomes the new\n                            // pending one.\n                            self.lead_surrogate = code_unit as u16;\n                            return (\n                                DecoderResult::Malformed(2, 2),\n                                unread_handle.consumed(),\n                                destination_handle.written(),\n                            );\n                        }\n                        self.lead_surrogate = code_unit;\n                        continue;\n                    }\n                    if high_bits == 0xDC00u16 {\n                        // low surrogate\n                        if self.lead_surrogate == 0 {\n                            return (\n                                DecoderResult::Malformed(2, 0),\n                                unread_handle.consumed(),\n                                destination_handle.written(),\n                            );\n                        }\n                        destination_handle.write_surrogate_pair(self.lead_surrogate, code_unit);\n                        self.lead_surrogate = 0;\n                        continue;\n                    }\n                    // bmp\n                    if self.lead_surrogate != 0 {\n                        // The previous high surrogate was in\n                        // error and this code unit becomes a\n                        // pending BMP character.\n                        self.lead_surrogate = code_unit;\n                        self.pending_bmp = true;\n                        return (\n                            DecoderResult::Malformed(2, 2),\n                            unread_handle.consumed(),\n                            destination_handle.written(),\n                        );\n                    }\n                    destination_handle.write_bmp(code_unit);\n                    continue;\n                }\n            }\n        },\n        self,\n        src_consumed,\n        dest,\n        source,\n        b,\n        destination_handle,\n        unread_handle,\n        check_space_astral\n    );\n}"],"utf_8::Utf8Decoder":["impl Utf8Decoder {\n    pub fn new_inner() -> Utf8Decoder {\n        Utf8Decoder {\n            code_point: 0,\n            bytes_seen: 0,\n            bytes_needed: 0,\n            lower_boundary: 0x80u8,\n            upper_boundary: 0xBFu8,\n        }\n    }\n\n    pub fn new() -> VariantDecoder {\n        VariantDecoder::Utf8(Utf8Decoder::new_inner())\n    }\n\n    pub fn in_neutral_state(&self) -> bool {\n        self.bytes_needed == 0\n    }\n\n    fn extra_from_state(&self) -> usize {\n        if self.bytes_needed == 0 {\n            0\n        } else {\n            self.bytes_seen + 1\n        }\n    }\n\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_add(1 + self.extra_from_state())\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_add(3 + self.extra_from_state())\n    }\n\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        checked_add(\n            3,\n            checked_mul(3, byte_length.checked_add(self.extra_from_state())),\n        )\n    }\n\n    decoder_functions!(\n        {},\n        {\n            // This is the fast path. The rest runs only at the\n            // start and end for partial sequences.\n            if self.bytes_needed == 0 {\n                dest.copy_utf8_up_to_invalid_from(&mut source);\n            }\n        },\n        {\n            if self.bytes_needed != 0 {\n                let bad_bytes = (self.bytes_seen + 1) as u8;\n                self.code_point = 0;\n                self.bytes_needed = 0;\n                self.bytes_seen = 0;\n                return (\n                    DecoderResult::Malformed(bad_bytes, 0),\n                    src_consumed,\n                    dest.written(),\n                );\n            }\n        },\n        {\n            if self.bytes_needed == 0 {\n                if b < 0x80u8 {\n                    destination_handle.write_ascii(b);\n                    continue;\n                }\n                if b < 0xC2u8 {\n                    return (\n                        DecoderResult::Malformed(1, 0),\n                        unread_handle.consumed(),\n                        destination_handle.written(),\n                    );\n                }\n                if b < 0xE0u8 {\n                    self.bytes_needed = 1;\n                    self.code_point = u32::from(b) & 0x1F;\n                    continue;\n                }\n                if b < 0xF0u8 {\n                    if b == 0xE0u8 {\n                        self.lower_boundary = 0xA0u8;\n                    } else if b == 0xEDu8 {\n                        self.upper_boundary = 0x9Fu8;\n                    }\n                    self.bytes_needed = 2;\n                    self.code_point = u32::from(b) & 0xF;\n                    continue;\n                }\n                if b < 0xF5u8 {\n                    if b == 0xF0u8 {\n                        self.lower_boundary = 0x90u8;\n                    } else if b == 0xF4u8 {\n                        self.upper_boundary = 0x8Fu8;\n                    }\n                    self.bytes_needed = 3;\n                    self.code_point = u32::from(b) & 0x7;\n                    continue;\n                }\n                return (\n                    DecoderResult::Malformed(1, 0),\n                    unread_handle.consumed(),\n                    destination_handle.written(),\n                );\n            }\n            // self.bytes_needed != 0\n            if !(b >= self.lower_boundary && b <= self.upper_boundary) {\n                let bad_bytes = (self.bytes_seen + 1) as u8;\n                self.code_point = 0;\n                self.bytes_needed = 0;\n                self.bytes_seen = 0;\n                self.lower_boundary = 0x80u8;\n                self.upper_boundary = 0xBFu8;\n                return (\n                    DecoderResult::Malformed(bad_bytes, 0),\n                    unread_handle.unread(),\n                    destination_handle.written(),\n                );\n            }\n            self.lower_boundary = 0x80u8;\n            self.upper_boundary = 0xBFu8;\n            self.code_point = (self.code_point << 6) | (u32::from(b) & 0x3F);\n            self.bytes_seen += 1;\n            if self.bytes_seen != self.bytes_needed {\n                continue;\n            }\n            if self.bytes_needed == 3 {\n                destination_handle.write_astral(self.code_point);\n            } else {\n                destination_handle.write_bmp_excl_ascii(self.code_point as u16);\n            }\n            self.code_point = 0;\n            self.bytes_needed = 0;\n            self.bytes_seen = 0;\n            continue;\n        },\n        self,\n        src_consumed,\n        dest,\n        source,\n        b,\n        destination_handle,\n        unread_handle,\n        check_space_astral\n    );\n}"],"utf_8::Utf8Encoder":["impl Utf8Encoder {\n    pub fn new(encoding: &'static Encoding) -> Encoder {\n        Encoder::new(encoding, VariantEncoder::Utf8(Utf8Encoder))\n    }\n\n    pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        u16_length.checked_mul(3)\n    }\n\n    pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        Some(byte_length)\n    }\n\n    pub fn encode_from_utf16_raw(\n        &mut self,\n        src: &[u16],\n        dst: &mut [u8],\n        _last: bool,\n    ) -> (EncoderResult, usize, usize) {\n        let (read, written) = convert_utf16_to_utf8_partial(src, dst);\n        (\n            if read == src.len() {\n                EncoderResult::InputEmpty\n            } else {\n                EncoderResult::OutputFull\n            },\n            read,\n            written,\n        )\n    }\n\n    pub fn encode_from_utf8_raw(\n        &mut self,\n        src: &str,\n        dst: &mut [u8],\n        _last: bool,\n    ) -> (EncoderResult, usize, usize) {\n        let bytes = src.as_bytes();\n        let mut to_write = bytes.len();\n        if to_write <= dst.len() {\n            (&mut dst[..to_write]).copy_from_slice(bytes);\n            return (EncoderResult::InputEmpty, to_write, to_write);\n        }\n        to_write = dst.len();\n        // Move back until we find a UTF-8 sequence boundary.\n        while (bytes[to_write] & 0xC0) == 0x80 {\n            to_write -= 1;\n        }\n        (&mut dst[..to_write]).copy_from_slice(&bytes[..to_write]);\n        (EncoderResult::OutputFull, to_write, to_write)\n    }\n}"],"variant::VariantDecoder":["impl VariantDecoder {\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        match *self {\n            VariantDecoder::SingleByte(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Utf8(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Gb18030(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Big5(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::EucJp(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Iso2022Jp(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::ShiftJis(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::EucKr(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Replacement(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::UserDefined(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Utf16(ref v) => v.max_utf16_buffer_length(byte_length),\n        }\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        match *self {\n            VariantDecoder::SingleByte(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Utf8(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Gb18030(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Big5(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::EucJp(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Iso2022Jp(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::ShiftJis(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::EucKr(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Replacement(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::UserDefined(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Utf16(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n        }\n    }\n\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        match *self {\n            VariantDecoder::SingleByte(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Utf8(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Gb18030(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Big5(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::EucJp(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Iso2022Jp(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::ShiftJis(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::EucKr(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Replacement(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::UserDefined(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Utf16(ref v) => v.max_utf8_buffer_length(byte_length),\n        }\n    }\n\n    pub fn decode_to_utf16_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u16],\n        last: bool,\n    ) -> (DecoderResult, usize, usize) {\n        match *self {\n            VariantDecoder::SingleByte(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Utf8(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Gb18030(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Big5(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::EucJp(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Iso2022Jp(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::ShiftJis(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::EucKr(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Replacement(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::UserDefined(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Utf16(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n        }\n    }\n\n    pub fn decode_to_utf8_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u8],\n        last: bool,\n    ) -> (DecoderResult, usize, usize) {\n        match *self {\n            VariantDecoder::SingleByte(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Utf8(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Gb18030(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Big5(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::EucJp(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Iso2022Jp(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::ShiftJis(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::EucKr(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Replacement(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::UserDefined(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Utf16(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n        }\n    }\n\n    pub fn latin1_byte_compatible_up_to(&self, buffer: &[u8]) -> Option<usize> {\n        match *self {\n            VariantDecoder::SingleByte(ref v) => {\n                return Some(v.latin1_byte_compatible_up_to(buffer));\n            }\n            VariantDecoder::Utf8(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::Gb18030(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::Big5(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::EucJp(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::Iso2022Jp(ref v) => {\n                if v.in_neutral_state() {\n                    return Some(Encoding::iso_2022_jp_ascii_valid_up_to(buffer));\n                }\n                return None;\n            }\n            VariantDecoder::ShiftJis(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::EucKr(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::UserDefined(_) => {}\n            VariantDecoder::Replacement(_) | VariantDecoder::Utf16(_) => {\n                return None;\n            }\n        };\n        Some(Encoding::ascii_valid_up_to(buffer))\n    }\n}"],"variant::VariantEncoder":["impl VariantEncoder {\n    pub fn has_pending_state(&self) -> bool {\n        match *self {\n            VariantEncoder::Iso2022Jp(ref v) => v.has_pending_state(),\n            _ => false,\n        }\n    }\n    pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        match *self {\n            VariantEncoder::SingleByte(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::Utf8(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::Gb18030(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::Big5(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::EucJp(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::Iso2022Jp(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::ShiftJis(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::EucKr(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::UserDefined(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n        }\n    }\n\n    pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        match *self {\n            VariantEncoder::SingleByte(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::Utf8(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::Gb18030(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::Big5(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::EucJp(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::Iso2022Jp(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::ShiftJis(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::EucKr(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::UserDefined(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n        }\n    }\n\n    pub fn encode_from_utf16_raw(\n        &mut self,\n        src: &[u16],\n        dst: &mut [u8],\n        last: bool,\n    ) -> (EncoderResult, usize, usize) {\n        match *self {\n            VariantEncoder::SingleByte(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::Utf8(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::Gb18030(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::Big5(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::EucJp(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::Iso2022Jp(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::ShiftJis(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::EucKr(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::UserDefined(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n        }\n    }\n\n    pub fn encode_from_utf8_raw(\n        &mut self,\n        src: &str,\n        dst: &mut [u8],\n        last: bool,\n    ) -> (EncoderResult, usize, usize) {\n        match *self {\n            VariantEncoder::SingleByte(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::Utf8(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::Gb18030(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::Big5(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::EucJp(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::Iso2022Jp(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::ShiftJis(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::EucKr(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::UserDefined(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n        }\n    }\n}"],"variant::VariantEncoding":["impl VariantEncoding {\n    pub fn new_variant_decoder(&self) -> VariantDecoder {\n        match *self {\n            VariantEncoding::SingleByte(table, _, _, _) => SingleByteDecoder::new(table),\n            VariantEncoding::Utf8 => Utf8Decoder::new(),\n            VariantEncoding::Gbk | VariantEncoding::Gb18030 => Gb18030Decoder::new(),\n            VariantEncoding::Big5 => Big5Decoder::new(),\n            VariantEncoding::EucJp => EucJpDecoder::new(),\n            VariantEncoding::Iso2022Jp => Iso2022JpDecoder::new(),\n            VariantEncoding::ShiftJis => ShiftJisDecoder::new(),\n            VariantEncoding::EucKr => EucKrDecoder::new(),\n            VariantEncoding::Replacement => ReplacementDecoder::new(),\n            VariantEncoding::UserDefined => UserDefinedDecoder::new(),\n            VariantEncoding::Utf16Be => Utf16Decoder::new(true),\n            VariantEncoding::Utf16Le => Utf16Decoder::new(false),\n        }\n    }\n\n    pub fn new_encoder(&self, encoding: &'static Encoding) -> Encoder {\n        match *self {\n            VariantEncoding::SingleByte(table, run_bmp_offset, run_byte_offset, run_length) => {\n                SingleByteEncoder::new(encoding, table, run_bmp_offset, run_byte_offset, run_length)\n            }\n            VariantEncoding::Utf8 => Utf8Encoder::new(encoding),\n            VariantEncoding::Gbk => Gb18030Encoder::new(encoding, false),\n            VariantEncoding::Gb18030 => Gb18030Encoder::new(encoding, true),\n            VariantEncoding::Big5 => Big5Encoder::new(encoding),\n            VariantEncoding::EucJp => EucJpEncoder::new(encoding),\n            VariantEncoding::Iso2022Jp => Iso2022JpEncoder::new(encoding),\n            VariantEncoding::ShiftJis => ShiftJisEncoder::new(encoding),\n            VariantEncoding::EucKr => EucKrEncoder::new(encoding),\n            VariantEncoding::UserDefined => UserDefinedEncoder::new(encoding),\n            VariantEncoding::Utf16Be | VariantEncoding::Replacement | VariantEncoding::Utf16Le => {\n                unreachable!()\n            }\n        }\n    }\n\n    pub fn is_single_byte(&self) -> bool {\n        match *self {\n            VariantEncoding::SingleByte(_, _, _, _) | VariantEncoding::UserDefined => true,\n            _ => false,\n        }\n    }\n}"],"x_user_defined::UserDefinedDecoder":["impl UserDefinedDecoder {\n    pub fn new() -> VariantDecoder {\n        VariantDecoder::UserDefined(UserDefinedDecoder)\n    }\n\n    pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        Some(byte_length)\n    }\n\n    pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_mul(3)\n    }\n\n    pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize> {\n        byte_length.checked_mul(3)\n    }\n\n    decoder_function!(\n        {},\n        {},\n        {},\n        {\n            if b < 0x80 {\n                // ASCII run not optimized, because binary data expected\n                destination_handle.write_ascii(b);\n                continue;\n            }\n            destination_handle.write_upper_bmp(u16::from(b) + 0xF700);\n            continue;\n        },\n        self,\n        src_consumed,\n        dest,\n        source,\n        b,\n        destination_handle,\n        _unread_handle,\n        check_space_bmp,\n        decode_to_utf8_raw,\n        u8,\n        Utf8Destination\n    );\n\n    #[cfg(not(feature = \"simd-accel\"))]\n    pub fn decode_to_utf16_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u16],\n        _last: bool,\n    ) -> (DecoderResult, usize, usize) {\n        let (pending, length) = if dst.len() < src.len() {\n            (DecoderResult::OutputFull, dst.len())\n        } else {\n            (DecoderResult::InputEmpty, src.len())\n        };\n        let src_trim = &src[..length];\n        let dst_trim = &mut dst[..length];\n        src_trim\n            .iter()\n            .zip(dst_trim.iter_mut())\n            .for_each(|(from, to)| {\n                *to = {\n                    let unit = *from;\n                    if unit < 0x80 {\n                        u16::from(unit)\n                    } else {\n                        u16::from(unit) + 0xF700\n                    }\n                }\n            });\n        (pending, length, length)\n    }\n\n    #[cfg(feature = \"simd-accel\")]\n    pub fn decode_to_utf16_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u16],\n        _last: bool,\n    ) -> (DecoderResult, usize, usize) {\n        let (pending, length) = if dst.len() < src.len() {\n            (DecoderResult::OutputFull, dst.len())\n        } else {\n            (DecoderResult::InputEmpty, src.len())\n        };\n        // Not bothering with alignment\n        let tail_start = length & !0xF;\n        let simd_iterations = length >> 4;\n        let src_ptr = src.as_ptr();\n        let dst_ptr = dst.as_mut_ptr();\n        for i in 0..simd_iterations {\n            let input = unsafe { load16_unaligned(src_ptr.add(i * 16)) };\n            let (first, second) = simd_unpack(input);\n            unsafe {\n                store8_unaligned(dst_ptr.add(i * 16), shift_upper(first));\n                store8_unaligned(dst_ptr.add((i * 16) + 8), shift_upper(second));\n            }\n        }\n        let src_tail = &src[tail_start..length];\n        let dst_tail = &mut dst[tail_start..length];\n        src_tail\n            .iter()\n            .zip(dst_tail.iter_mut())\n            .for_each(|(from, to)| {\n                *to = {\n                    let unit = *from;\n                    if unit < 0x80 {\n                        u16::from(unit)\n                    } else {\n                        u16::from(unit) + 0xF700\n                    }\n                }\n            });\n        (pending, length, length)\n    }\n}"],"x_user_defined::UserDefinedEncoder":["impl UserDefinedEncoder {\n    pub fn new(encoding: &'static Encoding) -> Encoder {\n        Encoder::new(encoding, VariantEncoder::UserDefined(UserDefinedEncoder))\n    }\n\n    pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize> {\n        Some(u16_length)\n    }\n\n    pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize> {\n        Some(byte_length)\n    }\n\n    encoder_functions!(\n        {},\n        {\n            if c <= '\\u{7F}' {\n                // TODO optimize ASCII run\n                destination_handle.write_one(c as u8);\n                continue;\n            }\n            if c < '\\u{F780}' || c > '\\u{F7FF}' {\n                return (\n                    EncoderResult::Unmappable(c),\n                    unread_handle.consumed(),\n                    destination_handle.written(),\n                );\n            }\n            destination_handle.write_one((u32::from(c) - 0xF700) as u8);\n            continue;\n        },\n        self,\n        src_consumed,\n        source,\n        dest,\n        c,\n        destination_handle,\n        unread_handle,\n        check_space_one\n    );\n}"]},"single_path_import":{},"srcs":{"<Encoding as std::cmp::PartialEq>::eq":["#[inline]\nfn eq(&self, other: &Encoding) -> bool{\n        (self as *const Encoding) == (other as *const Encoding)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Encoding as std::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        write!(f, \"Encoding {{ {} }}\", self.name)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Encoding as std::hash::Hash>::hash":["#[inline]\nfn hash<H: Hasher>(&self, state: &mut H){\n        (self as *const Encoding).hash(state);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"BomHandling":["/// Communicate the BOM handling mode.\nenum BomHandling {\n    /// Don't handle the BOM\n    Off,\n    /// Sniff for UTF-8, UTF-16BE or UTF-16LE BOM\n    Sniff,\n    /// Remove the BOM only if it's the BOM for this encoding\n    Remove,\n}","Real(LocalPath(\"src/lib.rs\"))"],"CoderResult":["/// Result of a (potentially partial) decode or encode operation with\n/// replacement.\n#[must_use]\npub enum CoderResult {\n    /// The input was exhausted.\n    ///\n    /// If this result was returned from a call where `last` was `true`, the\n    /// conversion process has completed. Otherwise, the caller should call a\n    /// decode or encode method again with more input.\n    InputEmpty,\n\n    /// The converter cannot produce another unit of output, because the output\n    /// buffer does not have enough space left.\n    ///\n    /// The caller must provide more output space upon the next call and re-push\n    /// the remaining input to the converter.\n    OutputFull,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Decoder":["/// A converter that decodes a byte stream into Unicode according to a\n/// character encoding in a streaming (incremental) manner.\n///\n/// The various `decode_*` methods take an input buffer (`src`) and an output\n/// buffer `dst` both of which are caller-allocated. There are variants for\n/// both UTF-8 and UTF-16 output buffers.\n///\n/// A `decode_*` method decodes bytes from `src` into Unicode characters stored\n/// into `dst` until one of the following three things happens:\n///\n/// 1. A malformed byte sequence is encountered (`*_without_replacement`\n///    variants only).\n///\n/// 2. The output buffer has been filled so near capacity that the decoder\n///    cannot be sure that processing an additional byte of input wouldn't\n///    cause so much output that the output buffer would overflow.\n///\n/// 3. All the input bytes have been processed.\n///\n/// The `decode_*` method then returns tuple of a status indicating which one\n/// of the three reasons to return happened, how many input bytes were read,\n/// how many output code units (`u8` when decoding into UTF-8 and `u16`\n/// when decoding to UTF-16) were written (except when decoding into `String`,\n/// whose length change indicates this), and in the case of the\n/// variants performing replacement, a boolean indicating whether an error was\n/// replaced with the REPLACEMENT CHARACTER during the call.\n///\n/// The number of bytes \"written\" is what's logically written. Garbage may be\n/// written in the output buffer beyond the point logically written to.\n/// Therefore, if you wish to decode into an `&mut str`, you should use the\n/// methods that take an `&mut str` argument instead of the ones that take an\n/// `&mut [u8]` argument. The former take care of overwriting the trailing\n/// garbage to ensure the UTF-8 validity of the `&mut str` as a whole, but the\n/// latter don't.\n///\n/// In the case of the `*_without_replacement` variants, the status is a\n/// [`DecoderResult`][1] enumeration (possibilities `Malformed`, `OutputFull` and\n/// `InputEmpty` corresponding to the three cases listed above).\n///\n/// In the case of methods whose name does not end with\n/// `*_without_replacement`, malformed sequences are automatically replaced\n/// with the REPLACEMENT CHARACTER and errors do not cause the methods to\n/// return early.\n///\n/// When decoding to UTF-8, the output buffer must have at least 4 bytes of\n/// space. When decoding to UTF-16, the output buffer must have at least two\n/// UTF-16 code units (`u16`) of space.\n///\n/// When decoding to UTF-8 without replacement, the methods are guaranteed\n/// not to return indicating that more output space is needed if the length\n/// of the output buffer is at least the length returned by\n/// [`max_utf8_buffer_length_without_replacement()`][2]. When decoding to UTF-8\n/// with replacement, the length of the output buffer that guarantees the\n/// methods not to return indicating that more output space is needed is given\n/// by [`max_utf8_buffer_length()`][3]. When decoding to UTF-16 with\n/// or without replacement, the length of the output buffer that guarantees\n/// the methods not to return indicating that more output space is needed is\n/// given by [`max_utf16_buffer_length()`][4].\n///\n/// The output written into `dst` is guaranteed to be valid UTF-8 or UTF-16,\n/// and the output after each `decode_*` call is guaranteed to consist of\n/// complete characters. (I.e. the code unit sequence for the last character is\n/// guaranteed not to be split across output buffers.)\n///\n/// The boolean argument `last` indicates that the end of the stream is reached\n/// when all the bytes in `src` have been consumed.\n///\n/// A `Decoder` object can be used to incrementally decode a byte stream.\n///\n/// During the processing of a single stream, the caller must call `decode_*`\n/// zero or more times with `last` set to `false` and then call `decode_*` at\n/// least once with `last` set to `true`. If `decode_*` returns `InputEmpty`,\n/// the processing of the stream has ended. Otherwise, the caller must call\n/// `decode_*` again with `last` set to `true` (or treat a `Malformed` result as\n///  a fatal error).\n///\n/// Once the stream has ended, the `Decoder` object must not be used anymore.\n/// That is, you need to create another one to process another stream.\n///\n/// When the decoder returns `OutputFull` or the decoder returns `Malformed` and\n/// the caller does not wish to treat it as a fatal error, the input buffer\n/// `src` may not have been completely consumed. In that case, the caller must\n/// pass the unconsumed contents of `src` to `decode_*` again upon the next\n/// call.\n///\n/// [1]: enum.DecoderResult.html\n/// [2]: #method.max_utf8_buffer_length_without_replacement\n/// [3]: #method.max_utf8_buffer_length\n/// [4]: #method.max_utf16_buffer_length\n///\n/// # Infinite loops\n///\n/// When converting with a fixed-size output buffer whose size is too small to\n/// accommodate one character or (when applicable) one numeric character\n/// reference of output, an infinite loop ensues. When converting with a\n/// fixed-size output buffer, it generally makes sense to make the buffer\n/// fairly large (e.g. couple of kilobytes).\npub struct Decoder {\n    encoding: &'static Encoding,\n    variant: VariantDecoder,\n    life_cycle: DecoderLifeCycle,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::decode_to_str":["/// Incrementally decode a byte stream into UTF-8 with malformed sequences\n/// replaced with the REPLACEMENT CHARACTER with type system signaling\n/// of UTF-8 validity.\n///\n/// This methods calls `decode_to_utf8` and then zeroes\n/// out up to three bytes that aren't logically part of the write in order\n/// to retain the UTF-8 validity even for the unwritten part of the buffer.\n///\n/// See the documentation of the struct for documentation for `decode_*`\n/// methods collectively.\n///\n/// Available to Rust only.\npub fn decode_to_str(\n        &mut self,\n        src: &[u8],\n        dst: &mut str,\n        last: bool,\n    ) -> (CoderResult, usize, usize, bool){\n        let bytes: &mut [u8] = unsafe { dst.as_bytes_mut() };\n        let (result, read, written, replaced) = self.decode_to_utf8(src, bytes, last);\n        let len = bytes.len();\n        let mut trail = written;\n        // Non-UTF-8 ASCII-compatible decoders may write up to `MAX_STRIDE_SIZE`\n        // bytes of trailing garbage. No need to optimize non-ASCII-compatible\n        // encodings to avoid overwriting here.\n        if self.encoding != UTF_8 {\n            let max = std::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);\n            while trail < max {\n                bytes[trail] = 0;\n                trail += 1;\n            }\n        }\n        while trail < len && ((bytes[trail] & 0xC0) == 0x80) {\n            bytes[trail] = 0;\n            trail += 1;\n        }\n        (result, read, written, replaced)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::decode_to_str_without_replacement":["/// Incrementally decode a byte stream into UTF-8 with type system signaling\n/// of UTF-8 validity.\n///\n/// This methods calls `decode_to_utf8` and then zeroes out up to three\n/// bytes that aren't logically part of the write in order to retain the\n/// UTF-8 validity even for the unwritten part of the buffer.\n///\n/// See the documentation of the struct for documentation for `decode_*`\n/// methods collectively.\n///\n/// Available to Rust only.\npub fn decode_to_str_without_replacement(\n        &mut self,\n        src: &[u8],\n        dst: &mut str,\n        last: bool,\n    ) -> (DecoderResult, usize, usize){\n        let bytes: &mut [u8] = unsafe { dst.as_bytes_mut() };\n        let (result, read, written) = self.decode_to_utf8_without_replacement(src, bytes, last);\n        let len = bytes.len();\n        let mut trail = written;\n        // Non-UTF-8 ASCII-compatible decoders may write up to `MAX_STRIDE_SIZE`\n        // bytes of trailing garbage. No need to optimize non-ASCII-compatible\n        // encodings to avoid overwriting here.\n        if self.encoding != UTF_8 {\n            let max = std::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);\n            while trail < max {\n                bytes[trail] = 0;\n                trail += 1;\n            }\n        }\n        while trail < len && ((bytes[trail] & 0xC0) == 0x80) {\n            bytes[trail] = 0;\n            trail += 1;\n        }\n        (result, read, written)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::decode_to_string":["/// Incrementally decode a byte stream into UTF-8 with malformed sequences\n/// replaced with the REPLACEMENT CHARACTER using a `String` receiver.\n///\n/// Like the others, this method follows the logic that the output buffer is\n/// caller-allocated. This method treats the capacity of the `String` as\n/// the output limit. That is, this method guarantees not to cause a\n/// reallocation of the backing buffer of `String`.\n///\n/// The return value is a tuple that contains the `DecoderResult`, the\n/// number of bytes read and a boolean indicating whether replacements\n/// were done. The number of bytes written is signaled via the length of\n/// the `String` changing.\n///\n/// See the documentation of the struct for documentation for `decode_*`\n/// methods collectively.\n///\n/// Available to Rust only.\npub fn decode_to_string(\n        &mut self,\n        src: &[u8],\n        dst: &mut String,\n        last: bool,\n    ) -> (CoderResult, usize, bool){\n        unsafe {\n            let vec = dst.as_mut_vec();\n            let old_len = vec.len();\n            let capacity = vec.capacity();\n            vec.set_len(capacity);\n            let (result, read, written, replaced) =\n                self.decode_to_utf8(src, &mut vec[old_len..], last);\n            vec.set_len(old_len + written);\n            (result, read, replaced)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::decode_to_string_without_replacement":["/// Incrementally decode a byte stream into UTF-8 using a `String` receiver.\n///\n/// Like the others, this method follows the logic that the output buffer is\n/// caller-allocated. This method treats the capacity of the `String` as\n/// the output limit. That is, this method guarantees not to cause a\n/// reallocation of the backing buffer of `String`.\n///\n/// The return value is a pair that contains the `DecoderResult` and the\n/// number of bytes read. The number of bytes written is signaled via\n/// the length of the `String` changing.\n///\n/// See the documentation of the struct for documentation for `decode_*`\n/// methods collectively.\n///\n/// Available to Rust only.\npub fn decode_to_string_without_replacement(\n        &mut self,\n        src: &[u8],\n        dst: &mut String,\n        last: bool,\n    ) -> (DecoderResult, usize){\n        unsafe {\n            let vec = dst.as_mut_vec();\n            let old_len = vec.len();\n            let capacity = vec.capacity();\n            vec.set_len(capacity);\n            let (result, read, written) =\n                self.decode_to_utf8_without_replacement(src, &mut vec[old_len..], last);\n            vec.set_len(old_len + written);\n            (result, read)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::decode_to_utf16":["/// Incrementally decode a byte stream into UTF-16 with malformed sequences\n/// replaced with the REPLACEMENT CHARACTER.\n///\n/// See the documentation of the struct for documentation for `decode_*`\n/// methods collectively.\n///\n/// Available via the C wrapper.\npub fn decode_to_utf16(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u16],\n        last: bool,\n    ) -> (CoderResult, usize, usize, bool){\n        let mut had_errors = false;\n        let mut total_read = 0usize;\n        let mut total_written = 0usize;\n        loop {\n            let (result, read, written) = self.decode_to_utf16_without_replacement(\n                &src[total_read..],\n                &mut dst[total_written..],\n                last,\n            );\n            total_read += read;\n            total_written += written;\n            match result {\n                DecoderResult::InputEmpty => {\n                    return (\n                        CoderResult::InputEmpty,\n                        total_read,\n                        total_written,\n                        had_errors,\n                    );\n                }\n                DecoderResult::OutputFull => {\n                    return (\n                        CoderResult::OutputFull,\n                        total_read,\n                        total_written,\n                        had_errors,\n                    );\n                }\n                DecoderResult::Malformed(_, _) => {\n                    had_errors = true;\n                    // There should always be space for the U+FFFD, because\n                    // otherwise we'd have gotten OutputFull already.\n                    dst[total_written] = 0xFFFD;\n                    total_written += 1;\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::decode_to_utf16_after_one_potential_bom_byte":["fn $decode_to_utf_after_one_potential_bom_byte(&mut self,\n                                                   src: &[u8],\n                                                   dst: &mut [$code_unit],\n                                                   last: bool,\n                                                   offset: usize,\n                                                   first_byte: u8)\n                                                   -> (DecoderResult, usize, usize){\n        self.life_cycle = DecoderLifeCycle::Converting;\n        if offset == 0usize {\n            // First byte was seen previously.\n            let first = [first_byte];\n            let mut out_read = 0usize;\n            let (mut first_result, _, mut first_written) =\n                self.variant\n                    .$decode_to_utf_raw(&first[..], dst, false);\n            match first_result {\n                DecoderResult::InputEmpty => {\n                    let (result, read, written) =\n                        self.$decode_to_utf_checking_end(src, &mut dst[first_written..], last);\n                    first_result = result;\n                    out_read = read; // Overwrite, don't add!\n                    first_written += written;\n                }\n                DecoderResult::Malformed(_, _) => {\n                    // Wasn't read from `src`!, leave out_read to 0\n                }\n                DecoderResult::OutputFull => {\n                    panic!(\"Output buffer must have been too small.\");\n                }\n            }\n            return (first_result, out_read, first_written);\n        }\n        debug_assert_eq!(offset, 1usize);\n        // The first byte is in `src`, so no need to push it separately.\n        self.$decode_to_utf_checking_end(src, dst, last)\n    }","Real(LocalPath(\"src/macros.rs\"))"],"Decoder::decode_to_utf16_after_two_potential_bom_bytes":["fn $decode_to_utf_after_two_potential_bom_bytes(&mut self,\n                                                    src: &[u8],\n                                                    dst: &mut [$code_unit],\n                                                    last: bool,\n                                                    offset: usize)\n                                                    -> (DecoderResult, usize, usize){\n        self.life_cycle = DecoderLifeCycle::Converting;\n        if offset == 0usize {\n            // The first two bytes are not in the current buffer..\n            let ef_bb = [0xEFu8, 0xBBu8];\n            let (mut first_result, mut first_read, mut first_written) =\n                self.variant\n                    .$decode_to_utf_raw(&ef_bb[..], dst, false);\n            match first_result {\n                DecoderResult::InputEmpty => {\n                    let (result, read, written) =\n                        self.$decode_to_utf_checking_end(src, &mut dst[first_written..], last);\n                    first_result = result;\n                    first_read = read; // Overwrite, don't add!\n                    first_written += written;\n                }\n                DecoderResult::Malformed(_, _) => {\n                    if first_read == 1usize {\n                        // The first byte was malformed. We need to handle\n                        // the second one, which isn't in `src`, later.\n                        self.life_cycle = DecoderLifeCycle::ConvertingWithPendingBB;\n                    }\n                    first_read = 0usize; // Wasn't read from `src`!\n                }\n                DecoderResult::OutputFull => {\n                    panic!(\"Output buffer must have been too small.\");\n                }\n            }\n            return (first_result, first_read, first_written);\n        }\n        if offset == 1usize {\n            // The first byte isn't in the current buffer but the second one\n            // is.\n            return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                    dst,\n                                                                    last,\n                                                                    0usize,\n                                                                    0xEFu8);\n\n        }\n        debug_assert_eq!(offset, 2usize);\n        // The first two bytes are in `src`, so no need to push them separately.\n        self.$decode_to_utf_checking_end(src, dst, last)\n    }","Real(LocalPath(\"src/macros.rs\"))"],"Decoder::decode_to_utf16_checking_end":["/// Calls through to the delegate and adjusts life cycle iff `last` is\n/// `true` and result is `DecoderResult::InputEmpty`.\nfn $decode_to_utf_checking_end(&mut self,\n                                   src: &[u8],\n                                   dst: &mut [$code_unit],\n                                   last: bool)\n                                   -> (DecoderResult, usize, usize){\n        debug_assert_eq!(self.life_cycle, DecoderLifeCycle::Converting);\n        let (result, read, written) = self.variant\n                                          .$decode_to_utf_raw(src, dst, last);\n        if last {\n            if let DecoderResult::InputEmpty = result {\n                self.life_cycle = DecoderLifeCycle::Finished;\n            }\n        }\n        (result, read, written)\n    }","Real(LocalPath(\"src/macros.rs\"))"],"Decoder::decode_to_utf16_checking_end_with_offset":["/// Calls `$decode_to_utf_checking_end` with `offset` bytes omitted from\n/// the start of `src` but adjusting the return values to show those bytes\n/// as having been consumed.\nfn $decode_to_utf_checking_end_with_offset(&mut self,\n                                               src: &[u8],\n                                               dst: &mut [$code_unit],\n                                               last: bool,\n                                               offset: usize)\n                                               -> (DecoderResult, usize, usize){\n        debug_assert_eq!(self.life_cycle, DecoderLifeCycle::Converting);\n        let (result, read, written) = self.$decode_to_utf_checking_end(&src[offset..], dst, last);\n        (result, read + offset, written)\n    }","Real(LocalPath(\"src/macros.rs\"))"],"Decoder::decode_to_utf16_without_replacement":["#[$meta]\n#[$meta]\n#[$meta]\n#[$meta]\n#[$meta]\n#[$meta]\n#[$meta]\n#[$meta]\npub fn $decode_to_utf(&mut self,\n                           src: &[u8],\n                           dst: &mut [$code_unit],\n                           last: bool)\n                           -> (DecoderResult, usize, usize){\n        let mut offset = 0usize;\n        loop {\n            match self.life_cycle {\n                // The common case. (Post-sniffing.)\n                DecoderLifeCycle::Converting => {\n                    return self.$decode_to_utf_checking_end(src, dst, last);\n                }\n                // The rest is all BOM sniffing!\n                DecoderLifeCycle::AtStart => {\n                    debug_assert_eq!(offset, 0usize);\n                    if src.is_empty() {\n                        return (DecoderResult::InputEmpty, 0, 0);\n                    }\n                    match src[0] {\n                        0xEFu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf8First;\n                            offset += 1;\n                            continue;\n                        }\n                        0xFEu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf16BeFirst;\n                            offset += 1;\n                            continue;\n                        }\n                        0xFFu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf16LeFirst;\n                            offset += 1;\n                            continue;\n                        }\n                        _ => {\n                            self.life_cycle = DecoderLifeCycle::Converting;\n                            continue;\n                        }\n                    }\n                }\n                DecoderLifeCycle::AtUtf8Start => {\n                    debug_assert_eq!(offset, 0usize);\n                    if src.is_empty() {\n                        return (DecoderResult::InputEmpty, 0, 0);\n                    }\n                    match src[0] {\n                        0xEFu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf8First;\n                            offset += 1;\n                            continue;\n                        }\n                        _ => {\n                            self.life_cycle = DecoderLifeCycle::Converting;\n                            continue;\n                        }\n                    }\n                }\n                DecoderLifeCycle::AtUtf16BeStart => {\n                    debug_assert_eq!(offset, 0usize);\n                    if src.is_empty() {\n                        return (DecoderResult::InputEmpty, 0, 0);\n                    }\n                    match src[0] {\n                        0xFEu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf16BeFirst;\n                            offset += 1;\n                            continue;\n                        }\n                        _ => {\n                            self.life_cycle = DecoderLifeCycle::Converting;\n                            continue;\n                        }\n                    }\n                }\n                DecoderLifeCycle::AtUtf16LeStart => {\n                    debug_assert_eq!(offset, 0usize);\n                    if src.is_empty() {\n                        return (DecoderResult::InputEmpty, 0, 0);\n                    }\n                    match src[0] {\n                        0xFFu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf16LeFirst;\n                            offset += 1;\n                            continue;\n                        }\n                        _ => {\n                            self.life_cycle = DecoderLifeCycle::Converting;\n                            continue;\n                        }\n                    }\n                }\n                DecoderLifeCycle::SeenUtf8First => {\n                    if offset >= src.len() {\n                        if last {\n                            return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                                    dst,\n                                                                                    last,\n                                                                                    offset,\n                                                                                    0xEFu8);\n                        }\n                        return (DecoderResult::InputEmpty, offset, 0);\n                    }\n                    if src[offset] == 0xBBu8 {\n                        self.life_cycle = DecoderLifeCycle::SeenUtf8Second;\n                        offset += 1;\n                        continue;\n                    }\n                    return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset,\n                                                                            0xEFu8);\n                }\n                DecoderLifeCycle::SeenUtf8Second => {\n                    if offset >= src.len() {\n                        if last {\n                            return self.$decode_to_utf_after_two_potential_bom_bytes(src,\n                                                                                     dst,\n                                                                                     last,\n                                                                                     offset);\n                        }\n                        return (DecoderResult::InputEmpty, offset, 0);\n                    }\n                    if src[offset] == 0xBFu8 {\n                        self.life_cycle = DecoderLifeCycle::Converting;\n                        offset += 1;\n                        if self.encoding != UTF_8 {\n                            self.encoding = UTF_8;\n                            self.variant = UTF_8.new_variant_decoder();\n                        }\n                        return self.$decode_to_utf_checking_end_with_offset(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset);\n                    }\n                    return self.$decode_to_utf_after_two_potential_bom_bytes(src,\n                                                                             dst,\n                                                                             last,\n                                                                             offset);\n                }\n                DecoderLifeCycle::SeenUtf16BeFirst => {\n                    if offset >= src.len() {\n                        if last {\n                            return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                                    dst,\n                                                                                    last,\n                                                                                    offset,\n                                                                                    0xFEu8);\n                        }\n                        return (DecoderResult::InputEmpty, offset, 0);\n                    }\n                    if src[offset] == 0xFFu8 {\n                        self.life_cycle = DecoderLifeCycle::Converting;\n                        offset += 1;\n                        if self.encoding != UTF_16BE {\n                            self.encoding = UTF_16BE;\n                            self.variant = UTF_16BE.new_variant_decoder();\n                        }\n                        return self.$decode_to_utf_checking_end_with_offset(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset);\n                    }\n                    return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset,\n                                                                            0xFEu8);\n                }\n                DecoderLifeCycle::SeenUtf16LeFirst => {\n                    if offset >= src.len() {\n                        if last {\n                            return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                                    dst,\n                                                                                    last,\n                                                                                    offset,\n                                                                                    0xFFu8);\n                        }\n                        return (DecoderResult::InputEmpty, offset, 0);\n                    }\n                    if src[offset] == 0xFEu8 {\n                        self.life_cycle = DecoderLifeCycle::Converting;\n                        offset += 1;\n                        if self.encoding != UTF_16LE {\n                            self.encoding = UTF_16LE;\n                            self.variant = UTF_16LE.new_variant_decoder();\n                        }\n                        return self.$decode_to_utf_checking_end_with_offset(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset);\n                    }\n                    return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset,\n                                                                            0xFFu8);\n                }\n                DecoderLifeCycle::ConvertingWithPendingBB => {\n                    debug_assert_eq!(offset, 0usize);\n                    return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                            dst,\n                                                                            last,\n                                                                            0usize,\n                                                                            0xBBu8);\n                }\n                DecoderLifeCycle::Finished => panic!(\"Must not use a decoder that has finished.\"),\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"Decoder::decode_to_utf8":["/// Incrementally decode a byte stream into UTF-8 with malformed sequences\n/// replaced with the REPLACEMENT CHARACTER.\n///\n/// See the documentation of the struct for documentation for `decode_*`\n/// methods collectively.\n///\n/// Available via the C wrapper.\npub fn decode_to_utf8(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u8],\n        last: bool,\n    ) -> (CoderResult, usize, usize, bool){\n        let mut had_errors = false;\n        let mut total_read = 0usize;\n        let mut total_written = 0usize;\n        loop {\n            let (result, read, written) = self.decode_to_utf8_without_replacement(\n                &src[total_read..],\n                &mut dst[total_written..],\n                last,\n            );\n            total_read += read;\n            total_written += written;\n            match result {\n                DecoderResult::InputEmpty => {\n                    return (\n                        CoderResult::InputEmpty,\n                        total_read,\n                        total_written,\n                        had_errors,\n                    );\n                }\n                DecoderResult::OutputFull => {\n                    return (\n                        CoderResult::OutputFull,\n                        total_read,\n                        total_written,\n                        had_errors,\n                    );\n                }\n                DecoderResult::Malformed(_, _) => {\n                    had_errors = true;\n                    // There should always be space for the U+FFFD, because\n                    // otherwise we'd have gotten OutputFull already.\n                    // XXX: is the above comment actually true for UTF-8 itself?\n                    // TODO: Consider having fewer bound checks here.\n                    dst[total_written] = 0xEFu8;\n                    total_written += 1;\n                    dst[total_written] = 0xBFu8;\n                    total_written += 1;\n                    dst[total_written] = 0xBDu8;\n                    total_written += 1;\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::decode_to_utf8_after_one_potential_bom_byte":["fn $decode_to_utf_after_one_potential_bom_byte(&mut self,\n                                                   src: &[u8],\n                                                   dst: &mut [$code_unit],\n                                                   last: bool,\n                                                   offset: usize,\n                                                   first_byte: u8)\n                                                   -> (DecoderResult, usize, usize){\n        self.life_cycle = DecoderLifeCycle::Converting;\n        if offset == 0usize {\n            // First byte was seen previously.\n            let first = [first_byte];\n            let mut out_read = 0usize;\n            let (mut first_result, _, mut first_written) =\n                self.variant\n                    .$decode_to_utf_raw(&first[..], dst, false);\n            match first_result {\n                DecoderResult::InputEmpty => {\n                    let (result, read, written) =\n                        self.$decode_to_utf_checking_end(src, &mut dst[first_written..], last);\n                    first_result = result;\n                    out_read = read; // Overwrite, don't add!\n                    first_written += written;\n                }\n                DecoderResult::Malformed(_, _) => {\n                    // Wasn't read from `src`!, leave out_read to 0\n                }\n                DecoderResult::OutputFull => {\n                    panic!(\"Output buffer must have been too small.\");\n                }\n            }\n            return (first_result, out_read, first_written);\n        }\n        debug_assert_eq!(offset, 1usize);\n        // The first byte is in `src`, so no need to push it separately.\n        self.$decode_to_utf_checking_end(src, dst, last)\n    }","Real(LocalPath(\"src/macros.rs\"))"],"Decoder::decode_to_utf8_after_two_potential_bom_bytes":["fn $decode_to_utf_after_two_potential_bom_bytes(&mut self,\n                                                    src: &[u8],\n                                                    dst: &mut [$code_unit],\n                                                    last: bool,\n                                                    offset: usize)\n                                                    -> (DecoderResult, usize, usize){\n        self.life_cycle = DecoderLifeCycle::Converting;\n        if offset == 0usize {\n            // The first two bytes are not in the current buffer..\n            let ef_bb = [0xEFu8, 0xBBu8];\n            let (mut first_result, mut first_read, mut first_written) =\n                self.variant\n                    .$decode_to_utf_raw(&ef_bb[..], dst, false);\n            match first_result {\n                DecoderResult::InputEmpty => {\n                    let (result, read, written) =\n                        self.$decode_to_utf_checking_end(src, &mut dst[first_written..], last);\n                    first_result = result;\n                    first_read = read; // Overwrite, don't add!\n                    first_written += written;\n                }\n                DecoderResult::Malformed(_, _) => {\n                    if first_read == 1usize {\n                        // The first byte was malformed. We need to handle\n                        // the second one, which isn't in `src`, later.\n                        self.life_cycle = DecoderLifeCycle::ConvertingWithPendingBB;\n                    }\n                    first_read = 0usize; // Wasn't read from `src`!\n                }\n                DecoderResult::OutputFull => {\n                    panic!(\"Output buffer must have been too small.\");\n                }\n            }\n            return (first_result, first_read, first_written);\n        }\n        if offset == 1usize {\n            // The first byte isn't in the current buffer but the second one\n            // is.\n            return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                    dst,\n                                                                    last,\n                                                                    0usize,\n                                                                    0xEFu8);\n\n        }\n        debug_assert_eq!(offset, 2usize);\n        // The first two bytes are in `src`, so no need to push them separately.\n        self.$decode_to_utf_checking_end(src, dst, last)\n    }","Real(LocalPath(\"src/macros.rs\"))"],"Decoder::decode_to_utf8_checking_end":["/// Calls through to the delegate and adjusts life cycle iff `last` is\n/// `true` and result is `DecoderResult::InputEmpty`.\nfn $decode_to_utf_checking_end(&mut self,\n                                   src: &[u8],\n                                   dst: &mut [$code_unit],\n                                   last: bool)\n                                   -> (DecoderResult, usize, usize){\n        debug_assert_eq!(self.life_cycle, DecoderLifeCycle::Converting);\n        let (result, read, written) = self.variant\n                                          .$decode_to_utf_raw(src, dst, last);\n        if last {\n            if let DecoderResult::InputEmpty = result {\n                self.life_cycle = DecoderLifeCycle::Finished;\n            }\n        }\n        (result, read, written)\n    }","Real(LocalPath(\"src/macros.rs\"))"],"Decoder::decode_to_utf8_checking_end_with_offset":["/// Calls `$decode_to_utf_checking_end` with `offset` bytes omitted from\n/// the start of `src` but adjusting the return values to show those bytes\n/// as having been consumed.\nfn $decode_to_utf_checking_end_with_offset(&mut self,\n                                               src: &[u8],\n                                               dst: &mut [$code_unit],\n                                               last: bool,\n                                               offset: usize)\n                                               -> (DecoderResult, usize, usize){\n        debug_assert_eq!(self.life_cycle, DecoderLifeCycle::Converting);\n        let (result, read, written) = self.$decode_to_utf_checking_end(&src[offset..], dst, last);\n        (result, read + offset, written)\n    }","Real(LocalPath(\"src/macros.rs\"))"],"Decoder::decode_to_utf8_without_replacement":["#[$meta]\n#[$meta]\n#[$meta]\n#[$meta]\n#[$meta]\n#[$meta]\n#[$meta]\n#[$meta]\npub fn $decode_to_utf(&mut self,\n                           src: &[u8],\n                           dst: &mut [$code_unit],\n                           last: bool)\n                           -> (DecoderResult, usize, usize){\n        let mut offset = 0usize;\n        loop {\n            match self.life_cycle {\n                // The common case. (Post-sniffing.)\n                DecoderLifeCycle::Converting => {\n                    return self.$decode_to_utf_checking_end(src, dst, last);\n                }\n                // The rest is all BOM sniffing!\n                DecoderLifeCycle::AtStart => {\n                    debug_assert_eq!(offset, 0usize);\n                    if src.is_empty() {\n                        return (DecoderResult::InputEmpty, 0, 0);\n                    }\n                    match src[0] {\n                        0xEFu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf8First;\n                            offset += 1;\n                            continue;\n                        }\n                        0xFEu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf16BeFirst;\n                            offset += 1;\n                            continue;\n                        }\n                        0xFFu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf16LeFirst;\n                            offset += 1;\n                            continue;\n                        }\n                        _ => {\n                            self.life_cycle = DecoderLifeCycle::Converting;\n                            continue;\n                        }\n                    }\n                }\n                DecoderLifeCycle::AtUtf8Start => {\n                    debug_assert_eq!(offset, 0usize);\n                    if src.is_empty() {\n                        return (DecoderResult::InputEmpty, 0, 0);\n                    }\n                    match src[0] {\n                        0xEFu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf8First;\n                            offset += 1;\n                            continue;\n                        }\n                        _ => {\n                            self.life_cycle = DecoderLifeCycle::Converting;\n                            continue;\n                        }\n                    }\n                }\n                DecoderLifeCycle::AtUtf16BeStart => {\n                    debug_assert_eq!(offset, 0usize);\n                    if src.is_empty() {\n                        return (DecoderResult::InputEmpty, 0, 0);\n                    }\n                    match src[0] {\n                        0xFEu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf16BeFirst;\n                            offset += 1;\n                            continue;\n                        }\n                        _ => {\n                            self.life_cycle = DecoderLifeCycle::Converting;\n                            continue;\n                        }\n                    }\n                }\n                DecoderLifeCycle::AtUtf16LeStart => {\n                    debug_assert_eq!(offset, 0usize);\n                    if src.is_empty() {\n                        return (DecoderResult::InputEmpty, 0, 0);\n                    }\n                    match src[0] {\n                        0xFFu8 => {\n                            self.life_cycle = DecoderLifeCycle::SeenUtf16LeFirst;\n                            offset += 1;\n                            continue;\n                        }\n                        _ => {\n                            self.life_cycle = DecoderLifeCycle::Converting;\n                            continue;\n                        }\n                    }\n                }\n                DecoderLifeCycle::SeenUtf8First => {\n                    if offset >= src.len() {\n                        if last {\n                            return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                                    dst,\n                                                                                    last,\n                                                                                    offset,\n                                                                                    0xEFu8);\n                        }\n                        return (DecoderResult::InputEmpty, offset, 0);\n                    }\n                    if src[offset] == 0xBBu8 {\n                        self.life_cycle = DecoderLifeCycle::SeenUtf8Second;\n                        offset += 1;\n                        continue;\n                    }\n                    return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset,\n                                                                            0xEFu8);\n                }\n                DecoderLifeCycle::SeenUtf8Second => {\n                    if offset >= src.len() {\n                        if last {\n                            return self.$decode_to_utf_after_two_potential_bom_bytes(src,\n                                                                                     dst,\n                                                                                     last,\n                                                                                     offset);\n                        }\n                        return (DecoderResult::InputEmpty, offset, 0);\n                    }\n                    if src[offset] == 0xBFu8 {\n                        self.life_cycle = DecoderLifeCycle::Converting;\n                        offset += 1;\n                        if self.encoding != UTF_8 {\n                            self.encoding = UTF_8;\n                            self.variant = UTF_8.new_variant_decoder();\n                        }\n                        return self.$decode_to_utf_checking_end_with_offset(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset);\n                    }\n                    return self.$decode_to_utf_after_two_potential_bom_bytes(src,\n                                                                             dst,\n                                                                             last,\n                                                                             offset);\n                }\n                DecoderLifeCycle::SeenUtf16BeFirst => {\n                    if offset >= src.len() {\n                        if last {\n                            return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                                    dst,\n                                                                                    last,\n                                                                                    offset,\n                                                                                    0xFEu8);\n                        }\n                        return (DecoderResult::InputEmpty, offset, 0);\n                    }\n                    if src[offset] == 0xFFu8 {\n                        self.life_cycle = DecoderLifeCycle::Converting;\n                        offset += 1;\n                        if self.encoding != UTF_16BE {\n                            self.encoding = UTF_16BE;\n                            self.variant = UTF_16BE.new_variant_decoder();\n                        }\n                        return self.$decode_to_utf_checking_end_with_offset(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset);\n                    }\n                    return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset,\n                                                                            0xFEu8);\n                }\n                DecoderLifeCycle::SeenUtf16LeFirst => {\n                    if offset >= src.len() {\n                        if last {\n                            return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                                    dst,\n                                                                                    last,\n                                                                                    offset,\n                                                                                    0xFFu8);\n                        }\n                        return (DecoderResult::InputEmpty, offset, 0);\n                    }\n                    if src[offset] == 0xFEu8 {\n                        self.life_cycle = DecoderLifeCycle::Converting;\n                        offset += 1;\n                        if self.encoding != UTF_16LE {\n                            self.encoding = UTF_16LE;\n                            self.variant = UTF_16LE.new_variant_decoder();\n                        }\n                        return self.$decode_to_utf_checking_end_with_offset(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset);\n                    }\n                    return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                            dst,\n                                                                            last,\n                                                                            offset,\n                                                                            0xFFu8);\n                }\n                DecoderLifeCycle::ConvertingWithPendingBB => {\n                    debug_assert_eq!(offset, 0usize);\n                    return self.$decode_to_utf_after_one_potential_bom_byte(src,\n                                                                            dst,\n                                                                            last,\n                                                                            0usize,\n                                                                            0xBBu8);\n                }\n                DecoderLifeCycle::Finished => panic!(\"Must not use a decoder that has finished.\"),\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"Decoder::encoding":["/// The `Encoding` this `Decoder` is for.\n///\n/// BOM sniffing can change the return value of this method during the life\n/// of the decoder.\n///\n/// Available via the C wrapper.\n#[inline]\npub fn encoding(&self) -> &'static Encoding{\n        self.encoding\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::latin1_byte_compatible_up_to":["/// Checks for compatibility with storing Unicode scalar values as unsigned\n/// bytes taking into account the state of the decoder.\n///\n/// Returns `None` if the decoder is not in a neutral state, including waiting\n/// for the BOM, or if the encoding is never Latin1-byte-compatible.\n///\n/// Otherwise returns the index of the first byte whose unsigned value doesn't\n/// directly correspond to the decoded Unicode scalar value, or the length\n/// of the input if all bytes in the input decode directly to scalar values\n/// corresponding to the unsigned byte values.\n///\n/// Does not change the state of the decoder.\n///\n/// Do not use this unless you are supporting SpiderMonkey/V8-style string\n/// storage optimizations.\n///\n/// Available via the C wrapper.\npub fn latin1_byte_compatible_up_to(&self, bytes: &[u8]) -> Option<usize>{\n        match self.life_cycle {\n            DecoderLifeCycle::Converting => {\n                return self.variant.latin1_byte_compatible_up_to(bytes);\n            }\n            DecoderLifeCycle::Finished => panic!(\"Must not use a decoder that has finished.\"),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::max_utf16_buffer_length":["/// Query the worst-case UTF-16 output size (with or without replacement).\n///\n/// Returns the size of the output buffer in UTF-16 code units (`u16`)\n/// that will not overflow given the current state of the decoder and\n/// `byte_length` number of additional input bytes or `None` if `usize`\n/// would overflow.\n///\n/// Since the REPLACEMENT CHARACTER fits into one UTF-16 code unit, the\n/// return value of this method applies also in the\n/// `_without_replacement` case.\n///\n/// Available via the C wrapper.\npub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        // Need to consider a) the decoder morphing due to the BOM and b) a partial\n        // BOM getting pushed to the underlying decoder.\n        match self.life_cycle {\n            DecoderLifeCycle::Converting\n            | DecoderLifeCycle::AtUtf8Start\n            | DecoderLifeCycle::AtUtf16LeStart\n            | DecoderLifeCycle::AtUtf16BeStart => {\n                return self.variant.max_utf16_buffer_length(byte_length);\n            }\n            DecoderLifeCycle::AtStart => {\n                if let Some(utf8_bom) = byte_length.checked_add(1) {\n                    if let Some(utf16_bom) =\n                        checked_add(1, checked_div(byte_length.checked_add(1), 2))\n                    {\n                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);\n                        let encoding = self.encoding();\n                        if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf_bom);\n                        } else if let Some(non_bom) =\n                            self.variant.max_utf16_buffer_length(byte_length)\n                        {\n                            return Some(std::cmp::max(utf_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::SeenUtf8First | DecoderLifeCycle::SeenUtf8Second => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf8_bom) = sum.checked_add(1) {\n                        if self.encoding() == UTF_8 {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf8_bom);\n                        } else if let Some(non_bom) = self.variant.max_utf16_buffer_length(sum) {\n                            return Some(std::cmp::max(utf8_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::ConvertingWithPendingBB => {\n                if let Some(sum) = byte_length.checked_add(2) {\n                    return self.variant.max_utf16_buffer_length(sum);\n                }\n            }\n            DecoderLifeCycle::SeenUtf16LeFirst | DecoderLifeCycle::SeenUtf16BeFirst => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf16_bom) = checked_add(1, checked_div(sum.checked_add(1), 2)) {\n                        let encoding = self.encoding();\n                        if encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf16_bom);\n                        } else if let Some(non_bom) = self.variant.max_utf16_buffer_length(sum) {\n                            return Some(std::cmp::max(utf16_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::Finished => panic!(\"Must not use a decoder that has finished.\"),\n        }\n        None\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::max_utf8_buffer_length":["/// Query the worst-case UTF-8 output size _with replacement_.\n///\n/// Returns the size of the output buffer in UTF-8 code units (`u8`)\n/// that will not overflow given the current state of the decoder and\n/// `byte_length` number of additional input bytes when decoding with\n/// errors handled by outputting a REPLACEMENT CHARACTER for each malformed\n/// sequence or `None` if `usize` would overflow.\n///\n/// Available via the C wrapper.\npub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        // Need to consider a) the decoder morphing due to the BOM and b) a partial\n        // BOM getting pushed to the underlying decoder.\n        match self.life_cycle {\n            DecoderLifeCycle::Converting\n            | DecoderLifeCycle::AtUtf8Start\n            | DecoderLifeCycle::AtUtf16LeStart\n            | DecoderLifeCycle::AtUtf16BeStart => {\n                return self.variant.max_utf8_buffer_length(byte_length);\n            }\n            DecoderLifeCycle::AtStart => {\n                if let Some(utf8_bom) = checked_add(3, byte_length.checked_mul(3)) {\n                    if let Some(utf16_bom) = checked_add(\n                        1,\n                        checked_mul(3, checked_div(byte_length.checked_add(1), 2)),\n                    ) {\n                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);\n                        let encoding = self.encoding();\n                        if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf_bom);\n                        } else if let Some(non_bom) =\n                            self.variant.max_utf8_buffer_length(byte_length)\n                        {\n                            return Some(std::cmp::max(utf_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::SeenUtf8First | DecoderLifeCycle::SeenUtf8Second => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf8_bom) = checked_add(3, sum.checked_mul(3)) {\n                        if self.encoding() == UTF_8 {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf8_bom);\n                        } else if let Some(non_bom) = self.variant.max_utf8_buffer_length(sum) {\n                            return Some(std::cmp::max(utf8_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::ConvertingWithPendingBB => {\n                if let Some(sum) = byte_length.checked_add(2) {\n                    return self.variant.max_utf8_buffer_length(sum);\n                }\n            }\n            DecoderLifeCycle::SeenUtf16LeFirst | DecoderLifeCycle::SeenUtf16BeFirst => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf16_bom) =\n                        checked_add(1, checked_mul(3, checked_div(sum.checked_add(1), 2)))\n                    {\n                        let encoding = self.encoding();\n                        if encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf16_bom);\n                        } else if let Some(non_bom) = self.variant.max_utf8_buffer_length(sum) {\n                            return Some(std::cmp::max(utf16_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::Finished => panic!(\"Must not use a decoder that has finished.\"),\n        }\n        None\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::max_utf8_buffer_length_without_replacement":["/// Query the worst-case UTF-8 output size _without replacement_.\n///\n/// Returns the size of the output buffer in UTF-8 code units (`u8`)\n/// that will not overflow given the current state of the decoder and\n/// `byte_length` number of additional input bytes when decoding without\n/// replacement error handling or `None` if `usize` would overflow.\n///\n/// Note that this value may be too small for the `_with_replacement` case.\n/// Use `max_utf8_buffer_length()` for that case.\n///\n/// Available via the C wrapper.\npub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        // Need to consider a) the decoder morphing due to the BOM and b) a partial\n        // BOM getting pushed to the underlying decoder.\n        match self.life_cycle {\n            DecoderLifeCycle::Converting\n            | DecoderLifeCycle::AtUtf8Start\n            | DecoderLifeCycle::AtUtf16LeStart\n            | DecoderLifeCycle::AtUtf16BeStart => {\n                return self\n                    .variant\n                    .max_utf8_buffer_length_without_replacement(byte_length);\n            }\n            DecoderLifeCycle::AtStart => {\n                if let Some(utf8_bom) = byte_length.checked_add(3) {\n                    if let Some(utf16_bom) = checked_add(\n                        1,\n                        checked_mul(3, checked_div(byte_length.checked_add(1), 2)),\n                    ) {\n                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);\n                        let encoding = self.encoding();\n                        if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf_bom);\n                        } else if let Some(non_bom) = self\n                            .variant\n                            .max_utf8_buffer_length_without_replacement(byte_length)\n                        {\n                            return Some(std::cmp::max(utf_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::SeenUtf8First | DecoderLifeCycle::SeenUtf8Second => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf8_bom) = sum.checked_add(3) {\n                        if self.encoding() == UTF_8 {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf8_bom);\n                        } else if let Some(non_bom) =\n                            self.variant.max_utf8_buffer_length_without_replacement(sum)\n                        {\n                            return Some(std::cmp::max(utf8_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::ConvertingWithPendingBB => {\n                if let Some(sum) = byte_length.checked_add(2) {\n                    return self.variant.max_utf8_buffer_length_without_replacement(sum);\n                }\n            }\n            DecoderLifeCycle::SeenUtf16LeFirst | DecoderLifeCycle::SeenUtf16BeFirst => {\n                // Add two bytes even when only one byte has been seen,\n                // because the one byte can become a lead byte in multibyte\n                // decoders, but only after the decoder has been queried\n                // for max length, so the decoder's own logic for adding\n                // one for a pending lead cannot work.\n                if let Some(sum) = byte_length.checked_add(2) {\n                    if let Some(utf16_bom) =\n                        checked_add(1, checked_mul(3, checked_div(sum.checked_add(1), 2)))\n                    {\n                        let encoding = self.encoding();\n                        if encoding == UTF_16LE || encoding == UTF_16BE {\n                            // No need to consider the internal state of the underlying decoder,\n                            // because it is at start, because no data has reached it yet.\n                            return Some(utf16_bom);\n                        } else if let Some(non_bom) =\n                            self.variant.max_utf8_buffer_length_without_replacement(sum)\n                        {\n                            return Some(std::cmp::max(utf16_bom, non_bom));\n                        }\n                    }\n                }\n            }\n            DecoderLifeCycle::Finished => panic!(\"Must not use a decoder that has finished.\"),\n        }\n        None\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Decoder::new":["fn new(enc: &'static Encoding, decoder: VariantDecoder, sniffing: BomHandling) -> Decoder{\n        Decoder {\n            encoding: enc,\n            variant: decoder,\n            life_cycle: match sniffing {\n                BomHandling::Off => DecoderLifeCycle::Converting,\n                BomHandling::Sniff => DecoderLifeCycle::AtStart,\n                BomHandling::Remove => {\n                    if enc == UTF_8 {\n                        DecoderLifeCycle::AtUtf8Start\n                    } else if enc == UTF_16BE {\n                        DecoderLifeCycle::AtUtf16BeStart\n                    } else if enc == UTF_16LE {\n                        DecoderLifeCycle::AtUtf16LeStart\n                    } else {\n                        DecoderLifeCycle::Converting\n                    }\n                }\n            },\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DecoderLifeCycle":["/// Tracks the life cycle of a decoder from BOM sniffing to conversion to end.\nenum DecoderLifeCycle {\n    /// The decoder has seen no input yet.\n    AtStart,\n    /// The decoder has seen no input yet but expects UTF-8.\n    AtUtf8Start,\n    /// The decoder has seen no input yet but expects UTF-16BE.\n    AtUtf16BeStart,\n    /// The decoder has seen no input yet but expects UTF-16LE.\n    AtUtf16LeStart,\n    /// The decoder has seen EF.\n    SeenUtf8First,\n    /// The decoder has seen EF, BB.\n    SeenUtf8Second,\n    /// The decoder has seen FE.\n    SeenUtf16BeFirst,\n    /// The decoder has seen FF.\n    SeenUtf16LeFirst,\n    /// Saw EF, BB but not BF, there was a buffer boundary after BB and the\n    /// underlying decoder reported EF as an error, so we need to remember to\n    /// push BB before the next buffer.\n    ConvertingWithPendingBB,\n    /// No longer looking for a BOM and EOF not yet seen.\n    Converting,\n    /// EOF has been seen.\n    Finished,\n}","Real(LocalPath(\"src/lib.rs\"))"],"DecoderResult":["/// Result of a (potentially partial) decode operation without replacement.\n#[must_use]\npub enum DecoderResult {\n    /// The input was exhausted.\n    ///\n    /// If this result was returned from a call where `last` was `true`, the\n    /// decoding process has completed. Otherwise, the caller should call a\n    /// decode method again with more input.\n    InputEmpty,\n\n    /// The decoder cannot produce another unit of output, because the output\n    /// buffer does not have enough space left.\n    ///\n    /// The caller must provide more output space upon the next call and re-push\n    /// the remaining input to the decoder.\n    OutputFull,\n\n    /// The decoder encountered a malformed byte sequence.\n    ///\n    /// The caller must either treat this as a fatal error or must append one\n    /// REPLACEMENT CHARACTER (U+FFFD) to the output and then re-push the\n    /// the remaining input to the decoder.\n    ///\n    /// The first wrapped integer indicates the length of the malformed byte\n    /// sequence. The second wrapped integer indicates the number of bytes\n    /// that were consumed after the malformed sequence. If the second\n    /// integer is zero, the last byte that was consumed is the last byte of\n    /// the malformed sequence. Note that the malformed bytes may have been part\n    /// of an earlier input buffer.\n    ///\n    /// The first wrapped integer can have values 1, 2, 3 or 4. The second\n    /// wrapped integer can have values 0, 1, 2 or 3. The worst-case sum\n    /// of the two is 6, which happens with ISO-2022-JP.\n    Malformed(u8, u8), // u8 instead of usize to avoid useless bloat\n}","Real(LocalPath(\"src/lib.rs\"))"],"Encoder":["/// A converter that encodes a Unicode stream into bytes according to a\n/// character encoding in a streaming (incremental) manner.\n///\n/// The various `encode_*` methods take an input buffer (`src`) and an output\n/// buffer `dst` both of which are caller-allocated. There are variants for\n/// both UTF-8 and UTF-16 input buffers.\n///\n/// An `encode_*` method encode characters from `src` into bytes characters\n/// stored into `dst` until one of the following three things happens:\n///\n/// 1. An unmappable character is encountered (`*_without_replacement` variants\n///    only).\n///\n/// 2. The output buffer has been filled so near capacity that the decoder\n///    cannot be sure that processing an additional character of input wouldn't\n///    cause so much output that the output buffer would overflow.\n///\n/// 3. All the input characters have been processed.\n///\n/// The `encode_*` method then returns tuple of a status indicating which one\n/// of the three reasons to return happened, how many input code units (`u8`\n/// when encoding from UTF-8 and `u16` when encoding from UTF-16) were read,\n/// how many output bytes were written (except when encoding into `Vec<u8>`,\n/// whose length change indicates this), and in the case of the variants that\n/// perform replacement, a boolean indicating whether an unmappable\n/// character was replaced with a numeric character reference during the call.\n///\n/// The number of bytes \"written\" is what's logically written. Garbage may be\n/// written in the output buffer beyond the point logically written to.\n///\n/// In the case of the methods whose name ends with\n/// `*_without_replacement`, the status is an [`EncoderResult`][1] enumeration\n/// (possibilities `Unmappable`, `OutputFull` and `InputEmpty` corresponding to\n/// the three cases listed above).\n///\n/// In the case of methods whose name does not end with\n/// `*_without_replacement`, unmappable characters are automatically replaced\n/// with the corresponding numeric character references and unmappable\n/// characters do not cause the methods to return early.\n///\n/// When encoding from UTF-8 without replacement, the methods are guaranteed\n/// not to return indicating that more output space is needed if the length\n/// of the output buffer is at least the length returned by\n/// [`max_buffer_length_from_utf8_without_replacement()`][2]. When encoding from\n/// UTF-8 with replacement, the length of the output buffer that guarantees the\n/// methods not to return indicating that more output space is needed in the\n/// absence of unmappable characters is given by\n/// [`max_buffer_length_from_utf8_if_no_unmappables()`][3]. When encoding from\n/// UTF-16 without replacement, the methods are guaranteed not to return\n/// indicating that more output space is needed if the length of the output\n/// buffer is at least the length returned by\n/// [`max_buffer_length_from_utf16_without_replacement()`][4]. When encoding\n/// from UTF-16 with replacement, the the length of the output buffer that\n/// guarantees the methods not to return indicating that more output space is\n/// needed in the absence of unmappable characters is given by\n/// [`max_buffer_length_from_utf16_if_no_unmappables()`][5].\n/// When encoding with replacement, applications are not expected to size the\n/// buffer for the worst case ahead of time but to resize the buffer if there\n/// are unmappable characters. This is why max length queries are only available\n/// for the case where there are no unmappable characters.\n///\n/// When encoding from UTF-8, each `src` buffer _must_ be valid UTF-8. (When\n/// calling from Rust, the type system takes care of this.) When encoding from\n/// UTF-16, unpaired surrogates in the input are treated as U+FFFD REPLACEMENT\n/// CHARACTERS. Therefore, in order for astral characters not to turn into a\n/// pair of REPLACEMENT CHARACTERS, the caller must ensure that surrogate pairs\n/// are not split across input buffer boundaries.\n///\n/// After an `encode_*` call returns, the output produced so far, taken as a\n/// whole from the start of the stream, is guaranteed to consist of a valid\n/// byte sequence in the target encoding. (I.e. the code unit sequence for a\n/// character is guaranteed not to be split across output buffers. However, due\n/// to the stateful nature of ISO-2022-JP, the stream needs to be considered\n/// from the start for it to be valid. For other encodings, the validity holds\n/// on a per-output buffer basis.)\n///\n/// The boolean argument `last` indicates that the end of the stream is reached\n/// when all the characters in `src` have been consumed. This argument is needed\n/// for ISO-2022-JP and is ignored for other encodings.\n///\n/// An `Encoder` object can be used to incrementally encode a byte stream.\n///\n/// During the processing of a single stream, the caller must call `encode_*`\n/// zero or more times with `last` set to `false` and then call `encode_*` at\n/// least once with `last` set to `true`. If `encode_*` returns `InputEmpty`,\n/// the processing of the stream has ended. Otherwise, the caller must call\n/// `encode_*` again with `last` set to `true` (or treat an `Unmappable` result\n/// as a fatal error).\n///\n/// Once the stream has ended, the `Encoder` object must not be used anymore.\n/// That is, you need to create another one to process another stream.\n///\n/// When the encoder returns `OutputFull` or the encoder returns `Unmappable`\n/// and the caller does not wish to treat it as a fatal error, the input buffer\n/// `src` may not have been completely consumed. In that case, the caller must\n/// pass the unconsumed contents of `src` to `encode_*` again upon the next\n/// call.\n///\n/// [1]: enum.EncoderResult.html\n/// [2]: #method.max_buffer_length_from_utf8_without_replacement\n/// [3]: #method.max_buffer_length_from_utf8_if_no_unmappables\n/// [4]: #method.max_buffer_length_from_utf16_without_replacement\n/// [5]: #method.max_buffer_length_from_utf16_if_no_unmappables\n///\n/// # Infinite loops\n///\n/// When converting with a fixed-size output buffer whose size is too small to\n/// accommodate one character of output, an infinite loop ensues. When\n/// converting with a fixed-size output buffer, it generally makes sense to\n/// make the buffer fairly large (e.g. couple of kilobytes).\npub struct Encoder {\n    encoding: &'static Encoding,\n    variant: VariantEncoder,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::encode_from_utf16":["/// Incrementally encode into byte stream from UTF-16 with unmappable\n/// characters replaced with HTML (decimal) numeric character references.\n///\n/// See the documentation of the struct for documentation for `encode_*`\n/// methods collectively.\n///\n/// Available via the C wrapper.\npub fn encode_from_utf16(\n        &mut self,\n        src: &[u16],\n        dst: &mut [u8],\n        last: bool,\n    ) -> (CoderResult, usize, usize, bool){\n        let dst_len = dst.len();\n        let effective_dst_len = if self.encoding().can_encode_everything() {\n            dst_len\n        } else {\n            if dst_len < NCR_EXTRA {\n                if src.is_empty() && !(last && self.has_pending_state()) {\n                    return (CoderResult::InputEmpty, 0, 0, false);\n                }\n                return (CoderResult::OutputFull, 0, 0, false);\n            }\n            dst_len - NCR_EXTRA\n        };\n        let mut had_unmappables = false;\n        let mut total_read = 0usize;\n        let mut total_written = 0usize;\n        loop {\n            let (result, read, written) = self.encode_from_utf16_without_replacement(\n                &src[total_read..],\n                &mut dst[total_written..effective_dst_len],\n                last,\n            );\n            total_read += read;\n            total_written += written;\n            match result {\n                EncoderResult::InputEmpty => {\n                    return (\n                        CoderResult::InputEmpty,\n                        total_read,\n                        total_written,\n                        had_unmappables,\n                    );\n                }\n                EncoderResult::OutputFull => {\n                    return (\n                        CoderResult::OutputFull,\n                        total_read,\n                        total_written,\n                        had_unmappables,\n                    );\n                }\n                EncoderResult::Unmappable(unmappable) => {\n                    had_unmappables = true;\n                    debug_assert!(dst.len() - total_written >= NCR_EXTRA);\n                    // There are no UTF-16 encoders and even if there were,\n                    // they'd never have unmappables.\n                    debug_assert_ne!(self.encoding(), UTF_16BE);\n                    debug_assert_ne!(self.encoding(), UTF_16LE);\n                    // Additionally, Iso2022JpEncoder is responsible for\n                    // transitioning to ASCII when returning with Unmappable\n                    // from the jis0208 state. That is, when we encode\n                    // ISO-2022-JP and come here, the encoder is in either the\n                    // ASCII or the Roman state. We are allowed to generate any\n                    // printable ASCII excluding \\ and ~.\n                    total_written += write_ncr(unmappable, &mut dst[total_written..]);\n                    if total_written >= effective_dst_len {\n                        if total_read == src.len() && !(last && self.has_pending_state()) {\n                            return (\n                                CoderResult::InputEmpty,\n                                total_read,\n                                total_written,\n                                had_unmappables,\n                            );\n                        }\n                        return (\n                            CoderResult::OutputFull,\n                            total_read,\n                            total_written,\n                            had_unmappables,\n                        );\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::encode_from_utf16_without_replacement":["/// Incrementally encode into byte stream from UTF-16 _without replacement_.\n///\n/// See the documentation of the struct for documentation for `encode_*`\n/// methods collectively.\n///\n/// Available via the C wrapper.\npub fn encode_from_utf16_without_replacement(\n        &mut self,\n        src: &[u16],\n        dst: &mut [u8],\n        last: bool,\n    ) -> (EncoderResult, usize, usize){\n        self.variant.encode_from_utf16_raw(src, dst, last)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::encode_from_utf8":["/// Incrementally encode into byte stream from UTF-8 with unmappable\n/// characters replaced with HTML (decimal) numeric character references.\n///\n/// See the documentation of the struct for documentation for `encode_*`\n/// methods collectively.\n///\n/// Available via the C wrapper.\npub fn encode_from_utf8(\n        &mut self,\n        src: &str,\n        dst: &mut [u8],\n        last: bool,\n    ) -> (CoderResult, usize, usize, bool){\n        let dst_len = dst.len();\n        let effective_dst_len = if self.encoding().can_encode_everything() {\n            dst_len\n        } else {\n            if dst_len < NCR_EXTRA {\n                if src.is_empty() && !(last && self.has_pending_state()) {\n                    return (CoderResult::InputEmpty, 0, 0, false);\n                }\n                return (CoderResult::OutputFull, 0, 0, false);\n            }\n            dst_len - NCR_EXTRA\n        };\n        let mut had_unmappables = false;\n        let mut total_read = 0usize;\n        let mut total_written = 0usize;\n        loop {\n            let (result, read, written) = self.encode_from_utf8_without_replacement(\n                &src[total_read..],\n                &mut dst[total_written..effective_dst_len],\n                last,\n            );\n            total_read += read;\n            total_written += written;\n            match result {\n                EncoderResult::InputEmpty => {\n                    return (\n                        CoderResult::InputEmpty,\n                        total_read,\n                        total_written,\n                        had_unmappables,\n                    );\n                }\n                EncoderResult::OutputFull => {\n                    return (\n                        CoderResult::OutputFull,\n                        total_read,\n                        total_written,\n                        had_unmappables,\n                    );\n                }\n                EncoderResult::Unmappable(unmappable) => {\n                    had_unmappables = true;\n                    debug_assert!(dst.len() - total_written >= NCR_EXTRA);\n                    debug_assert_ne!(self.encoding(), UTF_16BE);\n                    debug_assert_ne!(self.encoding(), UTF_16LE);\n                    // Additionally, Iso2022JpEncoder is responsible for\n                    // transitioning to ASCII when returning with Unmappable.\n                    total_written += write_ncr(unmappable, &mut dst[total_written..]);\n                    if total_written >= effective_dst_len {\n                        if total_read == src.len() && !(last && self.has_pending_state()) {\n                            return (\n                                CoderResult::InputEmpty,\n                                total_read,\n                                total_written,\n                                had_unmappables,\n                            );\n                        }\n                        return (\n                            CoderResult::OutputFull,\n                            total_read,\n                            total_written,\n                            had_unmappables,\n                        );\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::encode_from_utf8_to_vec":["/// Incrementally encode into byte stream from UTF-8 with unmappable\n/// characters replaced with HTML (decimal) numeric character references.\n///\n/// See the documentation of the struct for documentation for `encode_*`\n/// methods collectively.\n///\n/// Available to Rust only.\npub fn encode_from_utf8_to_vec(\n        &mut self,\n        src: &str,\n        dst: &mut Vec<u8>,\n        last: bool,\n    ) -> (CoderResult, usize, bool){\n        unsafe {\n            let old_len = dst.len();\n            let capacity = dst.capacity();\n            dst.set_len(capacity);\n            let (result, read, written, replaced) =\n                self.encode_from_utf8(src, &mut dst[old_len..], last);\n            dst.set_len(old_len + written);\n            (result, read, replaced)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::encode_from_utf8_to_vec_without_replacement":["/// Incrementally encode into byte stream from UTF-8 _without replacement_.\n///\n/// See the documentation of the struct for documentation for `encode_*`\n/// methods collectively.\n///\n/// Available to Rust only.\npub fn encode_from_utf8_to_vec_without_replacement(\n        &mut self,\n        src: &str,\n        dst: &mut Vec<u8>,\n        last: bool,\n    ) -> (EncoderResult, usize){\n        unsafe {\n            let old_len = dst.len();\n            let capacity = dst.capacity();\n            dst.set_len(capacity);\n            let (result, read, written) =\n                self.encode_from_utf8_without_replacement(src, &mut dst[old_len..], last);\n            dst.set_len(old_len + written);\n            (result, read)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::encode_from_utf8_without_replacement":["/// Incrementally encode into byte stream from UTF-8 _without replacement_.\n///\n/// See the documentation of the struct for documentation for `encode_*`\n/// methods collectively.\n///\n/// Available via the C wrapper.\npub fn encode_from_utf8_without_replacement(\n        &mut self,\n        src: &str,\n        dst: &mut [u8],\n        last: bool,\n    ) -> (EncoderResult, usize, usize){\n        self.variant.encode_from_utf8_raw(src, dst, last)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::encoding":["/// The `Encoding` this `Encoder` is for.\n#[inline]\npub fn encoding(&self) -> &'static Encoding{\n        self.encoding\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::has_pending_state":["/// Returns `true` if this is an ISO-2022-JP encoder that's not in the\n/// ASCII state and `false` otherwise.\n#[inline]\npub fn has_pending_state(&self) -> bool{\n        self.variant.has_pending_state()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::max_buffer_length_from_utf16_if_no_unmappables":["/// Query the worst-case output size when encoding from UTF-16 with\n/// replacement.\n///\n/// Returns the size of the output buffer in bytes that will not overflow\n/// given the current state of the encoder and `u16_length` number of\n/// additional input code units if there are no unmappable characters in\n/// the input or `None` if `usize` would overflow.\n///\n/// Available via the C wrapper.\npub fn max_buffer_length_from_utf16_if_no_unmappables(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        checked_add(\n            if self.encoding().can_encode_everything() {\n                0\n            } else {\n                NCR_EXTRA\n            },\n            self.max_buffer_length_from_utf16_without_replacement(u16_length),\n        )\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::max_buffer_length_from_utf16_without_replacement":["/// Query the worst-case output size when encoding from UTF-16 without\n/// replacement.\n///\n/// Returns the size of the output buffer in bytes that will not overflow\n/// given the current state of the encoder and `u16_length` number of\n/// additional input code units or `None` if `usize` would overflow.\n///\n/// Available via the C wrapper.\npub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        self.variant\n            .max_buffer_length_from_utf16_without_replacement(u16_length)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::max_buffer_length_from_utf8_if_no_unmappables":["/// Query the worst-case output size when encoding from UTF-8 with\n/// replacement.\n///\n/// Returns the size of the output buffer in bytes that will not overflow\n/// given the current state of the encoder and `byte_length` number of\n/// additional input code units if there are no unmappable characters in\n/// the input or `None` if `usize` would overflow.\n///\n/// Available via the C wrapper.\npub fn max_buffer_length_from_utf8_if_no_unmappables(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        checked_add(\n            if self.encoding().can_encode_everything() {\n                0\n            } else {\n                NCR_EXTRA\n            },\n            self.max_buffer_length_from_utf8_without_replacement(byte_length),\n        )\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::max_buffer_length_from_utf8_without_replacement":["/// Query the worst-case output size when encoding from UTF-8 without\n/// replacement.\n///\n/// Returns the size of the output buffer in bytes that will not overflow\n/// given the current state of the encoder and `byte_length` number of\n/// additional input code units or `None` if `usize` would overflow.\n///\n/// Available via the C wrapper.\npub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        self.variant\n            .max_buffer_length_from_utf8_without_replacement(byte_length)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoder::new":["fn new(enc: &'static Encoding, encoder: VariantEncoder) -> Encoder{\n        Encoder {\n            encoding: enc,\n            variant: encoder,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"EncoderResult":["/// Result of a (potentially partial) encode operation without replacement.\n#[must_use]\npub enum EncoderResult {\n    /// The input was exhausted.\n    ///\n    /// If this result was returned from a call where `last` was `true`, the\n    /// decoding process has completed. Otherwise, the caller should call a\n    /// decode method again with more input.\n    InputEmpty,\n\n    /// The encoder cannot produce another unit of output, because the output\n    /// buffer does not have enough space left.\n    ///\n    /// The caller must provide more output space upon the next call and re-push\n    /// the remaining input to the decoder.\n    OutputFull,\n\n    /// The encoder encountered an unmappable character.\n    ///\n    /// The caller must either treat this as a fatal error or must append\n    /// a placeholder to the output and then re-push the remaining input to the\n    /// encoder.\n    Unmappable(char),\n}","Real(LocalPath(\"src/lib.rs\"))"],"EncoderResult::unmappable_from_bmp":["fn unmappable_from_bmp(bmp: u16) -> EncoderResult{\n        EncoderResult::Unmappable(::std::char::from_u32(u32::from(bmp)).unwrap())\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding":["/// An encoding as defined in the [Encoding Standard][1].\n///\n/// An _encoding_ defines a mapping from a `u8` sequence to a `char` sequence\n/// and, in most cases, vice versa. Each encoding has a name, an output\n/// encoding, and one or more labels.\n///\n/// _Labels_ are ASCII-case-insensitive strings that are used to identify an\n/// encoding in formats and protocols. The _name_ of the encoding is the\n/// preferred label in the case appropriate for returning from the\n/// [`characterSet`][2] property of the `Document` DOM interface.\n///\n/// The _output encoding_ is the encoding used for form submission and URL\n/// parsing on Web pages in the encoding. This is UTF-8 for the replacement,\n/// UTF-16LE and UTF-16BE encodings and the encoding itself for other\n/// encodings.\n///\n/// [1]: https://encoding.spec.whatwg.org/\n/// [2]: https://dom.spec.whatwg.org/#dom-document-characterset\n///\n/// # Streaming vs. Non-Streaming\n///\n/// When you have the entire input in a single buffer, you can use the\n/// methods [`decode()`][3], [`decode_with_bom_removal()`][3],\n/// [`decode_without_bom_handling()`][5],\n/// [`decode_without_bom_handling_and_without_replacement()`][6] and\n/// [`encode()`][7]. (These methods are available to Rust callers only and are\n/// not available in the C API.) Unlike the rest of the API available to Rust,\n/// these methods perform heap allocations. You should the `Decoder` and\n/// `Encoder` objects when your input is split into multiple buffers or when\n/// you want to control the allocation of the output buffers.\n///\n/// [3]: #method.decode\n/// [4]: #method.decode_with_bom_removal\n/// [5]: #method.decode_without_bom_handling\n/// [6]: #method.decode_without_bom_handling_and_without_replacement\n/// [7]: #method.encode\n///\n/// # Instances\n///\n/// All instances of `Encoding` are statically allocated and have the `'static`\n/// lifetime. There is precisely one unique `Encoding` instance for each\n/// encoding defined in the Encoding Standard.\n///\n/// To obtain a reference to a particular encoding whose identity you know at\n/// compile time, use a `static` that refers to encoding. There is a `static`\n/// for each encoding. The `static`s are named in all caps with hyphens\n/// replaced with underscores (and in C/C++ have `_ENCODING` appended to the\n/// name). For example, if you know at compile time that you will want to\n/// decode using the UTF-8 encoding, use the `UTF_8` `static` (`UTF_8_ENCODING`\n/// in C/C++).\n///\n/// Additionally, there are non-reference-typed forms ending with `_INIT` to\n/// work around the problem that `static`s of the type `&'static Encoding`\n/// cannot be used to initialize items of an array whose type is\n/// `[&'static Encoding; N]`.\n///\n/// If you don't know what encoding you need at compile time and need to\n/// dynamically get an encoding by label, use\n/// <code>Encoding::<a href=\"#method.for_label\">for_label</a>(<var>label</var>)</code>.\n///\n/// Instances of `Encoding` can be compared with `==` (in both Rust and in\n/// C/C++).\npub struct Encoding {\n    name: &'static str,\n    variant: VariantEncoding,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::ascii_valid_up_to":["/// Validates ASCII.\n///\n/// Returns the index of the first byte that makes the input malformed as\n/// ASCII or the length of the slice if the slice is entirely valid.\n///\n/// Available via the C wrapper.\npub fn ascii_valid_up_to(bytes: &[u8]) -> usize{\n        ascii_valid_up_to(bytes)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::can_encode_everything":["/// Checks whether the _output encoding_ of this encoding can encode every\n/// `char`. (Only true if the output encoding is UTF-8.)\n///\n/// Available via the C wrapper.\n#[inline]\npub fn can_encode_everything(&'static self) -> bool{\n        self.output_encoding() == UTF_8\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::decode":["/// Decode complete input to `Cow<'a, str>` _with BOM sniffing_ and with\n/// malformed sequences replaced with the REPLACEMENT CHARACTER when the\n/// entire input is available as a single buffer (i.e. the end of the\n/// buffer marks the end of the stream).\n///\n/// This method implements the (non-streaming version of) the\n/// [_decode_](https://encoding.spec.whatwg.org/#decode) spec concept.\n///\n/// The second item in the returned tuple is the encoding that was actually\n/// used (which may differ from this encoding thanks to BOM sniffing).\n///\n/// The third item in the returned tuple indicates whether there were\n/// malformed sequences (that were replaced with the REPLACEMENT CHARACTER).\n///\n/// _Note:_ It is wrong to use this when the input buffer represents only\n/// a segment of the input instead of the whole input. Use `new_decoder()`\n/// when decoding segmented input.\n///\n/// This method performs a one or two heap allocations for the backing\n/// buffer of the `String` when unable to borrow. (One allocation if not\n/// errors and potentially another one in the presence of errors.) The\n/// first allocation assumes jemalloc and may not be optimal with\n/// allocators that do not use power-of-two buckets. A borrow is performed\n/// if decoding UTF-8 and the input is valid UTF-8, if decoding an\n/// ASCII-compatible encoding and the input is ASCII-only, or when decoding\n/// ISO-2022-JP and the input is entirely in the ASCII state without state\n/// transitions.\n///\n/// # Panics\n///\n/// If the size calculation for a heap-allocated backing buffer overflows\n/// `usize`.\n///\n/// Available to Rust only.\n#[inline]\npub fn decode<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, &'static Encoding, bool){\n        let (encoding, without_bom) = match Encoding::for_bom(bytes) {\n            Some((encoding, bom_length)) => (encoding, &bytes[bom_length..]),\n            None => (self, bytes),\n        };\n        let (cow, had_errors) = encoding.decode_without_bom_handling(without_bom);\n        (cow, encoding, had_errors)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::decode_with_bom_removal":["/// Decode complete input to `Cow<'a, str>` _with BOM removal_ and with\n/// malformed sequences replaced with the REPLACEMENT CHARACTER when the\n/// entire input is available as a single buffer (i.e. the end of the\n/// buffer marks the end of the stream).\n///\n/// When invoked on `UTF_8`, this method implements the (non-streaming\n/// version of) the\n/// [_UTF-8 decode_](https://encoding.spec.whatwg.org/#utf-8-decode) spec\n/// concept.\n///\n/// The second item in the returned pair indicates whether there were\n/// malformed sequences (that were replaced with the REPLACEMENT CHARACTER).\n///\n/// _Note:_ It is wrong to use this when the input buffer represents only\n/// a segment of the input instead of the whole input. Use\n/// `new_decoder_with_bom_removal()` when decoding segmented input.\n///\n/// This method performs a one or two heap allocations for the backing\n/// buffer of the `String` when unable to borrow. (One allocation if not\n/// errors and potentially another one in the presence of errors.) The\n/// first allocation assumes jemalloc and may not be optimal with\n/// allocators that do not use power-of-two buckets. A borrow is performed\n/// if decoding UTF-8 and the input is valid UTF-8, if decoding an\n/// ASCII-compatible encoding and the input is ASCII-only, or when decoding\n/// ISO-2022-JP and the input is entirely in the ASCII state without state\n/// transitions.\n///\n/// # Panics\n///\n/// If the size calculation for a heap-allocated backing buffer overflows\n/// `usize`.\n///\n/// Available to Rust only.\n#[inline]\npub fn decode_with_bom_removal<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, bool){\n        let without_bom = if self == UTF_8 && bytes.starts_with(b\"\\xEF\\xBB\\xBF\") {\n            &bytes[3..]\n        } else if (self == UTF_16LE && bytes.starts_with(b\"\\xFF\\xFE\"))\n            || (self == UTF_16BE && bytes.starts_with(b\"\\xFE\\xFF\"))\n        {\n            &bytes[2..]\n        } else {\n            bytes\n        };\n        self.decode_without_bom_handling(without_bom)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::decode_without_bom_handling":["/// Decode complete input to `Cow<'a, str>` _without BOM handling_ and\n/// with malformed sequences replaced with the REPLACEMENT CHARACTER when\n/// the entire input is available as a single buffer (i.e. the end of the\n/// buffer marks the end of the stream).\n///\n/// When invoked on `UTF_8`, this method implements the (non-streaming\n/// version of) the\n/// [_UTF-8 decode without BOM_](https://encoding.spec.whatwg.org/#utf-8-decode-without-bom)\n/// spec concept.\n///\n/// The second item in the returned pair indicates whether there were\n/// malformed sequences (that were replaced with the REPLACEMENT CHARACTER).\n///\n/// _Note:_ It is wrong to use this when the input buffer represents only\n/// a segment of the input instead of the whole input. Use\n/// `new_decoder_without_bom_handling()` when decoding segmented input.\n///\n/// This method performs a one or two heap allocations for the backing\n/// buffer of the `String` when unable to borrow. (One allocation if not\n/// errors and potentially another one in the presence of errors.) The\n/// first allocation assumes jemalloc and may not be optimal with\n/// allocators that do not use power-of-two buckets. A borrow is performed\n/// if decoding UTF-8 and the input is valid UTF-8, if decoding an\n/// ASCII-compatible encoding and the input is ASCII-only, or when decoding\n/// ISO-2022-JP and the input is entirely in the ASCII state without state\n/// transitions.\n///\n/// # Panics\n///\n/// If the size calculation for a heap-allocated backing buffer overflows\n/// `usize`.\n///\n/// Available to Rust only.\npub fn decode_without_bom_handling<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, bool){\n        let (mut decoder, mut string, mut total_read) = if self.is_potentially_borrowable() {\n            let valid_up_to = if self == UTF_8 {\n                utf8_valid_up_to(bytes)\n            } else if self == ISO_2022_JP {\n                iso_2022_jp_ascii_valid_up_to(bytes)\n            } else {\n                ascii_valid_up_to(bytes)\n            };\n            if valid_up_to == bytes.len() {\n                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };\n                return (Cow::Borrowed(str), false);\n            }\n            let decoder = self.new_decoder_without_bom_handling();\n\n            let rounded_without_replacement = checked_next_power_of_two(checked_add(\n                valid_up_to,\n                decoder.max_utf8_buffer_length_without_replacement(bytes.len() - valid_up_to),\n            ));\n            let with_replacement = checked_add(\n                valid_up_to,\n                decoder.max_utf8_buffer_length(bytes.len() - valid_up_to),\n            );\n            let mut string = String::with_capacity(\n                checked_min(rounded_without_replacement, with_replacement).unwrap(),\n            );\n            unsafe {\n                let vec = string.as_mut_vec();\n                vec.set_len(valid_up_to);\n                std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);\n            }\n            (decoder, string, valid_up_to)\n        } else {\n            let decoder = self.new_decoder_without_bom_handling();\n            let rounded_without_replacement = checked_next_power_of_two(\n                decoder.max_utf8_buffer_length_without_replacement(bytes.len()),\n            );\n            let with_replacement = decoder.max_utf8_buffer_length(bytes.len());\n            let string = String::with_capacity(\n                checked_min(rounded_without_replacement, with_replacement).unwrap(),\n            );\n            (decoder, string, 0)\n        };\n\n        let mut total_had_errors = false;\n        loop {\n            let (result, read, had_errors) =\n                decoder.decode_to_string(&bytes[total_read..], &mut string, true);\n            total_read += read;\n            total_had_errors |= had_errors;\n            match result {\n                CoderResult::InputEmpty => {\n                    debug_assert_eq!(total_read, bytes.len());\n                    return (Cow::Owned(string), total_had_errors);\n                }\n                CoderResult::OutputFull => {\n                    // Allocate for the worst case. That is, we should come\n                    // here at most once per invocation of this method.\n                    let needed = decoder.max_utf8_buffer_length(bytes.len() - total_read);\n                    string.reserve(needed.unwrap());\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::decode_without_bom_handling_and_without_replacement":["/// Decode complete input to `Cow<'a, str>` _without BOM handling_ and\n/// _with malformed sequences treated as fatal_ when the entire input is\n/// available as a single buffer (i.e. the end of the buffer marks the end\n/// of the stream).\n///\n/// When invoked on `UTF_8`, this method implements the (non-streaming\n/// version of) the\n/// [_UTF-8 decode without BOM or fail_](https://encoding.spec.whatwg.org/#utf-8-decode-without-bom-or-fail)\n/// spec concept.\n///\n/// Returns `None` if a malformed sequence was encountered and the result\n/// of the decode as `Some(String)` otherwise.\n///\n/// _Note:_ It is wrong to use this when the input buffer represents only\n/// a segment of the input instead of the whole input. Use\n/// `new_decoder_without_bom_handling()` when decoding segmented input.\n///\n/// This method performs a single heap allocation for the backing\n/// buffer of the `String` when unable to borrow. A borrow is performed if\n/// decoding UTF-8 and the input is valid UTF-8, if decoding an\n/// ASCII-compatible encoding and the input is ASCII-only, or when decoding\n/// ISO-2022-JP and the input is entirely in the ASCII state without state\n/// transitions.\n///\n/// # Panics\n///\n/// If the size calculation for a heap-allocated backing buffer overflows\n/// `usize`.\n///\n/// Available to Rust only.\npub fn decode_without_bom_handling_and_without_replacement<'a>(\n        &'static self,\n        bytes: &'a [u8],\n    ) -> Option<Cow<'a, str>>{\n        if self == UTF_8 {\n            let valid_up_to = utf8_valid_up_to(bytes);\n            if valid_up_to == bytes.len() {\n                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };\n                return Some(Cow::Borrowed(str));\n            }\n            return None;\n        }\n        let (mut decoder, mut string, input) = if self.is_potentially_borrowable() {\n            let valid_up_to = if self == ISO_2022_JP {\n                iso_2022_jp_ascii_valid_up_to(bytes)\n            } else {\n                ascii_valid_up_to(bytes)\n            };\n            if valid_up_to == bytes.len() {\n                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };\n                return Some(Cow::Borrowed(str));\n            }\n            let decoder = self.new_decoder_without_bom_handling();\n            let mut string = String::with_capacity(\n                checked_add(\n                    valid_up_to,\n                    decoder.max_utf8_buffer_length_without_replacement(bytes.len() - valid_up_to),\n                )\n                .unwrap(),\n            );\n            unsafe {\n                let vec = string.as_mut_vec();\n                vec.set_len(valid_up_to);\n                std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);\n            }\n            (decoder, string, &bytes[valid_up_to..])\n        } else {\n            let decoder = self.new_decoder_without_bom_handling();\n            let string = String::with_capacity(\n                decoder\n                    .max_utf8_buffer_length_without_replacement(bytes.len())\n                    .unwrap(),\n            );\n            (decoder, string, bytes)\n        };\n        let (result, read) = decoder.decode_to_string_without_replacement(input, &mut string, true);\n        match result {\n            DecoderResult::InputEmpty => {\n                debug_assert_eq!(read, input.len());\n                Some(Cow::Owned(string))\n            }\n            DecoderResult::Malformed(_, _) => None,\n            DecoderResult::OutputFull => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::encode":["/// Encode complete input to `Cow<'a, [u8]>` with unmappable characters\n/// replaced with decimal numeric character references when the entire input\n/// is available as a single buffer (i.e. the end of the buffer marks the\n/// end of the stream).\n///\n/// This method implements the (non-streaming version of) the\n/// [_encode_](https://encoding.spec.whatwg.org/#encode) spec concept. For\n/// the [_UTF-8 encode_](https://encoding.spec.whatwg.org/#utf-8-encode)\n/// spec concept, it is slightly more efficient to use\n/// <code><var>string</var>.as_bytes()</code> instead of invoking this\n/// method on `UTF_8`.\n///\n/// The second item in the returned tuple is the encoding that was actually\n/// used (which may differ from this encoding thanks to some encodings\n/// having UTF-8 as their output encoding).\n///\n/// The third item in the returned tuple indicates whether there were\n/// unmappable characters (that were replaced with HTML numeric character\n/// references).\n///\n/// _Note:_ It is wrong to use this when the input buffer represents only\n/// a segment of the input instead of the whole input. Use `new_encoder()`\n/// when encoding segmented output.\n///\n/// When encoding to UTF-8 or when encoding an ASCII-only input to a\n/// ASCII-compatible encoding, this method returns a borrow of the input\n/// without a heap allocation. Otherwise, this method performs a single\n/// heap allocation for the backing buffer of the `Vec<u8>` if there are no\n/// unmappable characters and potentially multiple heap allocations if\n/// there are. These allocations are tuned for jemalloc and may not be\n/// optimal when using a different allocator that doesn't use power-of-two\n/// buckets.\n///\n/// # Panics\n///\n/// If the size calculation for a heap-allocated backing buffer overflows\n/// `usize`.\n///\n/// Available to Rust only.\npub fn encode<'a>(&'static self, string: &'a str) -> (Cow<'a, [u8]>, &'static Encoding, bool){\n        let output_encoding = self.output_encoding();\n        if output_encoding == UTF_8 {\n            return (Cow::Borrowed(string.as_bytes()), output_encoding, false);\n        }\n        debug_assert!(output_encoding.is_potentially_borrowable());\n        let bytes = string.as_bytes();\n        let valid_up_to = if output_encoding == ISO_2022_JP {\n            iso_2022_jp_ascii_valid_up_to(bytes)\n        } else {\n            ascii_valid_up_to(bytes)\n        };\n        if valid_up_to == bytes.len() {\n            return (Cow::Borrowed(bytes), output_encoding, false);\n        }\n        let mut encoder = output_encoding.new_encoder();\n        let mut vec: Vec<u8> = Vec::with_capacity(\n            (checked_add(\n                valid_up_to,\n                encoder.max_buffer_length_from_utf8_if_no_unmappables(string.len() - valid_up_to),\n            ))\n            .unwrap()\n            .next_power_of_two(),\n        );\n        unsafe {\n            vec.set_len(valid_up_to);\n            std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);\n        }\n        let mut total_read = valid_up_to;\n        let mut total_had_errors = false;\n        loop {\n            let (result, read, had_errors) =\n                encoder.encode_from_utf8_to_vec(&string[total_read..], &mut vec, true);\n            total_read += read;\n            total_had_errors |= had_errors;\n            match result {\n                CoderResult::InputEmpty => {\n                    debug_assert_eq!(total_read, string.len());\n                    return (Cow::Owned(vec), output_encoding, total_had_errors);\n                }\n                CoderResult::OutputFull => {\n                    // reserve_exact wants to know how much more on top of current\n                    // length--not current capacity.\n                    let needed = encoder\n                        .max_buffer_length_from_utf8_if_no_unmappables(string.len() - total_read);\n                    let rounded = (checked_add(vec.capacity(), needed))\n                        .unwrap()\n                        .next_power_of_two();\n                    let additional = rounded - vec.len();\n                    vec.reserve_exact(additional);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::for_bom":["/// Performs non-incremental BOM sniffing.\n///\n/// The argument must either be a buffer representing the entire input\n/// stream (non-streaming case) or a buffer representing at least the first\n/// three bytes of the input stream (streaming case).\n///\n/// Returns `Some((UTF_8, 3))`, `Some((UTF_16LE, 2))` or\n/// `Some((UTF_16BE, 2))` if the argument starts with the UTF-8, UTF-16LE\n/// or UTF-16BE BOM or `None` otherwise.\n///\n/// Available via the C wrapper.\n#[inline]\npub fn for_bom(buffer: &[u8]) -> Option<(&'static Encoding, usize)>{\n        if buffer.starts_with(b\"\\xEF\\xBB\\xBF\") {\n            Some((UTF_8, 3))\n        } else if buffer.starts_with(b\"\\xFF\\xFE\") {\n            Some((UTF_16LE, 2))\n        } else if buffer.starts_with(b\"\\xFE\\xFF\") {\n            Some((UTF_16BE, 2))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::for_label":["/// Implements the\n/// [_get an encoding_](https://encoding.spec.whatwg.org/#concept-encoding-get)\n/// algorithm.\n///\n/// If, after ASCII-lowercasing and removing leading and trailing\n/// whitespace, the argument matches a label defined in the Encoding\n/// Standard, `Some(&'static Encoding)` representing the corresponding\n/// encoding is returned. If there is no match, `None` is returned.\n///\n/// This is the right method to use if the action upon the method returning\n/// `None` is to use a fallback encoding (e.g. `WINDOWS_1252`) instead.\n/// When the action upon the method returning `None` is not to proceed with\n/// a fallback but to refuse processing, `for_label_no_replacement()` is more\n/// appropriate.\n///\n/// The argument is of type `&[u8]` instead of `&str` to save callers\n/// that are extracting the label from a non-UTF-8 protocol the trouble\n/// of conversion to UTF-8. (If you have a `&str`, just call `.as_bytes()`\n/// on it.)\n///\n/// Available via the C wrapper.\npub fn for_label(label: &[u8]) -> Option<&'static Encoding>{\n        let mut trimmed = [0u8; LONGEST_LABEL_LENGTH];\n        let mut trimmed_pos = 0usize;\n        let mut iter = label.into_iter();\n        // before\n        loop {\n            match iter.next() {\n                None => {\n                    return None;\n                }\n                Some(byte) => {\n                    // The characters used in labels are:\n                    // a-z (except q, but excluding it below seems excessive)\n                    // 0-9\n                    // . _ - :\n                    match *byte {\n                        0x09u8 | 0x0Au8 | 0x0Cu8 | 0x0Du8 | 0x20u8 => {\n                            continue;\n                        }\n                        b'A'...b'Z' => {\n                            trimmed[trimmed_pos] = *byte + 0x20u8;\n                            trimmed_pos = 1usize;\n                            break;\n                        }\n                        b'a'...b'z' | b'0'...b'9' | b'-' | b'_' | b':' | b'.' => {\n                            trimmed[trimmed_pos] = *byte;\n                            trimmed_pos = 1usize;\n                            break;\n                        }\n                        _ => {\n                            return None;\n                        }\n                    }\n                }\n            }\n        }\n        // inside\n        loop {\n            match iter.next() {\n                None => {\n                    break;\n                }\n                Some(byte) => {\n                    match *byte {\n                        0x09u8 | 0x0Au8 | 0x0Cu8 | 0x0Du8 | 0x20u8 => {\n                            break;\n                        }\n                        b'A'...b'Z' => {\n                            if trimmed_pos == LONGEST_LABEL_LENGTH {\n                                // There's no encoding with a label this long\n                                return None;\n                            }\n                            trimmed[trimmed_pos] = *byte + 0x20u8;\n                            trimmed_pos += 1usize;\n                            continue;\n                        }\n                        b'a'...b'z' | b'0'...b'9' | b'-' | b'_' | b':' | b'.' => {\n                            if trimmed_pos == LONGEST_LABEL_LENGTH {\n                                // There's no encoding with a label this long\n                                return None;\n                            }\n                            trimmed[trimmed_pos] = *byte;\n                            trimmed_pos += 1usize;\n                            continue;\n                        }\n                        _ => {\n                            return None;\n                        }\n                    }\n                }\n            }\n        }\n        // after\n        loop {\n            match iter.next() {\n                None => {\n                    break;\n                }\n                Some(byte) => {\n                    match *byte {\n                        0x09u8 | 0x0Au8 | 0x0Cu8 | 0x0Du8 | 0x20u8 => {\n                            continue;\n                        }\n                        _ => {\n                            // There's no label with space in the middle\n                            return None;\n                        }\n                    }\n                }\n            }\n        }\n        let candidate = &trimmed[..trimmed_pos];\n        match LABELS_SORTED.binary_search_by(|probe| {\n            let bytes = probe.as_bytes();\n            let c = bytes.len().cmp(&candidate.len());\n            if c != Ordering::Equal {\n                return c;\n            }\n            let probe_iter = bytes.iter().rev();\n            let candidate_iter = candidate.iter().rev();\n            probe_iter.cmp(candidate_iter)\n        }) {\n            Ok(i) => Some(ENCODINGS_IN_LABEL_SORT[i]),\n            Err(_) => None,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::for_label_no_replacement":["/// This method behaves the same as `for_label()`, except when `for_label()`\n/// would return `Some(REPLACEMENT)`, this method returns `None` instead.\n///\n/// This method is useful in scenarios where a fatal error is required\n/// upon invalid label, because in those cases the caller typically wishes\n/// to treat the labels that map to the replacement encoding as fatal\n/// errors, too.\n///\n/// It is not OK to use this method when the action upon the method returning\n/// `None` is to use a fallback encoding (e.g. `WINDOWS_1252`). In such a\n/// case, the `for_label()` method should be used instead in order to avoid\n/// unsafe fallback for labels that `for_label()` maps to `Some(REPLACEMENT)`.\n///\n/// Available via the C wrapper.\n#[inline]\npub fn for_label_no_replacement(label: &[u8]) -> Option<&'static Encoding>{\n        match Encoding::for_label(label) {\n            None => None,\n            Some(encoding) => {\n                if encoding == REPLACEMENT {\n                    None\n                } else {\n                    Some(encoding)\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::is_ascii_compatible":["/// Checks whether the bytes 0x00...0x7F map exclusively to the characters\n/// U+0000...U+007F and vice versa.\n///\n/// Available via the C wrapper.\n#[inline]\npub fn is_ascii_compatible(&'static self) -> bool{\n        !(self == REPLACEMENT || self == UTF_16BE || self == UTF_16LE || self == ISO_2022_JP)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::is_potentially_borrowable":["/// Checks whether the bytes 0x00...0x7F map mostly to the characters\n/// U+0000...U+007F and vice versa.\n#[inline]\nfn is_potentially_borrowable(&'static self) -> bool{\n        !(self == REPLACEMENT || self == UTF_16BE || self == UTF_16LE)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::is_single_byte":["/// Checks whether this encoding maps one byte to one Basic Multilingual\n/// Plane code point (i.e. byte length equals decoded UTF-16 length) and\n/// vice versa (for mappable characters).\n///\n/// `true` iff this encoding is on the list of [Legacy single-byte\n/// encodings](https://encoding.spec.whatwg.org/#legacy-single-byte-encodings)\n/// in the spec or x-user-defined.\n///\n/// Available via the C wrapper.\n#[inline]\npub fn is_single_byte(&'static self) -> bool{\n        self.variant.is_single_byte()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::iso_2022_jp_ascii_valid_up_to":["/// Validates ISO-2022-JP ASCII-state data.\n///\n/// Returns the index of the first byte that makes the input not\n/// representable in the ASCII state of ISO-2022-JP or the length of the\n/// slice if the slice is entirely representable in the ASCII state of\n/// ISO-2022-JP.\n///\n/// Available via the C wrapper.\npub fn iso_2022_jp_ascii_valid_up_to(bytes: &[u8]) -> usize{\n        iso_2022_jp_ascii_valid_up_to(bytes)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::name":["/// Returns the name of this encoding.\n///\n/// This name is appropriate to return as-is from the DOM\n/// `document.characterSet` property.\n///\n/// Available via the C wrapper.\n#[inline]\npub fn name(&'static self) -> &'static str{\n        self.name\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::new_decoder":["/// Instantiates a new decoder for this encoding with BOM sniffing enabled.\n///\n/// BOM sniffing may cause the returned decoder to morph into a decoder\n/// for UTF-8, UTF-16LE or UTF-16BE instead of this encoding.\n///\n/// Available via the C wrapper.\n#[inline]\npub fn new_decoder(&'static self) -> Decoder{\n        Decoder::new(self, self.new_variant_decoder(), BomHandling::Sniff)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::new_decoder_with_bom_removal":["/// Instantiates a new decoder for this encoding with BOM removal.\n///\n/// If the input starts with bytes that are the BOM for this encoding,\n/// those bytes are removed. However, the decoder never morphs into a\n/// decoder for another encoding: A BOM for another encoding is treated as\n/// (potentially malformed) input to the decoding algorithm for this\n/// encoding.\n///\n/// Available via the C wrapper.\n#[inline]\npub fn new_decoder_with_bom_removal(&'static self) -> Decoder{\n        Decoder::new(self, self.new_variant_decoder(), BomHandling::Remove)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::new_decoder_without_bom_handling":["/// Instantiates a new decoder for this encoding with BOM handling disabled.\n///\n/// If the input starts with bytes that look like a BOM, those bytes are\n/// not treated as a BOM. (Hence, the decoder never morphs into a decoder\n/// for another encoding.)\n///\n/// _Note:_ If the caller has performed BOM sniffing on its own but has not\n/// removed the BOM, the caller should use `new_decoder_with_bom_removal()`\n/// instead of this method to cause the BOM to be removed.\n///\n/// Available via the C wrapper.\n#[inline]\npub fn new_decoder_without_bom_handling(&'static self) -> Decoder{\n        Decoder::new(self, self.new_variant_decoder(), BomHandling::Off)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::new_encoder":["/// Instantiates a new encoder for the output encoding of this encoding.\n///\n/// Available via the C wrapper.\n#[inline]\npub fn new_encoder(&'static self) -> Encoder{\n        let enc = self.output_encoding();\n        enc.variant.new_encoder(enc)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::new_variant_decoder":["fn new_variant_decoder(&'static self) -> VariantDecoder{\n        self.variant.new_variant_decoder()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::output_encoding":["/// Returns the _output encoding_ of this encoding. This is UTF-8 for\n/// UTF-16BE, UTF-16LE and replacement and the encoding itself otherwise.\n///\n/// Available via the C wrapper.\n#[inline]\npub fn output_encoding(&'static self) -> &'static Encoding{\n        if self == REPLACEMENT || self == UTF_16BE || self == UTF_16LE {\n            UTF_8\n        } else {\n            self\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Encoding::utf8_valid_up_to":["/// Validates UTF-8.\n///\n/// Returns the index of the first byte that makes the input malformed as\n/// UTF-8 or the length of the slice if the slice is entirely valid.\n///\n/// This is currently faster than the corresponding standard library\n/// functionality. If this implementation gets upstreamed to the standard\n/// library, this method may be removed in the future.\n///\n/// Available via the C wrapper.\npub fn utf8_valid_up_to(bytes: &[u8]) -> usize{\n        utf8_valid_up_to(bytes)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"ascii::ascii_to_ascii":["#[inline(always)]\npub unsafe fn $name(\n            src: *const $src_unit,\n            dst: *mut $dst_unit,\n            len: usize,\n        ) -> Option<($src_unit, usize)>{\n            let mut offset = 0usize;\n            // This loop is only broken out of as a `goto` forward\n            loop {\n                let mut until_alignment = {\n                    // Check if the other unit aligns if we move the narrower unit\n                    // to alignment.\n                    //               if ::std::mem::size_of::<$src_unit>() == ::std::mem::size_of::<$dst_unit>() {\n                    // ascii_to_ascii\n                    let src_alignment = (src as usize) & ALU_ALIGNMENT_MASK;\n                    let dst_alignment = (dst as usize) & ALU_ALIGNMENT_MASK;\n                    if src_alignment != dst_alignment {\n                        break;\n                    }\n                    (ALU_ALIGNMENT - src_alignment) & ALU_ALIGNMENT_MASK\n                    //               } else if ::std::mem::size_of::<$src_unit>() < ::std::mem::size_of::<$dst_unit>() {\n                    // ascii_to_basic_latin\n                    //                   let src_until_alignment = (ALIGNMENT - ((src as usize) & ALIGNMENT_MASK)) & ALIGNMENT_MASK;\n                    //                   if (dst.add(src_until_alignment) as usize) & ALIGNMENT_MASK != 0 {\n                    //                       break;\n                    //                   }\n                    //                   src_until_alignment\n                    //               } else {\n                    // basic_latin_to_ascii\n                    //                   let dst_until_alignment = (ALIGNMENT - ((dst as usize) & ALIGNMENT_MASK)) & ALIGNMENT_MASK;\n                    //                   if (src.add(dst_until_alignment) as usize) & ALIGNMENT_MASK != 0 {\n                    //                       break;\n                    //                   }\n                    //                   dst_until_alignment\n                    //               }\n                };\n                if until_alignment + ALU_STRIDE_SIZE <= len {\n                    // Moving pointers to alignment seems to be a pessimization on\n                    // x86_64 for operations that have UTF-16 as the internal\n                    // Unicode representation. However, since it seems to be a win\n                    // on ARM (tested ARMv7 code running on ARMv8 [rpi3]), except\n                    // mixed results when encoding from UTF-16 and since x86 and\n                    // x86_64 should be using SSE2 in due course, keeping the move\n                    // to alignment here. It would be good to test on more ARM CPUs\n                    // and on real MIPS and POWER hardware.\n                    while until_alignment != 0 {\n                        let code_unit = *(src.add(offset));\n                        if code_unit > 127 {\n                            return Some((code_unit, offset));\n                        }\n                        *(dst.add(offset)) = code_unit as $dst_unit;\n                        offset += 1;\n                        until_alignment -= 1;\n                    }\n                    let len_minus_stride = len - ALU_STRIDE_SIZE;\n                    loop {\n                        if let Some(num_ascii) = $stride_fn(\n                            src.add(offset) as *const usize,\n                            dst.add(offset) as *mut usize,\n                        ) {\n                            offset += num_ascii;\n                            return Some((*(src.add(offset)), offset));\n                        }\n                        offset += ALU_STRIDE_SIZE;\n                        if offset > len_minus_stride {\n                            break;\n                        }\n                    }\n                }\n                break;\n            }\n            while offset < len {\n                let code_unit = *(src.add(offset));\n                if code_unit > 127 {\n                    return Some((code_unit, offset));\n                }\n                *(dst.add(offset)) = code_unit as $dst_unit;\n                offset += 1;\n            }\n            None\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::ascii_to_ascii_stride":["#[inline(always)]\nunsafe fn ascii_to_ascii_stride(src: *const usize, dst: *mut usize) -> Option<usize>{\n            let word = *src;\n            let second_word = *(src.add(1));\n            *dst = word;\n            *(dst.add(1)) = second_word;\n            find_non_ascii(word, second_word)\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::ascii_to_basic_latin":["#[inline(always)]\npub unsafe fn $name(\n            src: *const $src_unit,\n            dst: *mut $dst_unit,\n            len: usize,\n        ) -> Option<($src_unit, usize)>{\n            let mut offset = 0usize;\n            // This loop is only broken out of as a `goto` forward\n            loop {\n                let mut until_alignment = {\n                    // Check if the other unit aligns if we move the narrower unit\n                    // to alignment.\n                    //               if ::std::mem::size_of::<$src_unit>() == ::std::mem::size_of::<$dst_unit>() {\n                    // ascii_to_ascii\n                    //                   let src_alignment = (src as usize) & ALIGNMENT_MASK;\n                    //                   let dst_alignment = (dst as usize) & ALIGNMENT_MASK;\n                    //                   if src_alignment != dst_alignment {\n                    //                       break;\n                    //                   }\n                    //                   (ALIGNMENT - src_alignment) & ALIGNMENT_MASK\n                    //               } else\n                    if ::std::mem::size_of::<$src_unit>() < ::std::mem::size_of::<$dst_unit>() {\n                        // ascii_to_basic_latin\n                        let src_until_alignment = (ALU_ALIGNMENT\n                            - ((src as usize) & ALU_ALIGNMENT_MASK))\n                            & ALU_ALIGNMENT_MASK;\n                        if (dst.add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {\n                            break;\n                        }\n                        src_until_alignment\n                    } else {\n                        // basic_latin_to_ascii\n                        let dst_until_alignment = (ALU_ALIGNMENT\n                            - ((dst as usize) & ALU_ALIGNMENT_MASK))\n                            & ALU_ALIGNMENT_MASK;\n                        if (src.add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {\n                            break;\n                        }\n                        dst_until_alignment\n                    }\n                };\n                if until_alignment + ALU_STRIDE_SIZE <= len {\n                    // Moving pointers to alignment seems to be a pessimization on\n                    // x86_64 for operations that have UTF-16 as the internal\n                    // Unicode representation. However, since it seems to be a win\n                    // on ARM (tested ARMv7 code running on ARMv8 [rpi3]), except\n                    // mixed results when encoding from UTF-16 and since x86 and\n                    // x86_64 should be using SSE2 in due course, keeping the move\n                    // to alignment here. It would be good to test on more ARM CPUs\n                    // and on real MIPS and POWER hardware.\n                    while until_alignment != 0 {\n                        let code_unit = *(src.add(offset));\n                        if code_unit > 127 {\n                            return Some((code_unit, offset));\n                        }\n                        *(dst.add(offset)) = code_unit as $dst_unit;\n                        offset += 1;\n                        until_alignment -= 1;\n                    }\n                    let len_minus_stride = len - ALU_STRIDE_SIZE;\n                    loop {\n                        if !$stride_fn(\n                            src.add(offset) as *const usize,\n                            dst.add(offset) as *mut usize,\n                        ) {\n                            break;\n                        }\n                        offset += ALU_STRIDE_SIZE;\n                        if offset > len_minus_stride {\n                            break;\n                        }\n                    }\n                }\n                break;\n            }\n            while offset < len {\n                let code_unit = *(src.add(offset));\n                if code_unit > 127 {\n                    return Some((code_unit, offset));\n                }\n                *(dst.add(offset)) = code_unit as $dst_unit;\n                offset += 1;\n            }\n            None\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::ascii_to_basic_latin_stride_alu":["#[inline(always)]\nunsafe fn ascii_to_basic_latin_stride_alu(src: *const usize, dst: *mut usize) -> bool{\n            let word = *src;\n            let second_word = *(src.add(1));\n            // Check if the words contains non-ASCII\n            if (word & ASCII_MASK) | (second_word & ASCII_MASK) != 0 {\n                return false;\n            }\n            unpack_alu(word, second_word, dst);\n            true\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::ascii_valid_up_to":["pub fn ascii_valid_up_to(bytes: &[u8]) -> usize{\n    match validate_ascii(bytes) {\n        None => bytes.len(),\n        Some((_, num_valid)) => num_valid,\n    }\n}","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::basic_latin_to_ascii":["#[inline(always)]\npub unsafe fn $name(\n            src: *const $src_unit,\n            dst: *mut $dst_unit,\n            len: usize,\n        ) -> Option<($src_unit, usize)>{\n            let mut offset = 0usize;\n            // This loop is only broken out of as a `goto` forward\n            loop {\n                let mut until_alignment = {\n                    // Check if the other unit aligns if we move the narrower unit\n                    // to alignment.\n                    //               if ::std::mem::size_of::<$src_unit>() == ::std::mem::size_of::<$dst_unit>() {\n                    // ascii_to_ascii\n                    //                   let src_alignment = (src as usize) & ALIGNMENT_MASK;\n                    //                   let dst_alignment = (dst as usize) & ALIGNMENT_MASK;\n                    //                   if src_alignment != dst_alignment {\n                    //                       break;\n                    //                   }\n                    //                   (ALIGNMENT - src_alignment) & ALIGNMENT_MASK\n                    //               } else\n                    if ::std::mem::size_of::<$src_unit>() < ::std::mem::size_of::<$dst_unit>() {\n                        // ascii_to_basic_latin\n                        let src_until_alignment = (ALU_ALIGNMENT\n                            - ((src as usize) & ALU_ALIGNMENT_MASK))\n                            & ALU_ALIGNMENT_MASK;\n                        if (dst.add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {\n                            break;\n                        }\n                        src_until_alignment\n                    } else {\n                        // basic_latin_to_ascii\n                        let dst_until_alignment = (ALU_ALIGNMENT\n                            - ((dst as usize) & ALU_ALIGNMENT_MASK))\n                            & ALU_ALIGNMENT_MASK;\n                        if (src.add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {\n                            break;\n                        }\n                        dst_until_alignment\n                    }\n                };\n                if until_alignment + ALU_STRIDE_SIZE <= len {\n                    // Moving pointers to alignment seems to be a pessimization on\n                    // x86_64 for operations that have UTF-16 as the internal\n                    // Unicode representation. However, since it seems to be a win\n                    // on ARM (tested ARMv7 code running on ARMv8 [rpi3]), except\n                    // mixed results when encoding from UTF-16 and since x86 and\n                    // x86_64 should be using SSE2 in due course, keeping the move\n                    // to alignment here. It would be good to test on more ARM CPUs\n                    // and on real MIPS and POWER hardware.\n                    while until_alignment != 0 {\n                        let code_unit = *(src.add(offset));\n                        if code_unit > 127 {\n                            return Some((code_unit, offset));\n                        }\n                        *(dst.add(offset)) = code_unit as $dst_unit;\n                        offset += 1;\n                        until_alignment -= 1;\n                    }\n                    let len_minus_stride = len - ALU_STRIDE_SIZE;\n                    loop {\n                        if !$stride_fn(\n                            src.add(offset) as *const usize,\n                            dst.add(offset) as *mut usize,\n                        ) {\n                            break;\n                        }\n                        offset += ALU_STRIDE_SIZE;\n                        if offset > len_minus_stride {\n                            break;\n                        }\n                    }\n                }\n                break;\n            }\n            while offset < len {\n                let code_unit = *(src.add(offset));\n                if code_unit > 127 {\n                    return Some((code_unit, offset));\n                }\n                *(dst.add(offset)) = code_unit as $dst_unit;\n                offset += 1;\n            }\n            None\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::basic_latin_to_ascii_stride_alu":["#[inline(always)]\nunsafe fn basic_latin_to_ascii_stride_alu(src: *const usize, dst: *mut usize) -> bool{\n            let first = *src;\n            let second = *(src.add(1));\n            let third = *(src.add(2));\n            let fourth = *(src.add(3));\n            if (first & BASIC_LATIN_MASK) | (second & BASIC_LATIN_MASK) | (third & BASIC_LATIN_MASK) | (fourth & BASIC_LATIN_MASK) != 0 {\n                return false;\n            }\n            pack_alu(first, second, third, fourth, dst);\n            true\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::count_zeros":["#[allow(dead_code)]\n#[inline(always)]\nfn count_zeros(word: usize) -> u32{\n            word.trailing_zeros()\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::find_non_ascii":["#[inline(always)]\nfn find_non_ascii(word: usize, second_word: usize) -> Option<usize>{\n            let word_masked = word & ASCII_MASK;\n            let second_masked = second_word & ASCII_MASK;\n            if (word_masked | second_masked) == 0 {\n                return None;\n            }\n            if word_masked != 0 {\n                let zeros = count_zeros(word_masked);\n                // `zeros` now contains 7 (for the seven bits of non-ASCII)\n                // plus 8 times the number of ASCII in text order before the\n                // non-ASCII byte in the little-endian case or 8 times the number of ASCII in\n                // text order before the non-ASCII byte in the big-endian case.\n                let num_ascii = (zeros >> 3) as usize;\n                return Some(num_ascii);\n            }\n            let zeros = count_zeros(second_masked);\n            // `zeros` now contains 7 (for the seven bits of non-ASCII)\n            // plus 8 times the number of ASCII in text order before the\n            // non-ASCII byte in the little-endian case or 8 times the number of ASCII in\n            // text order before the non-ASCII byte in the big-endian case.\n            let num_ascii = (zeros >> 3) as usize;\n            Some(ALU_ALIGNMENT + num_ascii)\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::iso_2022_jp_ascii_valid_up_to":["pub fn iso_2022_jp_ascii_valid_up_to(bytes: &[u8]) -> usize{\n    for (i, b_ref) in bytes.iter().enumerate() {\n        let b = *b_ref;\n        if b >= 0x80 || b == 0x1B || b == 0x0E || b == 0x0F {\n            return i;\n        }\n    }\n    bytes.len()\n}","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::likely":["#[allow(dead_code)]\n#[inline(always)]\nunsafe fn likely(b: bool) -> bool{\n            b\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::pack_alu":["#[inline(always)]\nunsafe fn pack_alu(first: usize, second: usize, third: usize, fourth: usize, dst: *mut usize){\n            let word = ((0x00FF_0000_0000_0000usize & second) << 8) |\n                       ((0x0000_00FF_0000_0000usize & second) << 16) |\n                       ((0x0000_0000_00FF_0000usize & second) << 24) |\n                       ((0x0000_0000_0000_00FFusize & second) << 32) |\n                       ((0x00FF_0000_0000_0000usize & first) >> 24) |\n                       ((0x0000_00FF_0000_0000usize & first) >> 16) |\n                       ((0x0000_0000_00FF_0000usize & first) >> 8) |\n                       (0x0000_0000_0000_00FFusize & first);\n            let second_word = ((0x00FF_0000_0000_0000usize & fourth) << 8) |\n                              ((0x0000_00FF_0000_0000usize & fourth) << 16) |\n                              ((0x0000_0000_00FF_0000usize & fourth) << 24) |\n                              ((0x0000_0000_0000_00FFusize & fourth) << 32) |\n                              ((0x00FF_0000_0000_0000usize & third) >> 24) |\n                              ((0x0000_00FF_0000_0000usize & third) >> 16) |\n                              ((0x0000_0000_00FF_0000usize & third) >> 8) |\n                              (0x0000_0000_0000_00FFusize & third);\n            *dst = word;\n            *(dst.add(1)) = second_word;\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::pack_latin1":["#[inline(always)]\npub unsafe fn $name(src: *const $src_unit, dst: *mut $dst_unit, len: usize){\n            let mut offset = 0usize;\n            // This loop is only broken out of as a `goto` forward\n            loop {\n                let mut until_alignment = {\n                    if ::std::mem::size_of::<$src_unit>() < ::std::mem::size_of::<$dst_unit>() {\n                        // unpack\n                        let src_until_alignment = (ALU_ALIGNMENT\n                            - ((src as usize) & ALU_ALIGNMENT_MASK))\n                            & ALU_ALIGNMENT_MASK;\n                        if (dst.add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {\n                            break;\n                        }\n                        src_until_alignment\n                    } else {\n                        // pack\n                        let dst_until_alignment = (ALU_ALIGNMENT\n                            - ((dst as usize) & ALU_ALIGNMENT_MASK))\n                            & ALU_ALIGNMENT_MASK;\n                        if (src.add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {\n                            break;\n                        }\n                        dst_until_alignment\n                    }\n                };\n                if until_alignment + ALU_STRIDE_SIZE <= len {\n                    while until_alignment != 0 {\n                        let code_unit = *(src.add(offset));\n                        *(dst.add(offset)) = code_unit as $dst_unit;\n                        offset += 1;\n                        until_alignment -= 1;\n                    }\n                    let len_minus_stride = len - ALU_STRIDE_SIZE;\n                    loop {\n                        $stride_fn(\n                            src.add(offset) as *const usize,\n                            dst.add(offset) as *mut usize,\n                        );\n                        offset += ALU_STRIDE_SIZE;\n                        if offset > len_minus_stride {\n                            break;\n                        }\n                    }\n                }\n                break;\n            }\n            while offset < len {\n                let code_unit = *(src.add(offset));\n                *(dst.add(offset)) = code_unit as $dst_unit;\n                offset += 1;\n            }\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::pack_latin1_stride_alu":["#[inline(always)]\nunsafe fn pack_latin1_stride_alu(src: *const usize, dst: *mut usize){\n            let first = *src;\n            let second = *(src.add(1));\n            let third = *(src.add(2));\n            let fourth = *(src.add(3));\n            pack_alu(first, second, third, fourth, dst);\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::unlikely":["#[allow(dead_code)]\n#[inline(always)]\nunsafe fn unlikely(b: bool) -> bool{\n            b\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::unpack_alu":["#[inline(always)]\nunsafe fn unpack_alu(word: usize, second_word: usize, dst: *mut usize){\n            let first = ((0x0000_0000_FF00_0000usize & word) << 24) |\n                        ((0x0000_0000_00FF_0000usize & word) << 16) |\n                        ((0x0000_0000_0000_FF00usize & word) << 8) |\n                        (0x0000_0000_0000_00FFusize & word);\n            let second = ((0xFF00_0000_0000_0000usize & word) >> 8) |\n                         ((0x00FF_0000_0000_0000usize & word) >> 16) |\n                         ((0x0000_FF00_0000_0000usize & word) >> 24) |\n                         ((0x0000_00FF_0000_0000usize & word) >> 32);\n            let third = ((0x0000_0000_FF00_0000usize & second_word) << 24) |\n                        ((0x0000_0000_00FF_0000usize & second_word) << 16) |\n                        ((0x0000_0000_0000_FF00usize & second_word) << 8) |\n                        (0x0000_0000_0000_00FFusize & second_word);\n            let fourth = ((0xFF00_0000_0000_0000usize & second_word) >> 8) |\n                         ((0x00FF_0000_0000_0000usize & second_word) >> 16) |\n                         ((0x0000_FF00_0000_0000usize & second_word) >> 24) |\n                         ((0x0000_00FF_0000_0000usize & second_word) >> 32);\n            *dst = first;\n            *(dst.add(1)) = second;\n            *(dst.add(2)) = third;\n            *(dst.add(3)) = fourth;\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::unpack_latin1":["#[inline(always)]\npub unsafe fn $name(src: *const $src_unit, dst: *mut $dst_unit, len: usize){\n            let mut offset = 0usize;\n            // This loop is only broken out of as a `goto` forward\n            loop {\n                let mut until_alignment = {\n                    if ::std::mem::size_of::<$src_unit>() < ::std::mem::size_of::<$dst_unit>() {\n                        // unpack\n                        let src_until_alignment = (ALU_ALIGNMENT\n                            - ((src as usize) & ALU_ALIGNMENT_MASK))\n                            & ALU_ALIGNMENT_MASK;\n                        if (dst.add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {\n                            break;\n                        }\n                        src_until_alignment\n                    } else {\n                        // pack\n                        let dst_until_alignment = (ALU_ALIGNMENT\n                            - ((dst as usize) & ALU_ALIGNMENT_MASK))\n                            & ALU_ALIGNMENT_MASK;\n                        if (src.add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {\n                            break;\n                        }\n                        dst_until_alignment\n                    }\n                };\n                if until_alignment + ALU_STRIDE_SIZE <= len {\n                    while until_alignment != 0 {\n                        let code_unit = *(src.add(offset));\n                        *(dst.add(offset)) = code_unit as $dst_unit;\n                        offset += 1;\n                        until_alignment -= 1;\n                    }\n                    let len_minus_stride = len - ALU_STRIDE_SIZE;\n                    loop {\n                        $stride_fn(\n                            src.add(offset) as *const usize,\n                            dst.add(offset) as *mut usize,\n                        );\n                        offset += ALU_STRIDE_SIZE;\n                        if offset > len_minus_stride {\n                            break;\n                        }\n                    }\n                }\n                break;\n            }\n            while offset < len {\n                let code_unit = *(src.add(offset));\n                *(dst.add(offset)) = code_unit as $dst_unit;\n                offset += 1;\n            }\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::unpack_latin1_stride_alu":["#[inline(always)]\nunsafe fn unpack_latin1_stride_alu(src: *const usize, dst: *mut usize){\n            let word = *src;\n            let second_word = *(src.add(1));\n            unpack_alu(word, second_word, dst);\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::validate_ascii":["#[inline(always)]\npub fn validate_ascii(slice: &[u8]) -> Option<(u8, usize)>{\n            let src = slice.as_ptr();\n            let len = slice.len();\n            let mut offset = 0usize;\n            let mut until_alignment = (ALU_ALIGNMENT - ((src as usize) & ALU_ALIGNMENT_MASK)) & ALU_ALIGNMENT_MASK;\n            if until_alignment + ALU_STRIDE_SIZE <= len {\n                while until_alignment != 0 {\n                    let code_unit = slice[offset];\n                    if code_unit > 127 {\n                        return Some((code_unit, offset));\n                    }\n                    offset += 1;\n                    until_alignment -= 1;\n                }\n                let len_minus_stride = len - ALU_STRIDE_SIZE;\n                loop {\n                    let ptr = unsafe { src.add(offset) as *const usize };\n                    if let Some(num_ascii) = unsafe { validate_ascii_stride(ptr) } {\n                        offset += num_ascii;\n                        return Some((unsafe { *(src.add(offset)) }, offset));\n                    }\n                    offset += ALU_STRIDE_SIZE;\n                    if offset > len_minus_stride {\n                        break;\n                    }\n                }\n            }\n            while offset < len {\n                let code_unit = slice[offset];\n                if code_unit > 127 {\n                    return Some((code_unit, offset));\n                }\n                offset += 1;\n           }\n           None\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"ascii::validate_ascii_stride":["#[inline(always)]\nunsafe fn validate_ascii_stride(src: *const usize) -> Option<usize>{\n            let word = *src;\n            let second_word = *(src.add(1));\n            find_non_ascii(word, second_word)\n        }","Real(LocalPath(\"src/ascii.rs\"))"],"big5::Big5Decoder":["pub struct Big5Decoder {\n    lead: Option<u8>,\n}","Real(LocalPath(\"src/big5.rs\"))"],"big5::Big5Decoder::decode_to_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut dest_prolog = $dest_struct::new(dst);\n        let dest = match $slf.lead {\n            Some(lead) => {\n                let $lead_minus_offset = lead;\n                $slf.lead = None;\n                // Since we don't have `goto` we could use to jump into the trail\n                // handling part of the main loop, we need to repeat trail handling\n                // here.\n                match $source.check_available() {\n                    Space::Full(src_consumed_prolog) => {\n                        if last {\n                            return (DecoderResult::Malformed(1, 0),\n                                    src_consumed_prolog,\n                                    dest_prolog.written());\n                        }\n                        return (DecoderResult::InputEmpty, src_consumed_prolog, dest_prolog.written());\n                    }\n                    Space::Available(source_handle_prolog) => {\n                        match dest_prolog.$destination_check() {\n                            Space::Full(dst_written_prolog) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle_prolog.consumed(),\n                                        dst_written_prolog);\n                            }\n                            Space::Available($handle) => {\n                                let ($byte, $unread_handle_trail) = source_handle_prolog.read();\n                                // Start non-boilerplate\n                                $trail\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            },\n            None => {\n                &mut dest_prolog\n            }\n        };\n        $outermost: loop {\n            match dest.$copy_ascii(&mut $source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut $non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = {\n                            let $lead_minus_offset = {\n                                // Start non-boilerplate\n                                $lead\n                                // End non-boilerplate\n                            };\n                            match $source.check_available() {\n                                Space::Full(src_consumed_trail) => {\n                                    if last {\n                                        return (DecoderResult::Malformed(1, 0),\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    $slf.lead = Some($lead_minus_offset);\n                                    return (DecoderResult::InputEmpty,\n                                            src_consumed_trail,\n                                            $handle.written());\n                                }\n                                Space::Available(source_handle_trail) => {\n                                    let ($byte, $unread_handle_trail) = source_handle_trail.read();\n                                    // Start non-boilerplate\n                                    $trail\n                                    // End non-boilerplate\n                                }\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (DecoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (DecoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut b, unread_handle) = source_handle.read();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            if b > 127 {\n                                                $non_ascii = b;\n                                                $handle = destination_handle;\n                                                continue 'middle;\n                                            }\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_ascii(b);\n                                            if $ascii_punctuation && b < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (DecoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (DecoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (b_again, _unread_handle_again) =\n                                                                        source_handle_again.read();\n                                                                    b = b_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue $outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"big5::Big5Decoder::decode_to_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut dest_prolog = $dest_struct::new(dst);\n        let dest = match $slf.lead {\n            Some(lead) => {\n                let $lead_minus_offset = lead;\n                $slf.lead = None;\n                // Since we don't have `goto` we could use to jump into the trail\n                // handling part of the main loop, we need to repeat trail handling\n                // here.\n                match $source.check_available() {\n                    Space::Full(src_consumed_prolog) => {\n                        if last {\n                            return (DecoderResult::Malformed(1, 0),\n                                    src_consumed_prolog,\n                                    dest_prolog.written());\n                        }\n                        return (DecoderResult::InputEmpty, src_consumed_prolog, dest_prolog.written());\n                    }\n                    Space::Available(source_handle_prolog) => {\n                        match dest_prolog.$destination_check() {\n                            Space::Full(dst_written_prolog) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle_prolog.consumed(),\n                                        dst_written_prolog);\n                            }\n                            Space::Available($handle) => {\n                                let ($byte, $unread_handle_trail) = source_handle_prolog.read();\n                                // Start non-boilerplate\n                                $trail\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            },\n            None => {\n                &mut dest_prolog\n            }\n        };\n        $outermost: loop {\n            match dest.$copy_ascii(&mut $source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut $non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = {\n                            let $lead_minus_offset = {\n                                // Start non-boilerplate\n                                $lead\n                                // End non-boilerplate\n                            };\n                            match $source.check_available() {\n                                Space::Full(src_consumed_trail) => {\n                                    if last {\n                                        return (DecoderResult::Malformed(1, 0),\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    $slf.lead = Some($lead_minus_offset);\n                                    return (DecoderResult::InputEmpty,\n                                            src_consumed_trail,\n                                            $handle.written());\n                                }\n                                Space::Available(source_handle_trail) => {\n                                    let ($byte, $unread_handle_trail) = source_handle_trail.read();\n                                    // Start non-boilerplate\n                                    $trail\n                                    // End non-boilerplate\n                                }\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (DecoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (DecoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut b, unread_handle) = source_handle.read();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            if b > 127 {\n                                                $non_ascii = b;\n                                                $handle = destination_handle;\n                                                continue 'middle;\n                                            }\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_ascii(b);\n                                            if $ascii_punctuation && b < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (DecoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (DecoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (b_again, _unread_handle_again) =\n                                                                        source_handle_again.read();\n                                                                    b = b_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue $outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"big5::Big5Decoder::in_neutral_state":["pub fn in_neutral_state(&self) -> bool{\n        self.lead.is_none()\n    }","Real(LocalPath(\"src/big5.rs\"))"],"big5::Big5Decoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        // If there is a lead but the next byte isn't a valid trail, an\n        // error is generated for the lead (+1). Then another iteration checks\n        // space, which needs +1 to account for the possibility of astral\n        // output or combining pair.\n        checked_add(1, self.plus_one_if_lead(byte_length))\n    }","Real(LocalPath(\"src/big5.rs\"))"],"big5::Big5Decoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        // If there is a lead but the next byte isn't a valid trail, an\n        // error is generated for the lead (+(1*3)). Then another iteration\n        // checks space, which needs +3 to account for the possibility of astral\n        // output or combining pair. In between start and end, the worst case\n        // is that every byte is bad: *3.\n        checked_add(3, checked_mul(3, self.plus_one_if_lead(byte_length)))\n    }","Real(LocalPath(\"src/big5.rs\"))"],"big5::Big5Decoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        // No need to account for REPLACEMENT CHARACTERS.\n        // Cases:\n        // ASCII: 1 to 1\n        // Valid pair: 2 to 2, 2 to 3 or 2 to 4, i.e. worst case 2 to 4\n        // lead set and first byte is trail: 1 to 4 worst case\n        //\n        // When checking for space for the last byte:\n        // no lead: the last byte must be ASCII (or fatal error): 1 to 1\n        // lead set: space for 4 bytes was already checked when reading the\n        // lead, hence the last lead and the last trail together are worst\n        // case 2 to 4.\n        //\n        // If lead set and the input is a single trail byte, the worst-case\n        // output is 4, so we need to add one before multiplying if lead is\n        // set.\n        //\n        // Finally, add two so that if input is non-zero, the output is at\n        // least 4.\n        checked_add(2, checked_mul(2, self.plus_one_if_lead(byte_length)))\n    }","Real(LocalPath(\"src/big5.rs\"))"],"big5::Big5Decoder::new":["pub fn new() -> VariantDecoder{\n        VariantDecoder::Big5(Big5Decoder { lead: None })\n    }","Real(LocalPath(\"src/big5.rs\"))"],"big5::Big5Decoder::plus_one_if_lead":["fn plus_one_if_lead(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_add(match self.lead {\n            None => 0,\n            Some(_) => 1,\n        })\n    }","Real(LocalPath(\"src/big5.rs\"))"],"big5::Big5Encoder":["pub struct Big5Encoder;","Real(LocalPath(\"src/big5.rs\"))"],"big5::Big5Encoder::encode_from_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 _last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut dest = ByteDestination::new(dst);\n        'outermost: loop {\n            match $source.$copy_ascii(&mut dest) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = match non_ascii {\n                            NonAscii::BmpExclAscii($bmp) => {\n                                // Start non-boilerplate\n                                $bmp_body\n                                // End non-boilerplate\n                            }\n                            NonAscii::Astral($astral) => {\n                                // Start non-boilerplate\n                                $astral_body\n                                // End non-boilerplate\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (EncoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (EncoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut c, unread_handle) = source_handle.read_enum();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            let ascii = match c {\n                                                Unicode::NonAscii(non_ascii_again) => {\n                                                    non_ascii = non_ascii_again;\n                                                    $handle = destination_handle;\n                                                    continue 'middle;\n                                                }\n                                                Unicode::Ascii(a) => a,\n                                            };\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_one(ascii);\n                                            if $ascii_punctuation && ascii < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (EncoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (EncoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (c_again, _unread_handle_again) =\n                                                                        source_handle_again.read_enum();\n                                                                    c = c_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"big5::Big5Encoder::encode_from_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 _last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut dest = ByteDestination::new(dst);\n        'outermost: loop {\n            match $source.$copy_ascii(&mut dest) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = match non_ascii {\n                            NonAscii::BmpExclAscii($bmp) => {\n                                // Start non-boilerplate\n                                $bmp_body\n                                // End non-boilerplate\n                            }\n                            NonAscii::Astral($astral) => {\n                                // Start non-boilerplate\n                                $astral_body\n                                // End non-boilerplate\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (EncoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (EncoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut c, unread_handle) = source_handle.read_enum();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            let ascii = match c {\n                                                Unicode::NonAscii(non_ascii_again) => {\n                                                    non_ascii = non_ascii_again;\n                                                    $handle = destination_handle;\n                                                    continue 'middle;\n                                                }\n                                                Unicode::Ascii(a) => a,\n                                            };\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_one(ascii);\n                                            if $ascii_punctuation && ascii < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (EncoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (EncoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (c_again, _unread_handle_again) =\n                                                                        source_handle_again.read_enum();\n                                                                    c = c_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"big5::Big5Encoder::max_buffer_length_from_utf16_without_replacement":["pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        // Astral: 2 to 2\n        // ASCII: 1 to 1\n        // Other: 1 to 2\n        u16_length.checked_mul(2)\n    }","Real(LocalPath(\"src/big5.rs\"))"],"big5::Big5Encoder::max_buffer_length_from_utf8_without_replacement":["pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        // Astral: 4 to 2\n        // Upper BMP: 3 to 2\n        // Lower BMP: 2 to 2\n        // ASCII: 1 to 1\n        byte_length.checked_add(1)\n    }","Real(LocalPath(\"src/big5.rs\"))"],"big5::Big5Encoder::new":["pub fn new(encoding: &'static Encoding) -> Encoder{\n        Encoder::new(encoding, VariantEncoder::Big5(Big5Encoder))\n    }","Real(LocalPath(\"src/big5.rs\"))"],"checked_add":["#[inline(always)]\nfn checked_add(num: usize, opt: Option<usize>) -> Option<usize>{\n    if let Some(n) = opt {\n        n.checked_add(num)\n    } else {\n        None\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"checked_add_opt":["#[inline(always)]\nfn checked_add_opt(one: Option<usize>, other: Option<usize>) -> Option<usize>{\n    if let Some(n) = one {\n        checked_add(n, other)\n    } else {\n        None\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"checked_div":["#[inline(always)]\nfn checked_div(opt: Option<usize>, num: usize) -> Option<usize>{\n    if let Some(n) = opt {\n        n.checked_div(num)\n    } else {\n        None\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"checked_min":["#[inline(always)]\nfn checked_min(one: Option<usize>, other: Option<usize>) -> Option<usize>{\n    if let Some(a) = one {\n        if let Some(b) = other {\n            Some(::std::cmp::min(a, b))\n        } else {\n            Some(a)\n        }\n    } else {\n        other\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"checked_mul":["#[inline(always)]\nfn checked_mul(num: usize, opt: Option<usize>) -> Option<usize>{\n    if let Some(n) = opt {\n        n.checked_mul(num)\n    } else {\n        None\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"checked_next_power_of_two":["#[inline(always)]\nfn checked_next_power_of_two(opt: Option<usize>) -> Option<usize>{\n    opt.map(|n| n.next_power_of_two())\n}","Real(LocalPath(\"src/lib.rs\"))"],"data::SingleByteData":["#[repr(align(64))]\npub struct SingleByteData {\n    pub ibm866: [u16; 128],\n    pub iso_8859_2: [u16; 128],\n    pub iso_8859_3: [u16; 128],\n    pub iso_8859_4: [u16; 128],\n    pub iso_8859_5: [u16; 128],\n    pub iso_8859_6: [u16; 128],\n    pub iso_8859_7: [u16; 128],\n    pub iso_8859_8: [u16; 128],\n    pub iso_8859_10: [u16; 128],\n    pub iso_8859_13: [u16; 128],\n    pub iso_8859_14: [u16; 128],\n    pub iso_8859_15: [u16; 128],\n    pub iso_8859_16: [u16; 128],\n    pub koi8_r: [u16; 128],\n    pub koi8_u: [u16; 128],\n    pub macintosh: [u16; 128],\n    pub windows_874: [u16; 128],\n    pub windows_1250: [u16; 128],\n    pub windows_1251: [u16; 128],\n    pub windows_1252: [u16; 128],\n    pub windows_1253: [u16; 128],\n    pub windows_1254: [u16; 128],\n    pub windows_1255: [u16; 128],\n    pub windows_1256: [u16; 128],\n    pub windows_1257: [u16; 128],\n    pub windows_1258: [u16; 128],\n    pub x_mac_cyrillic: [u16; 128],\n}","Real(LocalPath(\"src/data.rs\"))"],"data::big5_astral_encode":["#[inline(always)]\npub fn big5_astral_encode(low_bits: u16) -> Option<usize>{\n    match low_bits {\n        0x00CC => Some(11205 - 942),\n        0x008A => Some(11207 - 942),\n        0x7607 => Some(11213 - 942),\n        _ => {\n            let mut i = 18997 - 942;\n            while i < BIG5_LOW_BITS.len() - 1 {\n                if BIG5_LOW_BITS[i] == low_bits && big5_is_astral(i) {\n                    return Some(i);\n                }\n                i += 1;\n            }\n            None\n        }\n    }\n}","Real(LocalPath(\"src/data.rs\"))"],"data::big5_box_encode":["#[inline(always)]\npub fn big5_box_encode(bmp: u16) -> Option<usize>{\n    position(&BIG5_LOW_BITS[(18963 - 942)..(18992 - 942)], bmp).map(|x| x + 18963)\n}","Real(LocalPath(\"src/data.rs\"))"],"data::big5_is_astral":["#[inline(always)]\npub fn big5_is_astral(rebased_pointer: usize) -> bool{\n    (BIG5_ASTRALNESS[rebased_pointer >> 5] & (1 << (rebased_pointer & 0x1F))) != 0\n}","Real(LocalPath(\"src/data.rs\"))"],"data::big5_level1_hanzi_encode":["#[cfg(not(any(\n    feature = \"less-slow-big5-hanzi-encode\",\n    feature = \"fast-big5-hanzi-encode\"\n)))]\n#[inline(always)]\npub fn big5_level1_hanzi_encode(bmp: u16) -> Option<(u8, u8)>{\n    if super::in_inclusive_range16(bmp, 0x4E00, 0x9FB1) {\n        if let Some(hanzi_pointer) = position(&BIG5_LOW_BITS[(5495 - 942)..(10951 - 942)], bmp) {\n            let lead = hanzi_pointer / 157 + 0xA4;\n            let remainder = hanzi_pointer % 157;\n            let trail = if remainder < 0x3F {\n                remainder + 0x40\n            } else {\n                remainder + 0x62\n            };\n            return Some((lead as u8, trail as u8));\n        }\n        match bmp {\n            0x4E5A => {\n                return Some((0xC8, 0x7B));\n            }\n            0x5202 => {\n                return Some((0xC8, 0x7D));\n            }\n            0x9FB0 => {\n                return Some((0xC8, 0xA1));\n            }\n            0x5188 => {\n                return Some((0xC8, 0xA2));\n            }\n            0x9FB1 => {\n                return Some((0xC8, 0xA3));\n            }\n            _ => {\n                return None;\n            }\n        }\n    }\n    None\n}","Real(LocalPath(\"src/data.rs\"))"],"data::big5_low_bits":["#[inline(always)]\npub fn big5_low_bits(rebased_pointer: usize) -> u16{\n    if rebased_pointer < BIG5_LOW_BITS.len() {\n        BIG5_LOW_BITS[rebased_pointer]\n    } else {\n        0\n    }\n}","Real(LocalPath(\"src/data.rs\"))"],"data::big5_other_encode":["#[cfg(not(feature = \"fast-big5-hanzi-encode\"))]\n#[inline(always)]\npub fn big5_other_encode(bmp: u16) -> Option<usize>{\n    if 0x4491 == bmp {\n        return Some(11209);\n    }\n    if let Some(pos) = position(&BIG5_LOW_BITS[(5024 - 942)..(5466 - 942)], bmp) {\n        return Some(pos + 5024);\n    }\n    if let Some(pos) = position(&BIG5_LOW_BITS[(10896 - 942)..(11205 - 942)], bmp) {\n        return Some(pos + 10896);\n    }\n    if let Some(pos) = position(&BIG5_LOW_BITS[(11254 - 942)..(18963 - 942)], bmp) {\n        return Some(pos + 11254);\n    }\n    let mut i = 18996 - 942;\n    while i < BIG5_LOW_BITS.len() {\n        if BIG5_LOW_BITS[i] == bmp && !big5_is_astral(i) {\n            return Some(i + 942);\n        }\n        i += 1;\n    }\n    None\n}","Real(LocalPath(\"src/data.rs\"))"],"data::cp949_left_hangul_decode":["#[inline(always)]\npub fn cp949_left_hangul_decode(pointer: u16) -> u16{\n    map_with_ranges(\n        &CP949_LEFT_HANGUL_POINTERS[..],\n        &CP949_LEFT_HANGUL_OFFSETS[..],\n        pointer,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::cp949_left_hangul_encode":["#[cfg(not(feature = \"fast-hangul-encode\"))]\n#[inline(always)]\npub fn cp949_left_hangul_encode(bmp: u16) -> u16{\n    map_with_ranges(\n        &CP949_LEFT_HANGUL_OFFSETS[..],\n        &CP949_LEFT_HANGUL_POINTERS[..],\n        bmp,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::cp949_top_hangul_decode":["#[inline(always)]\npub fn cp949_top_hangul_decode(pointer: u16) -> u16{\n    map_with_ranges(\n        &CP949_TOP_HANGUL_POINTERS[..],\n        &CP949_TOP_HANGUL_OFFSETS[..],\n        pointer,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::cp949_top_hangul_encode":["#[cfg(not(feature = \"fast-hangul-encode\"))]\n#[inline(always)]\npub fn cp949_top_hangul_encode(bmp: u16) -> u16{\n    map_with_ranges(\n        &CP949_TOP_HANGUL_OFFSETS[..],\n        &CP949_TOP_HANGUL_POINTERS[..],\n        bmp,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gb18030_range_decode":["#[inline(always)]\npub fn gb18030_range_decode(pointer: u16) -> u16{\n    map_with_ranges(\n        &GB18030_RANGE_POINTERS[..],\n        &GB18030_RANGE_OFFSETS[..],\n        pointer,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gb18030_range_encode":["#[inline(always)]\npub fn gb18030_range_encode(bmp: u16) -> usize{\n    if bmp == 0xE7C7 {\n        return 7457;\n    }\n    map_with_ranges(&GB18030_RANGE_OFFSETS[..], &GB18030_RANGE_POINTERS[..], bmp) as usize\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gb2312_level1_hanzi_encode":["#[cfg(not(any(\n    feature = \"less-slow-gb-hanzi-encode\",\n    feature = \"fast-gb-hanzi-encode\"\n)))]\n#[inline(always)]\npub fn gb2312_level1_hanzi_encode(bmp: u16) -> Option<(u8, u8)>{\n    position(&GB2312_HANZI[..(94 * (0xD8 - 0xB0) - 5)], bmp).map(|hanzi_pointer| {\n        let hanzi_lead = (hanzi_pointer / 94) + 0xB0;\n        let hanzi_trail = (hanzi_pointer % 94) + 0xA1;\n        (hanzi_lead as u8, hanzi_trail as u8)\n    })\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gb2312_level2_hanzi_encode":["#[cfg(not(feature = \"fast-gb-hanzi-encode\"))]\n#[inline(always)]\npub fn gb2312_level2_hanzi_encode(bmp: u16) -> Option<usize>{\n    // TODO: optimize\n    position(&GB2312_HANZI[(94 * (0xD8 - 0xB0))..], bmp)\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gb2312_other_decode":["#[inline(always)]\npub fn gb2312_other_decode(pointer: u16) -> u16{\n    map_with_ranges(\n        &GB2312_OTHER_POINTERS[..GB2312_OTHER_POINTERS.len() - 1],\n        &GB2312_OTHER_UNSORTED_OFFSETS[..],\n        pointer,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gb2312_other_encode":["#[inline(always)]\npub fn gb2312_other_encode(bmp: u16) -> Option<u16>{\n    map_with_unsorted_ranges(\n        &GB2312_OTHER_UNSORTED_OFFSETS[..],\n        &GB2312_OTHER_POINTERS[..],\n        bmp,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gbk_left_ideograph_decode":["#[inline(always)]\npub fn gbk_left_ideograph_decode(pointer: u16) -> u16{\n    map_with_ranges(\n        &GBK_LEFT_IDEOGRAPH_POINTERS[..],\n        &GBK_LEFT_IDEOGRAPH_OFFSETS[..],\n        pointer,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gbk_left_ideograph_encode":["#[cfg(not(feature = \"fast-gb-hanzi-encode\"))]\n#[inline(always)]\npub fn gbk_left_ideograph_encode(bmp: u16) -> u16{\n    map_with_ranges(\n        &GBK_LEFT_IDEOGRAPH_OFFSETS[..],\n        &GBK_LEFT_IDEOGRAPH_POINTERS[..],\n        bmp,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gbk_other_decode":["#[inline(always)]\npub fn gbk_other_decode(pointer: u16) -> u16{\n    map_with_ranges(\n        &GBK_OTHER_POINTERS[..GBK_OTHER_POINTERS.len() - 1],\n        &GBK_OTHER_UNSORTED_OFFSETS[..],\n        pointer,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gbk_other_encode":["#[inline(always)]\npub fn gbk_other_encode(bmp: u16) -> Option<u16>{\n    map_with_unsorted_ranges(\n        &GBK_OTHER_UNSORTED_OFFSETS[..],\n        &GBK_OTHER_POINTERS[..],\n        bmp,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gbk_top_ideograph_decode":["#[inline(always)]\npub fn gbk_top_ideograph_decode(pointer: u16) -> u16{\n    map_with_ranges(\n        &GBK_TOP_IDEOGRAPH_POINTERS[..],\n        &GBK_TOP_IDEOGRAPH_OFFSETS[..],\n        pointer,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::gbk_top_ideograph_encode":["#[cfg(not(feature = \"fast-gb-hanzi-encode\"))]\n#[inline(always)]\npub fn gbk_top_ideograph_encode(bmp: u16) -> u16{\n    map_with_ranges(\n        &GBK_TOP_IDEOGRAPH_OFFSETS[..],\n        &GBK_TOP_IDEOGRAPH_POINTERS[..],\n        bmp,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::ibm_symbol_encode":["#[inline(always)]\npub fn ibm_symbol_encode(bmp: u16) -> Option<usize>{\n    position(&JIS0208_SYMBOLS[IBM_SYMBOL_START..IBM_SYMBOL_END], bmp)\n        .map(|x| x + IBM_SYMBOL_POINTER_START)\n}","Real(LocalPath(\"src/data.rs\"))"],"data::jis0208_level1_kanji_euc_jp_encode":["#[cfg(not(any(feature = \"less-slow-kanji-encode\", feature = \"fast-kanji-encode\")))]\n#[inline(always)]\npub fn jis0208_level1_kanji_euc_jp_encode(bmp: u16) -> Option<(u8, u8)>{\n    position(&JIS0208_LEVEL1_KANJI[..], bmp).map(|kanji_pointer| {\n        let lead = (kanji_pointer / 94) + 0xB0;\n        let trail = (kanji_pointer % 94) + 0xA1;\n        (lead as u8, trail as u8)\n    })\n}","Real(LocalPath(\"src/data.rs\"))"],"data::jis0208_level1_kanji_iso_2022_jp_encode":["#[cfg(not(any(feature = \"less-slow-kanji-encode\", feature = \"fast-kanji-encode\")))]\n#[inline(always)]\npub fn jis0208_level1_kanji_iso_2022_jp_encode(bmp: u16) -> Option<(u8, u8)>{\n    position(&JIS0208_LEVEL1_KANJI[..], bmp).map(|kanji_pointer| {\n        let lead = (kanji_pointer / 94) + (0xB0 - 0x80);\n        let trail = (kanji_pointer % 94) + 0x21;\n        (lead as u8, trail as u8)\n    })\n}","Real(LocalPath(\"src/data.rs\"))"],"data::jis0208_level1_kanji_shift_jis_encode":["#[cfg(not(any(feature = \"less-slow-kanji-encode\", feature = \"fast-kanji-encode\")))]\n#[inline(always)]\npub fn jis0208_level1_kanji_shift_jis_encode(bmp: u16) -> Option<(u8, u8)>{\n    position(&JIS0208_LEVEL1_KANJI[..], bmp).map(|kanji_pointer| {\n        let pointer = 1410 + kanji_pointer;\n        let lead = pointer / 188;\n        let lead_offset = if lead < 0x1F { 0x81 } else { 0xC1 };\n        let trail = pointer % 188;\n        let trail_offset = if trail < 0x3F { 0x40 } else { 0x41 };\n        ((lead + lead_offset) as u8, (trail + trail_offset) as u8)\n    })\n}","Real(LocalPath(\"src/data.rs\"))"],"data::jis0208_level2_and_additional_kanji_encode":["#[cfg(not(feature = \"fast-kanji-encode\"))]\n#[inline(always)]\npub fn jis0208_level2_and_additional_kanji_encode(bmp: u16) -> Option<usize>{\n    position(&JIS0208_LEVEL2_AND_ADDITIONAL_KANJI[..], bmp)\n}","Real(LocalPath(\"src/data.rs\"))"],"data::jis0208_range_decode":["#[inline(always)]\npub fn jis0208_range_decode(pointer: usize) -> Option<u16>{\n    let mut i = 0;\n    while i < JIS0208_RANGE_TRIPLES.len() {\n        let start = JIS0208_RANGE_TRIPLES[i] as usize;\n        let length = JIS0208_RANGE_TRIPLES[i + 1] as usize;\n        let pointer_minus_start = pointer.wrapping_sub(start);\n        if pointer_minus_start < length {\n            let offset = JIS0208_RANGE_TRIPLES[i + 2] as usize;\n            return Some((pointer_minus_start + offset) as u16);\n        }\n        i += 3;\n    }\n    None\n}","Real(LocalPath(\"src/data.rs\"))"],"data::jis0208_range_encode":["#[inline(always)]\npub fn jis0208_range_encode(bmp: u16) -> Option<usize>{\n    let mut i = 0;\n    while i < JIS0208_RANGE_TRIPLES.len() {\n        let start = JIS0208_RANGE_TRIPLES[i + 2] as usize;\n        let length = JIS0208_RANGE_TRIPLES[i + 1] as usize;\n        let bmp_minus_start = (bmp as usize).wrapping_sub(start);\n        if bmp_minus_start < length {\n            let offset = JIS0208_RANGE_TRIPLES[i] as usize;\n            return Some(bmp_minus_start + offset);\n        }\n        i += 3;\n    }\n    None\n}","Real(LocalPath(\"src/data.rs\"))"],"data::jis0208_symbol_decode":["pub fn jis0208_symbol_decode(pointer: usize) -> Option<u16>{\n    let mut i = 0;\n    while i < JIS0208_SYMBOL_TRIPLES.len() {\n        let start = JIS0208_SYMBOL_TRIPLES[i] as usize;\n        let length = JIS0208_SYMBOL_TRIPLES[i + 1] as usize;\n        let pointer_minus_start = pointer.wrapping_sub(start);\n        if pointer_minus_start < length {\n            let offset = JIS0208_SYMBOL_TRIPLES[i + 2] as usize;\n            return Some(JIS0208_SYMBOLS[pointer_minus_start + offset]);\n        }\n        i += 3;\n    }\n    None\n}","Real(LocalPath(\"src/data.rs\"))"],"data::jis0208_symbol_encode":["/// Prefers Shift_JIS pointers for the three symbols that are in both ranges.\n#[inline(always)]\npub fn jis0208_symbol_encode(bmp: u16) -> Option<usize>{\n    let mut i = 0;\n    while i < JIS0208_SYMBOL_TRIPLES.len() {\n        let pointer_start = JIS0208_SYMBOL_TRIPLES[i] as usize;\n        let length = JIS0208_SYMBOL_TRIPLES[i + 1] as usize;\n        let symbol_start = JIS0208_SYMBOL_TRIPLES[i + 2] as usize;\n        let symbol_end = symbol_start + length;\n        let mut symbol_pos = symbol_start;\n        while symbol_pos < symbol_end {\n            if JIS0208_SYMBOLS[symbol_pos] == bmp {\n                return Some(symbol_pos - symbol_start + pointer_start);\n            }\n            symbol_pos += 1;\n        }\n        i += 3;\n    }\n    None\n}","Real(LocalPath(\"src/data.rs\"))"],"data::jis0212_accented_decode":["pub fn jis0212_accented_decode(pointer: usize) -> Option<u16>{\n    let mut i = 0;\n    while i < JIS0212_ACCENTED_TRIPLES.len() {\n        let start = JIS0212_ACCENTED_TRIPLES[i] as usize;\n        let length = JIS0212_ACCENTED_TRIPLES[i + 1] as usize;\n        let pointer_minus_start = pointer.wrapping_sub(start);\n        if pointer_minus_start < length {\n            let offset = JIS0212_ACCENTED_TRIPLES[i + 2] as usize;\n            let candidate = JIS0212_ACCENTED[pointer_minus_start + offset];\n            if candidate == 0 {\n                return None;\n            }\n            return Some(candidate);\n        }\n        i += 3;\n    }\n    None\n}","Real(LocalPath(\"src/data.rs\"))"],"data::ksx1001_other_decode":["#[inline(always)]\npub fn ksx1001_other_decode(pointer: u16) -> u16{\n    map_with_ranges(\n        &KSX1001_OTHER_POINTERS[..KSX1001_OTHER_POINTERS.len() - 1],\n        &KSX1001_OTHER_UNSORTED_OFFSETS[..],\n        pointer,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::ksx1001_other_encode":["#[inline(always)]\npub fn ksx1001_other_encode(bmp: u16) -> Option<u16>{\n    map_with_unsorted_ranges(\n        &KSX1001_OTHER_UNSORTED_OFFSETS[..],\n        &KSX1001_OTHER_POINTERS[..],\n        bmp,\n    )\n}","Real(LocalPath(\"src/data.rs\"))"],"data::map_with_ranges":["#[inline(always)]\nfn map_with_ranges(haystack: &[u16], other: &[u16], needle: u16) -> u16{\n    debug_assert_eq!(haystack.len(), other.len());\n    match haystack.binary_search(&needle) {\n        Ok(i) => other[i],\n        Err(i) => other[i - 1] + (needle - haystack[i - 1]),\n    }\n}","Real(LocalPath(\"src/data.rs\"))"],"data::map_with_unsorted_ranges":["#[inline(always)]\nfn map_with_unsorted_ranges(haystack: &[u16], other: &[u16], needle: u16) -> Option<u16>{\n    debug_assert_eq!(haystack.len() + 1, other.len());\n    for i in 0..haystack.len() {\n        let start = other[i];\n        let end = other[i + 1];\n        let length = end - start;\n        let offset = needle.wrapping_sub(haystack[i]);\n        if offset < length {\n            return Some(start + offset);\n        }\n    }\n    None\n}","Real(LocalPath(\"src/data.rs\"))"],"data::mul_94":["#[inline(always)]\npub fn mul_94(lead: u8) -> usize{\n    lead as usize * 94\n}","Real(LocalPath(\"src/data.rs\"))"],"data::position":["#[inline(always)]\npub fn position(haystack: &[u16], needle: u16) -> Option<usize>{\n    haystack.iter().position(|&x| x == needle)\n}","Real(LocalPath(\"src/data.rs\"))"],"euc_jp::EucJpDecoder":["pub struct EucJpDecoder {\n    pending: EucJpPending,\n}","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpDecoder::decode_to_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut dest = $dest_struct::new(dst);\n        while !$slf.pending.is_none() {\n            match $source.check_available() {\n                Space::Full(src_consumed) => {\n                    if last {\n                        // Start non-boilerplate\n                        let count = $slf.pending.count();\n                        $slf.pending = EucJpPending::None;\n                        return (DecoderResult::Malformed(count as u8, 0),\n                                src_consumed,\n                                dest.written());\n                        // End non-boilerplate\n                    }\n                    return (DecoderResult::InputEmpty, src_consumed, dest.written());\n                }\n                Space::Available(source_handle) => {\n                    match dest.check_space_bmp() {\n                        Space::Full(dst_written) => {\n                            return (DecoderResult::OutputFull,\n                                    source_handle.consumed(),\n                                    dst_written);\n                        }\n                        Space::Available($handle) => {\n                            let ($byte, $unread_handle_trail) = source_handle.read();\n                            match $slf.pending {\n                                EucJpPending::Jis0208Lead($jis0208_lead_minus_offset) => {\n                                    $slf.pending = EucJpPending::None;\n                                    // Start non-boilerplate\n                                    $jis0802_trail_body\n                                    // End non-boilerplate\n                                }\n                                EucJpPending::Jis0212Shift => {\n                                    $slf.pending = EucJpPending::None;\n                                    let $lead = $byte;\n                                    let $unread_handle_jis0212 = $unread_handle_trail;\n                                    let $jis0212_lead_minus_offset = {\n                                        // Start non-boilerplate\n                                        $jis0812_lead_body\n                                        // End non-boilerplate\n                                    };\n                                    $slf.pending =\n                                        EucJpPending::Jis0212Lead($jis0212_lead_minus_offset);\n                                    $handle.commit()\n                                }\n                                EucJpPending::Jis0212Lead($jis0212_lead_minus_offset) => {\n                                    $slf.pending = EucJpPending::None;\n                                    // Start non-boilerplate\n                                    $jis0812_trail_body\n                                    // End non-boilerplate\n                                }\n                                EucJpPending::HalfWidthKatakana => {\n                                    $slf.pending = EucJpPending::None;\n                                    // Start non-boilerplate\n                                    $half_width_katakana_body\n                                    // End non-boilerplate\n                                }\n                                EucJpPending::None => unreachable!(\"Checked in loop condition\"),\n                            };\n                        }\n                    }\n                }\n            }\n        }\n        'outermost: loop {\n            match dest.copy_ascii_from_check_space_bmp(&mut $source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut $non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = {\n                            // If lead is between 0xA1 and 0xFE, inclusive,\n                            // subtract 0xA1. Else if lead is 0x8E, handle the\n                            // next byte as half-width Katakana. Else if lead is\n                            // 0x8F, expect JIS 0212.\n                            let $jis0208_lead_minus_offset = $non_ascii.wrapping_sub(0xA1);\n                            if $jis0208_lead_minus_offset <= (0xFE - 0xA1) {\n                                // JIS 0208\n                                match $source.check_available() {\n                                    Space::Full(src_consumed_trail) => {\n                                        if last {\n                                            return (DecoderResult::Malformed(1, 0),\n                                                    src_consumed_trail,\n                                                    $handle.written());\n                                        }\n                                        $slf.pending =\n                                            EucJpPending::Jis0208Lead($jis0208_lead_minus_offset);\n                                        return (DecoderResult::InputEmpty,\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    Space::Available(source_handle_trail) => {\n                                        let ($byte, $unread_handle_trail) =\n                                            source_handle_trail.read();\n                                        // Start non-boilerplate\n                                        $jis0802_trail_body\n                                        // End non-boilerplate\n                                    }\n                                }\n                            } else if $non_ascii == 0x8F {\n                                match $source.check_available() {\n                                    Space::Full(src_consumed_jis0212) => {\n                                        if last {\n                                            return (DecoderResult::Malformed(1, 0),\n                                                    src_consumed_jis0212,\n                                                    $handle.written());\n                                        }\n                                        $slf.pending = EucJpPending::Jis0212Shift;\n                                        return (DecoderResult::InputEmpty,\n                                                src_consumed_jis0212,\n                                                $handle.written());\n                                    }\n                                    Space::Available(source_handle_jis0212) => {\n                                        let ($lead, $unread_handle_jis0212) =\n                                            source_handle_jis0212.read();\n                                        let $jis0212_lead_minus_offset = {\n                                            // Start non-boilerplate\n                                            $jis0812_lead_body\n                                            // End non-boilerplate\n                                        };\n                                        match $unread_handle_jis0212.commit().check_available() {\n                                            Space::Full(src_consumed_trail) => {\n                                                if last {\n                                                    return (DecoderResult::Malformed(2, 0),\n                                                            src_consumed_trail,\n                                                            $handle.written());\n                                                }\n                                                $slf.pending = EucJpPending::Jis0212Lead($jis0212_lead_minus_offset);\n                                                return (DecoderResult::InputEmpty,\n                                                        src_consumed_trail,\n                                                        $handle.written());\n                                            }\n                                            Space::Available(source_handle_trail) => {\n                                                let ($byte, $unread_handle_trail) =\n                                                    source_handle_trail.read();\n                                                // Start non-boilerplate\n                                                $jis0812_trail_body\n                                                // End non-boilerplate\n                                            }\n                                        }\n                                    }\n                                }\n                            } else if $non_ascii == 0x8E {\n                                match $source.check_available() {\n                                    Space::Full(src_consumed_trail) => {\n                                        if last {\n                                            return (DecoderResult::Malformed(1, 0),\n                                                    src_consumed_trail,\n                                                    $handle.written());\n                                        }\n                                        $slf.pending = EucJpPending::HalfWidthKatakana;\n                                        return (DecoderResult::InputEmpty,\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    Space::Available(source_handle_trail) => {\n                                        let ($byte, $unread_handle_trail) =\n                                            source_handle_trail.read();\n                                        // Start non-boilerplate\n                                        $half_width_katakana_body\n                                        // End non-boilerplate\n                                    }\n                                }\n                            } else {\n                                return (DecoderResult::Malformed(1, 0),\n                                        $source.consumed(),\n                                        $handle.written());\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (DecoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.check_space_bmp() {\n                                    Space::Full(dst_written) => {\n                                        return (DecoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(destination_handle) => {\n                                        let (b, _) = source_handle.read();\n                                        'innermost: loop {\n                                            if b > 127 {\n                                                $non_ascii = b;\n                                                $handle = destination_handle;\n                                                continue 'middle;\n                                            }\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            destination_handle.write_ascii(b);\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"euc_jp::EucJpDecoder::decode_to_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut dest = $dest_struct::new(dst);\n        while !$slf.pending.is_none() {\n            match $source.check_available() {\n                Space::Full(src_consumed) => {\n                    if last {\n                        // Start non-boilerplate\n                        let count = $slf.pending.count();\n                        $slf.pending = EucJpPending::None;\n                        return (DecoderResult::Malformed(count as u8, 0),\n                                src_consumed,\n                                dest.written());\n                        // End non-boilerplate\n                    }\n                    return (DecoderResult::InputEmpty, src_consumed, dest.written());\n                }\n                Space::Available(source_handle) => {\n                    match dest.check_space_bmp() {\n                        Space::Full(dst_written) => {\n                            return (DecoderResult::OutputFull,\n                                    source_handle.consumed(),\n                                    dst_written);\n                        }\n                        Space::Available($handle) => {\n                            let ($byte, $unread_handle_trail) = source_handle.read();\n                            match $slf.pending {\n                                EucJpPending::Jis0208Lead($jis0208_lead_minus_offset) => {\n                                    $slf.pending = EucJpPending::None;\n                                    // Start non-boilerplate\n                                    $jis0802_trail_body\n                                    // End non-boilerplate\n                                }\n                                EucJpPending::Jis0212Shift => {\n                                    $slf.pending = EucJpPending::None;\n                                    let $lead = $byte;\n                                    let $unread_handle_jis0212 = $unread_handle_trail;\n                                    let $jis0212_lead_minus_offset = {\n                                        // Start non-boilerplate\n                                        $jis0812_lead_body\n                                        // End non-boilerplate\n                                    };\n                                    $slf.pending =\n                                        EucJpPending::Jis0212Lead($jis0212_lead_minus_offset);\n                                    $handle.commit()\n                                }\n                                EucJpPending::Jis0212Lead($jis0212_lead_minus_offset) => {\n                                    $slf.pending = EucJpPending::None;\n                                    // Start non-boilerplate\n                                    $jis0812_trail_body\n                                    // End non-boilerplate\n                                }\n                                EucJpPending::HalfWidthKatakana => {\n                                    $slf.pending = EucJpPending::None;\n                                    // Start non-boilerplate\n                                    $half_width_katakana_body\n                                    // End non-boilerplate\n                                }\n                                EucJpPending::None => unreachable!(\"Checked in loop condition\"),\n                            };\n                        }\n                    }\n                }\n            }\n        }\n        'outermost: loop {\n            match dest.copy_ascii_from_check_space_bmp(&mut $source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut $non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = {\n                            // If lead is between 0xA1 and 0xFE, inclusive,\n                            // subtract 0xA1. Else if lead is 0x8E, handle the\n                            // next byte as half-width Katakana. Else if lead is\n                            // 0x8F, expect JIS 0212.\n                            let $jis0208_lead_minus_offset = $non_ascii.wrapping_sub(0xA1);\n                            if $jis0208_lead_minus_offset <= (0xFE - 0xA1) {\n                                // JIS 0208\n                                match $source.check_available() {\n                                    Space::Full(src_consumed_trail) => {\n                                        if last {\n                                            return (DecoderResult::Malformed(1, 0),\n                                                    src_consumed_trail,\n                                                    $handle.written());\n                                        }\n                                        $slf.pending =\n                                            EucJpPending::Jis0208Lead($jis0208_lead_minus_offset);\n                                        return (DecoderResult::InputEmpty,\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    Space::Available(source_handle_trail) => {\n                                        let ($byte, $unread_handle_trail) =\n                                            source_handle_trail.read();\n                                        // Start non-boilerplate\n                                        $jis0802_trail_body\n                                        // End non-boilerplate\n                                    }\n                                }\n                            } else if $non_ascii == 0x8F {\n                                match $source.check_available() {\n                                    Space::Full(src_consumed_jis0212) => {\n                                        if last {\n                                            return (DecoderResult::Malformed(1, 0),\n                                                    src_consumed_jis0212,\n                                                    $handle.written());\n                                        }\n                                        $slf.pending = EucJpPending::Jis0212Shift;\n                                        return (DecoderResult::InputEmpty,\n                                                src_consumed_jis0212,\n                                                $handle.written());\n                                    }\n                                    Space::Available(source_handle_jis0212) => {\n                                        let ($lead, $unread_handle_jis0212) =\n                                            source_handle_jis0212.read();\n                                        let $jis0212_lead_minus_offset = {\n                                            // Start non-boilerplate\n                                            $jis0812_lead_body\n                                            // End non-boilerplate\n                                        };\n                                        match $unread_handle_jis0212.commit().check_available() {\n                                            Space::Full(src_consumed_trail) => {\n                                                if last {\n                                                    return (DecoderResult::Malformed(2, 0),\n                                                            src_consumed_trail,\n                                                            $handle.written());\n                                                }\n                                                $slf.pending = EucJpPending::Jis0212Lead($jis0212_lead_minus_offset);\n                                                return (DecoderResult::InputEmpty,\n                                                        src_consumed_trail,\n                                                        $handle.written());\n                                            }\n                                            Space::Available(source_handle_trail) => {\n                                                let ($byte, $unread_handle_trail) =\n                                                    source_handle_trail.read();\n                                                // Start non-boilerplate\n                                                $jis0812_trail_body\n                                                // End non-boilerplate\n                                            }\n                                        }\n                                    }\n                                }\n                            } else if $non_ascii == 0x8E {\n                                match $source.check_available() {\n                                    Space::Full(src_consumed_trail) => {\n                                        if last {\n                                            return (DecoderResult::Malformed(1, 0),\n                                                    src_consumed_trail,\n                                                    $handle.written());\n                                        }\n                                        $slf.pending = EucJpPending::HalfWidthKatakana;\n                                        return (DecoderResult::InputEmpty,\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    Space::Available(source_handle_trail) => {\n                                        let ($byte, $unread_handle_trail) =\n                                            source_handle_trail.read();\n                                        // Start non-boilerplate\n                                        $half_width_katakana_body\n                                        // End non-boilerplate\n                                    }\n                                }\n                            } else {\n                                return (DecoderResult::Malformed(1, 0),\n                                        $source.consumed(),\n                                        $handle.written());\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (DecoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.check_space_bmp() {\n                                    Space::Full(dst_written) => {\n                                        return (DecoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(destination_handle) => {\n                                        let (b, _) = source_handle.read();\n                                        'innermost: loop {\n                                            if b > 127 {\n                                                $non_ascii = b;\n                                                $handle = destination_handle;\n                                                continue 'middle;\n                                            }\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            destination_handle.write_ascii(b);\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"euc_jp::EucJpDecoder::in_neutral_state":["pub fn in_neutral_state(&self) -> bool{\n        self.pending.is_none()\n    }","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpDecoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        self.plus_one_if_lead(byte_length)\n    }","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpDecoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        checked_mul(3, self.plus_one_if_lead(byte_length))\n    }","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpDecoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        // worst case: 2 to 3\n        let len = self.plus_one_if_lead(byte_length);\n        checked_add(2, checked_add_opt(len, checked_div(checked_add(1, len), 2)))\n    }","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpDecoder::new":["pub fn new() -> VariantDecoder{\n        VariantDecoder::EucJp(EucJpDecoder {\n            pending: EucJpPending::None,\n        })\n    }","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpDecoder::plus_one_if_lead":["fn plus_one_if_lead(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_add(if self.pending.is_none() { 0 } else { 1 })\n    }","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpEncoder":["pub struct EucJpEncoder;","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpEncoder::encode_from_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 _last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut dest = ByteDestination::new(dst);\n        'outermost: loop {\n            match $source.$copy_ascii(&mut dest) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = match non_ascii {\n                            NonAscii::BmpExclAscii($bmp) => {\n                                // Start non-boilerplate\n                                $bmp_body\n                                // End non-boilerplate\n                            }\n                            NonAscii::Astral($astral) => {\n                                // Start non-boilerplate\n                                $astral_body\n                                // End non-boilerplate\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (EncoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (EncoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut c, unread_handle) = source_handle.read_enum();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            let ascii = match c {\n                                                Unicode::NonAscii(non_ascii_again) => {\n                                                    non_ascii = non_ascii_again;\n                                                    $handle = destination_handle;\n                                                    continue 'middle;\n                                                }\n                                                Unicode::Ascii(a) => a,\n                                            };\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_one(ascii);\n                                            if $ascii_punctuation && ascii < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (EncoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (EncoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (c_again, _unread_handle_again) =\n                                                                        source_handle_again.read_enum();\n                                                                    c = c_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"euc_jp::EucJpEncoder::encode_from_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 _last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut dest = ByteDestination::new(dst);\n        'outermost: loop {\n            match $source.$copy_ascii(&mut dest) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = match non_ascii {\n                            NonAscii::BmpExclAscii($bmp) => {\n                                // Start non-boilerplate\n                                $bmp_body\n                                // End non-boilerplate\n                            }\n                            NonAscii::Astral($astral) => {\n                                // Start non-boilerplate\n                                $astral_body\n                                // End non-boilerplate\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (EncoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (EncoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut c, unread_handle) = source_handle.read_enum();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            let ascii = match c {\n                                                Unicode::NonAscii(non_ascii_again) => {\n                                                    non_ascii = non_ascii_again;\n                                                    $handle = destination_handle;\n                                                    continue 'middle;\n                                                }\n                                                Unicode::Ascii(a) => a,\n                                            };\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_one(ascii);\n                                            if $ascii_punctuation && ascii < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (EncoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (EncoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (c_again, _unread_handle_again) =\n                                                                        source_handle_again.read_enum();\n                                                                    c = c_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"euc_jp::EucJpEncoder::max_buffer_length_from_utf16_without_replacement":["pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        u16_length.checked_mul(2)\n    }","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpEncoder::max_buffer_length_from_utf8_without_replacement":["pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        byte_length.checked_add(1)\n    }","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpEncoder::new":["pub fn new(encoding: &'static Encoding) -> Encoder{\n        Encoder::new(encoding, VariantEncoder::EucJp(EucJpEncoder))\n    }","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpPending":["enum EucJpPending {\n    None,\n    Jis0208Lead(u8),\n    Jis0212Shift,\n    Jis0212Lead(u8),\n    HalfWidthKatakana,\n}","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpPending::count":["fn count(&self) -> usize{\n        match *self {\n            EucJpPending::None => 0,\n            EucJpPending::Jis0208Lead(_)\n            | EucJpPending::Jis0212Shift\n            | EucJpPending::HalfWidthKatakana => 1,\n            EucJpPending::Jis0212Lead(_) => 2,\n        }\n    }","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::EucJpPending::is_none":["fn is_none(&self) -> bool{\n        match *self {\n            EucJpPending::None => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_jp::encode_kanji":["#[cfg(not(feature = \"fast-kanji-encode\"))]\n#[inline(always)]\nfn encode_kanji(bmp: u16) -> Option<(u8, u8)>{\n    if 0x4EDD == bmp {\n        // Ideograph on the symbol row!\n        Some((0xA1, 0xB8))\n    } else if let Some((lead, trail)) = jis0208_level1_kanji_euc_jp_encode(bmp) {\n        Some((lead, trail))\n    } else if let Some(pos) = jis0208_level2_and_additional_kanji_encode(bmp) {\n        let lead = (pos / 94) + 0xD0;\n        let trail = (pos % 94) + 0xA1;\n        Some((lead as u8, trail as u8))\n    } else if let Some(pos) = position(&IBM_KANJI[..], bmp) {\n        let lead = (pos / 94) + 0xF9;\n        let trail = (pos % 94) + 0xA1;\n        Some((lead as u8, trail as u8))\n    } else {\n        None\n    }\n}","Real(LocalPath(\"src/euc_jp.rs\"))"],"euc_kr::EucKrDecoder":["pub struct EucKrDecoder {\n    lead: Option<u8>,\n}","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::EucKrDecoder::decode_to_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut dest_prolog = $dest_struct::new(dst);\n        let dest = match $slf.lead {\n            Some(lead) => {\n                let $lead_minus_offset = lead;\n                $slf.lead = None;\n                // Since we don't have `goto` we could use to jump into the trail\n                // handling part of the main loop, we need to repeat trail handling\n                // here.\n                match $source.check_available() {\n                    Space::Full(src_consumed_prolog) => {\n                        if last {\n                            return (DecoderResult::Malformed(1, 0),\n                                    src_consumed_prolog,\n                                    dest_prolog.written());\n                        }\n                        return (DecoderResult::InputEmpty, src_consumed_prolog, dest_prolog.written());\n                    }\n                    Space::Available(source_handle_prolog) => {\n                        match dest_prolog.$destination_check() {\n                            Space::Full(dst_written_prolog) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle_prolog.consumed(),\n                                        dst_written_prolog);\n                            }\n                            Space::Available($handle) => {\n                                let ($byte, $unread_handle_trail) = source_handle_prolog.read();\n                                // Start non-boilerplate\n                                $trail\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            },\n            None => {\n                &mut dest_prolog\n            }\n        };\n        $outermost: loop {\n            match dest.$copy_ascii(&mut $source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut $non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = {\n                            let $lead_minus_offset = {\n                                // Start non-boilerplate\n                                $lead\n                                // End non-boilerplate\n                            };\n                            match $source.check_available() {\n                                Space::Full(src_consumed_trail) => {\n                                    if last {\n                                        return (DecoderResult::Malformed(1, 0),\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    $slf.lead = Some($lead_minus_offset);\n                                    return (DecoderResult::InputEmpty,\n                                            src_consumed_trail,\n                                            $handle.written());\n                                }\n                                Space::Available(source_handle_trail) => {\n                                    let ($byte, $unread_handle_trail) = source_handle_trail.read();\n                                    // Start non-boilerplate\n                                    $trail\n                                    // End non-boilerplate\n                                }\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (DecoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (DecoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut b, unread_handle) = source_handle.read();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            if b > 127 {\n                                                $non_ascii = b;\n                                                $handle = destination_handle;\n                                                continue 'middle;\n                                            }\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_ascii(b);\n                                            if $ascii_punctuation && b < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (DecoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (DecoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (b_again, _unread_handle_again) =\n                                                                        source_handle_again.read();\n                                                                    b = b_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue $outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"euc_kr::EucKrDecoder::decode_to_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut dest_prolog = $dest_struct::new(dst);\n        let dest = match $slf.lead {\n            Some(lead) => {\n                let $lead_minus_offset = lead;\n                $slf.lead = None;\n                // Since we don't have `goto` we could use to jump into the trail\n                // handling part of the main loop, we need to repeat trail handling\n                // here.\n                match $source.check_available() {\n                    Space::Full(src_consumed_prolog) => {\n                        if last {\n                            return (DecoderResult::Malformed(1, 0),\n                                    src_consumed_prolog,\n                                    dest_prolog.written());\n                        }\n                        return (DecoderResult::InputEmpty, src_consumed_prolog, dest_prolog.written());\n                    }\n                    Space::Available(source_handle_prolog) => {\n                        match dest_prolog.$destination_check() {\n                            Space::Full(dst_written_prolog) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle_prolog.consumed(),\n                                        dst_written_prolog);\n                            }\n                            Space::Available($handle) => {\n                                let ($byte, $unread_handle_trail) = source_handle_prolog.read();\n                                // Start non-boilerplate\n                                $trail\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            },\n            None => {\n                &mut dest_prolog\n            }\n        };\n        $outermost: loop {\n            match dest.$copy_ascii(&mut $source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut $non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = {\n                            let $lead_minus_offset = {\n                                // Start non-boilerplate\n                                $lead\n                                // End non-boilerplate\n                            };\n                            match $source.check_available() {\n                                Space::Full(src_consumed_trail) => {\n                                    if last {\n                                        return (DecoderResult::Malformed(1, 0),\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    $slf.lead = Some($lead_minus_offset);\n                                    return (DecoderResult::InputEmpty,\n                                            src_consumed_trail,\n                                            $handle.written());\n                                }\n                                Space::Available(source_handle_trail) => {\n                                    let ($byte, $unread_handle_trail) = source_handle_trail.read();\n                                    // Start non-boilerplate\n                                    $trail\n                                    // End non-boilerplate\n                                }\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (DecoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (DecoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut b, unread_handle) = source_handle.read();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            if b > 127 {\n                                                $non_ascii = b;\n                                                $handle = destination_handle;\n                                                continue 'middle;\n                                            }\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_ascii(b);\n                                            if $ascii_punctuation && b < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (DecoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (DecoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (b_again, _unread_handle_again) =\n                                                                        source_handle_again.read();\n                                                                    b = b_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue $outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"euc_kr::EucKrDecoder::in_neutral_state":["pub fn in_neutral_state(&self) -> bool{\n        self.lead.is_none()\n    }","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::EucKrDecoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        self.plus_one_if_lead(byte_length)\n    }","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::EucKrDecoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        checked_mul(3, self.plus_one_if_lead(byte_length))\n    }","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::EucKrDecoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        // worst case: 2 to 3\n        let len = self.plus_one_if_lead(byte_length);\n        checked_add(2, checked_add_opt(len, checked_div(checked_add(1, len), 2)))\n    }","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::EucKrDecoder::new":["pub fn new() -> VariantDecoder{\n        VariantDecoder::EucKr(EucKrDecoder { lead: None })\n    }","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::EucKrDecoder::plus_one_if_lead":["fn plus_one_if_lead(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_add(match self.lead {\n            None => 0,\n            Some(_) => 1,\n        })\n    }","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::EucKrEncoder":["pub struct EucKrEncoder;","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::EucKrEncoder::encode_from_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 _last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut dest = ByteDestination::new(dst);\n        'outermost: loop {\n            match $source.$copy_ascii(&mut dest) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = match non_ascii {\n                            NonAscii::BmpExclAscii($bmp) => {\n                                // Start non-boilerplate\n                                $bmp_body\n                                // End non-boilerplate\n                            }\n                            NonAscii::Astral($astral) => {\n                                // Start non-boilerplate\n                                $astral_body\n                                // End non-boilerplate\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (EncoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (EncoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut c, unread_handle) = source_handle.read_enum();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            let ascii = match c {\n                                                Unicode::NonAscii(non_ascii_again) => {\n                                                    non_ascii = non_ascii_again;\n                                                    $handle = destination_handle;\n                                                    continue 'middle;\n                                                }\n                                                Unicode::Ascii(a) => a,\n                                            };\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_one(ascii);\n                                            if $ascii_punctuation && ascii < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (EncoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (EncoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (c_again, _unread_handle_again) =\n                                                                        source_handle_again.read_enum();\n                                                                    c = c_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"euc_kr::EucKrEncoder::encode_from_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 _last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut dest = ByteDestination::new(dst);\n        'outermost: loop {\n            match $source.$copy_ascii(&mut dest) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = match non_ascii {\n                            NonAscii::BmpExclAscii($bmp) => {\n                                // Start non-boilerplate\n                                $bmp_body\n                                // End non-boilerplate\n                            }\n                            NonAscii::Astral($astral) => {\n                                // Start non-boilerplate\n                                $astral_body\n                                // End non-boilerplate\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (EncoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (EncoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut c, unread_handle) = source_handle.read_enum();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            let ascii = match c {\n                                                Unicode::NonAscii(non_ascii_again) => {\n                                                    non_ascii = non_ascii_again;\n                                                    $handle = destination_handle;\n                                                    continue 'middle;\n                                                }\n                                                Unicode::Ascii(a) => a,\n                                            };\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_one(ascii);\n                                            if $ascii_punctuation && ascii < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (EncoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (EncoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (c_again, _unread_handle_again) =\n                                                                        source_handle_again.read_enum();\n                                                                    c = c_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"euc_kr::EucKrEncoder::max_buffer_length_from_utf16_without_replacement":["pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        u16_length.checked_mul(2)\n    }","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::EucKrEncoder::max_buffer_length_from_utf8_without_replacement":["pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        byte_length.checked_add(1)\n    }","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::EucKrEncoder::new":["pub fn new(encoding: &'static Encoding) -> Encoder{\n        Encoder::new(encoding, VariantEncoder::EucKr(EucKrEncoder))\n    }","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::ksx1001_encode_hangul":["#[cfg(not(feature = \"fast-hangul-encode\"))]\n#[inline(always)]\nfn ksx1001_encode_hangul(bmp: u16, _: u16) -> (u8, u8){\n    match KSX1001_HANGUL.binary_search(&bmp) {\n        Ok(ksx_hangul_pointer) => {\n            let ksx_hangul_lead = (ksx_hangul_pointer / 94) + (0x81 + 0x2F);\n            let ksx_hangul_trail = (ksx_hangul_pointer % 94) + 0xA1;\n            (ksx_hangul_lead as u8, ksx_hangul_trail as u8)\n        }\n        Err(_) => {\n            let (lead, cp949_trail) = if bmp < 0xC8A5 {\n                // Above KS X 1001\n                let top_pointer = cp949_top_hangul_encode(bmp) as usize;\n                let top_lead = (top_pointer / (190 - 12)) + 0x81;\n                let top_trail = top_pointer % (190 - 12);\n                (top_lead as u8, top_trail as u8)\n            } else {\n                // To the left of KS X 1001\n                let left_pointer = cp949_left_hangul_encode(bmp) as usize;\n                let left_lead = (left_pointer / (190 - 94 - 12)) + (0x81 + 0x20);\n                let left_trail = left_pointer % (190 - 94 - 12);\n                (left_lead as u8, left_trail as u8)\n            };\n            let offset = if cp949_trail >= (0x40 - 12) {\n                0x41 + 12\n            } else if cp949_trail >= (0x20 - 6) {\n                0x41 + 6\n            } else {\n                0x41\n            };\n            (lead as u8, (cp949_trail + offset) as u8)\n        }\n    }\n}","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::ksx1001_encode_hanja":["#[cfg(not(feature = \"fast-hanja-encode\"))]\n#[inline(always)]\nfn ksx1001_encode_hanja(bmp: u16) -> Option<(u8, u8)>{\n    if let Some(hanja_pointer) = position(&KSX1001_HANJA[..], bmp) {\n        let hanja_lead = (hanja_pointer / 94) + (0x81 + 0x49);\n        let hanja_trail = (hanja_pointer % 94) + 0xA1;\n        Some((hanja_lead as u8, hanja_trail as u8))\n    } else {\n        None\n    }\n}","Real(LocalPath(\"src/euc_kr.rs\"))"],"euc_kr::ksx1001_encode_misc":["fn ksx1001_encode_misc(bmp: u16) -> Option<(usize, usize)>{\n    if in_inclusive_range16(bmp, 0x3000, 0x3015) {\n        if let Some(pos) = position(&KSX1001_SYMBOLS[..(0xAB - 0x60)], bmp) {\n            return Some((0xA1, pos + 0xA1));\n        }\n    }\n    if let Some(other_pointer) = ksx1001_other_encode(bmp) {\n        let other_lead = ((other_pointer as usize) / 94) + (0x81 + 0x22);\n        let other_trail = ((other_pointer as usize) % 94) + 0xA1;\n        return Some((other_lead, other_trail));\n    }\n    if in_range16(bmp, 0x00AA, 0x0168) {\n        // Latin\n        if let Some(pos) = position(&KSX1001_LOWERCASE[..], bmp) {\n            return Some((0x81 + 0x28, 0xA1 + pos));\n        }\n        if let Some(pos) = position(&KSX1001_UPPERCASE[..], bmp) {\n            return Some((0x81 + 0x27, 0xA1 + pos));\n        }\n    } else if in_range16(bmp, 0x2500, 0x254C) {\n        if let Some(pos) = position(&KSX1001_BOX[..], bmp) {\n            return Some((0x81 + 0x25, 0xA1 + pos));\n        }\n    }\n    if in_inclusive_range16(bmp, 0x2015, 0x266D)\n        || in_inclusive_range16(bmp, 0x321C, 0x33D8)\n        || in_inclusive_range16(bmp, 0xFF3C, 0xFFE5)\n        || in_inclusive_range16(bmp, 0x00A1, 0x00F7)\n        || in_inclusive_range16(bmp, 0x02C7, 0x02DD)\n    {\n        if let Some(pos) = position(&KSX1001_SYMBOLS[3..], bmp) {\n            if pos < (94 - 3) {\n                return Some((0xA1, pos + 0xA1 + 3));\n            }\n            return Some((0xA2, pos - (94 - 3) + 0xA1));\n        }\n    }\n    None\n}","Real(LocalPath(\"src/euc_kr.rs\"))"],"gb18030::Gb18030Decoder":["pub struct Gb18030Decoder {\n    first: Option<u8>,\n    second: Option<u8>,\n    third: Option<u8>,\n    pending: Gb18030Pending,\n    pending_ascii: Option<u8>,\n}","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Decoder::decode_to_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut dest = $dest_struct::new(dst);\n        {\n            if let Some(ascii) = $slf.pending_ascii {\n                match dest.check_space_bmp() {\n                    Space::Full(_) => {\n                        return (DecoderResult::OutputFull, 0, 0);\n                    }\n                    Space::Available(pending_ascii_handle) => {\n                        $slf.pending_ascii = None;\n                        pending_ascii_handle.write_ascii(ascii);\n                    }\n                }\n            }\n        }\n        while !$slf.pending.is_none() {\n            match $source.check_available() {\n                Space::Full(src_consumed) => {\n                    if last {\n                        // Start non-boilerplate\n                        let count = $slf.pending.count();\n                        $slf.pending = Gb18030Pending::None;\n                        return (DecoderResult::Malformed(count as u8, 0),\n                                src_consumed,\n                                dest.written());\n                        // End non-boilerplate\n                    }\n                    return (DecoderResult::InputEmpty, src_consumed, dest.written());\n                }\n                Space::Available(source_handle) => {\n                    match dest.check_space_astral() {\n                        Space::Full(dst_written) => {\n                            return (DecoderResult::OutputFull,\n                                    source_handle.consumed(),\n                                    dst_written);\n                        }\n                        Space::Available($handle) => {\n                            let (byte, unread_handle) = source_handle.read();\n                            match $slf.pending {\n                                Gb18030Pending::One($first_minus_offset) => {\n                                    $slf.pending = Gb18030Pending::None;\n                                    let $second = byte;\n                                    let $unread_handle_second = unread_handle;\n                                    // If second is between 0x40 and 0x7E,\n                                    // inclusive, subtract offset 0x40. Else if\n                                    // second is between 0x80 and 0xFE, inclusive,\n                                    // subtract offset 0x41. In both cases,\n                                    // handle as a two-byte sequence.\n                                    // Else if second is between 0x30 and 0x39,\n                                    // inclusive, subtract offset 0x30 and\n                                    // handle as a four-byte sequence.\n                                    let $second_minus_offset = $second.wrapping_sub(0x30);\n                                    // It's not optimal to do this check first,\n                                    // but this results in more readable code.\n                                    if $second_minus_offset > (0x39 - 0x30) {\n                                        // Start non-boilerplate\n                                        $second_body\n                                        // End non-boilerplate\n                                    } else {\n                                        // Four-byte!\n                                        $slf.pending = Gb18030Pending::Two($first_minus_offset,\n                                                                           $second_minus_offset);\n                                        $handle.commit()\n                                    }\n                                }\n                                Gb18030Pending::Two($first_minus_offset, $second_minus_offset) => {\n                                    $slf.pending = Gb18030Pending::None;\n                                    let $third = byte;\n                                    let $unread_handle_third = unread_handle;\n                                    let $third_minus_offset = {\n                                        // Start non-boilerplate\n                                        $third_body\n                                        // End non-boilerplate\n                                    };\n                                    $slf.pending = Gb18030Pending::Three($first_minus_offset,\n                                                                         $second_minus_offset,\n                                                                         $third_minus_offset);\n                                    $handle.commit()\n                                }\n                                Gb18030Pending::Three($first_minus_offset,\n                                                      $second_minus_offset,\n                                                      $third_minus_offset) => {\n                                    $slf.pending = Gb18030Pending::None;\n                                    let $fourth = byte;\n                                    let $unread_handle_fourth = unread_handle;\n                                    // Start non-boilerplate\n                                    $fourth_body\n                                    // End non-boilerplate\n                                }\n                                Gb18030Pending::None => unreachable!(\"Checked in loop condition\"),\n                            };\n                        }\n                    }\n                }\n            }\n        }\n        $outermost: loop {\n            match dest.copy_ascii_from_check_space_astral(&mut $source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut $non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = {\n                            let $first_minus_offset = {\n                                // Start non-boilerplate\n                                $first_body\n                                // End non-boilerplate\n                            };\n                            match $source.check_available() {\n                                Space::Full(src_consumed_trail) => {\n                                    if last {\n                                        return (DecoderResult::Malformed(1, 0),\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    $slf.pending = Gb18030Pending::One($first_minus_offset);\n                                    return (DecoderResult::InputEmpty,\n                                            src_consumed_trail,\n                                            $handle.written());\n                                }\n                                Space::Available(source_handle_trail) => {\n                                    let ($second, $unread_handle_second) = source_handle_trail.read();\n                                    // Start non-boilerplate\n                                    // If second is between 0x40 and 0x7E,\n                                    // inclusive, subtract offset 0x40. Else if\n                                    // second is between 0x80 and 0xFE, inclusive,\n                                    // subtract offset 0x41. In both cases,\n                                    // handle as a two-byte sequence.\n                                    // Else if second is between 0x30 and 0x39,\n                                    // inclusive, subtract offset 0x30 and\n                                    // handle as a four-byte sequence.\n                                    let $second_minus_offset = $second.wrapping_sub(0x30);\n                                    // It's not optimal to do this check first,\n                                    // but this results in more readable code.\n                                    if $second_minus_offset > (0x39 - 0x30) {\n                                        // Start non-boilerplate\n                                        $second_body\n                                        // End non-boilerplate\n                                    } else {\n                                        // Four-byte!\n                                        match $unread_handle_second.commit().check_available() {\n                                            Space::Full(src_consumed_third) => {\n                                                if last {\n                                                    return (DecoderResult::Malformed(2, 0),\n                                                            src_consumed_third,\n                                                            $handle.written());\n                                                }\n                                                $slf.pending =\n                                                    Gb18030Pending::Two($first_minus_offset,\n                                                                        $second_minus_offset);\n                                                return (DecoderResult::InputEmpty,\n                                                        src_consumed_third,\n                                                        $handle.written());\n                                            }\n                                            Space::Available(source_handle_third) => {\n                                                let ($third, $unread_handle_third) =\n                                                    source_handle_third.read();\n                                                let $third_minus_offset = {\n                                                    // Start non-boilerplate\n                                                    $third_body\n                                                    // End non-boilerplate\n                                                };\n                                                match $unread_handle_third.commit()\n                                                                         .check_available() {\n                                                    Space::Full(src_consumed_fourth) => {\n                                                        if last {\n                                                            return (DecoderResult::Malformed(3, 0),\n                                                                    src_consumed_fourth,\n                                                                    $handle.written());\n                                                        }\n                                                        $slf.pending = Gb18030Pending::Three($first_minus_offset, $second_minus_offset, $third_minus_offset);\n                                                        return (DecoderResult::InputEmpty,\n                                                                src_consumed_fourth,\n                                                                $handle.written());\n                                                    }\n                                                    Space::Available(source_handle_fourth) => {\n                                                        let ($fourth, $unread_handle_fourth) =\n                                                            source_handle_fourth.read();\n                                                        // Start non-boilerplate\n                                                        $fourth_body\n                                                        // End non-boilerplate\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    // End non-boilerplate\n                                }\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (DecoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.check_space_astral() {\n                                    Space::Full(dst_written) => {\n                                        return (DecoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(destination_handle) => {\n                                        let (b, _) = source_handle.read();\n                                        'innermost: loop {\n                                            if b > 127 {\n                                                $non_ascii = b;\n                                                $handle = destination_handle;\n                                                continue 'middle;\n                                            }\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            destination_handle.write_ascii(b);\n                                            // We've got markup or ASCII text\n                                            continue $outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"gb18030::Gb18030Decoder::decode_to_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut dest = $dest_struct::new(dst);\n        {\n            if let Some(ascii) = $slf.pending_ascii {\n                match dest.check_space_bmp() {\n                    Space::Full(_) => {\n                        return (DecoderResult::OutputFull, 0, 0);\n                    }\n                    Space::Available(pending_ascii_handle) => {\n                        $slf.pending_ascii = None;\n                        pending_ascii_handle.write_ascii(ascii);\n                    }\n                }\n            }\n        }\n        while !$slf.pending.is_none() {\n            match $source.check_available() {\n                Space::Full(src_consumed) => {\n                    if last {\n                        // Start non-boilerplate\n                        let count = $slf.pending.count();\n                        $slf.pending = Gb18030Pending::None;\n                        return (DecoderResult::Malformed(count as u8, 0),\n                                src_consumed,\n                                dest.written());\n                        // End non-boilerplate\n                    }\n                    return (DecoderResult::InputEmpty, src_consumed, dest.written());\n                }\n                Space::Available(source_handle) => {\n                    match dest.check_space_astral() {\n                        Space::Full(dst_written) => {\n                            return (DecoderResult::OutputFull,\n                                    source_handle.consumed(),\n                                    dst_written);\n                        }\n                        Space::Available($handle) => {\n                            let (byte, unread_handle) = source_handle.read();\n                            match $slf.pending {\n                                Gb18030Pending::One($first_minus_offset) => {\n                                    $slf.pending = Gb18030Pending::None;\n                                    let $second = byte;\n                                    let $unread_handle_second = unread_handle;\n                                    // If second is between 0x40 and 0x7E,\n                                    // inclusive, subtract offset 0x40. Else if\n                                    // second is between 0x80 and 0xFE, inclusive,\n                                    // subtract offset 0x41. In both cases,\n                                    // handle as a two-byte sequence.\n                                    // Else if second is between 0x30 and 0x39,\n                                    // inclusive, subtract offset 0x30 and\n                                    // handle as a four-byte sequence.\n                                    let $second_minus_offset = $second.wrapping_sub(0x30);\n                                    // It's not optimal to do this check first,\n                                    // but this results in more readable code.\n                                    if $second_minus_offset > (0x39 - 0x30) {\n                                        // Start non-boilerplate\n                                        $second_body\n                                        // End non-boilerplate\n                                    } else {\n                                        // Four-byte!\n                                        $slf.pending = Gb18030Pending::Two($first_minus_offset,\n                                                                           $second_minus_offset);\n                                        $handle.commit()\n                                    }\n                                }\n                                Gb18030Pending::Two($first_minus_offset, $second_minus_offset) => {\n                                    $slf.pending = Gb18030Pending::None;\n                                    let $third = byte;\n                                    let $unread_handle_third = unread_handle;\n                                    let $third_minus_offset = {\n                                        // Start non-boilerplate\n                                        $third_body\n                                        // End non-boilerplate\n                                    };\n                                    $slf.pending = Gb18030Pending::Three($first_minus_offset,\n                                                                         $second_minus_offset,\n                                                                         $third_minus_offset);\n                                    $handle.commit()\n                                }\n                                Gb18030Pending::Three($first_minus_offset,\n                                                      $second_minus_offset,\n                                                      $third_minus_offset) => {\n                                    $slf.pending = Gb18030Pending::None;\n                                    let $fourth = byte;\n                                    let $unread_handle_fourth = unread_handle;\n                                    // Start non-boilerplate\n                                    $fourth_body\n                                    // End non-boilerplate\n                                }\n                                Gb18030Pending::None => unreachable!(\"Checked in loop condition\"),\n                            };\n                        }\n                    }\n                }\n            }\n        }\n        $outermost: loop {\n            match dest.copy_ascii_from_check_space_astral(&mut $source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut $non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = {\n                            let $first_minus_offset = {\n                                // Start non-boilerplate\n                                $first_body\n                                // End non-boilerplate\n                            };\n                            match $source.check_available() {\n                                Space::Full(src_consumed_trail) => {\n                                    if last {\n                                        return (DecoderResult::Malformed(1, 0),\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    $slf.pending = Gb18030Pending::One($first_minus_offset);\n                                    return (DecoderResult::InputEmpty,\n                                            src_consumed_trail,\n                                            $handle.written());\n                                }\n                                Space::Available(source_handle_trail) => {\n                                    let ($second, $unread_handle_second) = source_handle_trail.read();\n                                    // Start non-boilerplate\n                                    // If second is between 0x40 and 0x7E,\n                                    // inclusive, subtract offset 0x40. Else if\n                                    // second is between 0x80 and 0xFE, inclusive,\n                                    // subtract offset 0x41. In both cases,\n                                    // handle as a two-byte sequence.\n                                    // Else if second is between 0x30 and 0x39,\n                                    // inclusive, subtract offset 0x30 and\n                                    // handle as a four-byte sequence.\n                                    let $second_minus_offset = $second.wrapping_sub(0x30);\n                                    // It's not optimal to do this check first,\n                                    // but this results in more readable code.\n                                    if $second_minus_offset > (0x39 - 0x30) {\n                                        // Start non-boilerplate\n                                        $second_body\n                                        // End non-boilerplate\n                                    } else {\n                                        // Four-byte!\n                                        match $unread_handle_second.commit().check_available() {\n                                            Space::Full(src_consumed_third) => {\n                                                if last {\n                                                    return (DecoderResult::Malformed(2, 0),\n                                                            src_consumed_third,\n                                                            $handle.written());\n                                                }\n                                                $slf.pending =\n                                                    Gb18030Pending::Two($first_minus_offset,\n                                                                        $second_minus_offset);\n                                                return (DecoderResult::InputEmpty,\n                                                        src_consumed_third,\n                                                        $handle.written());\n                                            }\n                                            Space::Available(source_handle_third) => {\n                                                let ($third, $unread_handle_third) =\n                                                    source_handle_third.read();\n                                                let $third_minus_offset = {\n                                                    // Start non-boilerplate\n                                                    $third_body\n                                                    // End non-boilerplate\n                                                };\n                                                match $unread_handle_third.commit()\n                                                                         .check_available() {\n                                                    Space::Full(src_consumed_fourth) => {\n                                                        if last {\n                                                            return (DecoderResult::Malformed(3, 0),\n                                                                    src_consumed_fourth,\n                                                                    $handle.written());\n                                                        }\n                                                        $slf.pending = Gb18030Pending::Three($first_minus_offset, $second_minus_offset, $third_minus_offset);\n                                                        return (DecoderResult::InputEmpty,\n                                                                src_consumed_fourth,\n                                                                $handle.written());\n                                                    }\n                                                    Space::Available(source_handle_fourth) => {\n                                                        let ($fourth, $unread_handle_fourth) =\n                                                            source_handle_fourth.read();\n                                                        // Start non-boilerplate\n                                                        $fourth_body\n                                                        // End non-boilerplate\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    // End non-boilerplate\n                                }\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (DecoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.check_space_astral() {\n                                    Space::Full(dst_written) => {\n                                        return (DecoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(destination_handle) => {\n                                        let (b, _) = source_handle.read();\n                                        'innermost: loop {\n                                            if b > 127 {\n                                                $non_ascii = b;\n                                                $handle = destination_handle;\n                                                continue 'middle;\n                                            }\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            destination_handle.write_ascii(b);\n                                            // We've got markup or ASCII text\n                                            continue $outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"gb18030::Gb18030Decoder::extra_from_state":["fn extra_from_state(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_add(\n            self.pending.count()\n                + match self.first {\n                    None => 0,\n                    Some(_) => 1,\n                }\n                + match self.second {\n                    None => 0,\n                    Some(_) => 1,\n                }\n                + match self.third {\n                    None => 0,\n                    Some(_) => 1,\n                }\n                + match self.pending_ascii {\n                    None => 0,\n                    Some(_) => 1,\n                },\n        )\n    }","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Decoder::in_neutral_state":["pub fn in_neutral_state(&self) -> bool{\n        self.first.is_none()\n            && self.second.is_none()\n            && self.third.is_none()\n            && self.pending.is_none()\n            && self.pending_ascii.is_none()\n    }","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Decoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        // ASCII: 1 to 1 (worst case)\n        // gbk: 2 to 1\n        // ranges: 4 to 1 or 4 to 2\n        checked_add(1, self.extra_from_state(byte_length))\n    }","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Decoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        checked_add(1, checked_mul(3, self.extra_from_state(byte_length)))\n    }","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Decoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        // ASCII: 1 to 1\n        // gbk: 2 to 2 or 2 to 3\n        // ranges: 4 to 2, 4 to 3 or 4 to 4\n        // 0x80: 1 to 3 (worst case)\n        self.max_utf8_buffer_length(byte_length)\n    }","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Decoder::new":["pub fn new() -> VariantDecoder{\n        VariantDecoder::Gb18030(Gb18030Decoder {\n            first: None,\n            second: None,\n            third: None,\n            pending: Gb18030Pending::None,\n            pending_ascii: None,\n        })\n    }","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Encoder":["pub struct Gb18030Encoder {\n    extended: bool,\n}","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Encoder::encode_from_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 _last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut dest = ByteDestination::new(dst);\n        'outermost: loop {\n            match $source.$copy_ascii(&mut dest) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = match non_ascii {\n                            NonAscii::BmpExclAscii($bmp) => {\n                                // Start non-boilerplate\n                                $bmp_body\n                                // End non-boilerplate\n                            }\n                            NonAscii::Astral($astral) => {\n                                // Start non-boilerplate\n                                $astral_body\n                                // End non-boilerplate\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (EncoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (EncoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut c, unread_handle) = source_handle.read_enum();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            let ascii = match c {\n                                                Unicode::NonAscii(non_ascii_again) => {\n                                                    non_ascii = non_ascii_again;\n                                                    $handle = destination_handle;\n                                                    continue 'middle;\n                                                }\n                                                Unicode::Ascii(a) => a,\n                                            };\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_one(ascii);\n                                            if $ascii_punctuation && ascii < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (EncoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (EncoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (c_again, _unread_handle_again) =\n                                                                        source_handle_again.read_enum();\n                                                                    c = c_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"gb18030::Gb18030Encoder::encode_from_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 _last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut dest = ByteDestination::new(dst);\n        'outermost: loop {\n            match $source.$copy_ascii(&mut dest) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = match non_ascii {\n                            NonAscii::BmpExclAscii($bmp) => {\n                                // Start non-boilerplate\n                                $bmp_body\n                                // End non-boilerplate\n                            }\n                            NonAscii::Astral($astral) => {\n                                // Start non-boilerplate\n                                $astral_body\n                                // End non-boilerplate\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (EncoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (EncoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut c, unread_handle) = source_handle.read_enum();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            let ascii = match c {\n                                                Unicode::NonAscii(non_ascii_again) => {\n                                                    non_ascii = non_ascii_again;\n                                                    $handle = destination_handle;\n                                                    continue 'middle;\n                                                }\n                                                Unicode::Ascii(a) => a,\n                                            };\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_one(ascii);\n                                            if $ascii_punctuation && ascii < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (EncoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (EncoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (c_again, _unread_handle_again) =\n                                                                        source_handle_again.read_enum();\n                                                                    c = c_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"gb18030::Gb18030Encoder::max_buffer_length_from_utf16_without_replacement":["pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        if self.extended {\n            u16_length.checked_mul(4)\n        } else {\n            // Need to add, because space check is done with the four-byte\n            // assumption.\n            checked_add(2, u16_length.checked_mul(2))\n        }\n    }","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Encoder::max_buffer_length_from_utf8_without_replacement":["pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        if self.extended {\n            // 1 to 1\n            // 2 to 2\n            // 3 to 2\n            // 2 to 4 (worst)\n            // 3 to 4\n            // 4 to 4\n            checked_add(2, byte_length.checked_mul(2))\n        } else {\n            // 1 to 1\n            // 2 to 2\n            // 3 to 2\n            // Need to add, because space check is done with the four-byte\n            // assumption.\n            byte_length.checked_add(3)\n        }\n    }","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Encoder::new":["pub fn new(encoding: &'static Encoding, extended_range: bool) -> Encoder{\n        Encoder::new(\n            encoding,\n            VariantEncoder::Gb18030(Gb18030Encoder {\n                extended: extended_range,\n            }),\n        )\n    }","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Pending":["enum Gb18030Pending {\n    None,\n    One(u8),\n    Two(u8, u8),\n    Three(u8, u8, u8),\n}","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Pending::count":["fn count(&self) -> usize{\n        match *self {\n            Gb18030Pending::None => 0,\n            Gb18030Pending::One(_) => 1,\n            Gb18030Pending::Two(_, _) => 2,\n            Gb18030Pending::Three(_, _, _) => 3,\n        }\n    }","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::Gb18030Pending::is_none":["fn is_none(&self) -> bool{\n        match *self {\n            Gb18030Pending::None => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::encode_hanzi":["#[cfg(not(feature = \"fast-gb-hanzi-encode\"))]\n#[inline(always)]\nfn encode_hanzi(bmp: u16, _: u16) -> (u8, u8){\n    if let Some((lead, trail)) = gb2312_level1_hanzi_encode(bmp) {\n        (lead, trail)\n    } else if let Some(hanzi_pointer) = gb2312_level2_hanzi_encode(bmp) {\n        let hanzi_lead = (hanzi_pointer / 94) + (0xD8);\n        let hanzi_trail = (hanzi_pointer % 94) + 0xA1;\n        (hanzi_lead as u8, hanzi_trail as u8)\n    } else {\n        let (lead, gbk_trail) = if bmp < 0x72DC {\n            // Above GB2312\n            let pointer = gbk_top_ideograph_encode(bmp) as usize;\n            let lead = (pointer / 190) + 0x81;\n            let gbk_trail = pointer % 190;\n            (lead, gbk_trail)\n        } else {\n            // To the left of GB2312\n            let gbk_left_ideograph_pointer = gbk_left_ideograph_encode(bmp) as usize;\n            let lead = (gbk_left_ideograph_pointer / (190 - 94)) + (0x81 + 0x29);\n            let gbk_trail = gbk_left_ideograph_pointer % (190 - 94);\n            (lead, gbk_trail)\n        };\n        let offset = if gbk_trail < 0x3F { 0x40 } else { 0x41 };\n        (lead as u8, (gbk_trail + offset) as u8)\n    }\n}","Real(LocalPath(\"src/gb18030.rs\"))"],"gb18030::gbk_encode_non_unified":["fn gbk_encode_non_unified(bmp: u16) -> Option<(usize, usize)>{\n    // Try ideographic punctuation first as it's the most likely case.\n    // Throwing in the check for full-width currencies and tilde is probably\n    // more size-efficient here than elsewhere.\n    if in_inclusive_range16(bmp, 0x2014, 0x3017) || in_inclusive_range16(bmp, 0xFF04, 0xFFE1) {\n        if let Some(pos) = position(&GB2312_SYMBOLS[..], bmp) {\n            return Some((0xA1, pos + 0xA1));\n        }\n    }\n    // Ext A\n    if in_range16(bmp, 0x3400, 0x4E00) {\n        return position(&GBK_BOTTOM[21..100], bmp).map(|pos| {\n            (\n                0xFE,\n                pos + if pos < (0x3F - 16) {\n                    0x40 + 16\n                } else {\n                    0x41 + 16\n                },\n            )\n        });\n    }\n    // Compatibility ideographs\n    if in_range16(bmp, 0xF900, 0xFB00) {\n        return position(&GBK_BOTTOM[0..21], bmp).map(|pos| {\n            if pos < 5 {\n                // end of second to last row\n                (0xFD, pos + (190 - 94 - 5 + 0x41))\n            } else {\n                // last row\n                (0xFE, pos + (0x40 - 5))\n            }\n        });\n    }\n    // Handle everything below U+02CA, which is in GBK_OTHER.\n    if bmp < 0x02CA {\n        if in_range16(bmp, 0x00E0, 0x0262) && bmp != 0x00F7 {\n            // Pinyin except U+1E3F\n            if let Some(pos) = position(&GB2312_PINYIN[..], bmp) {\n                return Some((0xA8, pos + 0xA1));\n            }\n        } else if in_inclusive_range16(bmp, 0x00A4, 0x00F7)\n            || in_inclusive_range16(bmp, 0x02C7, 0x02C9)\n        {\n            // Diacritics and Latin 1 symbols\n            if let Some(pos) = position(&GB2312_SYMBOLS[3..(0xAC - 0x60)], bmp) {\n                return Some((0xA1, pos + 0xA1 + 3));\n            }\n        }\n        return None;\n    }\n    if bmp >= 0xE794 {\n        // Various brackets, all in PUA or full-width regions\n        if let Some(pos) = position(&GB2312_SYMBOLS_AFTER_GREEK[..], bmp) {\n            return Some((0xA6, pos + (0x9F - 0x60 + 0xA1)));\n        }\n    } else if bmp == 0x1E3F {\n        // The one Pinyin placed elsewhere on the BMP\n        return Some((0xA8, 0x7B - 0x60 + 0xA1));\n    } else if in_range16(bmp, 0xA000, 0xD800) {\n        // Since Korean has usage in China, let's spend a branch to fast-track\n        // Hangul.\n        return None;\n    }\n    // GB2312 other (except bottom PUA and PUA between Hanzi levels).\n    if let Some(other_pointer) = gb2312_other_encode(bmp) {\n        let other_lead = other_pointer as usize / 94;\n        let other_trail = other_pointer as usize % 94;\n        return Some((0xA2 + other_lead, 0xA1 + other_trail));\n    }\n    // At this point, we've handled all mappable characters above U+02D9 but\n    // below U+2010. Let's check for that range in order to let lower BMP\n    // characters used for minority languages in China avoid the subsequent\n    // search that deals mainly with various symbols.\n    if in_range16(bmp, 0x02DA, 0x2010) {\n        return None;\n    }\n    // GBK other (except radicals and PUA in GBK_BOTTOM).\n    if let Some(other_pointer) = gbk_other_encode(bmp) {\n        let other_lead = other_pointer as usize / (190 - 94);\n        let other_trail = other_pointer as usize % (190 - 94);\n        let offset = if other_trail < 0x3F { 0x40 } else { 0x41 };\n        return Some((other_lead + (0x81 + 0x20), other_trail + offset));\n    }\n    // CJK Radicals Supplement or PUA in GBK_BOTTOM\n    if in_inclusive_range16(bmp, 0x2E81, 0x2ECA) || in_inclusive_range16(bmp, 0xE816, 0xE864) {\n        if let Some(pos) = position(&GBK_BOTTOM[21..], bmp) {\n            let trail = pos + 16;\n            let offset = if trail < 0x3F { 0x40 } else { 0x41 };\n            return Some((0xFE, trail + offset));\n        }\n    }\n    // GB2312 bottom PUA\n    let bmp_minus_gb2312_bottom_pua = bmp.wrapping_sub(0xE234);\n    if bmp_minus_gb2312_bottom_pua <= (0xE4C5 - 0xE234) {\n        let pua_lead = bmp_minus_gb2312_bottom_pua as usize / 94;\n        let pua_trail = bmp_minus_gb2312_bottom_pua as usize % 94;\n        return Some((0x81 + 0x77 + pua_lead, 0xA1 + pua_trail));\n    }\n    // PUA between Hanzi Levels\n    let bmp_minus_pua_between_hanzi = bmp.wrapping_sub(0xE810);\n    if bmp_minus_pua_between_hanzi < 5 {\n        return Some((0x81 + 0x56, 0xFF - 5 + bmp_minus_pua_between_hanzi as usize));\n    }\n    None\n}","Real(LocalPath(\"src/gb18030.rs\"))"],"handles::BigEndian":["pub struct BigEndian;","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteDestination":["pub struct ByteDestination<'a> {\n    slice: &'a mut [u8],\n    pos: usize,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteDestination::<'a>::check_space_four":["#[inline(always)]\npub fn check_space_four<'b>(&'b mut self) -> Space<ByteFourHandle<'b, 'a>>{\n        if self.pos + 3 < self.slice.len() {\n            Space::Available(ByteFourHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteDestination::<'a>::check_space_one":["#[inline(always)]\npub fn check_space_one<'b>(&'b mut self) -> Space<ByteOneHandle<'b, 'a>>{\n        if self.pos < self.slice.len() {\n            Space::Available(ByteOneHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteDestination::<'a>::check_space_three":["#[inline(always)]\npub fn check_space_three<'b>(&'b mut self) -> Space<ByteThreeHandle<'b, 'a>>{\n        if self.pos + 2 < self.slice.len() {\n            Space::Available(ByteThreeHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteDestination::<'a>::check_space_two":["#[inline(always)]\npub fn check_space_two<'b>(&'b mut self) -> Space<ByteTwoHandle<'b, 'a>>{\n        if self.pos + 1 < self.slice.len() {\n            Space::Available(ByteTwoHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteDestination::<'a>::new":["#[inline(always)]\npub fn new(dst: &mut [u8]) -> ByteDestination{\n        ByteDestination { slice: dst, pos: 0 }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteDestination::<'a>::write_four":["#[inline(always)]\nfn write_four(&mut self, first: u8, second: u8, third: u8, fourth: u8){\n        self.slice[self.pos] = first;\n        self.slice[self.pos + 1] = second;\n        self.slice[self.pos + 2] = third;\n        self.slice[self.pos + 3] = fourth;\n        self.pos += 4;\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteDestination::<'a>::write_one":["#[inline(always)]\nfn write_one(&mut self, first: u8){\n        self.slice[self.pos] = first;\n        self.pos += 1;\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteDestination::<'a>::write_three":["#[inline(always)]\nfn write_three(&mut self, first: u8, second: u8, third: u8){\n        self.slice[self.pos] = first;\n        self.slice[self.pos + 1] = second;\n        self.slice[self.pos + 2] = third;\n        self.pos += 3;\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteDestination::<'a>::write_two":["#[inline(always)]\nfn write_two(&mut self, first: u8, second: u8){\n        self.slice[self.pos] = first;\n        self.slice[self.pos + 1] = second;\n        self.pos += 2;\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteDestination::<'a>::written":["#[inline(always)]\npub fn written(&self) -> usize{\n        self.pos\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteFourHandle":["pub struct ByteFourHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    dest: &'a mut ByteDestination<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteFourHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(dst: &'a mut ByteDestination<'b>) -> ByteFourHandle<'a, 'b>{\n        ByteFourHandle { dest: dst }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteFourHandle::<'a, 'b>::write_four":["#[inline(always)]\npub fn write_four(\n        self,\n        first: u8,\n        second: u8,\n        third: u8,\n        fourth: u8,\n    ) -> &'a mut ByteDestination<'b>{\n        self.dest.write_four(first, second, third, fourth);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteFourHandle::<'a, 'b>::write_one":["#[inline(always)]\npub fn write_one(self, first: u8) -> &'a mut ByteDestination<'b>{\n        self.dest.write_one(first);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteFourHandle::<'a, 'b>::write_two":["#[inline(always)]\npub fn write_two(self, first: u8, second: u8) -> &'a mut ByteDestination<'b>{\n        self.dest.write_two(first, second);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteFourHandle::<'a, 'b>::written":["#[inline(always)]\npub fn written(&self) -> usize{\n        self.dest.written()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteOneHandle":["pub struct ByteOneHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    dest: &'a mut ByteDestination<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteOneHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(dst: &'a mut ByteDestination<'b>) -> ByteOneHandle<'a, 'b>{\n        ByteOneHandle { dest: dst }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteOneHandle::<'a, 'b>::write_one":["#[inline(always)]\npub fn write_one(self, first: u8) -> &'a mut ByteDestination<'b>{\n        self.dest.write_one(first);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteOneHandle::<'a, 'b>::written":["#[inline(always)]\npub fn written(&self) -> usize{\n        self.dest.written()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteReadHandle":["pub struct ByteReadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    source: &'a mut ByteSource<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteReadHandle::<'a, 'b>::consumed":["#[inline(always)]\npub fn consumed(&self) -> usize{\n        self.source.consumed()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteReadHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(src: &'a mut ByteSource<'b>) -> ByteReadHandle<'a, 'b>{\n        ByteReadHandle { source: src }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteReadHandle::<'a, 'b>::read":["#[inline(always)]\npub fn read(self) -> (u8, ByteUnreadHandle<'a, 'b>){\n        let byte = self.source.read();\n        let handle = ByteUnreadHandle::new(self.source);\n        (byte, handle)\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteSource":["pub struct ByteSource<'a> {\n    slice: &'a [u8],\n    pos: usize,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteSource::<'a>::check_available":["#[inline(always)]\npub fn check_available<'b>(&'b mut self) -> Space<ByteReadHandle<'b, 'a>>{\n        if self.pos < self.slice.len() {\n            Space::Available(ByteReadHandle::new(self))\n        } else {\n            Space::Full(self.consumed())\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteSource::<'a>::consumed":["#[inline(always)]\npub fn consumed(&self) -> usize{\n        self.pos\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteSource::<'a>::new":["#[inline(always)]\npub fn new(src: &[u8]) -> ByteSource{\n        ByteSource { slice: src, pos: 0 }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteSource::<'a>::read":["#[inline(always)]\nfn read(&mut self) -> u8{\n        let ret = self.slice[self.pos];\n        self.pos += 1;\n        ret\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteSource::<'a>::unread":["#[inline(always)]\nfn unread(&mut self) -> usize{\n        self.pos -= 1;\n        self.pos\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteThreeHandle":["pub struct ByteThreeHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    dest: &'a mut ByteDestination<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteThreeHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(dst: &'a mut ByteDestination<'b>) -> ByteThreeHandle<'a, 'b>{\n        ByteThreeHandle { dest: dst }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteThreeHandle::<'a, 'b>::write_one":["#[inline(always)]\npub fn write_one(self, first: u8) -> &'a mut ByteDestination<'b>{\n        self.dest.write_one(first);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteThreeHandle::<'a, 'b>::write_three":["#[inline(always)]\npub fn write_three(self, first: u8, second: u8, third: u8) -> &'a mut ByteDestination<'b>{\n        self.dest.write_three(first, second, third);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteThreeHandle::<'a, 'b>::write_three_return_written":["#[inline(always)]\npub fn write_three_return_written(self, first: u8, second: u8, third: u8) -> usize{\n        self.dest.write_three(first, second, third);\n        self.dest.written()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteThreeHandle::<'a, 'b>::write_two":["#[inline(always)]\npub fn write_two(self, first: u8, second: u8) -> &'a mut ByteDestination<'b>{\n        self.dest.write_two(first, second);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteThreeHandle::<'a, 'b>::written":["#[inline(always)]\npub fn written(&self) -> usize{\n        self.dest.written()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteTwoHandle":["pub struct ByteTwoHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    dest: &'a mut ByteDestination<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteTwoHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(dst: &'a mut ByteDestination<'b>) -> ByteTwoHandle<'a, 'b>{\n        ByteTwoHandle { dest: dst }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteTwoHandle::<'a, 'b>::write_one":["#[inline(always)]\npub fn write_one(self, first: u8) -> &'a mut ByteDestination<'b>{\n        self.dest.write_one(first);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteTwoHandle::<'a, 'b>::write_two":["#[inline(always)]\npub fn write_two(self, first: u8, second: u8) -> &'a mut ByteDestination<'b>{\n        self.dest.write_two(first, second);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteTwoHandle::<'a, 'b>::written":["#[inline(always)]\npub fn written(&self) -> usize{\n        self.dest.written()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteUnreadHandle":["pub struct ByteUnreadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    source: &'a mut ByteSource<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteUnreadHandle::<'a, 'b>::commit":["#[inline(always)]\npub fn commit(self) -> &'a mut ByteSource<'b>{\n        self.source\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteUnreadHandle::<'a, 'b>::consumed":["#[inline(always)]\npub fn consumed(&self) -> usize{\n        self.source.consumed()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteUnreadHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(src: &'a mut ByteSource<'b>) -> ByteUnreadHandle<'a, 'b>{\n        ByteUnreadHandle { source: src }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::ByteUnreadHandle::<'a, 'b>::unread":["#[inline(always)]\npub fn unread(self) -> usize{\n        self.source.unread()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::CopyAsciiResult":["pub enum CopyAsciiResult<T, U> {\n    Stop(T),\n    GoOn(U),\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Endian":["pub trait Endian {\n    const OPPOSITE_ENDIAN: bool;\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::LittleEndian":["pub struct LittleEndian;","Real(LocalPath(\"src/handles.rs\"))"],"handles::NonAscii":["pub enum NonAscii {\n    BmpExclAscii(u16),\n    Astral(char),\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Space":["pub enum Space<T> {\n    Available(T),\n    Full(usize),\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::UnalignedU16Slice":["struct UnalignedU16Slice {\n    ptr: *const u8,\n    len: usize,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::UnalignedU16Slice::at":["#[inline(always)]\npub fn at(&self, i: usize) -> u16{\n        assert!(i < self.len);\n        unsafe {\n            let mut u: u16 = ::std::mem::uninitialized();\n            ::std::ptr::copy_nonoverlapping(self.ptr.add(i * 2), &mut u as *mut u16 as *mut u8, 2);\n            u\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::UnalignedU16Slice::copy_bmp_to":["#[cfg(not(feature = \"simd-accel\"))]\n#[inline(always)]\nfn copy_bmp_to<E: Endian>(&self, other: &mut [u16]) -> Option<(u16, usize)>{\n        assert!(self.len <= other.len());\n        for (i, target) in other.iter_mut().enumerate().take(self.len) {\n            let unit = swap_if_opposite_endian::<E>(self.at(i));\n            *target = unit;\n            if super::in_range16(unit, 0xD800, 0xE000) {\n                return Some((unit, i));\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::UnalignedU16Slice::len":["#[inline(always)]\npub fn len(&self) -> usize{\n        self.len\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::UnalignedU16Slice::new":["#[inline(always)]\npub unsafe fn new(ptr: *const u8, len: usize) -> UnalignedU16Slice{\n        UnalignedU16Slice { ptr, len }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::UnalignedU16Slice::tail":["#[inline(always)]\npub fn tail(&self, from: usize) -> UnalignedU16Slice{\n        // XXX the return value should be restricted not to\n        // outlive self.\n        assert!(from <= self.len);\n        unsafe { UnalignedU16Slice::new(self.ptr.add(from * 2), self.len - from) }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::UnalignedU16Slice::trim_last":["#[inline(always)]\npub fn trim_last(&mut self){\n        assert!(self.len > 0);\n        self.len -= 1;\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Unicode":["pub enum Unicode {\n    Ascii(u8),\n    NonAscii(NonAscii),\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16AstralHandle":["pub struct Utf16AstralHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    dest: &'a mut Utf16Destination<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16AstralHandle::<'a, 'b>::commit":["#[inline(always)]\npub fn commit(self) -> &'a mut Utf16Destination<'b>{\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16AstralHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(dst: &'a mut Utf16Destination<'b>) -> Utf16AstralHandle<'a, 'b>{\n        Utf16AstralHandle { dest: dst }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16AstralHandle::<'a, 'b>::write_ascii":["#[inline(always)]\npub fn write_ascii(self, ascii: u8) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_ascii(ascii);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16AstralHandle::<'a, 'b>::write_astral":["#[inline(always)]\npub fn write_astral(self, astral: u32) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_astral(astral);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16AstralHandle::<'a, 'b>::write_big5_combination":["#[inline(always)]\npub fn write_big5_combination(\n        self,\n        combined: u16,\n        combining: u16,\n    ) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_big5_combination(combined, combining);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16AstralHandle::<'a, 'b>::write_bmp":["#[inline(always)]\npub fn write_bmp(self, bmp: u16) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_bmp(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16AstralHandle::<'a, 'b>::write_bmp_excl_ascii":["#[inline(always)]\npub fn write_bmp_excl_ascii(self, bmp: u16) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_bmp_excl_ascii(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16AstralHandle::<'a, 'b>::write_surrogate_pair":["#[inline(always)]\npub fn write_surrogate_pair(self, high: u16, low: u16) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_surrogate_pair(high, low);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16AstralHandle::<'a, 'b>::write_upper_bmp":["#[inline(always)]\npub fn write_upper_bmp(self, bmp: u16) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_upper_bmp(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16AstralHandle::<'a, 'b>::written":["#[inline(always)]\npub fn written(&self) -> usize{\n        self.dest.written()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16BmpHandle":["pub struct Utf16BmpHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    dest: &'a mut Utf16Destination<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16BmpHandle::<'a, 'b>::commit":["#[inline(always)]\npub fn commit(self) -> &'a mut Utf16Destination<'b>{\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16BmpHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(dst: &'a mut Utf16Destination<'b>) -> Utf16BmpHandle<'a, 'b>{\n        Utf16BmpHandle { dest: dst }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16BmpHandle::<'a, 'b>::write_ascii":["#[inline(always)]\npub fn write_ascii(self, ascii: u8) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_ascii(ascii);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16BmpHandle::<'a, 'b>::write_bmp":["#[inline(always)]\npub fn write_bmp(self, bmp: u16) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_bmp(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16BmpHandle::<'a, 'b>::write_bmp_excl_ascii":["#[inline(always)]\npub fn write_bmp_excl_ascii(self, bmp: u16) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_bmp_excl_ascii(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16BmpHandle::<'a, 'b>::write_mid_bmp":["#[inline(always)]\npub fn write_mid_bmp(self, bmp: u16) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_mid_bmp(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16BmpHandle::<'a, 'b>::write_upper_bmp":["#[inline(always)]\npub fn write_upper_bmp(self, bmp: u16) -> &'a mut Utf16Destination<'b>{\n        self.dest.write_upper_bmp(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16BmpHandle::<'a, 'b>::written":["#[inline(always)]\npub fn written(&self) -> usize{\n        self.dest.written()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination":["pub struct Utf16Destination<'a> {\n    slice: &'a mut [u16],\n    pos: usize,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::check_space_astral":["#[inline(always)]\npub fn check_space_astral<'b>(&'b mut self) -> Space<Utf16AstralHandle<'b, 'a>>{\n        if self.pos + 1 < self.slice.len() {\n            Space::Available(Utf16AstralHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::check_space_bmp":["#[inline(always)]\npub fn check_space_bmp<'b>(&'b mut self) -> Space<Utf16BmpHandle<'b, 'a>>{\n        if self.pos < self.slice.len() {\n            Space::Available(Utf16BmpHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::copy_ascii_from_check_space_astral":["#[inline(always)]\npub fn copy_ascii_from_check_space_astral<'b>(\n        &'b mut self,\n        source: &mut ByteSource,\n    ) -> CopyAsciiResult<(DecoderResult, usize, usize), (u8, Utf16AstralHandle<'b, 'a>)>{\n        let non_ascii_ret = {\n            let dst_len = self.slice.len();\n            let src_remaining = &source.slice[source.pos..];\n            let dst_remaining = &mut self.slice[self.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (DecoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (DecoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_basic_latin(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    source.pos += length;\n                    self.pos += length;\n                    return CopyAsciiResult::Stop((pending, source.pos, self.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    source.pos += consumed;\n                    self.pos += consumed;\n                    if self.pos + 1 < dst_len {\n                        source.pos += 1; // +1 for non_ascii\n                        non_ascii\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            DecoderResult::OutputFull,\n                            source.pos,\n                            self.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, Utf16AstralHandle::new(self)))\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::copy_ascii_from_check_space_bmp":["#[inline(always)]\npub fn copy_ascii_from_check_space_bmp<'b>(\n        &'b mut self,\n        source: &mut ByteSource,\n    ) -> CopyAsciiResult<(DecoderResult, usize, usize), (u8, Utf16BmpHandle<'b, 'a>)>{\n        let non_ascii_ret = {\n            let src_remaining = &source.slice[source.pos..];\n            let dst_remaining = &mut self.slice[self.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (DecoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (DecoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_basic_latin(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    source.pos += length;\n                    self.pos += length;\n                    return CopyAsciiResult::Stop((pending, source.pos, self.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    source.pos += consumed;\n                    self.pos += consumed;\n                    source.pos += 1; // +1 for non_ascii\n                    non_ascii\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, Utf16BmpHandle::new(self)))\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::copy_utf16_from":["#[inline(always)]\npub fn copy_utf16_from<E: Endian>(\n        &mut self,\n        source: &mut ByteSource,\n    ) -> Option<(usize, usize)>{\n        let src_remaining = &source.slice[source.pos..];\n        let dst_remaining = &mut self.slice[self.pos..];\n\n        let mut src_unaligned = unsafe {\n            UnalignedU16Slice::new(\n                src_remaining.as_ptr(),\n                ::std::cmp::min(src_remaining.len() / 2, dst_remaining.len()),\n            )\n        };\n        if src_unaligned.len() == 0 {\n            return None;\n        }\n        let last_unit = swap_if_opposite_endian::<E>(src_unaligned.at(src_unaligned.len() - 1));\n        if super::in_range16(last_unit, 0xD800, 0xDC00) {\n            // Last code unit is a high surrogate. It might\n            // legitimately form a pair later, so let's not\n            // include it.\n            src_unaligned.trim_last();\n        }\n        let mut offset = 0usize;\n        loop {\n            if let Some((surrogate, bmp_len)) = {\n                let src_left = src_unaligned.tail(offset);\n                let dst_left = &mut dst_remaining[offset..src_unaligned.len()];\n                src_left.copy_bmp_to::<E>(dst_left)\n            } {\n                offset += bmp_len; // surrogate has not been consumed yet\n                let second_pos = offset + 1;\n                if surrogate > 0xDBFF || second_pos == src_unaligned.len() {\n                    // Unpaired surrogate\n                    source.pos += second_pos * 2;\n                    self.pos += offset;\n                    return Some((source.pos, self.pos));\n                }\n                let second = swap_if_opposite_endian::<E>(src_unaligned.at(second_pos));\n                if !super::in_range16(second, 0xDC00, 0xE000) {\n                    // Unpaired surrogate\n                    source.pos += second_pos * 2;\n                    self.pos += offset;\n                    return Some((source.pos, self.pos));\n                }\n                // `surrogate` was already speculatively written\n                dst_remaining[second_pos] = second;\n                offset += 2;\n                continue;\n            } else {\n                source.pos += src_unaligned.len() * 2;\n                self.pos += src_unaligned.len();\n                return None;\n            }\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::copy_utf8_up_to_invalid_from":["#[inline(always)]\npub fn copy_utf8_up_to_invalid_from(&mut self, source: &mut ByteSource){\n        let src_remaining = &source.slice[source.pos..];\n        let dst_remaining = &mut self.slice[self.pos..];\n        let (read, written) = convert_utf8_to_utf16_up_to_invalid(src_remaining, dst_remaining);\n        source.pos += read;\n        self.pos += written;\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::new":["#[inline(always)]\npub fn new(dst: &mut [u16]) -> Utf16Destination{\n        Utf16Destination { slice: dst, pos: 0 }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::write_ascii":["#[inline(always)]\nfn write_ascii(&mut self, ascii: u8){\n        debug_assert!(ascii < 0x80);\n        self.write_code_unit(u16::from(ascii));\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::write_astral":["#[inline(always)]\nfn write_astral(&mut self, astral: u32){\n        debug_assert!(astral > 0xFFFF);\n        debug_assert!(astral <= 0x10_FFFF);\n        self.write_code_unit((0xD7C0 + (astral >> 10)) as u16);\n        self.write_code_unit((0xDC00 + (astral & 0x3FF)) as u16);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::write_big5_combination":["#[inline(always)]\nfn write_big5_combination(&mut self, combined: u16, combining: u16){\n        self.write_bmp_excl_ascii(combined);\n        self.write_bmp_excl_ascii(combining);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::write_bmp":["#[inline(always)]\nfn write_bmp(&mut self, bmp: u16){\n        self.write_code_unit(bmp);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::write_bmp_excl_ascii":["#[inline(always)]\nfn write_bmp_excl_ascii(&mut self, bmp: u16){\n        debug_assert!(bmp >= 0x80);\n        self.write_code_unit(bmp);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::write_code_unit":["#[inline(always)]\nfn write_code_unit(&mut self, u: u16){\n        unsafe {\n            // OK, because we checked before handing out a handle.\n            *(self.slice.get_unchecked_mut(self.pos)) = u;\n        }\n        self.pos += 1;\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::write_mid_bmp":["#[inline(always)]\nfn write_mid_bmp(&mut self, bmp: u16){\n        debug_assert!(bmp >= 0x80); // XXX\n        self.write_code_unit(bmp);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::write_surrogate_pair":["#[inline(always)]\npub fn write_surrogate_pair(&mut self, high: u16, low: u16){\n        self.write_code_unit(high);\n        self.write_code_unit(low);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::write_upper_bmp":["#[inline(always)]\nfn write_upper_bmp(&mut self, bmp: u16){\n        debug_assert!(bmp >= 0x80);\n        self.write_code_unit(bmp);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Destination::<'a>::written":["#[inline(always)]\npub fn written(&self) -> usize{\n        self.pos\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16ReadHandle":["pub struct Utf16ReadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    source: &'a mut Utf16Source<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16ReadHandle::<'a, 'b>::consumed":["#[inline(always)]\npub fn consumed(&self) -> usize{\n        self.source.consumed()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16ReadHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(src: &'a mut Utf16Source<'b>) -> Utf16ReadHandle<'a, 'b>{\n        Utf16ReadHandle { source: src }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16ReadHandle::<'a, 'b>::read":["#[inline(always)]\npub fn read(self) -> (char, Utf16UnreadHandle<'a, 'b>){\n        let character = self.source.read();\n        let handle = Utf16UnreadHandle::new(self.source);\n        (character, handle)\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16ReadHandle::<'a, 'b>::read_enum":["#[inline(always)]\npub fn read_enum(self) -> (Unicode, Utf16UnreadHandle<'a, 'b>){\n        let character = self.source.read_enum();\n        let handle = Utf16UnreadHandle::new(self.source);\n        (character, handle)\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Source":["pub struct Utf16Source<'a> {\n    slice: &'a [u16],\n    pos: usize,\n    old_pos: usize,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Source::<'a>::check_available":["#[inline(always)]\npub fn check_available<'b>(&'b mut self) -> Space<Utf16ReadHandle<'b, 'a>>{\n        if self.pos < self.slice.len() {\n            Space::Available(Utf16ReadHandle::new(self))\n        } else {\n            Space::Full(self.consumed())\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Source::<'a>::consumed":["#[inline(always)]\npub fn consumed(&self) -> usize{\n        self.pos\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Source::<'a>::copy_ascii_to_check_space_four":["#[inline(always)]\npub fn copy_ascii_to_check_space_four<'b>(\n        &mut self,\n        dest: &'b mut ByteDestination<'a>,\n    ) -> CopyAsciiResult<(EncoderResult, usize, usize), (NonAscii, ByteFourHandle<'b, 'a>)>{\n        let non_ascii_ret = {\n            let dst_len = dest.slice.len();\n            let src_remaining = &self.slice[self.pos..];\n            let dst_remaining = &mut dest.slice[dest.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (EncoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (EncoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                basic_latin_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    self.pos += length;\n                    dest.pos += length;\n                    return CopyAsciiResult::Stop((pending, self.pos, dest.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    self.pos += consumed;\n                    dest.pos += consumed;\n                    if dest.pos + 3 < dst_len {\n                        self.pos += 1; // commit to reading `non_ascii`\n                        let unit = non_ascii;\n                        let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);\n                        if unit_minus_surrogate_start > (0xDFFF - 0xD800) {\n                            NonAscii::BmpExclAscii(unit)\n                        } else if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {\n                            // high surrogate\n                            if self.pos == self.slice.len() {\n                                // Unpaired surrogate at the end of the buffer.\n                                NonAscii::BmpExclAscii(0xFFFDu16)\n                            } else {\n                                let second = self.slice[self.pos];\n                                let second_minus_low_surrogate_start = second.wrapping_sub(0xDC00);\n                                if second_minus_low_surrogate_start <= (0xDFFF - 0xDC00) {\n                                    // The next code unit is a low surrogate. Advance position.\n                                    self.pos += 1;\n                                    NonAscii::Astral(unsafe {\n                                        ::std::char::from_u32_unchecked(\n                                            (u32::from(unit) << 10) + u32::from(second)\n                                                - (((0xD800u32 << 10) - 0x1_0000u32) + 0xDC00u32),\n                                        )\n                                    })\n                                } else {\n                                    // The next code unit is not a low surrogate. Don't advance\n                                    // position and treat the high surrogate as unpaired.\n                                    NonAscii::BmpExclAscii(0xFFFDu16)\n                                }\n                            }\n                        } else {\n                            // Unpaired low surrogate\n                            NonAscii::BmpExclAscii(0xFFFDu16)\n                        }\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            EncoderResult::OutputFull,\n                            self.pos,\n                            dest.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, ByteFourHandle::new(dest)))\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Source::<'a>::copy_ascii_to_check_space_two":["#[inline(always)]\npub fn copy_ascii_to_check_space_two<'b>(\n        &mut self,\n        dest: &'b mut ByteDestination<'a>,\n    ) -> CopyAsciiResult<(EncoderResult, usize, usize), (NonAscii, ByteTwoHandle<'b, 'a>)>{\n        let non_ascii_ret = {\n            let dst_len = dest.slice.len();\n            let src_remaining = &self.slice[self.pos..];\n            let dst_remaining = &mut dest.slice[dest.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (EncoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (EncoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                basic_latin_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    self.pos += length;\n                    dest.pos += length;\n                    return CopyAsciiResult::Stop((pending, self.pos, dest.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    self.pos += consumed;\n                    dest.pos += consumed;\n                    if dest.pos + 1 < dst_len {\n                        self.pos += 1; // commit to reading `non_ascii`\n                        let unit = non_ascii;\n                        let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);\n                        if unit_minus_surrogate_start > (0xDFFF - 0xD800) {\n                            NonAscii::BmpExclAscii(unit)\n                        } else if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {\n                            // high surrogate\n                            if self.pos < self.slice.len() {\n                                let second = self.slice[self.pos];\n                                let second_minus_low_surrogate_start = second.wrapping_sub(0xDC00);\n                                if second_minus_low_surrogate_start <= (0xDFFF - 0xDC00) {\n                                    // The next code unit is a low surrogate. Advance position.\n                                    self.pos += 1;\n                                    NonAscii::Astral(unsafe {\n                                        ::std::char::from_u32_unchecked(\n                                            (u32::from(unit) << 10) + u32::from(second)\n                                                - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),\n                                        )\n                                    })\n                                } else {\n                                    // The next code unit is not a low surrogate. Don't advance\n                                    // position and treat the high surrogate as unpaired.\n                                    NonAscii::BmpExclAscii(0xFFFDu16)\n                                }\n                            } else {\n                                // Unpaired surrogate at the end of the buffer.\n                                NonAscii::BmpExclAscii(0xFFFDu16)\n                            }\n                        } else {\n                            // Unpaired low surrogate\n                            NonAscii::BmpExclAscii(0xFFFDu16)\n                        }\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            EncoderResult::OutputFull,\n                            self.pos,\n                            dest.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, ByteTwoHandle::new(dest)))\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Source::<'a>::new":["#[inline(always)]\npub fn new(src: &[u16]) -> Utf16Source{\n        Utf16Source {\n            slice: src,\n            pos: 0,\n            old_pos: 0,\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Source::<'a>::read":["#[inline(always)]\nfn read(&mut self) -> char{\n        self.old_pos = self.pos;\n        let unit = self.slice[self.pos];\n        self.pos += 1;\n        let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);\n        if unit_minus_surrogate_start > (0xDFFF - 0xD800) {\n            return unsafe { ::std::char::from_u32_unchecked(u32::from(unit)) };\n        }\n        if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {\n            // high surrogate\n            if self.pos < self.slice.len() {\n                let second = self.slice[self.pos];\n                let second_minus_low_surrogate_start = second.wrapping_sub(0xDC00);\n                if second_minus_low_surrogate_start <= (0xDFFF - 0xDC00) {\n                    // The next code unit is a low surrogate. Advance position.\n                    self.pos += 1;\n                    return unsafe {\n                        ::std::char::from_u32_unchecked(\n                            (u32::from(unit) << 10) + u32::from(second)\n                                - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),\n                        )\n                    };\n                }\n                // The next code unit is not a low surrogate. Don't advance\n                // position and treat the high surrogate as unpaired.\n                // fall through\n            }\n            // Unpaired surrogate at the end of buffer, fall through\n        }\n        // Unpaired low surrogate\n        '\\u{FFFD}'\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Source::<'a>::read_enum":["#[inline(always)]\nfn read_enum(&mut self) -> Unicode{\n        self.old_pos = self.pos;\n        let unit = self.slice[self.pos];\n        self.pos += 1;\n        if unit < 0x80 {\n            return Unicode::Ascii(unit as u8);\n        }\n        let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);\n        if unit_minus_surrogate_start > (0xDFFF - 0xD800) {\n            return Unicode::NonAscii(NonAscii::BmpExclAscii(unit));\n        }\n        if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {\n            // high surrogate\n            if self.pos < self.slice.len() {\n                let second = self.slice[self.pos];\n                let second_minus_low_surrogate_start = second.wrapping_sub(0xDC00);\n                if second_minus_low_surrogate_start <= (0xDFFF - 0xDC00) {\n                    // The next code unit is a low surrogate. Advance position.\n                    self.pos += 1;\n                    return Unicode::NonAscii(NonAscii::Astral(unsafe {\n                        ::std::char::from_u32_unchecked(\n                            (u32::from(unit) << 10) + u32::from(second)\n                                - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),\n                        )\n                    }));\n                }\n                // The next code unit is not a low surrogate. Don't advance\n                // position and treat the high surrogate as unpaired.\n                // fall through\n            }\n            // Unpaired surrogate at the end of buffer, fall through\n        }\n        // Unpaired low surrogate\n        Unicode::NonAscii(NonAscii::BmpExclAscii(0xFFFDu16))\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16Source::<'a>::unread":["#[inline(always)]\nfn unread(&mut self) -> usize{\n        self.pos = self.old_pos;\n        self.pos\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16UnreadHandle":["pub struct Utf16UnreadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    source: &'a mut Utf16Source<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16UnreadHandle::<'a, 'b>::commit":["#[inline(always)]\npub fn commit(self) -> &'a mut Utf16Source<'b>{\n        self.source\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16UnreadHandle::<'a, 'b>::consumed":["#[inline(always)]\npub fn consumed(&self) -> usize{\n        self.source.consumed()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16UnreadHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(src: &'a mut Utf16Source<'b>) -> Utf16UnreadHandle<'a, 'b>{\n        Utf16UnreadHandle { source: src }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf16UnreadHandle::<'a, 'b>::unread":["#[inline(always)]\npub fn unread(self) -> usize{\n        self.source.unread()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8AstralHandle":["pub struct Utf8AstralHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    dest: &'a mut Utf8Destination<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8AstralHandle::<'a, 'b>::commit":["#[inline(always)]\npub fn commit(self) -> &'a mut Utf8Destination<'b>{\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8AstralHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(dst: &'a mut Utf8Destination<'b>) -> Utf8AstralHandle<'a, 'b>{\n        Utf8AstralHandle { dest: dst }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8AstralHandle::<'a, 'b>::write_ascii":["#[inline(always)]\npub fn write_ascii(self, ascii: u8) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_ascii(ascii);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8AstralHandle::<'a, 'b>::write_astral":["#[inline(always)]\npub fn write_astral(self, astral: u32) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_astral(astral);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8AstralHandle::<'a, 'b>::write_big5_combination":["#[inline(always)]\npub fn write_big5_combination(\n        self,\n        combined: u16,\n        combining: u16,\n    ) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_big5_combination(combined, combining);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8AstralHandle::<'a, 'b>::write_bmp":["#[inline(always)]\npub fn write_bmp(self, bmp: u16) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_bmp(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8AstralHandle::<'a, 'b>::write_bmp_excl_ascii":["#[inline(always)]\npub fn write_bmp_excl_ascii(self, bmp: u16) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_bmp_excl_ascii(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8AstralHandle::<'a, 'b>::write_surrogate_pair":["#[inline(always)]\npub fn write_surrogate_pair(self, high: u16, low: u16) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_surrogate_pair(high, low);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8AstralHandle::<'a, 'b>::write_upper_bmp":["#[inline(always)]\npub fn write_upper_bmp(self, bmp: u16) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_upper_bmp(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8AstralHandle::<'a, 'b>::written":["#[inline(always)]\npub fn written(&self) -> usize{\n        self.dest.written()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8BmpHandle":["pub struct Utf8BmpHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    dest: &'a mut Utf8Destination<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8BmpHandle::<'a, 'b>::commit":["#[inline(always)]\npub fn commit(self) -> &'a mut Utf8Destination<'b>{\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8BmpHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(dst: &'a mut Utf8Destination<'b>) -> Utf8BmpHandle<'a, 'b>{\n        Utf8BmpHandle { dest: dst }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8BmpHandle::<'a, 'b>::write_ascii":["#[inline(always)]\npub fn write_ascii(self, ascii: u8) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_ascii(ascii);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8BmpHandle::<'a, 'b>::write_bmp":["#[inline(always)]\npub fn write_bmp(self, bmp: u16) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_bmp(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8BmpHandle::<'a, 'b>::write_bmp_excl_ascii":["#[inline(always)]\npub fn write_bmp_excl_ascii(self, bmp: u16) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_bmp_excl_ascii(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8BmpHandle::<'a, 'b>::write_mid_bmp":["#[inline(always)]\npub fn write_mid_bmp(self, bmp: u16) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_mid_bmp(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8BmpHandle::<'a, 'b>::write_upper_bmp":["#[inline(always)]\npub fn write_upper_bmp(self, bmp: u16) -> &'a mut Utf8Destination<'b>{\n        self.dest.write_upper_bmp(bmp);\n        self.dest\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8BmpHandle::<'a, 'b>::written":["#[inline(always)]\npub fn written(&self) -> usize{\n        self.dest.written()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination":["pub struct Utf8Destination<'a> {\n    slice: &'a mut [u8],\n    pos: usize,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::check_space_astral":["#[inline(always)]\npub fn check_space_astral<'b>(&'b mut self) -> Space<Utf8AstralHandle<'b, 'a>>{\n        if self.pos + 3 < self.slice.len() {\n            Space::Available(Utf8AstralHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::check_space_bmp":["#[inline(always)]\npub fn check_space_bmp<'b>(&'b mut self) -> Space<Utf8BmpHandle<'b, 'a>>{\n        if self.pos + 2 < self.slice.len() {\n            Space::Available(Utf8BmpHandle::new(self))\n        } else {\n            Space::Full(self.written())\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::copy_ascii_from_check_space_astral":["#[inline(always)]\npub fn copy_ascii_from_check_space_astral<'b>(\n        &'b mut self,\n        source: &mut ByteSource,\n    ) -> CopyAsciiResult<(DecoderResult, usize, usize), (u8, Utf8AstralHandle<'b, 'a>)>{\n        let non_ascii_ret = {\n            let dst_len = self.slice.len();\n            let src_remaining = &source.slice[source.pos..];\n            let dst_remaining = &mut self.slice[self.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (DecoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (DecoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    source.pos += length;\n                    self.pos += length;\n                    return CopyAsciiResult::Stop((pending, source.pos, self.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    source.pos += consumed;\n                    self.pos += consumed;\n                    if self.pos + 3 < dst_len {\n                        source.pos += 1; // +1 for non_ascii\n                        non_ascii\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            DecoderResult::OutputFull,\n                            source.pos,\n                            self.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, Utf8AstralHandle::new(self)))\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::copy_ascii_from_check_space_bmp":["#[inline(always)]\npub fn copy_ascii_from_check_space_bmp<'b>(\n        &'b mut self,\n        source: &mut ByteSource,\n    ) -> CopyAsciiResult<(DecoderResult, usize, usize), (u8, Utf8BmpHandle<'b, 'a>)>{\n        let non_ascii_ret = {\n            let dst_len = self.slice.len();\n            let src_remaining = &source.slice[source.pos..];\n            let dst_remaining = &mut self.slice[self.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (DecoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (DecoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    source.pos += length;\n                    self.pos += length;\n                    return CopyAsciiResult::Stop((pending, source.pos, self.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    source.pos += consumed;\n                    self.pos += consumed;\n                    if self.pos + 2 < dst_len {\n                        source.pos += 1; // +1 for non_ascii\n                        non_ascii\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            DecoderResult::OutputFull,\n                            source.pos,\n                            self.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, Utf8BmpHandle::new(self)))\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::copy_utf16_from":["#[inline(always)]\npub fn copy_utf16_from<E: Endian>(\n        &mut self,\n        source: &mut ByteSource,\n    ) -> Option<(usize, usize)>{\n        let src_remaining = &source.slice[source.pos..];\n        let dst_remaining = &mut self.slice[self.pos..];\n\n        let mut src_unaligned =\n            unsafe { UnalignedU16Slice::new(src_remaining.as_ptr(), src_remaining.len() / 2) };\n        if src_unaligned.len() == 0 {\n            return None;\n        }\n        let mut last_unit = src_unaligned.at(src_unaligned.len() - 1);\n        if E::OPPOSITE_ENDIAN {\n            last_unit = last_unit.swap_bytes();\n        }\n        if super::in_range16(last_unit, 0xD800, 0xDC00) {\n            // Last code unit is a high surrogate. It might\n            // legitimately form a pair later, so let's not\n            // include it.\n            src_unaligned.trim_last();\n        }\n        let (read, written, had_error) =\n            convert_unaligned_utf16_to_utf8::<E>(src_unaligned, dst_remaining);\n        source.pos += read * 2;\n        self.pos += written;\n        if had_error {\n            Some((source.pos, self.pos))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::copy_utf8_up_to_invalid_from":["#[inline(always)]\npub fn copy_utf8_up_to_invalid_from(&mut self, source: &mut ByteSource){\n        let src_remaining = &source.slice[source.pos..];\n        let dst_remaining = &mut self.slice[self.pos..];\n        let min_len = ::std::cmp::min(src_remaining.len(), dst_remaining.len());\n        // Validate first, then memcpy to let memcpy do its thing even for\n        // non-ASCII. (And potentially do something better than SSE2 for ASCII.)\n        let valid_len = utf8_valid_up_to(&src_remaining[..min_len]);\n        (&mut dst_remaining[..valid_len]).copy_from_slice(&src_remaining[..valid_len]);\n        source.pos += valid_len;\n        self.pos += valid_len;\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::new":["#[inline(always)]\npub fn new(dst: &mut [u8]) -> Utf8Destination{\n        Utf8Destination { slice: dst, pos: 0 }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::write_ascii":["#[inline(always)]\nfn write_ascii(&mut self, ascii: u8){\n        debug_assert!(ascii < 0x80);\n        self.write_code_unit(ascii);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::write_astral":["#[inline(always)]\nfn write_astral(&mut self, astral: u32){\n        debug_assert!(astral > 0xFFFF);\n        debug_assert!(astral <= 0x10_FFFF);\n        self.write_code_unit(((astral >> 18) | 0xF0) as u8);\n        self.write_code_unit((((astral & 0x3F000) >> 12) | 0x80) as u8);\n        self.write_code_unit((((astral & 0xFC0) >> 6) | 0x80) as u8);\n        self.write_code_unit(((astral & 0x3F) | 0x80) as u8);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::write_big5_combination":["#[inline(always)]\nfn write_big5_combination(&mut self, combined: u16, combining: u16){\n        self.write_mid_bmp(combined);\n        self.write_mid_bmp(combining);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::write_bmp":["#[inline(always)]\nfn write_bmp(&mut self, bmp: u16){\n        if bmp < 0x80u16 {\n            self.write_ascii(bmp as u8);\n        } else if bmp < 0x800u16 {\n            self.write_mid_bmp(bmp);\n        } else {\n            self.write_upper_bmp(bmp);\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::write_bmp_excl_ascii":["#[inline(always)]\nfn write_bmp_excl_ascii(&mut self, bmp: u16){\n        if bmp < 0x800u16 {\n            self.write_mid_bmp(bmp);\n        } else {\n            self.write_upper_bmp(bmp);\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::write_code_unit":["#[inline(always)]\nfn write_code_unit(&mut self, u: u8){\n        unsafe {\n            // OK, because we checked before handing out a handle.\n            *(self.slice.get_unchecked_mut(self.pos)) = u;\n        }\n        self.pos += 1;\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::write_mid_bmp":["#[inline(always)]\nfn write_mid_bmp(&mut self, mid_bmp: u16){\n        debug_assert!(mid_bmp >= 0x80);\n        debug_assert!(mid_bmp < 0x800);\n        self.write_code_unit(((mid_bmp >> 6) | 0xC0) as u8);\n        self.write_code_unit(((mid_bmp & 0x3F) | 0x80) as u8);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::write_surrogate_pair":["#[inline(always)]\npub fn write_surrogate_pair(&mut self, high: u16, low: u16){\n        self.write_astral(\n            (u32::from(high) << 10) + u32::from(low)\n                - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),\n        );\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::write_upper_bmp":["#[inline(always)]\nfn write_upper_bmp(&mut self, upper_bmp: u16){\n        debug_assert!(upper_bmp >= 0x800);\n        self.write_code_unit(((upper_bmp >> 12) | 0xE0) as u8);\n        self.write_code_unit((((upper_bmp & 0xFC0) >> 6) | 0x80) as u8);\n        self.write_code_unit(((upper_bmp & 0x3F) | 0x80) as u8);\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Destination::<'a>::written":["#[inline(always)]\npub fn written(&self) -> usize{\n        self.pos\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8ReadHandle":["pub struct Utf8ReadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    source: &'a mut Utf8Source<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8ReadHandle::<'a, 'b>::consumed":["#[inline(always)]\npub fn consumed(&self) -> usize{\n        self.source.consumed()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8ReadHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(src: &'a mut Utf8Source<'b>) -> Utf8ReadHandle<'a, 'b>{\n        Utf8ReadHandle { source: src }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8ReadHandle::<'a, 'b>::read":["#[inline(always)]\npub fn read(self) -> (char, Utf8UnreadHandle<'a, 'b>){\n        let character = self.source.read();\n        let handle = Utf8UnreadHandle::new(self.source);\n        (character, handle)\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8ReadHandle::<'a, 'b>::read_enum":["#[inline(always)]\npub fn read_enum(self) -> (Unicode, Utf8UnreadHandle<'a, 'b>){\n        let character = self.source.read_enum();\n        let handle = Utf8UnreadHandle::new(self.source);\n        (character, handle)\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Source":["pub struct Utf8Source<'a> {\n    slice: &'a [u8],\n    pos: usize,\n    old_pos: usize,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Source::<'a>::check_available":["#[inline(always)]\npub fn check_available<'b>(&'b mut self) -> Space<Utf8ReadHandle<'b, 'a>>{\n        if self.pos < self.slice.len() {\n            Space::Available(Utf8ReadHandle::new(self))\n        } else {\n            Space::Full(self.consumed())\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Source::<'a>::consumed":["#[inline(always)]\npub fn consumed(&self) -> usize{\n        self.pos\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Source::<'a>::copy_ascii_to_check_space_four":["#[inline(always)]\npub fn copy_ascii_to_check_space_four<'b>(\n        &mut self,\n        dest: &'b mut ByteDestination<'a>,\n    ) -> CopyAsciiResult<(EncoderResult, usize, usize), (NonAscii, ByteFourHandle<'b, 'a>)>{\n        let non_ascii_ret = {\n            let dst_len = dest.slice.len();\n            let src_remaining = &self.slice[self.pos..];\n            let dst_remaining = &mut dest.slice[dest.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (EncoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (EncoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    self.pos += length;\n                    dest.pos += length;\n                    return CopyAsciiResult::Stop((pending, self.pos, dest.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    self.pos += consumed;\n                    dest.pos += consumed;\n                    if dest.pos + 3 < dst_len {\n                        if non_ascii < 0xE0 {\n                            let point = ((u16::from(non_ascii) & 0x1F) << 6)\n                                | (u16::from(self.slice[self.pos + 1]) & 0x3F);\n                            self.pos += 2;\n                            NonAscii::BmpExclAscii(point)\n                        } else if non_ascii < 0xF0 {\n                            let point = ((u16::from(non_ascii) & 0xF) << 12)\n                                | ((u16::from(self.slice[self.pos + 1]) & 0x3F) << 6)\n                                | (u16::from(self.slice[self.pos + 2]) & 0x3F);\n                            self.pos += 3;\n                            NonAscii::BmpExclAscii(point)\n                        } else {\n                            let point = ((u32::from(non_ascii) & 0x7) << 18)\n                                | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)\n                                | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)\n                                | (u32::from(self.slice[self.pos + 3]) & 0x3F);\n                            self.pos += 4;\n                            NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })\n                        }\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            EncoderResult::OutputFull,\n                            self.pos,\n                            dest.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, ByteFourHandle::new(dest)))\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Source::<'a>::copy_ascii_to_check_space_one":["#[inline(always)]\npub fn copy_ascii_to_check_space_one<'b>(\n        &mut self,\n        dest: &'b mut ByteDestination<'a>,\n    ) -> CopyAsciiResult<(EncoderResult, usize, usize), (NonAscii, ByteOneHandle<'b, 'a>)>{\n        let non_ascii_ret = {\n            let src_remaining = &self.slice[self.pos..];\n            let dst_remaining = &mut dest.slice[dest.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (EncoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (EncoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    self.pos += length;\n                    dest.pos += length;\n                    return CopyAsciiResult::Stop((pending, self.pos, dest.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    self.pos += consumed;\n                    dest.pos += consumed;\n                    // We don't need to check space in destination, because\n                    // `ascii_to_ascii()` already did.\n                    if non_ascii < 0xE0 {\n                        let point = ((u16::from(non_ascii) & 0x1F) << 6)\n                            | (u16::from(self.slice[self.pos + 1]) & 0x3F);\n                        self.pos += 2;\n                        NonAscii::BmpExclAscii(point)\n                    } else if non_ascii < 0xF0 {\n                        let point = ((u16::from(non_ascii) & 0xF) << 12)\n                            | ((u16::from(self.slice[self.pos + 1]) & 0x3F) << 6)\n                            | (u16::from(self.slice[self.pos + 2]) & 0x3F);\n                        self.pos += 3;\n                        NonAscii::BmpExclAscii(point)\n                    } else {\n                        let point = ((u32::from(non_ascii) & 0x7) << 18)\n                            | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)\n                            | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)\n                            | (u32::from(self.slice[self.pos + 3]) & 0x3F);\n                        self.pos += 4;\n                        NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, ByteOneHandle::new(dest)))\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Source::<'a>::copy_ascii_to_check_space_two":["#[inline(always)]\npub fn copy_ascii_to_check_space_two<'b>(\n        &mut self,\n        dest: &'b mut ByteDestination<'a>,\n    ) -> CopyAsciiResult<(EncoderResult, usize, usize), (NonAscii, ByteTwoHandle<'b, 'a>)>{\n        let non_ascii_ret = {\n            let dst_len = dest.slice.len();\n            let src_remaining = &self.slice[self.pos..];\n            let dst_remaining = &mut dest.slice[dest.pos..];\n            let (pending, length) = if dst_remaining.len() < src_remaining.len() {\n                (EncoderResult::OutputFull, dst_remaining.len())\n            } else {\n                (EncoderResult::InputEmpty, src_remaining.len())\n            };\n            match unsafe {\n                ascii_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    self.pos += length;\n                    dest.pos += length;\n                    return CopyAsciiResult::Stop((pending, self.pos, dest.pos));\n                }\n                Some((non_ascii, consumed)) => {\n                    self.pos += consumed;\n                    dest.pos += consumed;\n                    if dest.pos + 1 < dst_len {\n                        if non_ascii < 0xE0 {\n                            let point = ((u16::from(non_ascii) & 0x1F) << 6)\n                                | (u16::from(self.slice[self.pos + 1]) & 0x3F);\n                            self.pos += 2;\n                            NonAscii::BmpExclAscii(point)\n                        } else if non_ascii < 0xF0 {\n                            let point = ((u16::from(non_ascii) & 0xF) << 12)\n                                | ((u16::from(self.slice[self.pos + 1]) & 0x3F) << 6)\n                                | (u16::from(self.slice[self.pos + 2]) & 0x3F);\n                            self.pos += 3;\n                            NonAscii::BmpExclAscii(point)\n                        } else {\n                            let point = ((u32::from(non_ascii) & 0x7) << 18)\n                                | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)\n                                | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)\n                                | (u32::from(self.slice[self.pos + 3]) & 0x3F);\n                            self.pos += 4;\n                            NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })\n                        }\n                    } else {\n                        return CopyAsciiResult::Stop((\n                            EncoderResult::OutputFull,\n                            self.pos,\n                            dest.pos,\n                        ));\n                    }\n                }\n            }\n        };\n        CopyAsciiResult::GoOn((non_ascii_ret, ByteTwoHandle::new(dest)))\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Source::<'a>::new":["#[inline(always)]\npub fn new(src: &str) -> Utf8Source{\n        Utf8Source {\n            slice: src.as_bytes(),\n            pos: 0,\n            old_pos: 0,\n        }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Source::<'a>::read":["#[inline(always)]\nfn read(&mut self) -> char{\n        self.old_pos = self.pos;\n        let unit = self.slice[self.pos];\n        if unit < 0x80 {\n            self.pos += 1;\n            return char::from(unit);\n        }\n        if unit < 0xE0 {\n            let point =\n                ((u32::from(unit) & 0x1F) << 6) | (u32::from(self.slice[self.pos + 1]) & 0x3F);\n            self.pos += 2;\n            return unsafe { ::std::char::from_u32_unchecked(point) };\n        }\n        if unit < 0xF0 {\n            let point = ((u32::from(unit) & 0xF) << 12)\n                | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 6)\n                | (u32::from(self.slice[self.pos + 2]) & 0x3F);\n            self.pos += 3;\n            return unsafe { ::std::char::from_u32_unchecked(point) };\n        }\n        let point = ((u32::from(unit) & 0x7) << 18)\n            | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)\n            | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)\n            | (u32::from(self.slice[self.pos + 3]) & 0x3F);\n        self.pos += 4;\n        unsafe { ::std::char::from_u32_unchecked(point) }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Source::<'a>::read_enum":["#[inline(always)]\nfn read_enum(&mut self) -> Unicode{\n        self.old_pos = self.pos;\n        let unit = self.slice[self.pos];\n        if unit < 0x80 {\n            self.pos += 1;\n            return Unicode::Ascii(unit);\n        }\n        if unit < 0xE0 {\n            let point =\n                ((u16::from(unit) & 0x1F) << 6) | (u16::from(self.slice[self.pos + 1]) & 0x3F);\n            self.pos += 2;\n            return Unicode::NonAscii(NonAscii::BmpExclAscii(point));\n        }\n        if unit < 0xF0 {\n            let point = ((u16::from(unit) & 0xF) << 12)\n                | ((u16::from(self.slice[self.pos + 1]) & 0x3F) << 6)\n                | (u16::from(self.slice[self.pos + 2]) & 0x3F);\n            self.pos += 3;\n            return Unicode::NonAscii(NonAscii::BmpExclAscii(point));\n        }\n        let point = ((u32::from(unit) & 0x7) << 18)\n            | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)\n            | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)\n            | (u32::from(self.slice[self.pos + 3]) & 0x3F);\n        self.pos += 4;\n        Unicode::NonAscii(NonAscii::Astral(unsafe {\n            ::std::char::from_u32_unchecked(point)\n        }))\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8Source::<'a>::unread":["#[inline(always)]\nfn unread(&mut self) -> usize{\n        self.pos = self.old_pos;\n        self.pos\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8UnreadHandle":["pub struct Utf8UnreadHandle<'a, 'b>\nwhere\n    'b: 'a,\n{\n    source: &'a mut Utf8Source<'b>,\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8UnreadHandle::<'a, 'b>::commit":["#[inline(always)]\npub fn commit(self) -> &'a mut Utf8Source<'b>{\n        self.source\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8UnreadHandle::<'a, 'b>::consumed":["#[inline(always)]\npub fn consumed(&self) -> usize{\n        self.source.consumed()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8UnreadHandle::<'a, 'b>::new":["#[inline(always)]\nfn new(src: &'a mut Utf8Source<'b>) -> Utf8UnreadHandle<'a, 'b>{\n        Utf8UnreadHandle { source: src }\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::Utf8UnreadHandle::<'a, 'b>::unread":["#[inline(always)]\npub fn unread(self) -> usize{\n        self.source.unread()\n    }","Real(LocalPath(\"src/handles.rs\"))"],"handles::convert_unaligned_utf16_to_utf8":["#[inline(always)]\nfn convert_unaligned_utf16_to_utf8<E: Endian>(\n    src: UnalignedU16Slice,\n    dst: &mut [u8],\n) -> (usize, usize, bool){\n    if dst.len() < 4 {\n        return (0, 0, false);\n    }\n    let mut src_pos = 0usize;\n    let mut dst_pos = 0usize;\n    let src_len = src.len();\n    let dst_len_minus_three = dst.len() - 3;\n    'outer: loop {\n        let mut non_ascii = match copy_unaligned_basic_latin_to_ascii::<E>(\n            src.tail(src_pos),\n            &mut dst[dst_pos..],\n        ) {\n            CopyAsciiResult::GoOn((unit, read_written)) => {\n                src_pos += read_written;\n                dst_pos += read_written;\n                unit\n            }\n            CopyAsciiResult::Stop(read_written) => {\n                return (src_pos + read_written, dst_pos + read_written, false);\n            }\n        };\n        if dst_pos >= dst_len_minus_three {\n            break 'outer;\n        }\n        // We have enough destination space to commit to\n        // having read `non_ascii`.\n        src_pos += 1;\n        'inner: loop {\n            let non_ascii_minus_surrogate_start = non_ascii.wrapping_sub(0xD800);\n            if non_ascii_minus_surrogate_start > (0xDFFF - 0xD800) {\n                if non_ascii < 0x800 {\n                    dst[dst_pos] = ((non_ascii >> 6) | 0xC0) as u8;\n                    dst_pos += 1;\n                    dst[dst_pos] = ((non_ascii & 0x3F) | 0x80) as u8;\n                    dst_pos += 1;\n                } else {\n                    dst[dst_pos] = ((non_ascii >> 12) | 0xE0) as u8;\n                    dst_pos += 1;\n                    dst[dst_pos] = (((non_ascii & 0xFC0) >> 6) | 0x80) as u8;\n                    dst_pos += 1;\n                    dst[dst_pos] = ((non_ascii & 0x3F) | 0x80) as u8;\n                    dst_pos += 1;\n                }\n            } else if non_ascii_minus_surrogate_start <= (0xDBFF - 0xD800) {\n                // high surrogate\n                if src_pos < src_len {\n                    let second = swap_if_opposite_endian::<E>(src.at(src_pos));\n                    let second_minus_low_surrogate_start = second.wrapping_sub(0xDC00);\n                    if second_minus_low_surrogate_start <= (0xDFFF - 0xDC00) {\n                        // The next code unit is a low surrogate. Advance position.\n                        src_pos += 1;\n                        let point = (u32::from(non_ascii) << 10) + u32::from(second)\n                            - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32);\n\n                        dst[dst_pos] = ((point >> 18) | 0xF0u32) as u8;\n                        dst_pos += 1;\n                        dst[dst_pos] = (((point & 0x3F000u32) >> 12) | 0x80u32) as u8;\n                        dst_pos += 1;\n                        dst[dst_pos] = (((point & 0xFC0u32) >> 6) | 0x80u32) as u8;\n                        dst_pos += 1;\n                        dst[dst_pos] = ((point & 0x3Fu32) | 0x80u32) as u8;\n                        dst_pos += 1;\n                    } else {\n                        // The next code unit is not a low surrogate. Don't advance\n                        // position and treat the high surrogate as unpaired.\n                        return (src_pos, dst_pos, true);\n                    }\n                } else {\n                    // Unpaired surrogate at the end of buffer\n                    return (src_pos, dst_pos, true);\n                }\n            } else {\n                // Unpaired low surrogate\n                return (src_pos, dst_pos, true);\n            }\n            if dst_pos >= dst_len_minus_three || src_pos == src_len {\n                break 'outer;\n            }\n            let unit = swap_if_opposite_endian::<E>(src.at(src_pos));\n            src_pos += 1;\n            if unit > 0x7F {\n                non_ascii = unit;\n                continue 'inner;\n            }\n            dst[dst_pos] = unit as u8;\n            dst_pos += 1;\n            continue 'outer;\n        }\n    }\n    (src_pos, dst_pos, false)\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::copy_unaligned_basic_latin_to_ascii":["#[cfg(not(feature = \"simd-accel\"))]\n#[inline(always)]\nfn copy_unaligned_basic_latin_to_ascii<E: Endian>(\n    src: UnalignedU16Slice,\n    dst: &mut [u8],\n) -> CopyAsciiResult<usize, (u16, usize)>{\n    copy_unaligned_basic_latin_to_ascii_alu::<E>(src, dst, 0)\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::copy_unaligned_basic_latin_to_ascii_alu":["#[inline(always)]\nfn copy_unaligned_basic_latin_to_ascii_alu<E: Endian>(\n    src: UnalignedU16Slice,\n    dst: &mut [u8],\n    offset: usize,\n) -> CopyAsciiResult<usize, (u16, usize)>{\n    let len = ::std::cmp::min(src.len(), dst.len());\n    let mut i = 0usize;\n    loop {\n        if i == len {\n            return CopyAsciiResult::Stop(i + offset);\n        }\n        let unit = swap_if_opposite_endian::<E>(src.at(i));\n        if unit > 0x7F {\n            return CopyAsciiResult::GoOn((unit, i + offset));\n        }\n        dst[i] = unit as u8;\n        i += 1;\n    }\n}","Real(LocalPath(\"src/handles.rs\"))"],"handles::swap_if_opposite_endian":["#[inline(always)]\nfn swap_if_opposite_endian<E: Endian>(unit: u16) -> u16{\n    if E::OPPOSITE_ENDIAN {\n        unit.swap_bytes()\n    } else {\n        unit\n    }\n}","Real(LocalPath(\"src/handles.rs\"))"],"in_inclusive_range":["#[inline(always)]\nfn in_inclusive_range(i: usize, start: usize, end: usize) -> bool{\n    i.wrapping_sub(start) <= (end - start)\n}","Real(LocalPath(\"src/lib.rs\"))"],"in_inclusive_range16":["#[inline(always)]\nfn in_inclusive_range16(i: u16, start: u16, end: u16) -> bool{\n    i.wrapping_sub(start) <= (end - start)\n}","Real(LocalPath(\"src/lib.rs\"))"],"in_inclusive_range32":["#[inline(always)]\nfn in_inclusive_range32(i: u32, start: u32, end: u32) -> bool{\n    i.wrapping_sub(start) <= (end - start)\n}","Real(LocalPath(\"src/lib.rs\"))"],"in_inclusive_range8":["#[inline(always)]\nfn in_inclusive_range8(i: u8, start: u8, end: u8) -> bool{\n    i.wrapping_sub(start) <= (end - start)\n}","Real(LocalPath(\"src/lib.rs\"))"],"in_range16":["#[inline(always)]\nfn in_range16(i: u16, start: u16, end: u16) -> bool{\n    i.wrapping_sub(start) < (end - start)\n}","Real(LocalPath(\"src/lib.rs\"))"],"in_range32":["#[inline(always)]\nfn in_range32(i: u32, start: u32, end: u32) -> bool{\n    i.wrapping_sub(start) < (end - start)\n}","Real(LocalPath(\"src/lib.rs\"))"],"iso_2022_jp::Iso2022JpDecoder":["pub struct Iso2022JpDecoder {\n    decoder_state: Iso2022JpDecoderState,\n    output_state: Iso2022JpDecoderState, // only takes 1 of first 4 values\n    lead: u8,\n    output_flag: bool,\n    pending_prepended: bool,\n}","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpDecoder::decode_to_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut $dest = $dest_struct::new(dst);\n        loop { // TODO: remove this loop\n            {\n                // Start non-boilerplate\n                $preamble\n                // End non-boilerplate\n            }\n            loop {\n                {\n                    $loop_preable\n                }\n                match $source.check_available() {\n                    Space::Full($src_consumed) => {\n                        if last {\n                            // Start non-boilerplate\n                            $eof\n                            // End non-boilerplate\n                        }\n                        return (DecoderResult::InputEmpty, $src_consumed, $dest.written());\n                    }\n                    Space::Available(source_handle) => {\n                        match $dest.$destination_check() {\n                            Space::Full(dst_written) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle.consumed(),\n                                        dst_written);\n                            }\n                            Space::Available($destination_handle) => {\n                                let ($b, $unread_handle) = source_handle.read();\n                                // Start non-boilerplate\n                                $body\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"iso_2022_jp::Iso2022JpDecoder::decode_to_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut $dest = $dest_struct::new(dst);\n        loop { // TODO: remove this loop\n            {\n                // Start non-boilerplate\n                $preamble\n                // End non-boilerplate\n            }\n            loop {\n                {\n                    $loop_preable\n                }\n                match $source.check_available() {\n                    Space::Full($src_consumed) => {\n                        if last {\n                            // Start non-boilerplate\n                            $eof\n                            // End non-boilerplate\n                        }\n                        return (DecoderResult::InputEmpty, $src_consumed, $dest.written());\n                    }\n                    Space::Available(source_handle) => {\n                        match $dest.$destination_check() {\n                            Space::Full(dst_written) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle.consumed(),\n                                        dst_written);\n                            }\n                            Space::Available($destination_handle) => {\n                                let ($b, $unread_handle) = source_handle.read();\n                                // Start non-boilerplate\n                                $body\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"iso_2022_jp::Iso2022JpDecoder::extra_to_input_from_state":["fn extra_to_input_from_state(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_add(\n            if self.lead == 0 || self.pending_prepended {\n                0\n            } else {\n                1\n            } + match self.decoder_state {\n                Iso2022JpDecoderState::Escape | Iso2022JpDecoderState::EscapeStart => 1,\n                _ => 0,\n            },\n        )\n    }","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpDecoder::extra_to_output_from_state":["fn extra_to_output_from_state(&self) -> usize{\n        if self.lead != 0 && self.pending_prepended {\n            1 + self.output_flag as usize\n        } else {\n            self.output_flag as usize\n        }\n    }","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpDecoder::in_neutral_state":["pub fn in_neutral_state(&self) -> bool{\n        self.decoder_state == Iso2022JpDecoderState::Ascii\n            && self.output_state == Iso2022JpDecoderState::Ascii\n            && self.lead == 0u8\n            && !self.output_flag\n            && !self.pending_prepended\n    }","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpDecoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        checked_add(\n            self.extra_to_output_from_state(),\n            self.extra_to_input_from_state(byte_length),\n        )\n    }","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpDecoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        checked_mul(\n            3,\n            checked_add(\n                self.extra_to_output_from_state(),\n                self.extra_to_input_from_state(byte_length),\n            ),\n        )\n    }","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpDecoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        // worst case: 1 to 3 (half-width katakana)\n        self.max_utf8_buffer_length(byte_length)\n    }","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpDecoder::new":["pub fn new() -> VariantDecoder{\n        VariantDecoder::Iso2022Jp(Iso2022JpDecoder {\n            decoder_state: Iso2022JpDecoderState::Ascii,\n            output_state: Iso2022JpDecoderState::Ascii,\n            lead: 0u8,\n            output_flag: false,\n            pending_prepended: false,\n        })\n    }","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpDecoderState":["enum Iso2022JpDecoderState {\n    Ascii,\n    Roman,\n    Katakana,\n    LeadByte,\n    TrailByte,\n    EscapeStart,\n    Escape,\n}","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpEncoder":["pub struct Iso2022JpEncoder {\n    state: Iso2022JpEncoderState,\n}","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpEncoder::encode_from_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut $dest = ByteDestination::new(dst);\n        loop {\n            match $source.check_available() {\n                Space::Full($src_consumed) => {\n                    if last {\n                        // Start non-boilerplate\n                        $eof\n                        // End non-boilerplate\n                    }\n                    return (EncoderResult::InputEmpty, $src_consumed, $dest.written());\n                }\n                Space::Available(source_handle) => {\n                    match $dest.$destination_check() {\n                        Space::Full(dst_written) => {\n                            return (EncoderResult::OutputFull,\n                                    source_handle.consumed(),\n                                    dst_written);\n                        }\n                        Space::Available($destination_handle) => {\n                            let ($c, $unread_handle) = source_handle.read();\n                            // Start non-boilerplate\n                            $body\n                            // End non-boilerplate\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"iso_2022_jp::Iso2022JpEncoder::encode_from_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut $dest = ByteDestination::new(dst);\n        loop {\n            match $source.check_available() {\n                Space::Full($src_consumed) => {\n                    if last {\n                        // Start non-boilerplate\n                        $eof\n                        // End non-boilerplate\n                    }\n                    return (EncoderResult::InputEmpty, $src_consumed, $dest.written());\n                }\n                Space::Available(source_handle) => {\n                    match $dest.$destination_check() {\n                        Space::Full(dst_written) => {\n                            return (EncoderResult::OutputFull,\n                                    source_handle.consumed(),\n                                    dst_written);\n                        }\n                        Space::Available($destination_handle) => {\n                            let ($c, $unread_handle) = source_handle.read();\n                            // Start non-boilerplate\n                            $body\n                            // End non-boilerplate\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"iso_2022_jp::Iso2022JpEncoder::has_pending_state":["pub fn has_pending_state(&self) -> bool{\n        match self.state {\n            Iso2022JpEncoderState::Ascii => false,\n            _ => true,\n        }\n    }","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpEncoder::max_buffer_length_from_utf16_without_replacement":["pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        // Worst case: every other character is ASCII/Roman and every other\n        // JIS0208.\n        // Two UTF-16 input units:\n        // Transition to Roman: 3\n        // Roman/ASCII: 1\n        // Transition to JIS0208: 3\n        // JIS0208: 2\n        // End transition: 3\n        checked_add_opt(\n            checked_add(3, u16_length.checked_mul(4)),\n            checked_div(u16_length.checked_add(1), 2),\n        )\n    }","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpEncoder::max_buffer_length_from_utf8_without_replacement":["pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        // Worst case: every other character is ASCII/Roman and every other\n        // JIS0208.\n        // Three UTF-8 input units: 1 ASCII, 2 JIS0208\n        // Transition to ASCII: 3\n        // Roman/ASCII: 1\n        // Transition to JIS0208: 3\n        // JIS0208: 2\n        // End transition: 3\n        checked_add(3, byte_length.checked_mul(3))\n    }","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpEncoder::new":["pub fn new(encoding: &'static Encoding) -> Encoder{\n        Encoder::new(\n            encoding,\n            VariantEncoder::Iso2022Jp(Iso2022JpEncoder {\n                state: Iso2022JpEncoderState::Ascii,\n            }),\n        )\n    }","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::Iso2022JpEncoderState":["enum Iso2022JpEncoderState {\n    Ascii,\n    Roman,\n    Jis0208,\n}","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::encode_kanji":["#[cfg(not(feature = \"fast-kanji-encode\"))]\n#[inline(always)]\nfn encode_kanji(bmp: u16) -> Option<(u8, u8)>{\n    if 0x4EDD == bmp {\n        // Ideograph on the symbol row!\n        Some((0x21, 0xB8 - 0x80))\n    } else if let Some((lead, trail)) = jis0208_level1_kanji_iso_2022_jp_encode(bmp) {\n        Some((lead, trail))\n    } else if let Some(pos) = jis0208_level2_and_additional_kanji_encode(bmp) {\n        let lead = (pos / 94) + (0xD0 - 0x80);\n        let trail = (pos % 94) + 0x21;\n        Some((lead as u8, trail as u8))\n    } else if let Some(pos) = position(&IBM_KANJI[..], bmp) {\n        let lead = (pos / 94) + (0xF9 - 0x80);\n        let trail = (pos % 94) + 0x21;\n        Some((lead as u8, trail as u8))\n    } else {\n        None\n    }\n}","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::is_kanji_mapped":["#[cfg(not(feature = \"fast-kanji-encode\"))]\n#[inline(always)]\nfn is_kanji_mapped(bmp: u16) -> bool{\n    if 0x4EDD == bmp {\n        true\n    } else if let Some(_) = jis0208_level1_kanji_shift_jis_encode(bmp) {\n        // Use the shift_jis variant, because we don't care about the\n        // byte values here.\n        true\n    } else if let Some(_) = jis0208_level2_and_additional_kanji_encode(bmp) {\n        true\n    } else if let Some(_) = position(&IBM_KANJI[..], bmp) {\n        true\n    } else {\n        false\n    }\n}","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"iso_2022_jp::is_mapped_for_two_byte_encode":["fn is_mapped_for_two_byte_encode(bmp: u16) -> bool{\n    // The code below uses else after return to\n    // keep the same structure as in EUC-JP.\n    // Lunde says 60% Hiragana, 30% Kanji, 10% Katakana\n    let bmp_minus_hiragana = bmp.wrapping_sub(0x3041);\n    if bmp_minus_hiragana < 0x53 {\n        true\n    } else if in_inclusive_range16(bmp, 0x4E00, 0x9FA0) {\n        is_kanji_mapped(bmp)\n    } else {\n        let bmp_minus_katakana = bmp.wrapping_sub(0x30A1);\n        if bmp_minus_katakana < 0x56 {\n            true\n        } else {\n            let bmp_minus_space = bmp.wrapping_sub(0x3000);\n            if bmp_minus_space < 3 {\n                // fast-track common punctuation\n                true\n            } else if in_inclusive_range16(bmp, 0xFF61, 0xFF9F) {\n                true\n            } else if bmp == 0x2212 {\n                true\n            } else if let Some(_) = jis0208_range_encode(bmp) {\n                true\n            } else if in_inclusive_range16(bmp, 0xFA0E, 0xFA2D) || bmp == 0xF929 || bmp == 0xF9DC {\n                true\n            } else if let Some(_) = ibm_symbol_encode(bmp) {\n                true\n            } else if let Some(_) = jis0208_symbol_encode(bmp) {\n                true\n            } else {\n                false\n            }\n        }\n    }\n}","Real(LocalPath(\"src/iso_2022_jp.rs\"))"],"mem::Latin1Bidi":["/// Classification of text as Latin1 (all code points are below U+0100),\n/// left-to-right with some non-Latin1 characters or as containing at least\n/// some right-to-left characters.\n#[must_use]\n#[repr(C)]\npub enum Latin1Bidi {\n    /// Every character is below U+0100.\n    Latin1 = 0,\n    /// There is at least one character that's U+0100 or higher, but there\n    /// are no right-to-left characters.\n    LeftToRight = 1,\n    /// There is at least one right-to-left character.\n    Bidi = 2,\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::check_str_for_latin1_and_bidi":["/// Checks whether a valid UTF-8 buffer contains code points\n/// that trigger right-to-left processing or is all-Latin1.\n///\n/// Possibly more efficient than performing the checks separately.\n///\n/// Returns `Latin1Bidi::Latin1` if `is_str_latin1()` would return `true`.\n/// Otherwise, returns `Latin1Bidi::Bidi` if `is_str_bidi()` would return\n/// `true`. Otherwise, returns `Latin1Bidi::LeftToRight`.\npub fn check_str_for_latin1_and_bidi(buffer: &str) -> Latin1Bidi{\n    // The transition from the latin1 check to the bidi check isn't\n    // optimal but not tweaking it to perfection today.\n    if let Some(offset) = is_str_latin1_impl(buffer) {\n        if is_str_bidi(&buffer[offset..]) {\n            Latin1Bidi::Bidi\n        } else {\n            Latin1Bidi::LeftToRight\n        }\n    } else {\n        Latin1Bidi::Latin1\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::check_utf16_for_latin1_and_bidi":["/// Checks whether a potentially invalid UTF-16 buffer contains code points\n/// that trigger right-to-left processing or is all-Latin1.\n///\n/// Possibly more efficient than performing the checks separately.\n///\n/// Returns `Latin1Bidi::Latin1` if `is_utf16_latin1()` would return `true`.\n/// Otherwise, returns `Latin1Bidi::Bidi` if `is_utf16_bidi()` would return\n/// `true`. Otherwise, returns `Latin1Bidi::LeftToRight`.\npub fn check_utf16_for_latin1_and_bidi(buffer: &[u16]) -> Latin1Bidi{\n    check_utf16_for_latin1_and_bidi_impl(buffer)\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::check_utf16_for_latin1_and_bidi_impl":["#[inline(always)]\nfn check_utf16_for_latin1_and_bidi_impl(buffer: &[u16]) -> Latin1Bidi{\n            let mut offset = 0usize;\n            let len = buffer.len();\n            if len >= ALU_ALIGNMENT / 2 {\n                let src = buffer.as_ptr();\n                let mut until_alignment = ((ALU_ALIGNMENT - ((src as usize) & ALU_ALIGNMENT_MASK)) &\n                                           ALU_ALIGNMENT_MASK) / 2;\n                if until_alignment + ALU_ALIGNMENT / 2 <= len {\n                    while until_alignment != 0 {\n                        if buffer[offset] > 0xFF {\n                            if is_utf16_bidi_impl(&buffer[offset..]) {\n                                return Latin1Bidi::Bidi;\n                            }\n                            return Latin1Bidi::LeftToRight;\n                        }\n                        offset += 1;\n                        until_alignment -= 1;\n                    }\n                    let len_minus_stride = len - ALU_ALIGNMENT / 2;\n                    loop {\n                        if unsafe { *(src.add(offset) as *const usize) } & LATIN1_MASK != 0 {\n                            if is_utf16_bidi_impl(&buffer[offset..]) {\n                                return Latin1Bidi::Bidi;\n                            }\n                            return Latin1Bidi::LeftToRight;\n                        }\n                        offset += ALU_ALIGNMENT / 2;\n                        if offset > len_minus_stride {\n                            break;\n                        }\n                    }\n                }\n            }\n            let mut iter = (&buffer[offset..]).iter();\n            loop {\n                if let Some(&u) = iter.next() {\n                    if u > 0xFF {\n                        let mut inner_u = u;\n                        loop {\n                            if is_utf16_code_unit_bidi(inner_u) {\n                                return Latin1Bidi::Bidi;\n                            }\n                            if let Some(&code_unit) = iter.next() {\n                                inner_u = code_unit;\n                            } else {\n                                return Latin1Bidi::LeftToRight;\n                            }\n                        }\n                    }\n                } else {\n                    return Latin1Bidi::Latin1;\n                }\n            }\n        }","Real(LocalPath(\"src/mem.rs\"))"],"mem::check_utf8_for_latin1_and_bidi":["/// Checks whether a potentially invalid UTF-8 buffer contains code points\n/// that trigger right-to-left processing or is all-Latin1.\n///\n/// Possibly more efficient than performing the checks separately.\n///\n/// Returns `Latin1Bidi::Latin1` if `is_utf8_latin1()` would return `true`.\n/// Otherwise, returns `Latin1Bidi::Bidi` if `is_utf8_bidi()` would return\n/// `true`. Otherwise, returns `Latin1Bidi::LeftToRight`.\npub fn check_utf8_for_latin1_and_bidi(buffer: &[u8]) -> Latin1Bidi{\n    if let Some(offset) = is_utf8_latin1_impl(buffer) {\n        if is_utf8_bidi(&buffer[offset..]) {\n            Latin1Bidi::Bidi\n        } else {\n            Latin1Bidi::LeftToRight\n        }\n    } else {\n        Latin1Bidi::Latin1\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_latin1_to_str":["/// Converts bytes whose unsigned value is interpreted as Unicode code point\n/// (i.e. U+0000 to U+00FF, inclusive) to UTF-8 such that the validity of the\n/// output is signaled using the Rust type system.\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer times two.\n///\n/// Returns the number of bytes written.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\n#[inline]\npub fn convert_latin1_to_str(src: &[u8], dst: &mut str) -> usize{\n    assert!(\n        dst.len() >= src.len() * 2,\n        \"Destination must not be shorter than the source times two.\"\n    );\n    let (read, written) = convert_latin1_to_str_partial(src, dst);\n    debug_assert_eq!(read, src.len());\n    written\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_latin1_to_str_partial":["/// Converts bytes whose unsigned value is interpreted as Unicode code point\n/// (i.e. U+0000 to U+00FF, inclusive) to UTF-8 such that the validity of the\n/// output is signaled using the Rust type system with potentially insufficient\n/// output space.\n///\n/// Returns the number of bytes read and the number of bytes written.\n///\n/// If the output isn't large enough, not all input is consumed.\n#[inline]\npub fn convert_latin1_to_str_partial(src: &[u8], dst: &mut str) -> (usize, usize){\n    let bytes: &mut [u8] = unsafe { dst.as_bytes_mut() };\n    let (read, written) = convert_latin1_to_utf8_partial(src, bytes);\n    let len = bytes.len();\n    let mut trail = written;\n    let max = ::std::cmp::min(len, trail + MAX_STRIDE_SIZE);\n    while trail < max {\n        bytes[trail] = 0;\n        trail += 1;\n    }\n    while trail < len && ((bytes[trail] & 0xC0) == 0x80) {\n        bytes[trail] = 0;\n        trail += 1;\n    }\n    (read, written)\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_latin1_to_utf16":["/// Converts bytes whose unsigned value is interpreted as Unicode code point\n/// (i.e. U+0000 to U+00FF, inclusive) to UTF-16.\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer.\n///\n/// The number of `u16`s written equals the length of the source buffer.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\npub fn convert_latin1_to_utf16(src: &[u8], dst: &mut [u16]){\n    assert!(\n        dst.len() >= src.len(),\n        \"Destination must not be shorter than the source.\"\n    );\n    // TODO: On aarch64, the safe version autovectorizes to the same unpacking\n    // instructions and this code, but, yet, the autovectorized version is\n    // faster.\n    unsafe {\n        unpack_latin1(src.as_ptr(), dst.as_mut_ptr(), src.len());\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_latin1_to_utf8":["/// Converts bytes whose unsigned value is interpreted as Unicode code point\n/// (i.e. U+0000 to U+00FF, inclusive) to UTF-8.\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer times two.\n///\n/// Returns the number of bytes written.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\n///\n/// # Safety\n///\n/// Note that this function may write garbage beyond the number of bytes\n/// indicated by the return value, so using a `&mut str` interpreted as\n/// `&mut [u8]` as the destination is not safe. If you want to convert into\n/// a `&mut str`, use `convert_utf16_to_str()` instead of this function.\n#[inline]\npub fn convert_latin1_to_utf8(src: &[u8], dst: &mut [u8]) -> usize{\n    assert!(\n        dst.len() >= src.len() * 2,\n        \"Destination must not be shorter than the source times two.\"\n    );\n    let (read, written) = convert_latin1_to_utf8_partial(src, dst);\n    debug_assert_eq!(read, src.len());\n    written\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_latin1_to_utf8_partial":["/// Converts bytes whose unsigned value is interpreted as Unicode code point\n/// (i.e. U+0000 to U+00FF, inclusive) to UTF-8 with potentially insufficient\n/// output space.\n///\n/// Returns the number of bytes read and the number of bytes written.\n///\n/// If the output isn't large enough, not all input is consumed.\n///\n/// # Safety\n///\n/// If you want to convert into a `&mut str`, use\n/// `convert_utf16_to_str_partial()` instead of using this function\n/// together with the `unsafe` method `as_bytes_mut()` on `&mut str`.\npub fn convert_latin1_to_utf8_partial(src: &[u8], dst: &mut [u8]) -> (usize, usize){\n    let src_len = src.len();\n    let src_ptr = src.as_ptr();\n    let dst_ptr = dst.as_mut_ptr();\n    let dst_len = dst.len();\n    let mut total_read = 0usize;\n    let mut total_written = 0usize;\n    loop {\n        // src can't advance more than dst\n        let src_left = src_len - total_read;\n        let dst_left = dst_len - total_written;\n        let min_left = ::std::cmp::min(src_left, dst_left);\n        if let Some((non_ascii, consumed)) = unsafe {\n            ascii_to_ascii(\n                src_ptr.add(total_read),\n                dst_ptr.add(total_written),\n                min_left,\n            )\n        } {\n            total_read += consumed;\n            total_written += consumed;\n            if total_written.checked_add(2).unwrap() > dst_len {\n                return (total_read, total_written);\n            }\n\n            total_read += 1; // consume `non_ascii`\n\n            dst[total_written] = (non_ascii >> 6) | 0xC0;\n            total_written += 1;\n            dst[total_written] = (non_ascii & 0x3F) | 0x80;\n            total_written += 1;\n            continue;\n        }\n        return (total_read + min_left, total_written + min_left);\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_str_to_utf16":["/// Converts valid UTF-8 to valid UTF-16.\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer.\n///\n/// Returns the number of `u16`s written.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\npub fn convert_str_to_utf16(src: &str, dst: &mut [u16]) -> usize{\n    assert!(\n        dst.len() >= src.len(),\n        \"Destination must not be shorter than the source.\"\n    );\n    let bytes = src.as_bytes();\n    let mut read = 0;\n    let mut written = 0;\n    'outer: loop {\n        let mut byte = {\n            let src_remaining = &bytes[read..];\n            let dst_remaining = &mut dst[written..];\n            let length = src_remaining.len();\n            match unsafe {\n                ascii_to_basic_latin(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    written += length;\n                    return written;\n                }\n                Some((non_ascii, consumed)) => {\n                    read += consumed;\n                    written += consumed;\n                    non_ascii\n                }\n            }\n        };\n        'inner: loop {\n            // At this point, `byte` is not included in `read`.\n            if byte < 0xE0 {\n                if byte >= 0x80 {\n                    // Two-byte\n                    let second = unsafe { *(bytes.get_unchecked(read + 1)) };\n                    let point = ((u16::from(byte) & 0x1F) << 6) | (u16::from(second) & 0x3F);\n                    unsafe { *(dst.get_unchecked_mut(written)) = point };\n                    read += 2;\n                    written += 1;\n                } else {\n                    // ASCII: write and go back to SIMD.\n                    unsafe { *(dst.get_unchecked_mut(written)) = u16::from(byte) };\n                    read += 1;\n                    written += 1;\n                    // Intuitively, we should go back to the outer loop only\n                    // if byte is 0x30 or above, so as to avoid trashing on\n                    // ASCII space, comma and period in non-Latin context.\n                    // However, the extra branch seems to cost more than it's\n                    // worth.\n                    continue 'outer;\n                }\n            } else if byte < 0xF0 {\n                // Three-byte\n                let second = unsafe { *(bytes.get_unchecked(read + 1)) };\n                let third = unsafe { *(bytes.get_unchecked(read + 2)) };\n                let point = ((u16::from(byte) & 0xF) << 12)\n                    | ((u16::from(second) & 0x3F) << 6)\n                    | (u16::from(third) & 0x3F);\n                unsafe { *(dst.get_unchecked_mut(written)) = point };\n                read += 3;\n                written += 1;\n            } else {\n                // Four-byte\n                let second = unsafe { *(bytes.get_unchecked(read + 1)) };\n                let third = unsafe { *(bytes.get_unchecked(read + 2)) };\n                let fourth = unsafe { *(bytes.get_unchecked(read + 3)) };\n                let point = ((u32::from(byte) & 0x7) << 18)\n                    | ((u32::from(second) & 0x3F) << 12)\n                    | ((u32::from(third) & 0x3F) << 6)\n                    | (u32::from(fourth) & 0x3F);\n                unsafe { *(dst.get_unchecked_mut(written)) = (0xD7C0 + (point >> 10)) as u16 };\n                unsafe {\n                    *(dst.get_unchecked_mut(written + 1)) = (0xDC00 + (point & 0x3FF)) as u16\n                };\n                read += 4;\n                written += 2;\n            }\n            // The comparison is always < or == and never >, but including\n            // > here to let the compiler assume that < is true if this\n            // comparison is false.\n            if read >= src.len() {\n                return written;\n            }\n            byte = bytes[read];\n            continue 'inner;\n        }\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_utf16_to_latin1_lossy":["/// If the input is valid UTF-16 representing only Unicode code points from\n/// U+0000 to U+00FF, inclusive, converts the input into output that\n/// represents the value of each code point as the unsigned byte value of\n/// each output byte.\n///\n/// If the input does not fulfill the condition stated above, does something\n/// that is memory-safe without any promises about any properties of the\n/// output and will probably assert in debug builds in future versions.\n/// In particular, callers shouldn't assume the output to be the same across\n/// crate versions or CPU architectures and should not assume that non-ASCII\n/// input can't map to ASCII output.\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer.\n///\n/// The number of bytes written equals the length of the source buffer.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\n///\n/// (Probably in future versions if debug assertions are enabled (and not\n/// fuzzing) and the input is not in the range U+0000 to U+00FF, inclusive.)\npub fn convert_utf16_to_latin1_lossy(src: &[u16], dst: &mut [u8]){\n    assert!(\n        dst.len() >= src.len(),\n        \"Destination must not be shorter than the source.\"\n    );\n    // non_fuzz_debug_assert!(is_utf16_latin1(src));\n    unsafe {\n        pack_latin1(src.as_ptr(), dst.as_mut_ptr(), src.len());\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_utf16_to_str":["/// Converts potentially-invalid UTF-16 to valid UTF-8 with errors replaced\n/// with the REPLACEMENT CHARACTER such that the validity of the output is\n/// signaled using the Rust type system.\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer times three.\n///\n/// Returns the number of bytes written.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\n#[inline(always)]\npub fn convert_utf16_to_str(src: &[u16], dst: &mut str) -> usize{\n    assert!(dst.len() >= src.len() * 3);\n    let (read, written) = convert_utf16_to_str_partial(src, dst);\n    debug_assert_eq!(read, src.len());\n    written\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_utf16_to_str_partial":["/// Converts potentially-invalid UTF-16 to valid UTF-8 with errors replaced\n/// with the REPLACEMENT CHARACTER such that the validity of the output is\n/// signaled using the Rust type system with potentially insufficient output\n/// space.\n///\n/// Returns the number of code units read and the number of bytes written.\n///\n/// Not all code units are read if there isn't enough output space.\n///\n/// Note  that this method isn't designed for general streamability but for\n/// not allocating memory for the worst case up front. Specifically,\n/// if the input starts with or ends with an unpaired surrogate, those are\n/// replaced with the REPLACEMENT CHARACTER.\npub fn convert_utf16_to_str_partial(src: &[u16], dst: &mut str) -> (usize, usize){\n    let bytes: &mut [u8] = unsafe { dst.as_bytes_mut() };\n    let (read, written) = convert_utf16_to_utf8_partial(src, bytes);\n    let len = bytes.len();\n    let mut trail = written;\n    while trail < len && ((bytes[trail] & 0xC0) == 0x80) {\n        bytes[trail] = 0;\n        trail += 1;\n    }\n    (read, written)\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_utf16_to_utf8":["/// Converts potentially-invalid UTF-16 to valid UTF-8 with errors replaced\n/// with the REPLACEMENT CHARACTER.\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer times three.\n///\n/// Returns the number of bytes written.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\n///\n/// # Safety\n///\n/// If you want to convert into a `&mut str`, use `convert_utf16_to_str()`\n/// instead of using this function together with the `unsafe` method\n/// `as_bytes_mut()` on `&mut str`.\n#[inline(always)]\npub fn convert_utf16_to_utf8(src: &[u16], dst: &mut [u8]) -> usize{\n    assert!(dst.len() >= src.len() * 3);\n    let (read, written) = convert_utf16_to_utf8_partial(src, dst);\n    debug_assert_eq!(read, src.len());\n    written\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_utf16_to_utf8_partial":["/// Converts potentially-invalid UTF-16 to valid UTF-8 with errors replaced\n/// with the REPLACEMENT CHARACTER with potentially insufficient output\n/// space.\n///\n/// Returns the number of code units read and the number of bytes written.\n///\n/// Guarantees that the bytes in the destination beyond the number of\n/// bytes claimed as written by the second item of the return tuple\n/// are left unmodified.\n///\n/// Not all code units are read if there isn't enough output space.\n///\n/// Note  that this method isn't designed for general streamability but for\n/// not allocating memory for the worst case up front. Specifically,\n/// if the input starts with or ends with an unpaired surrogate, those are\n/// replaced with the REPLACEMENT CHARACTER.\n///\n/// Matches the semantics of `TextEncoder.encodeInto()` from the\n/// Encoding Standard.\n///\n/// # Safety\n///\n/// If you want to convert into a `&mut str`, use\n/// `convert_utf16_to_str_partial()` instead of using this function\n/// together with the `unsafe` method `as_bytes_mut()` on `&mut str`.\n#[inline(always)]\npub fn convert_utf16_to_utf8_partial(src: &[u16], dst: &mut [u8]) -> (usize, usize){\n    // The two functions called below are marked `inline(never)` to make\n    // transitions from the hot part (first function) into the cold part\n    // (second function) go through a return and another call to discouge\n    // the CPU from speculating from the hot code into the cold code.\n    // Letting the transitions be mere intra-function jumps, even to\n    // basic blocks out-of-lined to the end of the function would wipe\n    // away a quarter of Arabic encode performance on Haswell!\n    let (read, written) = convert_utf16_to_utf8_partial_inner(src, dst);\n    if unsafe { likely(read == src.len()) } {\n        return (read, written);\n    }\n    let (tail_read, tail_written) =\n        convert_utf16_to_utf8_partial_tail(&src[read..], &mut dst[written..]);\n    (read + tail_read, written + tail_written)\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_utf8_to_latin1_lossy":["/// If the input is valid UTF-8 representing only Unicode code points from\n/// U+0000 to U+00FF, inclusive, converts the input into output that\n/// represents the value of each code point as the unsigned byte value of\n/// each output byte.\n///\n/// If the input does not fulfill the condition stated above, this function\n/// panics if debug assertions are enabled (and fuzzing isn't) and otherwise\n/// does something that is memory-safe without any promises about any\n/// properties of the output. In particular, callers shouldn't assume the\n/// output to be the same across crate versions or CPU architectures and\n/// should not assume that non-ASCII input can't map to ASCII output.\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer.\n///\n/// Returns the number of bytes written.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\n///\n/// If debug assertions are enabled (and not fuzzing) and the input is\n/// not in the range U+0000 to U+00FF, inclusive.\npub fn convert_utf8_to_latin1_lossy(src: &[u8], dst: &mut [u8]) -> usize{\n    assert!(\n        dst.len() >= src.len(),\n        \"Destination must not be shorter than the source.\"\n    );\n    non_fuzz_debug_assert!(is_utf8_latin1(src));\n    let src_len = src.len();\n    let src_ptr = src.as_ptr();\n    let dst_ptr = dst.as_mut_ptr();\n    let mut total_read = 0usize;\n    let mut total_written = 0usize;\n    loop {\n        // dst can't advance more than src\n        let src_left = src_len - total_read;\n        if let Some((non_ascii, consumed)) = unsafe {\n            ascii_to_ascii(\n                src_ptr.add(total_read),\n                dst_ptr.add(total_written),\n                src_left,\n            )\n        } {\n            total_read += consumed + 1;\n            total_written += consumed;\n\n            if total_read == src_len {\n                return total_written;\n            }\n\n            let trail = src[total_read];\n            total_read += 1;\n\n            dst[total_written] = ((non_ascii & 0x1F) << 6) | (trail & 0x3F);\n            total_written += 1;\n            continue;\n        }\n        return total_written + src_left;\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_utf8_to_utf16":["/// Converts potentially-invalid UTF-8 to valid UTF-16 with errors replaced\n/// with the REPLACEMENT CHARACTER.\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer _plus one_.\n///\n/// Returns the number of `u16`s written.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\npub fn convert_utf8_to_utf16(src: &[u8], dst: &mut [u16]) -> usize{\n    // TODO: Can the requirement for dst to be at least one unit longer\n    // be eliminated?\n    assert!(dst.len() > src.len());\n    let mut decoder = Utf8Decoder::new_inner();\n    let mut total_read = 0usize;\n    let mut total_written = 0usize;\n    loop {\n        let (result, read, written) =\n            decoder.decode_to_utf16_raw(&src[total_read..], &mut dst[total_written..], true);\n        total_read += read;\n        total_written += written;\n        match result {\n            DecoderResult::InputEmpty => {\n                return total_written;\n            }\n            DecoderResult::OutputFull => {\n                unreachable!(\"The assert at the top of the function should have caught this.\");\n            }\n            DecoderResult::Malformed(_, _) => {\n                // There should always be space for the U+FFFD, because\n                // otherwise we'd have gotten OutputFull already.\n                dst[total_written] = 0xFFFD;\n                total_written += 1;\n            }\n        }\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::convert_utf8_to_utf16_without_replacement":["/// Converts potentially-invalid UTF-8 to valid UTF-16 signaling on error.\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer.\n///\n/// Returns the number of `u16`s written or `None` if the input was invalid.\n///\n/// When the input was invalid, some output may have been written.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\npub fn convert_utf8_to_utf16_without_replacement(src: &[u8], dst: &mut [u16]) -> Option<usize>{\n    assert!(\n        dst.len() >= src.len(),\n        \"Destination must not be shorter than the source.\"\n    );\n    let (read, written) = convert_utf8_to_utf16_up_to_invalid(src, dst);\n    if read == src.len() {\n        return Some(written);\n    }\n    None\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::copy_ascii_to_ascii":["/// Copies ASCII from source to destination up to the first non-ASCII byte\n/// (or the end of the input if it is ASCII in its entirety).\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer.\n///\n/// Returns the number of bytes written.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\npub fn copy_ascii_to_ascii(src: &[u8], dst: &mut [u8]) -> usize{\n    assert!(\n        dst.len() >= src.len(),\n        \"Destination must not be shorter than the source.\"\n    );\n    if let Some((_, consumed)) =\n        unsafe { ascii_to_ascii(src.as_ptr(), dst.as_mut_ptr(), src.len()) }\n    {\n        consumed\n    } else {\n        src.len()\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::copy_ascii_to_basic_latin":["/// Copies ASCII from source to destination zero-extending it to UTF-16 up to\n/// the first non-ASCII byte (or the end of the input if it is ASCII in its\n/// entirety).\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer.\n///\n/// Returns the number of `u16`s written.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\npub fn copy_ascii_to_basic_latin(src: &[u8], dst: &mut [u16]) -> usize{\n    assert!(\n        dst.len() >= src.len(),\n        \"Destination must not be shorter than the source.\"\n    );\n    if let Some((_, consumed)) =\n        unsafe { ascii_to_basic_latin(src.as_ptr(), dst.as_mut_ptr(), src.len()) }\n    {\n        consumed\n    } else {\n        src.len()\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::copy_basic_latin_to_ascii":["/// Copies Basic Latin from source to destination narrowing it to ASCII up to\n/// the first non-Basic Latin code unit (or the end of the input if it is\n/// Basic Latin in its entirety).\n///\n/// The length of the destination buffer must be at least the length of the\n/// source buffer.\n///\n/// Returns the number of bytes written.\n///\n/// # Panics\n///\n/// Panics if the destination buffer is shorter than stated above.\npub fn copy_basic_latin_to_ascii(src: &[u16], dst: &mut [u8]) -> usize{\n    assert!(\n        dst.len() >= src.len(),\n        \"Destination must not be shorter than the source.\"\n    );\n    if let Some((_, consumed)) =\n        unsafe { basic_latin_to_ascii(src.as_ptr(), dst.as_mut_ptr(), src.len()) }\n    {\n        consumed\n    } else {\n        src.len()\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::decode_latin1":["/// Converts bytes whose unsigned value is interpreted as Unicode code point\n/// (i.e. U+0000 to U+00FF, inclusive) to UTF-8.\n///\n/// Borrows if input is ASCII-only. Performs a single heap allocation\n/// otherwise.\npub fn decode_latin1<'a>(bytes: &'a [u8]) -> Cow<'a, str>{\n    let up_to = ascii_valid_up_to(bytes);\n    // >= makes later things optimize better than ==\n    if up_to >= bytes.len() {\n        debug_assert_eq!(up_to, bytes.len());\n        let s: &str = unsafe { ::std::str::from_utf8_unchecked(bytes) };\n        return Cow::Borrowed(s);\n    }\n    let (head, tail) = bytes.split_at(up_to);\n    let capacity = head.len() + tail.len() * 2;\n    let mut vec = Vec::with_capacity(capacity);\n    unsafe {\n        vec.set_len(capacity);\n    }\n    (&mut vec[..up_to]).copy_from_slice(head);\n    let written = convert_latin1_to_utf8(tail, &mut vec[up_to..]);\n    vec.truncate(up_to + written);\n    Cow::Owned(unsafe { String::from_utf8_unchecked(vec) })\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::encode_latin1_lossy":["/// If the input is valid UTF-8 representing only Unicode code points from\n/// U+0000 to U+00FF, inclusive, converts the input into output that\n/// represents the value of each code point as the unsigned byte value of\n/// each output byte.\n///\n/// If the input does not fulfill the condition stated above, this function\n/// panics if debug assertions are enabled (and fuzzing isn't) and otherwise\n/// does something that is memory-safe without any promises about any\n/// properties of the output. In particular, callers shouldn't assume the\n/// output to be the same across crate versions or CPU architectures and\n/// should not assume that non-ASCII input can't map to ASCII output.\n///\n/// Borrows if input is ASCII-only. Performs a single heap allocation\n/// otherwise.\npub fn encode_latin1_lossy<'a>(string: &'a str) -> Cow<'a, [u8]>{\n    let bytes = string.as_bytes();\n    let up_to = ascii_valid_up_to(bytes);\n    // >= makes later things optimize better than ==\n    if up_to >= bytes.len() {\n        debug_assert_eq!(up_to, bytes.len());\n        return Cow::Borrowed(bytes);\n    }\n    let (head, tail) = bytes.split_at(up_to);\n    let capacity = bytes.len();\n    let mut vec = Vec::with_capacity(capacity);\n    unsafe {\n        vec.set_len(capacity);\n    }\n    (&mut vec[..up_to]).copy_from_slice(head);\n    let written = convert_utf8_to_latin1_lossy(tail, &mut vec[up_to..]);\n    vec.truncate(up_to + written);\n    Cow::Owned(vec)\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::ensure_utf16_validity":["/// Replaces unpaired surrogates in the input with the REPLACEMENT CHARACTER.\n#[inline]\npub fn ensure_utf16_validity(buffer: &mut [u16]){\n    let mut offset = 0;\n    loop {\n        offset += utf16_valid_up_to(&buffer[offset..]);\n        if offset == buffer.len() {\n            return;\n        }\n        buffer[offset] = 0xFFFD;\n        offset += 1;\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_ascii":["/// Checks whether the buffer is all-ASCII.\n///\n/// May read the entire buffer even if it isn't all-ASCII. (I.e. the function\n/// is not guaranteed to fail fast.)\npub fn is_ascii(buffer: &[u8]) -> bool{\n    is_ascii_impl(buffer)\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_ascii_impl":["#[inline(always)]\nfn $name(buffer: &[$unit]) -> bool{\n            let mut offset = 0usize;\n            let mut accu = 0usize;\n            let unit_size = ::std::mem::size_of::<$unit>();\n            let len = buffer.len();\n            if len >= ALU_ALIGNMENT / unit_size {\n                // The most common reason to return `false` is for the first code\n                // unit to fail the test, so check that first.\n                if buffer[0] >= $bound {\n                    return false;\n                }\n                let src = buffer.as_ptr();\n                let mut until_alignment = ((ALU_ALIGNMENT - ((src as usize) & ALU_ALIGNMENT_MASK))\n                    & ALU_ALIGNMENT_MASK)\n                    / unit_size;\n                if until_alignment + ALU_ALIGNMENT / unit_size <= len {\n                    if until_alignment != 0 {\n                        accu |= buffer[offset] as usize;\n                        offset += 1;\n                        until_alignment -= 1;\n                        while until_alignment != 0 {\n                            accu |= buffer[offset] as usize;\n                            offset += 1;\n                            until_alignment -= 1;\n                        }\n                        if accu >= $bound {\n                            return false;\n                        }\n                    }\n                    let len_minus_stride = len - ALU_ALIGNMENT / unit_size;\n                    if offset + (4 * (ALU_ALIGNMENT / unit_size)) <= len {\n                        let len_minus_unroll = len - (4 * (ALU_ALIGNMENT / unit_size));\n                        loop {\n                            let unroll_accu = unsafe { *(src.add(offset) as *const usize) }\n                                | unsafe {\n                                    *(src.add(offset + (ALU_ALIGNMENT / unit_size)) as *const usize)\n                                }\n                                | unsafe {\n                                    *(src.add(offset + (2 * (ALU_ALIGNMENT / unit_size)))\n                                        as *const usize)\n                                }\n                                | unsafe {\n                                    *(src.add(offset + (3 * (ALU_ALIGNMENT / unit_size)))\n                                        as *const usize)\n                                };\n                            if unroll_accu & $mask != 0 {\n                                return false;\n                            }\n                            offset += 4 * (ALU_ALIGNMENT / unit_size);\n                            if offset > len_minus_unroll {\n                                break;\n                            }\n                        }\n                    }\n                    while offset <= len_minus_stride {\n                        accu |= unsafe { *(src.add(offset) as *const usize) };\n                        offset += ALU_ALIGNMENT / unit_size;\n                    }\n                }\n            }\n            for &unit in &buffer[offset..] {\n                accu |= unit as usize;\n            }\n            accu & $mask == 0\n        }","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_basic_latin":["/// Checks whether the buffer is all-Basic Latin (i.e. UTF-16 representing\n/// only ASCII characters).\n///\n/// May read the entire buffer even if it isn't all-ASCII. (I.e. the function\n/// is not guaranteed to fail fast.)\npub fn is_basic_latin(buffer: &[u16]) -> bool{\n    is_basic_latin_impl(buffer)\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_basic_latin_impl":["#[inline(always)]\nfn $name(buffer: &[$unit]) -> bool{\n            let mut offset = 0usize;\n            let mut accu = 0usize;\n            let unit_size = ::std::mem::size_of::<$unit>();\n            let len = buffer.len();\n            if len >= ALU_ALIGNMENT / unit_size {\n                // The most common reason to return `false` is for the first code\n                // unit to fail the test, so check that first.\n                if buffer[0] >= $bound {\n                    return false;\n                }\n                let src = buffer.as_ptr();\n                let mut until_alignment = ((ALU_ALIGNMENT - ((src as usize) & ALU_ALIGNMENT_MASK))\n                    & ALU_ALIGNMENT_MASK)\n                    / unit_size;\n                if until_alignment + ALU_ALIGNMENT / unit_size <= len {\n                    if until_alignment != 0 {\n                        accu |= buffer[offset] as usize;\n                        offset += 1;\n                        until_alignment -= 1;\n                        while until_alignment != 0 {\n                            accu |= buffer[offset] as usize;\n                            offset += 1;\n                            until_alignment -= 1;\n                        }\n                        if accu >= $bound {\n                            return false;\n                        }\n                    }\n                    let len_minus_stride = len - ALU_ALIGNMENT / unit_size;\n                    if offset + (4 * (ALU_ALIGNMENT / unit_size)) <= len {\n                        let len_minus_unroll = len - (4 * (ALU_ALIGNMENT / unit_size));\n                        loop {\n                            let unroll_accu = unsafe { *(src.add(offset) as *const usize) }\n                                | unsafe {\n                                    *(src.add(offset + (ALU_ALIGNMENT / unit_size)) as *const usize)\n                                }\n                                | unsafe {\n                                    *(src.add(offset + (2 * (ALU_ALIGNMENT / unit_size)))\n                                        as *const usize)\n                                }\n                                | unsafe {\n                                    *(src.add(offset + (3 * (ALU_ALIGNMENT / unit_size)))\n                                        as *const usize)\n                                };\n                            if unroll_accu & $mask != 0 {\n                                return false;\n                            }\n                            offset += 4 * (ALU_ALIGNMENT / unit_size);\n                            if offset > len_minus_unroll {\n                                break;\n                            }\n                        }\n                    }\n                    while offset <= len_minus_stride {\n                        accu |= unsafe { *(src.add(offset) as *const usize) };\n                        offset += ALU_ALIGNMENT / unit_size;\n                    }\n                }\n            }\n            for &unit in &buffer[offset..] {\n                accu |= unit as usize;\n            }\n            accu & $mask == 0\n        }","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_char_bidi":["/// Checks whether a scalar value triggers right-to-left processing.\n///\n/// The check is done on a Unicode block basis without regard to assigned\n/// vs. unassigned code points in the block. Hebrew presentation forms in\n/// the Alphabetic Presentation Forms block are treated as if they formed\n/// a block on their own (i.e. it treated as right-to-left). Additionally,\n/// the four RIGHT-TO-LEFT FOO controls in General Punctuation are checked\n/// for. Control characters that are technically bidi controls but do not\n/// cause right-to-left behavior without the presence of right-to-left\n/// characters or right-to-left controls are not checked for. As a special\n/// case, U+FEFF is excluded from Arabic Presentation Forms-B.\n#[inline(always)]\npub fn is_char_bidi(c: char) -> bool{\n    // Controls:\n    // Every control with RIGHT-TO-LEFT in its name in\n    // https://www.unicode.org/charts/PDF/U2000.pdf\n    // U+200F RLM\n    // U+202B RLE\n    // U+202E RLO\n    // U+2067 RLI\n    //\n    // BMP RTL:\n    // https://www.unicode.org/roadmaps/bmp/\n    // U+0590...U+08FF\n    // U+FB1D...U+FDFF Hebrew presentation forms and\n    //                 Arabic Presentation Forms A\n    // U+FE70...U+FEFE Arabic Presentation Forms B (excl. BOM)\n    //\n    // Supplementary RTL:\n    // https://www.unicode.org/roadmaps/smp/\n    // U+10800...U+10FFF (Lead surrogate U+D802 or U+D803)\n    // U+1E800...U+1EFFF (Lead surrogate U+D83A or U+D83B)\n    let code_point = u32::from(c);\n    if code_point < 0x0590 {\n        // Below Hebrew\n        return false;\n    }\n    if in_range32(code_point, 0x0900, 0xFB1D) {\n        // Above Arabic Extended-A and below Hebrew presentation forms\n        if in_inclusive_range32(code_point, 0x200F, 0x2067) {\n            // In the range that contains the RTL controls\n            return code_point == 0x200F\n                || code_point == 0x202B\n                || code_point == 0x202E\n                || code_point == 0x2067;\n        }\n        return false;\n    }\n    if code_point > 0x1EFFF {\n        // Above second astral RTL. (Emoji is here.)\n        return false;\n    }\n    if in_range32(code_point, 0x11000, 0x1E800) {\n        // Between astral RTL blocks\n        return false;\n    }\n    if in_range32(code_point, 0xFEFF, 0x10800) {\n        // Above Arabic Presentations Forms B (excl. BOM) and below first\n        // astral RTL\n        return false;\n    }\n    if in_range32(code_point, 0xFE00, 0xFE70) {\n        // Between Arabic Presentations Forms\n        return false;\n    }\n    true\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_str_bidi":["/// Checks whether a valid UTF-8 buffer contains code points that trigger\n/// right-to-left processing.\n///\n/// The check is done on a Unicode block basis without regard to assigned\n/// vs. unassigned code points in the block. Hebrew presentation forms in\n/// the Alphabetic Presentation Forms block are treated as if they formed\n/// a block on their own (i.e. it treated as right-to-left). Additionally,\n/// the four RIGHT-TO-LEFT FOO controls in General Punctuation are checked\n/// for. Control characters that are technically bidi controls but do not\n/// cause right-to-left behavior without the presence of right-to-left\n/// characters or right-to-left controls are not checked for. As a special\n/// case, U+FEFF is excluded from Arabic Presentation Forms-B.\n#[inline]\npub fn is_str_bidi(buffer: &str) -> bool{\n    // U+058F: D6 8F\n    // U+0590: D6 90\n    // U+08FF: E0 A3 BF\n    // U+0900: E0 A4 80\n    //\n    // U+200F: E2 80 8F\n    // U+202B: E2 80 AB\n    // U+202E: E2 80 AE\n    // U+2067: E2 81 A7\n    //\n    // U+FB1C: EF AC 9C\n    // U+FB1D: EF AC 9D\n    // U+FDFF: EF B7 BF\n    // U+FE00: EF B8 80\n    //\n    // U+FE6F: EF B9 AF\n    // U+FE70: EF B9 B0\n    // U+FEFE: EF BB BE\n    // U+FEFF: EF BB BF\n    //\n    // U+107FF: F0 90 9F BF\n    // U+10800: F0 90 A0 80\n    // U+10FFF: F0 90 BF BF\n    // U+11000: F0 91 80 80\n    //\n    // U+1E7FF: F0 9E 9F BF\n    // U+1E800: F0 9E A0 80\n    // U+1EFFF: F0 9E BF BF\n    // U+1F000: F0 9F 80 80\n    let mut bytes = buffer.as_bytes();\n    'outer: loop {\n        // TODO: Instead of just validating ASCII using SIMD, use SIMD\n        // to check for non-ASCII lead bytes, too, to quickly conclude\n        // that the vector consist entirely of CJK and below-Hebrew\n        // code points.\n        // Unfortunately, scripts above Arabic but below CJK share\n        // lead bytes with RTL.\n        if let Some((mut byte, mut read)) = validate_ascii(bytes) {\n            'inner: loop {\n                // At this point, `byte` is not included in `read`.\n                if byte < 0xE0 {\n                    if byte >= 0x80 {\n                        // Two-byte\n                        // Adding `unlikely` here improved throughput on\n                        // Russian plain text by 33%!\n                        if unsafe { unlikely(byte >= 0xD6) } {\n                            if byte == 0xD6 {\n                                let second = bytes[read + 1];\n                                if second > 0x8F {\n                                    return true;\n                                }\n                            } else {\n                                return true;\n                            }\n                        }\n                        read += 2;\n                    } else {\n                        // ASCII: write and go back to SIMD.\n                        read += 1;\n                        // Intuitively, we should go back to the outer loop only\n                        // if byte is 0x30 or above, so as to avoid trashing on\n                        // ASCII space, comma and period in non-Latin context.\n                        // However, the extra branch seems to cost more than it's\n                        // worth.\n                        bytes = &bytes[read..];\n                        continue 'outer;\n                    }\n                } else if byte < 0xF0 {\n                    // Three-byte\n                    if unsafe { unlikely(!in_inclusive_range8(byte, 0xE3, 0xEE) && byte != 0xE1) } {\n                        let second = bytes[read + 1];\n                        if byte == 0xE0 {\n                            if second < 0xA4 {\n                                return true;\n                            }\n                        } else if byte == 0xE2 {\n                            let third = bytes[read + 2];\n                            if second == 0x80 {\n                                if third == 0x8F || third == 0xAB || third == 0xAE {\n                                    return true;\n                                }\n                            } else if second == 0x81 {\n                                if third == 0xA7 {\n                                    return true;\n                                }\n                            }\n                        } else {\n                            debug_assert_eq!(byte, 0xEF);\n                            if in_inclusive_range8(second, 0xAC, 0xB7) {\n                                if second == 0xAC {\n                                    let third = bytes[read + 2];\n                                    if third > 0x9C {\n                                        return true;\n                                    }\n                                } else {\n                                    return true;\n                                }\n                            } else if in_inclusive_range8(second, 0xB9, 0xBB) {\n                                if second == 0xB9 {\n                                    let third = bytes[read + 2];\n                                    if third > 0xAF {\n                                        return true;\n                                    }\n                                } else if second == 0xBB {\n                                    let third = bytes[read + 2];\n                                    if third != 0xBF {\n                                        return true;\n                                    }\n                                } else {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                    read += 3;\n                } else {\n                    // Four-byte\n                    let second = bytes[read + 1];\n                    if unsafe { unlikely(byte == 0xF0 && (second == 0x90 || second == 0x9E)) } {\n                        let third = bytes[read + 2];\n                        if third >= 0xA0 {\n                            return true;\n                        }\n                    }\n                    read += 4;\n                }\n                // The comparison is always < or == and never >, but including\n                // > here to let the compiler assume that < is true if this\n                // comparison is false.\n                if read >= bytes.len() {\n                    return false;\n                }\n                byte = bytes[read];\n                continue 'inner;\n            }\n        } else {\n            return false;\n        }\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_str_latin1":["/// Checks whether the buffer represents only code points less than or equal\n/// to U+00FF.\n///\n/// Fails fast. (I.e. returns before having read the whole buffer if code\n/// points above U+00FF are discovered.\npub fn is_str_latin1(buffer: &str) -> bool{\n    is_str_latin1_impl(buffer).is_none()\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_str_latin1_impl":["#[inline(always)]\nfn is_str_latin1_impl(buffer: &str) -> Option<usize>{\n            let mut bytes = buffer.as_bytes();\n            let mut total = 0;\n            loop {\n                if let Some((byte, offset)) = validate_ascii(bytes) {\n                    total += offset;\n                    if byte > 0xC3 {\n                        return Some(total);\n                    }\n                    bytes = &bytes[offset + 2..];\n                    total += 2;\n                } else {\n                    return None;\n                }\n            }\n        }","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_utf16_bidi":["/// Checks whether a UTF-16 buffer contains code points that trigger\n/// right-to-left processing.\n///\n/// The check is done on a Unicode block basis without regard to assigned\n/// vs. unassigned code points in the block. Hebrew presentation forms in\n/// the Alphabetic Presentation Forms block are treated as if they formed\n/// a block on their own (i.e. it treated as right-to-left). Additionally,\n/// the four RIGHT-TO-LEFT FOO controls in General Punctuation are checked\n/// for. Control characters that are technically bidi controls but do not\n/// cause right-to-left behavior without the presence of right-to-left\n/// characters or right-to-left controls are not checked for. As a special\n/// case, U+FEFF is excluded from Arabic Presentation Forms-B.\n///\n/// Returns `true` if the input contains an RTL character or an unpaired\n/// high surrogate that could be the high half of an RTL character.\n/// Returns `false` if the input contains neither RTL characters nor\n/// unpaired high surrogates that could be higher halves of RTL characters.\npub fn is_utf16_bidi(buffer: &[u16]) -> bool{\n    is_utf16_bidi_impl(buffer)\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_utf16_bidi_impl":["#[inline(always)]\nfn is_utf16_bidi_impl(buffer: &[u16]) -> bool{\n            for &u in buffer {\n                if is_utf16_code_unit_bidi(u) {\n                    return true;\n                }\n            }\n            false\n        }","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_utf16_code_unit_bidi":["/// Checks whether a UTF-16 code unit triggers right-to-left processing.\n///\n/// The check is done on a Unicode block basis without regard to assigned\n/// vs. unassigned code points in the block. Hebrew presentation forms in\n/// the Alphabetic Presentation Forms block are treated as if they formed\n/// a block on their own (i.e. it treated as right-to-left). Additionally,\n/// the four RIGHT-TO-LEFT FOO controls in General Punctuation are checked\n/// for. Control characters that are technically bidi controls but do not\n/// cause right-to-left behavior without the presence of right-to-left\n/// characters or right-to-left controls are not checked for. As a special\n/// case, U+FEFF is excluded from Arabic Presentation Forms-B.\n///\n/// Since supplementary-plane right-to-left blocks are identifiable from the\n/// high surrogate without examining the low surrogate, this function returns\n/// `true` for such high surrogates making the function suitable for handling\n/// supplementary-plane text without decoding surrogate pairs to scalar\n/// values. Obviously, such high surrogates are then reported as right-to-left\n/// even if actually unpaired.\n#[inline(always)]\npub fn is_utf16_code_unit_bidi(u: u16) -> bool{\n    if u < 0x0590 {\n        // Below Hebrew\n        return false;\n    }\n    if in_range16(u, 0x0900, 0xD802) {\n        // Above Arabic Extended-A and below first RTL surrogate\n        if in_inclusive_range16(u, 0x200F, 0x2067) {\n            // In the range that contains the RTL controls\n            return u == 0x200F || u == 0x202B || u == 0x202E || u == 0x2067;\n        }\n        return false;\n    }\n    if in_range16(u, 0xD83C, 0xFB1D) {\n        // Between astral RTL high surrogates and Hebrew presentation forms\n        // (Emoji is here)\n        return false;\n    }\n    if in_range16(u, 0xD804, 0xD83A) {\n        // Between RTL high surragates\n        return false;\n    }\n    if u > 0xFEFE {\n        // Above Arabic Presentation Forms (excl. BOM)\n        return false;\n    }\n    if in_range16(u, 0xFE00, 0xFE70) {\n        // Between Arabic Presentations Forms\n        return false;\n    }\n    true\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_utf16_latin1":["/// Checks whether the buffer represents only code point less than or equal\n/// to U+00FF.\n///\n/// May read the entire buffer even if it isn't all-Latin1. (I.e. the function\n/// is not guaranteed to fail fast.)\npub fn is_utf16_latin1(buffer: &[u16]) -> bool{\n    is_utf16_latin1_impl(buffer)\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_utf16_latin1_impl":["#[inline(always)]\nfn $name(buffer: &[$unit]) -> bool{\n            let mut offset = 0usize;\n            let mut accu = 0usize;\n            let unit_size = ::std::mem::size_of::<$unit>();\n            let len = buffer.len();\n            if len >= ALU_ALIGNMENT / unit_size {\n                // The most common reason to return `false` is for the first code\n                // unit to fail the test, so check that first.\n                if buffer[0] >= $bound {\n                    return false;\n                }\n                let src = buffer.as_ptr();\n                let mut until_alignment = ((ALU_ALIGNMENT - ((src as usize) & ALU_ALIGNMENT_MASK))\n                    & ALU_ALIGNMENT_MASK)\n                    / unit_size;\n                if until_alignment + ALU_ALIGNMENT / unit_size <= len {\n                    if until_alignment != 0 {\n                        accu |= buffer[offset] as usize;\n                        offset += 1;\n                        until_alignment -= 1;\n                        while until_alignment != 0 {\n                            accu |= buffer[offset] as usize;\n                            offset += 1;\n                            until_alignment -= 1;\n                        }\n                        if accu >= $bound {\n                            return false;\n                        }\n                    }\n                    let len_minus_stride = len - ALU_ALIGNMENT / unit_size;\n                    if offset + (4 * (ALU_ALIGNMENT / unit_size)) <= len {\n                        let len_minus_unroll = len - (4 * (ALU_ALIGNMENT / unit_size));\n                        loop {\n                            let unroll_accu = unsafe { *(src.add(offset) as *const usize) }\n                                | unsafe {\n                                    *(src.add(offset + (ALU_ALIGNMENT / unit_size)) as *const usize)\n                                }\n                                | unsafe {\n                                    *(src.add(offset + (2 * (ALU_ALIGNMENT / unit_size)))\n                                        as *const usize)\n                                }\n                                | unsafe {\n                                    *(src.add(offset + (3 * (ALU_ALIGNMENT / unit_size)))\n                                        as *const usize)\n                                };\n                            if unroll_accu & $mask != 0 {\n                                return false;\n                            }\n                            offset += 4 * (ALU_ALIGNMENT / unit_size);\n                            if offset > len_minus_unroll {\n                                break;\n                            }\n                        }\n                    }\n                    while offset <= len_minus_stride {\n                        accu |= unsafe { *(src.add(offset) as *const usize) };\n                        offset += ALU_ALIGNMENT / unit_size;\n                    }\n                }\n            }\n            for &unit in &buffer[offset..] {\n                accu |= unit as usize;\n            }\n            accu & $mask == 0\n        }","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_utf8_bidi":["/// Checks whether a potentially-invalid UTF-8 buffer contains code points\n/// that trigger right-to-left processing.\n///\n/// The check is done on a Unicode block basis without regard to assigned\n/// vs. unassigned code points in the block. Hebrew presentation forms in\n/// the Alphabetic Presentation Forms block are treated as if they formed\n/// a block on their own (i.e. it treated as right-to-left). Additionally,\n/// the four RIGHT-TO-LEFT FOO controls in General Punctuation are checked\n/// for. Control characters that are technically bidi controls but do not\n/// cause right-to-left behavior without the presence of right-to-left\n/// characters or right-to-left controls are not checked for. As a special\n/// case, U+FEFF is excluded from Arabic Presentation Forms-B.\n///\n/// Returns `true` if the input is invalid UTF-8 or the input contains an\n/// RTL character. Returns `false` if the input is valid UTF-8 and contains\n/// no RTL characters.\n#[inline]\npub fn is_utf8_bidi(buffer: &[u8]) -> bool{\n    // As of rustc 1.25.0-nightly (73ac5d6a8 2018-01-11), this is faster\n    // than UTF-8 validation followed by `is_str_bidi()` for German,\n    // Russian and Japanese. However, this is considerably slower for Thai.\n    // Chances are that the compiler makes some branch predictions that are\n    // unfortunate for Thai. Not spending the time to manually optimize\n    // further at this time, since it's unclear if this variant even has\n    // use cases. However, this is worth revisiting once Rust gets the\n    // ability to annotate relative priorities of match arms.\n\n    // U+058F: D6 8F\n    // U+0590: D6 90\n    // U+08FF: E0 A3 BF\n    // U+0900: E0 A4 80\n    //\n    // U+200F: E2 80 8F\n    // U+202B: E2 80 AB\n    // U+202E: E2 80 AE\n    // U+2067: E2 81 A7\n    //\n    // U+FB1C: EF AC 9C\n    // U+FB1D: EF AC 9D\n    // U+FDFF: EF B7 BF\n    // U+FE00: EF B8 80\n    //\n    // U+FE6F: EF B9 AF\n    // U+FE70: EF B9 B0\n    // U+FEFE: EF BB BE\n    // U+FEFF: EF BB BF\n    //\n    // U+107FF: F0 90 9F BF\n    // U+10800: F0 90 A0 80\n    // U+10FFF: F0 90 BF BF\n    // U+11000: F0 91 80 80\n    //\n    // U+1E7FF: F0 9E 9F BF\n    // U+1E800: F0 9E A0 80\n    // U+1EFFF: F0 9E BF BF\n    // U+1F000: F0 9F 80 80\n    let mut src = buffer;\n    'outer: loop {\n        if let Some((mut byte, mut read)) = validate_ascii(src) {\n            // Check for the longest sequence to avoid checking twice for the\n            // multi-byte sequences.\n            if read + 4 <= src.len() {\n                'inner: loop {\n                    // At this point, `byte` is not included in `read`.\n                    match byte {\n                        0...0x7F => {\n                            // ASCII: go back to SIMD.\n                            read += 1;\n                            src = &src[read..];\n                            continue 'outer;\n                        }\n                        0xC2...0xD5 => {\n                            // Two-byte\n                            let second = unsafe { *(src.get_unchecked(read + 1)) };\n                            if !in_inclusive_range8(second, 0x80, 0xBF) {\n                                return true;\n                            }\n                            read += 2;\n                        }\n                        0xD6 => {\n                            // Two-byte\n                            let second = unsafe { *(src.get_unchecked(read + 1)) };\n                            if !in_inclusive_range8(second, 0x80, 0xBF) {\n                                return true;\n                            }\n                            // XXX consider folding the above and below checks\n                            if second > 0x8F {\n                                return true;\n                            }\n                            read += 2;\n                        }\n                        // two-byte starting with 0xD7 and above is bidi\n                        0xE1 | 0xE3...0xEC | 0xEE => {\n                            // Three-byte normal\n                            let second = unsafe { *(src.get_unchecked(read + 1)) };\n                            let third = unsafe { *(src.get_unchecked(read + 2)) };\n                            if ((UTF8_DATA.table[usize::from(second)]\n                                & unsafe {\n                                    *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80))\n                                })\n                                | (third >> 6))\n                                != 2\n                            {\n                                return true;\n                            }\n                            read += 3;\n                        }\n                        0xE2 => {\n                            // Three-byte normal, potentially bidi\n                            let second = unsafe { *(src.get_unchecked(read + 1)) };\n                            let third = unsafe { *(src.get_unchecked(read + 2)) };\n                            if ((UTF8_DATA.table[usize::from(second)]\n                                & unsafe {\n                                    *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80))\n                                })\n                                | (third >> 6))\n                                != 2\n                            {\n                                return true;\n                            }\n                            if second == 0x80 {\n                                if third == 0x8F || third == 0xAB || third == 0xAE {\n                                    return true;\n                                }\n                            } else if second == 0x81 {\n                                if third == 0xA7 {\n                                    return true;\n                                }\n                            }\n                            read += 3;\n                        }\n                        0xEF => {\n                            // Three-byte normal, potentially bidi\n                            let second = unsafe { *(src.get_unchecked(read + 1)) };\n                            let third = unsafe { *(src.get_unchecked(read + 2)) };\n                            if ((UTF8_DATA.table[usize::from(second)]\n                                & unsafe {\n                                    *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80))\n                                })\n                                | (third >> 6))\n                                != 2\n                            {\n                                return true;\n                            }\n                            if in_inclusive_range8(second, 0xAC, 0xB7) {\n                                if second == 0xAC {\n                                    if third > 0x9C {\n                                        return true;\n                                    }\n                                } else {\n                                    return true;\n                                }\n                            } else if in_inclusive_range8(second, 0xB9, 0xBB) {\n                                if second == 0xB9 {\n                                    if third > 0xAF {\n                                        return true;\n                                    }\n                                } else if second == 0xBB {\n                                    if third != 0xBF {\n                                        return true;\n                                    }\n                                } else {\n                                    return true;\n                                }\n                            }\n                            read += 3;\n                        }\n                        0xE0 => {\n                            // Three-byte special lower bound, potentially bidi\n                            let second = unsafe { *(src.get_unchecked(read + 1)) };\n                            let third = unsafe { *(src.get_unchecked(read + 2)) };\n                            if ((UTF8_DATA.table[usize::from(second)]\n                                & unsafe {\n                                    *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80))\n                                })\n                                | (third >> 6))\n                                != 2\n                            {\n                                return true;\n                            }\n                            // XXX can this be folded into the above validity check\n                            if second < 0xA4 {\n                                return true;\n                            }\n                            read += 3;\n                        }\n                        0xED => {\n                            // Three-byte special upper bound\n                            let second = unsafe { *(src.get_unchecked(read + 1)) };\n                            let third = unsafe { *(src.get_unchecked(read + 2)) };\n                            if ((UTF8_DATA.table[usize::from(second)]\n                                & unsafe {\n                                    *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80))\n                                })\n                                | (third >> 6))\n                                != 2\n                            {\n                                return true;\n                            }\n                            read += 3;\n                        }\n                        0xF1...0xF4 => {\n                            // Four-byte normal\n                            let second = unsafe { *(src.get_unchecked(read + 1)) };\n                            let third = unsafe { *(src.get_unchecked(read + 2)) };\n                            let fourth = unsafe { *(src.get_unchecked(read + 3)) };\n                            if (u16::from(\n                                UTF8_DATA.table[usize::from(second)]\n                                    & unsafe {\n                                        *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80))\n                                    },\n                            ) | u16::from(third >> 6)\n                                | (u16::from(fourth & 0xC0) << 2))\n                                != 0x202\n                            {\n                                return true;\n                            }\n                            read += 4;\n                        }\n                        0xF0 => {\n                            // Four-byte special lower bound, potentially bidi\n                            let second = unsafe { *(src.get_unchecked(read + 1)) };\n                            let third = unsafe { *(src.get_unchecked(read + 2)) };\n                            let fourth = unsafe { *(src.get_unchecked(read + 3)) };\n                            if (u16::from(\n                                UTF8_DATA.table[usize::from(second)]\n                                    & unsafe {\n                                        *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80))\n                                    },\n                            ) | u16::from(third >> 6)\n                                | (u16::from(fourth & 0xC0) << 2))\n                                != 0x202\n                            {\n                                return true;\n                            }\n                            if unsafe { unlikely(second == 0x90 || second == 0x9E) } {\n                                let third = src[read + 2];\n                                if third >= 0xA0 {\n                                    return true;\n                                }\n                            }\n                            read += 4;\n                        }\n                        _ => {\n                            // Invalid lead or bidi-only lead\n                            return true;\n                        }\n                    }\n                    if read + 4 > src.len() {\n                        if read == src.len() {\n                            return false;\n                        }\n                        byte = src[read];\n                        break 'inner;\n                    }\n                    byte = src[read];\n                    continue 'inner;\n                }\n            }\n            // We can't have a complete 4-byte sequence, but we could still have\n            // a complete shorter sequence.\n\n            // At this point, `byte` is not included in `read`.\n            match byte {\n                0...0x7F => {\n                    // ASCII: go back to SIMD.\n                    read += 1;\n                    src = &src[read..];\n                    continue 'outer;\n                }\n                0xC2...0xD5 => {\n                    // Two-byte\n                    let new_read = read + 2;\n                    if new_read > src.len() {\n                        return true;\n                    }\n                    let second = unsafe { *(src.get_unchecked(read + 1)) };\n                    if !in_inclusive_range8(second, 0x80, 0xBF) {\n                        return true;\n                    }\n                    read = new_read;\n                    // We need to deal with the case where we came here with 3 bytes\n                    // left, so we need to take a look at the last one.\n                    src = &src[read..];\n                    continue 'outer;\n                }\n                0xD6 => {\n                    // Two-byte, potentially bidi\n                    let new_read = read + 2;\n                    if new_read > src.len() {\n                        return true;\n                    }\n                    let second = unsafe { *(src.get_unchecked(read + 1)) };\n                    if !in_inclusive_range8(second, 0x80, 0xBF) {\n                        return true;\n                    }\n                    // XXX consider folding the above and below checks\n                    if second > 0x8F {\n                        return true;\n                    }\n                    read = new_read;\n                    // We need to deal with the case where we came here with 3 bytes\n                    // left, so we need to take a look at the last one.\n                    src = &src[read..];\n                    continue 'outer;\n                }\n                // two-byte starting with 0xD7 and above is bidi\n                0xE1 | 0xE3...0xEC | 0xEE => {\n                    // Three-byte normal\n                    let new_read = read + 3;\n                    if new_read > src.len() {\n                        return true;\n                    }\n                    let second = unsafe { *(src.get_unchecked(read + 1)) };\n                    let third = unsafe { *(src.get_unchecked(read + 2)) };\n                    if ((UTF8_DATA.table[usize::from(second)]\n                        & unsafe { *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80)) })\n                        | (third >> 6))\n                        != 2\n                    {\n                        return true;\n                    }\n                }\n                0xE2 => {\n                    // Three-byte normal, potentially bidi\n                    let new_read = read + 3;\n                    if new_read > src.len() {\n                        return true;\n                    }\n                    let second = unsafe { *(src.get_unchecked(read + 1)) };\n                    let third = unsafe { *(src.get_unchecked(read + 2)) };\n                    if ((UTF8_DATA.table[usize::from(second)]\n                        & unsafe { *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80)) })\n                        | (third >> 6))\n                        != 2\n                    {\n                        return true;\n                    }\n                    if second == 0x80 {\n                        if third == 0x8F || third == 0xAB || third == 0xAE {\n                            return true;\n                        }\n                    } else if second == 0x81 {\n                        if third == 0xA7 {\n                            return true;\n                        }\n                    }\n                }\n                0xEF => {\n                    // Three-byte normal, potentially bidi\n                    let new_read = read + 3;\n                    if new_read > src.len() {\n                        return true;\n                    }\n                    let second = unsafe { *(src.get_unchecked(read + 1)) };\n                    let third = unsafe { *(src.get_unchecked(read + 2)) };\n                    if ((UTF8_DATA.table[usize::from(second)]\n                        & unsafe { *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80)) })\n                        | (third >> 6))\n                        != 2\n                    {\n                        return true;\n                    }\n                    if in_inclusive_range8(second, 0xAC, 0xB7) {\n                        if second == 0xAC {\n                            if third > 0x9C {\n                                return true;\n                            }\n                        } else {\n                            return true;\n                        }\n                    } else if in_inclusive_range8(second, 0xB9, 0xBB) {\n                        if second == 0xB9 {\n                            if third > 0xAF {\n                                return true;\n                            }\n                        } else if second == 0xBB {\n                            if third != 0xBF {\n                                return true;\n                            }\n                        } else {\n                            return true;\n                        }\n                    }\n                }\n                0xE0 => {\n                    // Three-byte special lower bound, potentially bidi\n                    let new_read = read + 3;\n                    if new_read > src.len() {\n                        return true;\n                    }\n                    let second = unsafe { *(src.get_unchecked(read + 1)) };\n                    let third = unsafe { *(src.get_unchecked(read + 2)) };\n                    if ((UTF8_DATA.table[usize::from(second)]\n                        & unsafe { *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80)) })\n                        | (third >> 6))\n                        != 2\n                    {\n                        return true;\n                    }\n                    // XXX can this be folded into the above validity check\n                    if second < 0xA4 {\n                        return true;\n                    }\n                }\n                0xED => {\n                    // Three-byte special upper bound\n                    let new_read = read + 3;\n                    if new_read > src.len() {\n                        return true;\n                    }\n                    let second = unsafe { *(src.get_unchecked(read + 1)) };\n                    let third = unsafe { *(src.get_unchecked(read + 2)) };\n                    if ((UTF8_DATA.table[usize::from(second)]\n                        & unsafe { *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80)) })\n                        | (third >> 6))\n                        != 2\n                    {\n                        return true;\n                    }\n                }\n                _ => {\n                    // Invalid lead, 4-byte lead or 2-byte bidi-only lead\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return false;\n        }\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_utf8_latin1":["/// Checks whether the buffer is valid UTF-8 representing only code points\n/// less than or equal to U+00FF.\n///\n/// Fails fast. (I.e. returns before having read the whole buffer if UTF-8\n/// invalidity or code points above U+00FF are discovered.\npub fn is_utf8_latin1(buffer: &[u8]) -> bool{\n    is_utf8_latin1_impl(buffer).is_none()\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::is_utf8_latin1_impl":["#[inline(always)]\nfn is_utf8_latin1_impl(buffer: &[u8]) -> Option<usize>{\n    let mut bytes = buffer;\n    let mut total = 0;\n    loop {\n        if let Some((byte, offset)) = validate_ascii(bytes) {\n            total += offset;\n            if in_inclusive_range8(byte, 0xC2, 0xC3) {\n                let next = offset + 1;\n                if next == bytes.len() {\n                    return Some(total);\n                }\n                if bytes[next] & 0xC0 != 0x80 {\n                    return Some(total);\n                }\n                bytes = &bytes[offset + 2..];\n                total += 2;\n            } else {\n                return Some(total);\n            }\n        } else {\n            return None;\n        }\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::likely":["#[inline(always)]\nunsafe fn likely(b: bool) -> bool{\n            b\n        }","Real(LocalPath(\"src/mem.rs\"))"],"mem::str_latin1_up_to":["/// Returns the index of first byte that starts a non-Latin1 byte\n/// sequence, or the length of the string if there are none.\npub fn str_latin1_up_to(buffer: &str) -> usize{\n    is_str_latin1_impl(buffer).unwrap_or(buffer.len())\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::unlikely":["#[inline(always)]\nunsafe fn unlikely(b: bool) -> bool{\n            b\n        }","Real(LocalPath(\"src/mem.rs\"))"],"mem::utf16_valid_up_to":["/// Returns the index of the first unpaired surrogate or, if the input is\n/// valid UTF-16 in its entirety, the length of the input.\npub fn utf16_valid_up_to(buffer: &[u16]) -> usize{\n    utf16_valid_up_to_impl(buffer)\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::utf16_valid_up_to_alu":["/// The second return value is true iff the last code unit of the slice was\n/// reached and turned out to be a low surrogate that is part of a valid pair.\n#[inline(always)]\nfn utf16_valid_up_to_alu(buffer: &[u16]) -> (usize, bool){\n    let len = buffer.len();\n    if len == 0 {\n        return (0, false);\n    }\n    let mut offset = 0usize;\n    loop {\n        let unit = buffer[offset];\n        let next = offset + 1;\n        let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);\n        if unit_minus_surrogate_start > (0xDFFF - 0xD800) {\n            // Not a surrogate\n            offset = next;\n            if offset == len {\n                return (offset, false);\n            }\n            continue;\n        }\n        if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {\n            // high surrogate\n            if next < len {\n                let second = buffer[next];\n                let second_minus_low_surrogate_start = second.wrapping_sub(0xDC00);\n                if second_minus_low_surrogate_start <= (0xDFFF - 0xDC00) {\n                    // The next code unit is a low surrogate. Advance position.\n                    offset = next + 1;\n                    if offset == len {\n                        return (offset, true);\n                    }\n                    continue;\n                }\n                // The next code unit is not a low surrogate. Don't advance\n                // position and treat the high surrogate as unpaired.\n                // fall through\n            }\n            // Unpaired, fall through\n        }\n        // Unpaired surrogate\n        return (offset, false);\n    }\n}","Real(LocalPath(\"src/mem.rs\"))"],"mem::utf16_valid_up_to_impl":["#[inline(always)]\nfn utf16_valid_up_to_impl(buffer: &[u16]) -> usize{\n            let (up_to, _) = utf16_valid_up_to_alu(buffer);\n            up_to\n        }","Real(LocalPath(\"src/mem.rs\"))"],"mem::utf8_latin1_up_to":["/// Returns the index of first byte that starts an invalid byte\n/// sequence or a non-Latin1 byte sequence, or the length of the\n/// string if there are neither.\npub fn utf8_latin1_up_to(buffer: &[u8]) -> usize{\n    is_utf8_latin1_impl(buffer).unwrap_or(buffer.len())\n}","Real(LocalPath(\"src/mem.rs\"))"],"replacement::ReplacementDecoder":["pub struct ReplacementDecoder {\n    emitted: bool,\n}","Real(LocalPath(\"src/replacement.rs\"))"],"replacement::ReplacementDecoder::decode_to_utf16_raw":["pub fn decode_to_utf16_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u16],\n        _last: bool,\n    ) -> (DecoderResult, usize, usize){\n        // Don't err if the input stream is empty. See\n        // https://github.com/whatwg/encoding/issues/33\n        if self.emitted || src.is_empty() {\n            (DecoderResult::InputEmpty, src.len(), 0)\n        } else if dst.is_empty() {\n            // Make sure there's room for the replacement character.\n            (DecoderResult::OutputFull, 0, 0)\n        } else {\n            self.emitted = true;\n            (DecoderResult::Malformed(1, 0), 1, 0)\n        }\n    }","Real(LocalPath(\"src/replacement.rs\"))"],"replacement::ReplacementDecoder::decode_to_utf8_raw":["pub fn decode_to_utf8_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u8],\n        _last: bool,\n    ) -> (DecoderResult, usize, usize){\n        // Don't err if the input stream is empty. See\n        // https://github.com/whatwg/encoding/issues/33\n        if self.emitted || src.is_empty() {\n            (DecoderResult::InputEmpty, src.len(), 0)\n        } else if dst.len() < 3 {\n            // Make sure there's room for the replacement character.\n            (DecoderResult::OutputFull, 0, 0)\n        } else {\n            self.emitted = true;\n            (DecoderResult::Malformed(1, 0), 1, 0)\n        }\n    }","Real(LocalPath(\"src/replacement.rs\"))"],"replacement::ReplacementDecoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, _u16_length: usize) -> Option<usize>{\n        Some(1)\n    }","Real(LocalPath(\"src/replacement.rs\"))"],"replacement::ReplacementDecoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, _byte_length: usize) -> Option<usize>{\n        Some(3)\n    }","Real(LocalPath(\"src/replacement.rs\"))"],"replacement::ReplacementDecoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, _byte_length: usize) -> Option<usize>{\n        Some(3)\n    }","Real(LocalPath(\"src/replacement.rs\"))"],"replacement::ReplacementDecoder::new":["pub fn new() -> VariantDecoder{\n        VariantDecoder::Replacement(ReplacementDecoder { emitted: false })\n    }","Real(LocalPath(\"src/replacement.rs\"))"],"shift_jis::ShiftJisDecoder":["pub struct ShiftJisDecoder {\n    lead: Option<u8>,\n}","Real(LocalPath(\"src/shift_jis.rs\"))"],"shift_jis::ShiftJisDecoder::decode_to_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut dest_prolog = $dest_struct::new(dst);\n        let dest = match $slf.lead {\n            Some(lead) => {\n                let $lead_minus_offset = lead;\n                $slf.lead = None;\n                // Since we don't have `goto` we could use to jump into the trail\n                // handling part of the main loop, we need to repeat trail handling\n                // here.\n                match $source.check_available() {\n                    Space::Full(src_consumed_prolog) => {\n                        if last {\n                            return (DecoderResult::Malformed(1, 0),\n                                    src_consumed_prolog,\n                                    dest_prolog.written());\n                        }\n                        return (DecoderResult::InputEmpty, src_consumed_prolog, dest_prolog.written());\n                    }\n                    Space::Available(source_handle_prolog) => {\n                        match dest_prolog.$destination_check() {\n                            Space::Full(dst_written_prolog) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle_prolog.consumed(),\n                                        dst_written_prolog);\n                            }\n                            Space::Available($handle) => {\n                                let ($byte, $unread_handle_trail) = source_handle_prolog.read();\n                                // Start non-boilerplate\n                                $trail\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            },\n            None => {\n                &mut dest_prolog\n            }\n        };\n        $outermost: loop {\n            match dest.$copy_ascii(&mut $source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut $non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = {\n                            let $lead_minus_offset = {\n                                // Start non-boilerplate\n                                $lead\n                                // End non-boilerplate\n                            };\n                            match $source.check_available() {\n                                Space::Full(src_consumed_trail) => {\n                                    if last {\n                                        return (DecoderResult::Malformed(1, 0),\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    $slf.lead = Some($lead_minus_offset);\n                                    return (DecoderResult::InputEmpty,\n                                            src_consumed_trail,\n                                            $handle.written());\n                                }\n                                Space::Available(source_handle_trail) => {\n                                    let ($byte, $unread_handle_trail) = source_handle_trail.read();\n                                    // Start non-boilerplate\n                                    $trail\n                                    // End non-boilerplate\n                                }\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (DecoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (DecoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut b, unread_handle) = source_handle.read();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            if b > 127 {\n                                                $non_ascii = b;\n                                                $handle = destination_handle;\n                                                continue 'middle;\n                                            }\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_ascii(b);\n                                            if $ascii_punctuation && b < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (DecoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (DecoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (b_again, _unread_handle_again) =\n                                                                        source_handle_again.read();\n                                                                    b = b_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue $outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"shift_jis::ShiftJisDecoder::decode_to_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut dest_prolog = $dest_struct::new(dst);\n        let dest = match $slf.lead {\n            Some(lead) => {\n                let $lead_minus_offset = lead;\n                $slf.lead = None;\n                // Since we don't have `goto` we could use to jump into the trail\n                // handling part of the main loop, we need to repeat trail handling\n                // here.\n                match $source.check_available() {\n                    Space::Full(src_consumed_prolog) => {\n                        if last {\n                            return (DecoderResult::Malformed(1, 0),\n                                    src_consumed_prolog,\n                                    dest_prolog.written());\n                        }\n                        return (DecoderResult::InputEmpty, src_consumed_prolog, dest_prolog.written());\n                    }\n                    Space::Available(source_handle_prolog) => {\n                        match dest_prolog.$destination_check() {\n                            Space::Full(dst_written_prolog) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle_prolog.consumed(),\n                                        dst_written_prolog);\n                            }\n                            Space::Available($handle) => {\n                                let ($byte, $unread_handle_trail) = source_handle_prolog.read();\n                                // Start non-boilerplate\n                                $trail\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            },\n            None => {\n                &mut dest_prolog\n            }\n        };\n        $outermost: loop {\n            match dest.$copy_ascii(&mut $source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut $non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = {\n                            let $lead_minus_offset = {\n                                // Start non-boilerplate\n                                $lead\n                                // End non-boilerplate\n                            };\n                            match $source.check_available() {\n                                Space::Full(src_consumed_trail) => {\n                                    if last {\n                                        return (DecoderResult::Malformed(1, 0),\n                                                src_consumed_trail,\n                                                $handle.written());\n                                    }\n                                    $slf.lead = Some($lead_minus_offset);\n                                    return (DecoderResult::InputEmpty,\n                                            src_consumed_trail,\n                                            $handle.written());\n                                }\n                                Space::Available(source_handle_trail) => {\n                                    let ($byte, $unread_handle_trail) = source_handle_trail.read();\n                                    // Start non-boilerplate\n                                    $trail\n                                    // End non-boilerplate\n                                }\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (DecoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (DecoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut b, unread_handle) = source_handle.read();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            if b > 127 {\n                                                $non_ascii = b;\n                                                $handle = destination_handle;\n                                                continue 'middle;\n                                            }\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_ascii(b);\n                                            if $ascii_punctuation && b < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (DecoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (DecoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (b_again, _unread_handle_again) =\n                                                                        source_handle_again.read();\n                                                                    b = b_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue $outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"shift_jis::ShiftJisDecoder::in_neutral_state":["pub fn in_neutral_state(&self) -> bool{\n        self.lead.is_none()\n    }","Real(LocalPath(\"src/shift_jis.rs\"))"],"shift_jis::ShiftJisDecoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        self.plus_one_if_lead(byte_length)\n    }","Real(LocalPath(\"src/shift_jis.rs\"))"],"shift_jis::ShiftJisDecoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        checked_mul(3, self.plus_one_if_lead(byte_length))\n    }","Real(LocalPath(\"src/shift_jis.rs\"))"],"shift_jis::ShiftJisDecoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        // worst case: 1 to 3 (half-width katakana)\n        self.max_utf8_buffer_length(byte_length)\n    }","Real(LocalPath(\"src/shift_jis.rs\"))"],"shift_jis::ShiftJisDecoder::new":["pub fn new() -> VariantDecoder{\n        VariantDecoder::ShiftJis(ShiftJisDecoder { lead: None })\n    }","Real(LocalPath(\"src/shift_jis.rs\"))"],"shift_jis::ShiftJisDecoder::plus_one_if_lead":["fn plus_one_if_lead(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_add(match self.lead {\n            None => 0,\n            Some(_) => 1,\n        })\n    }","Real(LocalPath(\"src/shift_jis.rs\"))"],"shift_jis::ShiftJisEncoder":["pub struct ShiftJisEncoder;","Real(LocalPath(\"src/shift_jis.rs\"))"],"shift_jis::ShiftJisEncoder::encode_from_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 _last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut dest = ByteDestination::new(dst);\n        'outermost: loop {\n            match $source.$copy_ascii(&mut dest) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = match non_ascii {\n                            NonAscii::BmpExclAscii($bmp) => {\n                                // Start non-boilerplate\n                                $bmp_body\n                                // End non-boilerplate\n                            }\n                            NonAscii::Astral($astral) => {\n                                // Start non-boilerplate\n                                $astral_body\n                                // End non-boilerplate\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (EncoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (EncoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut c, unread_handle) = source_handle.read_enum();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            let ascii = match c {\n                                                Unicode::NonAscii(non_ascii_again) => {\n                                                    non_ascii = non_ascii_again;\n                                                    $handle = destination_handle;\n                                                    continue 'middle;\n                                                }\n                                                Unicode::Ascii(a) => a,\n                                            };\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_one(ascii);\n                                            if $ascii_punctuation && ascii < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (EncoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (EncoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (c_again, _unread_handle_again) =\n                                                                        source_handle_again.read_enum();\n                                                                    c = c_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"shift_jis::ShiftJisEncoder::encode_from_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 _last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut dest = ByteDestination::new(dst);\n        'outermost: loop {\n            match $source.$copy_ascii(&mut dest) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = match non_ascii {\n                            NonAscii::BmpExclAscii($bmp) => {\n                                // Start non-boilerplate\n                                $bmp_body\n                                // End non-boilerplate\n                            }\n                            NonAscii::Astral($astral) => {\n                                // Start non-boilerplate\n                                $astral_body\n                                // End non-boilerplate\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (EncoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (EncoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut c, unread_handle) = source_handle.read_enum();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            let ascii = match c {\n                                                Unicode::NonAscii(non_ascii_again) => {\n                                                    non_ascii = non_ascii_again;\n                                                    $handle = destination_handle;\n                                                    continue 'middle;\n                                                }\n                                                Unicode::Ascii(a) => a,\n                                            };\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_one(ascii);\n                                            if $ascii_punctuation && ascii < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (EncoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (EncoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (c_again, _unread_handle_again) =\n                                                                        source_handle_again.read_enum();\n                                                                    c = c_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"shift_jis::ShiftJisEncoder::max_buffer_length_from_utf16_without_replacement":["pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        u16_length.checked_mul(2)\n    }","Real(LocalPath(\"src/shift_jis.rs\"))"],"shift_jis::ShiftJisEncoder::max_buffer_length_from_utf8_without_replacement":["pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        byte_length.checked_add(1)\n    }","Real(LocalPath(\"src/shift_jis.rs\"))"],"shift_jis::ShiftJisEncoder::new":["pub fn new(encoding: &'static Encoding) -> Encoder{\n        Encoder::new(encoding, VariantEncoder::ShiftJis(ShiftJisEncoder))\n    }","Real(LocalPath(\"src/shift_jis.rs\"))"],"shift_jis::encode_kanji":["#[cfg(not(feature = \"fast-kanji-encode\"))]\n#[inline(always)]\nfn encode_kanji(bmp: u16) -> Option<(u8, u8)>{\n    if let Some((lead, trail)) = jis0208_level1_kanji_shift_jis_encode(bmp) {\n        return Some((lead, trail));\n    }\n    let pointer = if 0x4EDD == bmp {\n        // Ideograph on the symbol row!\n        23\n    } else if let Some(pos) = jis0208_level2_and_additional_kanji_encode(bmp) {\n        4418 + pos\n    } else if let Some(pos) = position(&IBM_KANJI[..], bmp) {\n        10744 + pos\n    } else {\n        return None;\n    };\n    let lead = pointer / 188;\n    let lead_offset = if lead < 0x1F { 0x81usize } else { 0xC1usize };\n    let trail = pointer % 188;\n    let trail_offset = if trail < 0x3F { 0x40usize } else { 0x41usize };\n    Some(((lead + lead_offset) as u8, (trail + trail_offset) as u8))\n}","Real(LocalPath(\"src/shift_jis.rs\"))"],"single_byte::SingleByteDecoder":["pub struct SingleByteDecoder {\n    table: &'static [u16; 128],\n}","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteDecoder::decode_to_utf16_raw":["pub fn decode_to_utf16_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u16],\n        _last: bool,\n    ) -> (DecoderResult, usize, usize){\n        let (pending, length) = if dst.len() < src.len() {\n            (DecoderResult::OutputFull, dst.len())\n        } else {\n            (DecoderResult::InputEmpty, src.len())\n        };\n        let mut converted = 0usize;\n        'outermost: loop {\n            match unsafe {\n                ascii_to_basic_latin(\n                    src.as_ptr().add(converted),\n                    dst.as_mut_ptr().add(converted),\n                    length - converted,\n                )\n            } {\n                None => {\n                    return (pending, length, length);\n                }\n                Some((mut non_ascii, consumed)) => {\n                    converted += consumed;\n                    'middle: loop {\n                        // `converted` doesn't count the reading of `non_ascii` yet.\n                        // Since the non-ASCIIness of `non_ascii` is hidden from\n                        // the optimizer, it can't figure out that it's OK to\n                        // statically omit the bound check when accessing\n                        // `[u16; 128]` with an index\n                        // `non_ascii as usize - 0x80usize`.\n                        let mapped =\n                            unsafe { *(self.table.get_unchecked(non_ascii as usize - 0x80usize)) };\n                        // let mapped = self.table[non_ascii as usize - 0x80usize];\n                        if mapped == 0u16 {\n                            return (\n                                DecoderResult::Malformed(1, 0),\n                                converted + 1, // +1 `for non_ascii`\n                                converted,\n                            );\n                        }\n                        unsafe {\n                            // The bound check has already been performed\n                            *(dst.get_unchecked_mut(converted)) = mapped;\n                        }\n                        converted += 1;\n                        // Next, handle ASCII punctuation and non-ASCII without\n                        // going back to ASCII acceleration. Non-ASCII scripts\n                        // use ASCII punctuation, so this avoid going to\n                        // acceleration just for punctuation/space and then\n                        // failing. This is a significant boost to non-ASCII\n                        // scripts.\n                        // TODO: Split out Latin converters without this part\n                        // this stuff makes Latin script-conversion slower.\n                        if converted == length {\n                            return (pending, length, length);\n                        }\n                        let mut b = unsafe { *(src.get_unchecked(converted)) };\n                        'innermost: loop {\n                            if b > 127 {\n                                non_ascii = b;\n                                continue 'middle;\n                            }\n                            // Testing on Haswell says that we should write the\n                            // byte unconditionally instead of trying to unread it\n                            // to make it part of the next SIMD stride.\n                            unsafe {\n                                *(dst.get_unchecked_mut(converted)) = u16::from(b);\n                            }\n                            converted += 1;\n                            if b < 60 {\n                                // We've got punctuation\n                                if converted == length {\n                                    return (pending, length, length);\n                                }\n                                b = unsafe { *(src.get_unchecked(converted)) };\n                                continue 'innermost;\n                            }\n                            // We've got markup or ASCII text\n                            continue 'outermost;\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteDecoder::decode_to_utf8_raw":["pub fn decode_to_utf8_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u8],\n        _last: bool,\n    ) -> (DecoderResult, usize, usize){\n        let mut source = ByteSource::new(src);\n        let mut dest = Utf8Destination::new(dst);\n        'outermost: loop {\n            match dest.copy_ascii_from_check_space_bmp(&mut source) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut handle)) => 'middle: loop {\n                    // Start non-boilerplate\n                    //\n                    // Since the non-ASCIIness of `non_ascii` is hidden from\n                    // the optimizer, it can't figure out that it's OK to\n                    // statically omit the bound check when accessing\n                    // `[u16; 128]` with an index\n                    // `non_ascii as usize - 0x80usize`.\n                    let mapped =\n                        unsafe { *(self.table.get_unchecked(non_ascii as usize - 0x80usize)) };\n                    // let mapped = self.table[non_ascii as usize - 0x80usize];\n                    if mapped == 0u16 {\n                        return (\n                            DecoderResult::Malformed(1, 0),\n                            source.consumed(),\n                            handle.written(),\n                        );\n                    }\n                    let dest_again = handle.write_bmp_excl_ascii(mapped);\n                    // End non-boilerplate\n                    match source.check_available() {\n                        Space::Full(src_consumed) => {\n                            return (\n                                DecoderResult::InputEmpty,\n                                src_consumed,\n                                dest_again.written(),\n                            );\n                        }\n                        Space::Available(source_handle) => {\n                            match dest_again.check_space_bmp() {\n                                Space::Full(dst_written) => {\n                                    return (\n                                        DecoderResult::OutputFull,\n                                        source_handle.consumed(),\n                                        dst_written,\n                                    );\n                                }\n                                Space::Available(mut destination_handle) => {\n                                    let (mut b, unread_handle) = source_handle.read();\n                                    let source_again = unread_handle.commit();\n                                    'innermost: loop {\n                                        if b > 127 {\n                                            non_ascii = b;\n                                            handle = destination_handle;\n                                            continue 'middle;\n                                        }\n                                        // Testing on Haswell says that we should write the\n                                        // byte unconditionally instead of trying to unread it\n                                        // to make it part of the next SIMD stride.\n                                        let dest_again_again = destination_handle.write_ascii(b);\n                                        if b < 60 {\n                                            // We've got punctuation\n                                            match source_again.check_available() {\n                                                Space::Full(src_consumed_again) => {\n                                                    return (\n                                                        DecoderResult::InputEmpty,\n                                                        src_consumed_again,\n                                                        dest_again_again.written(),\n                                                    );\n                                                }\n                                                Space::Available(source_handle_again) => {\n                                                    match dest_again_again.check_space_bmp() {\n                                                        Space::Full(dst_written_again) => {\n                                                            return (\n                                                                DecoderResult::OutputFull,\n                                                                source_handle_again.consumed(),\n                                                                dst_written_again,\n                                                            );\n                                                        }\n                                                        Space::Available(\n                                                            destination_handle_again,\n                                                        ) => {\n                                                            let (b_again, _unread_handle_again) =\n                                                                source_handle_again.read();\n                                                            b = b_again;\n                                                            destination_handle =\n                                                                destination_handle_again;\n                                                            continue 'innermost;\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        // We've got markup or ASCII text\n                                        continue 'outermost;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n            }\n        }\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteDecoder::latin1_byte_compatible_up_to":["pub fn latin1_byte_compatible_up_to(&self, buffer: &[u8]) -> usize{\n        let mut bytes = buffer;\n        let mut total = 0;\n        loop {\n            if let Some((non_ascii, offset)) = validate_ascii(bytes) {\n                total += offset;\n                let mapped = unsafe { *(self.table.get_unchecked(non_ascii as usize - 0x80usize)) };\n                if mapped != u16::from(non_ascii) {\n                    return total;\n                }\n                total += 1;\n                bytes = &bytes[offset + 1..];\n            } else {\n                return total;\n            }\n        }\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteDecoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        Some(byte_length)\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteDecoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_mul(3)\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteDecoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_mul(3)\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteDecoder::new":["pub fn new(data: &'static [u16; 128]) -> VariantDecoder{\n        VariantDecoder::SingleByte(SingleByteDecoder { table: data })\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteEncoder":["pub struct SingleByteEncoder {\n    table: &'static [u16; 128],\n    run_bmp_offset: usize,\n    run_byte_offset: usize,\n    run_length: usize,\n}","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteEncoder::encode_from_utf16_raw":["pub fn encode_from_utf16_raw(\n        &mut self,\n        src: &[u16],\n        dst: &mut [u8],\n        _last: bool,\n    ) -> (EncoderResult, usize, usize){\n        let (pending, length) = if dst.len() < src.len() {\n            (EncoderResult::OutputFull, dst.len())\n        } else {\n            (EncoderResult::InputEmpty, src.len())\n        };\n        let mut converted = 0usize;\n        'outermost: loop {\n            match unsafe {\n                basic_latin_to_ascii(\n                    src.as_ptr().add(converted),\n                    dst.as_mut_ptr().add(converted),\n                    length - converted,\n                )\n            } {\n                None => {\n                    return (pending, length, length);\n                }\n                Some((mut non_ascii, consumed)) => {\n                    converted += consumed;\n                    'middle: loop {\n                        // `converted` doesn't count the reading of `non_ascii` yet.\n                        match self.encode_u16(non_ascii) {\n                            Some(byte) => {\n                                unsafe {\n                                    *(dst.get_unchecked_mut(converted)) = byte;\n                                }\n                                converted += 1;\n                            }\n                            None => {\n                                // At this point, we need to know if we\n                                // have a surrogate.\n                                let high_bits = non_ascii & 0xFC00u16;\n                                if high_bits == 0xD800u16 {\n                                    // high surrogate\n                                    if converted + 1 == length {\n                                        // End of buffer. This surrogate is unpaired.\n                                        return (\n                                            EncoderResult::Unmappable('\\u{FFFD}'),\n                                            converted + 1, // +1 `for non_ascii`\n                                            converted,\n                                        );\n                                    }\n                                    let second =\n                                        u32::from(unsafe { *src.get_unchecked(converted + 1) });\n                                    if second & 0xFC00u32 != 0xDC00u32 {\n                                        return (\n                                            EncoderResult::Unmappable('\\u{FFFD}'),\n                                            converted + 1, // +1 `for non_ascii`\n                                            converted,\n                                        );\n                                    }\n                                    // The next code unit is a low surrogate.\n                                    let astral: char = unsafe {\n                                        ::std::char::from_u32_unchecked(\n                                            (u32::from(non_ascii) << 10) + second\n                                                - (((0xD800u32 << 10) - 0x1_0000u32) + 0xDC00u32),\n                                        )\n                                    };\n                                    return (\n                                        EncoderResult::Unmappable(astral),\n                                        converted + 2, // +2 `for non_ascii` and `second`\n                                        converted,\n                                    );\n                                }\n                                if high_bits == 0xDC00u16 {\n                                    // Unpaired low surrogate\n                                    return (\n                                        EncoderResult::Unmappable('\\u{FFFD}'),\n                                        converted + 1, // +1 `for non_ascii`\n                                        converted,\n                                    );\n                                }\n                                return (\n                                    EncoderResult::unmappable_from_bmp(non_ascii),\n                                    converted + 1, // +1 `for non_ascii`\n                                    converted,\n                                );\n                            }\n                        }\n                        // Next, handle ASCII punctuation and non-ASCII without\n                        // going back to ASCII acceleration. Non-ASCII scripts\n                        // use ASCII punctuation, so this avoid going to\n                        // acceleration just for punctuation/space and then\n                        // failing. This is a significant boost to non-ASCII\n                        // scripts.\n                        // TODO: Split out Latin converters without this part\n                        // this stuff makes Latin script-conversion slower.\n                        if converted == length {\n                            return (pending, length, length);\n                        }\n                        let mut unit = unsafe { *(src.get_unchecked(converted)) };\n                        'innermost: loop {\n                            if unit > 127 {\n                                non_ascii = unit;\n                                continue 'middle;\n                            }\n                            // Testing on Haswell says that we should write the\n                            // byte unconditionally instead of trying to unread it\n                            // to make it part of the next SIMD stride.\n                            unsafe {\n                                *(dst.get_unchecked_mut(converted)) = unit as u8;\n                            }\n                            converted += 1;\n                            if unit < 60 {\n                                // We've got punctuation\n                                if converted == length {\n                                    return (pending, length, length);\n                                }\n                                unit = unsafe { *(src.get_unchecked(converted)) };\n                                continue 'innermost;\n                            }\n                            // We've got markup or ASCII text\n                            continue 'outermost;\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteEncoder::encode_from_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 _last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut dest = ByteDestination::new(dst);\n        'outermost: loop {\n            match $source.$copy_ascii(&mut dest) {\n                CopyAsciiResult::Stop(ret) => return ret,\n                CopyAsciiResult::GoOn((mut non_ascii, mut $handle)) => {\n                    'middle: loop {\n                        let dest_again = match non_ascii {\n                            NonAscii::BmpExclAscii($bmp) => {\n                                // Start non-boilerplate\n                                $bmp_body\n                                // End non-boilerplate\n                            }\n                            NonAscii::Astral($astral) => {\n                                // Start non-boilerplate\n                                $astral_body\n                                // End non-boilerplate\n                            }\n                        };\n                        match $source.check_available() {\n                            Space::Full(src_consumed) => {\n                                return (EncoderResult::InputEmpty,\n                                        src_consumed,\n                                        dest_again.written());\n                            }\n                            Space::Available(source_handle) => {\n                                match dest_again.$destination_check() {\n                                    Space::Full(dst_written) => {\n                                        return (EncoderResult::OutputFull,\n                                                source_handle.consumed(),\n                                                dst_written);\n                                    }\n                                    Space::Available(mut destination_handle) => {\n                                        let (mut c, unread_handle) = source_handle.read_enum();\n                                        let source_again = unread_handle.commit();\n                                        'innermost: loop {\n                                            let ascii = match c {\n                                                Unicode::NonAscii(non_ascii_again) => {\n                                                    non_ascii = non_ascii_again;\n                                                    $handle = destination_handle;\n                                                    continue 'middle;\n                                                }\n                                                Unicode::Ascii(a) => a,\n                                            };\n                                            // Testing on Haswell says that we should write the\n                                            // byte unconditionally instead of trying to unread it\n                                            // to make it part of the next SIMD stride.\n                                            let dest_again_again =\n                                                destination_handle.write_one(ascii);\n                                            if $ascii_punctuation && ascii < 60 {\n                                                // We've got punctuation\n                                                match source_again.check_available() {\n                                                    Space::Full(src_consumed_again) => {\n                                                        return (EncoderResult::InputEmpty,\n                                                                src_consumed_again,\n                                                                dest_again_again.written());\n                                                    }\n                                                    Space::Available(source_handle_again) => {\n                                                        match dest_again_again.$destination_check() {\n                                                            Space::Full(dst_written_again) => {\n                                                                return (EncoderResult::OutputFull,\n                                                                        source_handle_again.consumed(),\n                                                                        dst_written_again);\n                                                            }\n                                                            Space::Available(destination_handle_again) => {\n                                                                {\n                                                                    let (c_again, _unread_handle_again) =\n                                                                        source_handle_again.read_enum();\n                                                                    c = c_again;\n                                                                    destination_handle = destination_handle_again;\n                                                                    continue 'innermost;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            // We've got markup or ASCII text\n                                            continue 'outermost;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"single_byte::SingleByteEncoder::encode_u16":["#[inline(always)]\nfn encode_u16(&self, code_unit: u16) -> Option<u8>{\n        // First, we see if the code unit falls into a run of consecutive\n        // code units that can be mapped by offset. This is very efficient\n        // for most non-Latin encodings as well as Latin1-ish encodings.\n        //\n        // For encodings that don't fit this pattern, the run (which may\n        // have the length of just one) just establishes the starting point\n        // for the next rule.\n        //\n        // Next, we do a forward linear search in the part of the index\n        // after the run. Even in non-Latin1-ish Latin encodings (except\n        // macintosh), the lower case letters are here.\n        //\n        // Next, we search the third quadrant up to the start of the run\n        // (upper case letters in Latin encodings except macintosh, in\n        // Greek and in KOI encodings) and then the second quadrant,\n        // except if the run stared before the third quadrant, we search\n        // the second quadrant up to the run.\n        //\n        // Last, we search the first quadrant, which has unused controls\n        // or punctuation in most encodings. This is bad for macintosh\n        // and IBM866, but those are rare.\n\n        // Run of consecutive units\n        let unit_as_usize = code_unit as usize;\n        let offset = unit_as_usize.wrapping_sub(self.run_bmp_offset);\n        if offset < self.run_length {\n            return Some((128 + self.run_byte_offset + offset) as u8);\n        }\n\n        // Search after the run\n        let tail_start = self.run_byte_offset + self.run_length;\n        if let Some(pos) = position(&self.table[tail_start..], code_unit) {\n            return Some((128 + tail_start + pos) as u8);\n        }\n\n        if self.run_byte_offset >= 64 {\n            // Search third quadrant before the run\n            if let Some(pos) = position(&self.table[64..self.run_byte_offset], code_unit) {\n                return Some(((128 + 64) + pos) as u8);\n            }\n\n            // Search second quadrant\n            if let Some(pos) = position(&self.table[32..64], code_unit) {\n                return Some(((128 + 32) + pos) as u8);\n            }\n        } else if let Some(pos) = position(&self.table[32..self.run_byte_offset], code_unit) {\n            // windows-1252, windows-874, ISO-8859-15 and ISO-8859-5\n            // Search second quadrant before the run\n            return Some(((128 + 32) + pos) as u8);\n        }\n\n        // Search first quadrant\n        if let Some(pos) = position(&self.table[..32], code_unit) {\n            return Some((128 + pos) as u8);\n        }\n\n        None\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteEncoder::max_buffer_length_from_utf16_without_replacement":["pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        Some(u16_length)\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteEncoder::max_buffer_length_from_utf8_without_replacement":["pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        Some(byte_length)\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"single_byte::SingleByteEncoder::new":["pub fn new(\n        encoding: &'static Encoding,\n        data: &'static [u16; 128],\n        run_bmp_offset: u16,\n        run_byte_offset: u8,\n        run_length: u8,\n    ) -> Encoder{\n        Encoder::new(\n            encoding,\n            VariantEncoder::SingleByte(SingleByteEncoder {\n                table: data,\n                run_bmp_offset: run_bmp_offset as usize,\n                run_byte_offset: run_byte_offset as usize,\n                run_length: run_length as usize,\n            }),\n        )\n    }","Real(LocalPath(\"src/single_byte.rs\"))"],"utf_16::Utf16Decoder":["pub struct Utf16Decoder {\n    lead_surrogate: u16, // If non-zero and pending_bmp == false, a pending lead surrogate\n    lead_byte: Option<u8>,\n    be: bool,\n    pending_bmp: bool, // if true, lead_surrogate is actually pending BMP\n}","Real(LocalPath(\"src/utf_16.rs\"))"],"utf_16::Utf16Decoder::additional_from_state":["pub fn additional_from_state(&self) -> usize{\n        1 + if self.lead_byte.is_some() { 1 } else { 0 }\n            + if self.lead_surrogate == 0 { 0 } else { 2 }\n    }","Real(LocalPath(\"src/utf_16.rs\"))"],"utf_16::Utf16Decoder::decode_to_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut $dest = $dest_struct::new(dst);\n        loop { // TODO: remove this loop\n            {\n                // Start non-boilerplate\n                $preamble\n                // End non-boilerplate\n            }\n            loop {\n                {\n                    $loop_preable\n                }\n                match $source.check_available() {\n                    Space::Full($src_consumed) => {\n                        if last {\n                            // Start non-boilerplate\n                            $eof\n                            // End non-boilerplate\n                        }\n                        return (DecoderResult::InputEmpty, $src_consumed, $dest.written());\n                    }\n                    Space::Available(source_handle) => {\n                        match $dest.$destination_check() {\n                            Space::Full(dst_written) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle.consumed(),\n                                        dst_written);\n                            }\n                            Space::Available($destination_handle) => {\n                                let ($b, $unread_handle) = source_handle.read();\n                                // Start non-boilerplate\n                                $body\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"utf_16::Utf16Decoder::decode_to_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut $dest = $dest_struct::new(dst);\n        loop { // TODO: remove this loop\n            {\n                // Start non-boilerplate\n                $preamble\n                // End non-boilerplate\n            }\n            loop {\n                {\n                    $loop_preable\n                }\n                match $source.check_available() {\n                    Space::Full($src_consumed) => {\n                        if last {\n                            // Start non-boilerplate\n                            $eof\n                            // End non-boilerplate\n                        }\n                        return (DecoderResult::InputEmpty, $src_consumed, $dest.written());\n                    }\n                    Space::Available(source_handle) => {\n                        match $dest.$destination_check() {\n                            Space::Full(dst_written) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle.consumed(),\n                                        dst_written);\n                            }\n                            Space::Available($destination_handle) => {\n                                let ($b, $unread_handle) = source_handle.read();\n                                // Start non-boilerplate\n                                $body\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"utf_16::Utf16Decoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        checked_add(\n            1,\n            checked_div(byte_length.checked_add(self.additional_from_state()), 2),\n        )\n    }","Real(LocalPath(\"src/utf_16.rs\"))"],"utf_16::Utf16Decoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        checked_add(\n            1,\n            checked_mul(\n                3,\n                checked_div(byte_length.checked_add(self.additional_from_state()), 2),\n            ),\n        )\n    }","Real(LocalPath(\"src/utf_16.rs\"))"],"utf_16::Utf16Decoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        checked_add(\n            1,\n            checked_mul(\n                3,\n                checked_div(byte_length.checked_add(self.additional_from_state()), 2),\n            ),\n        )\n    }","Real(LocalPath(\"src/utf_16.rs\"))"],"utf_16::Utf16Decoder::new":["pub fn new(big_endian: bool) -> VariantDecoder{\n        VariantDecoder::Utf16(Utf16Decoder {\n            lead_surrogate: 0,\n            lead_byte: None,\n            be: big_endian,\n            pending_bmp: false,\n        })\n    }","Real(LocalPath(\"src/utf_16.rs\"))"],"utf_8::Utf8Data":["#[repr(align(64))]\npub struct Utf8Data {\n    pub table: [u8; 384],\n}","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Decoder":["pub struct Utf8Decoder {\n    code_point: u32,\n    bytes_seen: usize,   // 1, 2 or 3: counts continuations only\n    bytes_needed: usize, // 1, 2 or 3: counts continuations only\n    lower_boundary: u8,\n    upper_boundary: u8,\n}","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Decoder::decode_to_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut $dest = $dest_struct::new(dst);\n        loop { // TODO: remove this loop\n            {\n                // Start non-boilerplate\n                $preamble\n                // End non-boilerplate\n            }\n            loop {\n                {\n                    $loop_preable\n                }\n                match $source.check_available() {\n                    Space::Full($src_consumed) => {\n                        if last {\n                            // Start non-boilerplate\n                            $eof\n                            // End non-boilerplate\n                        }\n                        return (DecoderResult::InputEmpty, $src_consumed, $dest.written());\n                    }\n                    Space::Available(source_handle) => {\n                        match $dest.$destination_check() {\n                            Space::Full(dst_written) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle.consumed(),\n                                        dst_written);\n                            }\n                            Space::Available($destination_handle) => {\n                                let ($b, $unread_handle) = source_handle.read();\n                                // Start non-boilerplate\n                                $body\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"utf_8::Utf8Decoder::decode_to_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut $dest = $dest_struct::new(dst);\n        loop { // TODO: remove this loop\n            {\n                // Start non-boilerplate\n                $preamble\n                // End non-boilerplate\n            }\n            loop {\n                {\n                    $loop_preable\n                }\n                match $source.check_available() {\n                    Space::Full($src_consumed) => {\n                        if last {\n                            // Start non-boilerplate\n                            $eof\n                            // End non-boilerplate\n                        }\n                        return (DecoderResult::InputEmpty, $src_consumed, $dest.written());\n                    }\n                    Space::Available(source_handle) => {\n                        match $dest.$destination_check() {\n                            Space::Full(dst_written) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle.consumed(),\n                                        dst_written);\n                            }\n                            Space::Available($destination_handle) => {\n                                let ($b, $unread_handle) = source_handle.read();\n                                // Start non-boilerplate\n                                $body\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"utf_8::Utf8Decoder::extra_from_state":["fn extra_from_state(&self) -> usize{\n        if self.bytes_needed == 0 {\n            0\n        } else {\n            self.bytes_seen + 1\n        }\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Decoder::in_neutral_state":["pub fn in_neutral_state(&self) -> bool{\n        self.bytes_needed == 0\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Decoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_add(1 + self.extra_from_state())\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Decoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        checked_add(\n            3,\n            checked_mul(3, byte_length.checked_add(self.extra_from_state())),\n        )\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Decoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_add(3 + self.extra_from_state())\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Decoder::new":["pub fn new() -> VariantDecoder{\n        VariantDecoder::Utf8(Utf8Decoder::new_inner())\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Decoder::new_inner":["pub fn new_inner() -> Utf8Decoder{\n        Utf8Decoder {\n            code_point: 0,\n            bytes_seen: 0,\n            bytes_needed: 0,\n            lower_boundary: 0x80u8,\n            upper_boundary: 0xBFu8,\n        }\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Encoder":["pub struct Utf8Encoder;","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Encoder::encode_from_utf16_raw":["pub fn encode_from_utf16_raw(\n        &mut self,\n        src: &[u16],\n        dst: &mut [u8],\n        _last: bool,\n    ) -> (EncoderResult, usize, usize){\n        let (read, written) = convert_utf16_to_utf8_partial(src, dst);\n        (\n            if read == src.len() {\n                EncoderResult::InputEmpty\n            } else {\n                EncoderResult::OutputFull\n            },\n            read,\n            written,\n        )\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Encoder::encode_from_utf8_raw":["pub fn encode_from_utf8_raw(\n        &mut self,\n        src: &str,\n        dst: &mut [u8],\n        _last: bool,\n    ) -> (EncoderResult, usize, usize){\n        let bytes = src.as_bytes();\n        let mut to_write = bytes.len();\n        if to_write <= dst.len() {\n            (&mut dst[..to_write]).copy_from_slice(bytes);\n            return (EncoderResult::InputEmpty, to_write, to_write);\n        }\n        to_write = dst.len();\n        // Move back until we find a UTF-8 sequence boundary.\n        while (bytes[to_write] & 0xC0) == 0x80 {\n            to_write -= 1;\n        }\n        (&mut dst[..to_write]).copy_from_slice(&bytes[..to_write]);\n        (EncoderResult::OutputFull, to_write, to_write)\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Encoder::max_buffer_length_from_utf16_without_replacement":["pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        u16_length.checked_mul(3)\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Encoder::max_buffer_length_from_utf8_without_replacement":["pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        Some(byte_length)\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::Utf8Encoder::new":["pub fn new(encoding: &'static Encoding) -> Encoder{\n        Encoder::new(encoding, VariantEncoder::Utf8(Utf8Encoder))\n    }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::convert_utf16_to_utf8_partial_inner":["#[inline(never)]\npub fn convert_utf16_to_utf8_partial_inner(src: &[u16], dst: &mut [u8]) -> (usize, usize){\n    let mut read = 0;\n    let mut written = 0;\n    'outer: loop {\n        let mut unit = {\n            let src_remaining = &src[read..];\n            let dst_remaining = &mut dst[written..];\n            let length = if dst_remaining.len() < src_remaining.len() {\n                dst_remaining.len()\n            } else {\n                src_remaining.len()\n            };\n            match unsafe {\n                basic_latin_to_ascii(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    read += length;\n                    written += length;\n                    return (read, written);\n                }\n                Some((non_ascii, consumed)) => {\n                    read += consumed;\n                    written += consumed;\n                    non_ascii\n                }\n            }\n        };\n        'inner: loop {\n            // The following loop is only broken out of as a goto forward.\n            loop {\n                // Unfortunately, this check isn't enough for the compiler to elide\n                // the bound checks on writes to dst, which is why they are manually\n                // elided, which makes a measurable difference.\n                if written.checked_add(4).unwrap() > dst.len() {\n                    return (read, written);\n                }\n                read += 1;\n                if unit < 0x800 {\n                    unsafe {\n                        *(dst.get_unchecked_mut(written)) = (unit >> 6) as u8 | 0xC0u8;\n                        written += 1;\n                        *(dst.get_unchecked_mut(written)) = (unit & 0x3F) as u8 | 0x80u8;\n                        written += 1;\n                    }\n                    break;\n                }\n                let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);\n                if unsafe { likely(unit_minus_surrogate_start > (0xDFFF - 0xD800)) } {\n                    unsafe {\n                        *(dst.get_unchecked_mut(written)) = (unit >> 12) as u8 | 0xE0u8;\n                        written += 1;\n                        *(dst.get_unchecked_mut(written)) = ((unit & 0xFC0) >> 6) as u8 | 0x80u8;\n                        written += 1;\n                        *(dst.get_unchecked_mut(written)) = (unit & 0x3F) as u8 | 0x80u8;\n                        written += 1;\n                    }\n                    break;\n                }\n                if unsafe { likely(unit_minus_surrogate_start <= (0xDBFF - 0xD800)) } {\n                    // high surrogate\n                    // read > src.len() is impossible, but using\n                    // >= instead of == allows the compiler to elide a bound check.\n                    if read >= src.len() {\n                        debug_assert_eq!(read, src.len());\n                        // Unpaired surrogate at the end of the buffer.\n                        unsafe {\n                            *(dst.get_unchecked_mut(written)) = 0xEFu8;\n                            written += 1;\n                            *(dst.get_unchecked_mut(written)) = 0xBFu8;\n                            written += 1;\n                            *(dst.get_unchecked_mut(written)) = 0xBDu8;\n                            written += 1;\n                        }\n                        return (read, written);\n                    }\n                    let second = src[read];\n                    let second_minus_low_surrogate_start = second.wrapping_sub(0xDC00);\n                    if unsafe { likely(second_minus_low_surrogate_start <= (0xDFFF - 0xDC00)) } {\n                        // The next code unit is a low surrogate. Advance position.\n                        read += 1;\n                        let astral = (u32::from(unit) << 10) + u32::from(second)\n                            - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32);\n                        unsafe {\n                            *(dst.get_unchecked_mut(written)) = (astral >> 18) as u8 | 0xF0u8;\n                            written += 1;\n                            *(dst.get_unchecked_mut(written)) =\n                                ((astral & 0x3F000u32) >> 12) as u8 | 0x80u8;\n                            written += 1;\n                            *(dst.get_unchecked_mut(written)) =\n                                ((astral & 0xFC0u32) >> 6) as u8 | 0x80u8;\n                            written += 1;\n                            *(dst.get_unchecked_mut(written)) = (astral & 0x3F) as u8 | 0x80u8;\n                            written += 1;\n                        }\n                        break;\n                    }\n                    // The next code unit is not a low surrogate. Don't advance\n                    // position and treat the high surrogate as unpaired.\n                    // Fall through\n                }\n                // Unpaired low surrogate\n                unsafe {\n                    *(dst.get_unchecked_mut(written)) = 0xEFu8;\n                    written += 1;\n                    *(dst.get_unchecked_mut(written)) = 0xBFu8;\n                    written += 1;\n                    *(dst.get_unchecked_mut(written)) = 0xBDu8;\n                    written += 1;\n                }\n                break;\n            }\n            // Now see if the next unit is Basic Latin\n            // read > src.len() is impossible, but using\n            // >= instead of == allows the compiler to elide a bound check.\n            if read >= src.len() {\n                debug_assert_eq!(read, src.len());\n                return (read, written);\n            }\n            unit = src[read];\n            if unsafe { unlikely(unit < 0x80) } {\n                // written > dst.len() is impossible, but using\n                // >= instead of == allows the compiler to elide a bound check.\n                if written >= dst.len() {\n                    debug_assert_eq!(written, dst.len());\n                    return (read, written);\n                }\n                dst[written] = unit as u8;\n                read += 1;\n                written += 1;\n                // Mysteriously, adding a punctuation check here makes\n                // the expected benificiary cases *slower*!\n                continue 'outer;\n            }\n            continue 'inner;\n        }\n    }\n}","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::convert_utf16_to_utf8_partial_tail":["#[inline(never)]\npub fn convert_utf16_to_utf8_partial_tail(src: &[u16], dst: &mut [u8]) -> (usize, usize){\n    // Everything below is cold code!\n    let mut read = 0;\n    let mut written = 0;\n    let mut unit = src[read];\n    // We now have up to 3 output slots, so an astral character\n    // will not fit.\n    if unit < 0x800 {\n        loop {\n            if unit < 0x80 {\n                if written >= dst.len() {\n                    return (read, written);\n                }\n                read += 1;\n                dst[written] = unit as u8;\n                written += 1;\n            } else if unit < 0x800 {\n                if written + 2 > dst.len() {\n                    return (read, written);\n                }\n                read += 1;\n                dst[written] = (unit >> 6) as u8 | 0xC0u8;\n                written += 1;\n                dst[written] = (unit & 0x3F) as u8 | 0x80u8;\n                written += 1;\n            } else {\n                return (read, written);\n            }\n            // read > src.len() is impossible, but using\n            // >= instead of == allows the compiler to elide a bound check.\n            if read >= src.len() {\n                debug_assert_eq!(read, src.len());\n                return (read, written);\n            }\n            unit = src[read];\n        }\n    }\n    // Could be an unpaired surrogate, but we'll need 3 output\n    // slots in any case.\n    if written + 3 > dst.len() {\n        return (read, written);\n    }\n    read += 1;\n    let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);\n    if unit_minus_surrogate_start <= (0xDFFF - 0xD800) {\n        // Got surrogate\n        if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {\n            // Got high surrogate\n            if read >= src.len() {\n                // Unpaired high surrogate\n                unit = 0xFFFD;\n            } else {\n                let second = src[read];\n                if in_inclusive_range16(second, 0xDC00, 0xDFFF) {\n                    // Valid surrogate pair, but we know it won't fit.\n                    read -= 1;\n                    return (read, written);\n                }\n                // Unpaired high\n                unit = 0xFFFD;\n            }\n        } else {\n            // Unpaired low\n            unit = 0xFFFD;\n        }\n    }\n    dst[written] = (unit >> 12) as u8 | 0xE0u8;\n    written += 1;\n    dst[written] = ((unit & 0xFC0) >> 6) as u8 | 0x80u8;\n    written += 1;\n    dst[written] = (unit & 0x3F) as u8 | 0x80u8;\n    written += 1;\n    debug_assert_eq!(written, dst.len());\n    (read, written)\n}","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::convert_utf8_to_utf16_up_to_invalid":["pub fn convert_utf8_to_utf16_up_to_invalid(src: &[u8], dst: &mut [u16]) -> (usize, usize){\n    let mut read = 0;\n    let mut written = 0;\n    'outer: loop {\n        let mut byte = {\n            let src_remaining = &src[read..];\n            let dst_remaining = &mut dst[written..];\n            let length = ::std::cmp::min(src_remaining.len(), dst_remaining.len());\n            match unsafe {\n                ascii_to_basic_latin(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)\n            } {\n                None => {\n                    read += length;\n                    written += length;\n                    break 'outer;\n                }\n                Some((non_ascii, consumed)) => {\n                    read += consumed;\n                    written += consumed;\n                    non_ascii\n                }\n            }\n        };\n        // Check for the longest sequence to avoid checking twice for the\n        // multi-byte sequences. This can't overflow with 64-bit address space,\n        // because full 64 bits aren't in use. In the 32-bit PAE case, for this\n        // to overflow would mean that the source slice would be so large that\n        // the address space of the process would not have space for any code.\n        // Therefore, the slice cannot be so long that this would overflow.\n        if unsafe { likely(read + 4 <= src.len()) } {\n            'inner: loop {\n                // At this point, `byte` is not included in `read`, because we\n                // don't yet know that a) the UTF-8 sequence is valid and b) that there\n                // is output space if it is an astral sequence.\n                // We know, thanks to `ascii_to_basic_latin` that there is output\n                // space for at least one UTF-16 code unit, so no need to check\n                // for output space in the BMP cases.\n                // Inspecting the lead byte directly is faster than what the\n                // std lib does!\n                if unsafe { likely(in_inclusive_range8(byte, 0xC2, 0xDF)) } {\n                    // Two-byte\n                    let second = unsafe { *(src.get_unchecked(read + 1)) };\n                    if !in_inclusive_range8(second, 0x80, 0xBF) {\n                        break 'outer;\n                    }\n                    unsafe {\n                        *(dst.get_unchecked_mut(written)) =\n                            ((u16::from(byte) & 0x1F) << 6) | (u16::from(second) & 0x3F)\n                    };\n                    read += 2;\n                    written += 1;\n\n                    // Next lead (manually inlined)\n                    if written == dst.len() {\n                        break 'outer;\n                    }\n                    if unsafe { likely(read + 4 <= src.len()) } {\n                        byte = unsafe { *(src.get_unchecked(read)) };\n                        if byte < 0x80 {\n                            unsafe { *(dst.get_unchecked_mut(written)) = u16::from(byte) };\n                            read += 1;\n                            written += 1;\n                            continue 'outer;\n                        }\n                        continue 'inner;\n                    }\n                    break 'inner;\n                }\n                if unsafe { likely(byte < 0xF0) } {\n                    'three: loop {\n                        // Three-byte\n                        let second = unsafe { *(src.get_unchecked(read + 1)) };\n                        let third = unsafe { *(src.get_unchecked(read + 2)) };\n                        if ((UTF8_DATA.table[usize::from(second)]\n                            & unsafe { *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80)) })\n                            | (third >> 6))\n                            != 2\n                        {\n                            break 'outer;\n                        }\n                        let point = ((u16::from(byte) & 0xF) << 12)\n                            | ((u16::from(second) & 0x3F) << 6)\n                            | (u16::from(third) & 0x3F);\n                        unsafe { *(dst.get_unchecked_mut(written)) = point };\n                        read += 3;\n                        written += 1;\n\n                        // Next lead (manually inlined)\n                        if written == dst.len() {\n                            break 'outer;\n                        }\n                        if unsafe { likely(read + 4 <= src.len()) } {\n                            byte = unsafe { *(src.get_unchecked(read)) };\n                            if in_inclusive_range8(byte, 0xE0, 0xEF) {\n                                continue 'three;\n                            }\n                            if unsafe { likely(byte < 0x80) } {\n                                unsafe { *(dst.get_unchecked_mut(written)) = u16::from(byte) };\n                                read += 1;\n                                written += 1;\n                                continue 'outer;\n                            }\n                            continue 'inner;\n                        }\n                        break 'inner;\n                    }\n                }\n                // Four-byte\n                if written + 1 == dst.len() {\n                    break 'outer;\n                }\n                let second = unsafe { *(src.get_unchecked(read + 1)) };\n                let third = unsafe { *(src.get_unchecked(read + 2)) };\n                let fourth = unsafe { *(src.get_unchecked(read + 3)) };\n                if (u16::from(\n                    UTF8_DATA.table[usize::from(second)]\n                        & unsafe { *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80)) },\n                ) | u16::from(third >> 6)\n                    | (u16::from(fourth & 0xC0) << 2))\n                    != 0x202\n                {\n                    break 'outer;\n                }\n                let point = ((u32::from(byte) & 0x7) << 18)\n                    | ((u32::from(second) & 0x3F) << 12)\n                    | ((u32::from(third) & 0x3F) << 6)\n                    | (u32::from(fourth) & 0x3F);\n                unsafe { *(dst.get_unchecked_mut(written)) = (0xD7C0 + (point >> 10)) as u16 };\n                unsafe {\n                    *(dst.get_unchecked_mut(written + 1)) = (0xDC00 + (point & 0x3FF)) as u16\n                };\n                read += 4;\n                written += 2;\n\n                // Next lead\n                if written == dst.len() {\n                    break 'outer;\n                }\n                if unsafe { likely(read + 4 <= src.len()) } {\n                    byte = unsafe { *(src.get_unchecked(read)) };\n                    if byte < 0x80 {\n                        unsafe { *(dst.get_unchecked_mut(written)) = u16::from(byte) };\n                        read += 1;\n                        written += 1;\n                        continue 'outer;\n                    }\n                    continue 'inner;\n                }\n                break 'inner;\n            }\n        }\n        // We can't have a complete 4-byte sequence, but we could still have\n        // one to three shorter sequences.\n        'tail: loop {\n            // >= is better for bound check elision than ==\n            if read >= src.len() || written >= dst.len() {\n                break 'outer;\n            }\n            byte = src[read];\n            // At this point, `byte` is not included in `read`, because we\n            // don't yet know that a) the UTF-8 sequence is valid and b) that there\n            // is output space if it is an astral sequence.\n            // Inspecting the lead byte directly is faster than what the\n            // std lib does!\n            if byte < 0x80 {\n                dst[written] = u16::from(byte);\n                read += 1;\n                written += 1;\n                continue 'tail;\n            }\n            if in_inclusive_range8(byte, 0xC2, 0xDF) {\n                // Two-byte\n                let new_read = read + 2;\n                if new_read > src.len() {\n                    break 'outer;\n                }\n                let second = src[read + 1];\n                if !in_inclusive_range8(second, 0x80, 0xBF) {\n                    break 'outer;\n                }\n                dst[written] = ((u16::from(byte) & 0x1F) << 6) | (u16::from(second) & 0x3F);\n                read += 2;\n                written += 1;\n                continue 'tail;\n            }\n            // We need to exclude valid four byte lead bytes, because\n            // `UTF8_DATA.second_mask` covers\n            if byte < 0xF0 {\n                // Three-byte\n                let new_read = read + 3;\n                if new_read > src.len() {\n                    break 'outer;\n                }\n                let second = src[read + 1];\n                let third = src[read + 2];\n                if ((UTF8_DATA.table[usize::from(second)]\n                    & unsafe { *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80)) })\n                    | (third >> 6))\n                    != 2\n                {\n                    break 'outer;\n                }\n                let point = ((u16::from(byte) & 0xF) << 12)\n                    | ((u16::from(second) & 0x3F) << 6)\n                    | (u16::from(third) & 0x3F);\n                dst[written] = point;\n                read += 3;\n                written += 1;\n                // `'tail` handles sequences shorter than 4, so\n                // there can't be another sequence after this one.\n                break 'outer;\n            }\n            break 'outer;\n        }\n    }\n    (read, written)\n}","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::likely":["#[inline(always)]\nunsafe fn likely(b: bool) -> bool{\n            b\n        }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::unlikely":["#[inline(always)]\nunsafe fn unlikely(b: bool) -> bool{\n            b\n        }","Real(LocalPath(\"src/utf_8.rs\"))"],"utf_8::utf8_valid_up_to":["pub fn utf8_valid_up_to(src: &[u8]) -> usize{\n    let mut read = 0;\n    'outer: loop {\n        let mut byte = {\n            let src_remaining = &src[read..];\n            match validate_ascii(src_remaining) {\n                None => {\n                    return src.len();\n                }\n                Some((non_ascii, consumed)) => {\n                    read += consumed;\n                    non_ascii\n                }\n            }\n        };\n        // Check for the longest sequence to avoid checking twice for the\n        // multi-byte sequences. This can't overflow with 64-bit address space,\n        // because full 64 bits aren't in use. In the 32-bit PAE case, for this\n        // to overflow would mean that the source slice would be so large that\n        // the address space of the process would not have space for any code.\n        // Therefore, the slice cannot be so long that this would overflow.\n        if unsafe { likely(read + 4 <= src.len()) } {\n            'inner: loop {\n                // At this point, `byte` is not included in `read`, because we\n                // don't yet know that a) the UTF-8 sequence is valid and b) that there\n                // is output space if it is an astral sequence.\n                // Inspecting the lead byte directly is faster than what the\n                // std lib does!\n                if unsafe { likely(in_inclusive_range8(byte, 0xC2, 0xDF)) } {\n                    // Two-byte\n                    let second = unsafe { *(src.get_unchecked(read + 1)) };\n                    if !in_inclusive_range8(second, 0x80, 0xBF) {\n                        break 'outer;\n                    }\n                    read += 2;\n\n                    // Next lead (manually inlined)\n                    if unsafe { likely(read + 4 <= src.len()) } {\n                        byte = unsafe { *(src.get_unchecked(read)) };\n                        if byte < 0x80 {\n                            read += 1;\n                            continue 'outer;\n                        }\n                        continue 'inner;\n                    }\n                    break 'inner;\n                }\n                if unsafe { likely(byte < 0xF0) } {\n                    'three: loop {\n                        // Three-byte\n                        let second = unsafe { *(src.get_unchecked(read + 1)) };\n                        let third = unsafe { *(src.get_unchecked(read + 2)) };\n                        if ((UTF8_DATA.table[usize::from(second)]\n                            & unsafe { *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80)) })\n                            | (third >> 6))\n                            != 2\n                        {\n                            break 'outer;\n                        }\n                        read += 3;\n\n                        // Next lead (manually inlined)\n                        if unsafe { likely(read + 4 <= src.len()) } {\n                            byte = unsafe { *(src.get_unchecked(read)) };\n                            if in_inclusive_range8(byte, 0xE0, 0xEF) {\n                                continue 'three;\n                            }\n                            if unsafe { likely(byte < 0x80) } {\n                                read += 1;\n                                continue 'outer;\n                            }\n                            continue 'inner;\n                        }\n                        break 'inner;\n                    }\n                }\n                // Four-byte\n                let second = unsafe { *(src.get_unchecked(read + 1)) };\n                let third = unsafe { *(src.get_unchecked(read + 2)) };\n                let fourth = unsafe { *(src.get_unchecked(read + 3)) };\n                if (u16::from(\n                    UTF8_DATA.table[usize::from(second)]\n                        & unsafe { *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80)) },\n                ) | u16::from(third >> 6)\n                    | (u16::from(fourth & 0xC0) << 2))\n                    != 0x202\n                {\n                    break 'outer;\n                }\n                read += 4;\n\n                // Next lead\n                if unsafe { likely(read + 4 <= src.len()) } {\n                    byte = unsafe { *(src.get_unchecked(read)) };\n                    if byte < 0x80 {\n                        read += 1;\n                        continue 'outer;\n                    }\n                    continue 'inner;\n                }\n                break 'inner;\n            }\n        }\n        // We can't have a complete 4-byte sequence, but we could still have\n        // one to three shorter sequences.\n        'tail: loop {\n            // >= is better for bound check elision than ==\n            if read >= src.len() {\n                break 'outer;\n            }\n            byte = src[read];\n            // At this point, `byte` is not included in `read`, because we\n            // don't yet know that a) the UTF-8 sequence is valid and b) that there\n            // is output space if it is an astral sequence.\n            // Inspecting the lead byte directly is faster than what the\n            // std lib does!\n            if byte < 0x80 {\n                read += 1;\n                continue 'tail;\n            }\n            if in_inclusive_range8(byte, 0xC2, 0xDF) {\n                // Two-byte\n                let new_read = read + 2;\n                if new_read > src.len() {\n                    break 'outer;\n                }\n                let second = src[read + 1];\n                if !in_inclusive_range8(second, 0x80, 0xBF) {\n                    break 'outer;\n                }\n                read += 2;\n                continue 'tail;\n            }\n            // We need to exclude valid four byte lead bytes, because\n            // `UTF8_DATA.second_mask` covers\n            if byte < 0xF0 {\n                // Three-byte\n                let new_read = read + 3;\n                if new_read > src.len() {\n                    break 'outer;\n                }\n                let second = src[read + 1];\n                let third = src[read + 2];\n                if ((UTF8_DATA.table[usize::from(second)]\n                    & unsafe { *(UTF8_DATA.table.get_unchecked(byte as usize + 0x80)) })\n                    | (third >> 6))\n                    != 2\n                {\n                    break 'outer;\n                }\n                read += 3;\n                // `'tail` handles sequences shorter than 4, so\n                // there can't be another sequence after this one.\n                break 'outer;\n            }\n            break 'outer;\n        }\n    }\n    read\n}","Real(LocalPath(\"src/utf_8.rs\"))"],"variant::VariantDecoder":["pub enum VariantDecoder {\n    SingleByte(SingleByteDecoder),\n    Utf8(Utf8Decoder),\n    Gb18030(Gb18030Decoder),\n    Big5(Big5Decoder),\n    EucJp(EucJpDecoder),\n    Iso2022Jp(Iso2022JpDecoder),\n    ShiftJis(ShiftJisDecoder),\n    EucKr(EucKrDecoder),\n    Replacement(ReplacementDecoder),\n    UserDefined(UserDefinedDecoder),\n    Utf16(Utf16Decoder),\n}","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantDecoder::decode_to_utf16_raw":["pub fn decode_to_utf16_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u16],\n        last: bool,\n    ) -> (DecoderResult, usize, usize){\n        match *self {\n            VariantDecoder::SingleByte(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Utf8(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Gb18030(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Big5(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::EucJp(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Iso2022Jp(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::ShiftJis(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::EucKr(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Replacement(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::UserDefined(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n            VariantDecoder::Utf16(ref mut v) => v.decode_to_utf16_raw(src, dst, last),\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantDecoder::decode_to_utf8_raw":["pub fn decode_to_utf8_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u8],\n        last: bool,\n    ) -> (DecoderResult, usize, usize){\n        match *self {\n            VariantDecoder::SingleByte(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Utf8(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Gb18030(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Big5(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::EucJp(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Iso2022Jp(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::ShiftJis(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::EucKr(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Replacement(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::UserDefined(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n            VariantDecoder::Utf16(ref mut v) => v.decode_to_utf8_raw(src, dst, last),\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantDecoder::latin1_byte_compatible_up_to":["pub fn latin1_byte_compatible_up_to(&self, buffer: &[u8]) -> Option<usize>{\n        match *self {\n            VariantDecoder::SingleByte(ref v) => {\n                return Some(v.latin1_byte_compatible_up_to(buffer));\n            }\n            VariantDecoder::Utf8(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::Gb18030(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::Big5(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::EucJp(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::Iso2022Jp(ref v) => {\n                if v.in_neutral_state() {\n                    return Some(Encoding::iso_2022_jp_ascii_valid_up_to(buffer));\n                }\n                return None;\n            }\n            VariantDecoder::ShiftJis(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::EucKr(ref v) => {\n                if !v.in_neutral_state() {\n                    return None;\n                }\n            }\n            VariantDecoder::UserDefined(_) => {}\n            VariantDecoder::Replacement(_) | VariantDecoder::Utf16(_) => {\n                return None;\n            }\n        };\n        Some(Encoding::ascii_valid_up_to(buffer))\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantDecoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        match *self {\n            VariantDecoder::SingleByte(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Utf8(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Gb18030(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Big5(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::EucJp(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Iso2022Jp(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::ShiftJis(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::EucKr(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Replacement(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::UserDefined(ref v) => v.max_utf16_buffer_length(byte_length),\n            VariantDecoder::Utf16(ref v) => v.max_utf16_buffer_length(byte_length),\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantDecoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        match *self {\n            VariantDecoder::SingleByte(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Utf8(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Gb18030(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Big5(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::EucJp(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Iso2022Jp(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::ShiftJis(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::EucKr(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Replacement(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::UserDefined(ref v) => v.max_utf8_buffer_length(byte_length),\n            VariantDecoder::Utf16(ref v) => v.max_utf8_buffer_length(byte_length),\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantDecoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        match *self {\n            VariantDecoder::SingleByte(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Utf8(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Gb18030(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Big5(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::EucJp(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Iso2022Jp(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::ShiftJis(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::EucKr(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Replacement(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::UserDefined(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n            VariantDecoder::Utf16(ref v) => {\n                v.max_utf8_buffer_length_without_replacement(byte_length)\n            }\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantEncoder":["pub enum VariantEncoder {\n    SingleByte(SingleByteEncoder),\n    Utf8(Utf8Encoder),\n    Gb18030(Gb18030Encoder),\n    Big5(Big5Encoder),\n    EucJp(EucJpEncoder),\n    Iso2022Jp(Iso2022JpEncoder),\n    ShiftJis(ShiftJisEncoder),\n    EucKr(EucKrEncoder),\n    UserDefined(UserDefinedEncoder),\n}","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantEncoder::encode_from_utf16_raw":["pub fn encode_from_utf16_raw(\n        &mut self,\n        src: &[u16],\n        dst: &mut [u8],\n        last: bool,\n    ) -> (EncoderResult, usize, usize){\n        match *self {\n            VariantEncoder::SingleByte(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::Utf8(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::Gb18030(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::Big5(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::EucJp(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::Iso2022Jp(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::ShiftJis(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::EucKr(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n            VariantEncoder::UserDefined(ref mut v) => v.encode_from_utf16_raw(src, dst, last),\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantEncoder::encode_from_utf8_raw":["pub fn encode_from_utf8_raw(\n        &mut self,\n        src: &str,\n        dst: &mut [u8],\n        last: bool,\n    ) -> (EncoderResult, usize, usize){\n        match *self {\n            VariantEncoder::SingleByte(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::Utf8(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::Gb18030(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::Big5(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::EucJp(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::Iso2022Jp(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::ShiftJis(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::EucKr(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n            VariantEncoder::UserDefined(ref mut v) => v.encode_from_utf8_raw(src, dst, last),\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantEncoder::has_pending_state":["pub fn has_pending_state(&self) -> bool{\n        match *self {\n            VariantEncoder::Iso2022Jp(ref v) => v.has_pending_state(),\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantEncoder::max_buffer_length_from_utf16_without_replacement":["pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        match *self {\n            VariantEncoder::SingleByte(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::Utf8(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::Gb18030(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::Big5(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::EucJp(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::Iso2022Jp(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::ShiftJis(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::EucKr(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n            VariantEncoder::UserDefined(ref v) => {\n                v.max_buffer_length_from_utf16_without_replacement(u16_length)\n            }\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantEncoder::max_buffer_length_from_utf8_without_replacement":["pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        match *self {\n            VariantEncoder::SingleByte(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::Utf8(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::Gb18030(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::Big5(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::EucJp(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::Iso2022Jp(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::ShiftJis(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::EucKr(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n            VariantEncoder::UserDefined(ref v) => {\n                v.max_buffer_length_from_utf8_without_replacement(byte_length)\n            }\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantEncoding":["pub enum VariantEncoding {\n    SingleByte(&'static [u16; 128], u16, u8, u8),\n    Utf8,\n    Gbk,\n    Gb18030,\n    Big5,\n    EucJp,\n    Iso2022Jp,\n    ShiftJis,\n    EucKr,\n    Replacement,\n    Utf16Be,\n    Utf16Le,\n    UserDefined,\n}","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantEncoding::is_single_byte":["pub fn is_single_byte(&self) -> bool{\n        match *self {\n            VariantEncoding::SingleByte(_, _, _, _) | VariantEncoding::UserDefined => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantEncoding::new_encoder":["pub fn new_encoder(&self, encoding: &'static Encoding) -> Encoder{\n        match *self {\n            VariantEncoding::SingleByte(table, run_bmp_offset, run_byte_offset, run_length) => {\n                SingleByteEncoder::new(encoding, table, run_bmp_offset, run_byte_offset, run_length)\n            }\n            VariantEncoding::Utf8 => Utf8Encoder::new(encoding),\n            VariantEncoding::Gbk => Gb18030Encoder::new(encoding, false),\n            VariantEncoding::Gb18030 => Gb18030Encoder::new(encoding, true),\n            VariantEncoding::Big5 => Big5Encoder::new(encoding),\n            VariantEncoding::EucJp => EucJpEncoder::new(encoding),\n            VariantEncoding::Iso2022Jp => Iso2022JpEncoder::new(encoding),\n            VariantEncoding::ShiftJis => ShiftJisEncoder::new(encoding),\n            VariantEncoding::EucKr => EucKrEncoder::new(encoding),\n            VariantEncoding::UserDefined => UserDefinedEncoder::new(encoding),\n            VariantEncoding::Utf16Be | VariantEncoding::Replacement | VariantEncoding::Utf16Le => {\n                unreachable!()\n            }\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"variant::VariantEncoding::new_variant_decoder":["pub fn new_variant_decoder(&self) -> VariantDecoder{\n        match *self {\n            VariantEncoding::SingleByte(table, _, _, _) => SingleByteDecoder::new(table),\n            VariantEncoding::Utf8 => Utf8Decoder::new(),\n            VariantEncoding::Gbk | VariantEncoding::Gb18030 => Gb18030Decoder::new(),\n            VariantEncoding::Big5 => Big5Decoder::new(),\n            VariantEncoding::EucJp => EucJpDecoder::new(),\n            VariantEncoding::Iso2022Jp => Iso2022JpDecoder::new(),\n            VariantEncoding::ShiftJis => ShiftJisDecoder::new(),\n            VariantEncoding::EucKr => EucKrDecoder::new(),\n            VariantEncoding::Replacement => ReplacementDecoder::new(),\n            VariantEncoding::UserDefined => UserDefinedDecoder::new(),\n            VariantEncoding::Utf16Be => Utf16Decoder::new(true),\n            VariantEncoding::Utf16Le => Utf16Decoder::new(false),\n        }\n    }","Real(LocalPath(\"src/variant.rs\"))"],"write_ncr":["/// Format an unmappable as NCR without heap allocation.\nfn write_ncr(unmappable: char, dst: &mut [u8]) -> usize{\n    // len is the number of decimal digits needed to represent unmappable plus\n    // 3 (the length of \"&#\" and \";\").\n    let mut number = unmappable as u32;\n    let len = if number >= 1_000_000u32 {\n        10usize\n    } else if number >= 100_000u32 {\n        9usize\n    } else if number >= 10_000u32 {\n        8usize\n    } else if number >= 1_000u32 {\n        7usize\n    } else if number >= 100u32 {\n        6usize\n    } else {\n        // Review the outcome of https://github.com/whatwg/encoding/issues/15\n        // to see if this case is possible\n        5usize\n    };\n    debug_assert!(number >= 10u32);\n    debug_assert!(len <= dst.len());\n    let mut pos = len - 1;\n    dst[pos] = b';';\n    pos -= 1;\n    loop {\n        let rightmost = number % 10;\n        dst[pos] = rightmost as u8 + b'0';\n        pos -= 1;\n        if number < 10 {\n            break;\n        }\n        number /= 10;\n    }\n    dst[1] = b'#';\n    dst[0] = b'&';\n    len\n}","Real(LocalPath(\"src/lib.rs\"))"],"x_user_defined::UserDefinedDecoder":["pub struct UserDefinedDecoder;","Real(LocalPath(\"src/x_user_defined.rs\"))"],"x_user_defined::UserDefinedDecoder::decode_to_utf16_raw":["#[cfg(not(feature = \"simd-accel\"))]\npub fn decode_to_utf16_raw(\n        &mut self,\n        src: &[u8],\n        dst: &mut [u16],\n        _last: bool,\n    ) -> (DecoderResult, usize, usize){\n        let (pending, length) = if dst.len() < src.len() {\n            (DecoderResult::OutputFull, dst.len())\n        } else {\n            (DecoderResult::InputEmpty, src.len())\n        };\n        let src_trim = &src[..length];\n        let dst_trim = &mut dst[..length];\n        src_trim\n            .iter()\n            .zip(dst_trim.iter_mut())\n            .for_each(|(from, to)| {\n                *to = {\n                    let unit = *from;\n                    if unit < 0x80 {\n                        u16::from(unit)\n                    } else {\n                        u16::from(unit) + 0xF700\n                    }\n                }\n            });\n        (pending, length, length)\n    }","Real(LocalPath(\"src/x_user_defined.rs\"))"],"x_user_defined::UserDefinedDecoder::decode_to_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &[u8],\n                 dst: &mut [$code_unit],\n                 last: bool)\n                 -> (DecoderResult, usize, usize){\n        let mut $source = ByteSource::new(src);\n        let mut $dest = $dest_struct::new(dst);\n        loop { // TODO: remove this loop\n            {\n                // Start non-boilerplate\n                $preamble\n                // End non-boilerplate\n            }\n            loop {\n                {\n                    $loop_preable\n                }\n                match $source.check_available() {\n                    Space::Full($src_consumed) => {\n                        if last {\n                            // Start non-boilerplate\n                            $eof\n                            // End non-boilerplate\n                        }\n                        return (DecoderResult::InputEmpty, $src_consumed, $dest.written());\n                    }\n                    Space::Available(source_handle) => {\n                        match $dest.$destination_check() {\n                            Space::Full(dst_written) => {\n                                return (DecoderResult::OutputFull,\n                                        source_handle.consumed(),\n                                        dst_written);\n                            }\n                            Space::Available($destination_handle) => {\n                                let ($b, $unread_handle) = source_handle.read();\n                                // Start non-boilerplate\n                                $body\n                                // End non-boilerplate\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"x_user_defined::UserDefinedDecoder::max_utf16_buffer_length":["pub fn max_utf16_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        Some(byte_length)\n    }","Real(LocalPath(\"src/x_user_defined.rs\"))"],"x_user_defined::UserDefinedDecoder::max_utf8_buffer_length":["pub fn max_utf8_buffer_length(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_mul(3)\n    }","Real(LocalPath(\"src/x_user_defined.rs\"))"],"x_user_defined::UserDefinedDecoder::max_utf8_buffer_length_without_replacement":["pub fn max_utf8_buffer_length_without_replacement(&self, byte_length: usize) -> Option<usize>{\n        byte_length.checked_mul(3)\n    }","Real(LocalPath(\"src/x_user_defined.rs\"))"],"x_user_defined::UserDefinedDecoder::new":["pub fn new() -> VariantDecoder{\n        VariantDecoder::UserDefined(UserDefinedDecoder)\n    }","Real(LocalPath(\"src/x_user_defined.rs\"))"],"x_user_defined::UserDefinedEncoder":["pub struct UserDefinedEncoder;","Real(LocalPath(\"src/x_user_defined.rs\"))"],"x_user_defined::UserDefinedEncoder::encode_from_utf16_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut $dest = ByteDestination::new(dst);\n        loop {\n            match $source.check_available() {\n                Space::Full($src_consumed) => {\n                    if last {\n                        // Start non-boilerplate\n                        $eof\n                        // End non-boilerplate\n                    }\n                    return (EncoderResult::InputEmpty, $src_consumed, $dest.written());\n                }\n                Space::Available(source_handle) => {\n                    match $dest.$destination_check() {\n                        Space::Full(dst_written) => {\n                            return (EncoderResult::OutputFull,\n                                    source_handle.consumed(),\n                                    dst_written);\n                        }\n                        Space::Available($destination_handle) => {\n                            let ($c, $unread_handle) = source_handle.read();\n                            // Start non-boilerplate\n                            $body\n                            // End non-boilerplate\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"x_user_defined::UserDefinedEncoder::encode_from_utf8_raw":["pub fn $name(&mut $slf,\n                 src: &$input,\n                 dst: &mut [u8],\n                 last: bool)\n                 -> (EncoderResult, usize, usize){\n        let mut $source = $source_struct::new(src);\n        let mut $dest = ByteDestination::new(dst);\n        loop {\n            match $source.check_available() {\n                Space::Full($src_consumed) => {\n                    if last {\n                        // Start non-boilerplate\n                        $eof\n                        // End non-boilerplate\n                    }\n                    return (EncoderResult::InputEmpty, $src_consumed, $dest.written());\n                }\n                Space::Available(source_handle) => {\n                    match $dest.$destination_check() {\n                        Space::Full(dst_written) => {\n                            return (EncoderResult::OutputFull,\n                                    source_handle.consumed(),\n                                    dst_written);\n                        }\n                        Space::Available($destination_handle) => {\n                            let ($c, $unread_handle) = source_handle.read();\n                            // Start non-boilerplate\n                            $body\n                            // End non-boilerplate\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/macros.rs\"))"],"x_user_defined::UserDefinedEncoder::max_buffer_length_from_utf16_without_replacement":["pub fn max_buffer_length_from_utf16_without_replacement(\n        &self,\n        u16_length: usize,\n    ) -> Option<usize>{\n        Some(u16_length)\n    }","Real(LocalPath(\"src/x_user_defined.rs\"))"],"x_user_defined::UserDefinedEncoder::max_buffer_length_from_utf8_without_replacement":["pub fn max_buffer_length_from_utf8_without_replacement(\n        &self,\n        byte_length: usize,\n    ) -> Option<usize>{\n        Some(byte_length)\n    }","Real(LocalPath(\"src/x_user_defined.rs\"))"],"x_user_defined::UserDefinedEncoder::new":["pub fn new(encoding: &'static Encoding) -> Encoder{\n        Encoder::new(encoding, VariantEncoder::UserDefined(UserDefinedEncoder))\n    }","Real(LocalPath(\"src/x_user_defined.rs\"))"]},"struct_constructor":{"&'static Encoding":["encoding","for_label","for_label_no_replacement"],"&'static str":["name"],"(&'static Encoding, usize)":["for_bom"],"(CoderResult, usize, bool)":["decode_to_string","encode_from_utf8_to_vec"],"(CoderResult, usize, usize, bool)":["decode_to_str","decode_to_utf16","decode_to_utf8","encode_from_utf16","encode_from_utf8"],"(DecoderResult, usize)":["decode_to_string_without_replacement"],"(DecoderResult, usize, usize)":["decode_to_str_without_replacement","decode_to_utf16_after_one_potential_bom_byte","decode_to_utf16_after_two_potential_bom_bytes","decode_to_utf16_checking_end","decode_to_utf16_checking_end_with_offset","decode_to_utf16_raw","decode_to_utf16_without_replacement","decode_to_utf8_after_one_potential_bom_byte","decode_to_utf8_after_two_potential_bom_bytes","decode_to_utf8_checking_end","decode_to_utf8_checking_end_with_offset","decode_to_utf8_raw","decode_to_utf8_without_replacement"],"(EncoderResult, usize)":["encode_from_utf8_to_vec_without_replacement"],"(EncoderResult, usize, usize)":["encode_from_utf16_raw","encode_from_utf16_without_replacement","encode_from_utf8_raw","encode_from_utf8_without_replacement"],"(char, handles::Utf16UnreadHandle<'a, 'b>)":["read"],"(char, handles::Utf8UnreadHandle<'a, 'b>)":["read"],"(handles::Unicode, handles::Utf16UnreadHandle<'a, 'b>)":["read_enum"],"(handles::Unicode, handles::Utf8UnreadHandle<'a, 'b>)":["read_enum"],"(std::borrow::Cow<'a, [u8]>, &'static Encoding, bool)":["encode"],"(std::borrow::Cow<'a, str>, &'static Encoding, bool)":["decode"],"(std::borrow::Cow<'a, str>, bool)":["decode_with_bom_removal","decode_without_bom_handling"],"(u16, usize)":["basic_latin_to_ascii","copy_bmp_to"],"(u8, handles::ByteUnreadHandle<'a, 'b>)":["read"],"(u8, u8)":["big5_level1_hanzi_encode","encode_hanzi","encode_kanji","gb2312_level1_hanzi_encode","jis0208_level1_kanji_euc_jp_encode","jis0208_level1_kanji_iso_2022_jp_encode","jis0208_level1_kanji_shift_jis_encode","ksx1001_encode_hangul","ksx1001_encode_hanja"],"(u8, usize)":["ascii_to_ascii","ascii_to_basic_latin","validate_ascii"],"(usize, bool)":["utf16_valid_up_to_alu"],"(usize, usize)":["convert_latin1_to_str_partial","convert_latin1_to_utf8_partial","convert_utf16_to_str_partial","convert_utf16_to_utf8_partial","convert_utf16_to_utf8_partial_inner","convert_utf16_to_utf8_partial_tail","convert_utf8_to_utf16_up_to_invalid","copy_utf16_from","gbk_encode_non_unified","ksx1001_encode_misc"],"(usize, usize, bool)":["convert_unaligned_utf16_to_utf8"],"BomHandling":["clone"],"Decoder":["new","new_decoder","new_decoder_with_bom_removal","new_decoder_without_bom_handling"],"DecoderLifeCycle":["clone"],"Encoder":["new","new_encoder"],"EncoderResult":["unmappable_from_bmp"],"bool":["ascii_to_basic_latin_stride_alu","basic_latin_to_ascii_stride_alu","big5_is_astral","can_encode_everything","eq","has_pending_state","in_inclusive_range","in_inclusive_range16","in_inclusive_range32","in_inclusive_range8","in_neutral_state","in_range16","in_range32","is_ascii","is_ascii_compatible","is_ascii_impl","is_basic_latin","is_basic_latin_impl","is_char_bidi","is_kanji_mapped","is_mapped_for_two_byte_encode","is_none","is_potentially_borrowable","is_single_byte","is_str_bidi","is_str_latin1","is_utf16_bidi","is_utf16_bidi_impl","is_utf16_code_unit_bidi","is_utf16_latin1","is_utf16_latin1_impl","is_utf8_bidi","is_utf8_latin1"],"char":["read"],"handles::ByteDestination":["new"],"handles::ByteFourHandle":["new"],"handles::ByteOneHandle":["new"],"handles::ByteReadHandle":["new"],"handles::ByteSource":["new"],"handles::ByteThreeHandle":["new"],"handles::ByteTwoHandle":["new"],"handles::ByteUnreadHandle":["new"],"handles::CopyAsciiResult":["copy_ascii_from_check_space_astral","copy_ascii_from_check_space_bmp","copy_ascii_to_check_space_four","copy_ascii_to_check_space_one","copy_ascii_to_check_space_two","copy_unaligned_basic_latin_to_ascii","copy_unaligned_basic_latin_to_ascii_alu"],"handles::Space":["check_available","check_space_astral","check_space_bmp","check_space_four","check_space_one","check_space_three","check_space_two"],"handles::UnalignedU16Slice":["clone","new","tail"],"handles::Unicode":["read_enum"],"handles::Utf16AstralHandle":["new"],"handles::Utf16BmpHandle":["new"],"handles::Utf16Destination":["new"],"handles::Utf16ReadHandle":["new"],"handles::Utf16Source":["new"],"handles::Utf16UnreadHandle":["new"],"handles::Utf8AstralHandle":["new"],"handles::Utf8BmpHandle":["new"],"handles::Utf8Destination":["new"],"handles::Utf8ReadHandle":["new"],"handles::Utf8Source":["new"],"handles::Utf8UnreadHandle":["new"],"iso_2022_jp::Iso2022JpDecoderState":["clone"],"mem::Latin1Bidi":["check_str_for_latin1_and_bidi","check_utf16_for_latin1_and_bidi","check_utf16_for_latin1_and_bidi_impl","check_utf8_for_latin1_and_bidi"],"std::borrow::Cow":["decode_latin1","decode_without_bom_handling_and_without_replacement","encode_latin1_lossy"],"u16":["at","big5_low_bits","jis0208_range_decode","jis0208_symbol_decode","jis0212_accented_decode"],"u32":["count_zeros"],"u8":["encode_u16","read"],"usize":["additional_from_state","ascii_to_ascii_stride","ascii_valid_up_to","big5_astral_encode","big5_box_encode","big5_other_encode","consumed","convert_latin1_to_str","convert_latin1_to_utf8","convert_str_to_utf16","convert_utf16_to_str","convert_utf16_to_utf8","convert_utf8_to_latin1_lossy","convert_utf8_to_utf16","convert_utf8_to_utf16_without_replacement","copy_ascii_to_ascii","copy_ascii_to_basic_latin","copy_basic_latin_to_ascii","count","extra_from_state","extra_to_output_from_state","gb18030_range_encode","gb2312_level2_hanzi_encode","ibm_symbol_encode","is_str_latin1_impl","is_utf8_latin1_impl","iso_2022_jp_ascii_valid_up_to","jis0208_level2_and_additional_kanji_encode","jis0208_range_encode","jis0208_symbol_encode","latin1_byte_compatible_up_to","len","mul_94","position","str_latin1_up_to","unread","utf16_valid_up_to","utf16_valid_up_to_impl","utf8_latin1_up_to","utf8_valid_up_to","validate_ascii_stride","write_ncr","write_three_return_written","written"],"utf_8::Utf8Decoder":["new_inner"],"variant::VariantDecoder":["new","new_variant_decoder"]},"struct_to_trait":{"BomHandling":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"CoderResult":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"DecoderLifeCycle":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"DecoderResult":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"EncoderResult":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"Encoding":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash"],"handles::BigEndian":["handles::Endian"],"handles::LittleEndian":["handles::Endian"],"handles::UnalignedU16Slice":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"iso_2022_jp::Iso2022JpDecoderState":["std::clone::Clone","std::cmp::PartialEq","std::marker::Copy","std::marker::StructuralPartialEq"],"mem::Latin1Bidi":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"]},"targets":{"<Encoding as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/lib.rs\"))","std::cmp::PartialEq"],"<Encoding as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<Encoding as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/lib.rs\"))","std::hash::Hash"],"Decoder::decode_to_str":["decode_to_str","Real(LocalPath(\"src/lib.rs\"))",""],"Decoder::decode_to_str_without_replacement":["decode_to_str_without_replacement","Real(LocalPath(\"src/lib.rs\"))",""],"Decoder::decode_to_string":["decode_to_string","Real(LocalPath(\"src/lib.rs\"))",""],"Decoder::decode_to_string_without_replacement":["decode_to_string_without_replacement","Real(LocalPath(\"src/lib.rs\"))",""],"Decoder::decode_to_utf16":["decode_to_utf16","Real(LocalPath(\"src/lib.rs\"))",""],"Decoder::decode_to_utf16_after_one_potential_bom_byte":["decode_to_utf16_after_one_potential_bom_byte","Real(LocalPath(\"src/macros.rs\"))",""],"Decoder::decode_to_utf16_after_two_potential_bom_bytes":["decode_to_utf16_after_two_potential_bom_bytes","Real(LocalPath(\"src/macros.rs\"))",""],"Decoder::decode_to_utf16_checking_end":["decode_to_utf16_checking_end","Real(LocalPath(\"src/macros.rs\"))",""],"Decoder::decode_to_utf16_checking_end_with_offset":["decode_to_utf16_checking_end_with_offset","Real(LocalPath(\"src/macros.rs\"))",""],"Decoder::decode_to_utf16_without_replacement":["decode_to_utf16_without_replacement","Real(LocalPath(\"src/macros.rs\"))",""],"Decoder::decode_to_utf8":["decode_to_utf8","Real(LocalPath(\"src/lib.rs\"))",""],"Decoder::decode_to_utf8_after_one_potential_bom_byte":["decode_to_utf8_after_one_potential_bom_byte","Real(LocalPath(\"src/macros.rs\"))",""],"Decoder::decode_to_utf8_after_two_potential_bom_bytes":["decode_to_utf8_after_two_potential_bom_bytes","Real(LocalPath(\"src/macros.rs\"))",""],"Decoder::decode_to_utf8_checking_end":["decode_to_utf8_checking_end","Real(LocalPath(\"src/macros.rs\"))",""],"Decoder::decode_to_utf8_checking_end_with_offset":["decode_to_utf8_checking_end_with_offset","Real(LocalPath(\"src/macros.rs\"))",""],"Decoder::decode_to_utf8_without_replacement":["decode_to_utf8_without_replacement","Real(LocalPath(\"src/macros.rs\"))",""],"Decoder::encoding":["encoding","Real(LocalPath(\"src/lib.rs\"))",""],"Decoder::latin1_byte_compatible_up_to":["latin1_byte_compatible_up_to","Real(LocalPath(\"src/lib.rs\"))",""],"Decoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/lib.rs\"))",""],"Decoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/lib.rs\"))",""],"Decoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/lib.rs\"))",""],"Decoder::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::encode_from_utf16":["encode_from_utf16","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::encode_from_utf16_without_replacement":["encode_from_utf16_without_replacement","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::encode_from_utf8":["encode_from_utf8","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::encode_from_utf8_to_vec":["encode_from_utf8_to_vec","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::encode_from_utf8_to_vec_without_replacement":["encode_from_utf8_to_vec_without_replacement","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::encode_from_utf8_without_replacement":["encode_from_utf8_without_replacement","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::encoding":["encoding","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::has_pending_state":["has_pending_state","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::max_buffer_length_from_utf16_if_no_unmappables":["max_buffer_length_from_utf16_if_no_unmappables","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::max_buffer_length_from_utf16_without_replacement":["max_buffer_length_from_utf16_without_replacement","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::max_buffer_length_from_utf8_if_no_unmappables":["max_buffer_length_from_utf8_if_no_unmappables","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::max_buffer_length_from_utf8_without_replacement":["max_buffer_length_from_utf8_without_replacement","Real(LocalPath(\"src/lib.rs\"))",""],"Encoder::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"EncoderResult::unmappable_from_bmp":["unmappable_from_bmp","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::ascii_valid_up_to":["ascii_valid_up_to","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::can_encode_everything":["can_encode_everything","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::decode":["decode","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::decode_with_bom_removal":["decode_with_bom_removal","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::decode_without_bom_handling":["decode_without_bom_handling","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::decode_without_bom_handling_and_without_replacement":["decode_without_bom_handling_and_without_replacement","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::encode":["encode","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::for_bom":["for_bom","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::for_label":["for_label","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::for_label_no_replacement":["for_label_no_replacement","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::is_ascii_compatible":["is_ascii_compatible","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::is_potentially_borrowable":["is_potentially_borrowable","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::is_single_byte":["is_single_byte","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::iso_2022_jp_ascii_valid_up_to":["iso_2022_jp_ascii_valid_up_to","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::name":["name","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::new_decoder":["new_decoder","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::new_decoder_with_bom_removal":["new_decoder_with_bom_removal","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::new_decoder_without_bom_handling":["new_decoder_without_bom_handling","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::new_encoder":["new_encoder","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::new_variant_decoder":["new_variant_decoder","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::output_encoding":["output_encoding","Real(LocalPath(\"src/lib.rs\"))",""],"Encoding::utf8_valid_up_to":["utf8_valid_up_to","Real(LocalPath(\"src/lib.rs\"))",""],"ascii::ascii_to_ascii":["ascii_to_ascii","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::ascii_to_ascii_stride":["ascii_to_ascii_stride","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::ascii_to_basic_latin":["ascii_to_basic_latin","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::ascii_to_basic_latin_stride_alu":["ascii_to_basic_latin_stride_alu","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::ascii_valid_up_to":["ascii_valid_up_to","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::basic_latin_to_ascii":["basic_latin_to_ascii","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::basic_latin_to_ascii_stride_alu":["basic_latin_to_ascii_stride_alu","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::count_zeros":["count_zeros","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::find_non_ascii":["find_non_ascii","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::iso_2022_jp_ascii_valid_up_to":["iso_2022_jp_ascii_valid_up_to","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::likely":["likely","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::pack_alu":["pack_alu","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::pack_latin1":["pack_latin1","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::pack_latin1_stride_alu":["pack_latin1_stride_alu","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::unlikely":["unlikely","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::unpack_alu":["unpack_alu","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::unpack_latin1":["unpack_latin1","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::unpack_latin1_stride_alu":["unpack_latin1_stride_alu","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::validate_ascii":["validate_ascii","Real(LocalPath(\"src/ascii.rs\"))",""],"ascii::validate_ascii_stride":["validate_ascii_stride","Real(LocalPath(\"src/ascii.rs\"))",""],"big5::Big5Decoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"big5::Big5Decoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"big5::Big5Decoder::in_neutral_state":["in_neutral_state","Real(LocalPath(\"src/big5.rs\"))",""],"big5::Big5Decoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/big5.rs\"))",""],"big5::Big5Decoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/big5.rs\"))",""],"big5::Big5Decoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/big5.rs\"))",""],"big5::Big5Decoder::new":["new","Real(LocalPath(\"src/big5.rs\"))",""],"big5::Big5Decoder::plus_one_if_lead":["plus_one_if_lead","Real(LocalPath(\"src/big5.rs\"))",""],"big5::Big5Encoder::encode_from_utf16_raw":["encode_from_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"big5::Big5Encoder::encode_from_utf8_raw":["encode_from_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"big5::Big5Encoder::max_buffer_length_from_utf16_without_replacement":["max_buffer_length_from_utf16_without_replacement","Real(LocalPath(\"src/big5.rs\"))",""],"big5::Big5Encoder::max_buffer_length_from_utf8_without_replacement":["max_buffer_length_from_utf8_without_replacement","Real(LocalPath(\"src/big5.rs\"))",""],"big5::Big5Encoder::new":["new","Real(LocalPath(\"src/big5.rs\"))",""],"checked_add":["checked_add","Real(LocalPath(\"src/lib.rs\"))",""],"checked_add_opt":["checked_add_opt","Real(LocalPath(\"src/lib.rs\"))",""],"checked_div":["checked_div","Real(LocalPath(\"src/lib.rs\"))",""],"checked_min":["checked_min","Real(LocalPath(\"src/lib.rs\"))",""],"checked_mul":["checked_mul","Real(LocalPath(\"src/lib.rs\"))",""],"checked_next_power_of_two":["checked_next_power_of_two","Real(LocalPath(\"src/lib.rs\"))",""],"data::big5_astral_encode":["big5_astral_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::big5_box_encode":["big5_box_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::big5_is_astral":["big5_is_astral","Real(LocalPath(\"src/data.rs\"))",""],"data::big5_level1_hanzi_encode":["big5_level1_hanzi_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::big5_low_bits":["big5_low_bits","Real(LocalPath(\"src/data.rs\"))",""],"data::big5_other_encode":["big5_other_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::cp949_left_hangul_decode":["cp949_left_hangul_decode","Real(LocalPath(\"src/data.rs\"))",""],"data::cp949_left_hangul_encode":["cp949_left_hangul_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::cp949_top_hangul_decode":["cp949_top_hangul_decode","Real(LocalPath(\"src/data.rs\"))",""],"data::cp949_top_hangul_encode":["cp949_top_hangul_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::gb18030_range_decode":["gb18030_range_decode","Real(LocalPath(\"src/data.rs\"))",""],"data::gb18030_range_encode":["gb18030_range_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::gb2312_level1_hanzi_encode":["gb2312_level1_hanzi_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::gb2312_level2_hanzi_encode":["gb2312_level2_hanzi_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::gb2312_other_decode":["gb2312_other_decode","Real(LocalPath(\"src/data.rs\"))",""],"data::gb2312_other_encode":["gb2312_other_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::gbk_left_ideograph_decode":["gbk_left_ideograph_decode","Real(LocalPath(\"src/data.rs\"))",""],"data::gbk_left_ideograph_encode":["gbk_left_ideograph_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::gbk_other_decode":["gbk_other_decode","Real(LocalPath(\"src/data.rs\"))",""],"data::gbk_other_encode":["gbk_other_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::gbk_top_ideograph_decode":["gbk_top_ideograph_decode","Real(LocalPath(\"src/data.rs\"))",""],"data::gbk_top_ideograph_encode":["gbk_top_ideograph_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::ibm_symbol_encode":["ibm_symbol_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::jis0208_level1_kanji_euc_jp_encode":["jis0208_level1_kanji_euc_jp_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::jis0208_level1_kanji_iso_2022_jp_encode":["jis0208_level1_kanji_iso_2022_jp_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::jis0208_level1_kanji_shift_jis_encode":["jis0208_level1_kanji_shift_jis_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::jis0208_level2_and_additional_kanji_encode":["jis0208_level2_and_additional_kanji_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::jis0208_range_decode":["jis0208_range_decode","Real(LocalPath(\"src/data.rs\"))",""],"data::jis0208_range_encode":["jis0208_range_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::jis0208_symbol_decode":["jis0208_symbol_decode","Real(LocalPath(\"src/data.rs\"))",""],"data::jis0208_symbol_encode":["jis0208_symbol_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::jis0212_accented_decode":["jis0212_accented_decode","Real(LocalPath(\"src/data.rs\"))",""],"data::ksx1001_other_decode":["ksx1001_other_decode","Real(LocalPath(\"src/data.rs\"))",""],"data::ksx1001_other_encode":["ksx1001_other_encode","Real(LocalPath(\"src/data.rs\"))",""],"data::map_with_ranges":["map_with_ranges","Real(LocalPath(\"src/data.rs\"))",""],"data::map_with_unsorted_ranges":["map_with_unsorted_ranges","Real(LocalPath(\"src/data.rs\"))",""],"data::mul_94":["mul_94","Real(LocalPath(\"src/data.rs\"))",""],"data::position":["position","Real(LocalPath(\"src/data.rs\"))",""],"euc_jp::EucJpDecoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"euc_jp::EucJpDecoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"euc_jp::EucJpDecoder::in_neutral_state":["in_neutral_state","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_jp::EucJpDecoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_jp::EucJpDecoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_jp::EucJpDecoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_jp::EucJpDecoder::new":["new","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_jp::EucJpDecoder::plus_one_if_lead":["plus_one_if_lead","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_jp::EucJpEncoder::encode_from_utf16_raw":["encode_from_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"euc_jp::EucJpEncoder::encode_from_utf8_raw":["encode_from_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"euc_jp::EucJpEncoder::max_buffer_length_from_utf16_without_replacement":["max_buffer_length_from_utf16_without_replacement","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_jp::EucJpEncoder::max_buffer_length_from_utf8_without_replacement":["max_buffer_length_from_utf8_without_replacement","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_jp::EucJpEncoder::new":["new","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_jp::EucJpPending::count":["count","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_jp::EucJpPending::is_none":["is_none","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_jp::encode_kanji":["encode_kanji","Real(LocalPath(\"src/euc_jp.rs\"))",""],"euc_kr::EucKrDecoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"euc_kr::EucKrDecoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"euc_kr::EucKrDecoder::in_neutral_state":["in_neutral_state","Real(LocalPath(\"src/euc_kr.rs\"))",""],"euc_kr::EucKrDecoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/euc_kr.rs\"))",""],"euc_kr::EucKrDecoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/euc_kr.rs\"))",""],"euc_kr::EucKrDecoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/euc_kr.rs\"))",""],"euc_kr::EucKrDecoder::new":["new","Real(LocalPath(\"src/euc_kr.rs\"))",""],"euc_kr::EucKrDecoder::plus_one_if_lead":["plus_one_if_lead","Real(LocalPath(\"src/euc_kr.rs\"))",""],"euc_kr::EucKrEncoder::encode_from_utf16_raw":["encode_from_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"euc_kr::EucKrEncoder::encode_from_utf8_raw":["encode_from_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"euc_kr::EucKrEncoder::max_buffer_length_from_utf16_without_replacement":["max_buffer_length_from_utf16_without_replacement","Real(LocalPath(\"src/euc_kr.rs\"))",""],"euc_kr::EucKrEncoder::max_buffer_length_from_utf8_without_replacement":["max_buffer_length_from_utf8_without_replacement","Real(LocalPath(\"src/euc_kr.rs\"))",""],"euc_kr::EucKrEncoder::new":["new","Real(LocalPath(\"src/euc_kr.rs\"))",""],"euc_kr::ksx1001_encode_hangul":["ksx1001_encode_hangul","Real(LocalPath(\"src/euc_kr.rs\"))",""],"euc_kr::ksx1001_encode_hanja":["ksx1001_encode_hanja","Real(LocalPath(\"src/euc_kr.rs\"))",""],"euc_kr::ksx1001_encode_misc":["ksx1001_encode_misc","Real(LocalPath(\"src/euc_kr.rs\"))",""],"gb18030::Gb18030Decoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"gb18030::Gb18030Decoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"gb18030::Gb18030Decoder::extra_from_state":["extra_from_state","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::Gb18030Decoder::in_neutral_state":["in_neutral_state","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::Gb18030Decoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::Gb18030Decoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::Gb18030Decoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::Gb18030Decoder::new":["new","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::Gb18030Encoder::encode_from_utf16_raw":["encode_from_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"gb18030::Gb18030Encoder::encode_from_utf8_raw":["encode_from_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"gb18030::Gb18030Encoder::max_buffer_length_from_utf16_without_replacement":["max_buffer_length_from_utf16_without_replacement","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::Gb18030Encoder::max_buffer_length_from_utf8_without_replacement":["max_buffer_length_from_utf8_without_replacement","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::Gb18030Encoder::new":["new","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::Gb18030Pending::count":["count","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::Gb18030Pending::is_none":["is_none","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::encode_hanzi":["encode_hanzi","Real(LocalPath(\"src/gb18030.rs\"))",""],"gb18030::gbk_encode_non_unified":["gbk_encode_non_unified","Real(LocalPath(\"src/gb18030.rs\"))",""],"handles::ByteDestination::<'a>::check_space_four":["check_space_four","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteDestination::<'a>::check_space_one":["check_space_one","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteDestination::<'a>::check_space_three":["check_space_three","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteDestination::<'a>::check_space_two":["check_space_two","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteDestination::<'a>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteDestination::<'a>::write_four":["write_four","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteDestination::<'a>::write_one":["write_one","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteDestination::<'a>::write_three":["write_three","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteDestination::<'a>::write_two":["write_two","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteDestination::<'a>::written":["written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteFourHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteFourHandle::<'a, 'b>::write_four":["write_four","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteFourHandle::<'a, 'b>::write_one":["write_one","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteFourHandle::<'a, 'b>::write_two":["write_two","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteFourHandle::<'a, 'b>::written":["written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteOneHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteOneHandle::<'a, 'b>::write_one":["write_one","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteOneHandle::<'a, 'b>::written":["written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteReadHandle::<'a, 'b>::consumed":["consumed","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteReadHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteReadHandle::<'a, 'b>::read":["read","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteSource::<'a>::check_available":["check_available","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteSource::<'a>::consumed":["consumed","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteSource::<'a>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteSource::<'a>::read":["read","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteSource::<'a>::unread":["unread","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteThreeHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteThreeHandle::<'a, 'b>::write_one":["write_one","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteThreeHandle::<'a, 'b>::write_three":["write_three","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteThreeHandle::<'a, 'b>::write_three_return_written":["write_three_return_written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteThreeHandle::<'a, 'b>::write_two":["write_two","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteThreeHandle::<'a, 'b>::written":["written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteTwoHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteTwoHandle::<'a, 'b>::write_one":["write_one","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteTwoHandle::<'a, 'b>::write_two":["write_two","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteTwoHandle::<'a, 'b>::written":["written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteUnreadHandle::<'a, 'b>::commit":["commit","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteUnreadHandle::<'a, 'b>::consumed":["consumed","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteUnreadHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::ByteUnreadHandle::<'a, 'b>::unread":["unread","Real(LocalPath(\"src/handles.rs\"))",""],"handles::UnalignedU16Slice::at":["at","Real(LocalPath(\"src/handles.rs\"))",""],"handles::UnalignedU16Slice::copy_bmp_to":["copy_bmp_to","Real(LocalPath(\"src/handles.rs\"))",""],"handles::UnalignedU16Slice::len":["len","Real(LocalPath(\"src/handles.rs\"))",""],"handles::UnalignedU16Slice::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::UnalignedU16Slice::tail":["tail","Real(LocalPath(\"src/handles.rs\"))",""],"handles::UnalignedU16Slice::trim_last":["trim_last","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16AstralHandle::<'a, 'b>::commit":["commit","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16AstralHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16AstralHandle::<'a, 'b>::write_ascii":["write_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16AstralHandle::<'a, 'b>::write_astral":["write_astral","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16AstralHandle::<'a, 'b>::write_big5_combination":["write_big5_combination","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16AstralHandle::<'a, 'b>::write_bmp":["write_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16AstralHandle::<'a, 'b>::write_bmp_excl_ascii":["write_bmp_excl_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16AstralHandle::<'a, 'b>::write_surrogate_pair":["write_surrogate_pair","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16AstralHandle::<'a, 'b>::write_upper_bmp":["write_upper_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16AstralHandle::<'a, 'b>::written":["written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16BmpHandle::<'a, 'b>::commit":["commit","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16BmpHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16BmpHandle::<'a, 'b>::write_ascii":["write_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16BmpHandle::<'a, 'b>::write_bmp":["write_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16BmpHandle::<'a, 'b>::write_bmp_excl_ascii":["write_bmp_excl_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16BmpHandle::<'a, 'b>::write_mid_bmp":["write_mid_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16BmpHandle::<'a, 'b>::write_upper_bmp":["write_upper_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16BmpHandle::<'a, 'b>::written":["written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::check_space_astral":["check_space_astral","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::check_space_bmp":["check_space_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::copy_ascii_from_check_space_astral":["copy_ascii_from_check_space_astral","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::copy_ascii_from_check_space_bmp":["copy_ascii_from_check_space_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::copy_utf16_from":["copy_utf16_from","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::copy_utf8_up_to_invalid_from":["copy_utf8_up_to_invalid_from","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::write_ascii":["write_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::write_astral":["write_astral","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::write_big5_combination":["write_big5_combination","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::write_bmp":["write_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::write_bmp_excl_ascii":["write_bmp_excl_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::write_code_unit":["write_code_unit","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::write_mid_bmp":["write_mid_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::write_surrogate_pair":["write_surrogate_pair","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::write_upper_bmp":["write_upper_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Destination::<'a>::written":["written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16ReadHandle::<'a, 'b>::consumed":["consumed","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16ReadHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16ReadHandle::<'a, 'b>::read":["read","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16ReadHandle::<'a, 'b>::read_enum":["read_enum","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Source::<'a>::check_available":["check_available","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Source::<'a>::consumed":["consumed","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Source::<'a>::copy_ascii_to_check_space_four":["copy_ascii_to_check_space_four","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Source::<'a>::copy_ascii_to_check_space_two":["copy_ascii_to_check_space_two","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Source::<'a>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Source::<'a>::read":["read","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Source::<'a>::read_enum":["read_enum","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16Source::<'a>::unread":["unread","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16UnreadHandle::<'a, 'b>::commit":["commit","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16UnreadHandle::<'a, 'b>::consumed":["consumed","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16UnreadHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf16UnreadHandle::<'a, 'b>::unread":["unread","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8AstralHandle::<'a, 'b>::commit":["commit","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8AstralHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8AstralHandle::<'a, 'b>::write_ascii":["write_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8AstralHandle::<'a, 'b>::write_astral":["write_astral","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8AstralHandle::<'a, 'b>::write_big5_combination":["write_big5_combination","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8AstralHandle::<'a, 'b>::write_bmp":["write_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8AstralHandle::<'a, 'b>::write_bmp_excl_ascii":["write_bmp_excl_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8AstralHandle::<'a, 'b>::write_surrogate_pair":["write_surrogate_pair","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8AstralHandle::<'a, 'b>::write_upper_bmp":["write_upper_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8AstralHandle::<'a, 'b>::written":["written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8BmpHandle::<'a, 'b>::commit":["commit","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8BmpHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8BmpHandle::<'a, 'b>::write_ascii":["write_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8BmpHandle::<'a, 'b>::write_bmp":["write_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8BmpHandle::<'a, 'b>::write_bmp_excl_ascii":["write_bmp_excl_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8BmpHandle::<'a, 'b>::write_mid_bmp":["write_mid_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8BmpHandle::<'a, 'b>::write_upper_bmp":["write_upper_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8BmpHandle::<'a, 'b>::written":["written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::check_space_astral":["check_space_astral","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::check_space_bmp":["check_space_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::copy_ascii_from_check_space_astral":["copy_ascii_from_check_space_astral","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::copy_ascii_from_check_space_bmp":["copy_ascii_from_check_space_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::copy_utf16_from":["copy_utf16_from","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::copy_utf8_up_to_invalid_from":["copy_utf8_up_to_invalid_from","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::write_ascii":["write_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::write_astral":["write_astral","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::write_big5_combination":["write_big5_combination","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::write_bmp":["write_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::write_bmp_excl_ascii":["write_bmp_excl_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::write_code_unit":["write_code_unit","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::write_mid_bmp":["write_mid_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::write_surrogate_pair":["write_surrogate_pair","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::write_upper_bmp":["write_upper_bmp","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Destination::<'a>::written":["written","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8ReadHandle::<'a, 'b>::consumed":["consumed","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8ReadHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8ReadHandle::<'a, 'b>::read":["read","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8ReadHandle::<'a, 'b>::read_enum":["read_enum","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Source::<'a>::check_available":["check_available","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Source::<'a>::consumed":["consumed","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Source::<'a>::copy_ascii_to_check_space_four":["copy_ascii_to_check_space_four","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Source::<'a>::copy_ascii_to_check_space_one":["copy_ascii_to_check_space_one","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Source::<'a>::copy_ascii_to_check_space_two":["copy_ascii_to_check_space_two","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Source::<'a>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Source::<'a>::read":["read","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Source::<'a>::read_enum":["read_enum","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8Source::<'a>::unread":["unread","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8UnreadHandle::<'a, 'b>::commit":["commit","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8UnreadHandle::<'a, 'b>::consumed":["consumed","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8UnreadHandle::<'a, 'b>::new":["new","Real(LocalPath(\"src/handles.rs\"))",""],"handles::Utf8UnreadHandle::<'a, 'b>::unread":["unread","Real(LocalPath(\"src/handles.rs\"))",""],"handles::convert_unaligned_utf16_to_utf8":["convert_unaligned_utf16_to_utf8","Real(LocalPath(\"src/handles.rs\"))",""],"handles::copy_unaligned_basic_latin_to_ascii":["copy_unaligned_basic_latin_to_ascii","Real(LocalPath(\"src/handles.rs\"))",""],"handles::copy_unaligned_basic_latin_to_ascii_alu":["copy_unaligned_basic_latin_to_ascii_alu","Real(LocalPath(\"src/handles.rs\"))",""],"handles::swap_if_opposite_endian":["swap_if_opposite_endian","Real(LocalPath(\"src/handles.rs\"))",""],"in_inclusive_range":["in_inclusive_range","Real(LocalPath(\"src/lib.rs\"))",""],"in_inclusive_range16":["in_inclusive_range16","Real(LocalPath(\"src/lib.rs\"))",""],"in_inclusive_range32":["in_inclusive_range32","Real(LocalPath(\"src/lib.rs\"))",""],"in_inclusive_range8":["in_inclusive_range8","Real(LocalPath(\"src/lib.rs\"))",""],"in_range16":["in_range16","Real(LocalPath(\"src/lib.rs\"))",""],"in_range32":["in_range32","Real(LocalPath(\"src/lib.rs\"))",""],"iso_2022_jp::Iso2022JpDecoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"iso_2022_jp::Iso2022JpDecoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"iso_2022_jp::Iso2022JpDecoder::extra_to_input_from_state":["extra_to_input_from_state","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::Iso2022JpDecoder::extra_to_output_from_state":["extra_to_output_from_state","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::Iso2022JpDecoder::in_neutral_state":["in_neutral_state","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::Iso2022JpDecoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::Iso2022JpDecoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::Iso2022JpDecoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::Iso2022JpDecoder::new":["new","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::Iso2022JpEncoder::encode_from_utf16_raw":["encode_from_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"iso_2022_jp::Iso2022JpEncoder::encode_from_utf8_raw":["encode_from_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"iso_2022_jp::Iso2022JpEncoder::has_pending_state":["has_pending_state","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::Iso2022JpEncoder::max_buffer_length_from_utf16_without_replacement":["max_buffer_length_from_utf16_without_replacement","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::Iso2022JpEncoder::max_buffer_length_from_utf8_without_replacement":["max_buffer_length_from_utf8_without_replacement","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::Iso2022JpEncoder::new":["new","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::encode_kanji":["encode_kanji","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::is_kanji_mapped":["is_kanji_mapped","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"iso_2022_jp::is_mapped_for_two_byte_encode":["is_mapped_for_two_byte_encode","Real(LocalPath(\"src/iso_2022_jp.rs\"))",""],"mem::check_str_for_latin1_and_bidi":["check_str_for_latin1_and_bidi","Real(LocalPath(\"src/mem.rs\"))",""],"mem::check_utf16_for_latin1_and_bidi":["check_utf16_for_latin1_and_bidi","Real(LocalPath(\"src/mem.rs\"))",""],"mem::check_utf16_for_latin1_and_bidi_impl":["check_utf16_for_latin1_and_bidi_impl","Real(LocalPath(\"src/mem.rs\"))",""],"mem::check_utf8_for_latin1_and_bidi":["check_utf8_for_latin1_and_bidi","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_latin1_to_str":["convert_latin1_to_str","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_latin1_to_str_partial":["convert_latin1_to_str_partial","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_latin1_to_utf16":["convert_latin1_to_utf16","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_latin1_to_utf8":["convert_latin1_to_utf8","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_latin1_to_utf8_partial":["convert_latin1_to_utf8_partial","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_str_to_utf16":["convert_str_to_utf16","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_utf16_to_latin1_lossy":["convert_utf16_to_latin1_lossy","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_utf16_to_str":["convert_utf16_to_str","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_utf16_to_str_partial":["convert_utf16_to_str_partial","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_utf16_to_utf8":["convert_utf16_to_utf8","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_utf16_to_utf8_partial":["convert_utf16_to_utf8_partial","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_utf8_to_latin1_lossy":["convert_utf8_to_latin1_lossy","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_utf8_to_utf16":["convert_utf8_to_utf16","Real(LocalPath(\"src/mem.rs\"))",""],"mem::convert_utf8_to_utf16_without_replacement":["convert_utf8_to_utf16_without_replacement","Real(LocalPath(\"src/mem.rs\"))",""],"mem::copy_ascii_to_ascii":["copy_ascii_to_ascii","Real(LocalPath(\"src/mem.rs\"))",""],"mem::copy_ascii_to_basic_latin":["copy_ascii_to_basic_latin","Real(LocalPath(\"src/mem.rs\"))",""],"mem::copy_basic_latin_to_ascii":["copy_basic_latin_to_ascii","Real(LocalPath(\"src/mem.rs\"))",""],"mem::decode_latin1":["decode_latin1","Real(LocalPath(\"src/mem.rs\"))",""],"mem::encode_latin1_lossy":["encode_latin1_lossy","Real(LocalPath(\"src/mem.rs\"))",""],"mem::ensure_utf16_validity":["ensure_utf16_validity","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_ascii":["is_ascii","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_ascii_impl":["is_ascii_impl","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_basic_latin":["is_basic_latin","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_basic_latin_impl":["is_basic_latin_impl","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_char_bidi":["is_char_bidi","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_str_bidi":["is_str_bidi","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_str_latin1":["is_str_latin1","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_str_latin1_impl":["is_str_latin1_impl","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_utf16_bidi":["is_utf16_bidi","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_utf16_bidi_impl":["is_utf16_bidi_impl","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_utf16_code_unit_bidi":["is_utf16_code_unit_bidi","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_utf16_latin1":["is_utf16_latin1","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_utf16_latin1_impl":["is_utf16_latin1_impl","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_utf8_bidi":["is_utf8_bidi","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_utf8_latin1":["is_utf8_latin1","Real(LocalPath(\"src/mem.rs\"))",""],"mem::is_utf8_latin1_impl":["is_utf8_latin1_impl","Real(LocalPath(\"src/mem.rs\"))",""],"mem::likely":["likely","Real(LocalPath(\"src/mem.rs\"))",""],"mem::str_latin1_up_to":["str_latin1_up_to","Real(LocalPath(\"src/mem.rs\"))",""],"mem::unlikely":["unlikely","Real(LocalPath(\"src/mem.rs\"))",""],"mem::utf16_valid_up_to":["utf16_valid_up_to","Real(LocalPath(\"src/mem.rs\"))",""],"mem::utf16_valid_up_to_alu":["utf16_valid_up_to_alu","Real(LocalPath(\"src/mem.rs\"))",""],"mem::utf16_valid_up_to_impl":["utf16_valid_up_to_impl","Real(LocalPath(\"src/mem.rs\"))",""],"mem::utf8_latin1_up_to":["utf8_latin1_up_to","Real(LocalPath(\"src/mem.rs\"))",""],"replacement::ReplacementDecoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/replacement.rs\"))",""],"replacement::ReplacementDecoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/replacement.rs\"))",""],"replacement::ReplacementDecoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/replacement.rs\"))",""],"replacement::ReplacementDecoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/replacement.rs\"))",""],"replacement::ReplacementDecoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/replacement.rs\"))",""],"replacement::ReplacementDecoder::new":["new","Real(LocalPath(\"src/replacement.rs\"))",""],"shift_jis::ShiftJisDecoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"shift_jis::ShiftJisDecoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"shift_jis::ShiftJisDecoder::in_neutral_state":["in_neutral_state","Real(LocalPath(\"src/shift_jis.rs\"))",""],"shift_jis::ShiftJisDecoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/shift_jis.rs\"))",""],"shift_jis::ShiftJisDecoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/shift_jis.rs\"))",""],"shift_jis::ShiftJisDecoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/shift_jis.rs\"))",""],"shift_jis::ShiftJisDecoder::new":["new","Real(LocalPath(\"src/shift_jis.rs\"))",""],"shift_jis::ShiftJisDecoder::plus_one_if_lead":["plus_one_if_lead","Real(LocalPath(\"src/shift_jis.rs\"))",""],"shift_jis::ShiftJisEncoder::encode_from_utf16_raw":["encode_from_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"shift_jis::ShiftJisEncoder::encode_from_utf8_raw":["encode_from_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"shift_jis::ShiftJisEncoder::max_buffer_length_from_utf16_without_replacement":["max_buffer_length_from_utf16_without_replacement","Real(LocalPath(\"src/shift_jis.rs\"))",""],"shift_jis::ShiftJisEncoder::max_buffer_length_from_utf8_without_replacement":["max_buffer_length_from_utf8_without_replacement","Real(LocalPath(\"src/shift_jis.rs\"))",""],"shift_jis::ShiftJisEncoder::new":["new","Real(LocalPath(\"src/shift_jis.rs\"))",""],"shift_jis::encode_kanji":["encode_kanji","Real(LocalPath(\"src/shift_jis.rs\"))",""],"single_byte::SingleByteDecoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/single_byte.rs\"))",""],"single_byte::SingleByteDecoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/single_byte.rs\"))",""],"single_byte::SingleByteDecoder::latin1_byte_compatible_up_to":["latin1_byte_compatible_up_to","Real(LocalPath(\"src/single_byte.rs\"))",""],"single_byte::SingleByteDecoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/single_byte.rs\"))",""],"single_byte::SingleByteDecoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/single_byte.rs\"))",""],"single_byte::SingleByteDecoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/single_byte.rs\"))",""],"single_byte::SingleByteDecoder::new":["new","Real(LocalPath(\"src/single_byte.rs\"))",""],"single_byte::SingleByteEncoder::encode_from_utf16_raw":["encode_from_utf16_raw","Real(LocalPath(\"src/single_byte.rs\"))",""],"single_byte::SingleByteEncoder::encode_from_utf8_raw":["encode_from_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"single_byte::SingleByteEncoder::encode_u16":["encode_u16","Real(LocalPath(\"src/single_byte.rs\"))",""],"single_byte::SingleByteEncoder::max_buffer_length_from_utf16_without_replacement":["max_buffer_length_from_utf16_without_replacement","Real(LocalPath(\"src/single_byte.rs\"))",""],"single_byte::SingleByteEncoder::max_buffer_length_from_utf8_without_replacement":["max_buffer_length_from_utf8_without_replacement","Real(LocalPath(\"src/single_byte.rs\"))",""],"single_byte::SingleByteEncoder::new":["new","Real(LocalPath(\"src/single_byte.rs\"))",""],"utf_16::Utf16Decoder::additional_from_state":["additional_from_state","Real(LocalPath(\"src/utf_16.rs\"))",""],"utf_16::Utf16Decoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"utf_16::Utf16Decoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"utf_16::Utf16Decoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/utf_16.rs\"))",""],"utf_16::Utf16Decoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/utf_16.rs\"))",""],"utf_16::Utf16Decoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/utf_16.rs\"))",""],"utf_16::Utf16Decoder::new":["new","Real(LocalPath(\"src/utf_16.rs\"))",""],"utf_8::Utf8Decoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"utf_8::Utf8Decoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"utf_8::Utf8Decoder::extra_from_state":["extra_from_state","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::Utf8Decoder::in_neutral_state":["in_neutral_state","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::Utf8Decoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::Utf8Decoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::Utf8Decoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::Utf8Decoder::new":["new","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::Utf8Decoder::new_inner":["new_inner","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::Utf8Encoder::encode_from_utf16_raw":["encode_from_utf16_raw","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::Utf8Encoder::encode_from_utf8_raw":["encode_from_utf8_raw","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::Utf8Encoder::max_buffer_length_from_utf16_without_replacement":["max_buffer_length_from_utf16_without_replacement","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::Utf8Encoder::max_buffer_length_from_utf8_without_replacement":["max_buffer_length_from_utf8_without_replacement","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::Utf8Encoder::new":["new","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::convert_utf16_to_utf8_partial_inner":["convert_utf16_to_utf8_partial_inner","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::convert_utf16_to_utf8_partial_tail":["convert_utf16_to_utf8_partial_tail","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::convert_utf8_to_utf16_up_to_invalid":["convert_utf8_to_utf16_up_to_invalid","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::likely":["likely","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::unlikely":["unlikely","Real(LocalPath(\"src/utf_8.rs\"))",""],"utf_8::utf8_valid_up_to":["utf8_valid_up_to","Real(LocalPath(\"src/utf_8.rs\"))",""],"variant::VariantDecoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantDecoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantDecoder::latin1_byte_compatible_up_to":["latin1_byte_compatible_up_to","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantDecoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantDecoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantDecoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantEncoder::encode_from_utf16_raw":["encode_from_utf16_raw","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantEncoder::encode_from_utf8_raw":["encode_from_utf8_raw","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantEncoder::has_pending_state":["has_pending_state","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantEncoder::max_buffer_length_from_utf16_without_replacement":["max_buffer_length_from_utf16_without_replacement","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantEncoder::max_buffer_length_from_utf8_without_replacement":["max_buffer_length_from_utf8_without_replacement","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantEncoding::is_single_byte":["is_single_byte","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantEncoding::new_encoder":["new_encoder","Real(LocalPath(\"src/variant.rs\"))",""],"variant::VariantEncoding::new_variant_decoder":["new_variant_decoder","Real(LocalPath(\"src/variant.rs\"))",""],"write_ncr":["write_ncr","Real(LocalPath(\"src/lib.rs\"))",""],"x_user_defined::UserDefinedDecoder::decode_to_utf16_raw":["decode_to_utf16_raw","Real(LocalPath(\"src/x_user_defined.rs\"))",""],"x_user_defined::UserDefinedDecoder::decode_to_utf8_raw":["decode_to_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"x_user_defined::UserDefinedDecoder::max_utf16_buffer_length":["max_utf16_buffer_length","Real(LocalPath(\"src/x_user_defined.rs\"))",""],"x_user_defined::UserDefinedDecoder::max_utf8_buffer_length":["max_utf8_buffer_length","Real(LocalPath(\"src/x_user_defined.rs\"))",""],"x_user_defined::UserDefinedDecoder::max_utf8_buffer_length_without_replacement":["max_utf8_buffer_length_without_replacement","Real(LocalPath(\"src/x_user_defined.rs\"))",""],"x_user_defined::UserDefinedDecoder::new":["new","Real(LocalPath(\"src/x_user_defined.rs\"))",""],"x_user_defined::UserDefinedEncoder::encode_from_utf16_raw":["encode_from_utf16_raw","Real(LocalPath(\"src/macros.rs\"))",""],"x_user_defined::UserDefinedEncoder::encode_from_utf8_raw":["encode_from_utf8_raw","Real(LocalPath(\"src/macros.rs\"))",""],"x_user_defined::UserDefinedEncoder::max_buffer_length_from_utf16_without_replacement":["max_buffer_length_from_utf16_without_replacement","Real(LocalPath(\"src/x_user_defined.rs\"))",""],"x_user_defined::UserDefinedEncoder::max_buffer_length_from_utf8_without_replacement":["max_buffer_length_from_utf8_without_replacement","Real(LocalPath(\"src/x_user_defined.rs\"))",""],"x_user_defined::UserDefinedEncoder::new":["new","Real(LocalPath(\"src/x_user_defined.rs\"))",""]},"trait_to_struct":{"handles::Endian":["handles::BigEndian","handles::LittleEndian"],"std::clone::Clone":["BomHandling","DecoderLifeCycle","handles::UnalignedU16Slice","iso_2022_jp::Iso2022JpDecoderState"],"std::cmp::Eq":["CoderResult","DecoderResult","EncoderResult","Encoding","mem::Latin1Bidi"],"std::cmp::PartialEq":["CoderResult","DecoderLifeCycle","DecoderResult","EncoderResult","Encoding","iso_2022_jp::Iso2022JpDecoderState","mem::Latin1Bidi"],"std::fmt::Debug":["BomHandling","CoderResult","DecoderLifeCycle","DecoderResult","EncoderResult","Encoding","handles::UnalignedU16Slice","mem::Latin1Bidi"],"std::hash::Hash":["Encoding"],"std::marker::Copy":["BomHandling","DecoderLifeCycle","handles::UnalignedU16Slice","iso_2022_jp::Iso2022JpDecoderState"],"std::marker::StructuralEq":["CoderResult","DecoderResult","EncoderResult","mem::Latin1Bidi"],"std::marker::StructuralPartialEq":["CoderResult","DecoderLifeCycle","DecoderResult","EncoderResult","iso_2022_jp::Iso2022JpDecoderState","mem::Latin1Bidi"]},"type_to_def_path":{"BomHandling":"BomHandling","CoderResult":"CoderResult","Decoder":"Decoder","DecoderLifeCycle":"DecoderLifeCycle","DecoderResult":"DecoderResult","Encoder":"Encoder","EncoderResult":"EncoderResult","Encoding":"Encoding","big5::Big5Decoder":"big5::Big5Decoder","big5::Big5Encoder":"big5::Big5Encoder","data::SingleByteData":"data::SingleByteData","euc_jp::EucJpDecoder":"euc_jp::EucJpDecoder","euc_jp::EucJpEncoder":"euc_jp::EucJpEncoder","euc_jp::EucJpPending":"euc_jp::EucJpPending","euc_kr::EucKrDecoder":"euc_kr::EucKrDecoder","euc_kr::EucKrEncoder":"euc_kr::EucKrEncoder","gb18030::Gb18030Decoder":"gb18030::Gb18030Decoder","gb18030::Gb18030Encoder":"gb18030::Gb18030Encoder","gb18030::Gb18030Pending":"gb18030::Gb18030Pending","handles::BigEndian":"handles::BigEndian","handles::ByteDestination<'a>":"handles::ByteDestination","handles::ByteFourHandle<'a, 'b>":"handles::ByteFourHandle","handles::ByteOneHandle<'a, 'b>":"handles::ByteOneHandle","handles::ByteReadHandle<'a, 'b>":"handles::ByteReadHandle","handles::ByteSource<'a>":"handles::ByteSource","handles::ByteThreeHandle<'a, 'b>":"handles::ByteThreeHandle","handles::ByteTwoHandle<'a, 'b>":"handles::ByteTwoHandle","handles::ByteUnreadHandle<'a, 'b>":"handles::ByteUnreadHandle","handles::CopyAsciiResult<T, U>":"handles::CopyAsciiResult","handles::LittleEndian":"handles::LittleEndian","handles::NonAscii":"handles::NonAscii","handles::Space<T>":"handles::Space","handles::UnalignedU16Slice":"handles::UnalignedU16Slice","handles::Unicode":"handles::Unicode","handles::Utf16AstralHandle<'a, 'b>":"handles::Utf16AstralHandle","handles::Utf16BmpHandle<'a, 'b>":"handles::Utf16BmpHandle","handles::Utf16Destination<'a>":"handles::Utf16Destination","handles::Utf16ReadHandle<'a, 'b>":"handles::Utf16ReadHandle","handles::Utf16Source<'a>":"handles::Utf16Source","handles::Utf16UnreadHandle<'a, 'b>":"handles::Utf16UnreadHandle","handles::Utf8AstralHandle<'a, 'b>":"handles::Utf8AstralHandle","handles::Utf8BmpHandle<'a, 'b>":"handles::Utf8BmpHandle","handles::Utf8Destination<'a>":"handles::Utf8Destination","handles::Utf8ReadHandle<'a, 'b>":"handles::Utf8ReadHandle","handles::Utf8Source<'a>":"handles::Utf8Source","handles::Utf8UnreadHandle<'a, 'b>":"handles::Utf8UnreadHandle","iso_2022_jp::Iso2022JpDecoder":"iso_2022_jp::Iso2022JpDecoder","iso_2022_jp::Iso2022JpDecoderState":"iso_2022_jp::Iso2022JpDecoderState","iso_2022_jp::Iso2022JpEncoder":"iso_2022_jp::Iso2022JpEncoder","iso_2022_jp::Iso2022JpEncoderState":"iso_2022_jp::Iso2022JpEncoderState","mem::Latin1Bidi":"mem::Latin1Bidi","replacement::ReplacementDecoder":"replacement::ReplacementDecoder","shift_jis::ShiftJisDecoder":"shift_jis::ShiftJisDecoder","shift_jis::ShiftJisEncoder":"shift_jis::ShiftJisEncoder","single_byte::SingleByteDecoder":"single_byte::SingleByteDecoder","single_byte::SingleByteEncoder":"single_byte::SingleByteEncoder","utf_16::Utf16Decoder":"utf_16::Utf16Decoder","utf_8::Utf8Data":"utf_8::Utf8Data","utf_8::Utf8Decoder":"utf_8::Utf8Decoder","utf_8::Utf8Encoder":"utf_8::Utf8Encoder","variant::VariantDecoder":"variant::VariantDecoder","variant::VariantEncoder":"variant::VariantEncoder","variant::VariantEncoding":"variant::VariantEncoding","x_user_defined::UserDefinedDecoder":"x_user_defined::UserDefinedDecoder","x_user_defined::UserDefinedEncoder":"x_user_defined::UserDefinedEncoder"}}