{"dependencies":{"<&'a hash::map::HashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<&'a hash::map::HashMap<K, V, S> as std::ops::Add>::add":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<&'a hash::set::HashSet<A, S> as std::iter::IntoIterator>::into_iter":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<&'a hash::set::HashSet<A, S> as std::ops::Add>::add":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<&'a hash::set::HashSet<A, S> as std::ops::Mul>::mul":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<&'a ord::map::OrdMap<K, V> as std::iter::IntoIterator>::into_iter":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<&'a ord::map::OrdMap<K, V> as std::ops::Add>::add":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<&'a ord::set::OrdSet<A> as std::iter::IntoIterator>::into_iter":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<&'a ord::set::OrdSet<A> as std::ops::Add>::add":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<&'a ord::set::OrdSet<A> as std::ops::Mul>::mul":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<&'a vector::Vector<A> as std::iter::IntoIterator>::into_iter":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<&'a vector::Vector<A> as std::ops::Add>::add":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<fakepool::Arc<A> as std::clone::Clone>::clone":["fakepool::Arc","std::marker::Sized","std::sync::Arc"],"<fakepool::Arc<A> as std::cmp::PartialEq>::eq":["fakepool::Arc","std::marker::Sized","std::sync::Arc"],"<fakepool::Arc<A> as std::default::Default>::default":["fakepool::Arc","std::marker::Sized","std::sync::Arc"],"<fakepool::Arc<A> as std::fmt::Debug>::fmt":["fakepool::Arc","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<fakepool::Arc<A> as std::ops::Deref>::deref":["fakepool::Arc","std::marker::Sized","std::sync::Arc"],"<fakepool::Pool<A> as std::clone::Clone>::clone":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized"],"<fakepool::Rc<A> as std::clone::Clone>::clone":["fakepool::Rc","std::marker::Sized","std::rc::Rc"],"<fakepool::Rc<A> as std::cmp::PartialEq>::eq":["fakepool::Rc","std::marker::Sized","std::rc::Rc"],"<fakepool::Rc<A> as std::default::Default>::default":["fakepool::Rc","std::marker::Sized","std::rc::Rc"],"<fakepool::Rc<A> as std::fmt::Debug>::fmt":["fakepool::Rc","std::fmt::Formatter","std::marker::Sized","std::rc::Rc","std::result::Result"],"<fakepool::Rc<A> as std::ops::Deref>::deref":["fakepool::Rc","std::marker::Sized","std::rc::Rc"],"<hash::map::ConsumingIter<A> as std::iter::Iterator>::next":["fakepool::Arc","fakepool::Pool","hash::map::ConsumingIter","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<hash::map::ConsumingIter<A> as std::iter::Iterator>::size_hint":["fakepool::Arc","fakepool::Pool","hash::map::ConsumingIter","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<hash::map::HashMap<K, V, S> as std::clone::Clone>::clone":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::cmp::Ord>::cmp":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::cmp::PartialEq>::eq":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::cmp::PartialOrd>::partial_cmp":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::convert::AsRef<hash::map::HashMap<K, V, S>>>::as_ref":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a [(K, V)]>>::from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a std::collections::BTreeMap<K, V>>>::from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a std::collections::HashMap<K, V>>>::from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a std::vec::Vec<(K, V)>>>::from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<hash::map::HashMap<K, V, S> as std::convert::From<std::collections::BTreeMap<K, V>>>::from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::convert::From<std::collections::HashMap<K, V>>>::from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::convert::From<std::vec::Vec<(K, V)>>>::from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<hash::map::HashMap<K, V, S> as std::default::Default>::default":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::fmt::Debug>::fmt":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::hash::Hash>::hash":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::iter::Extend<(RK, RV)>>::extend":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::iter::FromIterator<(K, V)>>::from_iter":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::iter::Sum>::sum":["fakepool::Arc","fakepool::Pool","hash::map::ConsumingIter","hash::map::HashMap","hash::map::HashMapPool","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::iter::Iterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<hash::map::HashMap<K, V, S> as std::ops::Add>::add":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::ops::Index<&'a BK>>::index":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<K, V, S> as std::ops::IndexMut<&'a BK>>::index_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMap<OK, OV, SB> as std::convert::From<&'m hash::map::HashMap<&'k K, &'v V, SA>>>::from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::map::HashMapPool<K, V> as std::clone::Clone>::clone":["fakepool::Pool","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized"],"<hash::map::HashMapPool<K, V> as std::default::Default>::default":["fakepool::Pool","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized"],"<hash::map::Iter<'a, K, V> as std::iter::Iterator>::next":["bitmaps::Bits","hash::map::Iter","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<hash::map::Iter<'a, K, V> as std::iter::Iterator>::size_hint":["bitmaps::Bits","hash::map::Iter","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<hash::map::IterMut<'a, K, V> as std::iter::Iterator>::next":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","hash::map::IterMut","nodes::hamt::IterMut","sized_chunks::sparse_chunk::IterMut","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<hash::map::IterMut<'a, K, V> as std::iter::Iterator>::size_hint":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","hash::map::IterMut","nodes::hamt::IterMut","sized_chunks::sparse_chunk::IterMut","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<hash::map::Keys<'a, K, V> as std::iter::Iterator>::next":["bitmaps::Bits","hash::map::Keys","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<hash::map::Keys<'a, K, V> as std::iter::Iterator>::size_hint":["bitmaps::Bits","hash::map::Keys","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<hash::map::Values<'a, K, V> as std::iter::Iterator>::next":["bitmaps::Bits","hash::map::Values","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<hash::map::Values<'a, K, V> as std::iter::Iterator>::size_hint":["bitmaps::Bits","hash::map::Values","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<hash::set::ConsumingIter<A> as std::iter::Iterator>::next":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::set::ConsumingIter","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<hash::set::ConsumingIter<A> as std::iter::Iterator>::size_hint":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::set::ConsumingIter","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<hash::set::HashSet<A, S> as std::clone::Clone>::clone":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::cmp::Ord>::cmp":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::cmp::PartialEq>::eq":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::cmp::PartialOrd>::partial_cmp":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::convert::From<&'a [A]>>::from":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::convert::From<&'a ord::set::OrdSet<A>>>::from":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::convert::From<&'a std::collections::BTreeSet<A>>>::from":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::convert::From<&'a std::collections::HashSet<A>>>::from":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::convert::From<&'a std::vec::Vec<A>>>::from":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<hash::set::HashSet<A, S> as std::convert::From<ord::set::OrdSet<A>>>::from":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::convert::From<std::collections::HashSet<A>>>::from":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::convert::From<std::vec::Vec<A>>>::from":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<hash::set::HashSet<A, S> as std::default::Default>::default":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::fmt::Debug>::fmt":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::hash::Hash>::hash":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::iter::Extend<R>>::extend":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::set::HashSet","hash::set::HashSetPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::iter::FromIterator<RA>>::from_iter":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::set::HashSet","hash::set::HashSetPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::iter::IntoIterator>::into_iter":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::iter::Sum>::sum":["fakepool::Arc","fakepool::Pool","hash::map::ConsumingIter","hash::set::HashSet","hash::set::HashSetPool","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::iter::Iterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<hash::set::HashSet<A, S> as std::ops::Add>::add":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<A, S> as std::ops::Mul>::mul":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSet<OA, SB> as std::convert::From<&'s hash::set::HashSet<&'a A, SA>>>::from":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<hash::set::HashSetPool<A> as std::clone::Clone>::clone":["fakepool::Pool","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized"],"<hash::set::HashSetPool<A> as std::default::Default>::default":["fakepool::Pool","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized"],"<hash::set::Iter<'a, A> as std::iter::Iterator>::next":["bitmaps::Bits","hash::set::Iter","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<hash::set::Iter<'a, A> as std::iter::Iterator>::size_hint":["bitmaps::Bits","hash::set::Iter","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<hash::set::Value<A> as nodes::hamt::HashValue>::extract_key":["hash::set::Value","std::marker::Sized"],"<hash::set::Value<A> as nodes::hamt::HashValue>::ptr_eq":["hash::set::Value","std::marker::Sized"],"<hash::set::Value<A> as std::clone::Clone>::clone":["hash::set::Value","std::marker::Sized"],"<hash::set::Value<A> as std::cmp::Eq>::assert_receiver_is_total_eq":["hash::set::Value","std::marker::Sized"],"<hash::set::Value<A> as std::cmp::Ord>::cmp":["hash::set::Value","std::cmp::Ordering","std::marker::Sized"],"<hash::set::Value<A> as std::cmp::PartialEq>::eq":["hash::set::Value","std::marker::Sized"],"<hash::set::Value<A> as std::cmp::PartialOrd>::partial_cmp":["hash::set::Value","std::marker::Sized","std::option::Option"],"<hash::set::Value<A> as std::fmt::Debug>::fmt":["hash::set::Value","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<hash::set::Value<A> as std::ops::Deref>::deref":["hash::set::Value","std::marker::Sized"],"<nodes::btree::ConsumingIter<A> as std::iter::DoubleEndedIterator>::next_back":["nodes::btree::ConsumingIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<nodes::btree::ConsumingIter<A> as std::iter::Iterator>::next":["nodes::btree::ConsumingIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<nodes::btree::ConsumingIter<A> as std::iter::Iterator>::size_hint":["nodes::btree::ConsumingIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<nodes::btree::DiffItem<'a, A> as std::cmp::Eq>::assert_receiver_is_total_eq":["nodes::btree::DiffItem","std::marker::Sized"],"<nodes::btree::DiffItem<'a, A> as std::cmp::PartialEq>::eq":["nodes::btree::DiffItem","std::marker::Sized"],"<nodes::btree::DiffItem<'a, A> as std::fmt::Debug>::fmt":["nodes::btree::DiffItem","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<nodes::btree::DiffIter<'a, A> as std::iter::Iterator>::next":["nodes::btree::DiffIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<nodes::btree::Iter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["nodes::btree::Iter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<nodes::btree::Iter<'a, A> as std::iter::Iterator>::next":["nodes::btree::Iter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<nodes::btree::Iter<'a, A> as std::iter::Iterator>::size_hint":["nodes::btree::Iter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<nodes::btree::Node<A> as std::clone::Clone>::clone":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"<nodes::btree::Node<A> as std::default::Default>::default":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"<nodes::hamt::CollisionNode<A> as std::clone::Clone>::clone":["nodes::hamt::CollisionNode","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<nodes::hamt::Drain<A> as std::iter::Iterator>::next":["fakepool::Arc","fakepool::Pool","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<nodes::hamt::Drain<A> as std::iter::Iterator>::size_hint":["fakepool::Arc","fakepool::Pool","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<nodes::hamt::Entry<A> as std::clone::Clone>::clone":["fakepool::Arc","nodes::hamt::Entry","std::marker::Sized","std::sync::Arc"],"<nodes::hamt::Entry<A> as std::convert::From<nodes::hamt::CollisionNode<A>>>::from":["fakepool::Arc","nodes::hamt::CollisionNode","nodes::hamt::Entry","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<nodes::hamt::Iter<'a, A> as std::iter::Iterator>::next":["bitmaps::Bits","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<nodes::hamt::Iter<'a, A> as std::iter::Iterator>::size_hint":["bitmaps::Bits","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<nodes::hamt::IterMut<'a, A> as std::iter::Iterator>::next":["bitmaps::Bits","fakepool::Pool","nodes::hamt::IterMut","sized_chunks::sparse_chunk::IterMut","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<nodes::hamt::IterMut<'a, A> as std::iter::Iterator>::size_hint":["bitmaps::Bits","fakepool::Pool","nodes::hamt::IterMut","sized_chunks::sparse_chunk::IterMut","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<nodes::hamt::Node<A> as std::clone::Clone>::clone":["bitmaps::Bits","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"<nodes::hamt::Node<A> as std::default::Default>::default":["bitmaps::Bits","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"<nodes::hamt::Node<A> as std::fmt::Debug>::fmt":["bitmaps::Bits","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<nodes::rrb::Entry<A> as std::clone::Clone>::clone":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"<nodes::rrb::Node<A> as std::clone::Clone>::clone":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"<nodes::rrb::Node<A> as std::default::Default>::default":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"<nodes::rrb::Size as std::clone::Clone>::clone":["fakepool::Arc","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"<nodes::rrb::Size as std::fmt::Debug>::fmt":["fakepool::Arc","nodes::rrb::Size","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<ord::map::DiffItem<'a, K, V> as std::cmp::Eq>::assert_receiver_is_total_eq":["ord::map::DiffItem","std::marker::Sized"],"<ord::map::DiffItem<'a, K, V> as std::cmp::PartialEq>::eq":["ord::map::DiffItem","std::marker::Sized"],"<ord::map::DiffItem<'a, K, V> as std::fmt::Debug>::fmt":["ord::map::DiffItem","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ord::map::DiffIter<'a, K, V> as std::iter::Iterator>::next":["nodes::btree::DiffIter","ord::map::DiffIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::map::Iter<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["nodes::btree::Iter","ord::map::Iter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::map::Iter<'a, K, V> as std::iter::Iterator>::next":["nodes::btree::Iter","ord::map::Iter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::map::Iter<'a, K, V> as std::iter::Iterator>::size_hint":["nodes::btree::Iter","ord::map::Iter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::map::Keys<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["nodes::btree::Iter","ord::map::Iter","ord::map::Keys","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::map::Keys<'a, K, V> as std::iter::Iterator>::next":["nodes::btree::Iter","ord::map::Iter","ord::map::Keys","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::map::Keys<'a, K, V> as std::iter::Iterator>::size_hint":["nodes::btree::Iter","ord::map::Iter","ord::map::Keys","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::map::OrdMap<K, V> as std::clone::Clone>::clone":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::cmp::Ord>::cmp":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::cmp::PartialEq>::eq":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::cmp::PartialOrd>::partial_cmp":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::convert::AsRef<ord::map::OrdMap<K, V>>>::as_ref":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a [(RK, RV)]>>::from":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a hash::map::HashMap<K, V, S>>>::from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a std::collections::BTreeMap<RK, RV>>>::from":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a std::collections::HashMap<RK, RV>>>::from":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a std::vec::Vec<(RK, RV)>>>::from":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<ord::map::OrdMap<K, V> as std::convert::From<hash::map::HashMap<K, V, S>>>::from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::convert::From<std::collections::BTreeMap<RK, RV>>>::from":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::convert::From<std::collections::HashMap<RK, RV>>>::from":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::convert::From<std::vec::Vec<(RK, RV)>>>::from":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<ord::map::OrdMap<K, V> as std::default::Default>::default":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::fmt::Debug>::fmt":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::hash::Hash>::hash":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::iter::Extend<(RK, RV)>>::extend":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::iter::FromIterator<(RK, RV)>>::from_iter":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::iter::IntoIterator>::into_iter":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::iter::Sum>::sum":["fakepool::Arc","fakepool::Pool","hash::map::ConsumingIter","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","ord::map::OrdMap","ord::map::OrdMapPool","std::alloc::Allocator","std::iter::Iterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<ord::map::OrdMap<K, V> as std::ops::Add>::add":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::ops::Index<&'a BK>>::index":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<K, V> as std::ops::IndexMut<&'a BK>>::index_mut":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMap<OK, OV> as std::convert::From<&'m ord::map::OrdMap<&'k K, &'v V>>>::from":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::map::OrdMapPool<K, V> as std::clone::Clone>::clone":["fakepool::Pool","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized"],"<ord::map::OrdMapPool<K, V> as std::default::Default>::default":["fakepool::Pool","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized"],"<ord::map::Values<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["nodes::btree::Iter","ord::map::Iter","ord::map::Values","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::map::Values<'a, K, V> as std::iter::Iterator>::next":["nodes::btree::Iter","ord::map::Iter","ord::map::Values","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::map::Values<'a, K, V> as std::iter::Iterator>::size_hint":["nodes::btree::Iter","ord::map::Iter","ord::map::Values","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::set::ConsumingIter<A> as std::iter::Iterator>::next":["nodes::btree::ConsumingIter","ord::set::ConsumingIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::set::DiffIter<'a, A> as std::iter::Iterator>::next":["nodes::btree::DiffIter","ord::set::DiffIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::set::Iter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["nodes::btree::Iter","ord::set::Iter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::set::Iter<'a, A> as std::iter::Iterator>::next":["nodes::btree::Iter","ord::set::Iter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::set::Iter<'a, A> as std::iter::Iterator>::size_hint":["nodes::btree::Iter","ord::set::Iter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::set::OrdSet<A> as std::clone::Clone>::clone":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::cmp::Ord>::cmp":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::cmp::PartialEq>::eq":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::cmp::PartialOrd>::partial_cmp":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"<ord::set::OrdSet<A> as std::convert::From<&'a [A]>>::from":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::convert::From<&'a hash::set::HashSet<A, S>>>::from":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::convert::From<&'a std::collections::BTreeSet<A>>>::from":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::convert::From<&'a std::collections::HashSet<A>>>::from":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::convert::From<&'a std::vec::Vec<A>>>::from":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<ord::set::OrdSet<A> as std::convert::From<hash::set::HashSet<A, S>>>::from":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::convert::From<std::collections::BTreeSet<A>>>::from":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::convert::From<std::collections::HashSet<A>>>::from":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::collections::HashSet","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::convert::From<std::vec::Vec<A>>>::from":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<ord::set::OrdSet<A> as std::default::Default>::default":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::fmt::Debug>::fmt":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc"],"<ord::set::OrdSet<A> as std::hash::Hash>::hash":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::iter::Extend<R>>::extend":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::set::OrdSet","ord::set::OrdSetPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::iter::FromIterator<R>>::from_iter":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::set::OrdSet","ord::set::OrdSetPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::iter::IntoIterator>::into_iter":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::iter::Sum>::sum":["fakepool::Arc","fakepool::Pool","hash::map::ConsumingIter","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","ord::set::OrdSet","ord::set::OrdSetPool","std::alloc::Allocator","std::iter::Iterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<ord::set::OrdSet<A> as std::ops::Add>::add":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<A> as std::ops::Mul>::mul":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSet<OA> as std::convert::From<&'s ord::set::OrdSet<&'a A>>>::from":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::OrdSetPool<A> as std::clone::Clone>::clone":["fakepool::Pool","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized"],"<ord::set::OrdSetPool<A> as std::default::Default>::default":["fakepool::Pool","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized"],"<ord::set::RangedIter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["nodes::btree::Iter","ord::set::RangedIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::set::RangedIter<'a, A> as std::iter::Iterator>::next":["nodes::btree::Iter","ord::set::RangedIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::set::RangedIter<'a, A> as std::iter::Iterator>::size_hint":["nodes::btree::Iter","ord::set::RangedIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::cmp_keys":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::set::Value","std::borrow::Borrow","std::cmp::Ord","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::cmp_values":["ord::set::Value","std::cmp::Ordering","std::marker::Sized"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::ptr_eq":["ord::set::Value","std::marker::Sized"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::search_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::set::Value","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::search_value":["ord::set::Value","std::marker::Sized","std::result::Result"],"<ord::set::Value<A> as std::clone::Clone>::clone":["ord::set::Value","std::marker::Sized"],"<ord::set::Value<A> as std::cmp::Eq>::assert_receiver_is_total_eq":["ord::set::Value","std::marker::Sized"],"<ord::set::Value<A> as std::cmp::Ord>::cmp":["ord::set::Value","std::cmp::Ordering","std::marker::Sized"],"<ord::set::Value<A> as std::cmp::PartialEq>::eq":["ord::set::Value","std::marker::Sized"],"<ord::set::Value<A> as std::cmp::PartialOrd>::partial_cmp":["ord::set::Value","std::marker::Sized","std::option::Option"],"<ord::set::Value<A> as std::fmt::Debug>::fmt":["ord::set::Value","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ord::set::Value<A> as std::ops::Deref>::deref":["ord::set::Value","std::marker::Sized"],"<sync::lock::Lock<A> as std::clone::Clone>::clone":["std::marker::Sized","std::sync::Arc","sync::lock::Lock"],"<util::Side as std::clone::Clone>::clone":["util::Side"],"<util::Side as std::cmp::Eq>::assert_receiver_is_total_eq":["util::Side"],"<util::Side as std::cmp::PartialEq>::eq":["util::Side"],"<util::Side as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","util::Side"],"<vector::Chunks<'a, A> as std::iter::DoubleEndedIterator>::next_back":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","vector::Chunks","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"<vector::Chunks<'a, A> as std::iter::Iterator>::next":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","vector::Chunks","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"<vector::ChunksMut<'a, A> as std::iter::DoubleEndedIterator>::next_back":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::ChunksMut","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"<vector::ChunksMut<'a, A> as std::iter::Iterator>::next":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::ChunksMut","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"<vector::ConsumingIter<A> as std::iter::DoubleEndedIterator>::next_back":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::ConsumingIter","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::ConsumingIter<A> as std::iter::Iterator>::next":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::ConsumingIter","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::ConsumingIter<A> as std::iter::Iterator>::size_hint":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::ConsumingIter","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Iter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","vector::Iter","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"<vector::Iter<'a, A> as std::iter::Iterator>::next":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","vector::Iter","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"<vector::Iter<'a, A> as std::iter::Iterator>::size_hint":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","vector::Iter","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"<vector::IterMut<'a, A> as std::iter::DoubleEndedIterator>::next_back":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::IterMut","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"<vector::IterMut<'a, A> as std::iter::Iterator>::next":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::IterMut","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"<vector::IterMut<'a, A> as std::iter::Iterator>::size_hint":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::IterMut","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"<vector::RRB<A> as std::clone::Clone>::clone":["fakepool::Arc","std::marker::Sized","std::sync::Arc","vector::RRB"],"<vector::Vector<A> as std::clone::Clone>::clone":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::cmp::Ord>::cmp":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::cmp::PartialEq>::eq":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::cmp::PartialEq>::eq::cmp_chunk":["fakepool::Arc","std::marker::Sized","std::sync::Arc"],"<vector::Vector<A> as std::cmp::PartialOrd>::partial_cmp":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::convert::From<&'a [A]>>::from":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::convert::From<&'a std::vec::Vec<A>>>::from":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::convert::From<std::vec::Vec<A>>>::from":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::default::Default>::default":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::fmt::Debug>::fmt":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::hash::Hash>::hash":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::iter::Extend<A>>::extend":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","sized_chunks::InlineArray","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::iter::FromIterator<A>>::from_iter":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","sized_chunks::InlineArray","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::iter::IntoIterator>::into_iter":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::iter::Sum>::sum":["fakepool::Arc","fakepool::Pool","hash::map::ConsumingIter","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","sized_chunks::InlineArray","std::alloc::Allocator","std::iter::Iterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::ops::Add>::add":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::ops::Index<usize>>::index":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<A> as std::ops::IndexMut<usize>>::index_mut":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::Vector<OA> as std::convert::From<&'s vector::Vector<&'a A>>>::from":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"<vector::focus::Focus<'a, A> as std::clone::Clone>::clone":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"<vector::focus::Focus<'a, A> as std::iter::IntoIterator>::into_iter":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"<vector::focus::FocusMut<'a, A> as std::convert::Into<vector::focus::Focus<'a, A>>>::into":["fakepool::Arc","fakepool::Pool","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::RRB","vector::focus::Focus","vector::focus::FocusMut","vector::focus::TreeFocus","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"<vector::focus::FocusMut<'a, A> as std::iter::IntoIterator>::into_iter":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"<vector::focus::TreeFocus<A> as std::clone::Clone>::clone":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"<vector::pool::RRBPool<A> as std::clone::Clone>::clone":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","vector::pool::RRBPool"],"<vector::pool::RRBPool<A> as std::default::Default>::default":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","vector::pool::RRBPool"],"fakepool::Arc":["fakepool::Arc","std::marker::Sized","std::sync::Arc"],"fakepool::Arc::<A>::clone_from":["fakepool::Arc","fakepool::Pool","fakepool::PoolClone","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"fakepool::Arc::<A>::default":["fakepool::Arc","fakepool::Pool","fakepool::PoolDefault","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"fakepool::Arc::<A>::make_mut":["fakepool::Arc","fakepool::Pool","fakepool::PoolClone","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"fakepool::Arc::<A>::new":["fakepool::Arc","fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"fakepool::Arc::<A>::ptr_eq":["fakepool::Arc","std::marker::Sized","std::sync::Arc"],"fakepool::Arc::<A>::unwrap_or_clone":["fakepool::Arc","fakepool::PoolClone","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::sync::Arc"],"fakepool::Pool":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized"],"fakepool::Pool::<A>::fill":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized"],"fakepool::Pool::<A>::get_pool_size":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized"],"fakepool::Pool::<A>::new":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized"],"fakepool::Rc":["fakepool::Rc","std::marker::Sized","std::rc::Rc"],"fakepool::Rc::<A>::clone_from":["fakepool::Pool","fakepool::PoolClone","fakepool::Rc","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::rc::Rc"],"fakepool::Rc::<A>::default":["fakepool::Pool","fakepool::PoolDefault","fakepool::Rc","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::rc::Rc"],"fakepool::Rc::<A>::make_mut":["fakepool::Pool","fakepool::PoolClone","fakepool::Rc","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::rc::Rc"],"fakepool::Rc::<A>::new":["fakepool::Pool","fakepool::Rc","std::marker::PhantomData","std::marker::Sized","std::rc::Rc"],"fakepool::Rc::<A>::ptr_eq":["fakepool::Rc","std::marker::Sized","std::rc::Rc"],"fakepool::Rc::<A>::unwrap_or_clone":["fakepool::PoolClone","fakepool::Rc","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::rc::Rc"],"hash::map::<impl nodes::hamt::HashValue for (K, V)>::extract_key":[],"hash::map::<impl nodes::hamt::HashValue for (K, V)>::ptr_eq":[],"hash::map::ConsumingIter":["fakepool::Arc","fakepool::Pool","hash::map::ConsumingIter","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"hash::map::Entry":["fakepool::Arc","fakepool::Pool","hash::map::Entry","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","hash::map::VacantEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::Entry::<'a, K, V, S>::and_modify":["fakepool::Arc","fakepool::Pool","hash::map::Entry","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","hash::map::VacantEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::sync::Arc"],"hash::map::Entry::<'a, K, V, S>::key":["fakepool::Arc","fakepool::Pool","hash::map::Entry","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","hash::map::VacantEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::Entry::<'a, K, V, S>::or_default":["fakepool::Arc","fakepool::Pool","hash::map::Entry","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","hash::map::VacantEntry","std::clone::Clone","std::cmp::Eq","std::default::Default","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::Entry::<'a, K, V, S>::or_insert":["fakepool::Arc","fakepool::Pool","hash::map::Entry","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","hash::map::VacantEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::Entry::<'a, K, V, S>::or_insert_with":["fakepool::Arc","fakepool::Pool","hash::map::Entry","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","hash::map::VacantEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::sync::Arc"],"hash::map::HashMap":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::alter":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::clear":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::contains_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::difference":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::difference_with":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::difference_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::entry":["fakepool::Arc","fakepool::Pool","hash::map::Entry","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","hash::map::VacantEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::extract":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::extract_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::get":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::get_key_value":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::get_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::hasher":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::insert":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::intersection":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::intersection_with":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::intersection_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::is_empty":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::is_proper_submap":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::PartialEq","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::is_proper_submap_by":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::is_submap":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::PartialEq","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::is_submap_by":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::iter":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::Iter","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"hash::map::HashMap::<K, V, S>::iter_mut":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::IterMut","nodes::hamt::IterMut","sized_chunks::sparse_chunk::IterMut","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"hash::map::HashMap::<K, V, S>::keys":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::Keys","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"hash::map::HashMap::<K, V, S>::len":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::new_from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::ptr_eq":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::relative_complement":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::remove":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::remove_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::retain":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::symmetric_difference":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::symmetric_difference_with":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::symmetric_difference_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::test_eq":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::union":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::union_with":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::union_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::unions":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::default::Default","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::unions_with":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::default::Default","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::unions_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::default::Default","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::update":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::update_lookup_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::option::Option","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::update_with":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::update_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::values":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::Values","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"hash::map::HashMap::<K, V, S>::with_hasher":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::convert::From","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V, S>::without":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V>::new":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMap::<K, V>::unit":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::HashMapPool":["fakepool::Pool","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized"],"hash::map::HashMapPool::<K, V>::fill":["fakepool::Pool","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized"],"hash::map::HashMapPool::<K, V>::new":["fakepool::Pool","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized"],"hash::map::HashMapPool::<K, V>::pool_size":["fakepool::Pool","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized"],"hash::map::Iter":["bitmaps::Bits","hash::map::Iter","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"hash::map::IterMut":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","hash::map::IterMut","nodes::hamt::IterMut","sized_chunks::sparse_chunk::IterMut","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"hash::map::Keys":["bitmaps::Bits","hash::map::Keys","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"hash::map::OccupiedEntry":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::OccupiedEntry::<'a, K, V, S>::get":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::OccupiedEntry::<'a, K, V, S>::get_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::OccupiedEntry::<'a, K, V, S>::insert":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::OccupiedEntry::<'a, K, V, S>::into_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::OccupiedEntry::<'a, K, V, S>::key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::OccupiedEntry::<'a, K, V, S>::remove":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::OccupiedEntry::<'a, K, V, S>::remove_entry":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::OccupiedEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::VacantEntry":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::VacantEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::VacantEntry::<'a, K, V, S>::insert":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::VacantEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::VacantEntry::<'a, K, V, S>::into_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::VacantEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::VacantEntry::<'a, K, V, S>::key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::map::VacantEntry","std::clone::Clone","std::cmp::Eq","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::map::Values":["bitmaps::Bits","hash::map::Values","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"hash::set::ConsumingIter":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::set::ConsumingIter","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"hash::set::HashSet":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::clear":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::contains":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::set::HashSet","hash::set::HashSetPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::difference":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::hasher":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::insert":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"hash::set::HashSet::<A, S>::intersection":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::is_empty":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::is_proper_subset":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::is_subset":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::iter":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","hash::set::Iter","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"hash::set::HashSet::<A, S>::len":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::new_from":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::set::HashSet","hash::set::HashSetPool","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::ptr_eq":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::relative_complement":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::remove":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::set::HashSet","hash::set::HashSetPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"hash::set::HashSet::<A, S>::retain":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"hash::set::HashSet::<A, S>::symmetric_difference":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::test_eq":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::union":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::unions":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::set::HashSet","hash::set::HashSetPool","std::default::Default","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::update":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::with_hasher":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::set::HashSet","hash::set::HashSetPool","std::convert::From","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A, S>::without":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","hash::set::HashSet","hash::set::HashSetPool","std::borrow::Borrow","std::cmp::Eq","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A>::new":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSet::<A>::unit":["fakepool::Arc","fakepool::Pool","hash::set::HashSet","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"hash::set::HashSetPool":["fakepool::Pool","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized"],"hash::set::HashSetPool::<A>::fill":["fakepool::Pool","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized"],"hash::set::HashSetPool::<A>::new":["fakepool::Pool","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized"],"hash::set::HashSetPool::<A>::pool_size":["fakepool::Pool","hash::set::HashSetPool","std::marker::PhantomData","std::marker::Sized"],"hash::set::Iter":["bitmaps::Bits","hash::set::Iter","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"hash::set::Value":["hash::set::Value","std::marker::Sized"],"iter::unfold":["std::marker::Sized","std::ops::Fn"],"nodes::btree::BTreeValue::cmp_keys":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Ord","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"nodes::btree::BTreeValue::cmp_values":["std::cmp::Ordering"],"nodes::btree::BTreeValue::ptr_eq":[],"nodes::btree::BTreeValue::search_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc"],"nodes::btree::BTreeValue::search_value":["std::marker::Sized","std::result::Result"],"nodes::btree::ConsumingIter":["nodes::btree::ConsumingIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::btree::ConsumingIter::<A>::new":["nodes::btree::ConsumingIter","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::btree::ConsumingIter::<A>::push":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"nodes::btree::ConsumingIter::<A>::push_back":["nodes::btree::ConsumingIter","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::btree::ConsumingIter::<A>::push_fwd":["nodes::btree::ConsumingIter","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::btree::ConsumingIter::<A>::push_node":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::btree::ConsumingIter::<A>::push_node_back":["nodes::btree::ConsumingIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::btree::ConsumingIterItem":["nodes::btree::ConsumingIterItem","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::btree::DiffItem":["nodes::btree::DiffItem","std::marker::Sized"],"nodes::btree::DiffIter":["nodes::btree::DiffIter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"nodes::btree::DiffIter::<'a, A>::new":["nodes::btree::DiffIter","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"nodes::btree::DiffIter::<'a, A>::push":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"nodes::btree::DiffIter::<'a, A>::push_node":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::btree::Insert":["nodes::btree::Insert","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::btree::InsertAction":["nodes::btree::InsertAction","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::btree::Iter":["nodes::btree::Iter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"nodes::btree::Iter::<'a, A>::get":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::option::Option"],"nodes::btree::Iter::<'a, A>::new":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Iter","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::sync::Arc","std::vec::Vec"],"nodes::btree::Iter::<'a, A>::step_back":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::btree::Iter::<'a, A>::step_forward":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::btree::IterItem":["nodes::btree::IterItem","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::btree::Node":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::btree::Node::<A>::child_contains":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"nodes::btree::Node::<A>::has_room":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::btree::Node::<A>::insert":["fakepool::Arc","fakepool::Pool","nodes::btree::Insert","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"nodes::btree::Node::<A>::is_leaf":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::btree::Node::<A>::lookup":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"nodes::btree::Node::<A>::lookup_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"nodes::btree::Node::<A>::lookup_next":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"nodes::btree::Node::<A>::lookup_next_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"nodes::btree::Node::<A>::lookup_prev":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"nodes::btree::Node::<A>::lookup_prev_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"nodes::btree::Node::<A>::max":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::option::Option"],"nodes::btree::Node::<A>::merge":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::btree::Node::<A>::min":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::option::Option"],"nodes::btree::Node::<A>::new_from_split":["fakepool::Pool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized"],"nodes::btree::Node::<A>::path_first":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"nodes::btree::Node::<A>::path_last":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"nodes::btree::Node::<A>::path_next":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"nodes::btree::Node::<A>::path_prev":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"nodes::btree::Node::<A>::pop_max":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::option::Option"],"nodes::btree::Node::<A>::pop_min":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::option::Option"],"nodes::btree::Node::<A>::push_max":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::option::Option"],"nodes::btree::Node::<A>::push_min":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::option::Option"],"nodes::btree::Node::<A>::remove":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","nodes::btree::Remove","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"nodes::btree::Node::<A>::remove_index":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Node","nodes::btree::Remove","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc"],"nodes::btree::Node::<A>::split":["fakepool::Pool","nodes::btree::Insert","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::option::Option"],"nodes::btree::Node::<A>::too_small":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::btree::Node::<A>::unit":["nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::btree::Remove":["nodes::btree::Node","nodes::btree::Remove","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::btree::RemoveAction":["nodes::btree::RemoveAction"],"nodes::hamt::CollisionNode":["nodes::hamt::CollisionNode","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"nodes::hamt::CollisionNode::<A>::get":["fakepool::Arc","nodes::hamt::CollisionNode","std::alloc::Allocator","std::borrow::Borrow","std::cmp::Eq","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"nodes::hamt::CollisionNode::<A>::get_mut":["fakepool::Arc","nodes::hamt::CollisionNode","std::alloc::Allocator","std::borrow::Borrow","std::cmp::Eq","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"nodes::hamt::CollisionNode::<A>::insert":["nodes::hamt::CollisionNode","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::hamt::CollisionNode::<A>::len":["nodes::hamt::CollisionNode","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"nodes::hamt::CollisionNode::<A>::new":["nodes::hamt::CollisionNode","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"nodes::hamt::CollisionNode::<A>::pop":["fakepool::Arc","nodes::hamt::CollisionNode","nodes::hamt::Entry","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"nodes::hamt::CollisionNode::<A>::remove":["fakepool::Arc","nodes::hamt::CollisionNode","std::alloc::Allocator","std::borrow::Borrow","std::cmp::Eq","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"nodes::hamt::Drain":["fakepool::Arc","fakepool::Pool","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"nodes::hamt::Drain::<A>::new":["fakepool::Arc","fakepool::Pool","hash::set::Value","nodes::hamt::Drain","nodes::hamt::HashValue","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"nodes::hamt::Entry":["fakepool::Arc","nodes::hamt::Entry","std::marker::Sized","std::sync::Arc"],"nodes::hamt::Entry::<A>::from_node":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","nodes::hamt::Entry","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"nodes::hamt::Entry::<A>::is_value":["fakepool::Arc","nodes::hamt::Entry","std::marker::Sized","std::sync::Arc"],"nodes::hamt::Entry::<A>::unwrap_value":["fakepool::Arc","nodes::hamt::Entry","std::marker::Sized","std::sync::Arc"],"nodes::hamt::HashValue::extract_key":[],"nodes::hamt::HashValue::ptr_eq":[],"nodes::hamt::Iter":["bitmaps::Bits","nodes::hamt::Iter","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::hamt::Iter::<'a, A>::new":["bitmaps::Bits","nodes::hamt::Iter","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::sparse_chunk::Iter","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::hamt::IterMut":["bitmaps::Bits","fakepool::Pool","nodes::hamt::IterMut","sized_chunks::sparse_chunk::IterMut","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::hamt::IterMut::<'a, A>::new":["bitmaps::Bits","fakepool::Pool","nodes::hamt::IterMut","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::sparse_chunk::IterMut","sized_chunks::types::ChunkLength","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"nodes::hamt::Node":["bitmaps::Bits","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::hamt::Node::<A>::get":["bitmaps::Bits","fakepool::Arc","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::cmp::Eq","std::marker::Sized","std::option::Option","std::sync::Arc"],"nodes::hamt::Node::<A>::get_mut":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"nodes::hamt::Node::<A>::insert":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"nodes::hamt::Node::<A>::len":["bitmaps::Bits","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::hamt::Node::<A>::merge_values":["bitmaps::Bits","fakepool::Pool","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized"],"nodes::hamt::Node::<A>::new":["bitmaps::Bits","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::marker::Sized"],"nodes::hamt::Node::<A>::pair":["bitmaps::Bits","fakepool::Arc","nodes::hamt::Entry","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::sync::Arc"],"nodes::hamt::Node::<A>::pop":["bitmaps::Bits","fakepool::Arc","nodes::hamt::Entry","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::sync::Arc"],"nodes::hamt::Node::<A>::remove":["bitmaps::Bits","fakepool::Arc","fakepool::Pool","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"nodes::hamt::Node::<A>::single_child":["bitmaps::Bits","fakepool::Pool","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized"],"nodes::hamt::Node::<A>::unit":["bitmaps::Bits","fakepool::Arc","nodes::hamt::Entry","nodes::hamt::Node","sized_chunks::SparseChunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::sync::Arc"],"nodes::hamt::hash_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::hash::BuildHasher","std::hash::Hash","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"nodes::hamt::mask":[],"nodes::rrb::Entry":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Entry::<A>::is_empty_node":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Entry::<A>::is_full":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Entry::<A>::len":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Entry::<A>::nodes":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Size","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Entry::<A>::unwrap_nodes":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Size","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Entry::<A>::unwrap_nodes_mut":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Size","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Entry::<A>::unwrap_values":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Size","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Entry::<A>::unwrap_values_mut":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Size","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Entry::<A>::values":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Size","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::clear_node":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::elevate":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::first_child":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::from_chunk":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::index":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::index_in":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::option::Option","std::sync::Arc"],"nodes::rrb::Node::<A>::index_mut":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::is_completely_dense":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::is_dense":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::is_empty":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::is_full":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::is_single":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::join_branches":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::join_dense":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::len":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::lookup_chunk":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc"],"nodes::rrb::Node::<A>::lookup_chunk_mut":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::merge":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::merge_leaves":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::merge_rebalance":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::new":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::number_of_children":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::parent":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::pop_child_node":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","util::Side","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::pop_chunk":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::PopResult","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","util::Side","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::pop_size":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","util::Side","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::push_child_node":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","util::Side","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::push_chunk":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::PushResult","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","util::Side","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::push_size":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","util::Side","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::single_parent":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::size":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::size_up_to":["fakepool::Arc","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Node::<A>::split":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","nodes::rrb::SplitResult","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","util::Side","vector::pool::RRBPool"],"nodes::rrb::Node::<A>::update_size":["fakepool::Arc","fakepool::Pool","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::pool::RRBPool"],"nodes::rrb::PopResult":["nodes::rrb::PopResult","std::marker::Sized"],"nodes::rrb::PushResult":["nodes::rrb::PushResult","std::marker::Sized"],"nodes::rrb::Size":["fakepool::Arc","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Size::is_size":["fakepool::Arc","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Size::pop":["fakepool::Arc","fakepool::Pool","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","util::Side"],"nodes::rrb::Size::push":["fakepool::Arc","fakepool::Pool","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","util::Side"],"nodes::rrb::Size::size":["fakepool::Arc","nodes::rrb::Size","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Size::table_from_size":["fakepool::Arc","fakepool::Pool","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"nodes::rrb::Size::update":["fakepool::Arc","fakepool::Pool","nodes::rrb::Size","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"nodes::rrb::SplitResult":["nodes::rrb::SplitResult"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::cmp_keys":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Ord","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::cmp_values":["std::cmp::Ordering"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::ptr_eq":[],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::search_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::search_value":["std::marker::Sized","std::result::Result"],"ord::map::DiffItem":["ord::map::DiffItem","std::marker::Sized"],"ord::map::DiffIter":["nodes::btree::DiffIter","ord::map::DiffIter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ord::map::Entry":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::Entry","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::VacantEntry","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::Entry::<'a, K, V>::and_modify":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::Entry","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::VacantEntry","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::sync::Arc"],"ord::map::Entry::<'a, K, V>::key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::Entry","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::VacantEntry","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::Entry::<'a, K, V>::or_default":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::Entry","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::VacantEntry","std::clone::Clone","std::cmp::Ord","std::default::Default","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::Entry::<'a, K, V>::or_insert":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::Entry","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::VacantEntry","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::Entry::<'a, K, V>::or_insert_with":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::Entry","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::VacantEntry","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::sync::Arc"],"ord::map::Iter":["nodes::btree::Iter","ord::map::Iter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ord::map::Keys":["nodes::btree::Iter","ord::map::Iter","ord::map::Keys","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ord::map::OccupiedEntry":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OccupiedEntry::<'a, K, V>::get":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OccupiedEntry::<'a, K, V>::get_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OccupiedEntry::<'a, K, V>::insert":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OccupiedEntry::<'a, K, V>::into_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OccupiedEntry::<'a, K, V>::key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OccupiedEntry::<'a, K, V>::remove":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OccupiedEntry::<'a, K, V>::remove_entry":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::alter":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::sync::Arc"],"ord::map::OrdMap::<K, V>::clear":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::contains_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::diff":["fakepool::Arc","fakepool::Pool","nodes::btree::DiffIter","ord::map::DiffIter","ord::map::OrdMap","ord::map::OrdMapPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"ord::map::OrdMap::<K, V>::difference":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::difference_with":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"ord::map::OrdMap::<K, V>::difference_with_key":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"ord::map::OrdMap::<K, V>::entry":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::Entry","ord::map::OccupiedEntry","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::VacantEntry","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::extract":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::extract_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::get":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::get_key_value":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::get_max":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::get_min":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::get_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::get_next":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::get_next_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::get_prev":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::get_prev_mut":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::insert":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::intersection":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::intersection_with":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"ord::map::OrdMap::<K, V>::intersection_with_key":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"ord::map::OrdMap::<K, V>::is_empty":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::is_proper_submap":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::PartialEq","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::is_proper_submap_by":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"ord::map::OrdMap::<K, V>::is_submap":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::PartialEq","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::is_submap_by":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"ord::map::OrdMap::<K, V>::iter":["fakepool::Arc","fakepool::Pool","nodes::btree::Iter","ord::map::Iter","ord::map::OrdMap","ord::map::OrdMapPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"ord::map::OrdMap::<K, V>::keys":["fakepool::Arc","fakepool::Pool","nodes::btree::Iter","ord::map::Iter","ord::map::Keys","ord::map::OrdMap","ord::map::OrdMapPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"ord::map::OrdMap::<K, V>::len":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::new":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::ptr_eq":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::range":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Iter","ord::map::Iter","ord::map::OrdMap","ord::map::OrdMapPool","std::alloc::Allocator","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::sync::Arc","std::vec::Vec"],"ord::map::OrdMap::<K, V>::relative_complement":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::remove":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::remove_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::skip":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::split":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::split_lookup":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::symmetric_difference":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::symmetric_difference_with":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"ord::map::OrdMap::<K, V>::symmetric_difference_with_key":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"ord::map::OrdMap::<K, V>::take":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::union":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::union_with":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"ord::map::OrdMap::<K, V>::union_with_key":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc"],"ord::map::OrdMap::<K, V>::unions":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::unions_with":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::sync::Arc"],"ord::map::OrdMap::<K, V>::unions_with_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::sync::Arc"],"ord::map::OrdMap::<K, V>::unit":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::update":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::update_lookup_with_key":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::update_with":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::sync::Arc"],"ord::map::OrdMap::<K, V>::update_with_key":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::FnOnce","std::sync::Arc"],"ord::map::OrdMap::<K, V>::values":["fakepool::Arc","fakepool::Pool","nodes::btree::Iter","ord::map::Iter","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::Values","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"ord::map::OrdMap::<K, V>::without":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::OrdMap::<K, V>::without_max":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::without_max_with_key":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::without_min":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMap::<K, V>::without_min_with_key":["fakepool::Arc","fakepool::Pool","ord::map::OrdMap","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::map::OrdMapPool":["fakepool::Pool","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized"],"ord::map::OrdMapPool::<K, V>::fill":["fakepool::Pool","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized"],"ord::map::OrdMapPool::<K, V>::new":["fakepool::Pool","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized"],"ord::map::OrdMapPool::<K, V>::pool_size":["fakepool::Pool","ord::map::OrdMapPool","std::marker::PhantomData","std::marker::Sized"],"ord::map::VacantEntry":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::VacantEntry","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::VacantEntry::<'a, K, V>::insert":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::VacantEntry","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::VacantEntry::<'a, K, V>::into_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::VacantEntry","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::VacantEntry::<'a, K, V>::key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::map::OrdMap","ord::map::OrdMapPool","ord::map::VacantEntry","std::clone::Clone","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::map::Values":["nodes::btree::Iter","ord::map::Iter","ord::map::Values","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ord::set::ConsumingIter":["nodes::btree::ConsumingIter","ord::set::ConsumingIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"ord::set::DiffIter":["nodes::btree::DiffIter","ord::set::DiffIter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ord::set::Iter":["nodes::btree::Iter","ord::set::Iter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ord::set::OrdSet":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::clear":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::contains":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::set::OrdSet","ord::set::OrdSetPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::diff":["fakepool::Arc","fakepool::Pool","nodes::btree::DiffIter","ord::set::DiffIter","ord::set::OrdSet","ord::set::OrdSetPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"ord::set::OrdSet::<A>::difference":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::get_max":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::set::OrdSet::<A>::get_min":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::set::OrdSet::<A>::get_next":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::set::OrdSet::<A>::get_prev":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::set::OrdSet::<A>::insert":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::set::OrdSet::<A>::intersection":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::is_empty":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::is_proper_subset":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::is_subset":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::iter":["fakepool::Arc","fakepool::Pool","nodes::btree::Iter","ord::set::Iter","ord::set::OrdSet","ord::set::OrdSetPool","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"ord::set::OrdSet::<A>::len":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::new":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::ptr_eq":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::range":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","nodes::btree::Iter","ord::set::OrdSet","ord::set::OrdSetPool","ord::set::RangedIter","std::alloc::Allocator","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::sync::Arc","std::vec::Vec"],"ord::set::OrdSet::<A>::relative_complement":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::remove":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::set::OrdSet","ord::set::OrdSetPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::set::OrdSet::<A>::remove_max":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::set::OrdSet::<A>::remove_min":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::set::OrdSet::<A>::skip":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::split":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::set::OrdSet","ord::set::OrdSetPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::split_member":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::set::OrdSet","ord::set::OrdSetPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::symmetric_difference":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::take":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::union":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::unions":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::set::OrdSet","ord::set::OrdSetPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::unit":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::update":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::without":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","ord::set::OrdSet","ord::set::OrdSetPool","std::borrow::Borrow","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"],"ord::set::OrdSet::<A>::without_max":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::set::OrdSet::<A>::without_min":["fakepool::Arc","fakepool::Pool","ord::set::OrdSet","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc"],"ord::set::OrdSetPool":["fakepool::Pool","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized"],"ord::set::OrdSetPool::<A>::fill":["fakepool::Pool","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized"],"ord::set::OrdSetPool::<A>::new":["fakepool::Pool","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized"],"ord::set::OrdSetPool::<A>::pool_size":["fakepool::Pool","ord::set::OrdSetPool","std::marker::PhantomData","std::marker::Sized"],"ord::set::RangedIter":["nodes::btree::Iter","ord::set::RangedIter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"ord::set::Value":["ord::set::Value","std::marker::Sized"],"sort::do_quicksort":["fakepool::Arc","fakepool::Pool","rand_core::RngCore","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"sort::gen_range":["rand_core::RngCore","std::marker::Sized"],"sort::quicksort":["fakepool::Arc","fakepool::Pool","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"sync::lock::Lock":["std::marker::Sized","std::sync::Arc","sync::lock::Lock"],"sync::lock::Lock::<A>::lock":["std::marker::Sized","std::option::Option","std::sync::Arc","sync::lock::Lock"],"sync::lock::Lock::<A>::new":["std::marker::Sized","std::sync::Arc","sync::lock::Lock"],"util::Side":["util::Side"],"util::clone_ref":["fakepool::Arc","std::clone::Clone","std::marker::Sized","std::sync::Arc"],"util::linear_search_by":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::result::Result","std::sync::Arc"],"util::swap_indices":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::marker::PhantomData","std::marker::Sized","std::ops::IndexMut","std::sync::Arc"],"util::to_range":["std::marker::Sized","std::ops::Range","std::ops::RangeBounds"],"vector::Chunks":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::Chunks","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"vector::Chunks::<'a, A>::new":["fakepool::Arc","fakepool::Pool","sized_chunks::Chunk","sized_chunks::InlineArray","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::Chunks","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::Focus","vector::focus::TreeFocus","vector::pool::RRBPool"],"vector::ChunksMut":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::ChunksMut","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::ChunksMut::<'a, A>::new":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::ChunksMut","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::ConsumingIter":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::ConsumingIter","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::ConsumingIter::<A>::new":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::ConsumingIter","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Iter":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::Iter","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"vector::Iter::<'a, A>::from_focus":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::Iter","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"vector::Iter::<'a, A>::new":["fakepool::Arc","fakepool::Pool","sized_chunks::Chunk","sized_chunks::InlineArray","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::Iter","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::Focus","vector::focus::TreeFocus","vector::pool::RRBPool"],"vector::IterMut":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::IterMut","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::IterMut::<'a, A>::from_focus":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::IterMut","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::IterMut::<'a, A>::new":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::IterMut","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::RRB":["fakepool::Arc","std::marker::Sized","std::sync::Arc","vector::RRB"],"vector::RRB::<A>::new":["fakepool::Arc","fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::pool::RRBPool"],"vector::RRB::<A>::pop_back":["fakepool::Arc","fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::pool::RRBPool"],"vector::RRB::<A>::pop_front":["fakepool::Arc","fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::pool::RRBPool"],"vector::RRB::<A>::pop_middle":["fakepool::Arc","fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","util::Side","vector::RRB","vector::pool::RRBPool"],"vector::RRB::<A>::prune":["fakepool::Arc","std::marker::Sized","std::sync::Arc","vector::RRB"],"vector::RRB::<A>::push_back":["fakepool::Arc","fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::pool::RRBPool"],"vector::RRB::<A>::push_front":["fakepool::Arc","fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::pool::RRBPool"],"vector::RRB::<A>::push_middle":["fakepool::Arc","fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","util::Side","vector::RRB","vector::pool::RRBPool"],"vector::Vector":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::append":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::back":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::back_mut":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::binary_search":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","sized_chunks::InlineArray","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::binary_search_by":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::result::Result","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::binary_search_by_key":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","sized_chunks::InlineArray","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::result::Result","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::clear":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::contains":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::cmp::PartialEq","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::focus":["fakepool::Arc","fakepool::Pool","sized_chunks::Chunk","sized_chunks::InlineArray","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::Focus","vector::focus::TreeFocus","vector::pool::RRBPool"],"vector::Vector::<A>::focus_mut":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::Vector::<A>::front":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::front_mut":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::get":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::get_mut":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::head":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::index_of":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::cmp::PartialEq","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::insert":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::insert_ord":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","sized_chunks::InlineArray","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::is_empty":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::is_inline":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::iter":["fakepool::Arc","fakepool::Pool","sized_chunks::Chunk","sized_chunks::InlineArray","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::Iter","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::Focus","vector::focus::TreeFocus","vector::pool::RRBPool"],"vector::Vector::<A>::iter_mut":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::IterMut","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::Vector::<A>::last":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::leaves":["fakepool::Arc","fakepool::Pool","sized_chunks::Chunk","sized_chunks::InlineArray","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::Chunks","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::Focus","vector::focus::TreeFocus","vector::pool::RRBPool"],"vector::Vector::<A>::leaves_mut":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::ChunksMut","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::Vector::<A>::len":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::needs_promotion":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::new":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::pool":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::pop_back":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::pop_front":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::promote_back":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::promote_front":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::promote_inline":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::ptr_eq":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::ptr_eq::cmp_chunk":["fakepool::Arc","std::marker::Sized","std::sync::Arc"],"vector::Vector::<A>::push_back":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::push_front":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::remove":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::retain":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::set":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::skip":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::slice":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::ops::RangeBounds","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::sort":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","sized_chunks::InlineArray","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::sort_by":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::ops::Fn","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::split_at":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::split_off":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::swap":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::take":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::truncate":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::unit":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::Vector::<A>::update":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::pool::RRBPool"],"vector::VectorInner":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::sync::Arc","vector::RRB","vector::VectorInner","vector::pool::RRBPool"],"vector::focus::Focus":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"vector::focus::Focus::<'a, A>::chunk_at":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"vector::focus::Focus::<'a, A>::get":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"vector::focus::Focus::<'a, A>::index":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"vector::focus::Focus::<'a, A>::is_empty":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"vector::focus::Focus::<'a, A>::len":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"vector::focus::Focus::<'a, A>::narrow":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::ops::RangeBounds","std::sync::Arc","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"vector::focus::Focus::<'a, A>::new":["fakepool::Arc","fakepool::Pool","sized_chunks::Chunk","sized_chunks::InlineArray","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::Focus","vector::focus::TreeFocus","vector::pool::RRBPool"],"vector::focus::Focus::<'a, A>::split_at":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::Focus","vector::focus::TreeFocus"],"vector::focus::FocusMut":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::chunk_at":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::get":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::get_mut":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::index":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::index_mut":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::is_empty":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::len":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::narrow":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::ops::RangeBounds","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::new":["fakepool::Arc","fakepool::Pool","sized_chunks::InlineArray","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::RRB","vector::Vector","vector::VectorInner","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::pair":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::set":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::split_at":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::swap":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::triplet":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::FnMut","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::FocusMut","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::FocusMut::<'a, A>::unmut":["fakepool::Arc","fakepool::Pool","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::RRB","vector::focus::Focus","vector::focus::FocusMut","vector::focus::TreeFocus","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::TreeFocus":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"vector::focus::TreeFocus::<A>::get":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"vector::focus::TreeFocus::<A>::get_chunk":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"vector::focus::TreeFocus::<A>::get_focus":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"vector::focus::TreeFocus::<A>::len":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"vector::focus::TreeFocus::<A>::logical_range":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"vector::focus::TreeFocus::<A>::narrow":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"vector::focus::TreeFocus::<A>::new":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"vector::focus::TreeFocus::<A>::physical_index":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"vector::focus::TreeFocus::<A>::set_focus":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"vector::focus::TreeFocus::<A>::split_at":["fakepool::Arc","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","vector::RRB","vector::focus::TreeFocus"],"vector::focus::TreeFocusMut":["std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::TreeFocusMut"],"vector::focus::TreeFocusMut::<'a, A>::get":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::option::Option","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::TreeFocusMut::<'a, A>::get_chunk":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::TreeFocusMut::<'a, A>::get_focus":["sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::TreeFocusMut"],"vector::focus::TreeFocusMut::<'a, A>::len":["std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::TreeFocusMut"],"vector::focus::TreeFocusMut::<'a, A>::logical_range":["std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::TreeFocusMut"],"vector::focus::TreeFocusMut::<'a, A>::narrow":["std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::TreeFocusMut"],"vector::focus::TreeFocusMut::<'a, A>::new":["fakepool::Arc","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::RRB","vector::focus::TreeFocusMut"],"vector::focus::TreeFocusMut::<'a, A>::physical_index":["std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::TreeFocusMut"],"vector::focus::TreeFocusMut::<'a, A>::set_focus":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::TreeFocusMut","vector::pool::RRBPool"],"vector::focus::TreeFocusMut::<'a, A>::split_at":["std::marker::Sized","std::ops::Range","std::sync::Arc","std::sync::atomic::AtomicPtr","sync::lock::Lock","vector::focus::TreeFocusMut"],"vector::focus::contains":["fakepool::Arc","fakepool::Pool","hash::map::HashMap","hash::map::HashMapPool","std::cmp::Ord","std::marker::PhantomData","std::marker::Sized","std::ops::Range","std::sync::Arc"],"vector::pool::RRBPool":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","vector::pool::RRBPool"],"vector::pool::RRBPool::<A>::fill":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","vector::pool::RRBPool"],"vector::pool::RRBPool::<A>::leaf_pool_size":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","vector::pool::RRBPool"],"vector::pool::RRBPool::<A>::new":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","vector::pool::RRBPool"],"vector::pool::RRBPool::<A>::node_pool_size":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","vector::pool::RRBPool"],"vector::pool::RRBPool::<A>::size_table_pool_size":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","vector::pool::RRBPool"],"vector::pool::RRBPool::<A>::with_sizes":["fakepool::Pool","std::marker::PhantomData","std::marker::Sized","vector::pool::RRBPool"],"vector::replace_pool_def":["fakepool::Arc","fakepool::Pool","fakepool::PoolDefault","nodes::btree::Node","sized_chunks::Chunk","sized_chunks::types::ChunkLength","std::marker::PhantomData","std::marker::Sized","std::sync::Arc"]},"glob_path_import":{},"self_to_fn":{"fakepool::Arc":["Default","impl<A> Arc<A> {\n    #[inline(always)]\n    pub(crate) fn default(_pool: &Pool<A>) -> Self\n    where\n        A: PoolDefault,\n    {\n        Self(Default::default())\n    }\n\n    #[inline(always)]\n    pub(crate) fn new(_pool: &Pool<A>, value: A) -> Self {\n        Self(RArc::new(value))\n    }\n\n    #[inline(always)]\n    pub(crate) fn clone_from(_pool: &Pool<A>, value: &A) -> Self\n    where\n        A: PoolClone,\n    {\n        Self(RArc::new(value.clone()))\n    }\n\n    #[inline(always)]\n    pub(crate) fn make_mut<'a>(_pool: &Pool<A>, this: &'a mut Self) -> &'a mut A\n    where\n        A: PoolClone,\n    {\n        RArc::make_mut(&mut this.0)\n    }\n\n    #[inline(always)]\n    pub(crate) fn ptr_eq(left: &Self, right: &Self) -> bool {\n        RArc::ptr_eq(&left.0, &right.0)\n    }\n\n    pub(crate) fn unwrap_or_clone(this: Self) -> A\n    where\n        A: PoolClone,\n    {\n        RArc::try_unwrap(this.0).unwrap_or_else(|r| (*r).clone())\n    }\n}","impl<A> Clone for Arc<A> {\n    #[inline(always)]\n    fn clone(&self) -> Self {\n        Self(self.0.clone())\n    }\n}","impl<A> Deref for Arc<A> {\n    type Target = A;\n    #[inline(always)]\n    fn deref(&self) -> &Self::Target {\n        self.0.deref()\n    }\n}","impl<A> Eq for Arc<A> where A: Eq {}","impl<A> PartialEq for Arc<A>\nwhere\n    A: PartialEq,\n{\n    #[inline(always)]\n    fn eq(&self, other: &Self) -> bool {\n        **self == **other\n    }\n}","impl<A> std::fmt::Debug for Arc<A>\nwhere\n    A: std::fmt::Debug,\n{\n    #[inline(always)]\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n        self.0.fmt(f)\n    }\n}"],"fakepool::Pool":["impl<A> Clone for Pool<A> {\n    fn clone(&self) -> Self {\n        Self::new(0)\n    }\n}","impl<A> Pool<A> {\n    pub(crate) fn new(_size: usize) -> Self {\n        Pool(PhantomData)\n    }\n\n    pub(crate) fn get_pool_size(&self) -> usize {\n        0\n    }\n\n    pub(crate) fn fill(&self) {}\n}"],"fakepool::Rc":["Default","impl<A> Clone for Rc<A> {\n    #[inline(always)]\n    fn clone(&self) -> Self {\n        Rc(self.0.clone())\n    }\n}","impl<A> Deref for Rc<A> {\n    type Target = A;\n    #[inline(always)]\n    fn deref(&self) -> &Self::Target {\n        self.0.deref()\n    }\n}","impl<A> Eq for Rc<A> where A: Eq {}","impl<A> PartialEq for Rc<A>\nwhere\n    A: PartialEq,\n{\n    #[inline(always)]\n    fn eq(&self, other: &Self) -> bool {\n        **self == **other\n    }\n}","impl<A> Rc<A> {\n    #[inline(always)]\n    pub(crate) fn default(_pool: &Pool<A>) -> Self\n    where\n        A: PoolDefault,\n    {\n        Self(Default::default())\n    }\n\n    #[inline(always)]\n    pub(crate) fn new(_pool: &Pool<A>, value: A) -> Self {\n        Rc(RRc::new(value))\n    }\n\n    #[inline(always)]\n    pub(crate) fn clone_from(_pool: &Pool<A>, value: &A) -> Self\n    where\n        A: PoolClone,\n    {\n        Rc(RRc::new(value.clone()))\n    }\n\n    #[inline(always)]\n    pub(crate) fn make_mut<'a>(_pool: &Pool<A>, this: &'a mut Self) -> &'a mut A\n    where\n        A: PoolClone,\n    {\n        RRc::make_mut(&mut this.0)\n    }\n\n    #[inline(always)]\n    pub(crate) fn ptr_eq(left: &Self, right: &Self) -> bool {\n        RRc::ptr_eq(&left.0, &right.0)\n    }\n\n    pub(crate) fn unwrap_or_clone(this: Self) -> A\n    where\n        A: PoolClone,\n    {\n        RRc::try_unwrap(this.0).unwrap_or_else(|r| (*r).clone())\n    }\n}","impl<A> std::fmt::Debug for Rc<A>\nwhere\n    A: std::fmt::Debug,\n{\n    #[inline(always)]\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n        self.0.fmt(f)\n    }\n}"],"hash::map::ConsumingIter":["impl<A> ExactSizeIterator for ConsumingIter<A> where A: HashValue + Clone {}","impl<A> FusedIterator for ConsumingIter<A> where A: HashValue + Clone {}","impl<A> Iterator for ConsumingIter<A>\nwhere\n    A: HashValue + Clone,\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|(p, _)| p)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n}"],"hash::map::Entry":["impl<'a, K, V, S> Entry<'a, K, V, S>\nwhere\n    K: 'a + Hash + Eq + Clone,\n    V: 'a + Clone,\n    S: 'a + BuildHasher,\n{\n    /// Insert the default value provided if there was no value\n    /// already, and return a mutable reference to the value.\n    pub fn or_insert(self, default: V) -> &'a mut V {\n        self.or_insert_with(|| default)\n    }\n\n    /// Insert the default value from the provided function if there\n    /// was no value already, and return a mutable reference to the\n    /// value.\n    pub fn or_insert_with<F>(self, default: F) -> &'a mut V\n    where\n        F: FnOnce() -> V,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default()),\n        }\n    }\n\n    /// Insert a default value if there was no value already, and\n    /// return a mutable reference to the value.\n    pub fn or_default(self) -> &'a mut V\n    where\n        V: Default,\n    {\n        self.or_insert_with(Default::default)\n    }\n\n    /// Get the key for this entry.\n    #[must_use]\n    pub fn key(&self) -> &K {\n        match self {\n            Entry::Occupied(entry) => entry.key(),\n            Entry::Vacant(entry) => entry.key(),\n        }\n    }\n\n    /// Call the provided function to modify the value if the value\n    /// exists.\n    pub fn and_modify<F>(mut self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n        match &mut self {\n            Entry::Occupied(ref mut entry) => f(entry.get_mut()),\n            Entry::Vacant(_) => (),\n        }\n        self\n    }\n}"],"hash::map::HashMap":["impl<'a, BK, K, V, S> Index<&'a BK> for HashMap<K, V, S>\nwhere\n    BK: Hash + Eq + ?Sized,\n    K: Hash + Eq + Borrow<BK>,\n    S: BuildHasher,\n{\n    type Output = V;\n\n    fn index(&self, key: &BK) -> &Self::Output {\n        match self.root.get(hash_key(&*self.hasher, key), 0, key) {\n            None => panic!(\"HashMap::index: invalid key\"),\n            Some(&(_, ref value)) => value,\n        }\n    }\n}","impl<'a, BK, K, V, S> IndexMut<&'a BK> for HashMap<K, V, S>\nwhere\n    BK: Hash + Eq + ?Sized,\n    K: Hash + Eq + Clone + Borrow<BK>,\n    V: Clone,\n    S: BuildHasher,\n{\n    fn index_mut(&mut self, key: &BK) -> &mut Self::Output {\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        match root.get_mut(&self.pool.0, hash_key(&*self.hasher, key), 0, key) {\n            None => panic!(\"HashMap::index_mut: invalid key\"),\n            Some(&mut (_, ref mut value)) => value,\n        }\n    }\n}","impl<'a, K, V, S> From<&'a Vec<(K, V)>> for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher + Default,\n{\n    fn from(m: &'a Vec<(K, V)>) -> Self {\n        m.iter().cloned().collect()\n    }\n}","impl<'a, K, V, S> From<&'a [(K, V)]> for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher + Default,\n{\n    fn from(m: &'a [(K, V)]) -> Self {\n        m.iter().cloned().collect()\n    }\n}","impl<'a, K, V, S> From<&'a collections::BTreeMap<K, V>> for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher + Default,\n{\n    fn from(m: &'a collections::BTreeMap<K, V>) -> Self {\n        m.iter().map(|(k, v)| (k.clone(), v.clone())).collect()\n    }\n}","impl<'a, K, V, S> From<&'a collections::HashMap<K, V>> for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher + Default,\n{\n    fn from(m: &'a collections::HashMap<K, V>) -> Self {\n        m.iter().map(|(k, v)| (k.clone(), v.clone())).collect()\n    }\n}","impl<'m, 'k, 'v, K, V, OK, OV, SA, SB> From<&'m HashMap<&'k K, &'v V, SA>> for HashMap<OK, OV, SB>\nwhere\n    K: Hash + Eq + ToOwned<Owned = OK> + ?Sized,\n    V: ToOwned<Owned = OV> + ?Sized,\n    OK: Hash + Eq + Clone + Borrow<K>,\n    OV: Borrow<V> + Clone,\n    SA: BuildHasher,\n    SB: BuildHasher + Default,\n{\n    fn from(m: &HashMap<&K, &V, SA>) -> Self {\n        m.iter()\n            .map(|(k, v)| ((*k).to_owned(), (*v).to_owned()))\n            .collect()\n    }\n}","impl<K, V, S, RK, RV> Extend<(RK, RV)> for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone + From<RK>,\n    V: Clone + From<RV>,\n    S: BuildHasher,\n{\n    fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = (RK, RV)>,\n    {\n        for (key, value) in iter {\n            self.insert(From::from(key), From::from(value));\n        }\n    }\n}","impl<K, V, S> Add for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher,\n{\n    type Output = HashMap<K, V, S>;\n\n    fn add(self, other: Self) -> Self::Output {\n        self.union(other)\n    }\n}","impl<K, V, S> AsRef<HashMap<K, V, S>> for HashMap<K, V, S> {\n    #[inline]\n    fn as_ref(&self) -> &Self {\n        self\n    }\n}","impl<K, V, S> Clone for HashMap<K, V, S>\nwhere\n    K: Clone,\n    V: Clone,\n{\n    /// Clone a map.\n    ///\n    /// Time: O(1)\n    #[inline]\n    fn clone(&self) -> Self {\n        HashMap {\n            root: self.root.clone(),\n            pool: self.pool.clone(),\n            size: self.size,\n            hasher: self.hasher.clone(),\n        }\n    }\n}","impl<K, V, S> Debug for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Debug,\n    V: Debug,\n    S: BuildHasher,\n{\n    default fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        let mut d = f.debug_map();\n        for (k, v) in self {\n            d.entry(k, v);\n        }\n        d.finish()\n    }\n}","impl<K, V, S> Debug for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Ord + Debug,\n    V: Debug,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        let mut keys = collections::BTreeSet::new();\n        keys.extend(self.keys());\n        let mut d = f.debug_map();\n        for key in keys {\n            d.entry(key, &self[key]);\n        }\n        d.finish()\n    }\n}","impl<K, V, S> Default for HashMap<K, V, S>\nwhere\n    S: BuildHasher + Default,\n{\n    #[inline]\n    fn default() -> Self {\n        let pool = HashMapPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashMap {\n            size: 0,\n            pool,\n            root,\n            hasher: Ref::<S>::default(),\n        }\n    }\n}","impl<K, V, S> Eq for HashMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    V: Eq,\n    S: BuildHasher,\n{\n}","impl<K, V, S> From<Vec<(K, V)>> for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher + Default,\n{\n    fn from(m: Vec<(K, V)>) -> Self {\n        m.into_iter().collect()\n    }\n}","impl<K, V, S> From<collections::BTreeMap<K, V>> for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher + Default,\n{\n    fn from(m: collections::BTreeMap<K, V>) -> Self {\n        m.into_iter().collect()\n    }\n}","impl<K, V, S> From<collections::HashMap<K, V>> for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher + Default,\n{\n    fn from(m: collections::HashMap<K, V>) -> Self {\n        m.into_iter().collect()\n    }\n}","impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher + Default,\n{\n    fn from_iter<T>(i: T) -> Self\n    where\n        T: IntoIterator<Item = (K, V)>,\n    {\n        let mut map = Self::default();\n        for (k, v) in i {\n            map.insert(k, v);\n        }\n        map\n    }\n}","impl<K, V, S> Hash for HashMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    V: Hash,\n    S: BuildHasher,\n{\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for i in self.iter() {\n            i.hash(state);\n        }\n    }\n}","impl<K, V, S> HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher,\n{\n    /// Get a mutable iterator over the values of a hash map.\n    ///\n    /// Please note that the order is consistent between maps using\n    /// the same hasher, but no other ordering guarantee is offered.\n    /// Items will not come out in insertion order or sort order.\n    /// They will, however, come out in the same order every time for\n    /// the same map.\n    #[inline]\n    #[must_use]\n    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        IterMut {\n            it: NodeIterMut::new(&self.pool.0, root, self.size),\n        }\n    }\n\n    /// Get a mutable reference to the value for a key from a hash\n    /// map.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let mut map = hashmap!{123 => \"lol\"};\n    /// if let Some(value) = map.get_mut(&123) {\n    ///     *value = \"omg\";\n    /// }\n    /// assert_eq!(\n    ///   map.get(&123),\n    ///   Some(&\"omg\")\n    /// );\n    /// ```\n    #[must_use]\n    pub fn get_mut<BK>(&mut self, key: &BK) -> Option<&mut V>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,\n    {\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        match root.get_mut(&self.pool.0, hash_key(&*self.hasher, key), 0, key) {\n            None => None,\n            Some(&mut (_, ref mut value)) => Some(value),\n        }\n    }\n\n    /// Insert a key/value mapping into a map.\n    ///\n    /// If the map already has a mapping for the given key, the\n    /// previous value is overwritten.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let mut map = hashmap!{};\n    /// map.insert(123, \"123\");\n    /// map.insert(456, \"456\");\n    /// assert_eq!(\n    ///   map,\n    ///   hashmap!{123 => \"123\", 456 => \"456\"}\n    /// );\n    /// ```\n    #[inline]\n    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n        let hash = hash_key(&*self.hasher, &k);\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        let result = root.insert(&self.pool.0, hash, 0, (k, v));\n        if result.is_none() {\n            self.size += 1;\n        }\n        result.map(|(_, v)| v)\n    }\n\n    /// Remove a key/value pair from a map, if it exists, and return\n    /// the removed value.\n    ///\n    /// This is a copy-on-write operation, so that the parts of the\n    /// set's structure which are shared with other sets will be\n    /// safely copied before mutating.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let mut map = hashmap!{123 => \"123\", 456 => \"456\"};\n    /// assert_eq!(Some(\"123\"), map.remove(&123));\n    /// assert_eq!(Some(\"456\"), map.remove(&456));\n    /// assert_eq!(None, map.remove(&789));\n    /// assert!(map.is_empty());\n    /// ```\n    pub fn remove<BK>(&mut self, k: &BK) -> Option<V>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.remove_with_key(k).map(|(_, v)| v)\n    }\n\n    /// Remove a key/value pair from a map, if it exists, and return\n    /// the removed key and value.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let mut map = hashmap!{123 => \"123\", 456 => \"456\"};\n    /// assert_eq!(Some((123, \"123\")), map.remove_with_key(&123));\n    /// assert_eq!(Some((456, \"456\")), map.remove_with_key(&456));\n    /// assert_eq!(None, map.remove_with_key(&789));\n    /// assert!(map.is_empty());\n    /// ```\n    pub fn remove_with_key<BK>(&mut self, k: &BK) -> Option<(K, V)>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,\n    {\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        let result = root.remove(&self.pool.0, hash_key(&*self.hasher, k), 0, k);\n        if result.is_some() {\n            self.size -= 1;\n        }\n        result\n    }\n\n    /// Get the [`Entry`][Entry] for a key in the map for in-place manipulation.\n    ///\n    /// Time: O(log n)\n    ///\n    /// [Entry]: enum.Entry.html\n    #[must_use]\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V, S> {\n        let hash = hash_key(&*self.hasher, &key);\n        if self.root.get(hash, 0, &key).is_some() {\n            Entry::Occupied(OccupiedEntry {\n                map: self,\n                hash,\n                key,\n            })\n        } else {\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash,\n                key,\n            })\n        }\n    }\n\n    /// Construct a new hash map by inserting a key/value mapping into a map.\n    ///\n    /// If the map already has a mapping for the given key, the previous value\n    /// is overwritten.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map = hashmap!{};\n    /// assert_eq!(\n    ///   map.update(123, \"123\"),\n    ///   hashmap!{123 => \"123\"}\n    /// );\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn update(&self, k: K, v: V) -> Self {\n        let mut out = self.clone();\n        out.insert(k, v);\n        out\n    }\n\n    /// Construct a new hash map by inserting a key/value mapping into\n    /// a map.\n    ///\n    /// If the map already has a mapping for the given key, we call\n    /// the provided function with the old value and the new value,\n    /// and insert the result as the new value.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn update_with<F>(&self, k: K, v: V, f: F) -> Self\n    where\n        F: FnOnce(V, V) -> V,\n    {\n        match self.extract_with_key(&k) {\n            None => self.update(k, v),\n            Some((_, v2, m)) => m.update(k, f(v2, v)),\n        }\n    }\n\n    /// Construct a new map by inserting a key/value mapping into a\n    /// map.\n    ///\n    /// If the map already has a mapping for the given key, we call\n    /// the provided function with the key, the old value and the new\n    /// value, and insert the result as the new value.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn update_with_key<F>(&self, k: K, v: V, f: F) -> Self\n    where\n        F: FnOnce(&K, V, V) -> V,\n    {\n        match self.extract_with_key(&k) {\n            None => self.update(k, v),\n            Some((_, v2, m)) => {\n                let out_v = f(&k, v2, v);\n                m.update(k, out_v)\n            }\n        }\n    }\n\n    /// Construct a new map by inserting a key/value mapping into a\n    /// map, returning the old value for the key as well as the new\n    /// map.\n    ///\n    /// If the map already has a mapping for the given key, we call\n    /// the provided function with the key, the old value and the new\n    /// value, and insert the result as the new value.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn update_lookup_with_key<F>(&self, k: K, v: V, f: F) -> (Option<V>, Self)\n    where\n        F: FnOnce(&K, &V, V) -> V,\n    {\n        match self.extract_with_key(&k) {\n            None => (None, self.update(k, v)),\n            Some((_, v2, m)) => {\n                let out_v = f(&k, &v2, v);\n                (Some(v2), m.update(k, out_v))\n            }\n        }\n    }\n\n    /// Update the value for a given key by calling a function with\n    /// the current value and overwriting it with the function's\n    /// return value.\n    ///\n    /// The function gets an [`Option<V>`][std::option::Option] and\n    /// returns the same, so that it can decide to delete a mapping\n    /// instead of updating the value, and decide what to do if the\n    /// key isn't in the map.\n    ///\n    /// Time: O(log n)\n    ///\n    /// [std::option::Option]: https://doc.rust-lang.org/std/option/enum.Option.html\n    #[must_use]\n    pub fn alter<F>(&self, f: F, k: K) -> Self\n    where\n        F: FnOnce(Option<V>) -> Option<V>,\n    {\n        let pop = self.extract_with_key(&k);\n        match (f(pop.as_ref().map(|&(_, ref v, _)| v.clone())), pop) {\n            (None, None) => self.clone(),\n            (Some(v), None) => self.update(k, v),\n            (None, Some((_, _, m))) => m,\n            (Some(v), Some((_, _, m))) => m.update(k, v),\n        }\n    }\n\n    /// Construct a new map without the given key.\n    ///\n    /// Construct a map that's a copy of the current map, absent the\n    /// mapping for `key` if it's present.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn without<BK>(&self, k: &BK) -> Self\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,\n    {\n        match self.extract_with_key(k) {\n            None => self.clone(),\n            Some((_, _, map)) => map,\n        }\n    }\n\n    /// Filter out values from a map which don't satisfy a predicate.\n    ///\n    /// This is slightly more efficient than filtering using an\n    /// iterator, in that it doesn't need to rehash the retained\n    /// values, but it still needs to reconstruct the entire tree\n    /// structure of the map.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::HashMap;\n    /// let mut map = hashmap!{1 => 1, 2 => 2, 3 => 3};\n    /// map.retain(|k, v| *k > 1);\n    /// let expected = hashmap!{2 => 2, 3 => 3};\n    /// assert_eq!(expected, map);\n    /// ```\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&K, &V) -> bool,\n    {\n        let old_root = self.root.clone();\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        for ((key, value), hash) in NodeIter::new(&old_root, self.size) {\n            if !f(key, value) && root.remove(&self.pool.0, hash, 0, key).is_some() {\n                self.size -= 1;\n            }\n        }\n    }\n\n    /// Remove a key/value pair from a map, if it exists, and return\n    /// the removed value as well as the updated map.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn extract<BK>(&self, k: &BK) -> Option<(V, Self)>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.extract_with_key(k).map(|(_, v, m)| (v, m))\n    }\n\n    /// Remove a key/value pair from a map, if it exists, and return\n    /// the removed key and value as well as the updated list.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn extract_with_key<BK>(&self, k: &BK) -> Option<(K, V, Self)>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,\n    {\n        let mut out = self.clone();\n        out.remove_with_key(k).map(|(k, v)| (k, v, out))\n    }\n\n    /// Construct the union of two maps, keeping the values in the\n    /// current map when keys exist in both maps.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map1 = hashmap!{1 => 1, 3 => 3};\n    /// let map2 = hashmap!{2 => 2, 3 => 4};\n    /// let expected = hashmap!{1 => 1, 2 => 2, 3 => 3};\n    /// assert_eq!(expected, map1.union(map2));\n    /// ```\n    #[must_use]\n    pub fn union(mut self, other: Self) -> Self {\n        for (k, v) in other {\n            self.entry(k).or_insert(v);\n        }\n        self\n    }\n\n    /// Construct the union of two maps, using a function to decide\n    /// what to do with the value when a key is in both maps.\n    ///\n    /// The function is called when a value exists in both maps, and\n    /// receives the value from the current map as its first argument,\n    /// and the value from the other map as the second. It should\n    /// return the value to be inserted in the resulting map.\n    ///\n    /// Time: O(n log n)\n    #[inline]\n    #[must_use]\n    pub fn union_with<F>(self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(V, V) -> V,\n    {\n        self.union_with_key(other, |_, v1, v2| f(v1, v2))\n    }\n\n    /// Construct the union of two maps, using a function to decide\n    /// what to do with the value when a key is in both maps.\n    ///\n    /// The function is called when a value exists in both maps, and\n    /// receives a reference to the key as its first argument, the\n    /// value from the current map as the second argument, and the\n    /// value from the other map as the third argument. It should\n    /// return the value to be inserted in the resulting map.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map1 = hashmap!{1 => 1, 3 => 4};\n    /// let map2 = hashmap!{2 => 2, 3 => 5};\n    /// let expected = hashmap!{1 => 1, 2 => 2, 3 => 9};\n    /// assert_eq!(expected, map1.union_with_key(\n    ///     map2,\n    ///     |key, left, right| left + right\n    /// ));\n    /// ```\n    #[must_use]\n    pub fn union_with_key<F>(mut self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> V,\n    {\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => {\n                    self.insert(key, right_value);\n                }\n                Some(left_value) => {\n                    let final_value = f(&key, left_value, right_value);\n                    self.insert(key, final_value);\n                }\n            }\n        }\n        self\n    }\n\n    /// Construct the union of a sequence of maps, selecting the value\n    /// of the leftmost when a key appears in more than one map.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map1 = hashmap!{1 => 1, 3 => 3};\n    /// let map2 = hashmap!{2 => 2};\n    /// let expected = hashmap!{1 => 1, 2 => 2, 3 => 3};\n    /// assert_eq!(expected, HashMap::unions(vec![map1, map2]));\n    /// ```\n    #[must_use]\n    pub fn unions<I>(i: I) -> Self\n    where\n        S: Default,\n        I: IntoIterator<Item = Self>,\n    {\n        i.into_iter().fold(Self::default(), Self::union)\n    }\n\n    /// Construct the union of a sequence of maps, using a function to\n    /// decide what to do with the value when a key is in more than\n    /// one map.\n    ///\n    /// The function is called when a value exists in multiple maps,\n    /// and receives the value from the current map as its first\n    /// argument, and the value from the next map as the second. It\n    /// should return the value to be inserted in the resulting map.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn unions_with<I, F>(i: I, f: F) -> Self\n    where\n        S: Default,\n        I: IntoIterator<Item = Self>,\n        F: Fn(V, V) -> V,\n    {\n        i.into_iter()\n            .fold(Self::default(), |a, b| a.union_with(b, &f))\n    }\n\n    /// Construct the union of a sequence of maps, using a function to\n    /// decide what to do with the value when a key is in more than\n    /// one map.\n    ///\n    /// The function is called when a value exists in multiple maps,\n    /// and receives a reference to the key as its first argument, the\n    /// value from the current map as the second argument, and the\n    /// value from the next map as the third argument. It should\n    /// return the value to be inserted in the resulting map.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn unions_with_key<I, F>(i: I, f: F) -> Self\n    where\n        S: Default,\n        I: IntoIterator<Item = Self>,\n        F: Fn(&K, V, V) -> V,\n    {\n        i.into_iter()\n            .fold(Self::default(), |a, b| a.union_with_key(b, &f))\n    }\n\n    /// Construct the symmetric difference between two maps by discarding keys\n    /// which occur in both maps.\n    ///\n    /// This is an alias for the\n    /// [`symmetric_difference`][symmetric_difference] method.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map1 = hashmap!{1 => 1, 3 => 4};\n    /// let map2 = hashmap!{2 => 2, 3 => 5};\n    /// let expected = hashmap!{1 => 1, 2 => 2};\n    /// assert_eq!(expected, map1.difference(map2));\n    /// ```\n    ///\n    /// [symmetric_difference]: #method.symmetric_difference\n    #[inline]\n    #[must_use]\n    pub fn difference(self, other: Self) -> Self {\n        self.symmetric_difference(other)\n    }\n\n    /// Construct the symmetric difference between two maps by discarding keys\n    /// which occur in both maps.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map1 = hashmap!{1 => 1, 3 => 4};\n    /// let map2 = hashmap!{2 => 2, 3 => 5};\n    /// let expected = hashmap!{1 => 1, 2 => 2};\n    /// assert_eq!(expected, map1.symmetric_difference(map2));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn symmetric_difference(self, other: Self) -> Self {\n        self.symmetric_difference_with_key(other, |_, _, _| None)\n    }\n\n    /// Construct the symmetric difference between two maps by using a function\n    /// to decide what to do if a key occurs in both.\n    ///\n    /// This is an alias for the\n    /// [`symmetric_difference_with`][symmetric_difference_with] method.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// [symmetric_difference_with]: #method.symmetric_difference_with\n    #[inline]\n    #[must_use]\n    pub fn difference_with<F>(self, other: Self, f: F) -> Self\n    where\n        F: FnMut(V, V) -> Option<V>,\n    {\n        self.symmetric_difference_with(other, f)\n    }\n\n    /// Construct the symmetric difference between two maps by using a function\n    /// to decide what to do if a key occurs in both.\n    ///\n    /// Time: O(n log n)\n    #[inline]\n    #[must_use]\n    pub fn symmetric_difference_with<F>(self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(V, V) -> Option<V>,\n    {\n        self.symmetric_difference_with_key(other, |_, a, b| f(a, b))\n    }\n\n    /// Construct the symmetric difference between two maps by using a function\n    /// to decide what to do if a key occurs in both. The function\n    /// receives the key as well as both values.\n    ///\n    /// This is an alias for the\n    /// [`symmetric_difference_with`_key][symmetric_difference_with_key]\n    /// method.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map1 = hashmap!{1 => 1, 3 => 4};\n    /// let map2 = hashmap!{2 => 2, 3 => 5};\n    /// let expected = hashmap!{1 => 1, 2 => 2, 3 => 9};\n    /// assert_eq!(expected, map1.difference_with_key(\n    ///     map2,\n    ///     |key, left, right| Some(left + right)\n    /// ));\n    /// ```\n    ///\n    /// [symmetric_difference_with_key]: #method.symmetric_difference_with_key\n    #[must_use]\n    pub fn difference_with_key<F>(self, other: Self, f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> Option<V>,\n    {\n        self.symmetric_difference_with_key(other, f)\n    }\n\n    /// Construct the symmetric difference between two maps by using a function\n    /// to decide what to do if a key occurs in both. The function\n    /// receives the key as well as both values.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map1 = hashmap!{1 => 1, 3 => 4};\n    /// let map2 = hashmap!{2 => 2, 3 => 5};\n    /// let expected = hashmap!{1 => 1, 2 => 2, 3 => 9};\n    /// assert_eq!(expected, map1.symmetric_difference_with_key(\n    ///     map2,\n    ///     |key, left, right| Some(left + right)\n    /// ));\n    /// ```\n    #[must_use]\n    pub fn symmetric_difference_with_key<F>(mut self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> Option<V>,\n    {\n        let mut out = self.new_from();\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => {\n                    out.insert(key, right_value);\n                }\n                Some(left_value) => {\n                    if let Some(final_value) = f(&key, left_value, right_value) {\n                        out.insert(key, final_value);\n                    }\n                }\n            }\n        }\n        out.union(self)\n    }\n\n    /// Construct the relative complement between two maps by discarding keys\n    /// which occur in `other`.\n    ///\n    /// Time: O(m log n) where m is the size of the other map\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 3 => 4};\n    /// let map2 = ordmap!{2 => 2, 3 => 5};\n    /// let expected = ordmap!{1 => 1};\n    /// assert_eq!(expected, map1.relative_complement(map2));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn relative_complement(mut self, other: Self) -> Self {\n        for (key, _) in other {\n            let _ = self.remove(&key);\n        }\n        self\n    }\n\n    /// Construct the intersection of two maps, keeping the values\n    /// from the current map.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map1 = hashmap!{1 => 1, 2 => 2};\n    /// let map2 = hashmap!{2 => 3, 3 => 4};\n    /// let expected = hashmap!{2 => 2};\n    /// assert_eq!(expected, map1.intersection(map2));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn intersection(self, other: Self) -> Self {\n        self.intersection_with_key(other, |_, v, _| v)\n    }\n\n    /// Construct the intersection of two maps, calling a function\n    /// with both values for each key and using the result as the\n    /// value for the key.\n    ///\n    /// Time: O(n log n)\n    #[inline]\n    #[must_use]\n    pub fn intersection_with<B, C, F>(self, other: HashMap<K, B, S>, mut f: F) -> HashMap<K, C, S>\n    where\n        B: Clone,\n        C: Clone,\n        F: FnMut(V, B) -> C,\n    {\n        self.intersection_with_key(other, |_, v1, v2| f(v1, v2))\n    }\n\n    /// Construct the intersection of two maps, calling a function\n    /// with the key and both values for each key and using the result\n    /// as the value for the key.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map1 = hashmap!{1 => 1, 2 => 2};\n    /// let map2 = hashmap!{2 => 3, 3 => 4};\n    /// let expected = hashmap!{2 => 5};\n    /// assert_eq!(expected, map1.intersection_with_key(\n    ///     map2,\n    ///     |key, left, right| left + right\n    /// ));\n    /// ```\n    #[must_use]\n    pub fn intersection_with_key<B, C, F>(\n        mut self,\n        other: HashMap<K, B, S>,\n        mut f: F,\n    ) -> HashMap<K, C, S>\n    where\n        B: Clone,\n        C: Clone,\n        F: FnMut(&K, V, B) -> C,\n    {\n        let mut out = self.new_from();\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => (),\n                Some(left_value) => {\n                    let result = f(&key, left_value, right_value);\n                    out.insert(key, result);\n                }\n            }\n        }\n        out\n    }\n}","impl<K, V, S> HashMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    fn test_eq(&self, other: &Self) -> bool\n    where\n        K: Hash + Eq,\n        V: PartialEq,\n    {\n        if self.len() != other.len() {\n            return false;\n        }\n        let mut seen = collections::HashSet::new();\n        for (key, value) in self.iter() {\n            if Some(value) != other.get(&key) {\n                return false;\n            }\n            seen.insert(key);\n        }\n        for key in other.keys() {\n            if !seen.contains(&key) {\n                return false;\n            }\n        }\n        true\n    }\n\n    /// Get the value for a key from a hash map.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map = hashmap!{123 => \"lol\"};\n    /// assert_eq!(\n    ///   map.get(&123),\n    ///   Some(&\"lol\")\n    /// );\n    /// ```\n    #[must_use]\n    pub fn get<BK>(&self, key: &BK) -> Option<&V>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.root\n            .get(hash_key(&*self.hasher, key), 0, key)\n            .map(|&(_, ref v)| v)\n    }\n\n    /// Get the key/value pair for a key from a hash map.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map = hashmap!{123 => \"lol\"};\n    /// assert_eq!(\n    ///   map.get_key_value(&123),\n    ///   Some((&123, &\"lol\"))\n    /// );\n    /// ```\n    #[must_use]\n    pub fn get_key_value<BK>(&self, key: &BK) -> Option<(&K, &V)>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.root\n            .get(hash_key(&*self.hasher, key), 0, key)\n            .map(|&(ref k, ref v)| (k, v))\n    }\n\n    /// Test for the presence of a key in a hash map.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map = hashmap!{123 => \"lol\"};\n    /// assert!(\n    ///   map.contains_key(&123)\n    /// );\n    /// assert!(\n    ///   !map.contains_key(&321)\n    /// );\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn contains_key<BK>(&self, k: &BK) -> bool\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.get(k).is_some()\n    }\n\n    /// Test whether a map is a submap of another map, meaning that\n    /// all keys in our map must also be in the other map, with the\n    /// same values.\n    ///\n    /// Use the provided function to decide whether values are equal.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn is_submap_by<B, RM, F>(&self, other: RM, mut cmp: F) -> bool\n    where\n        F: FnMut(&V, &B) -> bool,\n        RM: Borrow<HashMap<K, B, S>>,\n    {\n        self.iter()\n            .all(|(k, v)| other.borrow().get(k).map(|ov| cmp(v, ov)).unwrap_or(false))\n    }\n\n    /// Test whether a map is a proper submap of another map, meaning\n    /// that all keys in our map must also be in the other map, with\n    /// the same values. To be a proper submap, ours must also contain\n    /// fewer keys than the other map.\n    ///\n    /// Use the provided function to decide whether values are equal.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn is_proper_submap_by<B, RM, F>(&self, other: RM, cmp: F) -> bool\n    where\n        F: FnMut(&V, &B) -> bool,\n        RM: Borrow<HashMap<K, B, S>>,\n    {\n        self.len() != other.borrow().len() && self.is_submap_by(other, cmp)\n    }\n\n    /// Test whether a map is a submap of another map, meaning that\n    /// all keys in our map must also be in the other map, with the\n    /// same values.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map1 = hashmap!{1 => 1, 2 => 2};\n    /// let map2 = hashmap!{1 => 1, 2 => 2, 3 => 3};\n    /// assert!(map1.is_submap(map2));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn is_submap<RM>(&self, other: RM) -> bool\n    where\n        V: PartialEq,\n        RM: Borrow<Self>,\n    {\n        self.is_submap_by(other.borrow(), PartialEq::eq)\n    }\n\n    /// Test whether a map is a proper submap of another map, meaning\n    /// that all keys in our map must also be in the other map, with\n    /// the same values. To be a proper submap, ours must also contain\n    /// fewer keys than the other map.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map1 = hashmap!{1 => 1, 2 => 2};\n    /// let map2 = hashmap!{1 => 1, 2 => 2, 3 => 3};\n    /// assert!(map1.is_proper_submap(map2));\n    ///\n    /// let map3 = hashmap!{1 => 1, 2 => 2};\n    /// let map4 = hashmap!{1 => 1, 2 => 2};\n    /// assert!(!map3.is_proper_submap(map4));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn is_proper_submap<RM>(&self, other: RM) -> bool\n    where\n        V: PartialEq,\n        RM: Borrow<Self>,\n    {\n        self.is_proper_submap_by(other.borrow(), PartialEq::eq)\n    }\n}","impl<K, V, S> HashMap<K, V, S> {\n    /// Test whether a hash map is empty.\n    ///\n    /// Time: O(1)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// assert!(\n    ///   !hashmap!{1 => 2}.is_empty()\n    /// );\n    /// assert!(\n    ///   HashMap::<i32, i32>::new().is_empty()\n    /// );\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Get the size of a hash map.\n    ///\n    /// Time: O(1)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// assert_eq!(3, hashmap!{\n    ///   1 => 11,\n    ///   2 => 22,\n    ///   3 => 33\n    /// }.len());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn len(&self) -> usize {\n        self.size\n    }\n\n    /// Test whether two maps refer to the same content in memory.\n    ///\n    /// This is true if the two sides are references to the same map,\n    /// or if the two maps refer to the same root node.\n    ///\n    /// This would return true if you're comparing a map to itself, or\n    /// if you're comparing a map to a fresh clone of itself.\n    ///\n    /// Time: O(1)\n    pub fn ptr_eq(&self, other: &Self) -> bool {\n        std::ptr::eq(self, other) || PoolRef::ptr_eq(&self.root, &other.root)\n    }\n\n    /// Get a reference to the memory pool used by this map.\n    ///\n    /// Note that if you didn't specifically construct it with a pool, you'll\n    /// get back a reference to a pool of size 0.\n    #[cfg(feature = \"pool\")]\n    pub fn pool(&self) -> &HashMapPool<K, V> {\n        &self.pool\n    }\n\n    /// Construct an empty hash map using the provided hasher.\n    #[inline]\n    #[must_use]\n    pub fn with_hasher<RS>(hasher: RS) -> Self\n    where\n        Ref<S>: From<RS>,\n    {\n        let pool = HashMapPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashMap {\n            size: 0,\n            hasher: hasher.into(),\n            pool,\n            root,\n        }\n    }\n\n    /// Construct an empty hash map using a specific memory pool and hasher.\n    #[cfg(feature = \"pool\")]\n    #[must_use]\n    pub fn with_pool_hasher<RS>(pool: &HashMapPool<K, V>, hasher: RS) -> Self\n    where\n        Ref<S>: From<RS>,\n    {\n        let root = PoolRef::default(&pool.0);\n        Self {\n            size: 0,\n            hasher: hasher.into(),\n            pool: pool.clone(),\n            root,\n        }\n    }\n\n    /// Get a reference to the map's [`BuildHasher`][BuildHasher].\n    ///\n    /// [BuildHasher]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    #[must_use]\n    pub fn hasher(&self) -> &Ref<S> {\n        &self.hasher\n    }\n\n    /// Construct an empty hash map using the same hasher as the\n    /// current hash map.\n    #[inline]\n    #[must_use]\n    pub fn new_from<K1, V1>(&self) -> HashMap<K1, V1, S>\n    where\n        K1: Hash + Eq + Clone,\n        V1: Clone,\n    {\n        let pool = HashMapPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashMap {\n            size: 0,\n            pool,\n            root,\n            hasher: self.hasher.clone(),\n        }\n    }\n\n    /// Get an iterator over the key/value pairs of a hash map.\n    ///\n    /// Please note that the order is consistent between maps using\n    /// the same hasher, but no other ordering guarantee is offered.\n    /// Items will not come out in insertion order or sort order.\n    /// They will, however, come out in the same order every time for\n    /// the same map.\n    #[inline]\n    #[must_use]\n    pub fn iter(&self) -> Iter<'_, K, V> {\n        Iter {\n            it: NodeIter::new(&self.root, self.size),\n        }\n    }\n\n    /// Get an iterator over a hash map's keys.\n    ///\n    /// Please note that the order is consistent between maps using\n    /// the same hasher, but no other ordering guarantee is offered.\n    /// Items will not come out in insertion order or sort order.\n    /// They will, however, come out in the same order every time for\n    /// the same map.\n    #[inline]\n    #[must_use]\n    pub fn keys(&self) -> Keys<'_, K, V> {\n        Keys {\n            it: NodeIter::new(&self.root, self.size),\n        }\n    }\n\n    /// Get an iterator over a hash map's values.\n    ///\n    /// Please note that the order is consistent between maps using\n    /// the same hasher, but no other ordering guarantee is offered.\n    /// Items will not come out in insertion order or sort order.\n    /// They will, however, come out in the same order every time for\n    /// the same map.\n    #[inline]\n    #[must_use]\n    pub fn values(&self) -> Values<'_, K, V> {\n        Values {\n            it: NodeIter::new(&self.root, self.size),\n        }\n    }\n\n    /// Discard all elements from the map.\n    ///\n    /// This leaves you with an empty map, and all elements that\n    /// were previously inside it are dropped.\n    ///\n    /// Time: O(n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::HashMap;\n    /// let mut map = hashmap![1=>1, 2=>2, 3=>3];\n    /// map.clear();\n    /// assert!(map.is_empty());\n    /// ```\n    pub fn clear(&mut self) {\n        if !self.is_empty() {\n            self.root = PoolRef::default(&self.pool.0);\n            self.size = 0;\n        }\n    }\n}","impl<K, V, S> IntoIterator for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher,\n{\n    type Item = (K, V);\n    type IntoIter = ConsumingIter<(K, V)>;\n\n    #[inline]\n    fn into_iter(self) -> Self::IntoIter {\n        ConsumingIter {\n            it: NodeDrain::new(&self.pool.0, self.root, self.size),\n        }\n    }\n}","impl<K, V, S> Ord for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Ord + Clone,\n    V: Ord + Clone,\n    S: BuildHasher,\n{\n    fn cmp(&self, other: &Self) -> Ordering {\n        if Ref::ptr_eq(&self.hasher, &other.hasher) {\n            return self.iter().cmp(other.iter());\n        }\n        self.iter().cmp(other.iter())\n    }\n}","impl<K, V, S> PartialEq for HashMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    V: Eq,\n    S: BuildHasher,\n{\n    fn eq(&self, other: &Self) -> bool {\n        if PoolRef::ptr_eq(&self.root, &other.root) {\n            return true;\n        }\n        self.test_eq(other)\n    }\n}","impl<K, V, S> PartialEq for HashMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    V: PartialEq,\n    S: BuildHasher,\n{\n    default fn eq(&self, other: &Self) -> bool {\n        self.test_eq(other)\n    }\n}","impl<K, V, S> PartialOrd for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone + PartialOrd,\n    V: PartialOrd + Clone,\n    S: BuildHasher,\n{\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        if Ref::ptr_eq(&self.hasher, &other.hasher) {\n            return self.iter().partial_cmp(other.iter());\n        }\n        self.iter().partial_cmp(other.iter())\n    }\n}","impl<K, V, S> Sum for HashMap<K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher + Default,\n{\n    fn sum<I>(it: I) -> Self\n    where\n        I: Iterator<Item = Self>,\n    {\n        it.fold(Self::default(), |a, b| a + b)\n    }\n}","impl<K, V> HashMap<K, V, RandomState>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n{\n    /// Construct a hash map with a single mapping.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashmap::HashMap;\n    /// let map = HashMap::unit(123, \"onetwothree\");\n    /// assert_eq!(\n    ///   map.get(&123),\n    ///   Some(&\"onetwothree\")\n    /// );\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn unit(k: K, v: V) -> HashMap<K, V> {\n        HashMap::new().update(k, v)\n    }\n}","impl<K, V> HashMap<K, V, RandomState> {\n    /// Construct an empty hash map.\n    #[inline]\n    #[must_use]\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Construct an empty hash map using a specific memory pool.\n    #[cfg(feature = \"pool\")]\n    #[must_use]\n    pub fn with_pool(pool: &HashMapPool<K, V>) -> Self {\n        let root = PoolRef::default(&pool.0);\n        Self {\n            size: 0,\n            hasher: Default::default(),\n            pool: pool.clone(),\n            root,\n        }\n    }\n}"],"hash::map::HashMapPool":["impl<$($arg,)*> $name<$($arg,)*> {\n            /// Create a new pool with the given size.\n            pub fn new(size: usize) -> Self {\n                Self(Pool::new(size))\n            }\n\n            /// Fill the pool with preallocated chunks.\n            pub fn fill(&self) {\n                self.0.fill();\n            }\n\n            ///Get the current size of the pool.\n            pub fn pool_size(&self) -> usize {\n                self.0.get_pool_size()\n            }\n        }","impl<$($arg,)*> Clone for $name<$($arg,)*> {\n            fn clone(&self) -> Self {\n                Self(self.0.clone())\n            }\n        }","impl<$($arg,)*> Default for $name<$($arg,)*> {\n            fn default() -> Self {\n                Self::new($crate::config::POOL_SIZE)\n            }\n        }"],"hash::map::Iter":["impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}","impl<'a, K, V> FusedIterator for Iter<'a, K, V> {}","impl<'a, K, V> Iterator for Iter<'a, K, V> {\n    type Item = (&'a K, &'a V);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|((k, v), _)| (k, v))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n}"],"hash::map::IterMut":["impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V>\nwhere\n    K: Clone,\n    V: Clone,\n{\n}","impl<'a, K, V> FusedIterator for IterMut<'a, K, V>\nwhere\n    K: Clone,\n    V: Clone,\n{\n}","impl<'a, K, V> Iterator for IterMut<'a, K, V>\nwhere\n    K: Clone,\n    V: Clone,\n{\n    type Item = (&'a K, &'a mut V);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|((k, v), _)| (&*k, v))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n}"],"hash::map::Keys":["impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {}","impl<'a, K, V> FusedIterator for Keys<'a, K, V> {}","impl<'a, K, V> Iterator for Keys<'a, K, V> {\n    type Item = &'a K;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|((k, _), _)| k)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n}"],"hash::map::OccupiedEntry":["impl<'a, K, V, S> OccupiedEntry<'a, K, V, S>\nwhere\n    K: 'a + Hash + Eq + Clone,\n    V: 'a + Clone,\n    S: 'a + BuildHasher,\n{\n    /// Get the key for this entry.\n    #[must_use]\n    pub fn key(&self) -> &K {\n        &self.key\n    }\n\n    /// Remove this entry from the map and return the removed mapping.\n    pub fn remove_entry(self) -> (K, V) {\n        let root = PoolRef::make_mut(&self.map.pool.0, &mut self.map.root);\n        let result = root.remove(&self.map.pool.0, self.hash, 0, &self.key);\n        self.map.size -= 1;\n        result.unwrap()\n    }\n\n    /// Get the current value.\n    #[must_use]\n    pub fn get(&self) -> &V {\n        &self.map.root.get(self.hash, 0, &self.key).unwrap().1\n    }\n\n    /// Get a mutable reference to the current value.\n    #[must_use]\n    pub fn get_mut(&mut self) -> &mut V {\n        let root = PoolRef::make_mut(&self.map.pool.0, &mut self.map.root);\n        &mut root\n            .get_mut(&self.map.pool.0, self.hash, 0, &self.key)\n            .unwrap()\n            .1\n    }\n\n    /// Convert this entry into a mutable reference.\n    #[must_use]\n    pub fn into_mut(self) -> &'a mut V {\n        let root = PoolRef::make_mut(&self.map.pool.0, &mut self.map.root);\n        &mut root\n            .get_mut(&self.map.pool.0, self.hash, 0, &self.key)\n            .unwrap()\n            .1\n    }\n\n    /// Overwrite the current value.\n    pub fn insert(&mut self, value: V) -> V {\n        mem::replace(self.get_mut(), value)\n    }\n\n    /// Remove this entry from the map and return the removed value.\n    pub fn remove(self) -> V {\n        self.remove_entry().1\n    }\n}"],"hash::map::VacantEntry":["impl<'a, K, V, S> VacantEntry<'a, K, V, S>\nwhere\n    K: 'a + Hash + Eq + Clone,\n    V: 'a + Clone,\n    S: 'a + BuildHasher,\n{\n    /// Get the key for this entry.\n    #[must_use]\n    pub fn key(&self) -> &K {\n        &self.key\n    }\n\n    /// Convert this entry into its key.\n    #[must_use]\n    pub fn into_key(self) -> K {\n        self.key\n    }\n\n    /// Insert a value into this entry.\n    pub fn insert(self, value: V) -> &'a mut V {\n        let root = PoolRef::make_mut(&self.map.pool.0, &mut self.map.root);\n        if root\n            .insert(&self.map.pool.0, self.hash, 0, (self.key.clone(), value))\n            .is_none()\n        {\n            self.map.size += 1;\n        }\n        // TODO it's unfortunate that we need to look up the key again\n        // here to get the mut ref.\n        &mut root\n            .get_mut(&self.map.pool.0, self.hash, 0, &self.key)\n            .unwrap()\n            .1\n    }\n}"],"hash::map::Values":["impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}","impl<'a, K, V> FusedIterator for Values<'a, K, V> {}","impl<'a, K, V> Iterator for Values<'a, K, V> {\n    type Item = &'a V;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|((_, v), _)| v)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n}"],"hash::set::ConsumingIter":["impl<A> ExactSizeIterator for ConsumingIter<A> where A: Hash + Eq + Clone {}","impl<A> FusedIterator for ConsumingIter<A> where A: Hash + Eq + Clone {}","impl<A> Iterator for ConsumingIter<A>\nwhere\n    A: Hash + Eq + Clone,\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|(v, _)| v.0)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n}"],"hash::set::HashSet":["impl<'a, A, S> From<&'a BTreeSet<A>> for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone,\n    S: BuildHasher + Default,\n{\n    fn from(btree_set: &BTreeSet<A>) -> Self {\n        btree_set.iter().cloned().collect()\n    }\n}","impl<'a, A, S> From<&'a OrdSet<A>> for HashSet<A, S>\nwhere\n    A: Ord + Hash + Eq + Clone,\n    S: BuildHasher + Default,\n{\n    fn from(ordset: &OrdSet<A>) -> Self {\n        ordset.into_iter().cloned().collect()\n    }\n}","impl<'a, A, S> From<&'a Vec<A>> for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone,\n    S: BuildHasher + Default,\n{\n    fn from(vec: &Vec<A>) -> Self {\n        vec.iter().cloned().collect()\n    }\n}","impl<'a, A, S> From<&'a [A]> for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone,\n    S: BuildHasher + Default,\n{\n    fn from(slice: &'a [A]) -> Self {\n        slice.iter().cloned().collect()\n    }\n}","impl<'a, A, S> From<&'a collections::HashSet<A>> for HashSet<A, S>\nwhere\n    A: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    fn from(hash_set: &collections::HashSet<A>) -> Self {\n        hash_set.iter().cloned().collect()\n    }\n}","impl<'s, 'a, A, OA, SA, SB> From<&'s HashSet<&'a A, SA>> for HashSet<OA, SB>\nwhere\n    A: ToOwned<Owned = OA> + Hash + Eq + ?Sized,\n    OA: Borrow<A> + Hash + Eq + Clone,\n    SA: BuildHasher,\n    SB: BuildHasher + Default,\n{\n    fn from(set: &HashSet<&A, SA>) -> Self {\n        set.iter().map(|a| (*a).to_owned()).collect()\n    }\n}","impl<A, RA, S> FromIterator<RA> for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone + From<RA>,\n    S: BuildHasher + Default,\n{\n    fn from_iter<T>(i: T) -> Self\n    where\n        T: IntoIterator<Item = RA>,\n    {\n        let mut set = Self::default();\n        for value in i {\n            set.insert(From::from(value));\n        }\n        set\n    }\n}","impl<A, S, R> Extend<R> for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone + From<R>,\n    S: BuildHasher,\n{\n    fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = R>,\n    {\n        for value in iter {\n            self.insert(From::from(value));\n        }\n    }\n}","impl<A, S> Add for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone,\n    S: BuildHasher,\n{\n    type Output = HashSet<A, S>;\n\n    fn add(self, other: Self) -> Self::Output {\n        self.union(other)\n    }\n}","impl<A, S> Clone for HashSet<A, S>\nwhere\n    A: Clone,\n{\n    /// Clone a set.\n    ///\n    /// Time: O(1)\n    #[inline]\n    fn clone(&self) -> Self {\n        HashSet {\n            hasher: self.hasher.clone(),\n            pool: self.pool.clone(),\n            root: self.root.clone(),\n            size: self.size,\n        }\n    }\n}","impl<A, S> Debug for HashSet<A, S>\nwhere\n    A: Hash + Eq + Debug + Ord,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        f.debug_set().entries(self.iter()).finish()\n    }\n}","impl<A, S> Debug for HashSet<A, S>\nwhere\n    A: Hash + Eq + Debug,\n    S: BuildHasher,\n{\n    default fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        f.debug_set().entries(self.iter()).finish()\n    }\n}","impl<A, S> Default for HashSet<A, S>\nwhere\n    S: BuildHasher + Default,\n{\n    fn default() -> Self {\n        let pool = HashSetPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashSet {\n            hasher: Ref::<S>::default(),\n            pool,\n            root,\n            size: 0,\n        }\n    }\n}","impl<A, S> Eq for HashSet<A, S>\nwhere\n    A: Hash + Eq,\n    S: BuildHasher + Default,\n{\n}","impl<A, S> From<OrdSet<A>> for HashSet<A, S>\nwhere\n    A: Ord + Hash + Eq + Clone,\n    S: BuildHasher + Default,\n{\n    fn from(ordset: OrdSet<A>) -> Self {\n        ordset.into_iter().collect()\n    }\n}","impl<A, S> From<Vec<A>> for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone,\n    S: BuildHasher + Default,\n{\n    fn from(vec: Vec<A>) -> Self {\n        vec.into_iter().collect()\n    }\n}","impl<A, S> From<collections::HashSet<A>> for HashSet<A, S>\nwhere\n    A: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    fn from(hash_set: collections::HashSet<A>) -> Self {\n        hash_set.into_iter().collect()\n    }\n}","impl<A, S> Hash for HashSet<A, S>\nwhere\n    A: Hash + Eq,\n    S: BuildHasher + Default,\n{\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for i in self.iter() {\n            i.hash(state);\n        }\n    }\n}","impl<A, S> HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone,\n    S: BuildHasher,\n{\n    /// Insert a value into a set.\n    ///\n    /// Time: O(log n)\n    #[inline]\n    pub fn insert(&mut self, a: A) -> Option<A> {\n        let hash = hash_key(&*self.hasher, &a);\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        match root.insert(&self.pool.0, hash, 0, Value(a)) {\n            None => {\n                self.size += 1;\n                None\n            }\n            Some(Value(old_value)) => Some(old_value),\n        }\n    }\n\n    /// Remove a value from a set if it exists.\n    ///\n    /// Time: O(log n)\n    pub fn remove<BA>(&mut self, a: &BA) -> Option<A>\n    where\n        BA: Hash + Eq + ?Sized,\n        A: Borrow<BA>,\n    {\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        let result = root.remove(&self.pool.0, hash_key(&*self.hasher, a), 0, a);\n        if result.is_some() {\n            self.size -= 1;\n        }\n        result.map(|v| v.0)\n    }\n\n    /// Construct a new set from the current set with the given value\n    /// added.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashset::HashSet;\n    /// # use std::sync::Arc;\n    /// let set = hashset![123];\n    /// assert_eq!(\n    ///   set.update(456),\n    ///   hashset![123, 456]\n    /// );\n    /// ```\n    #[must_use]\n    pub fn update(&self, a: A) -> Self {\n        let mut out = self.clone();\n        out.insert(a);\n        out\n    }\n\n    /// Construct a new set with the given value removed if it's in\n    /// the set.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn without<BA>(&self, a: &BA) -> Self\n    where\n        BA: Hash + Eq + ?Sized,\n        A: Borrow<BA>,\n    {\n        let mut out = self.clone();\n        out.remove(a);\n        out\n    }\n\n    /// Filter out values from a set which don't satisfy a predicate.\n    ///\n    /// This is slightly more efficient than filtering using an\n    /// iterator, in that it doesn't need to rehash the retained\n    /// values, but it still needs to reconstruct the entire tree\n    /// structure of the set.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::HashSet;\n    /// let mut set = hashset![1, 2, 3];\n    /// set.retain(|v| *v > 1);\n    /// let expected = hashset![2, 3];\n    /// assert_eq!(expected, set);\n    /// ```\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&A) -> bool,\n    {\n        let old_root = self.root.clone();\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        for (value, hash) in NodeIter::new(&old_root, self.size) {\n            if !f(value) && root.remove(&self.pool.0, hash, 0, value).is_some() {\n                self.size -= 1;\n            }\n        }\n    }\n\n    /// Construct the union of two sets.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashset::HashSet;\n    /// let set1 = hashset!{1, 2};\n    /// let set2 = hashset!{2, 3};\n    /// let expected = hashset!{1, 2, 3};\n    /// assert_eq!(expected, set1.union(set2));\n    /// ```\n    #[must_use]\n    pub fn union(mut self, other: Self) -> Self {\n        for value in other {\n            self.insert(value);\n        }\n        self\n    }\n\n    /// Construct the union of multiple sets.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn unions<I>(i: I) -> Self\n    where\n        I: IntoIterator<Item = Self>,\n        S: Default,\n    {\n        i.into_iter().fold(Self::default(), Self::union)\n    }\n\n    /// Construct the symmetric difference between two sets.\n    ///\n    /// This is an alias for the\n    /// [`symmetric_difference`][symmetric_difference] method.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashset::HashSet;\n    /// let set1 = hashset!{1, 2};\n    /// let set2 = hashset!{2, 3};\n    /// let expected = hashset!{1, 3};\n    /// assert_eq!(expected, set1.difference(set2));\n    /// ```\n    ///\n    /// [symmetric_difference]: #method.symmetric_difference\n    #[must_use]\n    pub fn difference(self, other: Self) -> Self {\n        self.symmetric_difference(other)\n    }\n\n    /// Construct the symmetric difference between two sets.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashset::HashSet;\n    /// let set1 = hashset!{1, 2};\n    /// let set2 = hashset!{2, 3};\n    /// let expected = hashset!{1, 3};\n    /// assert_eq!(expected, set1.symmetric_difference(set2));\n    /// ```\n    #[must_use]\n    pub fn symmetric_difference(mut self, other: Self) -> Self {\n        for value in other {\n            if self.remove(&value).is_none() {\n                self.insert(value);\n            }\n        }\n        self\n    }\n\n    /// Construct the relative complement between two sets, that is the set\n    /// of values in `self` that do not occur in `other`.\n    ///\n    /// Time: O(m log n) where m is the size of the other set\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// let set1 = ordset!{1, 2};\n    /// let set2 = ordset!{2, 3};\n    /// let expected = ordset!{1};\n    /// assert_eq!(expected, set1.relative_complement(set2));\n    /// ```\n    #[must_use]\n    pub fn relative_complement(mut self, other: Self) -> Self {\n        for value in other {\n            let _ = self.remove(&value);\n        }\n        self\n    }\n\n    /// Construct the intersection of two sets.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashset::HashSet;\n    /// let set1 = hashset!{1, 2};\n    /// let set2 = hashset!{2, 3};\n    /// let expected = hashset!{2};\n    /// assert_eq!(expected, set1.intersection(set2));\n    /// ```\n    #[must_use]\n    pub fn intersection(self, other: Self) -> Self {\n        let mut out = self.new_from();\n        for value in other {\n            if self.contains(&value) {\n                out.insert(value);\n            }\n        }\n        out\n    }\n}","impl<A, S> HashSet<A, S>\nwhere\n    A: Hash + Eq,\n    S: BuildHasher,\n{\n    fn test_eq(&self, other: &Self) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n        let mut seen = collections::HashSet::new();\n        for value in self.iter() {\n            if !other.contains(&value) {\n                return false;\n            }\n            seen.insert(value);\n        }\n        for value in other.iter() {\n            if !seen.contains(&value) {\n                return false;\n            }\n        }\n        true\n    }\n\n    /// Test if a value is part of a set.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn contains<BA>(&self, a: &BA) -> bool\n    where\n        BA: Hash + Eq + ?Sized,\n        A: Borrow<BA>,\n    {\n        self.root.get(hash_key(&*self.hasher, a), 0, a).is_some()\n    }\n\n    /// Test whether a set is a subset of another set, meaning that\n    /// all values in our set must also be in the other set.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn is_subset<RS>(&self, other: RS) -> bool\n    where\n        RS: Borrow<Self>,\n    {\n        let o = other.borrow();\n        self.iter().all(|a| o.contains(&a))\n    }\n\n    /// Test whether a set is a proper subset of another set, meaning\n    /// that all values in our set must also be in the other set. A\n    /// proper subset must also be smaller than the other set.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn is_proper_subset<RS>(&self, other: RS) -> bool\n    where\n        RS: Borrow<Self>,\n    {\n        self.len() != other.borrow().len() && self.is_subset(other)\n    }\n}","impl<A, S> HashSet<A, S> {\n    /// Test whether a set is empty.\n    ///\n    /// Time: O(1)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashset::HashSet;\n    /// assert!(\n    ///   !hashset![1, 2, 3].is_empty()\n    /// );\n    /// assert!(\n    ///   HashSet::<i32>::new().is_empty()\n    /// );\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Get the size of a set.\n    ///\n    /// Time: O(1)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashset::HashSet;\n    /// assert_eq!(3, hashset![1, 2, 3].len());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn len(&self) -> usize {\n        self.size\n    }\n\n    /// Test whether two sets refer to the same content in memory.\n    ///\n    /// This is true if the two sides are references to the same set,\n    /// or if the two sets refer to the same root node.\n    ///\n    /// This would return true if you're comparing a set to itself, or\n    /// if you're comparing a set to a fresh clone of itself.\n    ///\n    /// Time: O(1)\n    pub fn ptr_eq(&self, other: &Self) -> bool {\n        std::ptr::eq(self, other) || PoolRef::ptr_eq(&self.root, &other.root)\n    }\n\n    /// Get a reference to the memory pool used by this set.\n    ///\n    /// Note that if you didn't specifically construct it with a pool, you'll\n    /// get back a reference to a pool of size 0.\n    #[cfg(feature = \"pool\")]\n    pub fn pool(&self) -> &HashSetPool<A> {\n        &self.pool\n    }\n\n    /// Construct an empty hash set using the provided hasher.\n    #[inline]\n    #[must_use]\n    pub fn with_hasher<RS>(hasher: RS) -> Self\n    where\n        Ref<S>: From<RS>,\n    {\n        let pool = HashSetPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashSet {\n            size: 0,\n            pool,\n            root,\n            hasher: From::from(hasher),\n        }\n    }\n\n    /// Construct an empty hash set using the provided memory pool and hasher.\n    #[cfg(feature = \"pool\")]\n    #[inline]\n    #[must_use]\n    pub fn with_pool_hasher<RS>(pool: &HashSetPool<A>, hasher: RS) -> Self\n    where\n        Ref<S>: From<RS>,\n    {\n        let root = PoolRef::default(&pool.0);\n        HashSet {\n            size: 0,\n            pool: pool.clone(),\n            root,\n            hasher: From::from(hasher),\n        }\n    }\n\n    /// Get a reference to the set's [`BuildHasher`][BuildHasher].\n    ///\n    /// [BuildHasher]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    #[must_use]\n    pub fn hasher(&self) -> &Ref<S> {\n        &self.hasher\n    }\n\n    /// Construct an empty hash set using the same hasher as the current hash set.\n    #[inline]\n    #[must_use]\n    pub fn new_from<A1>(&self) -> HashSet<A1, S>\n    where\n        A1: Hash + Eq + Clone,\n    {\n        let pool = HashSetPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashSet {\n            size: 0,\n            pool,\n            root,\n            hasher: self.hasher.clone(),\n        }\n    }\n\n    /// Discard all elements from the set.\n    ///\n    /// This leaves you with an empty set, and all elements that\n    /// were previously inside it are dropped.\n    ///\n    /// Time: O(n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::HashSet;\n    /// let mut set = hashset![1, 2, 3];\n    /// set.clear();\n    /// assert!(set.is_empty());\n    /// ```\n    pub fn clear(&mut self) {\n        if !self.is_empty() {\n            self.root = PoolRef::default(&self.pool.0);\n            self.size = 0;\n        }\n    }\n\n    /// Get an iterator over the values in a hash set.\n    ///\n    /// Please note that the order is consistent between sets using\n    /// the same hasher, but no other ordering guarantee is offered.\n    /// Items will not come out in insertion order or sort order.\n    /// They will, however, come out in the same order every time for\n    /// the same set.\n    #[must_use]\n    pub fn iter(&self) -> Iter<'_, A> {\n        Iter {\n            it: NodeIter::new(&self.root, self.size),\n        }\n    }\n}","impl<A, S> IntoIterator for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone,\n    S: BuildHasher,\n{\n    type Item = A;\n    type IntoIter = ConsumingIter<Self::Item>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        ConsumingIter {\n            it: NodeDrain::new(&self.pool.0, self.root, self.size),\n        }\n    }\n}","impl<A, S> Mul for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone,\n    S: BuildHasher,\n{\n    type Output = HashSet<A, S>;\n\n    fn mul(self, other: Self) -> Self::Output {\n        self.intersection(other)\n    }\n}","impl<A, S> Ord for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone + Ord,\n    S: BuildHasher + Default,\n{\n    fn cmp(&self, other: &Self) -> Ordering {\n        if Ref::ptr_eq(&self.hasher, &other.hasher) {\n            return self.iter().cmp(other.iter());\n        }\n        self.iter().cmp(other.iter())\n    }\n}","impl<A, S> PartialEq for HashSet<A, S>\nwhere\n    A: Hash + Eq,\n    S: BuildHasher + Default,\n{\n    fn eq(&self, other: &Self) -> bool {\n        self.test_eq(other)\n    }\n}","impl<A, S> PartialOrd for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone + PartialOrd,\n    S: BuildHasher + Default,\n{\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        if Ref::ptr_eq(&self.hasher, &other.hasher) {\n            return self.iter().partial_cmp(other.iter());\n        }\n        self.iter().partial_cmp(other.iter())\n    }\n}","impl<A, S> Sum for HashSet<A, S>\nwhere\n    A: Hash + Eq + Clone,\n    S: BuildHasher + Default,\n{\n    fn sum<I>(it: I) -> Self\n    where\n        I: Iterator<Item = Self>,\n    {\n        it.fold(Self::default(), |a, b| a + b)\n    }\n}","impl<A> HashSet<A, RandomState>\nwhere\n    A: Hash + Eq + Clone,\n{\n    /// Construct a set with a single value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::hashset::HashSet;\n    /// # use std::sync::Arc;\n    /// let set = HashSet::unit(123);\n    /// assert!(set.contains(&123));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn unit(a: A) -> Self {\n        HashSet::new().update(a)\n    }\n}","impl<A> HashSet<A, RandomState> {\n    /// Construct an empty set.\n    #[must_use]\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Construct an empty set using a specific memory pool.\n    #[cfg(feature = \"pool\")]\n    #[must_use]\n    pub fn with_pool(pool: &HashSetPool<A>) -> Self {\n        Self {\n            pool: pool.clone(),\n            hasher: Default::default(),\n            size: 0,\n            root: PoolRef::default(&pool.0),\n        }\n    }\n}"],"hash::set::HashSetPool":["impl<$($arg,)*> $name<$($arg,)*> {\n            /// Create a new pool with the given size.\n            pub fn new(size: usize) -> Self {\n                Self(Pool::new(size))\n            }\n\n            /// Fill the pool with preallocated chunks.\n            pub fn fill(&self) {\n                self.0.fill();\n            }\n\n            ///Get the current size of the pool.\n            pub fn pool_size(&self) -> usize {\n                self.0.get_pool_size()\n            }\n        }","impl<$($arg,)*> Clone for $name<$($arg,)*> {\n            fn clone(&self) -> Self {\n                Self(self.0.clone())\n            }\n        }","impl<$($arg,)*> Default for $name<$($arg,)*> {\n            fn default() -> Self {\n                Self::new($crate::config::POOL_SIZE)\n            }\n        }"],"hash::set::Iter":["impl<'a, A> ExactSizeIterator for Iter<'a, A> {}","impl<'a, A> FusedIterator for Iter<'a, A> {}","impl<'a, A> Iterator for Iter<'a, A>\nwhere\n    A: 'a,\n{\n    type Item = &'a A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|(v, _)| &v.0)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n}"],"hash::set::Value":["Clone","Copy","Debug","Eq","Ord","PartialEq","PartialOrd","impl<A> Deref for Value<A> {\n    type Target = A;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}","impl<A> HashValue for Value<A>\nwhere\n    A: Hash + Eq,\n{\n    type Key = A;\n\n    fn extract_key(&self) -> &Self::Key {\n        &self.0\n    }\n\n    fn ptr_eq(&self, _other: &Self) -> bool {\n        false\n    }\n}"],"nodes::btree::ConsumingIter":["impl<A: BTreeValue + Clone> ExactSizeIterator for ConsumingIter<A> {}","impl<A: Clone> ConsumingIter<A> {\n    pub(crate) fn new(root: &Node<A>, total: usize) -> Self {\n        ConsumingIter {\n            fwd_last: None,\n            fwd_stack: vec![ConsumingIterItem::Consider(root.clone())],\n            back_last: None,\n            back_stack: vec![ConsumingIterItem::Consider(root.clone())],\n            remaining: total,\n        }\n    }\n\n    fn push_node(stack: &mut Vec<ConsumingIterItem<A>>, maybe_node: Option<PoolRef<Node<A>>>) {\n        if let Some(node) = maybe_node {\n            stack.push(ConsumingIterItem::Consider(PoolRef::unwrap_or_clone(node)))\n        }\n    }\n\n    fn push(stack: &mut Vec<ConsumingIterItem<A>>, mut node: Node<A>) {\n        for _n in 0..node.keys.len() {\n            ConsumingIter::push_node(stack, node.children.pop_back());\n            stack.push(ConsumingIterItem::Yield(node.keys.pop_back()));\n        }\n        ConsumingIter::push_node(stack, node.children.pop_back());\n    }\n\n    fn push_fwd(&mut self, node: Node<A>) {\n        ConsumingIter::push(&mut self.fwd_stack, node)\n    }\n\n    fn push_node_back(&mut self, maybe_node: Option<PoolRef<Node<A>>>) {\n        if let Some(node) = maybe_node {\n            self.back_stack\n                .push(ConsumingIterItem::Consider(PoolRef::unwrap_or_clone(node)))\n        }\n    }\n\n    fn push_back(&mut self, mut node: Node<A>) {\n        for _i in 0..node.keys.len() {\n            self.push_node_back(node.children.pop_front());\n            self.back_stack\n                .push(ConsumingIterItem::Yield(node.keys.pop_front()));\n        }\n        self.push_node_back(node.children.pop_back());\n    }\n}","impl<A> DoubleEndedIterator for ConsumingIter<A>\nwhere\n    A: BTreeValue + Clone,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        loop {\n            match self.back_stack.pop() {\n                None => {\n                    self.remaining = 0;\n                    return None;\n                }\n                Some(ConsumingIterItem::Consider(node)) => self.push_back(node),\n                Some(ConsumingIterItem::Yield(value)) => {\n                    if let Some(ref last) = self.fwd_last {\n                        if value.cmp_values(last) != Ordering::Greater {\n                            self.fwd_stack.clear();\n                            self.back_stack.clear();\n                            self.remaining = 0;\n                            return None;\n                        }\n                    }\n                    self.remaining -= 1;\n                    self.back_last = Some(value.clone());\n                    return Some(value);\n                }\n            }\n        }\n    }\n}","impl<A> Iterator for ConsumingIter<A>\nwhere\n    A: BTreeValue + Clone,\n{\n    type Item = A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            match self.fwd_stack.pop() {\n                None => {\n                    self.remaining = 0;\n                    return None;\n                }\n                Some(ConsumingIterItem::Consider(node)) => self.push_fwd(node),\n                Some(ConsumingIterItem::Yield(value)) => {\n                    if let Some(ref last) = self.back_last {\n                        if value.cmp_values(last) != Ordering::Less {\n                            self.fwd_stack.clear();\n                            self.back_stack.clear();\n                            self.remaining = 0;\n                            return None;\n                        }\n                    }\n                    self.remaining -= 1;\n                    self.fwd_last = Some(value.clone());\n                    return Some(value);\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.remaining, Some(self.remaining))\n    }\n}"],"nodes::btree::DiffItem":["Debug","Eq","PartialEq"],"nodes::btree::DiffIter":["impl<'a, A: 'a> DiffIter<'a, A> {\n    pub(crate) fn new(old: &'a Node<A>, new: &'a Node<A>) -> Self {\n        DiffIter {\n            old_stack: if old.keys.is_empty() {\n                Vec::new()\n            } else {\n                vec![IterItem::Consider(old)]\n            },\n            new_stack: if new.keys.is_empty() {\n                Vec::new()\n            } else {\n                vec![IterItem::Consider(new)]\n            },\n        }\n    }\n\n    fn push_node(stack: &mut Vec<IterItem<'a, A>>, maybe_node: &'a Option<PoolRef<Node<A>>>) {\n        if let Some(ref node) = *maybe_node {\n            stack.push(IterItem::Consider(&node))\n        }\n    }\n\n    fn push(stack: &mut Vec<IterItem<'a, A>>, node: &'a Node<A>) {\n        for n in 0..node.keys.len() {\n            let i = node.keys.len() - n;\n            Self::push_node(stack, &node.children[i]);\n            stack.push(IterItem::Yield(&node.keys[i - 1]));\n        }\n        Self::push_node(stack, &node.children[0]);\n    }\n}","impl<'a, A> Iterator for DiffIter<'a, A>\nwhere\n    A: 'a + BTreeValue + PartialEq,\n{\n    type Item = DiffItem<'a, A>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            match (self.old_stack.pop(), self.new_stack.pop()) {\n                (None, None) => return None,\n                (None, Some(new)) => match new {\n                    IterItem::Consider(new) => Self::push(&mut self.new_stack, &new),\n                    IterItem::Yield(new) => return Some(DiffItem::Add(new)),\n                },\n                (Some(old), None) => match old {\n                    IterItem::Consider(old) => Self::push(&mut self.old_stack, &old),\n                    IterItem::Yield(old) => return Some(DiffItem::Remove(old)),\n                },\n                (Some(old), Some(new)) => match (old, new) {\n                    (IterItem::Consider(old), IterItem::Consider(new)) => {\n                        if !std::ptr::eq(old, new) {\n                            match old.keys[0].cmp_values(&new.keys[0]) {\n                                Ordering::Less => {\n                                    Self::push(&mut self.old_stack, &old);\n                                    self.new_stack.push(IterItem::Consider(new));\n                                }\n                                Ordering::Greater => {\n                                    self.old_stack.push(IterItem::Consider(old));\n                                    Self::push(&mut self.new_stack, &new);\n                                }\n                                Ordering::Equal => {\n                                    Self::push(&mut self.old_stack, &old);\n                                    Self::push(&mut self.new_stack, &new);\n                                }\n                            }\n                        }\n                    }\n                    (IterItem::Consider(old), IterItem::Yield(new)) => {\n                        Self::push(&mut self.old_stack, &old);\n                        self.new_stack.push(IterItem::Yield(new));\n                    }\n                    (IterItem::Yield(old), IterItem::Consider(new)) => {\n                        self.old_stack.push(IterItem::Yield(old));\n                        Self::push(&mut self.new_stack, &new);\n                    }\n                    (IterItem::Yield(old), IterItem::Yield(new)) => match old.cmp_values(&new) {\n                        Ordering::Less => {\n                            self.new_stack.push(IterItem::Yield(new));\n                            return Some(DiffItem::Remove(old));\n                        }\n                        Ordering::Equal => {\n                            if old != new {\n                                return Some(DiffItem::Update { old, new });\n                            }\n                        }\n                        Ordering::Greater => {\n                            self.old_stack.push(IterItem::Yield(old));\n                            return Some(DiffItem::Add(new));\n                        }\n                    },\n                },\n            }\n        }\n    }\n}"],"nodes::btree::Iter":["impl<'a, A: 'a + BTreeValue> DoubleEndedIterator for Iter<'a, A> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        match Iter::get(&self.back_path) {\n            None => None,\n            Some(value) => match Iter::get(&self.fwd_path) {\n                Some(last_value) if value.cmp_values(last_value) == Ordering::Less => None,\n                None => None,\n                Some(_) => {\n                    Iter::step_back(&mut self.back_path);\n                    self.remaining -= 1;\n                    Some(value)\n                }\n            },\n        }\n    }\n}","impl<'a, A: 'a + BTreeValue> Iterator for Iter<'a, A> {\n    type Item = &'a A;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match Iter::get(&self.fwd_path) {\n            None => None,\n            Some(value) => match Iter::get(&self.back_path) {\n                Some(last_value) if value.cmp_values(last_value) == Ordering::Greater => None,\n                None => None,\n                Some(_) => {\n                    Iter::step_forward(&mut self.fwd_path);\n                    self.remaining -= 1;\n                    Some(value)\n                }\n            },\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // (0, Some(self.remaining))\n        (0, None)\n    }\n}","impl<'a, A: BTreeValue> Iter<'a, A> {\n    pub(crate) fn new<R, BK>(root: &'a Node<A>, size: usize, range: R) -> Self\n    where\n        R: RangeBounds<BK>,\n        A::Key: Borrow<BK>,\n        BK: Ord + ?Sized,\n    {\n        let fwd_path = match range.start_bound() {\n            Bound::Included(key) => root.path_next(key, Vec::new()),\n            Bound::Excluded(key) => {\n                let mut path = root.path_next(key, Vec::new());\n                if let Some(value) = Self::get(&path) {\n                    if value.cmp_keys(key) == Ordering::Equal {\n                        Self::step_forward(&mut path);\n                    }\n                }\n                path\n            }\n            Bound::Unbounded => root.path_first(Vec::new()),\n        };\n        let back_path = match range.end_bound() {\n            Bound::Included(key) => root.path_prev(key, Vec::new()),\n            Bound::Excluded(key) => {\n                let mut path = root.path_prev(key, Vec::new());\n                if let Some(value) = Self::get(&path) {\n                    if value.cmp_keys(key) == Ordering::Equal {\n                        Self::step_back(&mut path);\n                    }\n                }\n                path\n            }\n            Bound::Unbounded => root.path_last(Vec::new()),\n        };\n        Iter {\n            fwd_path,\n            back_path,\n            remaining: size,\n        }\n    }\n\n    fn get(path: &[(&'a Node<A>, usize)]) -> Option<&'a A> {\n        match path.last() {\n            Some((node, index)) => Some(&node.keys[*index]),\n            None => None,\n        }\n    }\n\n    fn step_forward(path: &mut Vec<(&'a Node<A>, usize)>) -> Option<&'a A> {\n        match path.pop() {\n            Some((node, index)) => {\n                let index = index + 1;\n                match node.children[index] {\n                    // Child between current and next key -> step down\n                    Some(ref child) => {\n                        path.push((node, index));\n                        path.push((child, 0));\n                        let mut node = child;\n                        while let Some(ref left_child) = node.children[0] {\n                            path.push((left_child, 0));\n                            node = left_child;\n                        }\n                        Some(&node.keys[0])\n                    }\n                    None => match node.keys.get(index) {\n                        // Yield next key\n                        value @ Some(_) => {\n                            path.push((node, index));\n                            value\n                        }\n                        // No more keys -> exhausted level, step up and yield\n                        None => loop {\n                            match path.pop() {\n                                None => {\n                                    return None;\n                                }\n                                Some((node, index)) => {\n                                    if let value @ Some(_) = node.keys.get(index) {\n                                        path.push((node, index));\n                                        return value;\n                                    }\n                                }\n                            }\n                        },\n                    },\n                }\n            }\n            None => None,\n        }\n    }\n\n    fn step_back(path: &mut Vec<(&'a Node<A>, usize)>) -> Option<&'a A> {\n        match path.pop() {\n            Some((node, index)) => match node.children[index] {\n                Some(ref child) => {\n                    path.push((node, index));\n                    let mut end = child.keys.len() - 1;\n                    path.push((child, end));\n                    let mut node = child;\n                    while let Some(ref right_child) = node.children[end + 1] {\n                        end = right_child.keys.len() - 1;\n                        path.push((right_child, end));\n                        node = right_child;\n                    }\n                    Some(&node.keys[end])\n                }\n                None => {\n                    if index == 0 {\n                        loop {\n                            match path.pop() {\n                                None => {\n                                    return None;\n                                }\n                                Some((node, index)) => {\n                                    if index > 0 {\n                                        let index = index - 1;\n                                        path.push((node, index));\n                                        return Some(&node.keys[index]);\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        let index = index - 1;\n                        path.push((node, index));\n                        Some(&node.keys[index])\n                    }\n                }\n            },\n            None => None,\n        }\n    }\n}"],"nodes::btree::Node":["impl<A: BTreeValue> Node<A> {\n    fn child_contains<BK>(&self, index: usize, key: &BK) -> bool\n    where\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        if let Some(Some(ref child)) = self.children.get(index) {\n            child.lookup(key).is_some()\n        } else {\n            false\n        }\n    }\n\n    pub(crate) fn lookup<BK>(&self, key: &BK) -> Option<&A>\n    where\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        if self.keys.is_empty() {\n            return None;\n        }\n        // Perform a binary search, resulting in either a match or\n        // the index of the first higher key, meaning we search the\n        // child to the left of it.\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&self.keys[index]),\n            Err(index) => match self.children[index] {\n                None => None,\n                Some(ref node) => node.lookup(key),\n            },\n        }\n    }\n\n    pub(crate) fn lookup_mut<BK>(&mut self, pool: &Pool<Node<A>>, key: &BK) -> Option<&mut A>\n    where\n        A: Clone,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        if self.keys.is_empty() {\n            return None;\n        }\n        // Perform a binary search, resulting in either a match or\n        // the index of the first higher key, meaning we search the\n        // child to the left of it.\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&mut self.keys[index]),\n            Err(index) => match self.children[index] {\n                None => None,\n                Some(ref mut child_ref) => {\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    child.lookup_mut(pool, key)\n                }\n            },\n        }\n    }\n\n    pub(crate) fn lookup_prev<'a, BK>(&'a self, key: &BK) -> Option<&A>\n    where\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        if self.keys.is_empty() {\n            return None;\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&self.keys[index]),\n            Err(index) => match self.children[index] {\n                None if index == 0 => None,\n                None => match self.keys.get(index - 1) {\n                    Some(_) => Some(&self.keys[index - 1]),\n                    None => None,\n                },\n                Some(ref node) => node.lookup_prev(key),\n            },\n        }\n    }\n\n    pub(crate) fn lookup_next<'a, BK>(&'a self, key: &BK) -> Option<&A>\n    where\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        if self.keys.is_empty() {\n            return None;\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&self.keys[index]),\n            Err(index) => match self.children[index] {\n                None => match self.keys.get(index) {\n                    Some(_) => Some(&self.keys[index]),\n                    None => None,\n                },\n                Some(ref node) => node.lookup_next(key),\n            },\n        }\n    }\n\n    pub(crate) fn lookup_prev_mut<'a, BK>(\n        &'a mut self,\n        pool: &Pool<Node<A>>,\n        key: &BK,\n    ) -> Option<&mut A>\n    where\n        A: Clone,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        if self.keys.is_empty() {\n            return None;\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&mut self.keys[index]),\n            Err(index) => match self.children[index] {\n                None if index == 0 => None,\n                None => match self.keys.get(index - 1) {\n                    Some(_) => Some(&mut self.keys[index - 1]),\n                    None => None,\n                },\n                Some(ref mut node) => PoolRef::make_mut(pool, node).lookup_prev_mut(pool, key),\n            },\n        }\n    }\n\n    pub(crate) fn lookup_next_mut<'a, BK>(\n        &'a mut self,\n        pool: &Pool<Node<A>>,\n        key: &BK,\n    ) -> Option<&mut A>\n    where\n        A: Clone,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        if self.keys.is_empty() {\n            return None;\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&mut self.keys[index]),\n            Err(index) => match self.children[index] {\n                None => match self.keys.get(index) {\n                    Some(_) => Some(&mut self.keys[index]),\n                    None => None,\n                },\n                Some(ref mut node) => PoolRef::make_mut(pool, node).lookup_next_mut(pool, key),\n            },\n        }\n    }\n\n    pub(crate) fn path_first<'a, BK>(\n        &'a self,\n        mut path: Vec<(&'a Node<A>, usize)>,\n    ) -> Vec<(&'a Node<A>, usize)>\n    where\n        A: 'a,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        if self.keys.is_empty() {\n            return Vec::new();\n        }\n        match self.children[0] {\n            None => {\n                path.push((self, 0));\n                path\n            }\n            Some(ref node) => {\n                path.push((self, 0));\n                node.path_first(path)\n            }\n        }\n    }\n\n    pub(crate) fn path_last<'a, BK>(\n        &'a self,\n        mut path: Vec<(&'a Node<A>, usize)>,\n    ) -> Vec<(&'a Node<A>, usize)>\n    where\n        A: 'a,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        if self.keys.is_empty() {\n            return Vec::new();\n        }\n        let end = self.children.len() - 1;\n        match self.children[end] {\n            None => {\n                path.push((self, end - 1));\n                path\n            }\n            Some(ref node) => {\n                path.push((self, end));\n                node.path_last(path)\n            }\n        }\n    }\n\n    pub(crate) fn path_next<'a, BK>(\n        &'a self,\n        key: &BK,\n        mut path: Vec<(&'a Node<A>, usize)>,\n    ) -> Vec<(&'a Node<A>, usize)>\n    where\n        A: 'a,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        if self.keys.is_empty() {\n            return Vec::new();\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => {\n                path.push((self, index));\n                path\n            }\n            Err(index) => match self.children[index] {\n                None => match self.keys.get(index) {\n                    Some(_) => {\n                        path.push((self, index));\n                        path\n                    }\n                    None => Vec::new(),\n                },\n                Some(ref node) => {\n                    path.push((self, index));\n                    node.path_next(key, path)\n                }\n            },\n        }\n    }\n\n    pub(crate) fn path_prev<'a, BK>(\n        &'a self,\n        key: &BK,\n        mut path: Vec<(&'a Node<A>, usize)>,\n    ) -> Vec<(&'a Node<A>, usize)>\n    where\n        A: 'a,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        if self.keys.is_empty() {\n            return Vec::new();\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => {\n                path.push((self, index));\n                path\n            }\n            Err(index) => match self.children[index] {\n                None if index == 0 => Vec::new(),\n                None => match self.keys.get(index - 1) {\n                    Some(_) => {\n                        path.push((self, index));\n                        path\n                    }\n                    None => Vec::new(),\n                },\n                Some(ref node) => {\n                    path.push((self, index));\n                    node.path_prev(key, path)\n                }\n            },\n        }\n    }\n\n    fn split(\n        &mut self,\n        pool: &Pool<Node<A>>,\n        value: A,\n        ins_left: Option<Node<A>>,\n        ins_right: Option<Node<A>>,\n    ) -> Insert<A> {\n        let left_child = ins_left.map(|node| PoolRef::new(pool, node));\n        let right_child = ins_right.map(|node| PoolRef::new(pool, node));\n        let index = A::search_value(&self.keys, &value).unwrap_err();\n        let mut left_keys;\n        let mut left_children;\n        let mut right_keys;\n        let mut right_children;\n        let median;\n        match index.cmp(&MEDIAN) {\n            Ordering::Less => {\n                self.children[index] = left_child;\n\n                left_keys = Chunk::from_front(&mut self.keys, index);\n                left_keys.push_back(value);\n                left_keys.drain_from_front(&mut self.keys, MEDIAN - index - 1);\n\n                left_children = Chunk::from_front(&mut self.children, index + 1);\n                left_children.push_back(right_child);\n                left_children.drain_from_front(&mut self.children, MEDIAN - index - 1);\n\n                median = self.keys.pop_front();\n\n                right_keys = Chunk::drain_from(&mut self.keys);\n                right_children = Chunk::drain_from(&mut self.children);\n            }\n            Ordering::Greater => {\n                self.children[index] = left_child;\n\n                left_keys = Chunk::from_front(&mut self.keys, MEDIAN);\n                left_children = Chunk::from_front(&mut self.children, MEDIAN + 1);\n\n                median = self.keys.pop_front();\n\n                right_keys = Chunk::from_front(&mut self.keys, index - MEDIAN - 1);\n                right_keys.push_back(value);\n                right_keys.append(&mut self.keys);\n\n                right_children = Chunk::from_front(&mut self.children, index - MEDIAN);\n                right_children.push_back(right_child);\n                right_children.append(&mut self.children);\n            }\n            Ordering::Equal => {\n                left_keys = Chunk::from_front(&mut self.keys, MEDIAN);\n                left_children = Chunk::from_front(&mut self.children, MEDIAN);\n                left_children.push_back(left_child);\n\n                median = value;\n\n                right_keys = Chunk::drain_from(&mut self.keys);\n                right_children = Chunk::drain_from(&mut self.children);\n                right_children[0] = right_child;\n            }\n        }\n\n        debug_assert!(left_keys.len() == MEDIAN);\n        debug_assert!(left_children.len() == MEDIAN + 1);\n        debug_assert!(right_keys.len() == MEDIAN);\n        debug_assert!(right_children.len() == MEDIAN + 1);\n\n        Split(\n            Node {\n                keys: left_keys,\n                children: left_children,\n            },\n            median,\n            Node {\n                keys: right_keys,\n                children: right_children,\n            },\n        )\n    }\n\n    fn merge(middle: A, left: Node<A>, mut right: Node<A>) -> Node<A> {\n        let mut keys = left.keys;\n        keys.push_back(middle);\n        keys.append(&mut right.keys);\n        let mut children = left.children;\n        children.append(&mut right.children);\n        Node { keys, children }\n    }\n\n    fn pop_min(&mut self) -> (A, Option<PoolRef<Node<A>>>) {\n        let value = self.keys.pop_front();\n        let child = self.children.pop_front();\n        (value, child)\n    }\n\n    fn pop_max(&mut self) -> (A, Option<PoolRef<Node<A>>>) {\n        let value = self.keys.pop_back();\n        let child = self.children.pop_back();\n        (value, child)\n    }\n\n    fn push_min(&mut self, child: Option<PoolRef<Node<A>>>, value: A) {\n        self.keys.push_front(value);\n        self.children.push_front(child);\n    }\n\n    fn push_max(&mut self, child: Option<PoolRef<Node<A>>>, value: A) {\n        self.keys.push_back(value);\n        self.children.push_back(child);\n    }\n\n    pub(crate) fn insert(&mut self, pool: &Pool<Node<A>>, value: A) -> Insert<A>\n    where\n        A: Clone,\n    {\n        if self.keys.is_empty() {\n            self.keys.push_back(value);\n            self.children.push_back(None);\n            return Insert::Added;\n        }\n        let (median, left, right) = match A::search_value(&self.keys, &value) {\n            // Key exists in node\n            Ok(index) => {\n                return Insert::Replaced(mem::replace(&mut self.keys[index], value));\n            }\n            // Key is adjacent to some key in node\n            Err(index) => {\n                let has_room = self.has_room();\n                let action = match self.children[index] {\n                    // No child at location, this is the target node.\n                    None => InsertAt,\n                    // Child at location, pass it on.\n                    Some(ref mut child_ref) => {\n                        let child = PoolRef::make_mut(pool, child_ref);\n                        match child.insert(pool, value.clone()) {\n                            Insert::Added => AddedAction,\n                            Insert::Replaced(value) => ReplacedAction(value),\n                            Insert::Split(left, median, right) => InsertSplit(left, median, right),\n                        }\n                    }\n                };\n                match action {\n                    ReplacedAction(value) => return Insert::Replaced(value),\n                    AddedAction => {\n                        return Insert::Added;\n                    }\n                    InsertAt => {\n                        if has_room {\n                            self.keys.insert(index, value);\n                            self.children.insert(index + 1, None);\n                            return Insert::Added;\n                        } else {\n                            (value, None, None)\n                        }\n                    }\n                    InsertSplit(left, median, right) => {\n                        if has_room {\n                            self.children[index] = Some(PoolRef::new(pool, left));\n                            self.keys.insert(index, median);\n                            self.children\n                                .insert(index + 1, Some(PoolRef::new(pool, right)));\n                            return Insert::Added;\n                        } else {\n                            (median, Some(left), Some(right))\n                        }\n                    }\n                }\n            }\n        };\n        self.split(pool, median, left, right)\n    }\n\n    pub(crate) fn remove<BK>(&mut self, pool: &Pool<Node<A>>, key: &BK) -> Remove<A>\n    where\n        A: Clone,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        let index = A::search_key(&self.keys, key);\n        self.remove_index(pool, index, key)\n    }\n\n    fn remove_index<BK>(\n        &mut self,\n        pool: &Pool<Node<A>>,\n        index: Result<usize, usize>,\n        key: &BK,\n    ) -> Remove<A>\n    where\n        A: Clone,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        let action = match index {\n            // Key exists in node, remove it.\n            Ok(index) => {\n                match (&self.children[index], &self.children[index + 1]) {\n                    // If we're a leaf, just delete the entry.\n                    (&None, &None) => RemoveAction::DeleteAt(index),\n                    // If the left hand child has capacity, pull the predecessor up.\n                    (&Some(ref left), _) if !left.too_small() => {\n                        if left.is_leaf() {\n                            RemoveAction::PullUp(left.keys.len() - 1, index, index)\n                        } else {\n                            RemoveAction::StealFromLeft(index + 1)\n                        }\n                    }\n                    // If the right hand child has capacity, pull the successor up.\n                    (_, &Some(ref right)) if !right.too_small() => {\n                        if right.is_leaf() {\n                            RemoveAction::PullUp(0, index, index + 1)\n                        } else {\n                            RemoveAction::StealFromRight(index)\n                        }\n                    }\n                    // If neither child has capacity, we'll have to merge them.\n                    (&Some(_), &Some(_)) => RemoveAction::Merge(index),\n                    // If one child exists and the other doesn't, we're in a bad state.\n                    _ => unreachable!(),\n                }\n            }\n            // Key is adjacent to some key in node\n            Err(index) => match self.children[index] {\n                // No child at location means key isn't in map.\n                None => return Remove::NoChange,\n                // Child at location, but it's at minimum capacity.\n                Some(ref child) if child.too_small() => {\n                    let left = if index > 0 {\n                        self.children.get(index - 1)\n                    } else {\n                        None\n                    }; // index is usize and can't be negative, best make sure it never is.\n                    match (left, self.children.get(index + 1)) {\n                        // If it has a left sibling with capacity, steal a key from it.\n                        (Some(&Some(ref old_left)), _) if !old_left.too_small() => {\n                            RemoveAction::StealFromLeft(index)\n                        }\n                        // If it has a right sibling with capacity, same as above.\n                        (_, Some(&Some(ref old_right))) if !old_right.too_small() => {\n                            RemoveAction::StealFromRight(index)\n                        }\n                        // If it has neither, we'll have to merge it with a sibling.\n                        // If we have a right sibling, we'll merge with that.\n                        (_, Some(&Some(_))) => RemoveAction::MergeFirst(index),\n                        // If we have a left sibling, we'll merge with that.\n                        (Some(&Some(_)), _) => RemoveAction::MergeFirst(index - 1),\n                        // If none of the above, we're in a bad state.\n                        _ => unreachable!(),\n                    }\n                }\n                // Child at location, and it's big enough, we can recurse down.\n                Some(_) => RemoveAction::ContinueDown(index),\n            },\n        };\n        match action {\n            RemoveAction::DeleteAt(index) => {\n                let pair = self.keys.remove(index);\n                self.children.remove(index);\n                Remove::Removed(pair)\n            }\n            RemoveAction::PullUp(target_index, pull_to, child_index) => {\n                let children = &mut self.children;\n                let mut update = None;\n                let value;\n                if let Some(&mut Some(ref mut child_ref)) = children.get_mut(child_index) {\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    match child.remove_index(pool, Ok(target_index), key) {\n                        Remove::NoChange => unreachable!(),\n                        Remove::Removed(pulled_value) => {\n                            value = self.keys.set(pull_to, pulled_value);\n                        }\n                        Remove::Update(pulled_value, new_child) => {\n                            value = self.keys.set(pull_to, pulled_value);\n                            update = Some(new_child);\n                        }\n                    }\n                } else {\n                    unreachable!()\n                }\n                if let Some(new_child) = update {\n                    children[child_index] = Some(PoolRef::new(pool, new_child));\n                }\n                Remove::Removed(value)\n            }\n            RemoveAction::Merge(index) => {\n                let left = self.children.remove(index).unwrap();\n                let right = mem::replace(&mut self.children[index], None).unwrap();\n                let value = self.keys.remove(index);\n                let mut merged_child = Node::merge(\n                    value,\n                    PoolRef::unwrap_or_clone(left),\n                    PoolRef::unwrap_or_clone(right),\n                );\n                let (removed, new_child) = match merged_child.remove(pool, key) {\n                    Remove::NoChange => unreachable!(),\n                    Remove::Removed(removed) => (removed, merged_child),\n                    Remove::Update(removed, updated_child) => (removed, updated_child),\n                };\n                if self.keys.is_empty() {\n                    // If we've depleted the root node, the merged child becomes the root.\n                    Remove::Update(removed, new_child)\n                } else {\n                    self.children[index] = Some(PoolRef::new(pool, new_child));\n                    Remove::Removed(removed)\n                }\n            }\n            RemoveAction::StealFromLeft(index) => {\n                let mut update = None;\n                let out_value;\n                {\n                    let mut children = self.children.as_mut_slice()[index - 1..=index]\n                        .iter_mut()\n                        .map(|n| {\n                            if let Some(ref mut o) = *n {\n                                o\n                            } else {\n                                unreachable!()\n                            }\n                        });\n                    let left = PoolRef::make_mut(pool, children.next().unwrap());\n                    let child = PoolRef::make_mut(pool, children.next().unwrap());\n                    // Prepare the rebalanced node.\n                    child.push_min(\n                        left.children.last().unwrap().clone(),\n                        self.keys[index - 1].clone(),\n                    );\n                    match child.remove(pool, key) {\n                        Remove::NoChange => {\n                            // Key wasn't there, we need to revert the steal.\n                            child.pop_min();\n                            return Remove::NoChange;\n                        }\n                        Remove::Removed(value) => {\n                            // If we did remove something, we complete the rebalancing.\n                            let (left_value, _) = left.pop_max();\n                            self.keys[index - 1] = left_value;\n                            out_value = value;\n                        }\n                        Remove::Update(value, new_child) => {\n                            // If we did remove something, we complete the rebalancing.\n                            let (left_value, _) = left.pop_max();\n                            self.keys[index - 1] = left_value;\n                            update = Some(new_child);\n                            out_value = value;\n                        }\n                    }\n                }\n                if let Some(new_child) = update {\n                    self.children[index] = Some(PoolRef::new(pool, new_child));\n                }\n                Remove::Removed(out_value)\n            }\n            RemoveAction::StealFromRight(index) => {\n                let mut update = None;\n                let out_value;\n                {\n                    let mut children = self.children.as_mut_slice()[index..index + 2]\n                        .iter_mut()\n                        .map(|n| {\n                            if let Some(ref mut o) = *n {\n                                o\n                            } else {\n                                unreachable!()\n                            }\n                        });\n                    let child = PoolRef::make_mut(pool, children.next().unwrap());\n                    let right = PoolRef::make_mut(pool, children.next().unwrap());\n                    // Prepare the rebalanced node.\n                    child.push_max(right.children[0].clone(), self.keys[index].clone());\n                    match child.remove(pool, key) {\n                        Remove::NoChange => {\n                            // Key wasn't there, we need to revert the steal.\n                            child.pop_max();\n                            return Remove::NoChange;\n                        }\n                        Remove::Removed(value) => {\n                            // If we did remove something, we complete the rebalancing.\n                            let (right_value, _) = right.pop_min();\n                            self.keys[index] = right_value;\n                            out_value = value;\n                        }\n                        Remove::Update(value, new_child) => {\n                            // If we did remove something, we complete the rebalancing.\n                            let (right_value, _) = right.pop_min();\n                            self.keys[index] = right_value;\n                            update = Some(new_child);\n                            out_value = value;\n                        }\n                    }\n                }\n                if let Some(new_child) = update {\n                    self.children[index] = Some(PoolRef::new(pool, new_child));\n                }\n                Remove::Removed(out_value)\n            }\n            RemoveAction::MergeFirst(index) => {\n                if self.keys[index].cmp_keys(key) != Ordering::Equal\n                    && !self.child_contains(index, key)\n                    && !self.child_contains(index + 1, key)\n                {\n                    return Remove::NoChange;\n                }\n                let left = self.children.remove(index).unwrap();\n                let right = mem::replace(&mut self.children[index], None).unwrap();\n                let middle = self.keys.remove(index);\n                let mut merged = Node::merge(\n                    middle,\n                    PoolRef::unwrap_or_clone(left),\n                    PoolRef::unwrap_or_clone(right),\n                );\n                let update;\n                let out_value;\n                match merged.remove(pool, key) {\n                    Remove::NoChange => {\n                        panic!(\"nodes::btree::Node::remove: caught an absent key too late while merging\");\n                    }\n                    Remove::Removed(value) => {\n                        if self.keys.is_empty() {\n                            return Remove::Update(value, merged);\n                        }\n                        update = merged;\n                        out_value = value;\n                    }\n                    Remove::Update(value, new_child) => {\n                        if self.keys.is_empty() {\n                            return Remove::Update(value, new_child);\n                        }\n                        update = new_child;\n                        out_value = value;\n                    }\n                }\n                self.children[index] = Some(PoolRef::new(pool, update));\n                Remove::Removed(out_value)\n            }\n            RemoveAction::ContinueDown(index) => {\n                let mut update = None;\n                let out_value;\n                if let Some(&mut Some(ref mut child_ref)) = self.children.get_mut(index) {\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    match child.remove(pool, key) {\n                        Remove::NoChange => return Remove::NoChange,\n                        Remove::Removed(value) => {\n                            out_value = value;\n                        }\n                        Remove::Update(value, new_child) => {\n                            update = Some(new_child);\n                            out_value = value;\n                        }\n                    }\n                } else {\n                    unreachable!()\n                }\n                if let Some(new_child) = update {\n                    self.children[index] = Some(PoolRef::new(pool, new_child));\n                }\n                Remove::Removed(out_value)\n            }\n        }\n    }\n}","impl<A> Clone for Node<A>\nwhere\n    A: Clone,\n{\n    fn clone(&self) -> Self {\n        Node {\n            keys: self.keys.clone(),\n            children: self.children.clone(),\n        }\n    }\n}","impl<A> Default for Node<A> {\n    fn default() -> Self {\n        Node {\n            keys: Chunk::new(),\n            children: Chunk::unit(None),\n        }\n    }\n}","impl<A> Node<A> {\n    #[inline]\n    fn has_room(&self) -> bool {\n        self.keys.len() < NODE_SIZE\n    }\n\n    #[inline]\n    fn too_small(&self) -> bool {\n        self.keys.len() < MEDIAN\n    }\n\n    #[inline]\n    fn is_leaf(&self) -> bool {\n        self.children[0].is_none()\n    }\n\n    #[inline]\n    pub(crate) fn unit(value: A) -> Self {\n        Node {\n            keys: Chunk::unit(value),\n            children: Chunk::pair(None, None),\n        }\n    }\n\n    #[inline]\n    pub(crate) fn new_from_split(\n        pool: &Pool<Node<A>>,\n        left: Node<A>,\n        median: A,\n        right: Node<A>,\n    ) -> Self {\n        Node {\n            keys: Chunk::unit(median),\n            children: Chunk::pair(\n                Some(PoolRef::new(pool, left)),\n                Some(PoolRef::new(pool, right)),\n            ),\n        }\n    }\n\n    pub(crate) fn min(&self) -> Option<&A> {\n        match self.children.first().unwrap() {\n            None => self.keys.first(),\n            Some(ref child) => child.min(),\n        }\n    }\n\n    pub(crate) fn max(&self) -> Option<&A> {\n        match self.children.last().unwrap() {\n            None => self.keys.last(),\n            Some(ref child) => child.max(),\n        }\n    }\n}","impl<A> PoolClone for Node<A>\nwhere\n    A: Clone,\n{\n    #[cfg(feature = \"pool\")]\n    unsafe fn clone_uninit(&self, target: &mut mem::MaybeUninit<Self>) {\n        self.keys\n            .clone_uninit(cast_uninit(&mut (*target.as_mut_ptr()).keys));\n        self.children\n            .clone_uninit(cast_uninit(&mut (*target.as_mut_ptr()).children));\n    }\n}","impl<A> PoolDefault for Node<A> {\n    #[cfg(feature = \"pool\")]\n    unsafe fn default_uninit(target: &mut mem::MaybeUninit<Self>) {\n        let ptr: *mut Self = target.as_mut_ptr();\n        Chunk::default_uninit(cast_uninit(&mut (*ptr).keys));\n        Chunk::default_uninit(cast_uninit(&mut (*ptr).children));\n        (*ptr).children.push_back(None);\n    }\n}"],"nodes::chunk::Chunk":["impl<A> PoolClone for Chunk<A> where A: Clone {}","impl<A> PoolDefault for Chunk<A> {}"],"nodes::hamt::CollisionNode":["Clone","impl<A: HashValue> CollisionNode<A> {\n    fn new(hash: HashBits, value1: A, value2: A) -> Self {\n        CollisionNode {\n            hash,\n            data: vec![value1, value2],\n        }\n    }\n\n    #[inline]\n    fn len(&self) -> usize {\n        self.data.len()\n    }\n\n    fn get<BK>(&self, key: &BK) -> Option<&A>\n    where\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        for entry in &self.data {\n            if key == entry.extract_key().borrow() {\n                return Some(entry);\n            }\n        }\n        None\n    }\n\n    fn get_mut<BK>(&mut self, key: &BK) -> Option<&mut A>\n    where\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        for entry in &mut self.data {\n            if key == entry.extract_key().borrow() {\n                return Some(entry);\n            }\n        }\n        None\n    }\n\n    fn insert(&mut self, value: A) -> Option<A> {\n        for item in &mut self.data {\n            if value.extract_key() == item.extract_key() {\n                return Some(mem::replace(item, value));\n            }\n        }\n        self.data.push(value);\n        None\n    }\n\n    fn remove<BK>(&mut self, key: &BK) -> Option<A>\n    where\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        let mut loc = None;\n        for (index, item) in self.data.iter().enumerate() {\n            if key == item.extract_key().borrow() {\n                loc = Some(index);\n            }\n        }\n        if let Some(index) = loc {\n            Some(self.data.remove(index))\n        } else {\n            None\n        }\n    }\n\n    fn pop(&mut self) -> Entry<A> {\n        Entry::Value(self.data.pop().unwrap(), self.hash)\n    }\n}"],"nodes::hamt::Drain":["impl<A: HashValue> ExactSizeIterator for Drain<A> where A: Clone {}","impl<A: HashValue> FusedIterator for Drain<A> where A: Clone {}","impl<A> Drain<A>\nwhere\n    A: HashValue,\n{\n    pub(crate) fn new(pool: &Pool<Node<A>>, root: PoolRef<Node<A>>, size: usize) -> Self {\n        Drain {\n            count: size,\n            pool: pool.clone(),\n            stack: vec![],\n            current: root,\n            collision: None,\n        }\n    }\n}","impl<A> Iterator for Drain<A>\nwhere\n    A: HashValue + Clone,\n{\n    type Item = (A, HashBits);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.count == 0 {\n            return None;\n        }\n        if self.collision.is_some() {\n            if let Some(ref mut coll) = self.collision {\n                if let Some(value) = coll.data.pop() {\n                    self.count -= 1;\n                    return Some((value, coll.hash));\n                }\n            }\n            self.collision = None;\n            return self.next();\n        }\n        match PoolRef::make_mut(&self.pool, &mut self.current).data.pop() {\n            Some(Entry::Value(value, hash)) => {\n                self.count -= 1;\n                Some((value, hash))\n            }\n            Some(Entry::Collision(coll_ref)) => {\n                self.collision = Some(clone_ref(coll_ref));\n                self.next()\n            }\n            Some(Entry::Node(child)) => {\n                let parent = mem::replace(&mut self.current, child);\n                self.stack.push(parent);\n                self.next()\n            }\n            None => match self.stack.pop() {\n                None => None,\n                Some(parent) => {\n                    self.current = parent;\n                    self.next()\n                }\n            },\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.count, Some(self.count))\n    }\n}"],"nodes::hamt::Entry":["impl<A: Clone> Clone for Entry<A> {\n    fn clone(&self) -> Self {\n        match self {\n            Entry::Value(value, hash) => Entry::Value(value.clone(), *hash),\n            Entry::Collision(coll) => Entry::Collision(coll.clone()),\n            Entry::Node(node) => Entry::Node(node.clone()),\n        }\n    }\n}","impl<A> Entry<A> {\n    fn is_value(&self) -> bool {\n        match self {\n            Entry::Value(_, _) => true,\n            _ => false,\n        }\n    }\n\n    fn unwrap_value(self) -> A {\n        match self {\n            Entry::Value(a, _) => a,\n            _ => panic!(\"nodes::hamt::Entry::unwrap_value: unwrapped a non-value\"),\n        }\n    }\n\n    fn from_node(pool: &Pool<Node<A>>, node: Node<A>) -> Self {\n        Entry::Node(PoolRef::new(pool, node))\n    }\n}","impl<A> From<CollisionNode<A>> for Entry<A> {\n    fn from(node: CollisionNode<A>) -> Self {\n        Entry::Collision(Ref::new(node))\n    }\n}"],"nodes::hamt::Iter":["impl<'a, A> ExactSizeIterator for Iter<'a, A> where A: 'a {}","impl<'a, A> FusedIterator for Iter<'a, A> where A: 'a {}","impl<'a, A> Iter<'a, A>\nwhere\n    A: 'a,\n{\n    pub(crate) fn new(root: &'a Node<A>, size: usize) -> Self {\n        Iter {\n            count: size,\n            stack: Vec::with_capacity((HASH_WIDTH / HASH_SHIFT) + 1),\n            current: root.data.iter(),\n            collision: None,\n        }\n    }\n}","impl<'a, A> Iterator for Iter<'a, A>\nwhere\n    A: 'a,\n{\n    type Item = (&'a A, HashBits);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.count == 0 {\n            return None;\n        }\n        if self.collision.is_some() {\n            if let Some((hash, ref mut coll)) = self.collision {\n                match coll.next() {\n                    None => {}\n                    Some(value) => {\n                        self.count -= 1;\n                        return Some((value, hash));\n                    }\n                }\n            }\n            self.collision = None;\n            return self.next();\n        }\n        match self.current.next() {\n            Some(Entry::Value(value, hash)) => {\n                self.count -= 1;\n                Some((value, *hash))\n            }\n            Some(Entry::Node(child)) => {\n                let current = mem::replace(&mut self.current, child.data.iter());\n                self.stack.push(current);\n                self.next()\n            }\n            Some(Entry::Collision(coll)) => {\n                self.collision = Some((coll.hash, coll.data.iter()));\n                self.next()\n            }\n            None => match self.stack.pop() {\n                None => None,\n                Some(iter) => {\n                    self.current = iter;\n                    self.next()\n                }\n            },\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.count, Some(self.count))\n    }\n}"],"nodes::hamt::IterMut":["impl<'a, A> ExactSizeIterator for IterMut<'a, A> where A: Clone + 'a {}","impl<'a, A> FusedIterator for IterMut<'a, A> where A: Clone + 'a {}","impl<'a, A> IterMut<'a, A>\nwhere\n    A: 'a,\n{\n    pub(crate) fn new(pool: &Pool<Node<A>>, root: &'a mut Node<A>, size: usize) -> Self {\n        IterMut {\n            count: size,\n            pool: pool.clone(),\n            stack: Vec::with_capacity((HASH_WIDTH / HASH_SHIFT) + 1),\n            current: root.data.iter_mut(),\n            collision: None,\n        }\n    }\n}","impl<'a, A> Iterator for IterMut<'a, A>\nwhere\n    A: Clone + 'a,\n{\n    type Item = (&'a mut A, HashBits);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.count == 0 {\n            return None;\n        }\n        if self.collision.is_some() {\n            if let Some((hash, ref mut coll)) = self.collision {\n                match coll.next() {\n                    None => {}\n                    Some(value) => {\n                        self.count -= 1;\n                        return Some((value, hash));\n                    }\n                }\n            }\n            self.collision = None;\n            return self.next();\n        }\n        match self.current.next() {\n            Some(Entry::Value(value, hash)) => {\n                self.count -= 1;\n                Some((value, *hash))\n            }\n            Some(Entry::Node(child_ref)) => {\n                let child = PoolRef::make_mut(&self.pool, child_ref);\n                let current = mem::replace(&mut self.current, child.data.iter_mut());\n                self.stack.push(current);\n                self.next()\n            }\n            Some(Entry::Collision(coll_ref)) => {\n                let coll = Ref::make_mut(coll_ref);\n                self.collision = Some((coll.hash, coll.data.iter_mut()));\n                self.next()\n            }\n            None => match self.stack.pop() {\n                None => None,\n                Some(iter) => {\n                    self.current = iter;\n                    self.next()\n                }\n            },\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.count, Some(self.count))\n    }\n}"],"nodes::hamt::Node":["Clone","impl<A: HashValue + fmt::Debug> fmt::Debug for Node<A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"Node[ \")?;\n        for i in self.data.indices() {\n            write!(f, \"{}: \", i)?;\n            match &self.data[i] {\n                Entry::Value(v, h) => write!(f, \"{:?} :: {}, \", v, h)?,\n                Entry::Collision(c) => write!(f, \"Coll{:?} :: {}\", c.data, c.hash)?,\n                Entry::Node(n) => write!(f, \"{:?}, \", n)?,\n            }\n        }\n        write!(f, \" ]\")\n    }\n}","impl<A: HashValue> Node<A> {\n    fn merge_values(\n        pool: &Pool<Node<A>>,\n        value1: A,\n        hash1: HashBits,\n        value2: A,\n        hash2: HashBits,\n        shift: usize,\n    ) -> Self {\n        let index1 = mask(hash1, shift) as usize;\n        let index2 = mask(hash2, shift) as usize;\n        if index1 != index2 {\n            // Both values fit on the same level.\n            Node::pair(\n                index1,\n                Entry::Value(value1, hash1),\n                index2,\n                Entry::Value(value2, hash2),\n            )\n        } else if shift + HASH_SHIFT >= HASH_WIDTH {\n            // If we're at the bottom, we've got a collision.\n            Node::unit(\n                index1,\n                Entry::from(CollisionNode::new(hash1, value1, value2)),\n            )\n        } else {\n            // Pass the values down a level.\n            let node = Node::merge_values(pool, value1, hash1, value2, hash2, shift + HASH_SHIFT);\n            Node::single_child(pool, index1, node)\n        }\n    }\n\n    pub(crate) fn get<BK>(&self, hash: HashBits, shift: usize, key: &BK) -> Option<&A>\n    where\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        let index = mask(hash, shift) as usize;\n        if let Some(entry) = self.data.get(index) {\n            match entry {\n                Entry::Value(ref value, _) => {\n                    if key == value.extract_key().borrow() {\n                        Some(value)\n                    } else {\n                        None\n                    }\n                }\n                Entry::Collision(ref coll) => coll.get(key),\n                Entry::Node(ref child) => child.get(hash, shift + HASH_SHIFT, key),\n            }\n        } else {\n            None\n        }\n    }\n\n    pub(crate) fn get_mut<BK>(\n        &mut self,\n        pool: &Pool<Node<A>>,\n        hash: HashBits,\n        shift: usize,\n        key: &BK,\n    ) -> Option<&mut A>\n    where\n        A: Clone,\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        let index = mask(hash, shift) as usize;\n        if let Some(entry) = self.data.get_mut(index) {\n            match entry {\n                Entry::Value(ref mut value, _) => {\n                    if key == value.extract_key().borrow() {\n                        Some(value)\n                    } else {\n                        None\n                    }\n                }\n                Entry::Collision(ref mut coll_ref) => {\n                    let coll = Ref::make_mut(coll_ref);\n                    coll.get_mut(key)\n                }\n                Entry::Node(ref mut child_ref) => {\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    child.get_mut(pool, hash, shift + HASH_SHIFT, key)\n                }\n            }\n        } else {\n            None\n        }\n    }\n\n    pub(crate) fn insert(\n        &mut self,\n        pool: &Pool<Node<A>>,\n        hash: HashBits,\n        shift: usize,\n        value: A,\n    ) -> Option<A>\n    where\n        A: Clone,\n    {\n        let index = mask(hash, shift) as usize;\n        if let Some(entry) = self.data.get_mut(index) {\n            let mut fallthrough = false;\n            // Value is here\n            match entry {\n                // Update value or create a subtree\n                Entry::Value(ref current, _) => {\n                    if current.extract_key() == value.extract_key() {\n                        // If we have a key match, fall through to the outer\n                        // level where we replace the current value. If we\n                        // don't, fall through to the inner level where we merge\n                        // some nodes.\n                        fallthrough = true;\n                    }\n                }\n                // There's already a collision here.\n                Entry::Collision(ref mut collision) => {\n                    let coll = Ref::make_mut(collision);\n                    return coll.insert(value);\n                }\n                Entry::Node(ref mut child_ref) => {\n                    // Child node\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    return child.insert(pool, hash, shift + HASH_SHIFT, value);\n                }\n            }\n            if !fallthrough {\n                // If we get here, we're looking at a value entry that needs a merge.\n                // We're going to be unsafe and pry it out of the reference, trusting\n                // that we overwrite it with the merged node.\n                #[allow(unsafe_code)]\n                let old_entry = unsafe { ptr::read(entry) };\n                if shift + HASH_SHIFT >= HASH_WIDTH {\n                    // We're at the lowest level, need to set up a collision node.\n                    let coll = CollisionNode::new(hash, old_entry.unwrap_value(), value);\n                    #[allow(unsafe_code)]\n                    unsafe {\n                        ptr::write(entry, Entry::from(coll))\n                    };\n                } else if let Entry::Value(old_value, old_hash) = old_entry {\n                    let node = Node::merge_values(\n                        pool,\n                        old_value,\n                        old_hash,\n                        value,\n                        hash,\n                        shift + HASH_SHIFT,\n                    );\n                    #[allow(unsafe_code)]\n                    unsafe {\n                        ptr::write(entry, Entry::from_node(pool, node))\n                    };\n                } else {\n                    unreachable!()\n                }\n                return None;\n            }\n        }\n        // If we get here, either we found nothing at this index, in which case\n        // we insert a new entry, or we hit a value entry with the same key, in\n        // which case we replace it.\n        self.data\n            .insert(index, Entry::Value(value, hash))\n            .map(Entry::unwrap_value)\n    }\n\n    pub(crate) fn remove<BK>(\n        &mut self,\n        pool: &Pool<Node<A>>,\n        hash: HashBits,\n        shift: usize,\n        key: &BK,\n    ) -> Option<A>\n    where\n        A: Clone,\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,\n    {\n        let index = mask(hash, shift) as usize;\n        let mut new_node = None;\n        let mut removed = None;\n        if let Some(entry) = self.data.get_mut(index) {\n            match entry {\n                Entry::Value(ref value, _) => {\n                    if key != value.extract_key().borrow() {\n                        // Key wasn't in the map.\n                        return None;\n                    } // Otherwise, fall through to the removal.\n                }\n                Entry::Collision(ref mut coll_ref) => {\n                    let coll = Ref::make_mut(coll_ref);\n                    removed = coll.remove(key);\n                    if coll.len() == 1 {\n                        new_node = Some(coll.pop());\n                    } else {\n                        return removed;\n                    }\n                }\n                Entry::Node(ref mut child_ref) => {\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    match child.remove(pool, hash, shift + HASH_SHIFT, key) {\n                        None => {\n                            return None;\n                        }\n                        Some(value) => {\n                            if child.len() == 1\n                                && child.data[child.data.first_index().unwrap()].is_value()\n                            {\n                                // If the child now contains only a single value node,\n                                // pull it up one level and discard the child.\n                                removed = Some(value);\n                                new_node = Some(child.pop());\n                            } else {\n                                return Some(value);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if let Some(node) = new_node {\n            self.data.insert(index, node);\n            return removed;\n        }\n        self.data.remove(index).map(Entry::unwrap_value)\n    }\n}","impl<A> Default for Node<A> {\n    fn default() -> Self {\n        Self::new()\n    }\n}","impl<A> Node<A> {\n    #[inline]\n    pub(crate) fn new() -> Self {\n        Node {\n            data: SparseChunk::new(),\n        }\n    }\n\n    #[inline]\n    fn len(&self) -> usize {\n        self.data.len()\n    }\n\n    #[inline]\n    pub(crate) fn unit(index: usize, value: Entry<A>) -> Self {\n        Node {\n            data: SparseChunk::unit(index, value),\n        }\n    }\n\n    #[inline]\n    pub(crate) fn pair(index1: usize, value1: Entry<A>, index2: usize, value2: Entry<A>) -> Self {\n        Node {\n            data: SparseChunk::pair(index1, value1, index2, value2),\n        }\n    }\n\n    #[inline]\n    pub(crate) fn single_child(pool: &Pool<Node<A>>, index: usize, node: Self) -> Self {\n        Node {\n            data: SparseChunk::unit(index, Entry::from_node(pool, node)),\n        }\n    }\n\n    fn pop(&mut self) -> Entry<A> {\n        self.data.pop().unwrap()\n    }\n}","impl<A> PoolClone for Node<A>\nwhere\n    A: Clone,\n{\n    #[cfg(feature = \"pool\")]\n    unsafe fn clone_uninit(&self, target: &mut mem::MaybeUninit<Self>) {\n        self.data.clone_uninit(\n            target\n                .as_mut_ptr()\n                .cast::<mem::MaybeUninit<SparseChunk<Entry<A>, HashWidth>>>()\n                .as_mut()\n                .unwrap(),\n        )\n    }\n}","impl<A> PoolDefault for Node<A> {\n    #[cfg(feature = \"pool\")]\n    unsafe fn default_uninit(target: &mut mem::MaybeUninit<Self>) {\n        SparseChunk::default_uninit(\n            target\n                .as_mut_ptr()\n                .cast::<mem::MaybeUninit<SparseChunk<Entry<A>, HashWidth>>>()\n                .as_mut()\n                .unwrap(),\n        )\n    }\n}"],"nodes::rrb::Entry":["impl<A: Clone> Clone for Entry<A> {\n    fn clone(&self) -> Self {\n        match *self {\n            Nodes(ref size, ref nodes) => Nodes(size.clone(), nodes.clone()),\n            Values(ref values) => Values(values.clone()),\n            Empty => Empty,\n        }\n    }\n}","impl<A: Clone> Entry<A> {\n    fn len(&self) -> usize {\n        match self {\n            Nodes(_, ref nodes) => nodes.len(),\n            Values(ref values) => values.len(),\n            Empty => 0,\n        }\n    }\n\n    fn is_full(&self) -> bool {\n        match self {\n            Nodes(_, ref nodes) => nodes.is_full(),\n            Values(ref values) => values.is_full(),\n            Empty => false,\n        }\n    }\n\n    fn unwrap_values(&self) -> &Chunk<A> {\n        match self {\n            Values(ref values) => values,\n            _ => panic!(\"rrb::Entry::unwrap_values: expected values, found nodes\"),\n        }\n    }\n\n    fn unwrap_nodes(&self) -> &Chunk<Node<A>> {\n        match self {\n            Nodes(_, ref nodes) => nodes,\n            _ => panic!(\"rrb::Entry::unwrap_nodes: expected nodes, found values\"),\n        }\n    }\n\n    fn unwrap_values_mut(&mut self, pool: &RRBPool<A>) -> &mut Chunk<A> {\n        match self {\n            Values(ref mut values) => PoolRef::make_mut(&pool.value_pool, values),\n            _ => panic!(\"rrb::Entry::unwrap_values_mut: expected values, found nodes\"),\n        }\n    }\n\n    fn unwrap_nodes_mut(&mut self, pool: &RRBPool<A>) -> &mut Chunk<Node<A>> {\n        match self {\n            Nodes(_, ref mut nodes) => PoolRef::make_mut(&pool.node_pool, nodes),\n            _ => panic!(\"rrb::Entry::unwrap_nodes_mut: expected nodes, found values\"),\n        }\n    }\n\n    fn values(self) -> Chunk<A> {\n        match self {\n            Values(values) => PoolRef::unwrap_or_clone(values),\n            _ => panic!(\"rrb::Entry::values: expected values, found nodes\"),\n        }\n    }\n\n    fn nodes(self) -> Chunk<Node<A>> {\n        match self {\n            Nodes(_, nodes) => PoolRef::unwrap_or_clone(nodes),\n            _ => panic!(\"rrb::Entry::nodes: expected nodes, found values\"),\n        }\n    }\n\n    fn is_empty_node(&self) -> bool {\n        match self {\n            Empty => true,\n            _ => false,\n        }\n    }\n}"],"nodes::rrb::Node":["impl<A: Clone> Clone for Node<A> {\n    fn clone(&self) -> Self {\n        Node {\n            children: self.children.clone(),\n        }\n    }\n}","impl<A: Clone> Default for Node<A> {\n    fn default() -> Self {\n        Self::new()\n    }\n}","impl<A: Clone> Node<A> {\n    pub(crate) fn new() -> Self {\n        Node { children: Empty }\n    }\n\n    pub(crate) fn parent(pool: &RRBPool<A>, level: usize, children: Chunk<Self>) -> Self {\n        let size = {\n            let mut size = Size::Size(0);\n            let mut it = children.iter().peekable();\n            loop {\n                match it.next() {\n                    None => break,\n                    Some(child) => {\n                        if size.is_size()\n                            && !child.is_completely_dense(level - 1)\n                            && it.peek().is_some()\n                        {\n                            size = Size::table_from_size(&pool.size_pool, level, size.size());\n                        }\n                        size.push(&pool.size_pool, Right, level, child.len())\n                    }\n                }\n            }\n            size\n        };\n        Node {\n            children: Nodes(size, PoolRef::new(&pool.node_pool, children)),\n        }\n    }\n\n    pub(crate) fn clear_node(&mut self) {\n        self.children = Empty;\n    }\n\n    pub(crate) fn from_chunk(pool: &RRBPool<A>, level: usize, chunk: PoolRef<Chunk<A>>) -> Self {\n        let node = Node {\n            children: Values(chunk),\n        };\n        node.elevate(pool, level)\n    }\n\n    pub(crate) fn single_parent(pool: &RRBPool<A>, node: Self) -> Self {\n        let size = if node.is_dense() {\n            Size::Size(node.len())\n        } else {\n            let size_table = Chunk::unit(node.len());\n            Size::Table(PoolRef::new(&pool.size_pool, size_table))\n        };\n        let children = PoolRef::new(&pool.node_pool, Chunk::unit(node));\n        Node {\n            children: Nodes(size, children),\n        }\n    }\n\n    pub(crate) fn join_dense(pool: &RRBPool<A>, left: Self, right: Self) -> Self {\n        let left_len = left.len();\n        let right_len = right.len();\n        Node {\n            children: {\n                let children = PoolRef::new(&pool.node_pool, Chunk::pair(left, right));\n                Nodes(Size::Size(left_len + right_len), children)\n            },\n        }\n    }\n\n    pub(crate) fn elevate(self, pool: &RRBPool<A>, level_increment: usize) -> Self {\n        if level_increment > 0 {\n            Self::single_parent(pool, self.elevate(pool, level_increment - 1))\n        } else {\n            self\n        }\n    }\n\n    pub(crate) fn join_branches(self, pool: &RRBPool<A>, right: Self, level: usize) -> Self {\n        let left_len = self.len();\n        let right_len = right.len();\n        let size = if self.is_completely_dense(level) && right.is_dense() {\n            Size::Size(left_len + right_len)\n        } else {\n            let size_table = Chunk::pair(left_len, left_len + right_len);\n            Size::Table(PoolRef::new(&pool.size_pool, size_table))\n        };\n        Node {\n            children: {\n                let children = Chunk::pair(self, right);\n                Nodes(size, PoolRef::new(&pool.node_pool, children))\n            },\n        }\n    }\n\n    pub(crate) fn len(&self) -> usize {\n        match self.children {\n            Entry::Nodes(Size::Size(size), _) => size,\n            Entry::Nodes(Size::Table(ref size_table), _) => *(size_table.last().unwrap_or(&0)),\n            Entry::Values(ref values) => values.len(),\n            Entry::Empty => 0,\n        }\n    }\n\n    pub(crate) fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    pub(crate) fn is_single(&self) -> bool {\n        self.children.len() == 1\n    }\n\n    pub(crate) fn is_full(&self) -> bool {\n        self.children.is_full()\n    }\n\n    #[allow(dead_code)] // this is only used by tests\n    pub(crate) fn number_of_children(&self) -> usize {\n        self.children.len()\n    }\n\n    pub(crate) fn first_child(&self) -> &Self {\n        self.children.unwrap_nodes().first().unwrap()\n    }\n\n    /// True if the node is dense and so doesn't have a size table\n    fn is_dense(&self) -> bool {\n        match self.children {\n            Entry::Nodes(Size::Table(_), _) => false,\n            _ => true,\n        }\n    }\n\n    /// True if the node and its children are dense and at capacity\n    // TODO can use this technique to quickly test if a Size::Table\n    // should be converted back to a Size::Size\n    fn is_completely_dense(&self, level: usize) -> bool {\n        // Size of a full node is NODE_SIZE at level 0, NODE_SIZE at\n        // level 1, etc.\n        if let Some(expected_size) = NODE_SIZE.checked_pow(level as u32 + 1) {\n            self.size() == expected_size\n        } else {\n            // We overflowed a usize, there's no way we can be completely dense as we know the size\n            // fits in a usize.\n            false\n        }\n    }\n\n    #[inline]\n    fn size(&self) -> usize {\n        match self.children {\n            Entry::Nodes(ref size, _) => size.size(),\n            Entry::Values(ref values) => values.len(),\n            Entry::Empty => 0,\n        }\n    }\n\n    #[inline]\n    fn push_size(&mut self, pool: &RRBPool<A>, side: Side, level: usize, value: usize) {\n        if let Entry::Nodes(ref mut size, _) = self.children {\n            size.push(&pool.size_pool, side, level, value)\n        }\n    }\n\n    #[inline]\n    fn pop_size(&mut self, pool: &RRBPool<A>, side: Side, level: usize, value: usize) {\n        if let Entry::Nodes(ref mut size, _) = self.children {\n            size.pop(&pool.size_pool, side, level, value)\n        }\n    }\n\n    #[inline]\n    fn update_size(&mut self, pool: &RRBPool<A>, index: usize, level: usize, value: isize) {\n        if let Entry::Nodes(ref mut size, _) = self.children {\n            size.update(&pool.size_pool, index, level, value)\n        }\n    }\n\n    fn size_up_to(&self, level: usize, index: usize) -> usize {\n        if let Entry::Nodes(ref size, _) = self.children {\n            if index == 0 {\n                0\n            } else {\n                match size {\n                    Size::Table(ref size_table) => size_table[index - 1],\n                    Size::Size(_) => index * NODE_SIZE.pow(level as u32),\n                }\n            }\n        } else {\n            index\n        }\n    }\n\n    fn index_in(&self, level: usize, index: usize) -> Option<usize> {\n        let mut target_idx = if let Some(child_size) = NODE_SIZE.checked_pow(level as u32) {\n            index / child_size\n        } else {\n            0\n        };\n        if target_idx >= self.children.len() {\n            return None;\n        }\n        if let Entry::Nodes(Size::Table(ref size_table), _) = self.children {\n            while size_table[target_idx] <= index {\n                target_idx += 1;\n                if target_idx >= size_table.len() {\n                    return None;\n                }\n            }\n        }\n        Some(target_idx)\n    }\n\n    pub(crate) fn index(&self, level: usize, index: usize) -> &A {\n        if level == 0 {\n            &self.children.unwrap_values()[index]\n        } else {\n            let target_idx = self.index_in(level, index).unwrap();\n            self.children.unwrap_nodes()[target_idx]\n                .index(level - 1, index - self.size_up_to(level, target_idx))\n        }\n    }\n\n    pub(crate) fn index_mut(&mut self, pool: &RRBPool<A>, level: usize, index: usize) -> &mut A {\n        if level == 0 {\n            &mut self.children.unwrap_values_mut(pool)[index]\n        } else {\n            let target_idx = self.index_in(level, index).unwrap();\n            let offset = index - self.size_up_to(level, target_idx);\n            let child = &mut self.children.unwrap_nodes_mut(pool)[target_idx];\n            child.index_mut(pool, level - 1, offset)\n        }\n    }\n\n    pub(crate) fn lookup_chunk(\n        &self,\n        level: usize,\n        base: usize,\n        index: usize,\n    ) -> (Range<usize>, *const Chunk<A>) {\n        if level == 0 {\n            (\n                base..(base + self.children.len()),\n                self.children.unwrap_values() as *const Chunk<A>,\n            )\n        } else {\n            let target_idx = self.index_in(level, index).unwrap();\n            let offset = self.size_up_to(level, target_idx);\n            let child_base = base + offset;\n            let children = self.children.unwrap_nodes();\n            let child = &children[target_idx];\n            child.lookup_chunk(level - 1, child_base, index - offset)\n        }\n    }\n\n    pub(crate) fn lookup_chunk_mut(\n        &mut self,\n        pool: &RRBPool<A>,\n        level: usize,\n        base: usize,\n        index: usize,\n    ) -> (Range<usize>, *mut Chunk<A>) {\n        if level == 0 {\n            (\n                base..(base + self.children.len()),\n                self.children.unwrap_values_mut(pool) as *mut Chunk<A>,\n            )\n        } else {\n            let target_idx = self.index_in(level, index).unwrap();\n            let offset = self.size_up_to(level, target_idx);\n            let child_base = base + offset;\n            let children = self.children.unwrap_nodes_mut(pool);\n            let child = &mut children[target_idx];\n            child.lookup_chunk_mut(pool, level - 1, child_base, index - offset)\n        }\n    }\n\n    fn push_child_node(&mut self, pool: &RRBPool<A>, side: Side, child: Node<A>) {\n        let children = self.children.unwrap_nodes_mut(pool);\n        match side {\n            Left => children.push_front(child),\n            Right => children.push_back(child),\n        }\n    }\n\n    fn pop_child_node(&mut self, pool: &RRBPool<A>, side: Side) -> Node<A> {\n        let children = self.children.unwrap_nodes_mut(pool);\n        match side {\n            Left => children.pop_front(),\n            Right => children.pop_back(),\n        }\n    }\n\n    pub(crate) fn push_chunk(\n        &mut self,\n        pool: &RRBPool<A>,\n        level: usize,\n        side: Side,\n        mut chunk: PoolRef<Chunk<A>>,\n    ) -> PushResult<PoolRef<Chunk<A>>> {\n        if chunk.is_empty() {\n            return PushResult::Done;\n        }\n        let is_full = self.is_full();\n        if level == 0 {\n            if self.children.is_empty_node() {\n                self.push_size(pool, side, level, chunk.len());\n                self.children = Values(chunk);\n                PushResult::Done\n            } else {\n                let values = self.children.unwrap_values_mut(pool);\n                if values.len() + chunk.len() <= NODE_SIZE {\n                    let chunk = PoolRef::make_mut(&pool.value_pool, &mut chunk);\n                    match side {\n                        Side::Left => {\n                            chunk.append(values);\n                            values.append(chunk);\n                        }\n                        Side::Right => values.append(chunk),\n                    }\n                    PushResult::Done\n                } else {\n                    PushResult::Full(chunk, 0)\n                }\n            }\n        } else if level == 1 {\n            // If rightmost existing node has any room, merge as much as\n            // possible over from the new node.\n            let num_drained = match side {\n                Side::Right => {\n                    if let Entry::Nodes(ref mut size, ref mut children) = self.children {\n                        let rightmost = PoolRef::make_mut(&pool.node_pool, children)\n                            .last_mut()\n                            .unwrap();\n                        let old_size = rightmost.len();\n                        let chunk = PoolRef::make_mut(&pool.value_pool, &mut chunk);\n                        let values = rightmost.children.unwrap_values_mut(pool);\n                        let to_drain = chunk.len().min(NODE_SIZE - values.len());\n                        values.drain_from_front(chunk, to_drain);\n                        size.pop(&pool.size_pool, Side::Right, level, old_size);\n                        size.push(&pool.size_pool, Side::Right, level, values.len());\n                        to_drain\n                    } else {\n                        0\n                    }\n                }\n                Side::Left => {\n                    if let Entry::Nodes(ref mut size, ref mut children) = self.children {\n                        let leftmost = PoolRef::make_mut(&pool.node_pool, children)\n                            .first_mut()\n                            .unwrap();\n                        let old_size = leftmost.len();\n                        let chunk = PoolRef::make_mut(&pool.value_pool, &mut chunk);\n                        let values = leftmost.children.unwrap_values_mut(pool);\n                        let to_drain = chunk.len().min(NODE_SIZE - values.len());\n                        values.drain_from_back(chunk, to_drain);\n                        size.pop(&pool.size_pool, Side::Left, level, old_size);\n                        size.push(&pool.size_pool, Side::Left, level, values.len());\n                        to_drain\n                    } else {\n                        0\n                    }\n                }\n            };\n            if is_full {\n                PushResult::Full(chunk, num_drained)\n            } else {\n                // If the chunk is empty after being drained, there might be\n                // more space in existing chunks. To keep the middle dense, we\n                // do not add it here.\n                if !chunk.is_empty() {\n                    if side == Left && chunk.len() < NODE_SIZE {\n                        if let Entry::Nodes(ref mut size, _) = self.children {\n                            if let Size::Size(value) = *size {\n                                *size = Size::table_from_size(&pool.size_pool, level, value);\n                            }\n                        }\n                    }\n                    self.push_size(pool, side, level, chunk.len());\n                    self.push_child_node(pool, side, Node::from_chunk(pool, 0, chunk));\n                }\n                PushResult::Done\n            }\n        } else {\n            let chunk_size = chunk.len();\n            let index = match side {\n                Right => self.children.len() - 1,\n                Left => 0,\n            };\n            let new_child = {\n                let children = self.children.unwrap_nodes_mut(pool);\n                let child = &mut children[index];\n                match child.push_chunk(pool, level - 1, side, chunk) {\n                    PushResult::Done => None,\n                    PushResult::Full(chunk, num_drained) => {\n                        // Our chunk was too large for `child`, so it could not\n                        // be pushed there. However, exactly `num_drained`\n                        // elements were added to the child. We need to reflect\n                        // that change in the size field of the node.\n                        match side {\n                            Right => match self.children {\n                                Entry::Nodes(Size::Table(ref mut sizes), _) => {\n                                    let sizes = PoolRef::make_mut(&pool.size_pool, sizes);\n                                    sizes[index] += num_drained;\n                                }\n                                Entry::Nodes(Size::Size(ref mut size), _) => {\n                                    *size += num_drained;\n                                }\n                                Entry::Values(_) | Entry::Empty => (),\n                            },\n                            Left => {\n                                self.update_size(pool, 0, level, num_drained as isize);\n                            }\n                        }\n                        if is_full {\n                            return PushResult::Full(chunk, 0);\n                        } else {\n                            Some(Node::from_chunk(pool, level - 1, chunk))\n                        }\n                    }\n                }\n            };\n            match new_child {\n                None => {\n                    self.update_size(pool, index, level, chunk_size as isize);\n                    PushResult::Done\n                }\n                Some(child) => {\n                    if side == Left && chunk_size < NODE_SIZE {\n                        if let Entry::Nodes(ref mut size, _) = self.children {\n                            if let Size::Size(value) = *size {\n                                *size = Size::table_from_size(&pool.size_pool, level, value);\n                            }\n                        }\n                    }\n                    self.push_size(pool, side, level, child.len());\n                    self.push_child_node(pool, side, child);\n                    PushResult::Done\n                }\n            }\n        }\n    }\n\n    pub(crate) fn pop_chunk(\n        &mut self,\n        pool: &RRBPool<A>,\n        level: usize,\n        side: Side,\n    ) -> PopResult<PoolRef<Chunk<A>>> {\n        if self.is_empty() {\n            return PopResult::Empty;\n        }\n        if level == 0 {\n            // should only get here if the tree is just one leaf node\n            match replace(&mut self.children, Empty) {\n                Values(chunk) => PopResult::Drained(chunk),\n                Empty => panic!(\"rrb::Node::pop_chunk: non-empty tree with Empty leaf\"),\n                Nodes(_, _) => panic!(\"rrb::Node::pop_chunk: branch node at leaf\"),\n            }\n        } else if level == 1 {\n            let child_node = self.pop_child_node(pool, side);\n            self.pop_size(pool, side, level, child_node.len());\n            let chunk = match child_node.children {\n                Values(ref chunk) => chunk.clone(),\n                Empty => panic!(\"rrb::Node::pop_chunk: non-empty tree with Empty leaf\"),\n                Nodes(_, _) => panic!(\"rrb::Node::pop_chunk: branch node at leaf\"),\n            };\n            if self.is_empty() {\n                PopResult::Drained(chunk)\n            } else {\n                PopResult::Done(chunk)\n            }\n        } else {\n            let index = match side {\n                Right => self.children.len() - 1,\n                Left => 0,\n            };\n            let mut drained = false;\n            let chunk = {\n                let children = self.children.unwrap_nodes_mut(pool);\n                let child = &mut children[index];\n                match child.pop_chunk(pool, level - 1, side) {\n                    PopResult::Empty => return PopResult::Empty,\n                    PopResult::Done(chunk) => chunk,\n                    PopResult::Drained(chunk) => {\n                        drained = true;\n                        chunk\n                    }\n                }\n            };\n            if drained {\n                self.pop_size(pool, side, level, chunk.len());\n                self.pop_child_node(pool, side);\n                if self.is_empty() {\n                    PopResult::Drained(chunk)\n                } else {\n                    PopResult::Done(chunk)\n                }\n            } else {\n                self.update_size(pool, index, level, -(chunk.len() as isize));\n                PopResult::Done(chunk)\n            }\n        }\n    }\n\n    pub(crate) fn split(\n        &mut self,\n        pool: &RRBPool<A>,\n        level: usize,\n        drop_side: Side,\n        index: usize,\n    ) -> SplitResult {\n        if index == 0 && drop_side == Side::Left {\n            // Dropped nothing\n            return SplitResult::Dropped(0);\n        }\n        if level > 0 && index == 0 && drop_side == Side::Right {\n            // Dropped everything\n            let dropped = if let Entry::Nodes(ref size, _) = self.children {\n                size.size()\n            } else {\n                panic!(\"leaf node at non-leaf level!\");\n            };\n            self.children = Entry::Empty;\n            return SplitResult::Dropped(dropped);\n        }\n        let mut dropped;\n        if level == 0 {\n            let len = self.children.len();\n            if index >= len {\n                return SplitResult::OutOfBounds;\n            }\n            let children = self.children.unwrap_values_mut(pool);\n            match drop_side {\n                Side::Left => children.drop_left(index),\n                Side::Right => children.drop_right(index),\n            }\n            SplitResult::Dropped(match drop_side {\n                Left => index,\n                Right => len - index,\n            })\n        } else if let Some(target_idx) = self.index_in(level, index) {\n            let size_up_to = self.size_up_to(level, target_idx);\n            let (size, children) =\n                if let Entry::Nodes(ref mut size, ref mut children) = self.children {\n                    (size, PoolRef::make_mut(&pool.node_pool, children))\n                } else {\n                    unreachable!()\n                };\n            let child_gone = 0 == {\n                let child_node = &mut children[target_idx];\n                match child_node.split(pool, level - 1, drop_side, index - size_up_to) {\n                    SplitResult::OutOfBounds => return SplitResult::OutOfBounds,\n                    SplitResult::Dropped(amount) => dropped = amount,\n                }\n                child_node.len()\n            };\n            match drop_side {\n                Left => {\n                    let mut drop_from = target_idx;\n                    if child_gone {\n                        drop_from += 1;\n                    }\n                    children.drop_left(drop_from);\n                    if let Size::Size(value) = *size {\n                        *size = Size::table_from_size(&pool.size_pool, level, value);\n                    }\n                    let size_table = if let Size::Table(ref mut size_ref) = size {\n                        PoolRef::make_mut(&pool.size_pool, size_ref)\n                    } else {\n                        unreachable!()\n                    };\n                    let dropped_size = if target_idx > 0 {\n                        size_table[target_idx - 1]\n                    } else {\n                        0\n                    };\n                    dropped += dropped_size;\n                    size_table.drop_left(drop_from);\n                    for i in size_table.iter_mut() {\n                        *i -= dropped;\n                    }\n                }\n                Right => {\n                    let at_last = target_idx == children.len() - 1;\n                    let mut drop_from = target_idx + 1;\n                    if child_gone {\n                        drop_from -= 1;\n                    }\n                    if drop_from < children.len() {\n                        children.drop_right(drop_from);\n                    }\n                    match size {\n                        Size::Size(ref mut size) if at_last => {\n                            *size -= dropped;\n                        }\n                        Size::Size(ref mut size) => {\n                            let size_per_child = NODE_SIZE.pow(level as u32);\n                            let remainder = (target_idx + 1) * size_per_child;\n                            let new_size = remainder - dropped;\n                            if new_size < *size {\n                                dropped = *size - new_size;\n                                *size = new_size;\n                            } else {\n                                unreachable!(\n                                    \"this means node is empty, should be caught at start of method\"\n                                );\n                            }\n                        }\n                        Size::Table(ref mut size_ref) => {\n                            let size_table = PoolRef::make_mut(&pool.size_pool, size_ref);\n                            let dropped_size =\n                                size_table[size_table.len() - 1] - size_table[target_idx];\n                            if drop_from < size_table.len() {\n                                size_table.drop_right(drop_from);\n                            }\n                            if !child_gone {\n                                size_table[target_idx] -= dropped;\n                            }\n                            dropped += dropped_size;\n                        }\n                    }\n                }\n            }\n            SplitResult::Dropped(dropped)\n        } else {\n            SplitResult::OutOfBounds\n        }\n    }\n\n    fn merge_leaves(pool: &RRBPool<A>, mut left: Self, mut right: Self) -> Self {\n        if left.children.is_empty_node() {\n            // Left is empty, just use right\n            Self::single_parent(pool, right)\n        } else if right.children.is_empty_node() {\n            // Right is empty, just use left\n            Self::single_parent(pool, left)\n        } else {\n            {\n                let left_vals = left.children.unwrap_values_mut(pool);\n                let left_len = left_vals.len();\n                let right_vals = right.children.unwrap_values_mut(pool);\n                let right_len = right_vals.len();\n                if left_len + right_len <= NODE_SIZE {\n                    left_vals.append(right_vals);\n                } else {\n                    let count = right_len.min(NODE_SIZE - left_len);\n                    left_vals.drain_from_front(right_vals, count);\n                }\n            }\n            if right.is_empty() {\n                Self::single_parent(pool, left)\n            } else {\n                Self::join_dense(pool, left, right)\n            }\n        }\n    }\n\n    fn merge_rebalance(\n        pool: &RRBPool<A>,\n        level: usize,\n        left: Self,\n        middle: Self,\n        right: Self,\n    ) -> Self {\n        let left_nodes = left.children.nodes().into_iter();\n        let middle_nodes = middle.children.nodes().into_iter();\n        let right_nodes = right.children.nodes().into_iter();\n        let mut subtree_still_balanced = true;\n        let mut next_leaf = Chunk::new();\n        let mut next_node = Chunk::new();\n        let mut next_subtree = Chunk::new();\n        let mut root = Chunk::new();\n\n        for subtree in left_nodes.chain(middle_nodes).chain(right_nodes) {\n            if subtree.is_empty() {\n                continue;\n            }\n            if subtree.is_completely_dense(level) && subtree_still_balanced {\n                root.push_back(subtree);\n                continue;\n            }\n            subtree_still_balanced = false;\n\n            if level == 1 {\n                for value in subtree.children.values() {\n                    next_leaf.push_back(value);\n                    if next_leaf.is_full() {\n                        let new_node =\n                            Node::from_chunk(pool, 0, PoolRef::new(&pool.value_pool, next_leaf));\n                        next_subtree.push_back(new_node);\n                        next_leaf = Chunk::new();\n                        if next_subtree.is_full() {\n                            let new_subtree = Node::parent(pool, level, next_subtree);\n                            root.push_back(new_subtree);\n                            next_subtree = Chunk::new();\n                        }\n                    }\n                }\n            } else {\n                for node in subtree.children.nodes() {\n                    next_node.push_back(node);\n                    if next_node.is_full() {\n                        let new_node = Node::parent(pool, level - 1, next_node);\n                        next_subtree.push_back(new_node);\n                        next_node = Chunk::new();\n                        if next_subtree.is_full() {\n                            let new_subtree = Node::parent(pool, level, next_subtree);\n                            root.push_back(new_subtree);\n                            next_subtree = Chunk::new();\n                        }\n                    }\n                }\n            }\n        }\n        if !next_leaf.is_empty() {\n            let new_node = Node::from_chunk(pool, 0, PoolRef::new(&pool.value_pool, next_leaf));\n            next_subtree.push_back(new_node);\n        }\n        if !next_node.is_empty() {\n            let new_node = Node::parent(pool, level - 1, next_node);\n            next_subtree.push_back(new_node);\n        }\n        if !next_subtree.is_empty() {\n            let new_subtree = Node::parent(pool, level, next_subtree);\n            root.push_back(new_subtree);\n        }\n        Node::parent(pool, level + 1, root)\n    }\n\n    pub(crate) fn merge(pool: &RRBPool<A>, mut left: Self, mut right: Self, level: usize) -> Self {\n        if level == 0 {\n            Self::merge_leaves(pool, left, right)\n        } else {\n            let merged = {\n                if level == 1 {\n                    // We're going to rebalance all the leaves anyway, there's\n                    // no need for a middle at level 1\n                    Node::parent(pool, 0, Chunk::new())\n                } else {\n                    let left_last =\n                        if let Entry::Nodes(ref mut size, ref mut children) = left.children {\n                            let node = PoolRef::make_mut(&pool.node_pool, children).pop_back();\n                            if !node.is_empty() {\n                                size.pop(&pool.size_pool, Side::Right, level, node.len());\n                            }\n                            node\n                        } else {\n                            panic!(\"expected nodes, found entries or empty\");\n                        };\n                    let right_first =\n                        if let Entry::Nodes(ref mut size, ref mut children) = right.children {\n                            let node = PoolRef::make_mut(&pool.node_pool, children).pop_front();\n                            if !node.is_empty() {\n                                size.pop(&pool.size_pool, Side::Left, level, node.len());\n                            }\n                            node\n                        } else {\n                            panic!(\"expected nodes, found entries or empty\");\n                        };\n                    Self::merge(pool, left_last, right_first, level - 1)\n                }\n            };\n            Self::merge_rebalance(pool, level, left, merged, right)\n        }\n    }\n\n    #[cfg(any(test, feature = \"debug\"))]\n    pub(crate) fn assert_invariants(&self, level: usize) -> usize {\n        // Verifies that the size table matches reality.\n        match self.children {\n            Entry::Empty => 0,\n            Entry::Values(ref values) => {\n                // An empty value node is pointless and should never occur.\n                assert_ne!(0, values.len());\n                // Value nodes should only occur at level 0.\n                assert_eq!(0, level);\n                values.len()\n            }\n            Entry::Nodes(ref size, ref children) => {\n                // A parent node with no children should never occur.\n                assert_ne!(0, children.len());\n                // Parent nodes should never occur at level 0.\n                assert_ne!(0, level);\n                let mut lengths = Vec::new();\n                let should_be_dense = if let Size::Size(_) = size {\n                    true\n                } else {\n                    false\n                };\n                for (index, child) in children.iter().enumerate() {\n                    let len = child.assert_invariants(level - 1);\n                    if should_be_dense && index < children.len() - 1 {\n                        // Assert that non-end nodes without size tables are full.\n                        assert_eq!(len, NODE_SIZE.pow(level as u32));\n                    }\n                    lengths.push(len);\n                }\n                match size {\n                    Size::Size(size) => {\n                        let total: usize = lengths.iter().sum();\n                        assert_eq!(*size, total);\n                    }\n                    Size::Table(ref table) => {\n                        assert_eq!(table.iter().len(), children.len());\n                        for (index, current) in table.iter().enumerate() {\n                            let expected: usize = lengths.iter().take(index + 1).sum();\n                            assert_eq!(expected, *current);\n                        }\n                    }\n                }\n                lengths.iter().sum()\n            }\n        }\n    }\n\n    // pub fn print<W>(&self, f: &mut W, indent: usize, level: usize) -> Result<(), fmt::Error>\n    // where\n    //     W: fmt::Write,\n    //     A: fmt::Debug,\n    // {\n    //     print_indent(f, indent)?;\n    //     if level == 0 {\n    //         if self.children.is_empty_node() {\n    //             writeln!(f, \"Leaf: EMPTY\")\n    //         } else {\n    //             writeln!(f, \"Leaf: {:?}\", self.children.unwrap_values())\n    //         }\n    //     } else {\n    //         match &self.children {\n    //             Entry::Nodes(size, children) => {\n    //                 writeln!(f, \"Node level {} size_table {:?}\", level, size)?;\n    //                 for child in children.iter() {\n    //                     child.print(f, indent + 4, level - 1)?;\n    //                 }\n    //                 Ok(())\n    //             }\n    //             _ => unreachable!(),\n    //         }\n    //     }\n    // }\n}"],"nodes::rrb::Size":["Debug","impl Clone for Size {\n    fn clone(&self) -> Self {\n        match *self {\n            Size::Size(size) => Size::Size(size),\n            Size::Table(ref table) => Size::Table(table.clone()),\n        }\n    }\n}","impl Size {\n    fn size(&self) -> usize {\n        match self {\n            Size::Size(s) => *s,\n            Size::Table(sizes) => *sizes.last().unwrap_or(&0),\n        }\n    }\n\n    fn is_size(&self) -> bool {\n        match self {\n            Size::Size(_) => true,\n            Size::Table(_) => false,\n        }\n    }\n\n    fn table_from_size(pool: &Pool<Chunk<usize>>, level: usize, size: usize) -> Self {\n        let mut chunk = Chunk::new();\n        let mut remaining = size;\n        if let Some(child_size) = NODE_SIZE.checked_pow(level as u32) {\n            while remaining > child_size {\n                let next_value = chunk.last().unwrap_or(&0) + child_size;\n                chunk.push_back(next_value);\n                remaining -= child_size;\n            }\n        }\n        if remaining > 0 {\n            let next_value = chunk.last().unwrap_or(&0) + remaining;\n            chunk.push_back(next_value);\n        }\n        Size::Table(PoolRef::new(pool, chunk))\n    }\n\n    fn push(&mut self, pool: &Pool<Chunk<usize>>, side: Side, level: usize, value: usize) {\n        let size = match self {\n            Size::Size(ref mut size) => match side {\n                Left => *size,\n                Right => {\n                    *size += value;\n                    return;\n                }\n            },\n            Size::Table(ref mut size_ref) => {\n                let size_table = PoolRef::make_mut(pool, size_ref);\n                debug_assert!(size_table.len() < NODE_SIZE);\n                match side {\n                    Left => {\n                        for entry in size_table.iter_mut() {\n                            *entry += value;\n                        }\n                        size_table.push_front(value);\n                    }\n                    Right => {\n                        let prev = *(size_table.last().unwrap_or(&0));\n                        size_table.push_back(value + prev);\n                    }\n                }\n                return;\n            }\n        };\n        *self = Size::table_from_size(pool, level, size);\n        self.push(pool, side, level, value);\n    }\n\n    fn pop(&mut self, pool: &Pool<Chunk<usize>>, side: Side, level: usize, value: usize) {\n        let size = match self {\n            Size::Size(ref mut size) => match side {\n                Left => *size,\n                Right => {\n                    *size -= value;\n                    return;\n                }\n            },\n            Size::Table(ref mut size_ref) => {\n                let size_table = PoolRef::make_mut(pool, size_ref);\n                match side {\n                    Left => {\n                        let first = size_table.pop_front();\n                        debug_assert_eq!(value, first);\n                        for entry in size_table.iter_mut() {\n                            *entry -= value;\n                        }\n                    }\n                    Right => {\n                        let pop = size_table.pop_back();\n                        let last = size_table.last().unwrap_or(&0);\n                        debug_assert_eq!(value, pop - last);\n                    }\n                }\n                return;\n            }\n        };\n        *self = Size::table_from_size(pool, level, size);\n        self.pop(pool, side, level, value);\n    }\n\n    fn update(&mut self, pool: &Pool<Chunk<usize>>, index: usize, level: usize, value: isize) {\n        let size = match self {\n            Size::Size(ref size) => *size,\n            Size::Table(ref mut size_ref) => {\n                let size_table = PoolRef::make_mut(pool, size_ref);\n                for entry in size_table.iter_mut().skip(index) {\n                    *entry = (*entry as isize + value) as usize;\n                }\n                return;\n            }\n        };\n        *self = Size::table_from_size(pool, level, size);\n        self.update(pool, index, level, value);\n    }\n}"],"ord::map::DiffItem":["Debug","Eq","PartialEq"],"ord::map::DiffIter":["impl<'a, K, V> Iterator for DiffIter<'a, K, V>\nwhere\n    (K, V): 'a + BTreeValue + PartialEq,\n{\n    type Item = DiffItem<'a, K, V>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|item| match item {\n            NodeDiffItem::Add((k, v)) => DiffItem::Add(k, v),\n            NodeDiffItem::Update {\n                old: (oldk, oldv),\n                new: (newk, newv),\n            } => DiffItem::Update {\n                old: (oldk, oldv),\n                new: (newk, newv),\n            },\n            NodeDiffItem::Remove((k, v)) => DiffItem::Remove(k, v),\n        })\n    }\n}"],"ord::map::Entry":["impl<'a, K, V> Entry<'a, K, V>\nwhere\n    K: Ord + Clone,\n    V: Clone,\n{\n    /// Insert the default value provided if there was no value\n    /// already, and return a mutable reference to the value.\n    pub fn or_insert(self, default: V) -> &'a mut V {\n        self.or_insert_with(|| default)\n    }\n\n    /// Insert the default value from the provided function if there\n    /// was no value already, and return a mutable reference to the\n    /// value.\n    pub fn or_insert_with<F>(self, default: F) -> &'a mut V\n    where\n        F: FnOnce() -> V,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default()),\n        }\n    }\n\n    /// Insert a default value if there was no value already, and\n    /// return a mutable reference to the value.\n    pub fn or_default(self) -> &'a mut V\n    where\n        V: Default,\n    {\n        self.or_insert_with(Default::default)\n    }\n\n    /// Get the key for this entry.\n    #[must_use]\n    pub fn key(&self) -> &K {\n        match self {\n            Entry::Occupied(entry) => entry.key(),\n            Entry::Vacant(entry) => entry.key(),\n        }\n    }\n\n    /// Call the provided function to modify the value if the value\n    /// exists.\n    pub fn and_modify<F>(mut self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n        match &mut self {\n            Entry::Occupied(ref mut entry) => f(entry.get_mut()),\n            Entry::Vacant(_) => (),\n        }\n        self\n    }\n}"],"ord::map::Iter":["impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V>\nwhere\n    (K, V): 'a + BTreeValue,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.it.next_back().map(|(k, v)| (k, v))\n    }\n}","impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> where (K, V): 'a + BTreeValue {}","impl<'a, K, V> Iterator for Iter<'a, K, V>\nwhere\n    (K, V): 'a + BTreeValue,\n{\n    type Item = (&'a K, &'a V);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|(k, v)| (k, v))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.it.remaining, Some(self.it.remaining))\n    }\n}"],"ord::map::Keys":["impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V>\nwhere\n    K: 'a + Ord,\n    V: 'a,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        match self.it.next_back() {\n            None => None,\n            Some((k, _)) => Some(k),\n        }\n    }\n}","impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V>\nwhere\n    K: 'a + Ord,\n    V: 'a,\n{\n}","impl<'a, K, V> Iterator for Keys<'a, K, V>\nwhere\n    K: 'a + Ord,\n    V: 'a,\n{\n    type Item = &'a K;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|(k, _)| k)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n}"],"ord::map::OccupiedEntry":["impl<'a, K, V> OccupiedEntry<'a, K, V>\nwhere\n    K: 'a + Ord + Clone,\n    V: 'a + Clone,\n{\n    /// Get the key for this entry.\n    #[must_use]\n    pub fn key(&self) -> &K {\n        &self.key\n    }\n\n    /// Remove this entry from the map and return the removed mapping.\n    pub fn remove_entry(self) -> (K, V) {\n        self.map\n            .remove_with_key(&self.key)\n            .expect(\"ordmap::OccupiedEntry::remove_entry: key has vanished!\")\n    }\n\n    /// Get the current value.\n    #[must_use]\n    pub fn get(&self) -> &V {\n        self.map.get(&self.key).unwrap()\n    }\n\n    /// Get a mutable reference to the current value.\n    #[must_use]\n    pub fn get_mut(&mut self) -> &mut V {\n        self.map.get_mut(&self.key).unwrap()\n    }\n\n    /// Convert this entry into a mutable reference.\n    #[must_use]\n    pub fn into_mut(self) -> &'a mut V {\n        self.map.get_mut(&self.key).unwrap()\n    }\n\n    /// Overwrite the current value.\n    pub fn insert(&mut self, value: V) -> V {\n        mem::replace(self.get_mut(), value)\n    }\n\n    /// Remove this entry from the map and return the removed value.\n    pub fn remove(self) -> V {\n        self.remove_entry().1\n    }\n}"],"ord::map::OrdMap":["impl<'a, BK, K, V> Index<&'a BK> for OrdMap<K, V>\nwhere\n    BK: Ord + ?Sized,\n    K: Ord + Borrow<BK>,\n{\n    type Output = V;\n\n    fn index(&self, key: &BK) -> &Self::Output {\n        match self.root.lookup(key) {\n            None => panic!(\"OrdMap::index: invalid key\"),\n            Some(&(_, ref value)) => value,\n        }\n    }\n}","impl<'a, BK, K, V> IndexMut<&'a BK> for OrdMap<K, V>\nwhere\n    BK: Ord + ?Sized,\n    K: Ord + Clone + Borrow<BK>,\n    V: Clone,\n{\n    fn index_mut(&mut self, key: &BK) -> &mut Self::Output {\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        match root.lookup_mut(&self.pool.0, key) {\n            None => panic!(\"OrdMap::index: invalid key\"),\n            Some(&mut (_, ref mut value)) => value,\n        }\n    }\n}","impl<'a, K, V, OK, OV, RK, RV> From<&'a collections::HashMap<RK, RV>> for OrdMap<K, V>\nwhere\n    K: Ord + Clone + From<OK>,\n    V: Clone + From<OV>,\n    OK: Borrow<RK>,\n    OV: Borrow<RV>,\n    RK: Hash + Eq + ToOwned<Owned = OK>,\n    RV: ToOwned<Owned = OV>,\n{\n    fn from(m: &'a collections::HashMap<RK, RV>) -> OrdMap<K, V> {\n        m.iter()\n            .map(|(k, v)| (k.to_owned(), v.to_owned()))\n            .collect()\n    }\n}","impl<'a, K, V, RK, RV, OK, OV> From<&'a [(RK, RV)]> for OrdMap<K, V>\nwhere\n    K: Ord + Clone + From<OK>,\n    V: Clone + From<OV>,\n    OK: Borrow<RK>,\n    OV: Borrow<RV>,\n    RK: ToOwned<Owned = OK>,\n    RV: ToOwned<Owned = OV>,\n{\n    fn from(m: &'a [(RK, RV)]) -> OrdMap<K, V> {\n        m.iter()\n            .map(|&(ref k, ref v)| (k.to_owned(), v.to_owned()))\n            .collect()\n    }\n}","impl<'a, K: Ord + Hash + Eq + Clone, V: Clone, S: BuildHasher> From<&'a HashMap<K, V, S>>\n    for OrdMap<K, V>\n{\n    fn from(m: &'a HashMap<K, V, S>) -> Self {\n        m.iter().map(|(k, v)| (k.clone(), v.clone())).collect()\n    }\n}","impl<'a, K: Ord, V, RK, RV, OK, OV> From<&'a Vec<(RK, RV)>> for OrdMap<K, V>\nwhere\n    K: Ord + Clone + From<OK>,\n    V: Clone + From<OV>,\n    OK: Borrow<RK>,\n    OV: Borrow<RV>,\n    RK: ToOwned<Owned = OK>,\n    RV: ToOwned<Owned = OV>,\n{\n    fn from(m: &'a Vec<(RK, RV)>) -> OrdMap<K, V> {\n        m.iter()\n            .map(|&(ref k, ref v)| (k.to_owned(), v.to_owned()))\n            .collect()\n    }\n}","impl<'a, K: Ord, V, RK, RV, OK, OV> From<&'a collections::BTreeMap<RK, RV>> for OrdMap<K, V>\nwhere\n    K: Ord + Clone + From<OK>,\n    V: Clone + From<OV>,\n    OK: Borrow<RK>,\n    OV: Borrow<RV>,\n    RK: Ord + ToOwned<Owned = OK>,\n    RV: ToOwned<Owned = OV>,\n{\n    fn from(m: &'a collections::BTreeMap<RK, RV>) -> OrdMap<K, V> {\n        m.iter()\n            .map(|(k, v)| (k.to_owned(), v.to_owned()))\n            .collect()\n    }\n}","impl<'m, 'k, 'v, K, V, OK, OV> From<&'m OrdMap<&'k K, &'v V>> for OrdMap<OK, OV>\nwhere\n    K: Ord + ToOwned<Owned = OK> + ?Sized,\n    V: ToOwned<Owned = OV> + ?Sized,\n    OK: Ord + Clone + Borrow<K>,\n    OV: Clone + Borrow<V>,\n{\n    fn from(m: &OrdMap<&K, &V>) -> Self {\n        m.iter()\n            .map(|(k, v)| ((*k).to_owned(), (*v).to_owned()))\n            .collect()\n    }\n}","impl<K, V, RK, RV> Extend<(RK, RV)> for OrdMap<K, V>\nwhere\n    K: Ord + Clone + From<RK>,\n    V: Clone + From<RV>,\n{\n    fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = (RK, RV)>,\n    {\n        for (key, value) in iter {\n            self.insert(From::from(key), From::from(value));\n        }\n    }\n}","impl<K, V, RK, RV> From<Vec<(RK, RV)>> for OrdMap<K, V>\nwhere\n    K: Ord + Clone + From<RK>,\n    V: Clone + From<RV>,\n{\n    fn from(m: Vec<(RK, RV)>) -> OrdMap<K, V> {\n        m.into_iter().collect()\n    }\n}","impl<K, V, RK, RV> FromIterator<(RK, RV)> for OrdMap<K, V>\nwhere\n    K: Ord + Clone + From<RK>,\n    V: Clone + From<RV>,\n{\n    fn from_iter<T>(i: T) -> Self\n    where\n        T: IntoIterator<Item = (RK, RV)>,\n    {\n        let mut m = OrdMap::default();\n        for (k, v) in i {\n            m.insert(From::from(k), From::from(v));\n        }\n        m\n    }\n}","impl<K, V> Add for OrdMap<K, V>\nwhere\n    K: Ord + Clone,\n    V: Clone,\n{\n    type Output = OrdMap<K, V>;\n\n    fn add(self, other: Self) -> Self::Output {\n        self.union(other)\n    }\n}","impl<K, V> AsRef<OrdMap<K, V>> for OrdMap<K, V> {\n    fn as_ref(&self) -> &Self {\n        self\n    }\n}","impl<K, V> Clone for OrdMap<K, V> {\n    /// Clone a map.\n    ///\n    /// Time: O(1)\n    #[inline]\n    fn clone(&self) -> Self {\n        OrdMap {\n            size: self.size,\n            pool: self.pool.clone(),\n            root: self.root.clone(),\n        }\n    }\n}","impl<K, V> Debug for OrdMap<K, V>\nwhere\n    K: Ord + Debug,\n    V: Debug,\n{\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        let mut d = f.debug_map();\n        for (k, v) in self.iter() {\n            d.entry(k, v);\n        }\n        d.finish()\n    }\n}","impl<K, V> Default for OrdMap<K, V> {\n    fn default() -> Self {\n        Self::new()\n    }\n}","impl<K, V> Hash for OrdMap<K, V>\nwhere\n    K: Ord + Hash,\n    V: Hash,\n{\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for i in self.iter() {\n            i.hash(state);\n        }\n    }\n}","impl<K, V> IntoIterator for OrdMap<K, V>\nwhere\n    K: Ord + Clone,\n    V: Clone,\n{\n    type Item = (K, V);\n    type IntoIter = ConsumingIter<(K, V)>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        ConsumingIter::new(&self.root, self.size)\n    }\n}","impl<K, V> Ord for OrdMap<K, V>\nwhere\n    K: Ord,\n    V: Ord,\n{\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.iter().cmp(other.iter())\n    }\n}","impl<K, V> OrdMap<K, V>\nwhere\n    K: Ord + Clone,\n    V: Clone,\n{\n    /// Get a mutable reference to the value for a key from a map.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let mut map = ordmap!{123 => \"lol\"};\n    /// if let Some(value) = map.get_mut(&123) {\n    ///     *value = \"omg\";\n    /// }\n    /// assert_eq!(\n    ///   map.get(&123),\n    ///   Some(&\"omg\")\n    /// );\n    /// ```\n    #[must_use]\n    pub fn get_mut<BK>(&mut self, key: &BK) -> Option<&mut V>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        root.lookup_mut(&self.pool.0, key).map(|(_, v)| v)\n    }\n\n    /// Get the closest smaller entry in a map to a given key\n    /// as a mutable reference.\n    ///\n    /// If the map contains the given key, this is returned.\n    /// Otherwise, the closest key in the map smaller than the\n    /// given value is returned. If the smallest key in the map\n    /// is larger than the given key, `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::OrdMap;\n    /// let mut map = ordmap![1 => 1, 3 => 3, 5 => 5];\n    /// if let Some((key, value)) = map.get_prev_mut(&4) {\n    ///     *value = 4;\n    /// }\n    /// assert_eq!(ordmap![1 => 1, 3 => 4, 5 => 5], map);\n    /// ```\n    #[must_use]\n    pub fn get_prev_mut<BK>(&mut self, key: &BK) -> Option<(&K, &mut V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        let pool = &self.pool.0;\n        PoolRef::make_mut(pool, &mut self.root)\n            .lookup_prev_mut(pool, key)\n            .map(|(ref k, ref mut v)| (k, v))\n    }\n\n    /// Get the closest larger entry in a map to a given key\n    /// as a mutable reference.\n    ///\n    /// If the set contains the given value, this is returned.\n    /// Otherwise, the closest value in the set larger than the\n    /// given value is returned. If the largest value in the set\n    /// is smaller than the given value, `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::OrdMap;\n    /// let mut map = ordmap![1 => 1, 3 => 3, 5 => 5];\n    /// if let Some((key, value)) = map.get_next_mut(&4) {\n    ///     *value = 4;\n    /// }\n    /// assert_eq!(ordmap![1 => 1, 3 => 3, 5 => 4], map);\n    /// ```\n    #[must_use]\n    pub fn get_next_mut<BK>(&mut self, key: &BK) -> Option<(&K, &mut V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        let pool = &self.pool.0;\n        PoolRef::make_mut(pool, &mut self.root)\n            .lookup_next_mut(pool, key)\n            .map(|(ref k, ref mut v)| (k, v))\n    }\n\n    /// Insert a key/value mapping into a map.\n    ///\n    /// This is a copy-on-write operation, so that the parts of the\n    /// map's structure which are shared with other maps will be\n    /// safely copied before mutating.\n    ///\n    /// If the map already has a mapping for the given key, the\n    /// previous value is overwritten.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let mut map = ordmap!{};\n    /// map.insert(123, \"123\");\n    /// map.insert(456, \"456\");\n    /// assert_eq!(\n    ///   map,\n    ///   ordmap!{123 => \"123\", 456 => \"456\"}\n    /// );\n    /// ```\n    ///\n    /// [insert]: #method.insert\n    #[inline]\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n        let new_root = {\n            let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n            match root.insert(&self.pool.0, (key, value)) {\n                Insert::Replaced((_, old_value)) => return Some(old_value),\n                Insert::Added => {\n                    self.size += 1;\n                    return None;\n                }\n                Insert::Split(left, median, right) => PoolRef::new(\n                    &self.pool.0,\n                    Node::new_from_split(&self.pool.0, left, median, right),\n                ),\n            }\n        };\n        self.size += 1;\n        self.root = new_root;\n        None\n    }\n\n    /// Remove a key/value mapping from a map if it exists.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let mut map = ordmap!{123 => \"123\", 456 => \"456\"};\n    /// map.remove(&123);\n    /// map.remove(&456);\n    /// assert!(map.is_empty());\n    /// ```\n    ///\n    /// [remove]: #method.remove\n    #[inline]\n    pub fn remove<BK>(&mut self, k: &BK) -> Option<V>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.remove_with_key(k).map(|(_, v)| v)\n    }\n\n    /// Remove a key/value pair from a map, if it exists, and return\n    /// the removed key and value.\n    ///\n    /// Time: O(log n)\n    pub fn remove_with_key<BK>(&mut self, k: &BK) -> Option<(K, V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        let (new_root, removed_value) = {\n            let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n            match root.remove(&self.pool.0, k) {\n                Remove::NoChange => return None,\n                Remove::Removed(pair) => {\n                    self.size -= 1;\n                    return Some(pair);\n                }\n                Remove::Update(pair, root) => (PoolRef::new(&self.pool.0, root), Some(pair)),\n            }\n        };\n        self.size -= 1;\n        self.root = new_root;\n        removed_value\n    }\n\n    /// Construct a new map by inserting a key/value mapping into a\n    /// map.\n    ///\n    /// If the map already has a mapping for the given key, the\n    /// previous value is overwritten.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map = ordmap!{};\n    /// assert_eq!(\n    ///   map.update(123, \"123\"),\n    ///   ordmap!{123 => \"123\"}\n    /// );\n    /// ```\n    #[must_use]\n    pub fn update(&self, key: K, value: V) -> Self {\n        let mut out = self.clone();\n        out.insert(key, value);\n        out\n    }\n\n    /// Construct a new map by inserting a key/value mapping into a\n    /// map.\n    ///\n    /// If the map already has a mapping for the given key, we call\n    /// the provided function with the old value and the new value,\n    /// and insert the result as the new value.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn update_with<F>(self, k: K, v: V, f: F) -> Self\n    where\n        F: FnOnce(V, V) -> V,\n    {\n        self.update_with_key(k, v, |_, v1, v2| f(v1, v2))\n    }\n\n    /// Construct a new map by inserting a key/value mapping into a\n    /// map.\n    ///\n    /// If the map already has a mapping for the given key, we call\n    /// the provided function with the key, the old value and the new\n    /// value, and insert the result as the new value.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn update_with_key<F>(self, k: K, v: V, f: F) -> Self\n    where\n        F: FnOnce(&K, V, V) -> V,\n    {\n        match self.extract_with_key(&k) {\n            None => self.update(k, v),\n            Some((_, v2, m)) => {\n                let out_v = f(&k, v2, v);\n                m.update(k, out_v)\n            }\n        }\n    }\n\n    /// Construct a new map by inserting a key/value mapping into a\n    /// map, returning the old value for the key as well as the new\n    /// map.\n    ///\n    /// If the map already has a mapping for the given key, we call\n    /// the provided function with the key, the old value and the new\n    /// value, and insert the result as the new value.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn update_lookup_with_key<F>(self, k: K, v: V, f: F) -> (Option<V>, Self)\n    where\n        F: FnOnce(&K, &V, V) -> V,\n    {\n        match self.extract_with_key(&k) {\n            None => (None, self.update(k, v)),\n            Some((_, v2, m)) => {\n                let out_v = f(&k, &v2, v);\n                (Some(v2), m.update(k, out_v))\n            }\n        }\n    }\n\n    /// Update the value for a given key by calling a function with\n    /// the current value and overwriting it with the function's\n    /// return value.\n    ///\n    /// The function gets an [`Option<V>`][std::option::Option] and\n    /// returns the same, so that it can decide to delete a mapping\n    /// instead of updating the value, and decide what to do if the\n    /// key isn't in the map.\n    ///\n    /// Time: O(log n)\n    ///\n    /// [std::option::Option]: https://doc.rust-lang.org/std/option/enum.Option.html\n    #[must_use]\n    pub fn alter<F>(&self, f: F, k: K) -> Self\n    where\n        F: FnOnce(Option<V>) -> Option<V>,\n    {\n        let pop = self.extract_with_key(&k);\n        match (f(pop.as_ref().map(|&(_, ref v, _)| v.clone())), pop) {\n            (None, None) => self.clone(),\n            (Some(v), None) => self.update(k, v),\n            (None, Some((_, _, m))) => m,\n            (Some(v), Some((_, _, m))) => m.update(k, v),\n        }\n    }\n\n    /// Remove a key/value pair from a map, if it exists.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn without<BK>(&self, k: &BK) -> Self\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.extract(k)\n            .map(|(_, m)| m)\n            .unwrap_or_else(|| self.clone())\n    }\n\n    /// Remove a key/value pair from a map, if it exists, and return\n    /// the removed value as well as the updated list.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn extract<BK>(&self, k: &BK) -> Option<(V, Self)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.extract_with_key(k).map(|(_, v, m)| (v, m))\n    }\n\n    /// Remove a key/value pair from a map, if it exists, and return\n    /// the removed key and value as well as the updated list.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn extract_with_key<BK>(&self, k: &BK) -> Option<(K, V, Self)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        let mut out = self.clone();\n        let result = out.remove_with_key(k);\n        result.map(|(k, v)| (k, v, out))\n    }\n\n    /// Construct the union of two maps, keeping the values in the\n    /// current map when keys exist in both maps.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 3 => 3};\n    /// let map2 = ordmap!{2 => 2, 3 => 4};\n    /// let expected = ordmap!{1 => 1, 2 => 2, 3 => 3};\n    /// assert_eq!(expected, map1.union(map2));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn union(mut self, other: Self) -> Self {\n        for (k, v) in other {\n            self.entry(k).or_insert(v);\n        }\n        self\n    }\n\n    /// Construct the union of two maps, using a function to decide\n    /// what to do with the value when a key is in both maps.\n    ///\n    /// The function is called when a value exists in both maps, and\n    /// receives the value from the current map as its first argument,\n    /// and the value from the other map as the second. It should\n    /// return the value to be inserted in the resulting map.\n    ///\n    /// Time: O(n log n)\n    #[inline]\n    #[must_use]\n    pub fn union_with<F>(self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(V, V) -> V,\n    {\n        self.union_with_key(other, |_, v1, v2| f(v1, v2))\n    }\n\n    /// Construct the union of two maps, using a function to decide\n    /// what to do with the value when a key is in both maps.\n    ///\n    /// The function is called when a value exists in both maps, and\n    /// receives a reference to the key as its first argument, the\n    /// value from the current map as the second argument, and the\n    /// value from the other map as the third argument. It should\n    /// return the value to be inserted in the resulting map.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 3 => 4};\n    /// let map2 = ordmap!{2 => 2, 3 => 5};\n    /// let expected = ordmap!{1 => 1, 2 => 2, 3 => 9};\n    /// assert_eq!(expected, map1.union_with_key(\n    ///     map2,\n    ///     |key, left, right| left + right\n    /// ));\n    /// ```\n    #[must_use]\n    pub fn union_with_key<F>(mut self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> V,\n    {\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => {\n                    self.insert(key, right_value);\n                }\n                Some(left_value) => {\n                    let final_value = f(&key, left_value, right_value);\n                    self.insert(key, final_value);\n                }\n            }\n        }\n        self\n    }\n\n    /// Construct the union of a sequence of maps, selecting the value\n    /// of the leftmost when a key appears in more than one map.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 3 => 3};\n    /// let map2 = ordmap!{2 => 2};\n    /// let expected = ordmap!{1 => 1, 2 => 2, 3 => 3};\n    /// assert_eq!(expected, OrdMap::unions(vec![map1, map2]));\n    /// ```\n    #[must_use]\n    pub fn unions<I>(i: I) -> Self\n    where\n        I: IntoIterator<Item = Self>,\n    {\n        i.into_iter().fold(Self::default(), Self::union)\n    }\n\n    /// Construct the union of a sequence of maps, using a function to\n    /// decide what to do with the value when a key is in more than\n    /// one map.\n    ///\n    /// The function is called when a value exists in multiple maps,\n    /// and receives the value from the current map as its first\n    /// argument, and the value from the next map as the second. It\n    /// should return the value to be inserted in the resulting map.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn unions_with<I, F>(i: I, f: F) -> Self\n    where\n        I: IntoIterator<Item = Self>,\n        F: Fn(V, V) -> V,\n    {\n        i.into_iter()\n            .fold(Self::default(), |a, b| a.union_with(b, &f))\n    }\n\n    /// Construct the union of a sequence of maps, using a function to\n    /// decide what to do with the value when a key is in more than\n    /// one map.\n    ///\n    /// The function is called when a value exists in multiple maps,\n    /// and receives a reference to the key as its first argument, the\n    /// value from the current map as the second argument, and the\n    /// value from the next map as the third argument. It should\n    /// return the value to be inserted in the resulting map.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn unions_with_key<I, F>(i: I, f: F) -> Self\n    where\n        I: IntoIterator<Item = Self>,\n        F: Fn(&K, V, V) -> V,\n    {\n        i.into_iter()\n            .fold(Self::default(), |a, b| a.union_with_key(b, &f))\n    }\n\n    /// Construct the symmetric difference between two maps by discarding keys\n    /// which occur in both maps.\n    ///\n    /// This is an alias for the\n    /// [`symmetric_difference`][symmetric_difference] method.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 3 => 4};\n    /// let map2 = ordmap!{2 => 2, 3 => 5};\n    /// let expected = ordmap!{1 => 1, 2 => 2};\n    /// assert_eq!(expected, map1.difference(map2));\n    /// ```\n    ///\n    /// [symmetric_difference]: #method.symmetric_difference\n    #[inline]\n    #[must_use]\n    pub fn difference(self, other: Self) -> Self {\n        self.symmetric_difference(other)\n    }\n\n    /// Construct the symmetric difference between two maps by discarding keys\n    /// which occur in both maps.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 3 => 4};\n    /// let map2 = ordmap!{2 => 2, 3 => 5};\n    /// let expected = ordmap!{1 => 1, 2 => 2};\n    /// assert_eq!(expected, map1.symmetric_difference(map2));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn symmetric_difference(self, other: Self) -> Self {\n        self.symmetric_difference_with_key(other, |_, _, _| None)\n    }\n\n    /// Construct the symmetric difference between two maps by using a function\n    /// to decide what to do if a key occurs in both.\n    ///\n    /// This is an alias for the\n    /// [`symmetric_difference_with`][symmetric_difference_with] method.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// [symmetric_difference_with]: #method.symmetric_difference_with\n    #[inline]\n    #[must_use]\n    pub fn difference_with<F>(self, other: Self, f: F) -> Self\n    where\n        F: FnMut(V, V) -> Option<V>,\n    {\n        self.symmetric_difference_with(other, f)\n    }\n\n    /// Construct the symmetric difference between two maps by using a function\n    /// to decide what to do if a key occurs in both.\n    ///\n    /// Time: O(n log n)\n    #[inline]\n    #[must_use]\n    pub fn symmetric_difference_with<F>(self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(V, V) -> Option<V>,\n    {\n        self.symmetric_difference_with_key(other, |_, a, b| f(a, b))\n    }\n\n    /// Construct the symmetric difference between two maps by using a function\n    /// to decide what to do if a key occurs in both. The function\n    /// receives the key as well as both values.\n    ///\n    /// This is an alias for the\n    /// [`symmetric_difference_with_key`][symmetric_difference_with_key]\n    /// method.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 3 => 4};\n    /// let map2 = ordmap!{2 => 2, 3 => 5};\n    /// let expected = ordmap!{1 => 1, 2 => 2, 3 => 9};\n    /// assert_eq!(expected, map1.difference_with_key(\n    ///     map2,\n    ///     |key, left, right| Some(left + right)\n    /// ));\n    /// ```\n    /// [symmetric_difference_with_key]: #method.symmetric_difference_with_key\n    #[must_use]\n    pub fn difference_with_key<F>(self, other: Self, f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> Option<V>,\n    {\n        self.symmetric_difference_with_key(other, f)\n    }\n\n    /// Construct the symmetric difference between two maps by using a function\n    /// to decide what to do if a key occurs in both. The function\n    /// receives the key as well as both values.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 3 => 4};\n    /// let map2 = ordmap!{2 => 2, 3 => 5};\n    /// let expected = ordmap!{1 => 1, 2 => 2, 3 => 9};\n    /// assert_eq!(expected, map1.symmetric_difference_with_key(\n    ///     map2,\n    ///     |key, left, right| Some(left + right)\n    /// ));\n    /// ```\n    #[must_use]\n    pub fn symmetric_difference_with_key<F>(mut self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> Option<V>,\n    {\n        let mut out = Self::default();\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => {\n                    out.insert(key, right_value);\n                }\n                Some(left_value) => {\n                    if let Some(final_value) = f(&key, left_value, right_value) {\n                        out.insert(key, final_value);\n                    }\n                }\n            }\n        }\n        out.union(self)\n    }\n\n    /// Construct the relative complement between two maps by discarding keys\n    /// which occur in `other`.\n    ///\n    /// Time: O(m log n) where m is the size of the other map\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 3 => 4};\n    /// let map2 = ordmap!{2 => 2, 3 => 5};\n    /// let expected = ordmap!{1 => 1};\n    /// assert_eq!(expected, map1.relative_complement(map2));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn relative_complement(mut self, other: Self) -> Self {\n        for (key, _) in other {\n            let _ = self.remove(&key);\n        }\n        self\n    }\n\n    /// Construct the intersection of two maps, keeping the values\n    /// from the current map.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 2 => 2};\n    /// let map2 = ordmap!{2 => 3, 3 => 4};\n    /// let expected = ordmap!{2 => 2};\n    /// assert_eq!(expected, map1.intersection(map2));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn intersection(self, other: Self) -> Self {\n        self.intersection_with_key(other, |_, v, _| v)\n    }\n\n    /// Construct the intersection of two maps, calling a function\n    /// with both values for each key and using the result as the\n    /// value for the key.\n    ///\n    /// Time: O(n log n)\n    #[inline]\n    #[must_use]\n    pub fn intersection_with<B, C, F>(self, other: OrdMap<K, B>, mut f: F) -> OrdMap<K, C>\n    where\n        B: Clone,\n        C: Clone,\n        F: FnMut(V, B) -> C,\n    {\n        self.intersection_with_key(other, |_, v1, v2| f(v1, v2))\n    }\n\n    /// Construct the intersection of two maps, calling a function\n    /// with the key and both values for each key and using the result\n    /// as the value for the key.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 2 => 2};\n    /// let map2 = ordmap!{2 => 3, 3 => 4};\n    /// let expected = ordmap!{2 => 5};\n    /// assert_eq!(expected, map1.intersection_with_key(\n    ///     map2,\n    ///     |key, left, right| left + right\n    /// ));\n    /// ```\n    #[must_use]\n    pub fn intersection_with_key<B, C, F>(mut self, other: OrdMap<K, B>, mut f: F) -> OrdMap<K, C>\n    where\n        B: Clone,\n        C: Clone,\n        F: FnMut(&K, V, B) -> C,\n    {\n        let mut out = OrdMap::<K, C>::default();\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => (),\n                Some(left_value) => {\n                    let result = f(&key, left_value, right_value);\n                    out.insert(key, result);\n                }\n            }\n        }\n        out\n    }\n\n    /// Split a map into two, with the left hand map containing keys\n    /// which are smaller than `split`, and the right hand map\n    /// containing keys which are larger than `split`.\n    ///\n    /// The `split` mapping is discarded.\n    #[must_use]\n    pub fn split<BK>(&self, split: &BK) -> (Self, Self)\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        let (l, _, r) = self.split_lookup(split);\n        (l, r)\n    }\n\n    /// Split a map into two, with the left hand map containing keys\n    /// which are smaller than `split`, and the right hand map\n    /// containing keys which are larger than `split`.\n    ///\n    /// Returns both the two maps and the value of `split`.\n    #[must_use]\n    pub fn split_lookup<BK>(&self, split: &BK) -> (Self, Option<V>, Self)\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        // TODO this is atrociously slow, got to be a better way\n        self.iter()\n            .fold((ordmap![], None, ordmap![]), |(l, m, r), (k, v)| {\n                match k.borrow().cmp(split) {\n                    Ordering::Less => (l.update(k.clone(), v.clone()), m, r),\n                    Ordering::Equal => (l, Some(v.clone()), r),\n                    Ordering::Greater => (l, m, r.update(k.clone(), v.clone())),\n                }\n            })\n    }\n\n    /// Construct a map with only the `n` smallest keys from a given\n    /// map.\n    #[must_use]\n    pub fn take(&self, n: usize) -> Self {\n        self.iter()\n            .take(n)\n            .map(|(k, v)| (k.clone(), v.clone()))\n            .collect()\n    }\n\n    /// Construct a map with the `n` smallest keys removed from a\n    /// given map.\n    #[must_use]\n    pub fn skip(&self, n: usize) -> Self {\n        self.iter()\n            .skip(n)\n            .map(|(k, v)| (k.clone(), v.clone()))\n            .collect()\n    }\n\n    /// Remove the smallest key from a map, and return its value as\n    /// well as the updated map.\n    #[must_use]\n    pub fn without_min(&self) -> (Option<V>, Self) {\n        let (pop, next) = self.without_min_with_key();\n        (pop.map(|(_, v)| v), next)\n    }\n\n    /// Remove the smallest key from a map, and return that key, its\n    /// value as well as the updated map.\n    #[must_use]\n    pub fn without_min_with_key(&self) -> (Option<(K, V)>, Self) {\n        match self.get_min() {\n            None => (None, self.clone()),\n            Some((k, _)) => {\n                let (key, value, next) = self.extract_with_key(k).unwrap();\n                (Some((key, value)), next)\n            }\n        }\n    }\n\n    /// Remove the largest key from a map, and return its value as\n    /// well as the updated map.\n    #[must_use]\n    pub fn without_max(&self) -> (Option<V>, Self) {\n        let (pop, next) = self.without_max_with_key();\n        (pop.map(|(_, v)| v), next)\n    }\n\n    /// Remove the largest key from a map, and return that key, its\n    /// value as well as the updated map.\n    #[must_use]\n    pub fn without_max_with_key(&self) -> (Option<(K, V)>, Self) {\n        match self.get_max() {\n            None => (None, self.clone()),\n            Some((k, _)) => {\n                let (key, value, next) = self.extract_with_key(k).unwrap();\n                (Some((key, value)), next)\n            }\n        }\n    }\n\n    /// Get the [`Entry`][Entry] for a key in the map for in-place manipulation.\n    ///\n    /// Time: O(log n)\n    ///\n    /// [Entry]: enum.Entry.html\n    #[must_use]\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n        if self.contains_key(&key) {\n            Entry::Occupied(OccupiedEntry { map: self, key })\n        } else {\n            Entry::Vacant(VacantEntry { map: self, key })\n        }\n    }\n}","impl<K, V> OrdMap<K, V>\nwhere\n    K: Ord,\n{\n    /// Get the largest key in a map, along with its value. If the map\n    /// is empty, return `None`.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// assert_eq!(Some(&(3, 33)), ordmap!{\n    ///   1 => 11,\n    ///   2 => 22,\n    ///   3 => 33\n    /// }.get_max());\n    /// ```\n    #[must_use]\n    pub fn get_max(&self) -> Option<&(K, V)> {\n        self.root.max()\n    }\n\n    /// Get the smallest key in a map, along with its value. If the\n    /// map is empty, return `None`.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// assert_eq!(Some(&(1, 11)), ordmap!{\n    ///   1 => 11,\n    ///   2 => 22,\n    ///   3 => 33\n    /// }.get_min());\n    /// ```\n    #[must_use]\n    pub fn get_min(&self) -> Option<&(K, V)> {\n        self.root.min()\n    }\n\n    /// Get an iterator over the key/value pairs of a map.\n    #[must_use]\n    pub fn iter(&self) -> Iter<'_, K, V> {\n        Iter {\n            it: RangedIter::new(&self.root, self.size, ..),\n        }\n    }\n\n    /// Create an iterator over a range of key/value pairs.\n    #[must_use]\n    pub fn range<R, BK>(&self, range: R) -> Iter<'_, K, V>\n    where\n        R: RangeBounds<BK>,\n        K: Borrow<BK>,\n        BK: Ord + ?Sized,\n    {\n        Iter {\n            it: RangedIter::new(&self.root, self.size, range),\n        }\n    }\n\n    /// Get an iterator over a map's keys.\n    #[must_use]\n    pub fn keys(&self) -> Keys<'_, K, V> {\n        Keys { it: self.iter() }\n    }\n\n    /// Get an iterator over a map's values.\n    #[must_use]\n    pub fn values(&self) -> Values<'_, K, V> {\n        Values { it: self.iter() }\n    }\n\n    /// Get an iterator over the differences between this map and\n    /// another, i.e. the set of entries to add, update, or remove to\n    /// this map in order to make it equal to the other map.\n    ///\n    /// This function will avoid visiting nodes which are shared\n    /// between the two maps, meaning that even very large maps can be\n    /// compared quickly if most of their structure is shared.\n    ///\n    /// Time: O(n) (where n is the number of unique elements across\n    /// the two maps, minus the number of elements belonging to nodes\n    /// shared between them)\n    #[must_use]\n    pub fn diff<'a>(&'a self, other: &'a Self) -> DiffIter<'a, K, V> {\n        DiffIter {\n            it: NodeDiffIter::new(&self.root, &other.root),\n        }\n    }\n\n    /// Get the value for a key from a map.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map = ordmap!{123 => \"lol\"};\n    /// assert_eq!(\n    ///   map.get(&123),\n    ///   Some(&\"lol\")\n    /// );\n    /// ```\n    #[must_use]\n    pub fn get<BK>(&self, key: &BK) -> Option<&V>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.root.lookup(key).map(|(_, v)| v)\n    }\n\n    /// Get the key/value pair for a key from a map.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map = ordmap!{123 => \"lol\"};\n    /// assert_eq!(\n    ///   map.get_key_value(&123),\n    ///   Some((&123, &\"lol\"))\n    /// );\n    /// ```\n    #[must_use]\n    pub fn get_key_value<BK>(&self, key: &BK) -> Option<(&K, &V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.root.lookup(key).map(|&(ref k, ref v)| (k, v))\n    }\n\n    /// Get the closest smaller entry in a map to a given key\n    /// as a mutable reference.\n    ///\n    /// If the map contains the given key, this is returned.\n    /// Otherwise, the closest key in the map smaller than the\n    /// given value is returned. If the smallest key in the map\n    /// is larger than the given key, `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::OrdMap;\n    /// let map = ordmap![1 => 1, 3 => 3, 5 => 5];\n    /// assert_eq!(Some((&3, &3)), map.get_prev(&4));\n    /// ```\n    #[must_use]\n    pub fn get_prev<BK>(&self, key: &BK) -> Option<(&K, &V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.root.lookup_prev(key).map(|(k, v)| (k, v))\n    }\n\n    /// Get the closest larger entry in a map to a given key\n    /// as a mutable reference.\n    ///\n    /// If the set contains the given value, this is returned.\n    /// Otherwise, the closest value in the set larger than the\n    /// given value is returned. If the largest value in the set\n    /// is smaller than the given value, `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::OrdMap;\n    /// let map = ordmap![1 => 1, 3 => 3, 5 => 5];\n    /// assert_eq!(Some((&5, &5)), map.get_next(&4));\n    /// ```\n    #[must_use]\n    pub fn get_next<BK>(&self, key: &BK) -> Option<(&K, &V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.root.lookup_next(key).map(|(k, v)| (k, v))\n    }\n\n    /// Test for the presence of a key in a map.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map = ordmap!{123 => \"lol\"};\n    /// assert!(\n    ///   map.contains_key(&123)\n    /// );\n    /// assert!(\n    ///   !map.contains_key(&321)\n    /// );\n    /// ```\n    #[must_use]\n    pub fn contains_key<BK>(&self, k: &BK) -> bool\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,\n    {\n        self.get(k).is_some()\n    }\n\n    /// Test whether a map is a submap of another map, meaning that\n    /// all keys in our map must also be in the other map, with the\n    /// same values.\n    ///\n    /// Use the provided function to decide whether values are equal.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn is_submap_by<B, RM, F>(&self, other: RM, mut cmp: F) -> bool\n    where\n        F: FnMut(&V, &B) -> bool,\n        RM: Borrow<OrdMap<K, B>>,\n    {\n        self.iter()\n            .all(|(k, v)| other.borrow().get(k).map(|ov| cmp(v, ov)).unwrap_or(false))\n    }\n\n    /// Test whether a map is a proper submap of another map, meaning\n    /// that all keys in our map must also be in the other map, with\n    /// the same values. To be a proper submap, ours must also contain\n    /// fewer keys than the other map.\n    ///\n    /// Use the provided function to decide whether values are equal.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn is_proper_submap_by<B, RM, F>(&self, other: RM, cmp: F) -> bool\n    where\n        F: FnMut(&V, &B) -> bool,\n        RM: Borrow<OrdMap<K, B>>,\n    {\n        self.len() != other.borrow().len() && self.is_submap_by(other, cmp)\n    }\n\n    /// Test whether a map is a submap of another map, meaning that\n    /// all keys in our map must also be in the other map, with the\n    /// same values.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 2 => 2};\n    /// let map2 = ordmap!{1 => 1, 2 => 2, 3 => 3};\n    /// assert!(map1.is_submap(map2));\n    /// ```\n    #[must_use]\n    pub fn is_submap<RM>(&self, other: RM) -> bool\n    where\n        V: PartialEq,\n        RM: Borrow<Self>,\n    {\n        self.is_submap_by(other.borrow(), PartialEq::eq)\n    }\n\n    /// Test whether a map is a proper submap of another map, meaning\n    /// that all keys in our map must also be in the other map, with\n    /// the same values. To be a proper submap, ours must also contain\n    /// fewer keys than the other map.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map1 = ordmap!{1 => 1, 2 => 2};\n    /// let map2 = ordmap!{1 => 1, 2 => 2, 3 => 3};\n    /// assert!(map1.is_proper_submap(map2));\n    ///\n    /// let map3 = ordmap!{1 => 1, 2 => 2};\n    /// let map4 = ordmap!{1 => 1, 2 => 2};\n    /// assert!(!map3.is_proper_submap(map4));\n    /// ```\n    #[must_use]\n    pub fn is_proper_submap<RM>(&self, other: RM) -> bool\n    where\n        V: PartialEq,\n        RM: Borrow<Self>,\n    {\n        self.is_proper_submap_by(other.borrow(), PartialEq::eq)\n    }\n}","impl<K, V> OrdMap<K, V> {\n    /// Construct an empty map.\n    #[must_use]\n    pub fn new() -> Self {\n        let pool = OrdMapPool::default();\n        let root = PoolRef::default(&pool.0);\n        OrdMap {\n            size: 0,\n            pool,\n            root,\n        }\n    }\n\n    /// Construct an empty map using a specific memory pool.\n    #[cfg(feature = \"pool\")]\n    #[must_use]\n    pub fn with_pool(pool: &OrdMapPool<K, V>) -> Self {\n        let root = PoolRef::default(&pool.0);\n        OrdMap {\n            size: 0,\n            pool: pool.clone(),\n            root,\n        }\n    }\n\n    /// Construct a map with a single mapping.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// let map = OrdMap::unit(123, \"onetwothree\");\n    /// assert_eq!(\n    ///   map.get(&123),\n    ///   Some(&\"onetwothree\")\n    /// );\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn unit(key: K, value: V) -> Self {\n        let pool = OrdMapPool::default();\n        let root = PoolRef::new(&pool.0, Node::unit((key, value)));\n        OrdMap {\n            size: 1,\n            pool,\n            root,\n        }\n    }\n\n    /// Test whether a map is empty.\n    ///\n    /// Time: O(1)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// assert!(\n    ///   !ordmap!{1 => 2}.is_empty()\n    /// );\n    /// assert!(\n    ///   OrdMap::<i32, i32>::new().is_empty()\n    /// );\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Test whether two maps refer to the same content in memory.\n    ///\n    /// This is true if the two sides are references to the same map,\n    /// or if the two maps refer to the same root node.\n    ///\n    /// This would return true if you're comparing a map to itself, or\n    /// if you're comparing a map to a fresh clone of itself.\n    ///\n    /// Time: O(1)\n    pub fn ptr_eq(&self, other: &Self) -> bool {\n        std::ptr::eq(self, other) || PoolRef::ptr_eq(&self.root, &other.root)\n    }\n\n    /// Get the size of a map.\n    ///\n    /// Time: O(1)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordmap::OrdMap;\n    /// assert_eq!(3, ordmap!{\n    ///   1 => 11,\n    ///   2 => 22,\n    ///   3 => 33\n    /// }.len());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn len(&self) -> usize {\n        self.size\n    }\n\n    /// Get a reference to the memory pool used by this map.\n    ///\n    /// Note that if you didn't specifically construct it with a pool, you'll\n    /// get back a reference to a pool of size 0.\n    #[cfg(feature = \"pool\")]\n    pub fn pool(&self) -> &OrdMapPool<K, V> {\n        &self.pool\n    }\n\n    /// Discard all elements from the map.\n    ///\n    /// This leaves you with an empty map, and all elements that\n    /// were previously inside it are dropped.\n    ///\n    /// Time: O(n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::OrdMap;\n    /// let mut map = ordmap![1=>1, 2=>2, 3=>3];\n    /// map.clear();\n    /// assert!(map.is_empty());\n    /// ```\n    pub fn clear(&mut self) {\n        if !self.is_empty() {\n            self.root = PoolRef::default(&self.pool.0);\n            self.size = 0;\n        }\n    }\n}","impl<K, V> PartialEq for OrdMap<K, V>\nwhere\n    K: Ord + Eq,\n    V: Eq,\n{\n    fn eq(&self, other: &Self) -> bool {\n        PoolRef::ptr_eq(&self.root, &other.root)\n            || (self.len() == other.len() && self.diff(other).next().is_none())\n    }\n}","impl<K, V> PartialEq for OrdMap<K, V>\nwhere\n    K: Ord + PartialEq,\n    V: PartialEq,\n{\n    default fn eq(&self, other: &Self) -> bool {\n        self.len() == other.len() && self.diff(other).next().is_none()\n    }\n}","impl<K, V> PartialOrd for OrdMap<K, V>\nwhere\n    K: Ord,\n    V: PartialOrd,\n{\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.iter().partial_cmp(other.iter())\n    }\n}","impl<K, V> Sum for OrdMap<K, V>\nwhere\n    K: Ord + Clone,\n    V: Clone,\n{\n    fn sum<I>(it: I) -> Self\n    where\n        I: Iterator<Item = Self>,\n    {\n        it.fold(Self::default(), |a, b| a + b)\n    }\n}","impl<K: Ord + Eq, V: Eq> Eq for OrdMap<K, V> {}","impl<K: Ord + Hash + Eq + Clone, V: Clone, S: BuildHasher> From<HashMap<K, V, S>> for OrdMap<K, V> {\n    fn from(m: HashMap<K, V, S>) -> Self {\n        m.into_iter().collect()\n    }\n}","impl<K: Ord, V, RK, RV> From<collections::BTreeMap<RK, RV>> for OrdMap<K, V>\nwhere\n    K: Ord + Clone + From<RK>,\n    V: Clone + From<RV>,\n{\n    fn from(m: collections::BTreeMap<RK, RV>) -> OrdMap<K, V> {\n        m.into_iter().collect()\n    }\n}","impl<K: Ord, V, RK: Eq + Hash, RV> From<collections::HashMap<RK, RV>> for OrdMap<K, V>\nwhere\n    K: Ord + Clone + From<RK>,\n    V: Clone + From<RV>,\n{\n    fn from(m: collections::HashMap<RK, RV>) -> OrdMap<K, V> {\n        m.into_iter().collect()\n    }\n}"],"ord::map::OrdMapPool":["impl<$($arg,)*> $name<$($arg,)*> {\n            /// Create a new pool with the given size.\n            pub fn new(size: usize) -> Self {\n                Self(Pool::new(size))\n            }\n\n            /// Fill the pool with preallocated chunks.\n            pub fn fill(&self) {\n                self.0.fill();\n            }\n\n            ///Get the current size of the pool.\n            pub fn pool_size(&self) -> usize {\n                self.0.get_pool_size()\n            }\n        }","impl<$($arg,)*> Clone for $name<$($arg,)*> {\n            fn clone(&self) -> Self {\n                Self(self.0.clone())\n            }\n        }","impl<$($arg,)*> Default for $name<$($arg,)*> {\n            fn default() -> Self {\n                Self::new($crate::config::POOL_SIZE)\n            }\n        }"],"ord::map::VacantEntry":["impl<'a, K, V> VacantEntry<'a, K, V>\nwhere\n    K: 'a + Ord + Clone,\n    V: 'a + Clone,\n{\n    /// Get the key for this entry.\n    #[must_use]\n    pub fn key(&self) -> &K {\n        &self.key\n    }\n\n    /// Convert this entry into its key.\n    #[must_use]\n    pub fn into_key(self) -> K {\n        self.key\n    }\n\n    /// Insert a value into this entry.\n    pub fn insert(self, value: V) -> &'a mut V {\n        self.map.insert(self.key.clone(), value);\n        // TODO insert_mut ought to return this reference\n        self.map.get_mut(&self.key).unwrap()\n    }\n}"],"ord::map::Values":["impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V>\nwhere\n    K: 'a + Ord,\n    V: 'a,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        match self.it.next_back() {\n            None => None,\n            Some((_, v)) => Some(v),\n        }\n    }\n}","impl<'a, K, V> ExactSizeIterator for Values<'a, K, V>\nwhere\n    K: 'a + Ord,\n    V: 'a,\n{\n}","impl<'a, K, V> Iterator for Values<'a, K, V>\nwhere\n    K: 'a + Ord,\n    V: 'a,\n{\n    type Item = &'a V;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|(_, v)| v)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n}"],"ord::set::ConsumingIter":["impl<A> Iterator for ConsumingIter<A>\nwhere\n    A: Ord + Clone,\n{\n    type Item = A;\n\n    /// Advance the iterator and return the next value.\n    ///\n    /// Time: O(1)*\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|v| v.0)\n    }\n}"],"ord::set::DiffIter":["impl<'a, A> Iterator for DiffIter<'a, A>\nwhere\n    A: Ord + PartialEq,\n{\n    type Item = DiffItem<'a, A>;\n\n    /// Advance the iterator and return the next value.\n    ///\n    /// Time: O(1)*\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(|item| match item {\n            DiffItem::Add(v) => DiffItem::Add(v.deref()),\n            DiffItem::Update { old, new } => DiffItem::Update {\n                old: old.deref(),\n                new: new.deref(),\n            },\n            DiffItem::Remove(v) => DiffItem::Remove(v.deref()),\n        })\n    }\n}"],"ord::set::Iter":["impl<'a, A> DoubleEndedIterator for Iter<'a, A>\nwhere\n    A: 'a + Ord,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.it.next_back().map(Deref::deref)\n    }\n}","impl<'a, A> ExactSizeIterator for Iter<'a, A> where A: 'a + Ord {}","impl<'a, A> Iterator for Iter<'a, A>\nwhere\n    A: 'a + Ord,\n{\n    type Item = &'a A;\n\n    /// Advance the iterator and return the next value.\n    ///\n    /// Time: O(1)*\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(Deref::deref)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.it.remaining, Some(self.it.remaining))\n    }\n}"],"ord::set::OrdSet":["impl<'a, A: Eq + Hash + Ord + Clone> From<&'a collections::HashSet<A>> for OrdSet<A> {\n    fn from(hash_set: &collections::HashSet<A>) -> Self {\n        hash_set.iter().cloned().collect()\n    }\n}","impl<'a, A: Hash + Eq + Ord + Clone, S: BuildHasher> From<&'a HashSet<A, S>> for OrdSet<A> {\n    fn from(hashset: &HashSet<A, S>) -> Self {\n        hashset.into_iter().cloned().collect()\n    }\n}","impl<'a, A: Ord + Clone> From<&'a Vec<A>> for OrdSet<A> {\n    fn from(vec: &Vec<A>) -> Self {\n        vec.iter().cloned().collect()\n    }\n}","impl<'a, A: Ord + Clone> From<&'a collections::BTreeSet<A>> for OrdSet<A> {\n    fn from(btree_set: &collections::BTreeSet<A>) -> Self {\n        btree_set.iter().cloned().collect()\n    }\n}","impl<'a, A> From<&'a [A]> for OrdSet<A>\nwhere\n    A: Ord + Clone,\n{\n    fn from(slice: &'a [A]) -> Self {\n        slice.iter().cloned().collect()\n    }\n}","impl<'s, 'a, A, OA> From<&'s OrdSet<&'a A>> for OrdSet<OA>\nwhere\n    A: ToOwned<Owned = OA> + Ord + ?Sized,\n    OA: Borrow<A> + Ord + Clone,\n{\n    fn from(set: &OrdSet<&A>) -> Self {\n        set.iter().map(|a| (*a).to_owned()).collect()\n    }\n}","impl<A, R> Extend<R> for OrdSet<A>\nwhere\n    A: Ord + Clone + From<R>,\n{\n    fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = R>,\n    {\n        for value in iter {\n            self.insert(From::from(value));\n        }\n    }\n}","impl<A, R> FromIterator<R> for OrdSet<A>\nwhere\n    A: Ord + Clone + From<R>,\n{\n    fn from_iter<T>(i: T) -> Self\n    where\n        T: IntoIterator<Item = R>,\n    {\n        let mut out = Self::new();\n        for item in i {\n            out.insert(From::from(item));\n        }\n        out\n    }\n}","impl<A: Eq + Hash + Ord + Clone> From<collections::HashSet<A>> for OrdSet<A> {\n    fn from(hash_set: collections::HashSet<A>) -> Self {\n        hash_set.into_iter().collect()\n    }\n}","impl<A: Hash + Eq + Ord + Clone, S: BuildHasher> From<HashSet<A, S>> for OrdSet<A> {\n    fn from(hashset: HashSet<A, S>) -> Self {\n        hashset.into_iter().collect()\n    }\n}","impl<A: Ord + Clone> Add for OrdSet<A> {\n    type Output = OrdSet<A>;\n\n    fn add(self, other: Self) -> Self::Output {\n        self.union(other)\n    }\n}","impl<A: Ord + Clone> From<Vec<A>> for OrdSet<A> {\n    fn from(vec: Vec<A>) -> Self {\n        vec.into_iter().collect()\n    }\n}","impl<A: Ord + Clone> From<collections::BTreeSet<A>> for OrdSet<A> {\n    fn from(btree_set: collections::BTreeSet<A>) -> Self {\n        btree_set.into_iter().collect()\n    }\n}","impl<A: Ord + Clone> Mul for OrdSet<A> {\n    type Output = OrdSet<A>;\n\n    fn mul(self, other: Self) -> Self::Output {\n        self.intersection(other)\n    }\n}","impl<A: Ord + Clone> Sum for OrdSet<A> {\n    fn sum<I>(it: I) -> Self\n    where\n        I: Iterator<Item = Self>,\n    {\n        it.fold(Self::new(), |a, b| a + b)\n    }\n}","impl<A: Ord + Debug> Debug for OrdSet<A> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        f.debug_set().entries(self.iter()).finish()\n    }\n}","impl<A: Ord + Eq> Eq for OrdSet<A> {}","impl<A: Ord + Hash> Hash for OrdSet<A> {\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for i in self.iter() {\n            i.hash(state);\n        }\n    }\n}","impl<A: Ord> Ord for OrdSet<A> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.iter().cmp(other.iter())\n    }\n}","impl<A: Ord> PartialEq for OrdSet<A> {\n    fn eq(&self, other: &Self) -> bool {\n        PoolRef::ptr_eq(&self.root, &other.root)\n            || (self.len() == other.len() && self.diff(other).next().is_none())\n    }\n}","impl<A: Ord> PartialOrd for OrdSet<A> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.iter().partial_cmp(other.iter())\n    }\n}","impl<A> Clone for OrdSet<A> {\n    /// Clone a set.\n    ///\n    /// Time: O(1)\n    #[inline]\n    fn clone(&self) -> Self {\n        OrdSet {\n            size: self.size,\n            pool: self.pool.clone(),\n            root: self.root.clone(),\n        }\n    }\n}","impl<A> Default for OrdSet<A> {\n    fn default() -> Self {\n        OrdSet::new()\n    }\n}","impl<A> IntoIterator for OrdSet<A>\nwhere\n    A: Ord + Clone,\n{\n    type Item = A;\n    type IntoIter = ConsumingIter<A>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        ConsumingIter {\n            it: ConsumingNodeIter::new(&self.root, self.size),\n        }\n    }\n}","impl<A> OrdSet<A>\nwhere\n    A: Ord + Clone,\n{\n    /// Insert a value into a set.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// let mut set = ordset!{};\n    /// set.insert(123);\n    /// set.insert(456);\n    /// assert_eq!(\n    ///   set,\n    ///   ordset![123, 456]\n    /// );\n    /// ```\n    #[inline]\n    pub fn insert(&mut self, a: A) -> Option<A> {\n        let new_root = {\n            let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n            match root.insert(&self.pool.0, Value(a)) {\n                Insert::Replaced(Value(old_value)) => return Some(old_value),\n                Insert::Added => {\n                    self.size += 1;\n                    return None;\n                }\n                Insert::Split(left, median, right) => PoolRef::new(\n                    &self.pool.0,\n                    Node::new_from_split(&self.pool.0, left, median, right),\n                ),\n            }\n        };\n        self.size += 1;\n        self.root = new_root;\n        None\n    }\n\n    /// Remove a value from a set.\n    ///\n    /// Time: O(log n)\n    #[inline]\n    pub fn remove<BA>(&mut self, a: &BA) -> Option<A>\n    where\n        BA: Ord + ?Sized,\n        A: Borrow<BA>,\n    {\n        let (new_root, removed_value) = {\n            let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n            match root.remove(&self.pool.0, a) {\n                Remove::Update(value, root) => (PoolRef::new(&self.pool.0, root), Some(value.0)),\n                Remove::Removed(value) => {\n                    self.size -= 1;\n                    return Some(value.0);\n                }\n                Remove::NoChange => return None,\n            }\n        };\n        self.size -= 1;\n        self.root = new_root;\n        removed_value\n    }\n\n    /// Remove the smallest value from a set.\n    ///\n    /// Time: O(log n)\n    pub fn remove_min(&mut self) -> Option<A> {\n        // FIXME implement this at the node level for better efficiency\n        let key = match self.get_min() {\n            None => return None,\n            Some(v) => v,\n        }\n        .clone();\n        self.remove(&key)\n    }\n\n    /// Remove the largest value from a set.\n    ///\n    /// Time: O(log n)\n    pub fn remove_max(&mut self) -> Option<A> {\n        // FIXME implement this at the node level for better efficiency\n        let key = match self.get_max() {\n            None => return None,\n            Some(v) => v,\n        }\n        .clone();\n        self.remove(&key)\n    }\n\n    /// Construct a new set from the current set with the given value\n    /// added.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// let set = ordset![456];\n    /// assert_eq!(\n    ///   set.update(123),\n    ///   ordset![123, 456]\n    /// );\n    /// ```\n    #[must_use]\n    pub fn update(&self, a: A) -> Self {\n        let mut out = self.clone();\n        out.insert(a);\n        out\n    }\n\n    /// Construct a new set with the given value removed if it's in\n    /// the set.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn without<BA>(&self, a: &BA) -> Self\n    where\n        BA: Ord + ?Sized,\n        A: Borrow<BA>,\n    {\n        let mut out = self.clone();\n        out.remove(a);\n        out\n    }\n\n    /// Remove the smallest value from a set, and return that value as\n    /// well as the updated set.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn without_min(&self) -> (Option<A>, Self) {\n        match self.get_min() {\n            Some(v) => (Some(v.clone()), self.without(&v)),\n            None => (None, self.clone()),\n        }\n    }\n\n    /// Remove the largest value from a set, and return that value as\n    /// well as the updated set.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn without_max(&self) -> (Option<A>, Self) {\n        match self.get_max() {\n            Some(v) => (Some(v.clone()), self.without(&v)),\n            None => (None, self.clone()),\n        }\n    }\n\n    /// Construct the union of two sets.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// let set1 = ordset!{1, 2};\n    /// let set2 = ordset!{2, 3};\n    /// let expected = ordset!{1, 2, 3};\n    /// assert_eq!(expected, set1.union(set2));\n    /// ```\n    #[must_use]\n    pub fn union(mut self, other: Self) -> Self {\n        for value in other {\n            self.insert(value);\n        }\n        self\n    }\n\n    /// Construct the union of multiple sets.\n    ///\n    /// Time: O(n log n)\n    #[must_use]\n    pub fn unions<I>(i: I) -> Self\n    where\n        I: IntoIterator<Item = Self>,\n    {\n        i.into_iter().fold(Self::default(), Self::union)\n    }\n\n    /// Construct the symmetric difference between two sets.\n    ///\n    /// This is an alias for the\n    /// [`symmetric_difference`][symmetric_difference] method.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// let set1 = ordset!{1, 2};\n    /// let set2 = ordset!{2, 3};\n    /// let expected = ordset!{1, 3};\n    /// assert_eq!(expected, set1.difference(set2));\n    /// ```\n    ///\n    /// [symmetric_difference]: #method.symmetric_difference\n    #[must_use]\n    pub fn difference(self, other: Self) -> Self {\n        self.symmetric_difference(other)\n    }\n\n    /// Construct the symmetric difference between two sets.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// let set1 = ordset!{1, 2};\n    /// let set2 = ordset!{2, 3};\n    /// let expected = ordset!{1, 3};\n    /// assert_eq!(expected, set1.symmetric_difference(set2));\n    /// ```\n    #[must_use]\n    pub fn symmetric_difference(mut self, other: Self) -> Self {\n        for value in other {\n            if self.remove(&value).is_none() {\n                self.insert(value);\n            }\n        }\n        self\n    }\n\n    /// Construct the relative complement between two sets, that is the set\n    /// of values in `self` that do not occur in `other`.\n    ///\n    /// Time: O(m log n) where m is the size of the other set\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// let set1 = ordset!{1, 2};\n    /// let set2 = ordset!{2, 3};\n    /// let expected = ordset!{1};\n    /// assert_eq!(expected, set1.relative_complement(set2));\n    /// ```\n    #[must_use]\n    pub fn relative_complement(mut self, other: Self) -> Self {\n        for value in other {\n            let _ = self.remove(&value);\n        }\n        self\n    }\n\n    /// Construct the intersection of two sets.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// let set1 = ordset!{1, 2};\n    /// let set2 = ordset!{2, 3};\n    /// let expected = ordset!{2};\n    /// assert_eq!(expected, set1.intersection(set2));\n    /// ```\n    #[must_use]\n    pub fn intersection(self, other: Self) -> Self {\n        let mut out = Self::default();\n        for value in other {\n            if self.contains(&value) {\n                out.insert(value);\n            }\n        }\n        out\n    }\n\n    /// Split a set into two, with the left hand set containing values\n    /// which are smaller than `split`, and the right hand set\n    /// containing values which are larger than `split`.\n    ///\n    /// The `split` value itself is discarded.\n    ///\n    /// Time: O(n)\n    #[must_use]\n    pub fn split<BA>(self, split: &BA) -> (Self, Self)\n    where\n        BA: Ord + ?Sized,\n        A: Borrow<BA>,\n    {\n        let (left, _, right) = self.split_member(split);\n        (left, right)\n    }\n\n    /// Split a set into two, with the left hand set containing values\n    /// which are smaller than `split`, and the right hand set\n    /// containing values which are larger than `split`.\n    ///\n    /// Returns a tuple of the two sets and a boolean which is true if\n    /// the `split` value existed in the original set, and false\n    /// otherwise.\n    ///\n    /// Time: O(n)\n    #[must_use]\n    pub fn split_member<BA>(self, split: &BA) -> (Self, bool, Self)\n    where\n        BA: Ord + ?Sized,\n        A: Borrow<BA>,\n    {\n        let mut left = Self::default();\n        let mut right = Self::default();\n        let mut present = false;\n        for value in self {\n            match value.borrow().cmp(split) {\n                Ordering::Less => {\n                    left.insert(value);\n                }\n                Ordering::Equal => {\n                    present = true;\n                }\n                Ordering::Greater => {\n                    right.insert(value);\n                }\n            }\n        }\n        (left, present, right)\n    }\n\n    /// Construct a set with only the `n` smallest values from a given\n    /// set.\n    ///\n    /// Time: O(n)\n    #[must_use]\n    pub fn take(&self, n: usize) -> Self {\n        self.iter().take(n).cloned().collect()\n    }\n\n    /// Construct a set with the `n` smallest values removed from a\n    /// given set.\n    ///\n    /// Time: O(n)\n    #[must_use]\n    pub fn skip(&self, n: usize) -> Self {\n        self.iter().skip(n).cloned().collect()\n    }\n}","impl<A> OrdSet<A>\nwhere\n    A: Ord,\n{\n    /// Get the smallest value in a set.\n    ///\n    /// If the set is empty, returns `None`.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn get_min(&self) -> Option<&A> {\n        self.root.min().map(Deref::deref)\n    }\n\n    /// Get the largest value in a set.\n    ///\n    /// If the set is empty, returns `None`.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn get_max(&self) -> Option<&A> {\n        self.root.max().map(Deref::deref)\n    }\n\n    /// Create an iterator over the contents of the set.\n    #[must_use]\n    pub fn iter(&self) -> Iter<'_, A> {\n        Iter {\n            it: NodeIter::new(&self.root, self.size, ..),\n        }\n    }\n\n    /// Create an iterator over a range inside the set.\n    #[must_use]\n    pub fn range<R, BA>(&self, range: R) -> RangedIter<'_, A>\n    where\n        R: RangeBounds<BA>,\n        A: Borrow<BA>,\n        BA: Ord + ?Sized,\n    {\n        RangedIter {\n            it: NodeIter::new(&self.root, self.size, range),\n        }\n    }\n\n    /// Get an iterator over the differences between this set and\n    /// another, i.e. the set of entries to add or remove to this set\n    /// in order to make it equal to the other set.\n    ///\n    /// This function will avoid visiting nodes which are shared\n    /// between the two sets, meaning that even very large sets can be\n    /// compared quickly if most of their structure is shared.\n    ///\n    /// Time: O(n) (where n is the number of unique elements across\n    /// the two sets, minus the number of elements belonging to nodes\n    /// shared between them)\n    #[must_use]\n    pub fn diff<'a>(&'a self, other: &'a Self) -> DiffIter<'_, A> {\n        DiffIter {\n            it: NodeDiffIter::new(&self.root, &other.root),\n        }\n    }\n\n    /// Test if a value is part of a set.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// let mut set = ordset!{1, 2, 3};\n    /// assert!(set.contains(&1));\n    /// assert!(!set.contains(&4));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn contains<BA>(&self, a: &BA) -> bool\n    where\n        BA: Ord + ?Sized,\n        A: Borrow<BA>,\n    {\n        self.root.lookup(a).is_some()\n    }\n\n    /// Get the closest smaller value in a set to a given value.\n    ///\n    /// If the set contains the given value, this is returned.\n    /// Otherwise, the closest value in the set smaller than the\n    /// given value is returned. If the smallest value in the set\n    /// is larger than the given value, `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::OrdSet;\n    /// let set = ordset![1, 3, 5, 7, 9];\n    /// assert_eq!(Some(&5), set.get_prev(&6));\n    /// ```\n    #[must_use]\n    pub fn get_prev(&self, key: &A) -> Option<&A> {\n        self.root.lookup_prev(key).map(|v| &v.0)\n    }\n\n    /// Get the closest larger value in a set to a given value.\n    ///\n    /// If the set contains the given value, this is returned.\n    /// Otherwise, the closest value in the set larger than the\n    /// given value is returned. If the largest value in the set\n    /// is smaller than the given value, `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::OrdSet;\n    /// let set = ordset![1, 3, 5, 7, 9];\n    /// assert_eq!(Some(&5), set.get_next(&4));\n    /// ```\n    #[must_use]\n    pub fn get_next(&self, key: &A) -> Option<&A> {\n        self.root.lookup_next(key).map(|v| &v.0)\n    }\n\n    /// Test whether a set is a subset of another set, meaning that\n    /// all values in our set must also be in the other set.\n    ///\n    /// Time: O(n log m) where m is the size of the other set\n    #[must_use]\n    pub fn is_subset<RS>(&self, other: RS) -> bool\n    where\n        RS: Borrow<Self>,\n    {\n        let other = other.borrow();\n        if other.len() < self.len() {\n            return false;\n        }\n        self.iter().all(|a| other.contains(&a))\n    }\n\n    /// Test whether a set is a proper subset of another set, meaning\n    /// that all values in our set must also be in the other set. A\n    /// proper subset must also be smaller than the other set.\n    ///\n    /// Time: O(n log m) where m is the size of the other set\n    #[must_use]\n    pub fn is_proper_subset<RS>(&self, other: RS) -> bool\n    where\n        RS: Borrow<Self>,\n    {\n        self.len() != other.borrow().len() && self.is_subset(other)\n    }\n}","impl<A> OrdSet<A> {\n    /// Construct an empty set.\n    #[must_use]\n    pub fn new() -> Self {\n        let pool = OrdSetPool::default();\n        let root = PoolRef::default(&pool.0);\n        OrdSet {\n            size: 0,\n            pool,\n            root,\n        }\n    }\n\n    /// Construct an empty set using a specific memory pool.\n    #[cfg(feature = \"pool\")]\n    #[must_use]\n    pub fn with_pool(pool: &OrdSetPool<A>) -> Self {\n        let root = PoolRef::default(&pool.0);\n        OrdSet {\n            size: 0,\n            pool: pool.clone(),\n            root,\n        }\n    }\n\n    /// Construct a set with a single value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// let set = OrdSet::unit(123);\n    /// assert!(set.contains(&123));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn unit(a: A) -> Self {\n        let pool = OrdSetPool::default();\n        let root = PoolRef::new(&pool.0, Node::unit(Value(a)));\n        OrdSet {\n            size: 1,\n            pool,\n            root,\n        }\n    }\n\n    /// Test whether a set is empty.\n    ///\n    /// Time: O(1)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// assert!(\n    ///   !ordset![1, 2, 3].is_empty()\n    /// );\n    /// assert!(\n    ///   OrdSet::<i32>::new().is_empty()\n    /// );\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Get the size of a set.\n    ///\n    /// Time: O(1)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::ordset::OrdSet;\n    /// assert_eq!(3, ordset![1, 2, 3].len());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn len(&self) -> usize {\n        self.size\n    }\n\n    /// Test whether two sets refer to the same content in memory.\n    ///\n    /// This is true if the two sides are references to the same set,\n    /// or if the two sets refer to the same root node.\n    ///\n    /// This would return true if you're comparing a set to itself, or\n    /// if you're comparing a set to a fresh clone of itself.\n    ///\n    /// Time: O(1)\n    pub fn ptr_eq(&self, other: &Self) -> bool {\n        std::ptr::eq(self, other) || PoolRef::ptr_eq(&self.root, &other.root)\n    }\n\n    /// Get a reference to the memory pool used by this set.\n    ///\n    /// Note that if you didn't specifically construct it with a pool, you'll\n    /// get back a reference to a pool of size 0.\n    #[cfg(feature = \"pool\")]\n    pub fn pool(&self) -> &OrdSetPool<A> {\n        &self.pool\n    }\n\n    /// Discard all elements from the set.\n    ///\n    /// This leaves you with an empty set, and all elements that\n    /// were previously inside it are dropped.\n    ///\n    /// Time: O(n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::OrdSet;\n    /// let mut set = ordset![1, 2, 3];\n    /// set.clear();\n    /// assert!(set.is_empty());\n    /// ```\n    pub fn clear(&mut self) {\n        if !self.is_empty() {\n            self.root = PoolRef::default(&self.pool.0);\n            self.size = 0;\n        }\n    }\n}"],"ord::set::OrdSetPool":["impl<$($arg,)*> $name<$($arg,)*> {\n            /// Create a new pool with the given size.\n            pub fn new(size: usize) -> Self {\n                Self(Pool::new(size))\n            }\n\n            /// Fill the pool with preallocated chunks.\n            pub fn fill(&self) {\n                self.0.fill();\n            }\n\n            ///Get the current size of the pool.\n            pub fn pool_size(&self) -> usize {\n                self.0.get_pool_size()\n            }\n        }","impl<$($arg,)*> Clone for $name<$($arg,)*> {\n            fn clone(&self) -> Self {\n                Self(self.0.clone())\n            }\n        }","impl<$($arg,)*> Default for $name<$($arg,)*> {\n            fn default() -> Self {\n                Self::new($crate::config::POOL_SIZE)\n            }\n        }"],"ord::set::RangedIter":["impl<'a, A> DoubleEndedIterator for RangedIter<'a, A>\nwhere\n    A: 'a + Ord,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.it.next_back().map(Deref::deref)\n    }\n}","impl<'a, A> Iterator for RangedIter<'a, A>\nwhere\n    A: 'a + Ord,\n{\n    type Item = &'a A;\n\n    /// Advance the iterator and return the next value.\n    ///\n    /// Time: O(1)*\n    fn next(&mut self) -> Option<Self::Item> {\n        self.it.next().map(Deref::deref)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n}"],"ord::set::Value":["Clone","Copy","Debug","Eq","Ord","PartialEq","PartialOrd","impl<A: Ord + Copy> BTreeValue for Value<A> {\n    fn search_key<BK>(slice: &[Self], key: &BK) -> Result<usize, usize>\n    where\n        BK: Ord + ?Sized,\n        Self::Key: Borrow<BK>,\n    {\n        linear_search_by(slice, |value| Self::Key::borrow(value).cmp(key))\n    }\n\n    fn search_value(slice: &[Self], key: &Self) -> Result<usize, usize> {\n        linear_search_by(slice, |value| value.cmp(key))\n    }\n}","impl<A: Ord> BTreeValue for Value<A> {\n    type Key = A;\n\n    fn ptr_eq(&self, _other: &Self) -> bool {\n        false\n    }\n\n    default fn search_key<BK>(slice: &[Self], key: &BK) -> Result<usize, usize>\n    where\n        BK: Ord + ?Sized,\n        Self::Key: Borrow<BK>,\n    {\n        slice.binary_search_by(|value| Self::Key::borrow(value).cmp(key))\n    }\n\n    default fn search_value(slice: &[Self], key: &Self) -> Result<usize, usize> {\n        slice.binary_search_by(|value| value.cmp(key))\n    }\n\n    fn cmp_keys<BK>(&self, other: &BK) -> Ordering\n    where\n        BK: Ord + ?Sized,\n        Self::Key: Borrow<BK>,\n    {\n        Self::Key::borrow(self).cmp(other)\n    }\n\n    fn cmp_values(&self, other: &Self) -> Ordering {\n        self.cmp(other)\n    }\n}","impl<A> Deref for Value<A> {\n    type Target = A;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}"],"sync::lock::Lock":["impl<A> Clone for Lock<A> {\n        fn clone(&self) -> Self {\n            Lock {\n                lock: self.lock.clone(),\n            }\n        }\n    }","impl<A> Lock<A> {\n        pub(crate) fn new(value: A) -> Self {\n            Lock {\n                lock: Arc::new(Mutex::new(value)),\n            }\n        }\n\n        #[inline]\n        pub(crate) fn lock(&mut self) -> Option<MutexGuard<'_, A>> {\n            self.lock.lock().ok()\n        }\n    }"],"util::Side":["Clone","Copy","Debug","Eq","PartialEq"],"vector::Chunks":["impl<'a, A: Clone> Chunks<'a, A> {\n    fn new(seq: &'a Vector<A>) -> Self {\n        Chunks {\n            focus: seq.focus(),\n            front_index: 0,\n            back_index: seq.len(),\n        }\n    }\n}","impl<'a, A: Clone> DoubleEndedIterator for Chunks<'a, A> {\n    /// Remove and return an element from the back of the iterator.\n    ///\n    /// Time: O(1)*\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        self.back_index -= 1;\n        #[allow(unsafe_code)]\n        let focus: &'a mut Focus<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let (range, value) = focus.chunk_at(self.back_index);\n        self.back_index = range.start;\n        Some(value)\n    }\n}","impl<'a, A: Clone> FusedIterator for Chunks<'a, A> {}","impl<'a, A: Clone> Iterator for Chunks<'a, A> {\n    type Item = &'a [A];\n\n    /// Advance the iterator and return the next value.\n    ///\n    /// Time: O(1)*\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        #[allow(unsafe_code)]\n        let focus: &'a mut Focus<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let (range, value) = focus.chunk_at(self.front_index);\n        self.front_index = range.end;\n        Some(value)\n    }\n}"],"vector::ChunksMut":["impl<'a, A: Clone> ChunksMut<'a, A> {\n    fn new(seq: &'a mut Vector<A>) -> Self {\n        let len = seq.len();\n        ChunksMut {\n            focus: seq.focus_mut(),\n            front_index: 0,\n            back_index: len,\n        }\n    }\n}","impl<'a, A: Clone> DoubleEndedIterator for ChunksMut<'a, A> {\n    /// Remove and return an element from the back of the iterator.\n    ///\n    /// Time: O(1)*\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        self.back_index -= 1;\n        #[allow(unsafe_code)]\n        let focus: &'a mut FocusMut<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let (range, value) = focus.chunk_at(self.back_index);\n        self.back_index = range.start;\n        Some(value)\n    }\n}","impl<'a, A: Clone> FusedIterator for ChunksMut<'a, A> {}","impl<'a, A: Clone> Iterator for ChunksMut<'a, A> {\n    type Item = &'a mut [A];\n\n    /// Advance the iterator and return the next value.\n    ///\n    /// Time: O(1)*\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        #[allow(unsafe_code)]\n        let focus: &'a mut FocusMut<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let (range, value) = focus.chunk_at(self.front_index);\n        self.front_index = range.end;\n        Some(value)\n    }\n}"],"vector::ConsumingIter":["impl<A: Clone> ConsumingIter<A> {\n    fn new(vector: Vector<A>) -> Self {\n        Self { vector }\n    }\n}","impl<A: Clone> DoubleEndedIterator for ConsumingIter<A> {\n    /// Remove and return an element from the back of the iterator.\n    ///\n    /// Time: O(1)*\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.vector.pop_back()\n    }\n}","impl<A: Clone> ExactSizeIterator for ConsumingIter<A> {}","impl<A: Clone> FusedIterator for ConsumingIter<A> {}","impl<A: Clone> Iterator for ConsumingIter<A> {\n    type Item = A;\n\n    /// Advance the iterator and return the next value.\n    ///\n    /// Time: O(1)*\n    fn next(&mut self) -> Option<Self::Item> {\n        self.vector.pop_front()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.vector.len();\n        (len, Some(len))\n    }\n}"],"vector::Iter":["impl<'a, A: Clone> DoubleEndedIterator for Iter<'a, A> {\n    /// Advance the iterator and return the next value.\n    ///\n    /// Time: O(1)*\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        self.back_index -= 1;\n        #[allow(unsafe_code)]\n        let focus: &'a mut Focus<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        focus.get(self.back_index)\n    }\n}","impl<'a, A: Clone> ExactSizeIterator for Iter<'a, A> {}","impl<'a, A: Clone> FusedIterator for Iter<'a, A> {}","impl<'a, A: Clone> Iter<'a, A> {\n    fn new(seq: &'a Vector<A>) -> Self {\n        Iter {\n            focus: seq.focus(),\n            front_index: 0,\n            back_index: seq.len(),\n        }\n    }\n\n    fn from_focus(focus: Focus<'a, A>) -> Self {\n        Iter {\n            front_index: 0,\n            back_index: focus.len(),\n            focus,\n        }\n    }\n}","impl<'a, A: Clone> Iterator for Iter<'a, A> {\n    type Item = &'a A;\n\n    /// Advance the iterator and return the next value.\n    ///\n    /// Time: O(1)*\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        #[allow(unsafe_code)]\n        let focus: &'a mut Focus<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let value = focus.get(self.front_index);\n        self.front_index += 1;\n        value\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.back_index - self.front_index;\n        (remaining, Some(remaining))\n    }\n}"],"vector::IterMut":["impl<'a, A: Clone> ExactSizeIterator for IterMut<'a, A> {}","impl<'a, A: Clone> FusedIterator for IterMut<'a, A> {}","impl<'a, A> DoubleEndedIterator for IterMut<'a, A>\nwhere\n    A: 'a + Clone,\n{\n    /// Remove and return an element from the back of the iterator.\n    ///\n    /// Time: O(1)*\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        self.back_index -= 1;\n        #[allow(unsafe_code)]\n        let focus: &'a mut FocusMut<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        focus.get_mut(self.back_index)\n    }\n}","impl<'a, A> IterMut<'a, A>\nwhere\n    A: Clone,\n{\n    fn new(seq: &'a mut Vector<A>) -> Self {\n        let focus = seq.focus_mut();\n        let len = focus.len();\n        IterMut {\n            focus,\n            front_index: 0,\n            back_index: len,\n        }\n    }\n\n    fn from_focus(focus: FocusMut<'a, A>) -> Self {\n        IterMut {\n            front_index: 0,\n            back_index: focus.len(),\n            focus,\n        }\n    }\n}","impl<'a, A> Iterator for IterMut<'a, A>\nwhere\n    A: 'a + Clone,\n{\n    type Item = &'a mut A;\n\n    /// Advance the iterator and return the next value.\n    ///\n    /// Time: O(1)*\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        #[allow(unsafe_code)]\n        let focus: &'a mut FocusMut<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let value = focus.get_mut(self.front_index);\n        self.front_index += 1;\n        value\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.back_index - self.front_index;\n        (remaining, Some(remaining))\n    }\n}"],"vector::RRB":["impl<A: Clone> RRB<A> {\n    fn new(pool: &RRBPool<A>) -> Self {\n        RRB {\n            length: 0,\n            middle_level: 0,\n            outer_f: PoolRef::default(&pool.value_pool),\n            inner_f: PoolRef::default(&pool.value_pool),\n            middle: Ref::new(Node::new()),\n            inner_b: PoolRef::default(&pool.value_pool),\n            outer_b: PoolRef::default(&pool.value_pool),\n        }\n    }\n\n    #[cfg(any(test, feature = \"debug\"))]\n    fn assert_invariants(&self) {\n        let ml = self.middle.assert_invariants(self.middle_level);\n        assert_eq!(\n            self.length,\n            self.outer_f.len() + self.inner_f.len() + ml + self.inner_b.len() + self.outer_b.len()\n        );\n    }\n\n    fn prune(&mut self) {\n        if self.middle.is_empty() {\n            self.middle = Ref::new(Node::new());\n            self.middle_level = 0;\n        } else {\n            while self.middle_level > 0 && self.middle.is_single() {\n                // FIXME could be optimised, cloning the node is expensive\n                self.middle = Ref::new(self.middle.first_child().clone());\n                self.middle_level -= 1;\n            }\n        }\n    }\n\n    fn pop_front(&mut self, pool: &RRBPool<A>) -> Option<A> {\n        if self.length == 0 {\n            return None;\n        }\n        if self.outer_f.is_empty() {\n            if self.inner_f.is_empty() {\n                if self.middle.is_empty() {\n                    if self.inner_b.is_empty() {\n                        swap(&mut self.outer_f, &mut self.outer_b);\n                    } else {\n                        swap(&mut self.outer_f, &mut self.inner_b);\n                    }\n                } else {\n                    self.outer_f = self.pop_middle(pool, Side::Left).unwrap();\n                }\n            } else {\n                swap(&mut self.outer_f, &mut self.inner_f);\n            }\n        }\n        self.length -= 1;\n        let outer_f = PoolRef::make_mut(&pool.value_pool, &mut self.outer_f);\n        Some(outer_f.pop_front())\n    }\n\n    fn pop_back(&mut self, pool: &RRBPool<A>) -> Option<A> {\n        if self.length == 0 {\n            return None;\n        }\n        if self.outer_b.is_empty() {\n            if self.inner_b.is_empty() {\n                if self.middle.is_empty() {\n                    if self.inner_f.is_empty() {\n                        swap(&mut self.outer_b, &mut self.outer_f);\n                    } else {\n                        swap(&mut self.outer_b, &mut self.inner_f);\n                    }\n                } else {\n                    self.outer_b = self.pop_middle(pool, Side::Right).unwrap();\n                }\n            } else {\n                swap(&mut self.outer_b, &mut self.inner_b);\n            }\n        }\n        self.length -= 1;\n        let outer_b = PoolRef::make_mut(&pool.value_pool, &mut self.outer_b);\n        Some(outer_b.pop_back())\n    }\n\n    fn push_front(&mut self, pool: &RRBPool<A>, value: A) {\n        if self.outer_f.is_full() {\n            swap(&mut self.outer_f, &mut self.inner_f);\n            if !self.outer_f.is_empty() {\n                let mut chunk = PoolRef::new(&pool.value_pool, Chunk::new());\n                swap(&mut chunk, &mut self.outer_f);\n                self.push_middle(pool, Side::Left, chunk);\n            }\n        }\n        self.length = self.length.checked_add(1).expect(\"Vector length overflow\");\n        let outer_f = PoolRef::make_mut(&pool.value_pool, &mut self.outer_f);\n        outer_f.push_front(value)\n    }\n\n    fn push_back(&mut self, pool: &RRBPool<A>, value: A) {\n        if self.outer_b.is_full() {\n            swap(&mut self.outer_b, &mut self.inner_b);\n            if !self.outer_b.is_empty() {\n                let mut chunk = PoolRef::new(&pool.value_pool, Chunk::new());\n                swap(&mut chunk, &mut self.outer_b);\n                self.push_middle(pool, Side::Right, chunk);\n            }\n        }\n        self.length = self.length.checked_add(1).expect(\"Vector length overflow\");\n        let outer_b = PoolRef::make_mut(&pool.value_pool, &mut self.outer_b);\n        outer_b.push_back(value)\n    }\n\n    fn push_middle(&mut self, pool: &RRBPool<A>, side: Side, chunk: PoolRef<Chunk<A>>) {\n        if chunk.is_empty() {\n            return;\n        }\n        let new_middle = {\n            let middle = Ref::make_mut(&mut self.middle);\n            match middle.push_chunk(pool, self.middle_level, side, chunk) {\n                PushResult::Done => return,\n                PushResult::Full(chunk, _num_drained) => Ref::from({\n                    match side {\n                        Side::Left => Node::from_chunk(pool, self.middle_level, chunk)\n                            .join_branches(pool, middle.clone(), self.middle_level),\n                        Side::Right => middle.clone().join_branches(\n                            pool,\n                            Node::from_chunk(pool, self.middle_level, chunk),\n                            self.middle_level,\n                        ),\n                    }\n                }),\n            }\n        };\n        self.middle_level += 1;\n        self.middle = new_middle;\n    }\n\n    fn pop_middle(&mut self, pool: &RRBPool<A>, side: Side) -> Option<PoolRef<Chunk<A>>> {\n        let chunk = {\n            let middle = Ref::make_mut(&mut self.middle);\n            match middle.pop_chunk(pool, self.middle_level, side) {\n                PopResult::Empty => return None,\n                PopResult::Done(chunk) => chunk,\n                PopResult::Drained(chunk) => {\n                    middle.clear_node();\n                    self.middle_level = 0;\n                    chunk\n                }\n            }\n        };\n        Some(chunk)\n    }\n}","impl<A> Clone for RRB<A> {\n    fn clone(&self) -> Self {\n        RRB {\n            length: self.length,\n            middle_level: self.middle_level,\n            outer_f: self.outer_f.clone(),\n            inner_f: self.inner_f.clone(),\n            middle: self.middle.clone(),\n            inner_b: self.inner_b.clone(),\n            outer_b: self.outer_b.clone(),\n        }\n    }\n}"],"vector::Vector":["impl<'a, A: Clone> From<&'a Vec<A>> for Vector<A> {\n    /// Create a vector from a [`std::vec::Vec`][vec].\n    ///\n    /// Time: O(n)\n    ///\n    /// [vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n    fn from(vec: &Vec<A>) -> Self {\n        vec.iter().cloned().collect()\n    }\n}","impl<'a, A: Clone> From<&'a [A]> for Vector<A> {\n    fn from(slice: &[A]) -> Self {\n        slice.iter().cloned().collect()\n    }\n}","impl<'s, 'a, A, OA> From<&'s Vector<&'a A>> for Vector<OA>\nwhere\n    A: ToOwned<Owned = OA>,\n    OA: Borrow<A> + Clone,\n{\n    fn from(vec: &Vector<&A>) -> Self {\n        vec.iter().map(|a| (*a).to_owned()).collect()\n    }\n}","impl<A: Clone + Debug> Debug for Vector<A> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        f.debug_list().entries(self.iter()).finish()\n        // match self {\n        //     Full(rrb) => {\n        //         writeln!(f, \"Head: {:?} {:?}\", rrb.outer_f, rrb.inner_f)?;\n        //         rrb.middle.print(f, 0, rrb.middle_level)?;\n        //         writeln!(f, \"Tail: {:?} {:?}\", rrb.inner_b, rrb.outer_b)\n        //     }\n        //     Single(_) => write!(f, \"nowt\"),\n        // }\n    }\n}","impl<A: Clone + Eq> Eq for Vector<A> {}","impl<A: Clone + Eq> PartialEq for Vector<A> {\n    fn eq(&self, other: &Self) -> bool {\n        fn cmp_chunk<A>(left: &PoolRef<Chunk<A>>, right: &PoolRef<Chunk<A>>) -> bool {\n            (left.is_empty() && right.is_empty()) || PoolRef::ptr_eq(left, right)\n        }\n\n        if std::ptr::eq(self, other) {\n            return true;\n        }\n\n        match (&self.vector, &other.vector) {\n            (Single(_, left), Single(_, right)) => {\n                if cmp_chunk(left, right) {\n                    return true;\n                }\n                self.iter().eq(other.iter())\n            }\n            (Full(_, left), Full(_, right)) => {\n                if left.length != right.length {\n                    return false;\n                }\n\n                if cmp_chunk(&left.outer_f, &right.outer_f)\n                    && cmp_chunk(&left.inner_f, &right.inner_f)\n                    && cmp_chunk(&left.inner_b, &right.inner_b)\n                    && cmp_chunk(&left.outer_b, &right.outer_b)\n                    && ((left.middle.is_empty() && right.middle.is_empty())\n                        || Ref::ptr_eq(&left.middle, &right.middle))\n                {\n                    return true;\n                }\n                self.iter().eq(other.iter())\n            }\n            _ => self.len() == other.len() && self.iter().eq(other.iter()),\n        }\n    }\n}","impl<A: Clone + Hash> Hash for Vector<A> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        for i in self {\n            i.hash(state)\n        }\n    }\n}","impl<A: Clone + Ord> Ord for Vector<A> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.iter().cmp(other.iter())\n    }\n}","impl<A: Clone + PartialEq> PartialEq for Vector<A> {\n    default fn eq(&self, other: &Self) -> bool {\n        self.len() == other.len() && self.iter().eq(other.iter())\n    }\n}","impl<A: Clone + PartialOrd> PartialOrd for Vector<A> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.iter().partial_cmp(other.iter())\n    }\n}","impl<A: Clone> Add for Vector<A> {\n    type Output = Vector<A>;\n\n    /// Concatenate two vectors.\n    ///\n    /// Time: O(log n)\n    fn add(mut self, other: Self) -> Self::Output {\n        self.append(other);\n        self\n    }\n}","impl<A: Clone> Clone for Vector<A> {\n    /// Clone a vector.\n    ///\n    /// Time: O(1), or O(n) with a very small, bounded *n* for an inline vector.\n    fn clone(&self) -> Self {\n        Self {\n            vector: match &self.vector {\n                Inline(pool, chunk) => Inline(pool.clone(), chunk.clone()),\n                Single(pool, chunk) => Single(pool.clone(), chunk.clone()),\n                Full(pool, tree) => Full(pool.clone(), tree.clone()),\n            },\n        }\n    }\n}","impl<A: Clone> Default for Vector<A> {\n    fn default() -> Self {\n        Self::new()\n    }\n}","impl<A: Clone> Extend<A> for Vector<A> {\n    /// Add values to the end of a vector by consuming an iterator.\n    ///\n    /// Time: O(n)\n    fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = A>,\n    {\n        for item in iter {\n            self.push_back(item)\n        }\n    }\n}","impl<A: Clone> From<Vec<A>> for Vector<A> {\n    /// Create a vector from a [`std::vec::Vec`][vec].\n    ///\n    /// Time: O(n)\n    ///\n    /// [vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n    fn from(vec: Vec<A>) -> Self {\n        vec.into_iter().collect()\n    }\n}","impl<A: Clone> FromIterator<A> for Vector<A> {\n    /// Create a vector from an iterator.\n    ///\n    /// Time: O(n)\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = A>,\n    {\n        let mut seq = Self::new();\n        for item in iter {\n            seq.push_back(item)\n        }\n        seq\n    }\n}","impl<A: Clone> Index<usize> for Vector<A> {\n    type Output = A;\n    /// Get a reference to the value at index `index` in the vector.\n    ///\n    /// Time: O(log n)\n    fn index(&self, index: usize) -> &Self::Output {\n        match self.get(index) {\n            Some(value) => value,\n            None => panic!(\n                \"Vector::index: index out of bounds: {} < {}\",\n                index,\n                self.len()\n            ),\n        }\n    }\n}","impl<A: Clone> IndexMut<usize> for Vector<A> {\n    /// Get a mutable reference to the value at index `index` in the\n    /// vector.\n    ///\n    /// Time: O(log n)\n    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        match self.get_mut(index) {\n            Some(value) => value,\n            None => panic!(\"Vector::index_mut: index out of bounds\"),\n        }\n    }\n}","impl<A: Clone> IntoIterator for Vector<A> {\n    type Item = A;\n    type IntoIter = ConsumingIter<A>;\n    fn into_iter(self) -> Self::IntoIter {\n        ConsumingIter::new(self)\n    }\n}","impl<A: Clone> Sum for Vector<A> {\n    fn sum<I>(it: I) -> Self\n    where\n        I: Iterator<Item = Self>,\n    {\n        it.fold(Self::new(), |a, b| a + b)\n    }\n}","impl<A: Clone> Vector<A> {\n    /// Construct a vector with a single value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// let vec = Vector::unit(1337);\n    /// assert_eq!(1, vec.len());\n    /// assert_eq!(\n    ///   vec.get(0),\n    ///   Some(&1337)\n    /// );\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn unit(a: A) -> Self {\n        let pool = RRBPool::default();\n        if InlineArray::<A, RRB<A>>::CAPACITY > 0 {\n            let mut array = InlineArray::new();\n            array.push(a);\n            Self {\n                vector: Inline(pool, array),\n            }\n        } else {\n            let chunk = PoolRef::new(&pool.value_pool, Chunk::unit(a));\n            Self {\n                vector: Single(pool, chunk),\n            }\n        }\n    }\n\n    /// Create a new vector with the value at index `index` updated.\n    ///\n    /// Panics if the index is out of bounds.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::Vector;\n    /// let mut vec = vector![1, 2, 3];\n    /// assert_eq!(vector![1, 5, 3], vec.update(1, 5));\n    /// ```\n    #[must_use]\n    pub fn update(&self, index: usize, value: A) -> Self {\n        let mut out = self.clone();\n        out[index] = value;\n        out\n    }\n\n    /// Update the value at index `index` in a vector.\n    ///\n    /// Returns the previous value at the index.\n    ///\n    /// Panics if the index is out of bounds.\n    ///\n    /// Time: O(log n)\n    #[inline]\n    pub fn set(&mut self, index: usize, value: A) -> A {\n        replace(&mut self[index], value)\n    }\n\n    /// Swap the elements at indices `i` and `j`.\n    ///\n    /// Time: O(log n)\n    pub fn swap(&mut self, i: usize, j: usize) {\n        swap_indices(self, i, j)\n    }\n\n    /// Push a value to the front of a vector.\n    ///\n    /// Time: O(1)*\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::Vector;\n    /// let mut vec = vector![5, 6, 7];\n    /// vec.push_front(4);\n    /// assert_eq!(vector![4, 5, 6, 7], vec);\n    /// ```\n    pub fn push_front(&mut self, value: A) {\n        if self.needs_promotion() {\n            self.promote_back();\n        }\n        match &mut self.vector {\n            Inline(_, chunk) => {\n                chunk.insert(0, value);\n            }\n            Single(pool, chunk) => PoolRef::make_mut(&pool.value_pool, chunk).push_front(value),\n            Full(pool, tree) => tree.push_front(pool, value),\n        }\n    }\n\n    /// Push a value to the back of a vector.\n    ///\n    /// Time: O(1)*\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::Vector;\n    /// let mut vec = vector![1, 2, 3];\n    /// vec.push_back(4);\n    /// assert_eq!(vector![1, 2, 3, 4], vec);\n    /// ```\n    pub fn push_back(&mut self, value: A) {\n        if self.needs_promotion() {\n            self.promote_front();\n        }\n        match &mut self.vector {\n            Inline(_, chunk) => {\n                chunk.push(value);\n            }\n            Single(pool, chunk) => PoolRef::make_mut(&pool.value_pool, chunk).push_back(value),\n            Full(pool, tree) => tree.push_back(pool, value),\n        }\n    }\n\n    /// Remove the first element from a vector and return it.\n    ///\n    /// Time: O(1)*\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::Vector;\n    /// let mut vec = vector![1, 2, 3];\n    /// assert_eq!(Some(1), vec.pop_front());\n    /// assert_eq!(vector![2, 3], vec);\n    /// ```\n    pub fn pop_front(&mut self) -> Option<A> {\n        if self.is_empty() {\n            None\n        } else {\n            match &mut self.vector {\n                Inline(_, chunk) => chunk.remove(0),\n                Single(pool, chunk) => Some(PoolRef::make_mut(&pool.value_pool, chunk).pop_front()),\n                Full(pool, tree) => tree.pop_front(pool),\n            }\n        }\n    }\n\n    /// Remove the last element from a vector and return it.\n    ///\n    /// Time: O(1)*\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::Vector;\n    /// let mut vec = vector![1, 2, 3];\n    /// assert_eq!(Some(3), vec.pop_back());\n    /// assert_eq!(vector![1, 2], vec);\n    /// ```\n    pub fn pop_back(&mut self) -> Option<A> {\n        if self.is_empty() {\n            None\n        } else {\n            match &mut self.vector {\n                Inline(_, chunk) => chunk.pop(),\n                Single(pool, chunk) => Some(PoolRef::make_mut(&pool.value_pool, chunk).pop_back()),\n                Full(pool, tree) => tree.pop_back(pool),\n            }\n        }\n    }\n\n    /// Append the vector `other` to the end of the current vector.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// let mut vec = vector![1, 2, 3];\n    /// vec.append(vector![7, 8, 9]);\n    /// assert_eq!(vector![1, 2, 3, 7, 8, 9], vec);\n    /// ```\n    pub fn append(&mut self, mut other: Self) {\n        if other.is_empty() {\n            return;\n        }\n\n        if self.is_empty() {\n            replace(self, other);\n            return;\n        }\n\n        self.promote_inline();\n        other.promote_inline();\n\n        let total_length = self\n            .len()\n            .checked_add(other.len())\n            .expect(\"Vector length overflow\");\n\n        match &mut self.vector {\n            Inline(_, _) => unreachable!(\"inline vecs should have been promoted\"),\n            Single(pool, left) => {\n                match &mut other.vector {\n                    Inline(_, _) => unreachable!(\"inline vecs should have been promoted\"),\n                    // If both are single chunks and left has room for right: directly\n                    // memcpy right into left\n                    Single(_, ref mut right) if total_length <= CHUNK_SIZE => {\n                        PoolRef::make_mut(&pool.value_pool, left)\n                            .append(PoolRef::make_mut(&pool.value_pool, right));\n                        return;\n                    }\n                    // If only left is a single chunk and has room for right: push\n                    // right's elements into left\n                    _ if total_length <= CHUNK_SIZE => {\n                        while let Some(value) = other.pop_front() {\n                            PoolRef::make_mut(&pool.value_pool, left).push_back(value);\n                        }\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n            Full(pool, left) => {\n                if let Full(_, mut right) = other.vector {\n                    // If left and right are trees with empty middles, left has no back\n                    // buffers, and right has no front buffers: copy right's back\n                    // buffers over to left\n                    if left.middle.is_empty()\n                        && right.middle.is_empty()\n                        && left.outer_b.is_empty()\n                        && left.inner_b.is_empty()\n                        && right.outer_f.is_empty()\n                        && right.inner_f.is_empty()\n                    {\n                        left.inner_b = right.inner_b;\n                        left.outer_b = right.outer_b;\n                        left.length = total_length;\n                        return;\n                    }\n                    // If left and right are trees with empty middles and left's buffers\n                    // can fit right's buffers: push right's elements onto left\n                    if left.middle.is_empty()\n                        && right.middle.is_empty()\n                        && total_length <= CHUNK_SIZE * 4\n                    {\n                        while let Some(value) = right.pop_front(pool) {\n                            left.push_back(pool, value);\n                        }\n                        return;\n                    }\n                    // Both are full and big: do the full RRB join\n                    let inner_b1 = left.inner_b.clone();\n                    left.push_middle(pool, Side::Right, inner_b1);\n                    let outer_b1 = left.outer_b.clone();\n                    left.push_middle(pool, Side::Right, outer_b1);\n                    let inner_f2 = right.inner_f.clone();\n                    right.push_middle(pool, Side::Left, inner_f2);\n                    let outer_f2 = right.outer_f.clone();\n                    right.push_middle(pool, Side::Left, outer_f2);\n\n                    let mut middle1 = clone_ref(replace(&mut left.middle, Ref::from(Node::new())));\n                    let mut middle2 = clone_ref(right.middle);\n                    let normalised_middle = match left.middle_level.cmp(&right.middle_level) {\n                        Ordering::Greater => {\n                            middle2 = middle2.elevate(pool, left.middle_level - right.middle_level);\n                            left.middle_level\n                        }\n                        Ordering::Less => {\n                            middle1 = middle1.elevate(pool, right.middle_level - left.middle_level);\n                            right.middle_level\n                        }\n                        Ordering::Equal => left.middle_level,\n                    };\n                    left.middle = Ref::new(Node::merge(pool, middle1, middle2, normalised_middle));\n                    left.middle_level = normalised_middle + 1;\n\n                    left.inner_b = right.inner_b;\n                    left.outer_b = right.outer_b;\n                    left.length = total_length;\n                    left.prune();\n                    return;\n                }\n            }\n        }\n        // No optimisations available, and either left, right or both are\n        // single: promote both to full and retry\n        self.promote_front();\n        other.promote_back();\n        self.append(other)\n    }\n\n    /// Retain only the elements specified by the predicate.\n    ///\n    /// Remove all elements for which the provided function `f`\n    /// returns false from the vector.\n    ///\n    /// Time: O(n)\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&A) -> bool,\n    {\n        let len = self.len();\n        let mut del = 0;\n        {\n            let mut focus = self.focus_mut();\n            for i in 0..len {\n                if !f(focus.index(i)) {\n                    del += 1;\n                } else if del > 0 {\n                    focus.swap(i - del, i);\n                }\n            }\n        }\n        if del > 0 {\n            self.split_off(len - del);\n        }\n    }\n\n    /// Split a vector at a given index.\n    ///\n    /// Split a vector at a given index, consuming the vector and\n    /// returning a pair of the left hand side and the right hand side\n    /// of the split.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// let mut vec = vector![1, 2, 3, 7, 8, 9];\n    /// let (left, right) = vec.split_at(3);\n    /// assert_eq!(vector![1, 2, 3], left);\n    /// assert_eq!(vector![7, 8, 9], right);\n    /// ```\n    pub fn split_at(mut self, index: usize) -> (Self, Self) {\n        let right = self.split_off(index);\n        (self, right)\n    }\n\n    /// Split a vector at a given index.\n    ///\n    /// Split a vector at a given index, leaving the left hand side in\n    /// the current vector and returning a new vector containing the\n    /// right hand side.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// let mut left = vector![1, 2, 3, 7, 8, 9];\n    /// let right = left.split_off(3);\n    /// assert_eq!(vector![1, 2, 3], left);\n    /// assert_eq!(vector![7, 8, 9], right);\n    /// ```\n    pub fn split_off(&mut self, index: usize) -> Self {\n        assert!(index <= self.len());\n\n        match &mut self.vector {\n            Inline(pool, chunk) => Self {\n                vector: Inline(pool.clone(), chunk.split_off(index)),\n            },\n            Single(pool, chunk) => Self {\n                vector: Single(\n                    pool.clone(),\n                    PoolRef::new(\n                        &pool.value_pool,\n                        PoolRef::make_mut(&pool.value_pool, chunk).split_off(index),\n                    ),\n                ),\n            },\n            Full(pool, tree) => {\n                let mut local_index = index;\n\n                if local_index < tree.outer_f.len() {\n                    let of2 = PoolRef::make_mut(&pool.value_pool, &mut tree.outer_f)\n                        .split_off(local_index);\n                    let right = RRB {\n                        length: tree.length - index,\n                        middle_level: tree.middle_level,\n                        outer_f: PoolRef::new(&pool.value_pool, of2),\n                        inner_f: replace_pool_def(&pool.value_pool, &mut tree.inner_f),\n                        middle: std::mem::take(&mut tree.middle),\n                        inner_b: replace_pool_def(&pool.value_pool, &mut tree.inner_b),\n                        outer_b: replace_pool_def(&pool.value_pool, &mut tree.outer_b),\n                    };\n                    tree.length = index;\n                    tree.middle_level = 0;\n                    return Self {\n                        vector: Full(pool.clone(), right),\n                    };\n                }\n\n                local_index -= tree.outer_f.len();\n\n                if local_index < tree.inner_f.len() {\n                    let if2 = PoolRef::make_mut(&pool.value_pool, &mut tree.inner_f)\n                        .split_off(local_index);\n                    let right = RRB {\n                        length: tree.length - index,\n                        middle_level: tree.middle_level,\n                        outer_f: PoolRef::new(&pool.value_pool, if2),\n                        inner_f: PoolRef::<Chunk<A>>::default(&pool.value_pool),\n                        middle: std::mem::take(&mut tree.middle),\n                        inner_b: replace_pool_def(&pool.value_pool, &mut tree.inner_b),\n                        outer_b: replace_pool_def(&pool.value_pool, &mut tree.outer_b),\n                    };\n                    tree.length = index;\n                    tree.middle_level = 0;\n                    swap(&mut tree.outer_b, &mut tree.inner_f);\n                    return Self {\n                        vector: Full(pool.clone(), right),\n                    };\n                }\n\n                local_index -= tree.inner_f.len();\n\n                if local_index < tree.middle.len() {\n                    let mut right_middle = tree.middle.clone();\n                    let (c1, c2) = {\n                        let m1 = Ref::make_mut(&mut tree.middle);\n                        let m2 = Ref::make_mut(&mut right_middle);\n                        match m1.split(pool, tree.middle_level, Side::Right, local_index) {\n                            SplitResult::Dropped(_) => (),\n                            SplitResult::OutOfBounds => unreachable!(),\n                        };\n                        match m2.split(pool, tree.middle_level, Side::Left, local_index) {\n                            SplitResult::Dropped(_) => (),\n                            SplitResult::OutOfBounds => unreachable!(),\n                        };\n                        let c1 = match m1.pop_chunk(pool, tree.middle_level, Side::Right) {\n                            PopResult::Empty => PoolRef::default(&pool.value_pool),\n                            PopResult::Done(chunk) => chunk,\n                            PopResult::Drained(chunk) => {\n                                m1.clear_node();\n                                chunk\n                            }\n                        };\n                        let c2 = match m2.pop_chunk(pool, tree.middle_level, Side::Left) {\n                            PopResult::Empty => PoolRef::default(&pool.value_pool),\n                            PopResult::Done(chunk) => chunk,\n                            PopResult::Drained(chunk) => {\n                                m2.clear_node();\n                                chunk\n                            }\n                        };\n                        (c1, c2)\n                    };\n                    let mut right = RRB {\n                        length: tree.length - index,\n                        middle_level: tree.middle_level,\n                        outer_f: c2,\n                        inner_f: PoolRef::<Chunk<A>>::default(&pool.value_pool),\n                        middle: right_middle,\n                        inner_b: replace_pool_def(&pool.value_pool, &mut tree.inner_b),\n                        outer_b: replace(&mut tree.outer_b, c1),\n                    };\n                    tree.length = index;\n                    tree.prune();\n                    right.prune();\n                    return Self {\n                        vector: Full(pool.clone(), right),\n                    };\n                }\n\n                local_index -= tree.middle.len();\n\n                if local_index < tree.inner_b.len() {\n                    let ib2 = PoolRef::make_mut(&pool.value_pool, &mut tree.inner_b)\n                        .split_off(local_index);\n                    let right = RRB {\n                        length: tree.length - index,\n                        outer_b: replace_pool_def(&pool.value_pool, &mut tree.outer_b),\n                        outer_f: PoolRef::new(&pool.value_pool, ib2),\n                        ..RRB::new(pool)\n                    };\n                    tree.length = index;\n                    swap(&mut tree.outer_b, &mut tree.inner_b);\n                    return Self {\n                        vector: Full(pool.clone(), right),\n                    };\n                }\n\n                local_index -= tree.inner_b.len();\n\n                let ob2 =\n                    PoolRef::make_mut(&pool.value_pool, &mut tree.outer_b).split_off(local_index);\n                tree.length = index;\n                Self {\n                    vector: Single(pool.clone(), PoolRef::new(&pool.value_pool, ob2)),\n                }\n            }\n        }\n    }\n\n    /// Construct a vector with `count` elements removed from the\n    /// start of the current vector.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn skip(&self, count: usize) -> Self {\n        // FIXME can be made more efficient by dropping the unwanted side without constructing it\n        self.clone().split_off(count)\n    }\n\n    /// Construct a vector of the first `count` elements from the\n    /// current vector.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn take(&self, count: usize) -> Self {\n        // FIXME can be made more efficient by dropping the unwanted side without constructing it\n        let mut left = self.clone();\n        left.split_off(count);\n        left\n    }\n\n    /// Truncate a vector to the given size.\n    ///\n    /// Discards all elements in the vector beyond the given length.\n    ///\n    /// Panics if the new length is greater than the current length.\n    ///\n    /// Time: O(log n)\n    pub fn truncate(&mut self, len: usize) {\n        // FIXME can be made more efficient by dropping the unwanted side without constructing it\n        self.split_off(len);\n    }\n\n    /// Extract a slice from a vector.\n    ///\n    /// Remove the elements from `start_index` until `end_index` in\n    /// the current vector and return the removed slice as a new\n    /// vector.\n    ///\n    /// Time: O(log n)\n    pub fn slice<R>(&mut self, range: R) -> Self\n    where\n        R: RangeBounds<usize>,\n    {\n        let r = to_range(&range, self.len());\n        if r.start >= r.end || r.start >= self.len() {\n            return Vector::new();\n        }\n        let mut middle = self.split_off(r.start);\n        let right = middle.split_off(r.end - r.start);\n        self.append(right);\n        middle\n    }\n\n    /// Insert an element into a vector.\n    ///\n    /// Insert an element at position `index`, shifting all elements\n    /// after it to the right.\n    ///\n    /// ## Performance Note\n    ///\n    /// While `push_front` and `push_back` are heavily optimised\n    /// operations, `insert` in the middle of a vector requires a\n    /// split, a push, and an append. Thus, if you want to insert\n    /// many elements at the same location, instead of `insert`ing\n    /// them one by one, you should rather create a new vector\n    /// containing the elements to insert, split the vector at the\n    /// insertion point, and append the left hand, the new vector and\n    /// the right hand in order.\n    ///\n    /// Time: O(log n)\n    pub fn insert(&mut self, index: usize, value: A) {\n        if index == 0 {\n            return self.push_front(value);\n        }\n        if index == self.len() {\n            return self.push_back(value);\n        }\n        assert!(index < self.len());\n        if if let Inline(_, chunk) = &self.vector {\n            chunk.is_full()\n        } else {\n            false\n        } {\n            self.promote_inline();\n        }\n        match &mut self.vector {\n            Inline(_, chunk) => {\n                chunk.insert(index, value);\n            }\n            Single(pool, chunk) if chunk.len() < CHUNK_SIZE => {\n                PoolRef::make_mut(&pool.value_pool, chunk).insert(index, value)\n            }\n            // TODO a lot of optimisations still possible here\n            _ => {\n                let right = self.split_off(index);\n                self.push_back(value);\n                self.append(right);\n            }\n        }\n    }\n\n    /// Remove an element from a vector.\n    ///\n    /// Remove the element from position 'index', shifting all\n    /// elements after it to the left, and return the removec element.\n    ///\n    /// ## Performance Note\n    ///\n    /// While `pop_front` and `pop_back` are heavily optimised\n    /// operations, `remove` in the middle of a vector requires a\n    /// split, a pop, and an append. Thus, if you want to remove many\n    /// elements from the same location, instead of `remove`ing them\n    /// one by one, it is much better to use [`slice`][slice].\n    ///\n    /// Time: O(log n)\n    ///\n    /// [slice]: #method.slice\n    pub fn remove(&mut self, index: usize) -> A {\n        assert!(index < self.len());\n        match &mut self.vector {\n            Inline(_, chunk) => chunk.remove(index).unwrap(),\n            Single(pool, chunk) => PoolRef::make_mut(&pool.value_pool, chunk).remove(index),\n            _ => {\n                if index == 0 {\n                    return self.pop_front().unwrap();\n                }\n                if index == self.len() - 1 {\n                    return self.pop_back().unwrap();\n                }\n                // TODO a lot of optimisations still possible here\n                let mut right = self.split_off(index);\n                let value = right.pop_front().unwrap();\n                self.append(right);\n                value\n            }\n        }\n    }\n\n    /// Insert an element into a sorted vector.\n    ///\n    /// Insert an element into a vector in sorted order, assuming the vector is\n    /// already in sorted order.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// let mut vec = vector![1, 2, 3, 7, 8, 9];\n    /// vec.insert_ord(5);\n    /// assert_eq!(vector![1, 2, 3, 5, 7, 8, 9], vec);\n    /// ```\n    pub fn insert_ord(&mut self, item: A)\n    where\n        A: Ord,\n    {\n        match self.binary_search(&item) {\n            Ok(index) => self.insert(index, item),\n            Err(index) => self.insert(index, item),\n        }\n    }\n\n    /// Sort a vector.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// let mut vec = vector![3, 2, 5, 4, 1];\n    /// vec.sort();\n    /// assert_eq!(vector![1, 2, 3, 4, 5], vec);\n    /// ```\n    pub fn sort(&mut self)\n    where\n        A: Ord,\n    {\n        self.sort_by(Ord::cmp)\n    }\n\n    /// Sort a vector using a comparator function.\n    ///\n    /// Time: O(n log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// let mut vec = vector![3, 2, 5, 4, 1];\n    /// vec.sort_by(|left, right| left.cmp(right));\n    /// assert_eq!(vector![1, 2, 3, 4, 5], vec);\n    /// ```\n    pub fn sort_by<F>(&mut self, cmp: F)\n    where\n        F: Fn(&A, &A) -> Ordering,\n    {\n        let len = self.len();\n        if len > 1 {\n            sort::quicksort(self.focus_mut(), &cmp);\n        }\n    }\n\n    /// Verify the internal consistency of a vector.\n    ///\n    /// This method walks the RRB tree making up the current `Vector`\n    /// (if it has one) and verifies that all the invariants hold.\n    /// If something is wrong, it will panic.\n    ///\n    /// This method requires the `debug` feature flag.\n    #[cfg(any(test, feature = \"debug\"))]\n    pub fn assert_invariants(&self) {\n        if let Full(_, ref tree) = self.vector {\n            tree.assert_invariants();\n        }\n    }\n}","impl<A: Clone> Vector<A> {\n    /// Get a reference to the memory pool this `Vector` is using.\n    ///\n    /// Note that if you didn't specifically construct it with a pool, you'll\n    /// get back a reference to a pool of size 0.\n    #[cfg_attr(not(feature = \"pool\"), doc = \"hidden\")]\n    pub fn pool(&self) -> &RRBPool<A> {\n        match self.vector {\n            Inline(ref pool, _) => pool,\n            Single(ref pool, _) => pool,\n            Full(ref pool, _) => pool,\n        }\n    }\n\n    /// True if a vector is a full inline or single chunk, ie. must be promoted\n    /// to grow further.\n    fn needs_promotion(&self) -> bool {\n        match &self.vector {\n            Inline(_, chunk) if chunk.is_full() => true,\n            Single(_, chunk) if chunk.is_full() => true,\n            _ => false,\n        }\n    }\n\n    /// Promote an inline to a single.\n    fn promote_inline(&mut self) {\n        if let Inline(pool, chunk) = &mut self.vector {\n            self.vector = Single(pool.clone(), PoolRef::new(&pool.value_pool, chunk.into()));\n        }\n    }\n\n    /// Promote a single to a full, with the single chunk becoming inner_f, or\n    /// promote an inline to a single.\n    fn promote_front(&mut self) {\n        self.vector = match &mut self.vector {\n            Inline(pool, chunk) => {\n                Single(pool.clone(), PoolRef::new(&pool.value_pool, chunk.into()))\n            }\n            Single(pool, chunk) => {\n                let chunk = chunk.clone();\n                Full(\n                    pool.clone(),\n                    RRB {\n                        length: chunk.len(),\n                        middle_level: 0,\n                        outer_f: PoolRef::default(&pool.value_pool),\n                        inner_f: chunk,\n                        middle: Ref::new(Node::new()),\n                        inner_b: PoolRef::default(&pool.value_pool),\n                        outer_b: PoolRef::default(&pool.value_pool),\n                    },\n                )\n            }\n            Full(_, _) => return,\n        }\n    }\n\n    /// Promote a single to a full, with the single chunk becoming inner_b, or\n    /// promote an inline to a single.\n    fn promote_back(&mut self) {\n        self.vector = match &mut self.vector {\n            Inline(pool, chunk) => {\n                Single(pool.clone(), PoolRef::new(&pool.value_pool, chunk.into()))\n            }\n            Single(pool, chunk) => {\n                let chunk = chunk.clone();\n                Full(\n                    pool.clone(),\n                    RRB {\n                        length: chunk.len(),\n                        middle_level: 0,\n                        outer_f: PoolRef::default(&pool.value_pool),\n                        inner_f: PoolRef::default(&pool.value_pool),\n                        middle: Ref::new(Node::new()),\n                        inner_b: chunk,\n                        outer_b: PoolRef::default(&pool.value_pool),\n                    },\n                )\n            }\n            Full(_, _) => return,\n        }\n    }\n\n    /// Construct an empty vector.\n    #[must_use]\n    pub fn new() -> Self {\n        Self {\n            vector: Inline(RRBPool::default(), InlineArray::new()),\n        }\n    }\n\n    /// Construct an empty vector using a specific memory pool.\n    #[cfg(feature = \"pool\")]\n    #[must_use]\n    pub fn with_pool(pool: &RRBPool<A>) -> Self {\n        Self {\n            vector: Inline(pool.clone(), InlineArray::new()),\n        }\n    }\n\n    /// Get the length of a vector.\n    ///\n    /// Time: O(1)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// assert_eq!(5, vector![1, 2, 3, 4, 5].len());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn len(&self) -> usize {\n        match &self.vector {\n            Inline(_, chunk) => chunk.len(),\n            Single(_, chunk) => chunk.len(),\n            Full(_, tree) => tree.length,\n        }\n    }\n\n    /// Test whether a vector is empty.\n    ///\n    /// Time: O(1)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::Vector;\n    /// let vec = vector![\"Joe\", \"Mike\", \"Robert\"];\n    /// assert_eq!(false, vec.is_empty());\n    /// assert_eq!(true, Vector::<i32>::new().is_empty());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Test whether a vector is currently inlined.\n    ///\n    /// Vectors small enough that their contents could be stored entirely inside\n    /// the space of `std::mem::size_of::<Vector<A>>()` bytes are stored inline on\n    /// the stack instead of allocating any chunks. This method returns `true` if\n    /// this vector is currently inlined, or `false` if it currently has chunks allocated\n    /// on the heap.\n    ///\n    /// This may be useful in conjunction with [`ptr_eq()`][ptr_eq], which checks if\n    /// two vectors' heap allocations are the same, and thus will never return `true`\n    /// for inlined vectors.\n    ///\n    /// Time: O(1)\n    ///\n    /// [ptr_eq]: #method.ptr_eq\n    #[inline]\n    #[must_use]\n    pub fn is_inline(&self) -> bool {\n        if let Inline(_, _) = &self.vector {\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Test whether two vectors refer to the same content in memory.\n    ///\n    /// This uses the following rules to determine equality:\n    /// * If the two sides are references to the same vector, return true.\n    /// * If the two sides are single chunk vectors pointing to the same chunk, return true.\n    /// * If the two sides are full trees pointing to the same chunks, return true.\n    ///\n    /// This would return true if you're comparing a vector to itself, or\n    /// if you're comparing a vector to a fresh clone of itself. The exception to this is\n    /// if you've cloned an inline array (ie. an array with so few elements they can fit\n    /// inside the space a `Vector` allocates for its pointers, so there are no heap allocations\n    /// to compare).\n    ///\n    /// Time: O(1), or O(n) for inline vectors\n    #[must_use]\n    pub fn ptr_eq(&self, other: &Self) -> bool {\n        fn cmp_chunk<A>(left: &PoolRef<Chunk<A>>, right: &PoolRef<Chunk<A>>) -> bool {\n            (left.is_empty() && right.is_empty()) || PoolRef::ptr_eq(left, right)\n        }\n\n        if std::ptr::eq(self, other) {\n            return true;\n        }\n\n        match (&self.vector, &other.vector) {\n            (Single(_, left), Single(_, right)) => cmp_chunk(left, right),\n            (Full(_, left), Full(_, right)) => {\n                cmp_chunk(&left.outer_f, &right.outer_f)\n                    && cmp_chunk(&left.inner_f, &right.inner_f)\n                    && cmp_chunk(&left.inner_b, &right.inner_b)\n                    && cmp_chunk(&left.outer_b, &right.outer_b)\n                    && ((left.middle.is_empty() && right.middle.is_empty())\n                        || Ref::ptr_eq(&left.middle, &right.middle))\n            }\n            _ => false,\n        }\n    }\n\n    /// Get an iterator over a vector.\n    ///\n    /// Time: O(1)\n    #[inline]\n    #[must_use]\n    pub fn iter(&self) -> Iter<'_, A> {\n        Iter::new(self)\n    }\n\n    /// Get a mutable iterator over a vector.\n    ///\n    /// Time: O(1)\n    #[inline]\n    #[must_use]\n    pub fn iter_mut(&mut self) -> IterMut<'_, A> {\n        IterMut::new(self)\n    }\n\n    /// Get an iterator over the leaf nodes of a vector.\n    ///\n    /// This returns an iterator over the [`Chunk`s][Chunk] at the leaves of the\n    /// RRB tree. These are useful for efficient parallelisation of work on\n    /// the vector, but should not be used for basic iteration.\n    ///\n    /// Time: O(1)\n    ///\n    /// [Chunk]: ../chunk/struct.Chunk.html\n    #[inline]\n    #[must_use]\n    pub fn leaves(&self) -> Chunks<'_, A> {\n        Chunks::new(self)\n    }\n\n    /// Get a mutable iterator over the leaf nodes of a vector.\n    //\n    /// This returns an iterator over the [`Chunk`s][Chunk] at the leaves of the\n    /// RRB tree. These are useful for efficient parallelisation of work on\n    /// the vector, but should not be used for basic iteration.\n    ///\n    /// Time: O(1)\n    ///\n    /// [Chunk]: ../chunk/struct.Chunk.html\n    #[inline]\n    #[must_use]\n    pub fn leaves_mut(&mut self) -> ChunksMut<'_, A> {\n        ChunksMut::new(self)\n    }\n\n    /// Construct a [`Focus`][Focus] for a vector.\n    ///\n    /// Time: O(1)\n    ///\n    /// [Focus]: enum.Focus.html\n    #[inline]\n    #[must_use]\n    pub fn focus(&self) -> Focus<'_, A> {\n        Focus::new(self)\n    }\n\n    /// Construct a [`FocusMut`][FocusMut] for a vector.\n    ///\n    /// Time: O(1)\n    ///\n    /// [FocusMut]: enum.FocusMut.html\n    #[inline]\n    #[must_use]\n    pub fn focus_mut(&mut self) -> FocusMut<'_, A> {\n        FocusMut::new(self)\n    }\n\n    /// Get a reference to the value at index `index` in a vector.\n    ///\n    /// Returns `None` if the index is out of bounds.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::Vector;\n    /// let vec = vector![\"Joe\", \"Mike\", \"Robert\"];\n    /// assert_eq!(Some(&\"Robert\"), vec.get(2));\n    /// assert_eq!(None, vec.get(5));\n    /// ```\n    #[must_use]\n    pub fn get(&self, index: usize) -> Option<&A> {\n        if index >= self.len() {\n            return None;\n        }\n\n        match &self.vector {\n            Inline(_, chunk) => chunk.get(index),\n            Single(_, chunk) => chunk.get(index),\n            Full(_, tree) => {\n                let mut local_index = index;\n\n                if local_index < tree.outer_f.len() {\n                    return Some(&tree.outer_f[local_index]);\n                }\n                local_index -= tree.outer_f.len();\n\n                if local_index < tree.inner_f.len() {\n                    return Some(&tree.inner_f[local_index]);\n                }\n                local_index -= tree.inner_f.len();\n\n                if local_index < tree.middle.len() {\n                    return Some(tree.middle.index(tree.middle_level, local_index));\n                }\n                local_index -= tree.middle.len();\n\n                if local_index < tree.inner_b.len() {\n                    return Some(&tree.inner_b[local_index]);\n                }\n                local_index -= tree.inner_b.len();\n\n                Some(&tree.outer_b[local_index])\n            }\n        }\n    }\n\n    /// Get a mutable reference to the value at index `index` in a\n    /// vector.\n    ///\n    /// Returns `None` if the index is out of bounds.\n    ///\n    /// Time: O(log n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::Vector;\n    /// let mut vec = vector![\"Joe\", \"Mike\", \"Robert\"];\n    /// {\n    ///     let robert = vec.get_mut(2).unwrap();\n    ///     assert_eq!(&mut \"Robert\", robert);\n    ///     *robert = \"Bjarne\";\n    /// }\n    /// assert_eq!(vector![\"Joe\", \"Mike\", \"Bjarne\"], vec);\n    /// ```\n    #[must_use]\n    pub fn get_mut(&mut self, index: usize) -> Option<&mut A> {\n        if index >= self.len() {\n            return None;\n        }\n\n        match &mut self.vector {\n            Inline(_, chunk) => chunk.get_mut(index),\n            Single(pool, chunk) => PoolRef::make_mut(&pool.value_pool, chunk).get_mut(index),\n            Full(pool, tree) => {\n                let mut local_index = index;\n\n                if local_index < tree.outer_f.len() {\n                    let outer_f = PoolRef::make_mut(&pool.value_pool, &mut tree.outer_f);\n                    return Some(&mut outer_f[local_index]);\n                }\n                local_index -= tree.outer_f.len();\n\n                if local_index < tree.inner_f.len() {\n                    let inner_f = PoolRef::make_mut(&pool.value_pool, &mut tree.inner_f);\n                    return Some(&mut inner_f[local_index]);\n                }\n                local_index -= tree.inner_f.len();\n\n                if local_index < tree.middle.len() {\n                    let middle = Ref::make_mut(&mut tree.middle);\n                    return Some(middle.index_mut(pool, tree.middle_level, local_index));\n                }\n                local_index -= tree.middle.len();\n\n                if local_index < tree.inner_b.len() {\n                    let inner_b = PoolRef::make_mut(&pool.value_pool, &mut tree.inner_b);\n                    return Some(&mut inner_b[local_index]);\n                }\n                local_index -= tree.inner_b.len();\n\n                let outer_b = PoolRef::make_mut(&pool.value_pool, &mut tree.outer_b);\n                Some(&mut outer_b[local_index])\n            }\n        }\n    }\n\n    /// Get the first element of a vector.\n    ///\n    /// If the vector is empty, `None` is returned.\n    ///\n    /// Time: O(log n)\n    #[inline]\n    #[must_use]\n    pub fn front(&self) -> Option<&A> {\n        self.get(0)\n    }\n\n    /// Get a mutable reference to the first element of a vector.\n    ///\n    /// If the vector is empty, `None` is returned.\n    ///\n    /// Time: O(log n)\n    #[inline]\n    #[must_use]\n    pub fn front_mut(&mut self) -> Option<&mut A> {\n        self.get_mut(0)\n    }\n\n    /// Get the first element of a vector.\n    ///\n    /// If the vector is empty, `None` is returned.\n    ///\n    /// This is an alias for the [`front`][front] method.\n    ///\n    /// Time: O(log n)\n    ///\n    /// [front]: #method.front\n    #[inline]\n    #[must_use]\n    pub fn head(&self) -> Option<&A> {\n        self.get(0)\n    }\n\n    /// Get the last element of a vector.\n    ///\n    /// If the vector is empty, `None` is returned.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn back(&self) -> Option<&A> {\n        if self.is_empty() {\n            None\n        } else {\n            self.get(self.len() - 1)\n        }\n    }\n\n    /// Get a mutable reference to the last element of a vector.\n    ///\n    /// If the vector is empty, `None` is returned.\n    ///\n    /// Time: O(log n)\n    #[must_use]\n    pub fn back_mut(&mut self) -> Option<&mut A> {\n        if self.is_empty() {\n            None\n        } else {\n            let len = self.len();\n            self.get_mut(len - 1)\n        }\n    }\n\n    /// Get the last element of a vector.\n    ///\n    /// If the vector is empty, `None` is returned.\n    ///\n    /// This is an alias for the [`back`][back] method.\n    ///\n    /// Time: O(log n)\n    ///\n    /// [back]: #method.back\n    #[inline]\n    #[must_use]\n    pub fn last(&self) -> Option<&A> {\n        self.back()\n    }\n\n    /// Get the index of a given element in the vector.\n    ///\n    /// Searches the vector for the first occurrence of a given value,\n    /// and returns the index of the value if it's there. Otherwise,\n    /// it returns `None`.\n    ///\n    /// Time: O(n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::Vector;\n    /// let mut vec = vector![1, 2, 3, 4, 5];\n    /// assert_eq!(Some(2), vec.index_of(&3));\n    /// assert_eq!(None, vec.index_of(&31337));\n    /// ```\n    #[must_use]\n    pub fn index_of(&self, value: &A) -> Option<usize>\n    where\n        A: PartialEq,\n    {\n        for (index, item) in self.iter().enumerate() {\n            if value == item {\n                return Some(index);\n            }\n        }\n        None\n    }\n\n    /// Test if a given element is in the vector.\n    ///\n    /// Searches the vector for the first occurrence of a given value,\n    /// and returns `true if it's there. If it's nowhere to be found\n    /// in the vector, it returns `false`.\n    ///\n    /// Time: O(n)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate im;\n    /// # use im::Vector;\n    /// let mut vec = vector![1, 2, 3, 4, 5];\n    /// assert_eq!(true, vec.contains(&3));\n    /// assert_eq!(false, vec.contains(&31337));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn contains(&self, value: &A) -> bool\n    where\n        A: PartialEq,\n    {\n        self.index_of(value).is_some()\n    }\n\n    /// Discard all elements from the vector.\n    ///\n    /// This leaves you with an empty vector, and all elements that\n    /// were previously inside it are dropped.\n    ///\n    /// Time: O(n)\n    pub fn clear(&mut self) {\n        if !self.is_empty() {\n            self.vector = Inline(self.pool().clone(), InlineArray::new());\n        }\n    }\n\n    /// Binary search a sorted vector for a given element using a comparator\n    /// function.\n    ///\n    /// Assumes the vector has already been sorted using the same comparator\n    /// function, eg. by using [`sort_by`][sort_by].\n    ///\n    /// If the value is found, it returns `Ok(index)` where `index` is the index\n    /// of the element. If the value isn't found, it returns `Err(index)` where\n    /// `index` is the index at which the element would need to be inserted to\n    /// maintain sorted order.\n    ///\n    /// Time: O(log n)\n    ///\n    /// [sort_by]: #method.sort_by\n    pub fn binary_search_by<F>(&self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&A) -> Ordering,\n    {\n        let mut size = self.len();\n        if size == 0 {\n            return Err(0);\n        }\n        let mut base = 0;\n        while size > 1 {\n            let half = size / 2;\n            let mid = base + half;\n            base = match f(&self[mid]) {\n                Ordering::Greater => base,\n                _ => mid,\n            };\n            size -= half;\n        }\n        match f(&self[base]) {\n            Ordering::Equal => Ok(base),\n            Ordering::Greater => Err(base),\n            Ordering::Less => Err(base + 1),\n        }\n    }\n\n    /// Binary search a sorted vector for a given element.\n    ///\n    /// If the value is found, it returns `Ok(index)` where `index` is the index\n    /// of the element. If the value isn't found, it returns `Err(index)` where\n    /// `index` is the index at which the element would need to be inserted to\n    /// maintain sorted order.\n    ///\n    /// Time: O(log n)\n    pub fn binary_search(&self, value: &A) -> Result<usize, usize>\n    where\n        A: Ord,\n    {\n        self.binary_search_by(|e| e.cmp(value))\n    }\n\n    /// Binary search a sorted vector for a given element with a key extract\n    /// function.\n    ///\n    /// Assumes the vector has already been sorted using the same key extract\n    /// function, eg. by using [`sort_by_key`][sort_by_key].\n    ///\n    /// If the value is found, it returns `Ok(index)` where `index` is the index\n    /// of the element. If the value isn't found, it returns `Err(index)` where\n    /// `index` is the index at which the element would need to be inserted to\n    /// maintain sorted order.\n    ///\n    /// Time: O(log n)\n    ///\n    /// [sort_by_key]: #method.sort_by_key\n    pub fn binary_search_by_key<B, F>(&self, b: &B, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&A) -> B,\n        B: Ord,\n    {\n        self.binary_search_by(|k| f(k).cmp(b))\n    }\n}"],"vector::focus::Focus":["impl<'a, A> Clone for Focus<'a, A>\nwhere\n    A: Clone + 'a,\n{\n    fn clone(&self) -> Self {\n        match self {\n            Focus::Single(chunk) => Focus::Single(chunk),\n            Focus::Full(tree) => Focus::Full(tree.clone()),\n        }\n    }\n}","impl<'a, A> Focus<'a, A>\nwhere\n    A: Clone + 'a,\n{\n    /// Construct a `Focus` for a [`Vector`][Vector].\n    ///\n    /// [Vector]: enum.Vector.html\n    pub fn new(vector: &'a Vector<A>) -> Self {\n        match &vector.vector {\n            Inline(_, chunk) => Focus::Single(chunk),\n            Single(_, chunk) => Focus::Single(chunk),\n            Full(_, tree) => Focus::Full(TreeFocus::new(tree)),\n        }\n    }\n\n    /// Get the length of the focused [`Vector`][Vector].\n    ///\n    /// [Vector]: enum.Vector.html\n    pub fn len(&self) -> usize {\n        match self {\n            Focus::Single(chunk) => chunk.len(),\n            Focus::Full(tree) => tree.len(),\n        }\n    }\n\n    /// Test if the focused [`Vector`][Vector] is empty.\n    ///\n    /// [Vector]: enum.Vector.html\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Get a reference to the value at a given index.\n    pub fn get(&mut self, index: usize) -> Option<&A> {\n        match self {\n            Focus::Single(chunk) => chunk.get(index),\n            Focus::Full(tree) => tree.get(index),\n        }\n    }\n\n    /// Get a reference to the value at a given index.\n    ///\n    /// Panics if the index is out of bounds.\n    pub fn index(&mut self, index: usize) -> &A {\n        self.get(index).expect(\"index out of bounds\")\n    }\n\n    /// Get the chunk for the given index.\n    ///\n    /// This gives you a reference to the leaf node that contains the index,\n    /// along with its start and end indices.\n    pub fn chunk_at(&mut self, index: usize) -> (Range<usize>, &[A]) {\n        let len = self.len();\n        if index >= len {\n            panic!(\"vector::Focus::chunk_at: index out of bounds\");\n        }\n        match self {\n            Focus::Single(chunk) => (0..len, chunk),\n            Focus::Full(tree) => tree.get_chunk(index),\n        }\n    }\n\n    /// Narrow the focus onto a subslice of the vector.\n    ///\n    /// `Focus::narrow(range)` has the same effect as `&slice[range]`, without\n    /// actually modifying the underlying vector.\n    ///\n    /// Panics if the range isn't fully inside the current focus.\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// # use std::iter::FromIterator;\n    /// let vec = Vector::from_iter(0..1000);\n    /// let narrowed = vec.focus().narrow(100..200);\n    /// let narrowed_vec = narrowed.into_iter().cloned().collect();\n    /// assert_eq!(Vector::from_iter(100..200), narrowed_vec);\n    /// ```\n    ///\n    /// [slice::split_at]: https://doc.rust-lang.org/std/primitive.slice.html#method.split_at\n    /// [Vector::split_at]: enum.Vector.html#method.split_at\n    pub fn narrow<R>(self, range: R) -> Self\n    where\n        R: RangeBounds<usize>,\n    {\n        let r = to_range(&range, self.len());\n        if r.start >= r.end || r.start >= self.len() {\n            panic!(\"vector::Focus::narrow: range out of bounds\");\n        }\n        match self {\n            Focus::Single(chunk) => Focus::Single(&chunk[r]),\n            Focus::Full(tree) => Focus::Full(tree.narrow(r)),\n        }\n    }\n\n    /// Split the focus into two.\n    ///\n    /// Given an index `index`, consume the focus and produce two new foci, the\n    /// left onto indices `0..index`, and the right onto indices `index..N`\n    /// where `N` is the length of the current focus.\n    ///\n    /// Panics if the index is out of bounds.\n    ///\n    /// This is the moral equivalent of [`slice::split_at`][slice::split_at], in\n    /// that it leaves the underlying data structure unchanged, unlike\n    /// [`Vector::split_at`][Vector::split_at].\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// # use std::iter::FromIterator;\n    /// let vec = Vector::from_iter(0..1000);\n    /// let (left, right) = vec.focus().split_at(500);\n    /// let left_vec = left.into_iter().cloned().collect();\n    /// let right_vec = right.into_iter().cloned().collect();\n    /// assert_eq!(Vector::from_iter(0..500), left_vec);\n    /// assert_eq!(Vector::from_iter(500..1000), right_vec);\n    /// ```\n    ///\n    /// [slice::split_at]: https://doc.rust-lang.org/std/primitive.slice.html#method.split_at\n    /// [Vector::split_at]: enum.Vector.html#method.split_at\n    pub fn split_at(self, index: usize) -> (Self, Self) {\n        if index >= self.len() {\n            panic!(\"vector::Focus::split_at: index out of bounds\");\n        }\n        match self {\n            Focus::Single(chunk) => {\n                let (left, right) = chunk.split_at(index);\n                (Focus::Single(left), Focus::Single(right))\n            }\n            Focus::Full(tree) => {\n                let (left, right) = tree.split_at(index);\n                (Focus::Full(left), Focus::Full(right))\n            }\n        }\n    }\n}","impl<'a, A> IntoIterator for Focus<'a, A>\nwhere\n    A: Clone + 'a,\n{\n    type Item = &'a A;\n    type IntoIter = Iter<'a, A>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        Iter::from_focus(self)\n    }\n}"],"vector::focus::FocusMut":["impl<'a, A> FocusMut<'a, A>\nwhere\n    A: Clone + 'a,\n{\n    /// Construct a `FocusMut` for a `Vector`.\n    pub fn new(vector: &'a mut Vector<A>) -> Self {\n        match &mut vector.vector {\n            Inline(pool, chunk) => FocusMut::Single(pool.clone(), chunk),\n            Single(pool, chunk) => FocusMut::Single(\n                pool.clone(),\n                PoolRef::make_mut(&pool.value_pool, chunk).as_mut_slice(),\n            ),\n            Full(pool, tree) => FocusMut::Full(pool.clone(), TreeFocusMut::new(tree)),\n        }\n    }\n\n    /// Get the length of the focused `Vector`.\n    pub fn len(&self) -> usize {\n        match self {\n            FocusMut::Single(_, chunk) => chunk.len(),\n            FocusMut::Full(_, tree) => tree.len(),\n        }\n    }\n\n    /// Test if the focused `Vector` is empty.\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Get a reference to the value at a given index.\n    pub fn get(&mut self, index: usize) -> Option<&A> {\n        self.get_mut(index).map(|r| &*r)\n    }\n\n    /// Get a mutable reference to the value at a given index.\n    pub fn get_mut(&mut self, index: usize) -> Option<&mut A> {\n        match self {\n            FocusMut::Single(_, chunk) => chunk.get_mut(index),\n            FocusMut::Full(pool, tree) => tree.get(pool, index),\n        }\n    }\n\n    /// Get a reference to the value at a given index.\n    ///\n    /// Panics if the index is out of bounds.\n    pub fn index(&mut self, index: usize) -> &A {\n        &*self.index_mut(index)\n    }\n\n    /// Get a mutable reference to the value at a given index.\n    ///\n    /// Panics if the index is out of bounds.\n    #[allow(clippy::should_implement_trait)] // would if I could\n    pub fn index_mut(&mut self, index: usize) -> &mut A {\n        self.get_mut(index).expect(\"index out of bounds\")\n    }\n\n    /// Update the value at a given index.\n    ///\n    /// Returns `None` if the index is out of bounds, or the replaced value\n    /// otherwise.\n    pub fn set(&mut self, index: usize, value: A) -> Option<A> {\n        match self.get_mut(index) {\n            Some(ref mut pos) => Some(replace(pos, value)),\n            None => None,\n        }\n    }\n\n    /// Swap the values at two given indices.\n    ///\n    /// Panics if either index is out of bounds.\n    ///\n    /// If the indices are equal, this function returns without doing anything.\n    pub fn swap(&mut self, a: usize, b: usize) {\n        if a == b {\n            return;\n        }\n        self.pair(a, b, |left, right| swap(left, right));\n    }\n\n    /// Lookup two indices simultaneously and run a function over them.\n    ///\n    /// Useful because the borrow checker won't let you have more than one\n    /// mutable reference into the same data structure at any given time.\n    ///\n    /// Panics if either index is out of bounds, or if they are the same index.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// # use std::iter::FromIterator;\n    /// let mut vec = vector![1, 2, 3, 4, 5];\n    /// vec.focus_mut().pair(1, 3, |a, b| *a += *b);\n    /// assert_eq!(vector![1, 6, 3, 4, 5], vec);\n    /// ```\n    #[allow(unsafe_code)]\n    pub fn pair<F, B>(&mut self, a: usize, b: usize, mut f: F) -> B\n    where\n        F: FnMut(&mut A, &mut A) -> B,\n    {\n        if a == b {\n            panic!(\"vector::FocusMut::pair: indices cannot be equal!\");\n        }\n        let pa: *mut A = self.index_mut(a);\n        let pb: *mut A = self.index_mut(b);\n        unsafe { f(&mut *pa, &mut *pb) }\n    }\n\n    /// Lookup three indices simultaneously and run a function over them.\n    ///\n    /// Useful because the borrow checker won't let you have more than one\n    /// mutable reference into the same data structure at any given time.\n    ///\n    /// Panics if any index is out of bounds, or if any indices are equal.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// # use std::iter::FromIterator;\n    /// let mut vec = vector![1, 2, 3, 4, 5];\n    /// vec.focus_mut().triplet(0, 2, 4, |a, b, c| *a += *b + *c);\n    /// assert_eq!(vector![9, 2, 3, 4, 5], vec);\n    /// ```\n    #[allow(unsafe_code)]\n    pub fn triplet<F, B>(&mut self, a: usize, b: usize, c: usize, mut f: F) -> B\n    where\n        F: FnMut(&mut A, &mut A, &mut A) -> B,\n    {\n        if a == b || b == c || a == c {\n            panic!(\"vector::FocusMut::triplet: indices cannot be equal!\");\n        }\n        let pa: *mut A = self.index_mut(a);\n        let pb: *mut A = self.index_mut(b);\n        let pc: *mut A = self.index_mut(c);\n        unsafe { f(&mut *pa, &mut *pb, &mut *pc) }\n    }\n\n    /// Get the chunk for the given index.\n    ///\n    /// This gives you a reference to the leaf node that contains the index,\n    /// along with its start and end indices.\n    pub fn chunk_at(&mut self, index: usize) -> (Range<usize>, &mut [A]) {\n        let len = self.len();\n        if index >= len {\n            panic!(\"vector::FocusMut::chunk_at: index out of bounds\");\n        }\n        match self {\n            FocusMut::Single(_, chunk) => (0..len, chunk),\n            FocusMut::Full(pool, tree) => {\n                let (range, chunk) = tree.get_chunk(pool, index);\n                (range, chunk)\n            }\n        }\n    }\n\n    /// Narrow the focus onto a subslice of the vector.\n    ///\n    /// `FocusMut::narrow(range)` has the same effect as `&slice[range]`, without\n    /// actually modifying the underlying vector.\n    ///\n    /// Panics if the range isn't fully inside the current focus.\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// # use std::iter::FromIterator;\n    /// let mut vec = Vector::from_iter(0..1000);\n    /// let narrowed = vec.focus_mut().narrow(100..200);\n    /// let narrowed_vec = narrowed.unmut().into_iter().cloned().collect();\n    /// assert_eq!(Vector::from_iter(100..200), narrowed_vec);\n    /// ```\n    ///\n    /// [slice::split_at]: https://doc.rust-lang.org/std/primitive.slice.html#method.split_at\n    /// [Vector::split_at]: enum.Vector.html#method.split_at\n    pub fn narrow<R>(self, range: R) -> Self\n    where\n        R: RangeBounds<usize>,\n    {\n        let r = to_range(&range, self.len());\n        if r.start > r.end || r.start > self.len() {\n            panic!(\"vector::FocusMut::narrow: range out of bounds\");\n        }\n        match self {\n            FocusMut::Single(pool, chunk) => FocusMut::Single(pool, &mut chunk[r]),\n            FocusMut::Full(pool, tree) => FocusMut::Full(pool, tree.narrow(r)),\n        }\n    }\n\n    /// Split the focus into two.\n    ///\n    /// Given an index `index`, consume the focus and produce two new foci, the\n    /// left onto indices `0..index`, and the right onto indices `index..N`\n    /// where `N` is the length of the current focus.\n    ///\n    /// Panics if the index is out of bounds.\n    ///\n    /// This is the moral equivalent of [`slice::split_at`][slice::split_at], in\n    /// that it leaves the underlying data structure unchanged, unlike\n    /// [`Vector::split_at`][Vector::split_at].\n    ///\n    /// ## Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate im;\n    /// # use im::vector::Vector;\n    /// # use std::iter::FromIterator;\n    /// let mut vec = Vector::from_iter(0..1000);\n    /// {\n    ///     let (left, right) = vec.focus_mut().split_at(500);\n    ///     for ptr in left {\n    ///         *ptr += 100;\n    ///     }\n    ///     for ptr in right {\n    ///         *ptr -= 100;\n    ///     }\n    /// }\n    /// let expected = Vector::from_iter(100..600)\n    ///              + Vector::from_iter(400..900);\n    /// assert_eq!(expected, vec);\n    /// ```\n    ///\n    /// [slice::split_at]: https://doc.rust-lang.org/std/primitive.slice.html#method.split_at\n    /// [Vector::split_at]: enum.Vector.html#method.split_at\n    #[allow(clippy::redundant_clone)]\n    pub fn split_at(self, index: usize) -> (Self, Self) {\n        if index > self.len() {\n            panic!(\"vector::FocusMut::split_at: index out of bounds\");\n        }\n        match self {\n            FocusMut::Single(pool, chunk) => {\n                let (left, right) = chunk.split_at_mut(index);\n                (\n                    FocusMut::Single(pool.clone(), left),\n                    FocusMut::Single(pool, right),\n                )\n            }\n            FocusMut::Full(pool, tree) => {\n                let (left, right) = tree.split_at(index);\n                (\n                    FocusMut::Full(pool.clone(), left),\n                    FocusMut::Full(pool, right),\n                )\n            }\n        }\n    }\n\n    /// Convert a `FocusMut` into a `Focus`.\n    pub fn unmut(self) -> Focus<'a, A> {\n        match self {\n            FocusMut::Single(_, chunk) => Focus::Single(chunk),\n            FocusMut::Full(_, mut tree) => Focus::Full(TreeFocus {\n                tree: {\n                    let t = tree.tree.lock().unwrap();\n                    (*t).clone()\n                },\n                view: tree.view.clone(),\n                middle_range: tree.middle_range.clone(),\n                target_range: 0..0,\n                target_ptr: null(),\n            }),\n        }\n    }\n}","impl<'a, A> Into<Focus<'a, A>> for FocusMut<'a, A>\nwhere\n    A: Clone + 'a,\n{\n    fn into(self) -> Focus<'a, A> {\n        self.unmut()\n    }\n}","impl<'a, A> IntoIterator for FocusMut<'a, A>\nwhere\n    A: Clone + 'a,\n{\n    type Item = &'a mut A;\n    type IntoIter = IterMut<'a, A>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        IterMut::from_focus(self)\n    }\n}"],"vector::focus::TreeFocus":["impl<A> Clone for TreeFocus<A> {\n    fn clone(&self) -> Self {\n        let tree = self.tree.clone();\n        TreeFocus {\n            view: self.view.clone(),\n            middle_range: self.middle_range.clone(),\n            target_range: 0..0,\n            target_ptr: null(),\n            tree,\n        }\n    }\n}","impl<A> TreeFocus<A>\nwhere\n    A: Clone,\n{\n    fn new(tree: &RRB<A>) -> Self {\n        let middle_start = tree.outer_f.len() + tree.inner_f.len();\n        let middle_end = middle_start + tree.middle.len();\n        TreeFocus {\n            tree: tree.clone(),\n            view: 0..tree.length,\n            middle_range: middle_start..middle_end,\n            target_range: 0..0,\n            target_ptr: null(),\n        }\n    }\n\n    fn len(&self) -> usize {\n        self.view.end - self.view.start\n    }\n\n    fn narrow(self, mut view: Range<usize>) -> Self {\n        view.start += self.view.start;\n        view.end += self.view.start;\n        TreeFocus {\n            view,\n            middle_range: self.middle_range.clone(),\n            target_range: 0..0,\n            target_ptr: null(),\n            tree: self.tree,\n        }\n    }\n\n    fn split_at(self, index: usize) -> (Self, Self) {\n        let len = self.len();\n        let left = self.clone().narrow(0..index);\n        let right = self.narrow(index..len);\n        (left, right)\n    }\n\n    fn physical_index(&self, index: usize) -> usize {\n        debug_assert!(index < self.view.end);\n        self.view.start + index\n    }\n\n    fn logical_range(&self, range: &Range<usize>) -> Range<usize> {\n        (range.start - self.view.start)..(range.end - self.view.start)\n    }\n\n    fn set_focus(&mut self, index: usize) {\n        if index < self.middle_range.start {\n            let outer_len = self.tree.outer_f.len();\n            if index < outer_len {\n                self.target_range = 0..outer_len;\n                self.target_ptr = &*self.tree.outer_f;\n            } else {\n                self.target_range = outer_len..self.middle_range.start;\n                self.target_ptr = &*self.tree.inner_f;\n            }\n        } else if index >= self.middle_range.end {\n            let outer_start = self.middle_range.end + self.tree.inner_b.len();\n            if index < outer_start {\n                self.target_range = self.middle_range.end..outer_start;\n                self.target_ptr = &*self.tree.inner_b;\n            } else {\n                self.target_range = outer_start..self.tree.length;\n                self.target_ptr = &*self.tree.outer_b;\n            }\n        } else {\n            let tree_index = index - self.middle_range.start;\n            let (range, ptr) = self\n                .tree\n                .middle\n                .lookup_chunk(self.tree.middle_level, 0, tree_index);\n            self.target_range =\n                (range.start + self.middle_range.start)..(range.end + self.middle_range.start);\n            self.target_ptr = ptr;\n        }\n    }\n\n    #[allow(unsafe_code)]\n    fn get_focus(&self) -> &Chunk<A> {\n        unsafe { &*self.target_ptr }\n    }\n\n    pub fn get(&mut self, index: usize) -> Option<&A> {\n        if index >= self.len() {\n            return None;\n        }\n        let phys_index = self.physical_index(index);\n        if !contains(&self.target_range, &phys_index) {\n            self.set_focus(phys_index);\n        }\n        let target_phys_index = phys_index - self.target_range.start;\n        Some(&self.get_focus()[target_phys_index])\n    }\n\n    pub fn get_chunk(&mut self, index: usize) -> (Range<usize>, &[A]) {\n        let phys_index = self.physical_index(index);\n        if !contains(&self.target_range, &phys_index) {\n            self.set_focus(phys_index);\n        }\n        let mut slice: &[A] = self.get_focus();\n        let mut left = 0;\n        let mut right = 0;\n        if self.target_range.start < self.view.start {\n            left = self.view.start - self.target_range.start;\n        }\n        if self.target_range.end > self.view.end {\n            right = self.target_range.end - self.view.end;\n        }\n        slice = &slice[left..(slice.len() - right)];\n        let phys_range = (self.target_range.start + left)..(self.target_range.end - right);\n        (self.logical_range(&phys_range), slice)\n    }\n}","unsafe impl<A> Send for TreeFocus<A> {}","unsafe impl<A> Sync for TreeFocus<A> {}"],"vector::focus::TreeFocusMut":["impl<'a, A> TreeFocusMut<'a, A>\nwhere\n    A: Clone + 'a,\n{\n    fn new(tree: &'a mut RRB<A>) -> Self {\n        let middle_start = tree.outer_f.len() + tree.inner_f.len();\n        let middle_end = middle_start + tree.middle.len();\n        TreeFocusMut {\n            view: 0..tree.length,\n            tree: Lock::new(tree),\n            middle_range: middle_start..middle_end,\n            target_range: 0..0,\n            target_ptr: AtomicPtr::default(),\n        }\n    }\n\n    fn len(&self) -> usize {\n        self.view.end - self.view.start\n    }\n\n    fn narrow(self, mut view: Range<usize>) -> Self {\n        view.start += self.view.start;\n        view.end += self.view.start;\n        TreeFocusMut {\n            view,\n            middle_range: self.middle_range.clone(),\n            target_range: 0..0,\n            target_ptr: AtomicPtr::default(),\n            tree: self.tree,\n        }\n    }\n\n    fn split_at(self, index: usize) -> (Self, Self) {\n        let len = self.len();\n        debug_assert!(index <= len);\n        #[allow(unsafe_code)]\n        let left = TreeFocusMut {\n            view: self.view.start..(self.view.start + index),\n            middle_range: self.middle_range.clone(),\n            target_range: 0..0,\n            target_ptr: AtomicPtr::default(),\n            tree: self.tree.clone(),\n        };\n        let right = TreeFocusMut {\n            view: (self.view.start + index)..(self.view.start + len),\n            middle_range: self.middle_range.clone(),\n            target_range: 0..0,\n            target_ptr: AtomicPtr::default(),\n            tree: self.tree,\n        };\n        (left, right)\n    }\n\n    fn physical_index(&self, index: usize) -> usize {\n        debug_assert!(index < self.view.end);\n        self.view.start + index\n    }\n\n    fn logical_range(&self, range: &Range<usize>) -> Range<usize> {\n        (range.start - self.view.start)..(range.end - self.view.start)\n    }\n\n    fn set_focus(&mut self, pool: &RRBPool<A>, index: usize) {\n        let mut tree = self\n            .tree\n            .lock()\n            .expect(\"im::vector::Focus::set_focus: unable to acquire exclusive lock on Vector\");\n        if index < self.middle_range.start {\n            let outer_len = tree.outer_f.len();\n            if index < outer_len {\n                self.target_range = 0..outer_len;\n                self.target_ptr.store(\n                    PoolRef::make_mut(&pool.value_pool, &mut tree.outer_f),\n                    Ordering::Relaxed,\n                );\n            } else {\n                self.target_range = outer_len..self.middle_range.start;\n                self.target_ptr.store(\n                    PoolRef::make_mut(&pool.value_pool, &mut tree.inner_f),\n                    Ordering::Relaxed,\n                );\n            }\n        } else if index >= self.middle_range.end {\n            let outer_start = self.middle_range.end + tree.inner_b.len();\n            if index < outer_start {\n                self.target_range = self.middle_range.end..outer_start;\n                self.target_ptr.store(\n                    PoolRef::make_mut(&pool.value_pool, &mut tree.inner_b),\n                    Ordering::Relaxed,\n                );\n            } else {\n                self.target_range = outer_start..tree.length;\n                self.target_ptr.store(\n                    PoolRef::make_mut(&pool.value_pool, &mut tree.outer_b),\n                    Ordering::Relaxed,\n                );\n            }\n        } else {\n            let tree_index = index - self.middle_range.start;\n            let level = tree.middle_level;\n            let middle = Ref::make_mut(&mut tree.middle);\n            let (range, ptr) = middle.lookup_chunk_mut(pool, level, 0, tree_index);\n            self.target_range =\n                (range.start + self.middle_range.start)..(range.end + self.middle_range.start);\n            self.target_ptr.store(ptr, Ordering::Relaxed);\n        }\n    }\n\n    #[allow(unsafe_code)]\n    fn get_focus(&mut self) -> &mut Chunk<A> {\n        unsafe { &mut *self.target_ptr.load(Ordering::Relaxed) }\n    }\n\n    pub fn get(&mut self, pool: &RRBPool<A>, index: usize) -> Option<&mut A> {\n        if index >= self.len() {\n            return None;\n        }\n        let phys_index = self.physical_index(index);\n        if !contains(&self.target_range, &phys_index) {\n            self.set_focus(pool, phys_index);\n        }\n        let target_phys_index = phys_index - self.target_range.start;\n        Some(&mut self.get_focus()[target_phys_index])\n    }\n\n    pub fn get_chunk(&mut self, pool: &RRBPool<A>, index: usize) -> (Range<usize>, &mut [A]) {\n        let phys_index = self.physical_index(index);\n        if !contains(&self.target_range, &phys_index) {\n            self.set_focus(pool, phys_index);\n        }\n        let mut left = 0;\n        let mut right = 0;\n        if self.target_range.start < self.view.start {\n            left = self.view.start - self.target_range.start;\n        }\n        if self.target_range.end > self.view.end {\n            right = self.target_range.end - self.view.end;\n        }\n        let phys_range = (self.target_range.start + left)..(self.target_range.end - right);\n        let log_range = self.logical_range(&phys_range);\n        let slice_len = self.get_focus().len();\n        let slice = &mut (self.get_focus().as_mut_slice())[left..(slice_len - right)];\n        (log_range, slice)\n    }\n}"],"vector::pool::RRBPool":["impl<A> Clone for RRBPool<A> {\n    fn clone(&self) -> Self {\n        Self {\n            node_pool: self.node_pool.clone(),\n            value_pool: self.value_pool.clone(),\n            size_pool: self.size_pool.clone(),\n        }\n    }\n}","impl<A> Default for RRBPool<A> {\n    /// Construct a pool with a reasonable default pool size.\n    fn default() -> Self {\n        Self::new(POOL_SIZE)\n    }\n}","impl<A> RRBPool<A> {\n    /// Create a new memory pool with the given size.\n    pub fn new(size: usize) -> Self {\n        Self::with_sizes(size, size, size)\n    }\n\n    /// Create a new memory pool with the given sizes for each subpool.\n    pub fn with_sizes(\n        node_pool_size: usize,\n        leaf_pool_size: usize,\n        size_table_pool_size: usize,\n    ) -> Self {\n        Self {\n            node_pool: Pool::new(node_pool_size),\n            value_pool: Pool::new(leaf_pool_size),\n            size_pool: Pool::new(size_table_pool_size),\n        }\n    }\n\n    /// Fill the memory pool with preallocated chunks.\n    pub fn fill(&self) {\n        self.node_pool.fill();\n        self.value_pool.fill();\n        self.size_pool.fill();\n    }\n\n    /// Get the size of the node subpool.\n    pub fn node_pool_size(&self) -> usize {\n        self.node_pool.get_pool_size()\n    }\n\n    /// Get the size of the leaf node subpool.\n    pub fn leaf_pool_size(&self) -> usize {\n        self.value_pool.get_pool_size()\n    }\n\n    /// Get the size of the size table subpool.\n    pub fn size_table_pool_size(&self) -> usize {\n        self.size_pool.get_pool_size()\n    }\n}"]},"single_path_import":{"hash::map":"map","hash::map::HashMap":"HashMap","hash::set":"set","hash::set::HashSet":"HashSet","nodes::btree::ConsumingIter":"ord::map::ConsumingIter","nodes::btree::DiffItem":"ord::set::DiffItem","nodes::btree::DiffIter":"ord::map::DiffIter","nodes::btree::Iter":"ord::map::Iter","ord::map":"map","ord::map::OrdMap":"OrdMap","ord::set":"set","ord::set::OrdSet":"OrdSet","vector::Vector":"Vector","vector::focus::Focus":"vector::Focus","vector::focus::FocusMut":"vector::FocusMut","vector::pool::RRBPool":"vector::RRBPool"},"srcs":{"<&'a hash::map::HashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<&'a hash::map::HashMap<K, V, S> as std::ops::Add>::add":["fn add(self, other: Self) -> Self::Output{\n        self.clone().union(other.clone())\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<&'a hash::set::HashSet<A, S> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<&'a hash::set::HashSet<A, S> as std::ops::Add>::add":["fn add(self, other: Self) -> Self::Output{\n        self.clone().union(other.clone())\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<&'a hash::set::HashSet<A, S> as std::ops::Mul>::mul":["fn mul(self, other: Self) -> Self::Output{\n        self.clone().intersection(other.clone())\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<&'a ord::map::OrdMap<K, V> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<&'a ord::map::OrdMap<K, V> as std::ops::Add>::add":["fn add(self, other: Self) -> Self::Output{\n        self.clone().union(other.clone())\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<&'a ord::set::OrdSet<A> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<&'a ord::set::OrdSet<A> as std::ops::Add>::add":["fn add(self, other: Self) -> Self::Output{\n        self.clone().union(other.clone())\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<&'a ord::set::OrdSet<A> as std::ops::Mul>::mul":["fn mul(self, other: Self) -> Self::Output{\n        self.clone().intersection(other.clone())\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<&'a vector::Vector<A> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<&'a vector::Vector<A> as std::ops::Add>::add":["/// Concatenate two vectors.\n///\n/// Time: O(log n)\nfn add(self, other: Self) -> Self::Output{\n        let mut out = self.clone();\n        out.append(other.clone());\n        out\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<fakepool::Arc<A> as std::clone::Clone>::clone":["#[inline(always)]\nfn clone(&self) -> Self{\n        Self(self.0.clone())\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"<fakepool::Arc<A> as std::cmp::PartialEq>::eq":["#[inline(always)]\nfn eq(&self, other: &Self) -> bool{\n        **self == **other\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"<fakepool::Arc<A> as std::fmt::Debug>::fmt":["#[inline(always)]\nfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error>{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"<fakepool::Arc<A> as std::ops::Deref>::deref":["#[inline(always)]\nfn deref(&self) -> &Self::Target{\n        self.0.deref()\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"<fakepool::Pool<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        Self::new(0)\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"<fakepool::Rc<A> as std::clone::Clone>::clone":["#[inline(always)]\nfn clone(&self) -> Self{\n        Rc(self.0.clone())\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"<fakepool::Rc<A> as std::cmp::PartialEq>::eq":["#[inline(always)]\nfn eq(&self, other: &Self) -> bool{\n        **self == **other\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"<fakepool::Rc<A> as std::fmt::Debug>::fmt":["#[inline(always)]\nfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error>{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"<fakepool::Rc<A> as std::ops::Deref>::deref":["#[inline(always)]\nfn deref(&self) -> &Self::Target{\n        self.0.deref()\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"<hash::map::ConsumingIter<A> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|(p, _)| p)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::ConsumingIter<A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::clone::Clone>::clone":["/// Clone a map.\n///\n/// Time: O(1)\n#[inline]\nfn clone(&self) -> Self{\n        HashMap {\n            root: self.root.clone(),\n            pool: self.pool.clone(),\n            size: self.size,\n            hasher: self.hasher.clone(),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Self) -> Ordering{\n        if Ref::ptr_eq(&self.hasher, &other.hasher) {\n            return self.iter().cmp(other.iter());\n        }\n        self.iter().cmp(other.iter())\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n        if PoolRef::ptr_eq(&self.root, &other.root) {\n            return true;\n        }\n        self.test_eq(other)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n        if Ref::ptr_eq(&self.hasher, &other.hasher) {\n            return self.iter().partial_cmp(other.iter());\n        }\n        self.iter().partial_cmp(other.iter())\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::convert::AsRef<hash::map::HashMap<K, V, S>>>::as_ref":["#[inline]\nfn as_ref(&self) -> &Self{\n        self\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a [(K, V)]>>::from":["fn from(m: &'a [(K, V)]) -> Self{\n        m.iter().cloned().collect()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a std::collections::BTreeMap<K, V>>>::from":["fn from(m: &'a collections::BTreeMap<K, V>) -> Self{\n        m.iter().map(|(k, v)| (k.clone(), v.clone())).collect()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a std::collections::HashMap<K, V>>>::from":["fn from(m: &'a collections::HashMap<K, V>) -> Self{\n        m.iter().map(|(k, v)| (k.clone(), v.clone())).collect()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a std::vec::Vec<(K, V)>>>::from":["fn from(m: &'a Vec<(K, V)>) -> Self{\n        m.iter().cloned().collect()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::convert::From<std::collections::BTreeMap<K, V>>>::from":["fn from(m: collections::BTreeMap<K, V>) -> Self{\n        m.into_iter().collect()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::convert::From<std::collections::HashMap<K, V>>>::from":["fn from(m: collections::HashMap<K, V>) -> Self{\n        m.into_iter().collect()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::convert::From<std::vec::Vec<(K, V)>>>::from":["fn from(m: Vec<(K, V)>) -> Self{\n        m.into_iter().collect()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::default::Default>::default":["#[inline]\nfn default() -> Self{\n        let pool = HashMapPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashMap {\n            size: 0,\n            pool,\n            root,\n            hasher: Ref::<S>::default(),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>{\n        let mut keys = collections::BTreeSet::new();\n        keys.extend(self.keys());\n        let mut d = f.debug_map();\n        for key in keys {\n            d.entry(key, &self[key]);\n        }\n        d.finish()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::hash::Hash>::hash":["fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,{\n        for i in self.iter() {\n            i.hash(state);\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::iter::Extend<(RK, RV)>>::extend":["fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = (RK, RV)>,{\n        for (key, value) in iter {\n            self.insert(From::from(key), From::from(value));\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::iter::FromIterator<(K, V)>>::from_iter":["fn from_iter<T>(i: T) -> Self\n    where\n        T: IntoIterator<Item = (K, V)>,{\n        let mut map = Self::default();\n        for (k, v) in i {\n            map.insert(k, v);\n        }\n        map\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        ConsumingIter {\n            it: NodeDrain::new(&self.pool.0, self.root, self.size),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::iter::Sum>::sum":["fn sum<I>(it: I) -> Self\n    where\n        I: Iterator<Item = Self>,{\n        it.fold(Self::default(), |a, b| a + b)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::ops::Add>::add":["fn add(self, other: Self) -> Self::Output{\n        self.union(other)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::ops::Index<&'a BK>>::index":["fn index(&self, key: &BK) -> &Self::Output{\n        match self.root.get(hash_key(&*self.hasher, key), 0, key) {\n            None => panic!(\"HashMap::index: invalid key\"),\n            Some(&(_, ref value)) => value,\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<K, V, S> as std::ops::IndexMut<&'a BK>>::index_mut":["fn index_mut(&mut self, key: &BK) -> &mut Self::Output{\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        match root.get_mut(&self.pool.0, hash_key(&*self.hasher, key), 0, key) {\n            None => panic!(\"HashMap::index_mut: invalid key\"),\n            Some(&mut (_, ref mut value)) => value,\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMap<OK, OV, SB> as std::convert::From<&'m hash::map::HashMap<&'k K, &'v V, SA>>>::from":["fn from(m: &HashMap<&K, &V, SA>) -> Self{\n        m.iter()\n            .map(|(k, v)| ((*k).to_owned(), (*v).to_owned()))\n            .collect()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::HashMapPool<K, V> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                Self(self.0.clone())\n            }","Real(LocalPath(\"src/util.rs\"))"],"<hash::map::HashMapPool<K, V> as std::default::Default>::default":["fn default() -> Self{\n                Self::new($crate::config::POOL_SIZE)\n            }","Real(LocalPath(\"src/util.rs\"))"],"<hash::map::Iter<'a, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|((k, v), _)| (k, v))\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::Iter<'a, K, V> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::IterMut<'a, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|((k, v), _)| (&*k, v))\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::IterMut<'a, K, V> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::Keys<'a, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|((k, _), _)| k)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::Keys<'a, K, V> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::Values<'a, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|((_, v), _)| v)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::map::Values<'a, K, V> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"<hash::set::ConsumingIter<A> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|(v, _)| v.0)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::ConsumingIter<A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::clone::Clone>::clone":["/// Clone a set.\n///\n/// Time: O(1)\n#[inline]\nfn clone(&self) -> Self{\n        HashSet {\n            hasher: self.hasher.clone(),\n            pool: self.pool.clone(),\n            root: self.root.clone(),\n            size: self.size,\n        }\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Self) -> Ordering{\n        if Ref::ptr_eq(&self.hasher, &other.hasher) {\n            return self.iter().cmp(other.iter());\n        }\n        self.iter().cmp(other.iter())\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n        self.test_eq(other)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n        if Ref::ptr_eq(&self.hasher, &other.hasher) {\n            return self.iter().partial_cmp(other.iter());\n        }\n        self.iter().partial_cmp(other.iter())\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::convert::From<&'a [A]>>::from":["fn from(slice: &'a [A]) -> Self{\n        slice.iter().cloned().collect()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::convert::From<&'a ord::set::OrdSet<A>>>::from":["fn from(ordset: &OrdSet<A>) -> Self{\n        ordset.into_iter().cloned().collect()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::convert::From<&'a std::collections::BTreeSet<A>>>::from":["fn from(btree_set: &BTreeSet<A>) -> Self{\n        btree_set.iter().cloned().collect()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::convert::From<&'a std::collections::HashSet<A>>>::from":["fn from(hash_set: &collections::HashSet<A>) -> Self{\n        hash_set.iter().cloned().collect()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::convert::From<&'a std::vec::Vec<A>>>::from":["fn from(vec: &Vec<A>) -> Self{\n        vec.iter().cloned().collect()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::convert::From<ord::set::OrdSet<A>>>::from":["fn from(ordset: OrdSet<A>) -> Self{\n        ordset.into_iter().collect()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::convert::From<std::collections::HashSet<A>>>::from":["fn from(hash_set: collections::HashSet<A>) -> Self{\n        hash_set.into_iter().collect()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::convert::From<std::vec::Vec<A>>>::from":["fn from(vec: Vec<A>) -> Self{\n        vec.into_iter().collect()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::default::Default>::default":["fn default() -> Self{\n        let pool = HashSetPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashSet {\n            hasher: Ref::<S>::default(),\n            pool,\n            root,\n            size: 0,\n        }\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>{\n        f.debug_set().entries(self.iter()).finish()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::hash::Hash>::hash":["fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,{\n        for i in self.iter() {\n            i.hash(state);\n        }\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::iter::Extend<R>>::extend":["fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = R>,{\n        for value in iter {\n            self.insert(From::from(value));\n        }\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::iter::FromIterator<RA>>::from_iter":["fn from_iter<T>(i: T) -> Self\n    where\n        T: IntoIterator<Item = RA>,{\n        let mut set = Self::default();\n        for value in i {\n            set.insert(From::from(value));\n        }\n        set\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        ConsumingIter {\n            it: NodeDrain::new(&self.pool.0, self.root, self.size),\n        }\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::iter::Sum>::sum":["fn sum<I>(it: I) -> Self\n    where\n        I: Iterator<Item = Self>,{\n        it.fold(Self::default(), |a, b| a + b)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::ops::Add>::add":["fn add(self, other: Self) -> Self::Output{\n        self.union(other)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<A, S> as std::ops::Mul>::mul":["fn mul(self, other: Self) -> Self::Output{\n        self.intersection(other)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSet<OA, SB> as std::convert::From<&'s hash::set::HashSet<&'a A, SA>>>::from":["fn from(set: &HashSet<&A, SA>) -> Self{\n        set.iter().map(|a| (*a).to_owned()).collect()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::HashSetPool<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                Self(self.0.clone())\n            }","Real(LocalPath(\"src/util.rs\"))"],"<hash::set::HashSetPool<A> as std::default::Default>::default":["fn default() -> Self{\n                Self::new($crate::config::POOL_SIZE)\n            }","Real(LocalPath(\"src/util.rs\"))"],"<hash::set::Iter<'a, A> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|(v, _)| &v.0)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::Iter<'a, A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::Value<A> as nodes::hamt::HashValue>::extract_key":["fn extract_key(&self) -> &Self::Key{\n        &self.0\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::Value<A> as nodes::hamt::HashValue>::ptr_eq":["fn ptr_eq(&self, _other: &Self) -> bool{\n        false\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<hash::set::Value<A> as std::ops::Deref>::deref":["fn deref(&self) -> &Self::Target{\n        &self.0\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"<nodes::btree::ConsumingIter<A> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        loop {\n            match self.back_stack.pop() {\n                None => {\n                    self.remaining = 0;\n                    return None;\n                }\n                Some(ConsumingIterItem::Consider(node)) => self.push_back(node),\n                Some(ConsumingIterItem::Yield(value)) => {\n                    if let Some(ref last) = self.fwd_last {\n                        if value.cmp_values(last) != Ordering::Greater {\n                            self.fwd_stack.clear();\n                            self.back_stack.clear();\n                            self.remaining = 0;\n                            return None;\n                        }\n                    }\n                    self.remaining -= 1;\n                    self.back_last = Some(value.clone());\n                    return Some(value);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"<nodes::btree::ConsumingIter<A> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        loop {\n            match self.fwd_stack.pop() {\n                None => {\n                    self.remaining = 0;\n                    return None;\n                }\n                Some(ConsumingIterItem::Consider(node)) => self.push_fwd(node),\n                Some(ConsumingIterItem::Yield(value)) => {\n                    if let Some(ref last) = self.back_last {\n                        if value.cmp_values(last) != Ordering::Less {\n                            self.fwd_stack.clear();\n                            self.back_stack.clear();\n                            self.remaining = 0;\n                            return None;\n                        }\n                    }\n                    self.remaining -= 1;\n                    self.fwd_last = Some(value.clone());\n                    return Some(value);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"<nodes::btree::ConsumingIter<A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (self.remaining, Some(self.remaining))\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"<nodes::btree::DiffIter<'a, A> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        loop {\n            match (self.old_stack.pop(), self.new_stack.pop()) {\n                (None, None) => return None,\n                (None, Some(new)) => match new {\n                    IterItem::Consider(new) => Self::push(&mut self.new_stack, &new),\n                    IterItem::Yield(new) => return Some(DiffItem::Add(new)),\n                },\n                (Some(old), None) => match old {\n                    IterItem::Consider(old) => Self::push(&mut self.old_stack, &old),\n                    IterItem::Yield(old) => return Some(DiffItem::Remove(old)),\n                },\n                (Some(old), Some(new)) => match (old, new) {\n                    (IterItem::Consider(old), IterItem::Consider(new)) => {\n                        if !std::ptr::eq(old, new) {\n                            match old.keys[0].cmp_values(&new.keys[0]) {\n                                Ordering::Less => {\n                                    Self::push(&mut self.old_stack, &old);\n                                    self.new_stack.push(IterItem::Consider(new));\n                                }\n                                Ordering::Greater => {\n                                    self.old_stack.push(IterItem::Consider(old));\n                                    Self::push(&mut self.new_stack, &new);\n                                }\n                                Ordering::Equal => {\n                                    Self::push(&mut self.old_stack, &old);\n                                    Self::push(&mut self.new_stack, &new);\n                                }\n                            }\n                        }\n                    }\n                    (IterItem::Consider(old), IterItem::Yield(new)) => {\n                        Self::push(&mut self.old_stack, &old);\n                        self.new_stack.push(IterItem::Yield(new));\n                    }\n                    (IterItem::Yield(old), IterItem::Consider(new)) => {\n                        self.old_stack.push(IterItem::Yield(old));\n                        Self::push(&mut self.new_stack, &new);\n                    }\n                    (IterItem::Yield(old), IterItem::Yield(new)) => match old.cmp_values(&new) {\n                        Ordering::Less => {\n                            self.new_stack.push(IterItem::Yield(new));\n                            return Some(DiffItem::Remove(old));\n                        }\n                        Ordering::Equal => {\n                            if old != new {\n                                return Some(DiffItem::Update { old, new });\n                            }\n                        }\n                        Ordering::Greater => {\n                            self.old_stack.push(IterItem::Yield(old));\n                            return Some(DiffItem::Add(new));\n                        }\n                    },\n                },\n            }\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"<nodes::btree::Iter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        match Iter::get(&self.back_path) {\n            None => None,\n            Some(value) => match Iter::get(&self.fwd_path) {\n                Some(last_value) if value.cmp_values(last_value) == Ordering::Less => None,\n                None => None,\n                Some(_) => {\n                    Iter::step_back(&mut self.back_path);\n                    self.remaining -= 1;\n                    Some(value)\n                }\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"<nodes::btree::Iter<'a, A> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        match Iter::get(&self.fwd_path) {\n            None => None,\n            Some(value) => match Iter::get(&self.back_path) {\n                Some(last_value) if value.cmp_values(last_value) == Ordering::Greater => None,\n                None => None,\n                Some(_) => {\n                    Iter::step_forward(&mut self.fwd_path);\n                    self.remaining -= 1;\n                    Some(value)\n                }\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"<nodes::btree::Iter<'a, A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        // (0, Some(self.remaining))\n        (0, None)\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"<nodes::btree::Node<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        Node {\n            keys: self.keys.clone(),\n            children: self.children.clone(),\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"<nodes::btree::Node<A> as std::default::Default>::default":["fn default() -> Self{\n        Node {\n            keys: Chunk::new(),\n            children: Chunk::unit(None),\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"<nodes::hamt::Drain<A> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        if self.count == 0 {\n            return None;\n        }\n        if self.collision.is_some() {\n            if let Some(ref mut coll) = self.collision {\n                if let Some(value) = coll.data.pop() {\n                    self.count -= 1;\n                    return Some((value, coll.hash));\n                }\n            }\n            self.collision = None;\n            return self.next();\n        }\n        match PoolRef::make_mut(&self.pool, &mut self.current).data.pop() {\n            Some(Entry::Value(value, hash)) => {\n                self.count -= 1;\n                Some((value, hash))\n            }\n            Some(Entry::Collision(coll_ref)) => {\n                self.collision = Some(clone_ref(coll_ref));\n                self.next()\n            }\n            Some(Entry::Node(child)) => {\n                let parent = mem::replace(&mut self.current, child);\n                self.stack.push(parent);\n                self.next()\n            }\n            None => match self.stack.pop() {\n                None => None,\n                Some(parent) => {\n                    self.current = parent;\n                    self.next()\n                }\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"<nodes::hamt::Drain<A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (self.count, Some(self.count))\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"<nodes::hamt::Entry<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        match self {\n            Entry::Value(value, hash) => Entry::Value(value.clone(), *hash),\n            Entry::Collision(coll) => Entry::Collision(coll.clone()),\n            Entry::Node(node) => Entry::Node(node.clone()),\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"<nodes::hamt::Entry<A> as std::convert::From<nodes::hamt::CollisionNode<A>>>::from":["fn from(node: CollisionNode<A>) -> Self{\n        Entry::Collision(Ref::new(node))\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"<nodes::hamt::Iter<'a, A> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        if self.count == 0 {\n            return None;\n        }\n        if self.collision.is_some() {\n            if let Some((hash, ref mut coll)) = self.collision {\n                match coll.next() {\n                    None => {}\n                    Some(value) => {\n                        self.count -= 1;\n                        return Some((value, hash));\n                    }\n                }\n            }\n            self.collision = None;\n            return self.next();\n        }\n        match self.current.next() {\n            Some(Entry::Value(value, hash)) => {\n                self.count -= 1;\n                Some((value, *hash))\n            }\n            Some(Entry::Node(child)) => {\n                let current = mem::replace(&mut self.current, child.data.iter());\n                self.stack.push(current);\n                self.next()\n            }\n            Some(Entry::Collision(coll)) => {\n                self.collision = Some((coll.hash, coll.data.iter()));\n                self.next()\n            }\n            None => match self.stack.pop() {\n                None => None,\n                Some(iter) => {\n                    self.current = iter;\n                    self.next()\n                }\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"<nodes::hamt::Iter<'a, A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (self.count, Some(self.count))\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"<nodes::hamt::IterMut<'a, A> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        if self.count == 0 {\n            return None;\n        }\n        if self.collision.is_some() {\n            if let Some((hash, ref mut coll)) = self.collision {\n                match coll.next() {\n                    None => {}\n                    Some(value) => {\n                        self.count -= 1;\n                        return Some((value, hash));\n                    }\n                }\n            }\n            self.collision = None;\n            return self.next();\n        }\n        match self.current.next() {\n            Some(Entry::Value(value, hash)) => {\n                self.count -= 1;\n                Some((value, *hash))\n            }\n            Some(Entry::Node(child_ref)) => {\n                let child = PoolRef::make_mut(&self.pool, child_ref);\n                let current = mem::replace(&mut self.current, child.data.iter_mut());\n                self.stack.push(current);\n                self.next()\n            }\n            Some(Entry::Collision(coll_ref)) => {\n                let coll = Ref::make_mut(coll_ref);\n                self.collision = Some((coll.hash, coll.data.iter_mut()));\n                self.next()\n            }\n            None => match self.stack.pop() {\n                None => None,\n                Some(iter) => {\n                    self.current = iter;\n                    self.next()\n                }\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"<nodes::hamt::IterMut<'a, A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (self.count, Some(self.count))\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"<nodes::hamt::Node<A> as std::default::Default>::default":["fn default() -> Self{\n        Self::new()\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"<nodes::hamt::Node<A> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error>{\n        write!(f, \"Node[ \")?;\n        for i in self.data.indices() {\n            write!(f, \"{}: \", i)?;\n            match &self.data[i] {\n                Entry::Value(v, h) => write!(f, \"{:?} :: {}, \", v, h)?,\n                Entry::Collision(c) => write!(f, \"Coll{:?} :: {}\", c.data, c.hash)?,\n                Entry::Node(n) => write!(f, \"{:?}, \", n)?,\n            }\n        }\n        write!(f, \" ]\")\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"<nodes::rrb::Entry<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        match *self {\n            Nodes(ref size, ref nodes) => Nodes(size.clone(), nodes.clone()),\n            Values(ref values) => Values(values.clone()),\n            Empty => Empty,\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"<nodes::rrb::Node<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        Node {\n            children: self.children.clone(),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"<nodes::rrb::Node<A> as std::default::Default>::default":["fn default() -> Self{\n        Self::new()\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"<nodes::rrb::Size as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        match *self {\n            Size::Size(size) => Size::Size(size),\n            Size::Table(ref table) => Size::Table(table.clone()),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"<ord::map::DiffIter<'a, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|item| match item {\n            NodeDiffItem::Add((k, v)) => DiffItem::Add(k, v),\n            NodeDiffItem::Update {\n                old: (oldk, oldv),\n                new: (newk, newv),\n            } => DiffItem::Update {\n                old: (oldk, oldv),\n                new: (newk, newv),\n            },\n            NodeDiffItem::Remove((k, v)) => DiffItem::Remove(k, v),\n        })\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::Iter<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.it.next_back().map(|(k, v)| (k, v))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::Iter<'a, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|(k, v)| (k, v))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::Iter<'a, K, V> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (self.it.remaining, Some(self.it.remaining))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::Keys<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        match self.it.next_back() {\n            None => None,\n            Some((k, _)) => Some(k),\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::Keys<'a, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|(k, _)| k)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::Keys<'a, K, V> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::clone::Clone>::clone":["/// Clone a map.\n///\n/// Time: O(1)\n#[inline]\nfn clone(&self) -> Self{\n        OrdMap {\n            size: self.size,\n            pool: self.pool.clone(),\n            root: self.root.clone(),\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Self) -> Ordering{\n        self.iter().cmp(other.iter())\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n        PoolRef::ptr_eq(&self.root, &other.root)\n            || (self.len() == other.len() && self.diff(other).next().is_none())\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n        self.iter().partial_cmp(other.iter())\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::convert::AsRef<ord::map::OrdMap<K, V>>>::as_ref":["fn as_ref(&self) -> &Self{\n        self\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a [(RK, RV)]>>::from":["fn from(m: &'a [(RK, RV)]) -> OrdMap<K, V>{\n        m.iter()\n            .map(|&(ref k, ref v)| (k.to_owned(), v.to_owned()))\n            .collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a hash::map::HashMap<K, V, S>>>::from":["fn from(m: &'a HashMap<K, V, S>) -> Self{\n        m.iter().map(|(k, v)| (k.clone(), v.clone())).collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a std::collections::BTreeMap<RK, RV>>>::from":["fn from(m: &'a collections::BTreeMap<RK, RV>) -> OrdMap<K, V>{\n        m.iter()\n            .map(|(k, v)| (k.to_owned(), v.to_owned()))\n            .collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a std::collections::HashMap<RK, RV>>>::from":["fn from(m: &'a collections::HashMap<RK, RV>) -> OrdMap<K, V>{\n        m.iter()\n            .map(|(k, v)| (k.to_owned(), v.to_owned()))\n            .collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a std::vec::Vec<(RK, RV)>>>::from":["fn from(m: &'a Vec<(RK, RV)>) -> OrdMap<K, V>{\n        m.iter()\n            .map(|&(ref k, ref v)| (k.to_owned(), v.to_owned()))\n            .collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::convert::From<hash::map::HashMap<K, V, S>>>::from":["fn from(m: HashMap<K, V, S>) -> Self{\n        m.into_iter().collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::convert::From<std::collections::BTreeMap<RK, RV>>>::from":["fn from(m: collections::BTreeMap<RK, RV>) -> OrdMap<K, V>{\n        m.into_iter().collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::convert::From<std::collections::HashMap<RK, RV>>>::from":["fn from(m: collections::HashMap<RK, RV>) -> OrdMap<K, V>{\n        m.into_iter().collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::convert::From<std::vec::Vec<(RK, RV)>>>::from":["fn from(m: Vec<(RK, RV)>) -> OrdMap<K, V>{\n        m.into_iter().collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::default::Default>::default":["fn default() -> Self{\n        Self::new()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>{\n        let mut d = f.debug_map();\n        for (k, v) in self.iter() {\n            d.entry(k, v);\n        }\n        d.finish()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::hash::Hash>::hash":["fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,{\n        for i in self.iter() {\n            i.hash(state);\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::iter::Extend<(RK, RV)>>::extend":["fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = (RK, RV)>,{\n        for (key, value) in iter {\n            self.insert(From::from(key), From::from(value));\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::iter::FromIterator<(RK, RV)>>::from_iter":["fn from_iter<T>(i: T) -> Self\n    where\n        T: IntoIterator<Item = (RK, RV)>,{\n        let mut m = OrdMap::default();\n        for (k, v) in i {\n            m.insert(From::from(k), From::from(v));\n        }\n        m\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        ConsumingIter::new(&self.root, self.size)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::iter::Sum>::sum":["fn sum<I>(it: I) -> Self\n    where\n        I: Iterator<Item = Self>,{\n        it.fold(Self::default(), |a, b| a + b)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::ops::Add>::add":["fn add(self, other: Self) -> Self::Output{\n        self.union(other)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::ops::Index<&'a BK>>::index":["fn index(&self, key: &BK) -> &Self::Output{\n        match self.root.lookup(key) {\n            None => panic!(\"OrdMap::index: invalid key\"),\n            Some(&(_, ref value)) => value,\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<K, V> as std::ops::IndexMut<&'a BK>>::index_mut":["fn index_mut(&mut self, key: &BK) -> &mut Self::Output{\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        match root.lookup_mut(&self.pool.0, key) {\n            None => panic!(\"OrdMap::index: invalid key\"),\n            Some(&mut (_, ref mut value)) => value,\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMap<OK, OV> as std::convert::From<&'m ord::map::OrdMap<&'k K, &'v V>>>::from":["fn from(m: &OrdMap<&K, &V>) -> Self{\n        m.iter()\n            .map(|(k, v)| ((*k).to_owned(), (*v).to_owned()))\n            .collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::OrdMapPool<K, V> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                Self(self.0.clone())\n            }","Real(LocalPath(\"src/util.rs\"))"],"<ord::map::OrdMapPool<K, V> as std::default::Default>::default":["fn default() -> Self{\n                Self::new($crate::config::POOL_SIZE)\n            }","Real(LocalPath(\"src/util.rs\"))"],"<ord::map::Values<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        match self.it.next_back() {\n            None => None,\n            Some((_, v)) => Some(v),\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::Values<'a, K, V> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|(_, v)| v)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::map::Values<'a, K, V> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"<ord::set::ConsumingIter<A> as std::iter::Iterator>::next":["/// Advance the iterator and return the next value.\n///\n/// Time: O(1)*\nfn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|v| v.0)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::DiffIter<'a, A> as std::iter::Iterator>::next":["/// Advance the iterator and return the next value.\n///\n/// Time: O(1)*\nfn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(|item| match item {\n            DiffItem::Add(v) => DiffItem::Add(v.deref()),\n            DiffItem::Update { old, new } => DiffItem::Update {\n                old: old.deref(),\n                new: new.deref(),\n            },\n            DiffItem::Remove(v) => DiffItem::Remove(v.deref()),\n        })\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::Iter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.it.next_back().map(Deref::deref)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::Iter<'a, A> as std::iter::Iterator>::next":["/// Advance the iterator and return the next value.\n///\n/// Time: O(1)*\nfn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(Deref::deref)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::Iter<'a, A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (self.it.remaining, Some(self.it.remaining))\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::clone::Clone>::clone":["/// Clone a set.\n///\n/// Time: O(1)\n#[inline]\nfn clone(&self) -> Self{\n        OrdSet {\n            size: self.size,\n            pool: self.pool.clone(),\n            root: self.root.clone(),\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Self) -> Ordering{\n        self.iter().cmp(other.iter())\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n        PoolRef::ptr_eq(&self.root, &other.root)\n            || (self.len() == other.len() && self.diff(other).next().is_none())\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n        self.iter().partial_cmp(other.iter())\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::convert::From<&'a [A]>>::from":["fn from(slice: &'a [A]) -> Self{\n        slice.iter().cloned().collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::convert::From<&'a hash::set::HashSet<A, S>>>::from":["fn from(hashset: &HashSet<A, S>) -> Self{\n        hashset.into_iter().cloned().collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::convert::From<&'a std::collections::BTreeSet<A>>>::from":["fn from(btree_set: &collections::BTreeSet<A>) -> Self{\n        btree_set.iter().cloned().collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::convert::From<&'a std::collections::HashSet<A>>>::from":["fn from(hash_set: &collections::HashSet<A>) -> Self{\n        hash_set.iter().cloned().collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::convert::From<&'a std::vec::Vec<A>>>::from":["fn from(vec: &Vec<A>) -> Self{\n        vec.iter().cloned().collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::convert::From<hash::set::HashSet<A, S>>>::from":["fn from(hashset: HashSet<A, S>) -> Self{\n        hashset.into_iter().collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::convert::From<std::collections::BTreeSet<A>>>::from":["fn from(btree_set: collections::BTreeSet<A>) -> Self{\n        btree_set.into_iter().collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::convert::From<std::collections::HashSet<A>>>::from":["fn from(hash_set: collections::HashSet<A>) -> Self{\n        hash_set.into_iter().collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::convert::From<std::vec::Vec<A>>>::from":["fn from(vec: Vec<A>) -> Self{\n        vec.into_iter().collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::default::Default>::default":["fn default() -> Self{\n        OrdSet::new()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>{\n        f.debug_set().entries(self.iter()).finish()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::hash::Hash>::hash":["fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,{\n        for i in self.iter() {\n            i.hash(state);\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::iter::Extend<R>>::extend":["fn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = R>,{\n        for value in iter {\n            self.insert(From::from(value));\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::iter::FromIterator<R>>::from_iter":["fn from_iter<T>(i: T) -> Self\n    where\n        T: IntoIterator<Item = R>,{\n        let mut out = Self::new();\n        for item in i {\n            out.insert(From::from(item));\n        }\n        out\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        ConsumingIter {\n            it: ConsumingNodeIter::new(&self.root, self.size),\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::iter::Sum>::sum":["fn sum<I>(it: I) -> Self\n    where\n        I: Iterator<Item = Self>,{\n        it.fold(Self::new(), |a, b| a + b)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::ops::Add>::add":["fn add(self, other: Self) -> Self::Output{\n        self.union(other)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<A> as std::ops::Mul>::mul":["fn mul(self, other: Self) -> Self::Output{\n        self.intersection(other)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSet<OA> as std::convert::From<&'s ord::set::OrdSet<&'a A>>>::from":["fn from(set: &OrdSet<&A>) -> Self{\n        set.iter().map(|a| (*a).to_owned()).collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::OrdSetPool<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n                Self(self.0.clone())\n            }","Real(LocalPath(\"src/util.rs\"))"],"<ord::set::OrdSetPool<A> as std::default::Default>::default":["fn default() -> Self{\n                Self::new($crate::config::POOL_SIZE)\n            }","Real(LocalPath(\"src/util.rs\"))"],"<ord::set::RangedIter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        self.it.next_back().map(Deref::deref)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::RangedIter<'a, A> as std::iter::Iterator>::next":["/// Advance the iterator and return the next value.\n///\n/// Time: O(1)*\nfn next(&mut self) -> Option<Self::Item>{\n        self.it.next().map(Deref::deref)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::RangedIter<'a, A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::cmp_keys":["fn cmp_keys<BK>(&self, other: &BK) -> Ordering\n    where\n        BK: Ord + ?Sized,\n        Self::Key: Borrow<BK>,{\n        Self::Key::borrow(self).cmp(other)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::cmp_values":["fn cmp_values(&self, other: &Self) -> Ordering{\n        self.cmp(other)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::ptr_eq":["fn ptr_eq(&self, _other: &Self) -> bool{\n        false\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::search_key":["fn search_key<BK>(slice: &[Self], key: &BK) -> Result<usize, usize>\n    where\n        BK: Ord + ?Sized,\n        Self::Key: Borrow<BK>,{\n        linear_search_by(slice, |value| Self::Key::borrow(value).cmp(key))\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::search_value":["fn search_value(slice: &[Self], key: &Self) -> Result<usize, usize>{\n        linear_search_by(slice, |value| value.cmp(key))\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<ord::set::Value<A> as std::ops::Deref>::deref":["fn deref(&self) -> &Self::Target{\n        &self.0\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"<sync::lock::Lock<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n            Lock {\n                lock: self.lock.clone(),\n            }\n        }","Real(LocalPath(\"src/sync.rs\"))"],"<vector::Chunks<'a, A> as std::iter::DoubleEndedIterator>::next_back":["/// Remove and return an element from the back of the iterator.\n///\n/// Time: O(1)*\nfn next_back(&mut self) -> Option<Self::Item>{\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        self.back_index -= 1;\n        #[allow(unsafe_code)]\n        let focus: &'a mut Focus<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let (range, value) = focus.chunk_at(self.back_index);\n        self.back_index = range.start;\n        Some(value)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Chunks<'a, A> as std::iter::Iterator>::next":["/// Advance the iterator and return the next value.\n///\n/// Time: O(1)*\nfn next(&mut self) -> Option<Self::Item>{\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        #[allow(unsafe_code)]\n        let focus: &'a mut Focus<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let (range, value) = focus.chunk_at(self.front_index);\n        self.front_index = range.end;\n        Some(value)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::ChunksMut<'a, A> as std::iter::DoubleEndedIterator>::next_back":["/// Remove and return an element from the back of the iterator.\n///\n/// Time: O(1)*\nfn next_back(&mut self) -> Option<Self::Item>{\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        self.back_index -= 1;\n        #[allow(unsafe_code)]\n        let focus: &'a mut FocusMut<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let (range, value) = focus.chunk_at(self.back_index);\n        self.back_index = range.start;\n        Some(value)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::ChunksMut<'a, A> as std::iter::Iterator>::next":["/// Advance the iterator and return the next value.\n///\n/// Time: O(1)*\nfn next(&mut self) -> Option<Self::Item>{\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        #[allow(unsafe_code)]\n        let focus: &'a mut FocusMut<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let (range, value) = focus.chunk_at(self.front_index);\n        self.front_index = range.end;\n        Some(value)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::ConsumingIter<A> as std::iter::DoubleEndedIterator>::next_back":["/// Remove and return an element from the back of the iterator.\n///\n/// Time: O(1)*\nfn next_back(&mut self) -> Option<Self::Item>{\n        self.vector.pop_back()\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::ConsumingIter<A> as std::iter::Iterator>::next":["/// Advance the iterator and return the next value.\n///\n/// Time: O(1)*\nfn next(&mut self) -> Option<Self::Item>{\n        self.vector.pop_front()\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::ConsumingIter<A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let len = self.vector.len();\n        (len, Some(len))\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Iter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["/// Advance the iterator and return the next value.\n///\n/// Time: O(1)*\nfn next_back(&mut self) -> Option<Self::Item>{\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        self.back_index -= 1;\n        #[allow(unsafe_code)]\n        let focus: &'a mut Focus<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        focus.get(self.back_index)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Iter<'a, A> as std::iter::Iterator>::next":["/// Advance the iterator and return the next value.\n///\n/// Time: O(1)*\nfn next(&mut self) -> Option<Self::Item>{\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        #[allow(unsafe_code)]\n        let focus: &'a mut Focus<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let value = focus.get(self.front_index);\n        self.front_index += 1;\n        value\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Iter<'a, A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let remaining = self.back_index - self.front_index;\n        (remaining, Some(remaining))\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::IterMut<'a, A> as std::iter::DoubleEndedIterator>::next_back":["/// Remove and return an element from the back of the iterator.\n///\n/// Time: O(1)*\nfn next_back(&mut self) -> Option<Self::Item>{\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        self.back_index -= 1;\n        #[allow(unsafe_code)]\n        let focus: &'a mut FocusMut<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        focus.get_mut(self.back_index)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::IterMut<'a, A> as std::iter::Iterator>::next":["/// Advance the iterator and return the next value.\n///\n/// Time: O(1)*\nfn next(&mut self) -> Option<Self::Item>{\n        if self.front_index >= self.back_index {\n            return None;\n        }\n        #[allow(unsafe_code)]\n        let focus: &'a mut FocusMut<'a, A> = unsafe { &mut *(&mut self.focus as *mut _) };\n        let value = focus.get_mut(self.front_index);\n        self.front_index += 1;\n        value\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::IterMut<'a, A> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let remaining = self.back_index - self.front_index;\n        (remaining, Some(remaining))\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::RRB<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        RRB {\n            length: self.length,\n            middle_level: self.middle_level,\n            outer_f: self.outer_f.clone(),\n            inner_f: self.inner_f.clone(),\n            middle: self.middle.clone(),\n            inner_b: self.inner_b.clone(),\n            outer_b: self.outer_b.clone(),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::clone::Clone>::clone":["/// Clone a vector.\n///\n/// Time: O(1), or O(n) with a very small, bounded *n* for an inline vector.\nfn clone(&self) -> Self{\n        Self {\n            vector: match &self.vector {\n                Inline(pool, chunk) => Inline(pool.clone(), chunk.clone()),\n                Single(pool, chunk) => Single(pool.clone(), chunk.clone()),\n                Full(pool, tree) => Full(pool.clone(), tree.clone()),\n            },\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Self) -> Ordering{\n        self.iter().cmp(other.iter())\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n        fn cmp_chunk<A>(left: &PoolRef<Chunk<A>>, right: &PoolRef<Chunk<A>>) -> bool {\n            (left.is_empty() && right.is_empty()) || PoolRef::ptr_eq(left, right)\n        }\n\n        if std::ptr::eq(self, other) {\n            return true;\n        }\n\n        match (&self.vector, &other.vector) {\n            (Single(_, left), Single(_, right)) => {\n                if cmp_chunk(left, right) {\n                    return true;\n                }\n                self.iter().eq(other.iter())\n            }\n            (Full(_, left), Full(_, right)) => {\n                if left.length != right.length {\n                    return false;\n                }\n\n                if cmp_chunk(&left.outer_f, &right.outer_f)\n                    && cmp_chunk(&left.inner_f, &right.inner_f)\n                    && cmp_chunk(&left.inner_b, &right.inner_b)\n                    && cmp_chunk(&left.outer_b, &right.outer_b)\n                    && ((left.middle.is_empty() && right.middle.is_empty())\n                        || Ref::ptr_eq(&left.middle, &right.middle))\n                {\n                    return true;\n                }\n                self.iter().eq(other.iter())\n            }\n            _ => self.len() == other.len() && self.iter().eq(other.iter()),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::cmp::PartialEq>::eq::cmp_chunk":["fn cmp_chunk<A>(left: &PoolRef<Chunk<A>>, right: &PoolRef<Chunk<A>>) -> bool{\n            (left.is_empty() && right.is_empty()) || PoolRef::ptr_eq(left, right)\n        }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n        self.iter().partial_cmp(other.iter())\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::convert::From<&'a [A]>>::from":["fn from(slice: &[A]) -> Self{\n        slice.iter().cloned().collect()\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::convert::From<&'a std::vec::Vec<A>>>::from":["/// Create a vector from a [`std::vec::Vec`][vec].\n///\n/// Time: O(n)\n///\n/// [vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\nfn from(vec: &Vec<A>) -> Self{\n        vec.iter().cloned().collect()\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::convert::From<std::vec::Vec<A>>>::from":["/// Create a vector from a [`std::vec::Vec`][vec].\n///\n/// Time: O(n)\n///\n/// [vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\nfn from(vec: Vec<A>) -> Self{\n        vec.into_iter().collect()\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::default::Default>::default":["fn default() -> Self{\n        Self::new()\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>{\n        f.debug_list().entries(self.iter()).finish()\n        // match self {\n        //     Full(rrb) => {\n        //         writeln!(f, \"Head: {:?} {:?}\", rrb.outer_f, rrb.inner_f)?;\n        //         rrb.middle.print(f, 0, rrb.middle_level)?;\n        //         writeln!(f, \"Tail: {:?} {:?}\", rrb.inner_b, rrb.outer_b)\n        //     }\n        //     Single(_) => write!(f, \"nowt\"),\n        // }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::hash::Hash>::hash":["fn hash<H: Hasher>(&self, state: &mut H){\n        for i in self {\n            i.hash(state)\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::iter::Extend<A>>::extend":["/// Add values to the end of a vector by consuming an iterator.\n///\n/// Time: O(n)\nfn extend<I>(&mut self, iter: I)\n    where\n        I: IntoIterator<Item = A>,{\n        for item in iter {\n            self.push_back(item)\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::iter::FromIterator<A>>::from_iter":["/// Create a vector from an iterator.\n///\n/// Time: O(n)\nfn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = A>,{\n        let mut seq = Self::new();\n        for item in iter {\n            seq.push_back(item)\n        }\n        seq\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        ConsumingIter::new(self)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::iter::Sum>::sum":["fn sum<I>(it: I) -> Self\n    where\n        I: Iterator<Item = Self>,{\n        it.fold(Self::new(), |a, b| a + b)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::ops::Add>::add":["/// Concatenate two vectors.\n///\n/// Time: O(log n)\nfn add(mut self, other: Self) -> Self::Output{\n        self.append(other);\n        self\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::ops::Index<usize>>::index":["/// Get a reference to the value at index `index` in the vector.\n///\n/// Time: O(log n)\nfn index(&self, index: usize) -> &Self::Output{\n        match self.get(index) {\n            Some(value) => value,\n            None => panic!(\n                \"Vector::index: index out of bounds: {} < {}\",\n                index,\n                self.len()\n            ),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<A> as std::ops::IndexMut<usize>>::index_mut":["/// Get a mutable reference to the value at index `index` in the\n/// vector.\n///\n/// Time: O(log n)\nfn index_mut(&mut self, index: usize) -> &mut Self::Output{\n        match self.get_mut(index) {\n            Some(value) => value,\n            None => panic!(\"Vector::index_mut: index out of bounds\"),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::Vector<OA> as std::convert::From<&'s vector::Vector<&'a A>>>::from":["fn from(vec: &Vector<&A>) -> Self{\n        vec.iter().map(|a| (*a).to_owned()).collect()\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"<vector::focus::Focus<'a, A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        match self {\n            Focus::Single(chunk) => Focus::Single(chunk),\n            Focus::Full(tree) => Focus::Full(tree.clone()),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"<vector::focus::Focus<'a, A> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        Iter::from_focus(self)\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"<vector::focus::FocusMut<'a, A> as std::convert::Into<vector::focus::Focus<'a, A>>>::into":["fn into(self) -> Focus<'a, A>{\n        self.unmut()\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"<vector::focus::FocusMut<'a, A> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        IterMut::from_focus(self)\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"<vector::focus::TreeFocus<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        let tree = self.tree.clone();\n        TreeFocus {\n            view: self.view.clone(),\n            middle_range: self.middle_range.clone(),\n            target_range: 0..0,\n            target_ptr: null(),\n            tree,\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"<vector::pool::RRBPool<A> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        Self {\n            node_pool: self.node_pool.clone(),\n            value_pool: self.value_pool.clone(),\n            size_pool: self.size_pool.clone(),\n        }\n    }","Real(LocalPath(\"src/vector/pool.rs\"))"],"<vector::pool::RRBPool<A> as std::default::Default>::default":["/// Construct a pool with a reasonable default pool size.\nfn default() -> Self{\n        Self::new(POOL_SIZE)\n    }","Real(LocalPath(\"src/vector/pool.rs\"))"],"fakepool::Arc":["pub(crate) struct Arc<A>(RArc<A>);","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Arc::<A>::clone_from":["#[inline(always)]\npub(crate) fn clone_from(_pool: &Pool<A>, value: &A) -> Self\n    where\n        A: PoolClone,{\n        Self(RArc::new(value.clone()))\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Arc::<A>::default":["#[inline(always)]\npub(crate) fn default(_pool: &Pool<A>) -> Self\n    where\n        A: PoolDefault,{\n        Self(Default::default())\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Arc::<A>::make_mut":["#[inline(always)]\npub(crate) fn make_mut<'a>(_pool: &Pool<A>, this: &'a mut Self) -> &'a mut A\n    where\n        A: PoolClone,{\n        RArc::make_mut(&mut this.0)\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Arc::<A>::new":["#[inline(always)]\npub(crate) fn new(_pool: &Pool<A>, value: A) -> Self{\n        Self(RArc::new(value))\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Arc::<A>::ptr_eq":["#[inline(always)]\npub(crate) fn ptr_eq(left: &Self, right: &Self) -> bool{\n        RArc::ptr_eq(&left.0, &right.0)\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Arc::<A>::unwrap_or_clone":["pub(crate) fn unwrap_or_clone(this: Self) -> A\n    where\n        A: PoolClone,{\n        RArc::try_unwrap(this.0).unwrap_or_else(|r| (*r).clone())\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Pool":["pub(crate) struct Pool<A>(PhantomData<A>);","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Pool::<A>::fill":["pub(crate) fn fill(&self){}","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Pool::<A>::get_pool_size":["pub(crate) fn get_pool_size(&self) -> usize{\n        0\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Pool::<A>::new":["pub(crate) fn new(_size: usize) -> Self{\n        Pool(PhantomData)\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::PoolClone":["pub(crate) trait PoolClone: Clone {}","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::PoolDefault":["pub(crate) trait PoolDefault: Default {}","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Rc":["pub(crate) struct Rc<A>(RRc<A>);","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Rc::<A>::clone_from":["#[inline(always)]\npub(crate) fn clone_from(_pool: &Pool<A>, value: &A) -> Self\n    where\n        A: PoolClone,{\n        Rc(RRc::new(value.clone()))\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Rc::<A>::default":["#[inline(always)]\npub(crate) fn default(_pool: &Pool<A>) -> Self\n    where\n        A: PoolDefault,{\n        Self(Default::default())\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Rc::<A>::make_mut":["#[inline(always)]\npub(crate) fn make_mut<'a>(_pool: &Pool<A>, this: &'a mut Self) -> &'a mut A\n    where\n        A: PoolClone,{\n        RRc::make_mut(&mut this.0)\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Rc::<A>::new":["#[inline(always)]\npub(crate) fn new(_pool: &Pool<A>, value: A) -> Self{\n        Rc(RRc::new(value))\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Rc::<A>::ptr_eq":["#[inline(always)]\npub(crate) fn ptr_eq(left: &Self, right: &Self) -> bool{\n        RRc::ptr_eq(&left.0, &right.0)\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"fakepool::Rc::<A>::unwrap_or_clone":["pub(crate) fn unwrap_or_clone(this: Self) -> A\n    where\n        A: PoolClone,{\n        RRc::try_unwrap(this.0).unwrap_or_else(|r| (*r).clone())\n    }","Real(LocalPath(\"src/fakepool.rs\"))"],"hash::map::<impl nodes::hamt::HashValue for (K, V)>::extract_key":["fn extract_key(&self) -> &Self::Key{\n        &self.0\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::<impl nodes::hamt::HashValue for (K, V)>::ptr_eq":["fn ptr_eq(&self, _other: &Self) -> bool{\n        false\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::ConsumingIter":["/// A consuming iterator over the elements of a map.\npub struct ConsumingIter<A: HashValue> {\n    it: NodeDrain<A>,\n}","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::Entry":["/// A handle for a key and its associated value.\n///\n/// ## Performance Note\n///\n/// When using an `Entry`, the key is only ever hashed once, when you\n/// create the `Entry`. Operations on an `Entry` will never trigger a\n/// rehash, where eg. a `contains_key(key)` followed by an\n/// `insert(key, default_value)` (the equivalent of\n/// `Entry::or_insert()`) would need to hash the key once for the\n/// `contains_key` and again for the `insert`. The operations\n/// generally perform similarly otherwise.\npub enum Entry<'a, K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher,\n{\n    /// An entry which exists in the map.\n    Occupied(OccupiedEntry<'a, K, V, S>),\n    /// An entry which doesn't exist in the map.\n    Vacant(VacantEntry<'a, K, V, S>),\n}","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::Entry::<'a, K, V, S>::and_modify":["/// Call the provided function to modify the value if the value\n/// exists.\npub fn and_modify<F>(mut self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),{\n        match &mut self {\n            Entry::Occupied(ref mut entry) => f(entry.get_mut()),\n            Entry::Vacant(_) => (),\n        }\n        self\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::Entry::<'a, K, V, S>::key":["/// Get the key for this entry.\n#[must_use]\npub fn key(&self) -> &K{\n        match self {\n            Entry::Occupied(entry) => entry.key(),\n            Entry::Vacant(entry) => entry.key(),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::Entry::<'a, K, V, S>::or_default":["/// Insert a default value if there was no value already, and\n/// return a mutable reference to the value.\npub fn or_default(self) -> &'a mut V\n    where\n        V: Default,{\n        self.or_insert_with(Default::default)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::Entry::<'a, K, V, S>::or_insert":["/// Insert the default value provided if there was no value\n/// already, and return a mutable reference to the value.\npub fn or_insert(self, default: V) -> &'a mut V{\n        self.or_insert_with(|| default)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::Entry::<'a, K, V, S>::or_insert_with":["/// Insert the default value from the provided function if there\n/// was no value already, and return a mutable reference to the\n/// value.\npub fn or_insert_with<F>(self, default: F) -> &'a mut V\n    where\n        F: FnOnce() -> V,{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default()),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap":["/// An unordered map.\n///\n/// An immutable hash map using [hash array mapped tries] [1].\n///\n/// Most operations on this map are O(log<sub>x</sub> n) for a\n/// suitably high *x* that it should be nearly O(1) for most maps.\n/// Because of this, it's a great choice for a generic map as long as\n/// you don't mind that keys will need to implement\n/// [`Hash`][std::hash::Hash] and [`Eq`][std::cmp::Eq].\n///\n/// Map entries will have a predictable order based on the hasher\n/// being used. Unless otherwise specified, this will be the standard\n/// [`RandomState`][std::collections::hash_map::RandomState] hasher.\n///\n/// [1]: https://en.wikipedia.org/wiki/Hash_array_mapped_trie\n/// [std::cmp::Eq]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [std::hash::Hash]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n/// [std::collections::hash_map::RandomState]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\npub struct HashMap<K, V, S = RandomState> {\n    size: usize,\n    pool: HashMapPool<K, V>,\n    root: PoolRef<Node<(K, V)>>,\n    hasher: Ref<S>,\n}","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::alter":["/// Update the value for a given key by calling a function with\n/// the current value and overwriting it with the function's\n/// return value.\n///\n/// The function gets an [`Option<V>`][std::option::Option] and\n/// returns the same, so that it can decide to delete a mapping\n/// instead of updating the value, and decide what to do if the\n/// key isn't in the map.\n///\n/// Time: O(log n)\n///\n/// [std::option::Option]: https://doc.rust-lang.org/std/option/enum.Option.html\n#[must_use]\npub fn alter<F>(&self, f: F, k: K) -> Self\n    where\n        F: FnOnce(Option<V>) -> Option<V>,{\n        let pop = self.extract_with_key(&k);\n        match (f(pop.as_ref().map(|&(_, ref v, _)| v.clone())), pop) {\n            (None, None) => self.clone(),\n            (Some(v), None) => self.update(k, v),\n            (None, Some((_, _, m))) => m,\n            (Some(v), Some((_, _, m))) => m.update(k, v),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::clear":["/// Discard all elements from the map.\n///\n/// This leaves you with an empty map, and all elements that\n/// were previously inside it are dropped.\n///\n/// Time: O(n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::HashMap;\n/// let mut map = hashmap![1=>1, 2=>2, 3=>3];\n/// map.clear();\n/// assert!(map.is_empty());\n/// ```\npub fn clear(&mut self){\n        if !self.is_empty() {\n            self.root = PoolRef::default(&self.pool.0);\n            self.size = 0;\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::contains_key":["/// Test for the presence of a key in a hash map.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map = hashmap!{123 => \"lol\"};\n/// assert!(\n///   map.contains_key(&123)\n/// );\n/// assert!(\n///   !map.contains_key(&321)\n/// );\n/// ```\n#[inline]\n#[must_use]\npub fn contains_key<BK>(&self, k: &BK) -> bool\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,{\n        self.get(k).is_some()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::difference":["/// Construct the symmetric difference between two maps by discarding keys\n/// which occur in both maps.\n///\n/// This is an alias for the\n/// [`symmetric_difference`][symmetric_difference] method.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map1 = hashmap!{1 => 1, 3 => 4};\n/// let map2 = hashmap!{2 => 2, 3 => 5};\n/// let expected = hashmap!{1 => 1, 2 => 2};\n/// assert_eq!(expected, map1.difference(map2));\n/// ```\n///\n/// [symmetric_difference]: #method.symmetric_difference\n#[inline]\n#[must_use]\npub fn difference(self, other: Self) -> Self{\n        self.symmetric_difference(other)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::difference_with":["/// Construct the symmetric difference between two maps by using a function\n/// to decide what to do if a key occurs in both.\n///\n/// This is an alias for the\n/// [`symmetric_difference_with`][symmetric_difference_with] method.\n///\n/// Time: O(n log n)\n///\n/// [symmetric_difference_with]: #method.symmetric_difference_with\n#[inline]\n#[must_use]\npub fn difference_with<F>(self, other: Self, f: F) -> Self\n    where\n        F: FnMut(V, V) -> Option<V>,{\n        self.symmetric_difference_with(other, f)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::difference_with_key":["/// Construct the symmetric difference between two maps by using a function\n/// to decide what to do if a key occurs in both. The function\n/// receives the key as well as both values.\n///\n/// This is an alias for the\n/// [`symmetric_difference_with`_key][symmetric_difference_with_key]\n/// method.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map1 = hashmap!{1 => 1, 3 => 4};\n/// let map2 = hashmap!{2 => 2, 3 => 5};\n/// let expected = hashmap!{1 => 1, 2 => 2, 3 => 9};\n/// assert_eq!(expected, map1.difference_with_key(\n///     map2,\n///     |key, left, right| Some(left + right)\n/// ));\n/// ```\n///\n/// [symmetric_difference_with_key]: #method.symmetric_difference_with_key\n#[must_use]\npub fn difference_with_key<F>(self, other: Self, f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> Option<V>,{\n        self.symmetric_difference_with_key(other, f)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::entry":["/// Get the [`Entry`][Entry] for a key in the map for in-place manipulation.\n///\n/// Time: O(log n)\n///\n/// [Entry]: enum.Entry.html\n#[must_use]\npub fn entry(&mut self, key: K) -> Entry<'_, K, V, S>{\n        let hash = hash_key(&*self.hasher, &key);\n        if self.root.get(hash, 0, &key).is_some() {\n            Entry::Occupied(OccupiedEntry {\n                map: self,\n                hash,\n                key,\n            })\n        } else {\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash,\n                key,\n            })\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::extract":["/// Remove a key/value pair from a map, if it exists, and return\n/// the removed value as well as the updated map.\n///\n/// Time: O(log n)\n#[must_use]\npub fn extract<BK>(&self, k: &BK) -> Option<(V, Self)>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,{\n        self.extract_with_key(k).map(|(_, v, m)| (v, m))\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::extract_with_key":["/// Remove a key/value pair from a map, if it exists, and return\n/// the removed key and value as well as the updated list.\n///\n/// Time: O(log n)\n#[must_use]\npub fn extract_with_key<BK>(&self, k: &BK) -> Option<(K, V, Self)>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,{\n        let mut out = self.clone();\n        out.remove_with_key(k).map(|(k, v)| (k, v, out))\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::get":["/// Get the value for a key from a hash map.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map = hashmap!{123 => \"lol\"};\n/// assert_eq!(\n///   map.get(&123),\n///   Some(&\"lol\")\n/// );\n/// ```\n#[must_use]\npub fn get<BK>(&self, key: &BK) -> Option<&V>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,{\n        self.root\n            .get(hash_key(&*self.hasher, key), 0, key)\n            .map(|&(_, ref v)| v)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::get_key_value":["/// Get the key/value pair for a key from a hash map.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map = hashmap!{123 => \"lol\"};\n/// assert_eq!(\n///   map.get_key_value(&123),\n///   Some((&123, &\"lol\"))\n/// );\n/// ```\n#[must_use]\npub fn get_key_value<BK>(&self, key: &BK) -> Option<(&K, &V)>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,{\n        self.root\n            .get(hash_key(&*self.hasher, key), 0, key)\n            .map(|&(ref k, ref v)| (k, v))\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::get_mut":["/// Get a mutable reference to the value for a key from a hash\n/// map.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let mut map = hashmap!{123 => \"lol\"};\n/// if let Some(value) = map.get_mut(&123) {\n///     *value = \"omg\";\n/// }\n/// assert_eq!(\n///   map.get(&123),\n///   Some(&\"omg\")\n/// );\n/// ```\n#[must_use]\npub fn get_mut<BK>(&mut self, key: &BK) -> Option<&mut V>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,{\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        match root.get_mut(&self.pool.0, hash_key(&*self.hasher, key), 0, key) {\n            None => None,\n            Some(&mut (_, ref mut value)) => Some(value),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::hasher":["/// Get a reference to the map's [`BuildHasher`][BuildHasher].\n///\n/// [BuildHasher]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n#[must_use]\npub fn hasher(&self) -> &Ref<S>{\n        &self.hasher\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::insert":["/// Insert a key/value mapping into a map.\n///\n/// If the map already has a mapping for the given key, the\n/// previous value is overwritten.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let mut map = hashmap!{};\n/// map.insert(123, \"123\");\n/// map.insert(456, \"456\");\n/// assert_eq!(\n///   map,\n///   hashmap!{123 => \"123\", 456 => \"456\"}\n/// );\n/// ```\n#[inline]\npub fn insert(&mut self, k: K, v: V) -> Option<V>{\n        let hash = hash_key(&*self.hasher, &k);\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        let result = root.insert(&self.pool.0, hash, 0, (k, v));\n        if result.is_none() {\n            self.size += 1;\n        }\n        result.map(|(_, v)| v)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::intersection":["/// Construct the intersection of two maps, keeping the values\n/// from the current map.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map1 = hashmap!{1 => 1, 2 => 2};\n/// let map2 = hashmap!{2 => 3, 3 => 4};\n/// let expected = hashmap!{2 => 2};\n/// assert_eq!(expected, map1.intersection(map2));\n/// ```\n#[inline]\n#[must_use]\npub fn intersection(self, other: Self) -> Self{\n        self.intersection_with_key(other, |_, v, _| v)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::intersection_with":["/// Construct the intersection of two maps, calling a function\n/// with both values for each key and using the result as the\n/// value for the key.\n///\n/// Time: O(n log n)\n#[inline]\n#[must_use]\npub fn intersection_with<B, C, F>(self, other: HashMap<K, B, S>, mut f: F) -> HashMap<K, C, S>\n    where\n        B: Clone,\n        C: Clone,\n        F: FnMut(V, B) -> C,{\n        self.intersection_with_key(other, |_, v1, v2| f(v1, v2))\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::intersection_with_key":["/// Construct the intersection of two maps, calling a function\n/// with the key and both values for each key and using the result\n/// as the value for the key.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map1 = hashmap!{1 => 1, 2 => 2};\n/// let map2 = hashmap!{2 => 3, 3 => 4};\n/// let expected = hashmap!{2 => 5};\n/// assert_eq!(expected, map1.intersection_with_key(\n///     map2,\n///     |key, left, right| left + right\n/// ));\n/// ```\n#[must_use]\npub fn intersection_with_key<B, C, F>(\n        mut self,\n        other: HashMap<K, B, S>,\n        mut f: F,\n    ) -> HashMap<K, C, S>\n    where\n        B: Clone,\n        C: Clone,\n        F: FnMut(&K, V, B) -> C,{\n        let mut out = self.new_from();\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => (),\n                Some(left_value) => {\n                    let result = f(&key, left_value, right_value);\n                    out.insert(key, result);\n                }\n            }\n        }\n        out\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::is_empty":["/// Test whether a hash map is empty.\n///\n/// Time: O(1)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// assert!(\n///   !hashmap!{1 => 2}.is_empty()\n/// );\n/// assert!(\n///   HashMap::<i32, i32>::new().is_empty()\n/// );\n/// ```\n#[inline]\n#[must_use]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::is_proper_submap":["/// Test whether a map is a proper submap of another map, meaning\n/// that all keys in our map must also be in the other map, with\n/// the same values. To be a proper submap, ours must also contain\n/// fewer keys than the other map.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map1 = hashmap!{1 => 1, 2 => 2};\n/// let map2 = hashmap!{1 => 1, 2 => 2, 3 => 3};\n/// assert!(map1.is_proper_submap(map2));\n///\n/// let map3 = hashmap!{1 => 1, 2 => 2};\n/// let map4 = hashmap!{1 => 1, 2 => 2};\n/// assert!(!map3.is_proper_submap(map4));\n/// ```\n#[inline]\n#[must_use]\npub fn is_proper_submap<RM>(&self, other: RM) -> bool\n    where\n        V: PartialEq,\n        RM: Borrow<Self>,{\n        self.is_proper_submap_by(other.borrow(), PartialEq::eq)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::is_proper_submap_by":["/// Test whether a map is a proper submap of another map, meaning\n/// that all keys in our map must also be in the other map, with\n/// the same values. To be a proper submap, ours must also contain\n/// fewer keys than the other map.\n///\n/// Use the provided function to decide whether values are equal.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn is_proper_submap_by<B, RM, F>(&self, other: RM, cmp: F) -> bool\n    where\n        F: FnMut(&V, &B) -> bool,\n        RM: Borrow<HashMap<K, B, S>>,{\n        self.len() != other.borrow().len() && self.is_submap_by(other, cmp)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::is_submap":["/// Test whether a map is a submap of another map, meaning that\n/// all keys in our map must also be in the other map, with the\n/// same values.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map1 = hashmap!{1 => 1, 2 => 2};\n/// let map2 = hashmap!{1 => 1, 2 => 2, 3 => 3};\n/// assert!(map1.is_submap(map2));\n/// ```\n#[inline]\n#[must_use]\npub fn is_submap<RM>(&self, other: RM) -> bool\n    where\n        V: PartialEq,\n        RM: Borrow<Self>,{\n        self.is_submap_by(other.borrow(), PartialEq::eq)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::is_submap_by":["/// Test whether a map is a submap of another map, meaning that\n/// all keys in our map must also be in the other map, with the\n/// same values.\n///\n/// Use the provided function to decide whether values are equal.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn is_submap_by<B, RM, F>(&self, other: RM, mut cmp: F) -> bool\n    where\n        F: FnMut(&V, &B) -> bool,\n        RM: Borrow<HashMap<K, B, S>>,{\n        self.iter()\n            .all(|(k, v)| other.borrow().get(k).map(|ov| cmp(v, ov)).unwrap_or(false))\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::iter":["/// Get an iterator over the key/value pairs of a hash map.\n///\n/// Please note that the order is consistent between maps using\n/// the same hasher, but no other ordering guarantee is offered.\n/// Items will not come out in insertion order or sort order.\n/// They will, however, come out in the same order every time for\n/// the same map.\n#[inline]\n#[must_use]\npub fn iter(&self) -> Iter<'_, K, V>{\n        Iter {\n            it: NodeIter::new(&self.root, self.size),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::iter_mut":["/// Get a mutable iterator over the values of a hash map.\n///\n/// Please note that the order is consistent between maps using\n/// the same hasher, but no other ordering guarantee is offered.\n/// Items will not come out in insertion order or sort order.\n/// They will, however, come out in the same order every time for\n/// the same map.\n#[inline]\n#[must_use]\npub fn iter_mut(&mut self) -> IterMut<'_, K, V>{\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        IterMut {\n            it: NodeIterMut::new(&self.pool.0, root, self.size),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::keys":["/// Get an iterator over a hash map's keys.\n///\n/// Please note that the order is consistent between maps using\n/// the same hasher, but no other ordering guarantee is offered.\n/// Items will not come out in insertion order or sort order.\n/// They will, however, come out in the same order every time for\n/// the same map.\n#[inline]\n#[must_use]\npub fn keys(&self) -> Keys<'_, K, V>{\n        Keys {\n            it: NodeIter::new(&self.root, self.size),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::len":["/// Get the size of a hash map.\n///\n/// Time: O(1)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// assert_eq!(3, hashmap!{\n///   1 => 11,\n///   2 => 22,\n///   3 => 33\n/// }.len());\n/// ```\n#[inline]\n#[must_use]\npub fn len(&self) -> usize{\n        self.size\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::new_from":["/// Construct an empty hash map using the same hasher as the\n/// current hash map.\n#[inline]\n#[must_use]\npub fn new_from<K1, V1>(&self) -> HashMap<K1, V1, S>\n    where\n        K1: Hash + Eq + Clone,\n        V1: Clone,{\n        let pool = HashMapPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashMap {\n            size: 0,\n            pool,\n            root,\n            hasher: self.hasher.clone(),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::ptr_eq":["/// Test whether two maps refer to the same content in memory.\n///\n/// This is true if the two sides are references to the same map,\n/// or if the two maps refer to the same root node.\n///\n/// This would return true if you're comparing a map to itself, or\n/// if you're comparing a map to a fresh clone of itself.\n///\n/// Time: O(1)\npub fn ptr_eq(&self, other: &Self) -> bool{\n        std::ptr::eq(self, other) || PoolRef::ptr_eq(&self.root, &other.root)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::relative_complement":["/// Construct the relative complement between two maps by discarding keys\n/// which occur in `other`.\n///\n/// Time: O(m log n) where m is the size of the other map\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 3 => 4};\n/// let map2 = ordmap!{2 => 2, 3 => 5};\n/// let expected = ordmap!{1 => 1};\n/// assert_eq!(expected, map1.relative_complement(map2));\n/// ```\n#[inline]\n#[must_use]\npub fn relative_complement(mut self, other: Self) -> Self{\n        for (key, _) in other {\n            let _ = self.remove(&key);\n        }\n        self\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::remove":["/// Remove a key/value pair from a map, if it exists, and return\n/// the removed value.\n///\n/// This is a copy-on-write operation, so that the parts of the\n/// set's structure which are shared with other sets will be\n/// safely copied before mutating.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let mut map = hashmap!{123 => \"123\", 456 => \"456\"};\n/// assert_eq!(Some(\"123\"), map.remove(&123));\n/// assert_eq!(Some(\"456\"), map.remove(&456));\n/// assert_eq!(None, map.remove(&789));\n/// assert!(map.is_empty());\n/// ```\npub fn remove<BK>(&mut self, k: &BK) -> Option<V>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,{\n        self.remove_with_key(k).map(|(_, v)| v)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::remove_with_key":["/// Remove a key/value pair from a map, if it exists, and return\n/// the removed key and value.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let mut map = hashmap!{123 => \"123\", 456 => \"456\"};\n/// assert_eq!(Some((123, \"123\")), map.remove_with_key(&123));\n/// assert_eq!(Some((456, \"456\")), map.remove_with_key(&456));\n/// assert_eq!(None, map.remove_with_key(&789));\n/// assert!(map.is_empty());\n/// ```\npub fn remove_with_key<BK>(&mut self, k: &BK) -> Option<(K, V)>\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,{\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        let result = root.remove(&self.pool.0, hash_key(&*self.hasher, k), 0, k);\n        if result.is_some() {\n            self.size -= 1;\n        }\n        result\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::retain":["/// Filter out values from a map which don't satisfy a predicate.\n///\n/// This is slightly more efficient than filtering using an\n/// iterator, in that it doesn't need to rehash the retained\n/// values, but it still needs to reconstruct the entire tree\n/// structure of the map.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::HashMap;\n/// let mut map = hashmap!{1 => 1, 2 => 2, 3 => 3};\n/// map.retain(|k, v| *k > 1);\n/// let expected = hashmap!{2 => 2, 3 => 3};\n/// assert_eq!(expected, map);\n/// ```\npub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&K, &V) -> bool,{\n        let old_root = self.root.clone();\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        for ((key, value), hash) in NodeIter::new(&old_root, self.size) {\n            if !f(key, value) && root.remove(&self.pool.0, hash, 0, key).is_some() {\n                self.size -= 1;\n            }\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::symmetric_difference":["/// Construct the symmetric difference between two maps by discarding keys\n/// which occur in both maps.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map1 = hashmap!{1 => 1, 3 => 4};\n/// let map2 = hashmap!{2 => 2, 3 => 5};\n/// let expected = hashmap!{1 => 1, 2 => 2};\n/// assert_eq!(expected, map1.symmetric_difference(map2));\n/// ```\n#[inline]\n#[must_use]\npub fn symmetric_difference(self, other: Self) -> Self{\n        self.symmetric_difference_with_key(other, |_, _, _| None)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::symmetric_difference_with":["/// Construct the symmetric difference between two maps by using a function\n/// to decide what to do if a key occurs in both.\n///\n/// Time: O(n log n)\n#[inline]\n#[must_use]\npub fn symmetric_difference_with<F>(self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(V, V) -> Option<V>,{\n        self.symmetric_difference_with_key(other, |_, a, b| f(a, b))\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::symmetric_difference_with_key":["/// Construct the symmetric difference between two maps by using a function\n/// to decide what to do if a key occurs in both. The function\n/// receives the key as well as both values.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map1 = hashmap!{1 => 1, 3 => 4};\n/// let map2 = hashmap!{2 => 2, 3 => 5};\n/// let expected = hashmap!{1 => 1, 2 => 2, 3 => 9};\n/// assert_eq!(expected, map1.symmetric_difference_with_key(\n///     map2,\n///     |key, left, right| Some(left + right)\n/// ));\n/// ```\n#[must_use]\npub fn symmetric_difference_with_key<F>(mut self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> Option<V>,{\n        let mut out = self.new_from();\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => {\n                    out.insert(key, right_value);\n                }\n                Some(left_value) => {\n                    if let Some(final_value) = f(&key, left_value, right_value) {\n                        out.insert(key, final_value);\n                    }\n                }\n            }\n        }\n        out.union(self)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::test_eq":["fn test_eq(&self, other: &Self) -> bool\n    where\n        K: Hash + Eq,\n        V: PartialEq,{\n        if self.len() != other.len() {\n            return false;\n        }\n        let mut seen = collections::HashSet::new();\n        for (key, value) in self.iter() {\n            if Some(value) != other.get(&key) {\n                return false;\n            }\n            seen.insert(key);\n        }\n        for key in other.keys() {\n            if !seen.contains(&key) {\n                return false;\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::union":["/// Construct the union of two maps, keeping the values in the\n/// current map when keys exist in both maps.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map1 = hashmap!{1 => 1, 3 => 3};\n/// let map2 = hashmap!{2 => 2, 3 => 4};\n/// let expected = hashmap!{1 => 1, 2 => 2, 3 => 3};\n/// assert_eq!(expected, map1.union(map2));\n/// ```\n#[must_use]\npub fn union(mut self, other: Self) -> Self{\n        for (k, v) in other {\n            self.entry(k).or_insert(v);\n        }\n        self\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::union_with":["/// Construct the union of two maps, using a function to decide\n/// what to do with the value when a key is in both maps.\n///\n/// The function is called when a value exists in both maps, and\n/// receives the value from the current map as its first argument,\n/// and the value from the other map as the second. It should\n/// return the value to be inserted in the resulting map.\n///\n/// Time: O(n log n)\n#[inline]\n#[must_use]\npub fn union_with<F>(self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(V, V) -> V,{\n        self.union_with_key(other, |_, v1, v2| f(v1, v2))\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::union_with_key":["/// Construct the union of two maps, using a function to decide\n/// what to do with the value when a key is in both maps.\n///\n/// The function is called when a value exists in both maps, and\n/// receives a reference to the key as its first argument, the\n/// value from the current map as the second argument, and the\n/// value from the other map as the third argument. It should\n/// return the value to be inserted in the resulting map.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map1 = hashmap!{1 => 1, 3 => 4};\n/// let map2 = hashmap!{2 => 2, 3 => 5};\n/// let expected = hashmap!{1 => 1, 2 => 2, 3 => 9};\n/// assert_eq!(expected, map1.union_with_key(\n///     map2,\n///     |key, left, right| left + right\n/// ));\n/// ```\n#[must_use]\npub fn union_with_key<F>(mut self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> V,{\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => {\n                    self.insert(key, right_value);\n                }\n                Some(left_value) => {\n                    let final_value = f(&key, left_value, right_value);\n                    self.insert(key, final_value);\n                }\n            }\n        }\n        self\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::unions":["/// Construct the union of a sequence of maps, selecting the value\n/// of the leftmost when a key appears in more than one map.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map1 = hashmap!{1 => 1, 3 => 3};\n/// let map2 = hashmap!{2 => 2};\n/// let expected = hashmap!{1 => 1, 2 => 2, 3 => 3};\n/// assert_eq!(expected, HashMap::unions(vec![map1, map2]));\n/// ```\n#[must_use]\npub fn unions<I>(i: I) -> Self\n    where\n        S: Default,\n        I: IntoIterator<Item = Self>,{\n        i.into_iter().fold(Self::default(), Self::union)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::unions_with":["/// Construct the union of a sequence of maps, using a function to\n/// decide what to do with the value when a key is in more than\n/// one map.\n///\n/// The function is called when a value exists in multiple maps,\n/// and receives the value from the current map as its first\n/// argument, and the value from the next map as the second. It\n/// should return the value to be inserted in the resulting map.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn unions_with<I, F>(i: I, f: F) -> Self\n    where\n        S: Default,\n        I: IntoIterator<Item = Self>,\n        F: Fn(V, V) -> V,{\n        i.into_iter()\n            .fold(Self::default(), |a, b| a.union_with(b, &f))\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::unions_with_key":["/// Construct the union of a sequence of maps, using a function to\n/// decide what to do with the value when a key is in more than\n/// one map.\n///\n/// The function is called when a value exists in multiple maps,\n/// and receives a reference to the key as its first argument, the\n/// value from the current map as the second argument, and the\n/// value from the next map as the third argument. It should\n/// return the value to be inserted in the resulting map.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn unions_with_key<I, F>(i: I, f: F) -> Self\n    where\n        S: Default,\n        I: IntoIterator<Item = Self>,\n        F: Fn(&K, V, V) -> V,{\n        i.into_iter()\n            .fold(Self::default(), |a, b| a.union_with_key(b, &f))\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::update":["/// Construct a new hash map by inserting a key/value mapping into a map.\n///\n/// If the map already has a mapping for the given key, the previous value\n/// is overwritten.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map = hashmap!{};\n/// assert_eq!(\n///   map.update(123, \"123\"),\n///   hashmap!{123 => \"123\"}\n/// );\n/// ```\n#[inline]\n#[must_use]\npub fn update(&self, k: K, v: V) -> Self{\n        let mut out = self.clone();\n        out.insert(k, v);\n        out\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::update_lookup_with_key":["/// Construct a new map by inserting a key/value mapping into a\n/// map, returning the old value for the key as well as the new\n/// map.\n///\n/// If the map already has a mapping for the given key, we call\n/// the provided function with the key, the old value and the new\n/// value, and insert the result as the new value.\n///\n/// Time: O(log n)\n#[must_use]\npub fn update_lookup_with_key<F>(&self, k: K, v: V, f: F) -> (Option<V>, Self)\n    where\n        F: FnOnce(&K, &V, V) -> V,{\n        match self.extract_with_key(&k) {\n            None => (None, self.update(k, v)),\n            Some((_, v2, m)) => {\n                let out_v = f(&k, &v2, v);\n                (Some(v2), m.update(k, out_v))\n            }\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::update_with":["/// Construct a new hash map by inserting a key/value mapping into\n/// a map.\n///\n/// If the map already has a mapping for the given key, we call\n/// the provided function with the old value and the new value,\n/// and insert the result as the new value.\n///\n/// Time: O(log n)\n#[must_use]\npub fn update_with<F>(&self, k: K, v: V, f: F) -> Self\n    where\n        F: FnOnce(V, V) -> V,{\n        match self.extract_with_key(&k) {\n            None => self.update(k, v),\n            Some((_, v2, m)) => m.update(k, f(v2, v)),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::update_with_key":["/// Construct a new map by inserting a key/value mapping into a\n/// map.\n///\n/// If the map already has a mapping for the given key, we call\n/// the provided function with the key, the old value and the new\n/// value, and insert the result as the new value.\n///\n/// Time: O(log n)\n#[must_use]\npub fn update_with_key<F>(&self, k: K, v: V, f: F) -> Self\n    where\n        F: FnOnce(&K, V, V) -> V,{\n        match self.extract_with_key(&k) {\n            None => self.update(k, v),\n            Some((_, v2, m)) => {\n                let out_v = f(&k, v2, v);\n                m.update(k, out_v)\n            }\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::values":["/// Get an iterator over a hash map's values.\n///\n/// Please note that the order is consistent between maps using\n/// the same hasher, but no other ordering guarantee is offered.\n/// Items will not come out in insertion order or sort order.\n/// They will, however, come out in the same order every time for\n/// the same map.\n#[inline]\n#[must_use]\npub fn values(&self) -> Values<'_, K, V>{\n        Values {\n            it: NodeIter::new(&self.root, self.size),\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::with_hasher":["/// Construct an empty hash map using the provided hasher.\n#[inline]\n#[must_use]\npub fn with_hasher<RS>(hasher: RS) -> Self\n    where\n        Ref<S>: From<RS>,{\n        let pool = HashMapPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashMap {\n            size: 0,\n            hasher: hasher.into(),\n            pool,\n            root,\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V, S>::without":["/// Construct a new map without the given key.\n///\n/// Construct a map that's a copy of the current map, absent the\n/// mapping for `key` if it's present.\n///\n/// Time: O(log n)\n#[must_use]\npub fn without<BK>(&self, k: &BK) -> Self\n    where\n        BK: Hash + Eq + ?Sized,\n        K: Borrow<BK>,{\n        match self.extract_with_key(k) {\n            None => self.clone(),\n            Some((_, _, map)) => map,\n        }\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V>::new":["/// Construct an empty hash map.\n#[inline]\n#[must_use]\npub fn new() -> Self{\n        Self::default()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMap::<K, V>::unit":["/// Construct a hash map with a single mapping.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashmap::HashMap;\n/// let map = HashMap::unit(123, \"onetwothree\");\n/// assert_eq!(\n///   map.get(&123),\n///   Some(&\"onetwothree\")\n/// );\n/// ```\n#[inline]\n#[must_use]\npub fn unit(k: K, v: V) -> HashMap<K, V>{\n        HashMap::new().update(k, v)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::HashMapPool":["/// A memory pool for the appropriate node type.\npub struct $name<$($arg,)*>(Pool<$pooltype>);","Real(LocalPath(\"src/util.rs\"))"],"hash::map::HashMapPool::<K, V>::fill":["/// Fill the pool with preallocated chunks.\npub fn fill(&self){\n                self.0.fill();\n            }","Real(LocalPath(\"src/util.rs\"))"],"hash::map::HashMapPool::<K, V>::new":["/// Create a new pool with the given size.\npub fn new(size: usize) -> Self{\n                Self(Pool::new(size))\n            }","Real(LocalPath(\"src/util.rs\"))"],"hash::map::HashMapPool::<K, V>::pool_size":["///Get the current size of the pool.\npub fn pool_size(&self) -> usize{\n                self.0.get_pool_size()\n            }","Real(LocalPath(\"src/util.rs\"))"],"hash::map::Iter":["/// An iterator over the elements of a map.\npub struct Iter<'a, K, V> {\n    it: NodeIter<'a, (K, V)>,\n}","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::IterMut":["/// A mutable iterator over the elements of a map.\npub struct IterMut<'a, K, V>\nwhere\n    K: Clone,\n    V: Clone,\n{\n    it: NodeIterMut<'a, (K, V)>,\n}","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::Keys":["/// An iterator over the keys of a map.\npub struct Keys<'a, K, V> {\n    it: NodeIter<'a, (K, V)>,\n}","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::OccupiedEntry":["/// An entry for a mapping that already exists in the map.\npub struct OccupiedEntry<'a, K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher,\n{\n    map: &'a mut HashMap<K, V, S>,\n    hash: HashBits,\n    key: K,\n}","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::OccupiedEntry::<'a, K, V, S>::get":["/// Get the current value.\n#[must_use]\npub fn get(&self) -> &V{\n        &self.map.root.get(self.hash, 0, &self.key).unwrap().1\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::OccupiedEntry::<'a, K, V, S>::get_mut":["/// Get a mutable reference to the current value.\n#[must_use]\npub fn get_mut(&mut self) -> &mut V{\n        let root = PoolRef::make_mut(&self.map.pool.0, &mut self.map.root);\n        &mut root\n            .get_mut(&self.map.pool.0, self.hash, 0, &self.key)\n            .unwrap()\n            .1\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::OccupiedEntry::<'a, K, V, S>::insert":["/// Overwrite the current value.\npub fn insert(&mut self, value: V) -> V{\n        mem::replace(self.get_mut(), value)\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::OccupiedEntry::<'a, K, V, S>::into_mut":["/// Convert this entry into a mutable reference.\n#[must_use]\npub fn into_mut(self) -> &'a mut V{\n        let root = PoolRef::make_mut(&self.map.pool.0, &mut self.map.root);\n        &mut root\n            .get_mut(&self.map.pool.0, self.hash, 0, &self.key)\n            .unwrap()\n            .1\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::OccupiedEntry::<'a, K, V, S>::key":["/// Get the key for this entry.\n#[must_use]\npub fn key(&self) -> &K{\n        &self.key\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::OccupiedEntry::<'a, K, V, S>::remove":["/// Remove this entry from the map and return the removed value.\npub fn remove(self) -> V{\n        self.remove_entry().1\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::OccupiedEntry::<'a, K, V, S>::remove_entry":["/// Remove this entry from the map and return the removed mapping.\npub fn remove_entry(self) -> (K, V){\n        let root = PoolRef::make_mut(&self.map.pool.0, &mut self.map.root);\n        let result = root.remove(&self.map.pool.0, self.hash, 0, &self.key);\n        self.map.size -= 1;\n        result.unwrap()\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::VacantEntry":["/// An entry for a mapping that does not already exist in the map.\npub struct VacantEntry<'a, K, V, S>\nwhere\n    K: Hash + Eq + Clone,\n    V: Clone,\n    S: BuildHasher,\n{\n    map: &'a mut HashMap<K, V, S>,\n    hash: HashBits,\n    key: K,\n}","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::VacantEntry::<'a, K, V, S>::insert":["/// Insert a value into this entry.\npub fn insert(self, value: V) -> &'a mut V{\n        let root = PoolRef::make_mut(&self.map.pool.0, &mut self.map.root);\n        if root\n            .insert(&self.map.pool.0, self.hash, 0, (self.key.clone(), value))\n            .is_none()\n        {\n            self.map.size += 1;\n        }\n        // TODO it's unfortunate that we need to look up the key again\n        // here to get the mut ref.\n        &mut root\n            .get_mut(&self.map.pool.0, self.hash, 0, &self.key)\n            .unwrap()\n            .1\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::VacantEntry::<'a, K, V, S>::into_key":["/// Convert this entry into its key.\n#[must_use]\npub fn into_key(self) -> K{\n        self.key\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::VacantEntry::<'a, K, V, S>::key":["/// Get the key for this entry.\n#[must_use]\npub fn key(&self) -> &K{\n        &self.key\n    }","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::map::Values":["/// An iterator over the values of a map.\npub struct Values<'a, K, V> {\n    it: NodeIter<'a, (K, V)>,\n}","Real(LocalPath(\"src/hash/map.rs\"))"],"hash::set::ConsumingIter":["/// A consuming iterator over the elements of a set.\npub struct ConsumingIter<A>\nwhere\n    A: Hash + Eq + Clone,\n{\n    it: NodeDrain<Value<A>>,\n}","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet":["/// An unordered set.\n///\n/// An immutable hash set using [hash array mapped tries] [1].\n///\n/// Most operations on this set are O(log<sub>x</sub> n) for a\n/// suitably high *x* that it should be nearly O(1) for most sets.\n/// Because of this, it's a great choice for a generic set as long as\n/// you don't mind that values will need to implement\n/// [`Hash`][std::hash::Hash] and [`Eq`][std::cmp::Eq].\n///\n/// Values will have a predictable order based on the hasher\n/// being used. Unless otherwise specified, this will be the standard\n/// [`RandomState`][std::collections::hash_map::RandomState] hasher.\n///\n/// [1]: https://en.wikipedia.org/wiki/Hash_array_mapped_trie\n/// [std::cmp::Eq]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [std::hash::Hash]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n/// [std::collections::hash_map::RandomState]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\npub struct HashSet<A, S = RandomState> {\n    hasher: Ref<S>,\n    pool: HashSetPool<A>,\n    root: PoolRef<Node<Value<A>>>,\n    size: usize,\n}","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::clear":["/// Discard all elements from the set.\n///\n/// This leaves you with an empty set, and all elements that\n/// were previously inside it are dropped.\n///\n/// Time: O(n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::HashSet;\n/// let mut set = hashset![1, 2, 3];\n/// set.clear();\n/// assert!(set.is_empty());\n/// ```\npub fn clear(&mut self){\n        if !self.is_empty() {\n            self.root = PoolRef::default(&self.pool.0);\n            self.size = 0;\n        }\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::contains":["/// Test if a value is part of a set.\n///\n/// Time: O(log n)\n#[must_use]\npub fn contains<BA>(&self, a: &BA) -> bool\n    where\n        BA: Hash + Eq + ?Sized,\n        A: Borrow<BA>,{\n        self.root.get(hash_key(&*self.hasher, a), 0, a).is_some()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::difference":["/// Construct the symmetric difference between two sets.\n///\n/// This is an alias for the\n/// [`symmetric_difference`][symmetric_difference] method.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashset::HashSet;\n/// let set1 = hashset!{1, 2};\n/// let set2 = hashset!{2, 3};\n/// let expected = hashset!{1, 3};\n/// assert_eq!(expected, set1.difference(set2));\n/// ```\n///\n/// [symmetric_difference]: #method.symmetric_difference\n#[must_use]\npub fn difference(self, other: Self) -> Self{\n        self.symmetric_difference(other)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::hasher":["/// Get a reference to the set's [`BuildHasher`][BuildHasher].\n///\n/// [BuildHasher]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n#[must_use]\npub fn hasher(&self) -> &Ref<S>{\n        &self.hasher\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::insert":["/// Insert a value into a set.\n///\n/// Time: O(log n)\n#[inline]\npub fn insert(&mut self, a: A) -> Option<A>{\n        let hash = hash_key(&*self.hasher, &a);\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        match root.insert(&self.pool.0, hash, 0, Value(a)) {\n            None => {\n                self.size += 1;\n                None\n            }\n            Some(Value(old_value)) => Some(old_value),\n        }\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::intersection":["/// Construct the intersection of two sets.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashset::HashSet;\n/// let set1 = hashset!{1, 2};\n/// let set2 = hashset!{2, 3};\n/// let expected = hashset!{2};\n/// assert_eq!(expected, set1.intersection(set2));\n/// ```\n#[must_use]\npub fn intersection(self, other: Self) -> Self{\n        let mut out = self.new_from();\n        for value in other {\n            if self.contains(&value) {\n                out.insert(value);\n            }\n        }\n        out\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::is_empty":["/// Test whether a set is empty.\n///\n/// Time: O(1)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashset::HashSet;\n/// assert!(\n///   !hashset![1, 2, 3].is_empty()\n/// );\n/// assert!(\n///   HashSet::<i32>::new().is_empty()\n/// );\n/// ```\n#[inline]\n#[must_use]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::is_proper_subset":["/// Test whether a set is a proper subset of another set, meaning\n/// that all values in our set must also be in the other set. A\n/// proper subset must also be smaller than the other set.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn is_proper_subset<RS>(&self, other: RS) -> bool\n    where\n        RS: Borrow<Self>,{\n        self.len() != other.borrow().len() && self.is_subset(other)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::is_subset":["/// Test whether a set is a subset of another set, meaning that\n/// all values in our set must also be in the other set.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn is_subset<RS>(&self, other: RS) -> bool\n    where\n        RS: Borrow<Self>,{\n        let o = other.borrow();\n        self.iter().all(|a| o.contains(&a))\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::iter":["/// Get an iterator over the values in a hash set.\n///\n/// Please note that the order is consistent between sets using\n/// the same hasher, but no other ordering guarantee is offered.\n/// Items will not come out in insertion order or sort order.\n/// They will, however, come out in the same order every time for\n/// the same set.\n#[must_use]\npub fn iter(&self) -> Iter<'_, A>{\n        Iter {\n            it: NodeIter::new(&self.root, self.size),\n        }\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::len":["/// Get the size of a set.\n///\n/// Time: O(1)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashset::HashSet;\n/// assert_eq!(3, hashset![1, 2, 3].len());\n/// ```\n#[inline]\n#[must_use]\npub fn len(&self) -> usize{\n        self.size\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::new_from":["/// Construct an empty hash set using the same hasher as the current hash set.\n#[inline]\n#[must_use]\npub fn new_from<A1>(&self) -> HashSet<A1, S>\n    where\n        A1: Hash + Eq + Clone,{\n        let pool = HashSetPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashSet {\n            size: 0,\n            pool,\n            root,\n            hasher: self.hasher.clone(),\n        }\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::ptr_eq":["/// Test whether two sets refer to the same content in memory.\n///\n/// This is true if the two sides are references to the same set,\n/// or if the two sets refer to the same root node.\n///\n/// This would return true if you're comparing a set to itself, or\n/// if you're comparing a set to a fresh clone of itself.\n///\n/// Time: O(1)\npub fn ptr_eq(&self, other: &Self) -> bool{\n        std::ptr::eq(self, other) || PoolRef::ptr_eq(&self.root, &other.root)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::relative_complement":["/// Construct the relative complement between two sets, that is the set\n/// of values in `self` that do not occur in `other`.\n///\n/// Time: O(m log n) where m is the size of the other set\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// let set1 = ordset!{1, 2};\n/// let set2 = ordset!{2, 3};\n/// let expected = ordset!{1};\n/// assert_eq!(expected, set1.relative_complement(set2));\n/// ```\n#[must_use]\npub fn relative_complement(mut self, other: Self) -> Self{\n        for value in other {\n            let _ = self.remove(&value);\n        }\n        self\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::remove":["/// Remove a value from a set if it exists.\n///\n/// Time: O(log n)\npub fn remove<BA>(&mut self, a: &BA) -> Option<A>\n    where\n        BA: Hash + Eq + ?Sized,\n        A: Borrow<BA>,{\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        let result = root.remove(&self.pool.0, hash_key(&*self.hasher, a), 0, a);\n        if result.is_some() {\n            self.size -= 1;\n        }\n        result.map(|v| v.0)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::retain":["/// Filter out values from a set which don't satisfy a predicate.\n///\n/// This is slightly more efficient than filtering using an\n/// iterator, in that it doesn't need to rehash the retained\n/// values, but it still needs to reconstruct the entire tree\n/// structure of the set.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::HashSet;\n/// let mut set = hashset![1, 2, 3];\n/// set.retain(|v| *v > 1);\n/// let expected = hashset![2, 3];\n/// assert_eq!(expected, set);\n/// ```\npub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&A) -> bool,{\n        let old_root = self.root.clone();\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        for (value, hash) in NodeIter::new(&old_root, self.size) {\n            if !f(value) && root.remove(&self.pool.0, hash, 0, value).is_some() {\n                self.size -= 1;\n            }\n        }\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::symmetric_difference":["/// Construct the symmetric difference between two sets.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashset::HashSet;\n/// let set1 = hashset!{1, 2};\n/// let set2 = hashset!{2, 3};\n/// let expected = hashset!{1, 3};\n/// assert_eq!(expected, set1.symmetric_difference(set2));\n/// ```\n#[must_use]\npub fn symmetric_difference(mut self, other: Self) -> Self{\n        for value in other {\n            if self.remove(&value).is_none() {\n                self.insert(value);\n            }\n        }\n        self\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::test_eq":["fn test_eq(&self, other: &Self) -> bool{\n        if self.len() != other.len() {\n            return false;\n        }\n        let mut seen = collections::HashSet::new();\n        for value in self.iter() {\n            if !other.contains(&value) {\n                return false;\n            }\n            seen.insert(value);\n        }\n        for value in other.iter() {\n            if !seen.contains(&value) {\n                return false;\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::union":["/// Construct the union of two sets.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashset::HashSet;\n/// let set1 = hashset!{1, 2};\n/// let set2 = hashset!{2, 3};\n/// let expected = hashset!{1, 2, 3};\n/// assert_eq!(expected, set1.union(set2));\n/// ```\n#[must_use]\npub fn union(mut self, other: Self) -> Self{\n        for value in other {\n            self.insert(value);\n        }\n        self\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::unions":["/// Construct the union of multiple sets.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn unions<I>(i: I) -> Self\n    where\n        I: IntoIterator<Item = Self>,\n        S: Default,{\n        i.into_iter().fold(Self::default(), Self::union)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::update":["/// Construct a new set from the current set with the given value\n/// added.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashset::HashSet;\n/// # use std::sync::Arc;\n/// let set = hashset![123];\n/// assert_eq!(\n///   set.update(456),\n///   hashset![123, 456]\n/// );\n/// ```\n#[must_use]\npub fn update(&self, a: A) -> Self{\n        let mut out = self.clone();\n        out.insert(a);\n        out\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::with_hasher":["/// Construct an empty hash set using the provided hasher.\n#[inline]\n#[must_use]\npub fn with_hasher<RS>(hasher: RS) -> Self\n    where\n        Ref<S>: From<RS>,{\n        let pool = HashSetPool::default();\n        let root = PoolRef::default(&pool.0);\n        HashSet {\n            size: 0,\n            pool,\n            root,\n            hasher: From::from(hasher),\n        }\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A, S>::without":["/// Construct a new set with the given value removed if it's in\n/// the set.\n///\n/// Time: O(log n)\n#[must_use]\npub fn without<BA>(&self, a: &BA) -> Self\n    where\n        BA: Hash + Eq + ?Sized,\n        A: Borrow<BA>,{\n        let mut out = self.clone();\n        out.remove(a);\n        out\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A>::new":["/// Construct an empty set.\n#[must_use]\npub fn new() -> Self{\n        Self::default()\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSet::<A>::unit":["/// Construct a set with a single value.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::hashset::HashSet;\n/// # use std::sync::Arc;\n/// let set = HashSet::unit(123);\n/// assert!(set.contains(&123));\n/// ```\n#[inline]\n#[must_use]\npub fn unit(a: A) -> Self{\n        HashSet::new().update(a)\n    }","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::HashSetPool":["/// A memory pool for the appropriate node type.\npub struct $name<$($arg,)*>(Pool<$pooltype>);","Real(LocalPath(\"src/util.rs\"))"],"hash::set::HashSetPool::<A>::fill":["/// Fill the pool with preallocated chunks.\npub fn fill(&self){\n                self.0.fill();\n            }","Real(LocalPath(\"src/util.rs\"))"],"hash::set::HashSetPool::<A>::new":["/// Create a new pool with the given size.\npub fn new(size: usize) -> Self{\n                Self(Pool::new(size))\n            }","Real(LocalPath(\"src/util.rs\"))"],"hash::set::HashSetPool::<A>::pool_size":["///Get the current size of the pool.\npub fn pool_size(&self) -> usize{\n                self.0.get_pool_size()\n            }","Real(LocalPath(\"src/util.rs\"))"],"hash::set::Iter":["/// An iterator over the elements of a set.\npub struct Iter<'a, A> {\n    it: NodeIter<'a, Value<A>>,\n}","Real(LocalPath(\"src/hash/set.rs\"))"],"hash::set::Value":["struct Value<A>(A);","Real(LocalPath(\"src/hash/set.rs\"))"],"iter::unfold":["/// Create an iterator of values using a function to update an owned state\n/// value.\n///\n/// The function is called with the current state as its argument, and should\n/// return an [`Option`][std::option::Option] of a tuple of the next value to\n/// yield from the iterator and the updated state. If the function returns\n/// [`None`][std::option::Option::None], the iterator ends.\n///\n/// # Examples\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::iter::unfold;\n/// # use im::vector::Vector;\n/// # use std::iter::FromIterator;\n/// // Create an infinite stream of numbers, starting at 0.\n/// let mut it = unfold(0, |i| Some((i, i + 1)));\n///\n/// // Make a list out of its first five elements.\n/// let numbers = Vector::from_iter(it.take(5));\n/// assert_eq!(numbers, vector![0, 1, 2, 3, 4]);\n/// ```\n///\n/// [std::option::Option]: https://doc.rust-lang.org/std/option/enum.Option.html\n/// [std::option::Option::None]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\npub fn unfold<F, S, A>(value: S, f: F) -> impl Iterator<Item = A>\nwhere\n    F: Fn(S) -> Option<(A, S)>,{\n    let mut value = Some(value);\n    std::iter::from_fn(move || {\n        f(value.take().unwrap()).map(|(next, state)| {\n            value = Some(state);\n            next\n        })\n    })\n}","Real(LocalPath(\"src/iter.rs\"))"],"nodes::btree::BTreeValue":["pub trait BTreeValue {\n    type Key;\n    fn ptr_eq(&self, other: &Self) -> bool;\n    fn search_key<BK>(slice: &[Self], key: &BK) -> Result<usize, usize>\n    where\n        BK: Ord + ?Sized,\n        Self: Sized,\n        Self::Key: Borrow<BK>;\n    fn search_value(slice: &[Self], value: &Self) -> Result<usize, usize>\n    where\n        Self: Sized;\n    fn cmp_keys<BK>(&self, other: &BK) -> Ordering\n    where\n        BK: Ord + ?Sized,\n        Self::Key: Borrow<BK>;\n    fn cmp_values(&self, other: &Self) -> Ordering;\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::ConsumingIter":["/// A consuming iterator over an ordered set.\npub struct ConsumingIter<A> {\n    fwd_last: Option<A>,\n    fwd_stack: Vec<ConsumingIterItem<A>>,\n    back_last: Option<A>,\n    back_stack: Vec<ConsumingIterItem<A>>,\n    remaining: usize,\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::ConsumingIter::<A>::new":["pub(crate) fn new(root: &Node<A>, total: usize) -> Self{\n        ConsumingIter {\n            fwd_last: None,\n            fwd_stack: vec![ConsumingIterItem::Consider(root.clone())],\n            back_last: None,\n            back_stack: vec![ConsumingIterItem::Consider(root.clone())],\n            remaining: total,\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::ConsumingIter::<A>::push":["fn push(stack: &mut Vec<ConsumingIterItem<A>>, mut node: Node<A>){\n        for _n in 0..node.keys.len() {\n            ConsumingIter::push_node(stack, node.children.pop_back());\n            stack.push(ConsumingIterItem::Yield(node.keys.pop_back()));\n        }\n        ConsumingIter::push_node(stack, node.children.pop_back());\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::ConsumingIter::<A>::push_back":["fn push_back(&mut self, mut node: Node<A>){\n        for _i in 0..node.keys.len() {\n            self.push_node_back(node.children.pop_front());\n            self.back_stack\n                .push(ConsumingIterItem::Yield(node.keys.pop_front()));\n        }\n        self.push_node_back(node.children.pop_back());\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::ConsumingIter::<A>::push_fwd":["fn push_fwd(&mut self, node: Node<A>){\n        ConsumingIter::push(&mut self.fwd_stack, node)\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::ConsumingIter::<A>::push_node":["fn push_node(stack: &mut Vec<ConsumingIterItem<A>>, maybe_node: Option<PoolRef<Node<A>>>){\n        if let Some(node) = maybe_node {\n            stack.push(ConsumingIterItem::Consider(PoolRef::unwrap_or_clone(node)))\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::ConsumingIter::<A>::push_node_back":["fn push_node_back(&mut self, maybe_node: Option<PoolRef<Node<A>>>){\n        if let Some(node) = maybe_node {\n            self.back_stack\n                .push(ConsumingIterItem::Consider(PoolRef::unwrap_or_clone(node)))\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::ConsumingIterItem":["enum ConsumingIterItem<A> {\n    Consider(Node<A>),\n    Yield(A),\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::DiffItem":["/// A description of a difference between two ordered sets.\npub enum DiffItem<'a, A> {\n    /// This value has been added to the new set.\n    Add(&'a A),\n    /// This value has been changed between the two sets.\n    Update {\n        /// The old value.\n        old: &'a A,\n        /// The new value.\n        new: &'a A,\n    },\n    /// This value has been removed from the new set.\n    Remove(&'a A),\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::DiffIter":["/// An iterator over the differences between two ordered sets.\npub struct DiffIter<'a, A> {\n    old_stack: Vec<IterItem<'a, A>>,\n    new_stack: Vec<IterItem<'a, A>>,\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::DiffIter::<'a, A>::new":["pub(crate) fn new(old: &'a Node<A>, new: &'a Node<A>) -> Self{\n        DiffIter {\n            old_stack: if old.keys.is_empty() {\n                Vec::new()\n            } else {\n                vec![IterItem::Consider(old)]\n            },\n            new_stack: if new.keys.is_empty() {\n                Vec::new()\n            } else {\n                vec![IterItem::Consider(new)]\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::DiffIter::<'a, A>::push":["fn push(stack: &mut Vec<IterItem<'a, A>>, node: &'a Node<A>){\n        for n in 0..node.keys.len() {\n            let i = node.keys.len() - n;\n            Self::push_node(stack, &node.children[i]);\n            stack.push(IterItem::Yield(&node.keys[i - 1]));\n        }\n        Self::push_node(stack, &node.children[0]);\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::DiffIter::<'a, A>::push_node":["fn push_node(stack: &mut Vec<IterItem<'a, A>>, maybe_node: &'a Option<PoolRef<Node<A>>>){\n        if let Some(ref node) = *maybe_node {\n            stack.push(IterItem::Consider(&node))\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Insert":["pub(crate) enum Insert<A> {\n    Added,\n    Replaced(A),\n    Split(Node<A>, A, Node<A>),\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::InsertAction":["enum InsertAction<A> {\n    AddedAction,\n    ReplacedAction(A),\n    InsertAt,\n    InsertSplit(Node<A>, A, Node<A>),\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Iter":["/// An iterator over an ordered set.\npub struct Iter<'a, A> {\n    fwd_path: Vec<(&'a Node<A>, usize)>,\n    back_path: Vec<(&'a Node<A>, usize)>,\n    pub(crate) remaining: usize,\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Iter::<'a, A>::get":["fn get(path: &[(&'a Node<A>, usize)]) -> Option<&'a A>{\n        match path.last() {\n            Some((node, index)) => Some(&node.keys[*index]),\n            None => None,\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Iter::<'a, A>::new":["pub(crate) fn new<R, BK>(root: &'a Node<A>, size: usize, range: R) -> Self\n    where\n        R: RangeBounds<BK>,\n        A::Key: Borrow<BK>,\n        BK: Ord + ?Sized,{\n        let fwd_path = match range.start_bound() {\n            Bound::Included(key) => root.path_next(key, Vec::new()),\n            Bound::Excluded(key) => {\n                let mut path = root.path_next(key, Vec::new());\n                if let Some(value) = Self::get(&path) {\n                    if value.cmp_keys(key) == Ordering::Equal {\n                        Self::step_forward(&mut path);\n                    }\n                }\n                path\n            }\n            Bound::Unbounded => root.path_first(Vec::new()),\n        };\n        let back_path = match range.end_bound() {\n            Bound::Included(key) => root.path_prev(key, Vec::new()),\n            Bound::Excluded(key) => {\n                let mut path = root.path_prev(key, Vec::new());\n                if let Some(value) = Self::get(&path) {\n                    if value.cmp_keys(key) == Ordering::Equal {\n                        Self::step_back(&mut path);\n                    }\n                }\n                path\n            }\n            Bound::Unbounded => root.path_last(Vec::new()),\n        };\n        Iter {\n            fwd_path,\n            back_path,\n            remaining: size,\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Iter::<'a, A>::step_back":["fn step_back(path: &mut Vec<(&'a Node<A>, usize)>) -> Option<&'a A>{\n        match path.pop() {\n            Some((node, index)) => match node.children[index] {\n                Some(ref child) => {\n                    path.push((node, index));\n                    let mut end = child.keys.len() - 1;\n                    path.push((child, end));\n                    let mut node = child;\n                    while let Some(ref right_child) = node.children[end + 1] {\n                        end = right_child.keys.len() - 1;\n                        path.push((right_child, end));\n                        node = right_child;\n                    }\n                    Some(&node.keys[end])\n                }\n                None => {\n                    if index == 0 {\n                        loop {\n                            match path.pop() {\n                                None => {\n                                    return None;\n                                }\n                                Some((node, index)) => {\n                                    if index > 0 {\n                                        let index = index - 1;\n                                        path.push((node, index));\n                                        return Some(&node.keys[index]);\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        let index = index - 1;\n                        path.push((node, index));\n                        Some(&node.keys[index])\n                    }\n                }\n            },\n            None => None,\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Iter::<'a, A>::step_forward":["fn step_forward(path: &mut Vec<(&'a Node<A>, usize)>) -> Option<&'a A>{\n        match path.pop() {\n            Some((node, index)) => {\n                let index = index + 1;\n                match node.children[index] {\n                    // Child between current and next key -> step down\n                    Some(ref child) => {\n                        path.push((node, index));\n                        path.push((child, 0));\n                        let mut node = child;\n                        while let Some(ref left_child) = node.children[0] {\n                            path.push((left_child, 0));\n                            node = left_child;\n                        }\n                        Some(&node.keys[0])\n                    }\n                    None => match node.keys.get(index) {\n                        // Yield next key\n                        value @ Some(_) => {\n                            path.push((node, index));\n                            value\n                        }\n                        // No more keys -> exhausted level, step up and yield\n                        None => loop {\n                            match path.pop() {\n                                None => {\n                                    return None;\n                                }\n                                Some((node, index)) => {\n                                    if let value @ Some(_) = node.keys.get(index) {\n                                        path.push((node, index));\n                                        return value;\n                                    }\n                                }\n                            }\n                        },\n                    },\n                }\n            }\n            None => None,\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::IterItem":["enum IterItem<'a, A> {\n    Consider(&'a Node<A>),\n    Yield(&'a A),\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node":["pub(crate) struct Node<A> {\n    keys: Chunk<A, NodeSize>,\n    children: Chunk<Option<PoolRef<Node<A>>>, Add1<NodeSize>>,\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::child_contains":["fn child_contains<BK>(&self, index: usize, key: &BK) -> bool\n    where\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        if let Some(Some(ref child)) = self.children.get(index) {\n            child.lookup(key).is_some()\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::has_room":["#[inline]\nfn has_room(&self) -> bool{\n        self.keys.len() < NODE_SIZE\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::insert":["pub(crate) fn insert(&mut self, pool: &Pool<Node<A>>, value: A) -> Insert<A>\n    where\n        A: Clone,{\n        if self.keys.is_empty() {\n            self.keys.push_back(value);\n            self.children.push_back(None);\n            return Insert::Added;\n        }\n        let (median, left, right) = match A::search_value(&self.keys, &value) {\n            // Key exists in node\n            Ok(index) => {\n                return Insert::Replaced(mem::replace(&mut self.keys[index], value));\n            }\n            // Key is adjacent to some key in node\n            Err(index) => {\n                let has_room = self.has_room();\n                let action = match self.children[index] {\n                    // No child at location, this is the target node.\n                    None => InsertAt,\n                    // Child at location, pass it on.\n                    Some(ref mut child_ref) => {\n                        let child = PoolRef::make_mut(pool, child_ref);\n                        match child.insert(pool, value.clone()) {\n                            Insert::Added => AddedAction,\n                            Insert::Replaced(value) => ReplacedAction(value),\n                            Insert::Split(left, median, right) => InsertSplit(left, median, right),\n                        }\n                    }\n                };\n                match action {\n                    ReplacedAction(value) => return Insert::Replaced(value),\n                    AddedAction => {\n                        return Insert::Added;\n                    }\n                    InsertAt => {\n                        if has_room {\n                            self.keys.insert(index, value);\n                            self.children.insert(index + 1, None);\n                            return Insert::Added;\n                        } else {\n                            (value, None, None)\n                        }\n                    }\n                    InsertSplit(left, median, right) => {\n                        if has_room {\n                            self.children[index] = Some(PoolRef::new(pool, left));\n                            self.keys.insert(index, median);\n                            self.children\n                                .insert(index + 1, Some(PoolRef::new(pool, right)));\n                            return Insert::Added;\n                        } else {\n                            (median, Some(left), Some(right))\n                        }\n                    }\n                }\n            }\n        };\n        self.split(pool, median, left, right)\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::is_leaf":["#[inline]\nfn is_leaf(&self) -> bool{\n        self.children[0].is_none()\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::lookup":["pub(crate) fn lookup<BK>(&self, key: &BK) -> Option<&A>\n    where\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        if self.keys.is_empty() {\n            return None;\n        }\n        // Perform a binary search, resulting in either a match or\n        // the index of the first higher key, meaning we search the\n        // child to the left of it.\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&self.keys[index]),\n            Err(index) => match self.children[index] {\n                None => None,\n                Some(ref node) => node.lookup(key),\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::lookup_mut":["pub(crate) fn lookup_mut<BK>(&mut self, pool: &Pool<Node<A>>, key: &BK) -> Option<&mut A>\n    where\n        A: Clone,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        if self.keys.is_empty() {\n            return None;\n        }\n        // Perform a binary search, resulting in either a match or\n        // the index of the first higher key, meaning we search the\n        // child to the left of it.\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&mut self.keys[index]),\n            Err(index) => match self.children[index] {\n                None => None,\n                Some(ref mut child_ref) => {\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    child.lookup_mut(pool, key)\n                }\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::lookup_next":["pub(crate) fn lookup_next<'a, BK>(&'a self, key: &BK) -> Option<&A>\n    where\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        if self.keys.is_empty() {\n            return None;\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&self.keys[index]),\n            Err(index) => match self.children[index] {\n                None => match self.keys.get(index) {\n                    Some(_) => Some(&self.keys[index]),\n                    None => None,\n                },\n                Some(ref node) => node.lookup_next(key),\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::lookup_next_mut":["pub(crate) fn lookup_next_mut<'a, BK>(\n        &'a mut self,\n        pool: &Pool<Node<A>>,\n        key: &BK,\n    ) -> Option<&mut A>\n    where\n        A: Clone,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        if self.keys.is_empty() {\n            return None;\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&mut self.keys[index]),\n            Err(index) => match self.children[index] {\n                None => match self.keys.get(index) {\n                    Some(_) => Some(&mut self.keys[index]),\n                    None => None,\n                },\n                Some(ref mut node) => PoolRef::make_mut(pool, node).lookup_next_mut(pool, key),\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::lookup_prev":["pub(crate) fn lookup_prev<'a, BK>(&'a self, key: &BK) -> Option<&A>\n    where\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        if self.keys.is_empty() {\n            return None;\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&self.keys[index]),\n            Err(index) => match self.children[index] {\n                None if index == 0 => None,\n                None => match self.keys.get(index - 1) {\n                    Some(_) => Some(&self.keys[index - 1]),\n                    None => None,\n                },\n                Some(ref node) => node.lookup_prev(key),\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::lookup_prev_mut":["pub(crate) fn lookup_prev_mut<'a, BK>(\n        &'a mut self,\n        pool: &Pool<Node<A>>,\n        key: &BK,\n    ) -> Option<&mut A>\n    where\n        A: Clone,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        if self.keys.is_empty() {\n            return None;\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => Some(&mut self.keys[index]),\n            Err(index) => match self.children[index] {\n                None if index == 0 => None,\n                None => match self.keys.get(index - 1) {\n                    Some(_) => Some(&mut self.keys[index - 1]),\n                    None => None,\n                },\n                Some(ref mut node) => PoolRef::make_mut(pool, node).lookup_prev_mut(pool, key),\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::max":["pub(crate) fn max(&self) -> Option<&A>{\n        match self.children.last().unwrap() {\n            None => self.keys.last(),\n            Some(ref child) => child.max(),\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::merge":["fn merge(middle: A, left: Node<A>, mut right: Node<A>) -> Node<A>{\n        let mut keys = left.keys;\n        keys.push_back(middle);\n        keys.append(&mut right.keys);\n        let mut children = left.children;\n        children.append(&mut right.children);\n        Node { keys, children }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::min":["pub(crate) fn min(&self) -> Option<&A>{\n        match self.children.first().unwrap() {\n            None => self.keys.first(),\n            Some(ref child) => child.min(),\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::new_from_split":["#[inline]\npub(crate) fn new_from_split(\n        pool: &Pool<Node<A>>,\n        left: Node<A>,\n        median: A,\n        right: Node<A>,\n    ) -> Self{\n        Node {\n            keys: Chunk::unit(median),\n            children: Chunk::pair(\n                Some(PoolRef::new(pool, left)),\n                Some(PoolRef::new(pool, right)),\n            ),\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::path_first":["pub(crate) fn path_first<'a, BK>(\n        &'a self,\n        mut path: Vec<(&'a Node<A>, usize)>,\n    ) -> Vec<(&'a Node<A>, usize)>\n    where\n        A: 'a,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        if self.keys.is_empty() {\n            return Vec::new();\n        }\n        match self.children[0] {\n            None => {\n                path.push((self, 0));\n                path\n            }\n            Some(ref node) => {\n                path.push((self, 0));\n                node.path_first(path)\n            }\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::path_last":["pub(crate) fn path_last<'a, BK>(\n        &'a self,\n        mut path: Vec<(&'a Node<A>, usize)>,\n    ) -> Vec<(&'a Node<A>, usize)>\n    where\n        A: 'a,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        if self.keys.is_empty() {\n            return Vec::new();\n        }\n        let end = self.children.len() - 1;\n        match self.children[end] {\n            None => {\n                path.push((self, end - 1));\n                path\n            }\n            Some(ref node) => {\n                path.push((self, end));\n                node.path_last(path)\n            }\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::path_next":["pub(crate) fn path_next<'a, BK>(\n        &'a self,\n        key: &BK,\n        mut path: Vec<(&'a Node<A>, usize)>,\n    ) -> Vec<(&'a Node<A>, usize)>\n    where\n        A: 'a,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        if self.keys.is_empty() {\n            return Vec::new();\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => {\n                path.push((self, index));\n                path\n            }\n            Err(index) => match self.children[index] {\n                None => match self.keys.get(index) {\n                    Some(_) => {\n                        path.push((self, index));\n                        path\n                    }\n                    None => Vec::new(),\n                },\n                Some(ref node) => {\n                    path.push((self, index));\n                    node.path_next(key, path)\n                }\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::path_prev":["pub(crate) fn path_prev<'a, BK>(\n        &'a self,\n        key: &BK,\n        mut path: Vec<(&'a Node<A>, usize)>,\n    ) -> Vec<(&'a Node<A>, usize)>\n    where\n        A: 'a,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        if self.keys.is_empty() {\n            return Vec::new();\n        }\n        match A::search_key(&self.keys, key) {\n            Ok(index) => {\n                path.push((self, index));\n                path\n            }\n            Err(index) => match self.children[index] {\n                None if index == 0 => Vec::new(),\n                None => match self.keys.get(index - 1) {\n                    Some(_) => {\n                        path.push((self, index));\n                        path\n                    }\n                    None => Vec::new(),\n                },\n                Some(ref node) => {\n                    path.push((self, index));\n                    node.path_prev(key, path)\n                }\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::pop_max":["fn pop_max(&mut self) -> (A, Option<PoolRef<Node<A>>>){\n        let value = self.keys.pop_back();\n        let child = self.children.pop_back();\n        (value, child)\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::pop_min":["fn pop_min(&mut self) -> (A, Option<PoolRef<Node<A>>>){\n        let value = self.keys.pop_front();\n        let child = self.children.pop_front();\n        (value, child)\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::push_max":["fn push_max(&mut self, child: Option<PoolRef<Node<A>>>, value: A){\n        self.keys.push_back(value);\n        self.children.push_back(child);\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::push_min":["fn push_min(&mut self, child: Option<PoolRef<Node<A>>>, value: A){\n        self.keys.push_front(value);\n        self.children.push_front(child);\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::remove":["pub(crate) fn remove<BK>(&mut self, pool: &Pool<Node<A>>, key: &BK) -> Remove<A>\n    where\n        A: Clone,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        let index = A::search_key(&self.keys, key);\n        self.remove_index(pool, index, key)\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::remove_index":["fn remove_index<BK>(\n        &mut self,\n        pool: &Pool<Node<A>>,\n        index: Result<usize, usize>,\n        key: &BK,\n    ) -> Remove<A>\n    where\n        A: Clone,\n        BK: Ord + ?Sized,\n        A::Key: Borrow<BK>,{\n        let action = match index {\n            // Key exists in node, remove it.\n            Ok(index) => {\n                match (&self.children[index], &self.children[index + 1]) {\n                    // If we're a leaf, just delete the entry.\n                    (&None, &None) => RemoveAction::DeleteAt(index),\n                    // If the left hand child has capacity, pull the predecessor up.\n                    (&Some(ref left), _) if !left.too_small() => {\n                        if left.is_leaf() {\n                            RemoveAction::PullUp(left.keys.len() - 1, index, index)\n                        } else {\n                            RemoveAction::StealFromLeft(index + 1)\n                        }\n                    }\n                    // If the right hand child has capacity, pull the successor up.\n                    (_, &Some(ref right)) if !right.too_small() => {\n                        if right.is_leaf() {\n                            RemoveAction::PullUp(0, index, index + 1)\n                        } else {\n                            RemoveAction::StealFromRight(index)\n                        }\n                    }\n                    // If neither child has capacity, we'll have to merge them.\n                    (&Some(_), &Some(_)) => RemoveAction::Merge(index),\n                    // If one child exists and the other doesn't, we're in a bad state.\n                    _ => unreachable!(),\n                }\n            }\n            // Key is adjacent to some key in node\n            Err(index) => match self.children[index] {\n                // No child at location means key isn't in map.\n                None => return Remove::NoChange,\n                // Child at location, but it's at minimum capacity.\n                Some(ref child) if child.too_small() => {\n                    let left = if index > 0 {\n                        self.children.get(index - 1)\n                    } else {\n                        None\n                    }; // index is usize and can't be negative, best make sure it never is.\n                    match (left, self.children.get(index + 1)) {\n                        // If it has a left sibling with capacity, steal a key from it.\n                        (Some(&Some(ref old_left)), _) if !old_left.too_small() => {\n                            RemoveAction::StealFromLeft(index)\n                        }\n                        // If it has a right sibling with capacity, same as above.\n                        (_, Some(&Some(ref old_right))) if !old_right.too_small() => {\n                            RemoveAction::StealFromRight(index)\n                        }\n                        // If it has neither, we'll have to merge it with a sibling.\n                        // If we have a right sibling, we'll merge with that.\n                        (_, Some(&Some(_))) => RemoveAction::MergeFirst(index),\n                        // If we have a left sibling, we'll merge with that.\n                        (Some(&Some(_)), _) => RemoveAction::MergeFirst(index - 1),\n                        // If none of the above, we're in a bad state.\n                        _ => unreachable!(),\n                    }\n                }\n                // Child at location, and it's big enough, we can recurse down.\n                Some(_) => RemoveAction::ContinueDown(index),\n            },\n        };\n        match action {\n            RemoveAction::DeleteAt(index) => {\n                let pair = self.keys.remove(index);\n                self.children.remove(index);\n                Remove::Removed(pair)\n            }\n            RemoveAction::PullUp(target_index, pull_to, child_index) => {\n                let children = &mut self.children;\n                let mut update = None;\n                let value;\n                if let Some(&mut Some(ref mut child_ref)) = children.get_mut(child_index) {\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    match child.remove_index(pool, Ok(target_index), key) {\n                        Remove::NoChange => unreachable!(),\n                        Remove::Removed(pulled_value) => {\n                            value = self.keys.set(pull_to, pulled_value);\n                        }\n                        Remove::Update(pulled_value, new_child) => {\n                            value = self.keys.set(pull_to, pulled_value);\n                            update = Some(new_child);\n                        }\n                    }\n                } else {\n                    unreachable!()\n                }\n                if let Some(new_child) = update {\n                    children[child_index] = Some(PoolRef::new(pool, new_child));\n                }\n                Remove::Removed(value)\n            }\n            RemoveAction::Merge(index) => {\n                let left = self.children.remove(index).unwrap();\n                let right = mem::replace(&mut self.children[index], None).unwrap();\n                let value = self.keys.remove(index);\n                let mut merged_child = Node::merge(\n                    value,\n                    PoolRef::unwrap_or_clone(left),\n                    PoolRef::unwrap_or_clone(right),\n                );\n                let (removed, new_child) = match merged_child.remove(pool, key) {\n                    Remove::NoChange => unreachable!(),\n                    Remove::Removed(removed) => (removed, merged_child),\n                    Remove::Update(removed, updated_child) => (removed, updated_child),\n                };\n                if self.keys.is_empty() {\n                    // If we've depleted the root node, the merged child becomes the root.\n                    Remove::Update(removed, new_child)\n                } else {\n                    self.children[index] = Some(PoolRef::new(pool, new_child));\n                    Remove::Removed(removed)\n                }\n            }\n            RemoveAction::StealFromLeft(index) => {\n                let mut update = None;\n                let out_value;\n                {\n                    let mut children = self.children.as_mut_slice()[index - 1..=index]\n                        .iter_mut()\n                        .map(|n| {\n                            if let Some(ref mut o) = *n {\n                                o\n                            } else {\n                                unreachable!()\n                            }\n                        });\n                    let left = PoolRef::make_mut(pool, children.next().unwrap());\n                    let child = PoolRef::make_mut(pool, children.next().unwrap());\n                    // Prepare the rebalanced node.\n                    child.push_min(\n                        left.children.last().unwrap().clone(),\n                        self.keys[index - 1].clone(),\n                    );\n                    match child.remove(pool, key) {\n                        Remove::NoChange => {\n                            // Key wasn't there, we need to revert the steal.\n                            child.pop_min();\n                            return Remove::NoChange;\n                        }\n                        Remove::Removed(value) => {\n                            // If we did remove something, we complete the rebalancing.\n                            let (left_value, _) = left.pop_max();\n                            self.keys[index - 1] = left_value;\n                            out_value = value;\n                        }\n                        Remove::Update(value, new_child) => {\n                            // If we did remove something, we complete the rebalancing.\n                            let (left_value, _) = left.pop_max();\n                            self.keys[index - 1] = left_value;\n                            update = Some(new_child);\n                            out_value = value;\n                        }\n                    }\n                }\n                if let Some(new_child) = update {\n                    self.children[index] = Some(PoolRef::new(pool, new_child));\n                }\n                Remove::Removed(out_value)\n            }\n            RemoveAction::StealFromRight(index) => {\n                let mut update = None;\n                let out_value;\n                {\n                    let mut children = self.children.as_mut_slice()[index..index + 2]\n                        .iter_mut()\n                        .map(|n| {\n                            if let Some(ref mut o) = *n {\n                                o\n                            } else {\n                                unreachable!()\n                            }\n                        });\n                    let child = PoolRef::make_mut(pool, children.next().unwrap());\n                    let right = PoolRef::make_mut(pool, children.next().unwrap());\n                    // Prepare the rebalanced node.\n                    child.push_max(right.children[0].clone(), self.keys[index].clone());\n                    match child.remove(pool, key) {\n                        Remove::NoChange => {\n                            // Key wasn't there, we need to revert the steal.\n                            child.pop_max();\n                            return Remove::NoChange;\n                        }\n                        Remove::Removed(value) => {\n                            // If we did remove something, we complete the rebalancing.\n                            let (right_value, _) = right.pop_min();\n                            self.keys[index] = right_value;\n                            out_value = value;\n                        }\n                        Remove::Update(value, new_child) => {\n                            // If we did remove something, we complete the rebalancing.\n                            let (right_value, _) = right.pop_min();\n                            self.keys[index] = right_value;\n                            update = Some(new_child);\n                            out_value = value;\n                        }\n                    }\n                }\n                if let Some(new_child) = update {\n                    self.children[index] = Some(PoolRef::new(pool, new_child));\n                }\n                Remove::Removed(out_value)\n            }\n            RemoveAction::MergeFirst(index) => {\n                if self.keys[index].cmp_keys(key) != Ordering::Equal\n                    && !self.child_contains(index, key)\n                    && !self.child_contains(index + 1, key)\n                {\n                    return Remove::NoChange;\n                }\n                let left = self.children.remove(index).unwrap();\n                let right = mem::replace(&mut self.children[index], None).unwrap();\n                let middle = self.keys.remove(index);\n                let mut merged = Node::merge(\n                    middle,\n                    PoolRef::unwrap_or_clone(left),\n                    PoolRef::unwrap_or_clone(right),\n                );\n                let update;\n                let out_value;\n                match merged.remove(pool, key) {\n                    Remove::NoChange => {\n                        panic!(\"nodes::btree::Node::remove: caught an absent key too late while merging\");\n                    }\n                    Remove::Removed(value) => {\n                        if self.keys.is_empty() {\n                            return Remove::Update(value, merged);\n                        }\n                        update = merged;\n                        out_value = value;\n                    }\n                    Remove::Update(value, new_child) => {\n                        if self.keys.is_empty() {\n                            return Remove::Update(value, new_child);\n                        }\n                        update = new_child;\n                        out_value = value;\n                    }\n                }\n                self.children[index] = Some(PoolRef::new(pool, update));\n                Remove::Removed(out_value)\n            }\n            RemoveAction::ContinueDown(index) => {\n                let mut update = None;\n                let out_value;\n                if let Some(&mut Some(ref mut child_ref)) = self.children.get_mut(index) {\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    match child.remove(pool, key) {\n                        Remove::NoChange => return Remove::NoChange,\n                        Remove::Removed(value) => {\n                            out_value = value;\n                        }\n                        Remove::Update(value, new_child) => {\n                            update = Some(new_child);\n                            out_value = value;\n                        }\n                    }\n                } else {\n                    unreachable!()\n                }\n                if let Some(new_child) = update {\n                    self.children[index] = Some(PoolRef::new(pool, new_child));\n                }\n                Remove::Removed(out_value)\n            }\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::split":["fn split(\n        &mut self,\n        pool: &Pool<Node<A>>,\n        value: A,\n        ins_left: Option<Node<A>>,\n        ins_right: Option<Node<A>>,\n    ) -> Insert<A>{\n        let left_child = ins_left.map(|node| PoolRef::new(pool, node));\n        let right_child = ins_right.map(|node| PoolRef::new(pool, node));\n        let index = A::search_value(&self.keys, &value).unwrap_err();\n        let mut left_keys;\n        let mut left_children;\n        let mut right_keys;\n        let mut right_children;\n        let median;\n        match index.cmp(&MEDIAN) {\n            Ordering::Less => {\n                self.children[index] = left_child;\n\n                left_keys = Chunk::from_front(&mut self.keys, index);\n                left_keys.push_back(value);\n                left_keys.drain_from_front(&mut self.keys, MEDIAN - index - 1);\n\n                left_children = Chunk::from_front(&mut self.children, index + 1);\n                left_children.push_back(right_child);\n                left_children.drain_from_front(&mut self.children, MEDIAN - index - 1);\n\n                median = self.keys.pop_front();\n\n                right_keys = Chunk::drain_from(&mut self.keys);\n                right_children = Chunk::drain_from(&mut self.children);\n            }\n            Ordering::Greater => {\n                self.children[index] = left_child;\n\n                left_keys = Chunk::from_front(&mut self.keys, MEDIAN);\n                left_children = Chunk::from_front(&mut self.children, MEDIAN + 1);\n\n                median = self.keys.pop_front();\n\n                right_keys = Chunk::from_front(&mut self.keys, index - MEDIAN - 1);\n                right_keys.push_back(value);\n                right_keys.append(&mut self.keys);\n\n                right_children = Chunk::from_front(&mut self.children, index - MEDIAN);\n                right_children.push_back(right_child);\n                right_children.append(&mut self.children);\n            }\n            Ordering::Equal => {\n                left_keys = Chunk::from_front(&mut self.keys, MEDIAN);\n                left_children = Chunk::from_front(&mut self.children, MEDIAN);\n                left_children.push_back(left_child);\n\n                median = value;\n\n                right_keys = Chunk::drain_from(&mut self.keys);\n                right_children = Chunk::drain_from(&mut self.children);\n                right_children[0] = right_child;\n            }\n        }\n\n        debug_assert!(left_keys.len() == MEDIAN);\n        debug_assert!(left_children.len() == MEDIAN + 1);\n        debug_assert!(right_keys.len() == MEDIAN);\n        debug_assert!(right_children.len() == MEDIAN + 1);\n\n        Split(\n            Node {\n                keys: left_keys,\n                children: left_children,\n            },\n            median,\n            Node {\n                keys: right_keys,\n                children: right_children,\n            },\n        )\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::too_small":["#[inline]\nfn too_small(&self) -> bool{\n        self.keys.len() < MEDIAN\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Node::<A>::unit":["#[inline]\npub(crate) fn unit(value: A) -> Self{\n        Node {\n            keys: Chunk::unit(value),\n            children: Chunk::pair(None, None),\n        }\n    }","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::Remove":["pub(crate) enum Remove<A> {\n    NoChange,\n    Removed(A),\n    Update(A, Node<A>),\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::btree::RemoveAction":["enum RemoveAction {\n    DeleteAt(usize),\n    PullUp(usize, usize, usize),\n    Merge(usize),\n    StealFromLeft(usize),\n    StealFromRight(usize),\n    MergeFirst(usize),\n    ContinueDown(usize),\n}","Real(LocalPath(\"src/nodes/btree.rs\"))"],"nodes::hamt::CollisionNode":["pub(crate) struct CollisionNode<A> {\n    hash: HashBits,\n    data: Vec<A>,\n}","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::CollisionNode::<A>::get":["fn get<BK>(&self, key: &BK) -> Option<&A>\n    where\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,{\n        for entry in &self.data {\n            if key == entry.extract_key().borrow() {\n                return Some(entry);\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::CollisionNode::<A>::get_mut":["fn get_mut<BK>(&mut self, key: &BK) -> Option<&mut A>\n    where\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,{\n        for entry in &mut self.data {\n            if key == entry.extract_key().borrow() {\n                return Some(entry);\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::CollisionNode::<A>::insert":["fn insert(&mut self, value: A) -> Option<A>{\n        for item in &mut self.data {\n            if value.extract_key() == item.extract_key() {\n                return Some(mem::replace(item, value));\n            }\n        }\n        self.data.push(value);\n        None\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::CollisionNode::<A>::len":["#[inline]\nfn len(&self) -> usize{\n        self.data.len()\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::CollisionNode::<A>::new":["fn new(hash: HashBits, value1: A, value2: A) -> Self{\n        CollisionNode {\n            hash,\n            data: vec![value1, value2],\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::CollisionNode::<A>::pop":["fn pop(&mut self) -> Entry<A>{\n        Entry::Value(self.data.pop().unwrap(), self.hash)\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::CollisionNode::<A>::remove":["fn remove<BK>(&mut self, key: &BK) -> Option<A>\n    where\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,{\n        let mut loc = None;\n        for (index, item) in self.data.iter().enumerate() {\n            if key == item.extract_key().borrow() {\n                loc = Some(index);\n            }\n        }\n        if let Some(index) = loc {\n            Some(self.data.remove(index))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Drain":["pub(crate) struct Drain<A>\nwhere\n    A: HashValue,\n{\n    count: usize,\n    pool: Pool<Node<A>>,\n    stack: Vec<PoolRef<Node<A>>>,\n    current: PoolRef<Node<A>>,\n    collision: Option<CollisionNode<A>>,\n}","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Drain::<A>::new":["pub(crate) fn new(pool: &Pool<Node<A>>, root: PoolRef<Node<A>>, size: usize) -> Self{\n        Drain {\n            count: size,\n            pool: pool.clone(),\n            stack: vec![],\n            current: root,\n            collision: None,\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Entry":["pub(crate) enum Entry<A> {\n    Value(A, HashBits),\n    Collision(Ref<CollisionNode<A>>),\n    Node(PoolRef<Node<A>>),\n}","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Entry::<A>::from_node":["fn from_node(pool: &Pool<Node<A>>, node: Node<A>) -> Self{\n        Entry::Node(PoolRef::new(pool, node))\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Entry::<A>::is_value":["fn is_value(&self) -> bool{\n        match self {\n            Entry::Value(_, _) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Entry::<A>::unwrap_value":["fn unwrap_value(self) -> A{\n        match self {\n            Entry::Value(a, _) => a,\n            _ => panic!(\"nodes::hamt::Entry::unwrap_value: unwrapped a non-value\"),\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::HashValue":["pub trait HashValue {\n    type Key: Eq;\n\n    fn extract_key(&self) -> &Self::Key;\n    fn ptr_eq(&self, other: &Self) -> bool;\n}","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Iter":["pub(crate) struct Iter<'a, A> {\n    count: usize,\n    stack: Vec<ChunkIter<'a, Entry<A>, HashWidth>>,\n    current: ChunkIter<'a, Entry<A>, HashWidth>,\n    collision: Option<(HashBits, SliceIter<'a, A>)>,\n}","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Iter::<'a, A>::new":["pub(crate) fn new(root: &'a Node<A>, size: usize) -> Self{\n        Iter {\n            count: size,\n            stack: Vec::with_capacity((HASH_WIDTH / HASH_SHIFT) + 1),\n            current: root.data.iter(),\n            collision: None,\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::IterMut":["pub(crate) struct IterMut<'a, A> {\n    count: usize,\n    pool: Pool<Node<A>>,\n    stack: Vec<ChunkIterMut<'a, Entry<A>, HashWidth>>,\n    current: ChunkIterMut<'a, Entry<A>, HashWidth>,\n    collision: Option<(HashBits, SliceIterMut<'a, A>)>,\n}","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::IterMut::<'a, A>::new":["pub(crate) fn new(pool: &Pool<Node<A>>, root: &'a mut Node<A>, size: usize) -> Self{\n        IterMut {\n            count: size,\n            pool: pool.clone(),\n            stack: Vec::with_capacity((HASH_WIDTH / HASH_SHIFT) + 1),\n            current: root.data.iter_mut(),\n            collision: None,\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node":["pub(crate) struct Node<A> {\n    data: SparseChunk<Entry<A>, HashWidth>,\n}","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node::<A>::get":["pub(crate) fn get<BK>(&self, hash: HashBits, shift: usize, key: &BK) -> Option<&A>\n    where\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,{\n        let index = mask(hash, shift) as usize;\n        if let Some(entry) = self.data.get(index) {\n            match entry {\n                Entry::Value(ref value, _) => {\n                    if key == value.extract_key().borrow() {\n                        Some(value)\n                    } else {\n                        None\n                    }\n                }\n                Entry::Collision(ref coll) => coll.get(key),\n                Entry::Node(ref child) => child.get(hash, shift + HASH_SHIFT, key),\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node::<A>::get_mut":["pub(crate) fn get_mut<BK>(\n        &mut self,\n        pool: &Pool<Node<A>>,\n        hash: HashBits,\n        shift: usize,\n        key: &BK,\n    ) -> Option<&mut A>\n    where\n        A: Clone,\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,{\n        let index = mask(hash, shift) as usize;\n        if let Some(entry) = self.data.get_mut(index) {\n            match entry {\n                Entry::Value(ref mut value, _) => {\n                    if key == value.extract_key().borrow() {\n                        Some(value)\n                    } else {\n                        None\n                    }\n                }\n                Entry::Collision(ref mut coll_ref) => {\n                    let coll = Ref::make_mut(coll_ref);\n                    coll.get_mut(key)\n                }\n                Entry::Node(ref mut child_ref) => {\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    child.get_mut(pool, hash, shift + HASH_SHIFT, key)\n                }\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node::<A>::insert":["pub(crate) fn insert(\n        &mut self,\n        pool: &Pool<Node<A>>,\n        hash: HashBits,\n        shift: usize,\n        value: A,\n    ) -> Option<A>\n    where\n        A: Clone,{\n        let index = mask(hash, shift) as usize;\n        if let Some(entry) = self.data.get_mut(index) {\n            let mut fallthrough = false;\n            // Value is here\n            match entry {\n                // Update value or create a subtree\n                Entry::Value(ref current, _) => {\n                    if current.extract_key() == value.extract_key() {\n                        // If we have a key match, fall through to the outer\n                        // level where we replace the current value. If we\n                        // don't, fall through to the inner level where we merge\n                        // some nodes.\n                        fallthrough = true;\n                    }\n                }\n                // There's already a collision here.\n                Entry::Collision(ref mut collision) => {\n                    let coll = Ref::make_mut(collision);\n                    return coll.insert(value);\n                }\n                Entry::Node(ref mut child_ref) => {\n                    // Child node\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    return child.insert(pool, hash, shift + HASH_SHIFT, value);\n                }\n            }\n            if !fallthrough {\n                // If we get here, we're looking at a value entry that needs a merge.\n                // We're going to be unsafe and pry it out of the reference, trusting\n                // that we overwrite it with the merged node.\n                #[allow(unsafe_code)]\n                let old_entry = unsafe { ptr::read(entry) };\n                if shift + HASH_SHIFT >= HASH_WIDTH {\n                    // We're at the lowest level, need to set up a collision node.\n                    let coll = CollisionNode::new(hash, old_entry.unwrap_value(), value);\n                    #[allow(unsafe_code)]\n                    unsafe {\n                        ptr::write(entry, Entry::from(coll))\n                    };\n                } else if let Entry::Value(old_value, old_hash) = old_entry {\n                    let node = Node::merge_values(\n                        pool,\n                        old_value,\n                        old_hash,\n                        value,\n                        hash,\n                        shift + HASH_SHIFT,\n                    );\n                    #[allow(unsafe_code)]\n                    unsafe {\n                        ptr::write(entry, Entry::from_node(pool, node))\n                    };\n                } else {\n                    unreachable!()\n                }\n                return None;\n            }\n        }\n        // If we get here, either we found nothing at this index, in which case\n        // we insert a new entry, or we hit a value entry with the same key, in\n        // which case we replace it.\n        self.data\n            .insert(index, Entry::Value(value, hash))\n            .map(Entry::unwrap_value)\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node::<A>::len":["#[inline]\nfn len(&self) -> usize{\n        self.data.len()\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node::<A>::merge_values":["fn merge_values(\n        pool: &Pool<Node<A>>,\n        value1: A,\n        hash1: HashBits,\n        value2: A,\n        hash2: HashBits,\n        shift: usize,\n    ) -> Self{\n        let index1 = mask(hash1, shift) as usize;\n        let index2 = mask(hash2, shift) as usize;\n        if index1 != index2 {\n            // Both values fit on the same level.\n            Node::pair(\n                index1,\n                Entry::Value(value1, hash1),\n                index2,\n                Entry::Value(value2, hash2),\n            )\n        } else if shift + HASH_SHIFT >= HASH_WIDTH {\n            // If we're at the bottom, we've got a collision.\n            Node::unit(\n                index1,\n                Entry::from(CollisionNode::new(hash1, value1, value2)),\n            )\n        } else {\n            // Pass the values down a level.\n            let node = Node::merge_values(pool, value1, hash1, value2, hash2, shift + HASH_SHIFT);\n            Node::single_child(pool, index1, node)\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node::<A>::new":["#[inline]\npub(crate) fn new() -> Self{\n        Node {\n            data: SparseChunk::new(),\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node::<A>::pair":["#[inline]\npub(crate) fn pair(index1: usize, value1: Entry<A>, index2: usize, value2: Entry<A>) -> Self{\n        Node {\n            data: SparseChunk::pair(index1, value1, index2, value2),\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node::<A>::pop":["fn pop(&mut self) -> Entry<A>{\n        self.data.pop().unwrap()\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node::<A>::remove":["pub(crate) fn remove<BK>(\n        &mut self,\n        pool: &Pool<Node<A>>,\n        hash: HashBits,\n        shift: usize,\n        key: &BK,\n    ) -> Option<A>\n    where\n        A: Clone,\n        BK: Eq + ?Sized,\n        A::Key: Borrow<BK>,{\n        let index = mask(hash, shift) as usize;\n        let mut new_node = None;\n        let mut removed = None;\n        if let Some(entry) = self.data.get_mut(index) {\n            match entry {\n                Entry::Value(ref value, _) => {\n                    if key != value.extract_key().borrow() {\n                        // Key wasn't in the map.\n                        return None;\n                    } // Otherwise, fall through to the removal.\n                }\n                Entry::Collision(ref mut coll_ref) => {\n                    let coll = Ref::make_mut(coll_ref);\n                    removed = coll.remove(key);\n                    if coll.len() == 1 {\n                        new_node = Some(coll.pop());\n                    } else {\n                        return removed;\n                    }\n                }\n                Entry::Node(ref mut child_ref) => {\n                    let child = PoolRef::make_mut(pool, child_ref);\n                    match child.remove(pool, hash, shift + HASH_SHIFT, key) {\n                        None => {\n                            return None;\n                        }\n                        Some(value) => {\n                            if child.len() == 1\n                                && child.data[child.data.first_index().unwrap()].is_value()\n                            {\n                                // If the child now contains only a single value node,\n                                // pull it up one level and discard the child.\n                                removed = Some(value);\n                                new_node = Some(child.pop());\n                            } else {\n                                return Some(value);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if let Some(node) = new_node {\n            self.data.insert(index, node);\n            return removed;\n        }\n        self.data.remove(index).map(Entry::unwrap_value)\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node::<A>::single_child":["#[inline]\npub(crate) fn single_child(pool: &Pool<Node<A>>, index: usize, node: Self) -> Self{\n        Node {\n            data: SparseChunk::unit(index, Entry::from_node(pool, node)),\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::Node::<A>::unit":["#[inline]\npub(crate) fn unit(index: usize, value: Entry<A>) -> Self{\n        Node {\n            data: SparseChunk::unit(index, value),\n        }\n    }","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::hash_key":["pub(crate) fn hash_key<K: Hash + ?Sized, S: BuildHasher>(bh: &S, key: &K) -> HashBits{\n    let mut hasher = bh.build_hasher();\n    key.hash(&mut hasher);\n    hasher.finish() as HashBits\n}","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::hamt::mask":["#[inline]\nfn mask(hash: HashBits, shift: usize) -> HashBits{\n    hash >> shift & HASH_MASK\n}","Real(LocalPath(\"src/nodes/hamt.rs\"))"],"nodes::rrb::Entry":["enum Entry<A> {\n    Nodes(Size, PoolRef<Chunk<Node<A>>>),\n    Values(PoolRef<Chunk<A>>),\n    Empty,\n}","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Entry::<A>::is_empty_node":["fn is_empty_node(&self) -> bool{\n        match self {\n            Empty => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Entry::<A>::is_full":["fn is_full(&self) -> bool{\n        match self {\n            Nodes(_, ref nodes) => nodes.is_full(),\n            Values(ref values) => values.is_full(),\n            Empty => false,\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Entry::<A>::len":["fn len(&self) -> usize{\n        match self {\n            Nodes(_, ref nodes) => nodes.len(),\n            Values(ref values) => values.len(),\n            Empty => 0,\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Entry::<A>::nodes":["fn nodes(self) -> Chunk<Node<A>>{\n        match self {\n            Nodes(_, nodes) => PoolRef::unwrap_or_clone(nodes),\n            _ => panic!(\"rrb::Entry::nodes: expected nodes, found values\"),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Entry::<A>::unwrap_nodes":["fn unwrap_nodes(&self) -> &Chunk<Node<A>>{\n        match self {\n            Nodes(_, ref nodes) => nodes,\n            _ => panic!(\"rrb::Entry::unwrap_nodes: expected nodes, found values\"),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Entry::<A>::unwrap_nodes_mut":["fn unwrap_nodes_mut(&mut self, pool: &RRBPool<A>) -> &mut Chunk<Node<A>>{\n        match self {\n            Nodes(_, ref mut nodes) => PoolRef::make_mut(&pool.node_pool, nodes),\n            _ => panic!(\"rrb::Entry::unwrap_nodes_mut: expected nodes, found values\"),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Entry::<A>::unwrap_values":["fn unwrap_values(&self) -> &Chunk<A>{\n        match self {\n            Values(ref values) => values,\n            _ => panic!(\"rrb::Entry::unwrap_values: expected values, found nodes\"),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Entry::<A>::unwrap_values_mut":["fn unwrap_values_mut(&mut self, pool: &RRBPool<A>) -> &mut Chunk<A>{\n        match self {\n            Values(ref mut values) => PoolRef::make_mut(&pool.value_pool, values),\n            _ => panic!(\"rrb::Entry::unwrap_values_mut: expected values, found nodes\"),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Entry::<A>::values":["fn values(self) -> Chunk<A>{\n        match self {\n            Values(values) => PoolRef::unwrap_or_clone(values),\n            _ => panic!(\"rrb::Entry::values: expected values, found nodes\"),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node":["pub(crate) struct Node<A> {\n    children: Entry<A>,\n}","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::clear_node":["pub(crate) fn clear_node(&mut self){\n        self.children = Empty;\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::elevate":["pub(crate) fn elevate(self, pool: &RRBPool<A>, level_increment: usize) -> Self{\n        if level_increment > 0 {\n            Self::single_parent(pool, self.elevate(pool, level_increment - 1))\n        } else {\n            self\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::first_child":["pub(crate) fn first_child(&self) -> &Self{\n        self.children.unwrap_nodes().first().unwrap()\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::from_chunk":["pub(crate) fn from_chunk(pool: &RRBPool<A>, level: usize, chunk: PoolRef<Chunk<A>>) -> Self{\n        let node = Node {\n            children: Values(chunk),\n        };\n        node.elevate(pool, level)\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::index":["pub(crate) fn index(&self, level: usize, index: usize) -> &A{\n        if level == 0 {\n            &self.children.unwrap_values()[index]\n        } else {\n            let target_idx = self.index_in(level, index).unwrap();\n            self.children.unwrap_nodes()[target_idx]\n                .index(level - 1, index - self.size_up_to(level, target_idx))\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::index_in":["fn index_in(&self, level: usize, index: usize) -> Option<usize>{\n        let mut target_idx = if let Some(child_size) = NODE_SIZE.checked_pow(level as u32) {\n            index / child_size\n        } else {\n            0\n        };\n        if target_idx >= self.children.len() {\n            return None;\n        }\n        if let Entry::Nodes(Size::Table(ref size_table), _) = self.children {\n            while size_table[target_idx] <= index {\n                target_idx += 1;\n                if target_idx >= size_table.len() {\n                    return None;\n                }\n            }\n        }\n        Some(target_idx)\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::index_mut":["pub(crate) fn index_mut(&mut self, pool: &RRBPool<A>, level: usize, index: usize) -> &mut A{\n        if level == 0 {\n            &mut self.children.unwrap_values_mut(pool)[index]\n        } else {\n            let target_idx = self.index_in(level, index).unwrap();\n            let offset = index - self.size_up_to(level, target_idx);\n            let child = &mut self.children.unwrap_nodes_mut(pool)[target_idx];\n            child.index_mut(pool, level - 1, offset)\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::is_completely_dense":["/// True if the node and its children are dense and at capacity\nfn is_completely_dense(&self, level: usize) -> bool{\n        // Size of a full node is NODE_SIZE at level 0, NODE_SIZE at\n        // level 1, etc.\n        if let Some(expected_size) = NODE_SIZE.checked_pow(level as u32 + 1) {\n            self.size() == expected_size\n        } else {\n            // We overflowed a usize, there's no way we can be completely dense as we know the size\n            // fits in a usize.\n            false\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::is_dense":["/// True if the node is dense and so doesn't have a size table\nfn is_dense(&self) -> bool{\n        match self.children {\n            Entry::Nodes(Size::Table(_), _) => false,\n            _ => true,\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::is_empty":["pub(crate) fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::is_full":["pub(crate) fn is_full(&self) -> bool{\n        self.children.is_full()\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::is_single":["pub(crate) fn is_single(&self) -> bool{\n        self.children.len() == 1\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::join_branches":["pub(crate) fn join_branches(self, pool: &RRBPool<A>, right: Self, level: usize) -> Self{\n        let left_len = self.len();\n        let right_len = right.len();\n        let size = if self.is_completely_dense(level) && right.is_dense() {\n            Size::Size(left_len + right_len)\n        } else {\n            let size_table = Chunk::pair(left_len, left_len + right_len);\n            Size::Table(PoolRef::new(&pool.size_pool, size_table))\n        };\n        Node {\n            children: {\n                let children = Chunk::pair(self, right);\n                Nodes(size, PoolRef::new(&pool.node_pool, children))\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::join_dense":["pub(crate) fn join_dense(pool: &RRBPool<A>, left: Self, right: Self) -> Self{\n        let left_len = left.len();\n        let right_len = right.len();\n        Node {\n            children: {\n                let children = PoolRef::new(&pool.node_pool, Chunk::pair(left, right));\n                Nodes(Size::Size(left_len + right_len), children)\n            },\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::len":["pub(crate) fn len(&self) -> usize{\n        match self.children {\n            Entry::Nodes(Size::Size(size), _) => size,\n            Entry::Nodes(Size::Table(ref size_table), _) => *(size_table.last().unwrap_or(&0)),\n            Entry::Values(ref values) => values.len(),\n            Entry::Empty => 0,\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::lookup_chunk":["pub(crate) fn lookup_chunk(\n        &self,\n        level: usize,\n        base: usize,\n        index: usize,\n    ) -> (Range<usize>, *const Chunk<A>){\n        if level == 0 {\n            (\n                base..(base + self.children.len()),\n                self.children.unwrap_values() as *const Chunk<A>,\n            )\n        } else {\n            let target_idx = self.index_in(level, index).unwrap();\n            let offset = self.size_up_to(level, target_idx);\n            let child_base = base + offset;\n            let children = self.children.unwrap_nodes();\n            let child = &children[target_idx];\n            child.lookup_chunk(level - 1, child_base, index - offset)\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::lookup_chunk_mut":["pub(crate) fn lookup_chunk_mut(\n        &mut self,\n        pool: &RRBPool<A>,\n        level: usize,\n        base: usize,\n        index: usize,\n    ) -> (Range<usize>, *mut Chunk<A>){\n        if level == 0 {\n            (\n                base..(base + self.children.len()),\n                self.children.unwrap_values_mut(pool) as *mut Chunk<A>,\n            )\n        } else {\n            let target_idx = self.index_in(level, index).unwrap();\n            let offset = self.size_up_to(level, target_idx);\n            let child_base = base + offset;\n            let children = self.children.unwrap_nodes_mut(pool);\n            let child = &mut children[target_idx];\n            child.lookup_chunk_mut(pool, level - 1, child_base, index - offset)\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::merge":["pub(crate) fn merge(pool: &RRBPool<A>, mut left: Self, mut right: Self, level: usize) -> Self{\n        if level == 0 {\n            Self::merge_leaves(pool, left, right)\n        } else {\n            let merged = {\n                if level == 1 {\n                    // We're going to rebalance all the leaves anyway, there's\n                    // no need for a middle at level 1\n                    Node::parent(pool, 0, Chunk::new())\n                } else {\n                    let left_last =\n                        if let Entry::Nodes(ref mut size, ref mut children) = left.children {\n                            let node = PoolRef::make_mut(&pool.node_pool, children).pop_back();\n                            if !node.is_empty() {\n                                size.pop(&pool.size_pool, Side::Right, level, node.len());\n                            }\n                            node\n                        } else {\n                            panic!(\"expected nodes, found entries or empty\");\n                        };\n                    let right_first =\n                        if let Entry::Nodes(ref mut size, ref mut children) = right.children {\n                            let node = PoolRef::make_mut(&pool.node_pool, children).pop_front();\n                            if !node.is_empty() {\n                                size.pop(&pool.size_pool, Side::Left, level, node.len());\n                            }\n                            node\n                        } else {\n                            panic!(\"expected nodes, found entries or empty\");\n                        };\n                    Self::merge(pool, left_last, right_first, level - 1)\n                }\n            };\n            Self::merge_rebalance(pool, level, left, merged, right)\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::merge_leaves":["fn merge_leaves(pool: &RRBPool<A>, mut left: Self, mut right: Self) -> Self{\n        if left.children.is_empty_node() {\n            // Left is empty, just use right\n            Self::single_parent(pool, right)\n        } else if right.children.is_empty_node() {\n            // Right is empty, just use left\n            Self::single_parent(pool, left)\n        } else {\n            {\n                let left_vals = left.children.unwrap_values_mut(pool);\n                let left_len = left_vals.len();\n                let right_vals = right.children.unwrap_values_mut(pool);\n                let right_len = right_vals.len();\n                if left_len + right_len <= NODE_SIZE {\n                    left_vals.append(right_vals);\n                } else {\n                    let count = right_len.min(NODE_SIZE - left_len);\n                    left_vals.drain_from_front(right_vals, count);\n                }\n            }\n            if right.is_empty() {\n                Self::single_parent(pool, left)\n            } else {\n                Self::join_dense(pool, left, right)\n            }\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::merge_rebalance":["fn merge_rebalance(\n        pool: &RRBPool<A>,\n        level: usize,\n        left: Self,\n        middle: Self,\n        right: Self,\n    ) -> Self{\n        let left_nodes = left.children.nodes().into_iter();\n        let middle_nodes = middle.children.nodes().into_iter();\n        let right_nodes = right.children.nodes().into_iter();\n        let mut subtree_still_balanced = true;\n        let mut next_leaf = Chunk::new();\n        let mut next_node = Chunk::new();\n        let mut next_subtree = Chunk::new();\n        let mut root = Chunk::new();\n\n        for subtree in left_nodes.chain(middle_nodes).chain(right_nodes) {\n            if subtree.is_empty() {\n                continue;\n            }\n            if subtree.is_completely_dense(level) && subtree_still_balanced {\n                root.push_back(subtree);\n                continue;\n            }\n            subtree_still_balanced = false;\n\n            if level == 1 {\n                for value in subtree.children.values() {\n                    next_leaf.push_back(value);\n                    if next_leaf.is_full() {\n                        let new_node =\n                            Node::from_chunk(pool, 0, PoolRef::new(&pool.value_pool, next_leaf));\n                        next_subtree.push_back(new_node);\n                        next_leaf = Chunk::new();\n                        if next_subtree.is_full() {\n                            let new_subtree = Node::parent(pool, level, next_subtree);\n                            root.push_back(new_subtree);\n                            next_subtree = Chunk::new();\n                        }\n                    }\n                }\n            } else {\n                for node in subtree.children.nodes() {\n                    next_node.push_back(node);\n                    if next_node.is_full() {\n                        let new_node = Node::parent(pool, level - 1, next_node);\n                        next_subtree.push_back(new_node);\n                        next_node = Chunk::new();\n                        if next_subtree.is_full() {\n                            let new_subtree = Node::parent(pool, level, next_subtree);\n                            root.push_back(new_subtree);\n                            next_subtree = Chunk::new();\n                        }\n                    }\n                }\n            }\n        }\n        if !next_leaf.is_empty() {\n            let new_node = Node::from_chunk(pool, 0, PoolRef::new(&pool.value_pool, next_leaf));\n            next_subtree.push_back(new_node);\n        }\n        if !next_node.is_empty() {\n            let new_node = Node::parent(pool, level - 1, next_node);\n            next_subtree.push_back(new_node);\n        }\n        if !next_subtree.is_empty() {\n            let new_subtree = Node::parent(pool, level, next_subtree);\n            root.push_back(new_subtree);\n        }\n        Node::parent(pool, level + 1, root)\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::new":["pub(crate) fn new() -> Self{\n        Node { children: Empty }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::number_of_children":["#[allow(dead_code)]\npub(crate) fn number_of_children(&self) -> usize{\n        self.children.len()\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::parent":["pub(crate) fn parent(pool: &RRBPool<A>, level: usize, children: Chunk<Self>) -> Self{\n        let size = {\n            let mut size = Size::Size(0);\n            let mut it = children.iter().peekable();\n            loop {\n                match it.next() {\n                    None => break,\n                    Some(child) => {\n                        if size.is_size()\n                            && !child.is_completely_dense(level - 1)\n                            && it.peek().is_some()\n                        {\n                            size = Size::table_from_size(&pool.size_pool, level, size.size());\n                        }\n                        size.push(&pool.size_pool, Right, level, child.len())\n                    }\n                }\n            }\n            size\n        };\n        Node {\n            children: Nodes(size, PoolRef::new(&pool.node_pool, children)),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::pop_child_node":["fn pop_child_node(&mut self, pool: &RRBPool<A>, side: Side) -> Node<A>{\n        let children = self.children.unwrap_nodes_mut(pool);\n        match side {\n            Left => children.pop_front(),\n            Right => children.pop_back(),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::pop_chunk":["pub(crate) fn pop_chunk(\n        &mut self,\n        pool: &RRBPool<A>,\n        level: usize,\n        side: Side,\n    ) -> PopResult<PoolRef<Chunk<A>>>{\n        if self.is_empty() {\n            return PopResult::Empty;\n        }\n        if level == 0 {\n            // should only get here if the tree is just one leaf node\n            match replace(&mut self.children, Empty) {\n                Values(chunk) => PopResult::Drained(chunk),\n                Empty => panic!(\"rrb::Node::pop_chunk: non-empty tree with Empty leaf\"),\n                Nodes(_, _) => panic!(\"rrb::Node::pop_chunk: branch node at leaf\"),\n            }\n        } else if level == 1 {\n            let child_node = self.pop_child_node(pool, side);\n            self.pop_size(pool, side, level, child_node.len());\n            let chunk = match child_node.children {\n                Values(ref chunk) => chunk.clone(),\n                Empty => panic!(\"rrb::Node::pop_chunk: non-empty tree with Empty leaf\"),\n                Nodes(_, _) => panic!(\"rrb::Node::pop_chunk: branch node at leaf\"),\n            };\n            if self.is_empty() {\n                PopResult::Drained(chunk)\n            } else {\n                PopResult::Done(chunk)\n            }\n        } else {\n            let index = match side {\n                Right => self.children.len() - 1,\n                Left => 0,\n            };\n            let mut drained = false;\n            let chunk = {\n                let children = self.children.unwrap_nodes_mut(pool);\n                let child = &mut children[index];\n                match child.pop_chunk(pool, level - 1, side) {\n                    PopResult::Empty => return PopResult::Empty,\n                    PopResult::Done(chunk) => chunk,\n                    PopResult::Drained(chunk) => {\n                        drained = true;\n                        chunk\n                    }\n                }\n            };\n            if drained {\n                self.pop_size(pool, side, level, chunk.len());\n                self.pop_child_node(pool, side);\n                if self.is_empty() {\n                    PopResult::Drained(chunk)\n                } else {\n                    PopResult::Done(chunk)\n                }\n            } else {\n                self.update_size(pool, index, level, -(chunk.len() as isize));\n                PopResult::Done(chunk)\n            }\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::pop_size":["#[inline]\nfn pop_size(&mut self, pool: &RRBPool<A>, side: Side, level: usize, value: usize){\n        if let Entry::Nodes(ref mut size, _) = self.children {\n            size.pop(&pool.size_pool, side, level, value)\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::push_child_node":["fn push_child_node(&mut self, pool: &RRBPool<A>, side: Side, child: Node<A>){\n        let children = self.children.unwrap_nodes_mut(pool);\n        match side {\n            Left => children.push_front(child),\n            Right => children.push_back(child),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::push_chunk":["pub(crate) fn push_chunk(\n        &mut self,\n        pool: &RRBPool<A>,\n        level: usize,\n        side: Side,\n        mut chunk: PoolRef<Chunk<A>>,\n    ) -> PushResult<PoolRef<Chunk<A>>>{\n        if chunk.is_empty() {\n            return PushResult::Done;\n        }\n        let is_full = self.is_full();\n        if level == 0 {\n            if self.children.is_empty_node() {\n                self.push_size(pool, side, level, chunk.len());\n                self.children = Values(chunk);\n                PushResult::Done\n            } else {\n                let values = self.children.unwrap_values_mut(pool);\n                if values.len() + chunk.len() <= NODE_SIZE {\n                    let chunk = PoolRef::make_mut(&pool.value_pool, &mut chunk);\n                    match side {\n                        Side::Left => {\n                            chunk.append(values);\n                            values.append(chunk);\n                        }\n                        Side::Right => values.append(chunk),\n                    }\n                    PushResult::Done\n                } else {\n                    PushResult::Full(chunk, 0)\n                }\n            }\n        } else if level == 1 {\n            // If rightmost existing node has any room, merge as much as\n            // possible over from the new node.\n            let num_drained = match side {\n                Side::Right => {\n                    if let Entry::Nodes(ref mut size, ref mut children) = self.children {\n                        let rightmost = PoolRef::make_mut(&pool.node_pool, children)\n                            .last_mut()\n                            .unwrap();\n                        let old_size = rightmost.len();\n                        let chunk = PoolRef::make_mut(&pool.value_pool, &mut chunk);\n                        let values = rightmost.children.unwrap_values_mut(pool);\n                        let to_drain = chunk.len().min(NODE_SIZE - values.len());\n                        values.drain_from_front(chunk, to_drain);\n                        size.pop(&pool.size_pool, Side::Right, level, old_size);\n                        size.push(&pool.size_pool, Side::Right, level, values.len());\n                        to_drain\n                    } else {\n                        0\n                    }\n                }\n                Side::Left => {\n                    if let Entry::Nodes(ref mut size, ref mut children) = self.children {\n                        let leftmost = PoolRef::make_mut(&pool.node_pool, children)\n                            .first_mut()\n                            .unwrap();\n                        let old_size = leftmost.len();\n                        let chunk = PoolRef::make_mut(&pool.value_pool, &mut chunk);\n                        let values = leftmost.children.unwrap_values_mut(pool);\n                        let to_drain = chunk.len().min(NODE_SIZE - values.len());\n                        values.drain_from_back(chunk, to_drain);\n                        size.pop(&pool.size_pool, Side::Left, level, old_size);\n                        size.push(&pool.size_pool, Side::Left, level, values.len());\n                        to_drain\n                    } else {\n                        0\n                    }\n                }\n            };\n            if is_full {\n                PushResult::Full(chunk, num_drained)\n            } else {\n                // If the chunk is empty after being drained, there might be\n                // more space in existing chunks. To keep the middle dense, we\n                // do not add it here.\n                if !chunk.is_empty() {\n                    if side == Left && chunk.len() < NODE_SIZE {\n                        if let Entry::Nodes(ref mut size, _) = self.children {\n                            if let Size::Size(value) = *size {\n                                *size = Size::table_from_size(&pool.size_pool, level, value);\n                            }\n                        }\n                    }\n                    self.push_size(pool, side, level, chunk.len());\n                    self.push_child_node(pool, side, Node::from_chunk(pool, 0, chunk));\n                }\n                PushResult::Done\n            }\n        } else {\n            let chunk_size = chunk.len();\n            let index = match side {\n                Right => self.children.len() - 1,\n                Left => 0,\n            };\n            let new_child = {\n                let children = self.children.unwrap_nodes_mut(pool);\n                let child = &mut children[index];\n                match child.push_chunk(pool, level - 1, side, chunk) {\n                    PushResult::Done => None,\n                    PushResult::Full(chunk, num_drained) => {\n                        // Our chunk was too large for `child`, so it could not\n                        // be pushed there. However, exactly `num_drained`\n                        // elements were added to the child. We need to reflect\n                        // that change in the size field of the node.\n                        match side {\n                            Right => match self.children {\n                                Entry::Nodes(Size::Table(ref mut sizes), _) => {\n                                    let sizes = PoolRef::make_mut(&pool.size_pool, sizes);\n                                    sizes[index] += num_drained;\n                                }\n                                Entry::Nodes(Size::Size(ref mut size), _) => {\n                                    *size += num_drained;\n                                }\n                                Entry::Values(_) | Entry::Empty => (),\n                            },\n                            Left => {\n                                self.update_size(pool, 0, level, num_drained as isize);\n                            }\n                        }\n                        if is_full {\n                            return PushResult::Full(chunk, 0);\n                        } else {\n                            Some(Node::from_chunk(pool, level - 1, chunk))\n                        }\n                    }\n                }\n            };\n            match new_child {\n                None => {\n                    self.update_size(pool, index, level, chunk_size as isize);\n                    PushResult::Done\n                }\n                Some(child) => {\n                    if side == Left && chunk_size < NODE_SIZE {\n                        if let Entry::Nodes(ref mut size, _) = self.children {\n                            if let Size::Size(value) = *size {\n                                *size = Size::table_from_size(&pool.size_pool, level, value);\n                            }\n                        }\n                    }\n                    self.push_size(pool, side, level, child.len());\n                    self.push_child_node(pool, side, child);\n                    PushResult::Done\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::push_size":["#[inline]\nfn push_size(&mut self, pool: &RRBPool<A>, side: Side, level: usize, value: usize){\n        if let Entry::Nodes(ref mut size, _) = self.children {\n            size.push(&pool.size_pool, side, level, value)\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::single_parent":["pub(crate) fn single_parent(pool: &RRBPool<A>, node: Self) -> Self{\n        let size = if node.is_dense() {\n            Size::Size(node.len())\n        } else {\n            let size_table = Chunk::unit(node.len());\n            Size::Table(PoolRef::new(&pool.size_pool, size_table))\n        };\n        let children = PoolRef::new(&pool.node_pool, Chunk::unit(node));\n        Node {\n            children: Nodes(size, children),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::size":["#[inline]\nfn size(&self) -> usize{\n        match self.children {\n            Entry::Nodes(ref size, _) => size.size(),\n            Entry::Values(ref values) => values.len(),\n            Entry::Empty => 0,\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::size_up_to":["fn size_up_to(&self, level: usize, index: usize) -> usize{\n        if let Entry::Nodes(ref size, _) = self.children {\n            if index == 0 {\n                0\n            } else {\n                match size {\n                    Size::Table(ref size_table) => size_table[index - 1],\n                    Size::Size(_) => index * NODE_SIZE.pow(level as u32),\n                }\n            }\n        } else {\n            index\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::split":["pub(crate) fn split(\n        &mut self,\n        pool: &RRBPool<A>,\n        level: usize,\n        drop_side: Side,\n        index: usize,\n    ) -> SplitResult{\n        if index == 0 && drop_side == Side::Left {\n            // Dropped nothing\n            return SplitResult::Dropped(0);\n        }\n        if level > 0 && index == 0 && drop_side == Side::Right {\n            // Dropped everything\n            let dropped = if let Entry::Nodes(ref size, _) = self.children {\n                size.size()\n            } else {\n                panic!(\"leaf node at non-leaf level!\");\n            };\n            self.children = Entry::Empty;\n            return SplitResult::Dropped(dropped);\n        }\n        let mut dropped;\n        if level == 0 {\n            let len = self.children.len();\n            if index >= len {\n                return SplitResult::OutOfBounds;\n            }\n            let children = self.children.unwrap_values_mut(pool);\n            match drop_side {\n                Side::Left => children.drop_left(index),\n                Side::Right => children.drop_right(index),\n            }\n            SplitResult::Dropped(match drop_side {\n                Left => index,\n                Right => len - index,\n            })\n        } else if let Some(target_idx) = self.index_in(level, index) {\n            let size_up_to = self.size_up_to(level, target_idx);\n            let (size, children) =\n                if let Entry::Nodes(ref mut size, ref mut children) = self.children {\n                    (size, PoolRef::make_mut(&pool.node_pool, children))\n                } else {\n                    unreachable!()\n                };\n            let child_gone = 0 == {\n                let child_node = &mut children[target_idx];\n                match child_node.split(pool, level - 1, drop_side, index - size_up_to) {\n                    SplitResult::OutOfBounds => return SplitResult::OutOfBounds,\n                    SplitResult::Dropped(amount) => dropped = amount,\n                }\n                child_node.len()\n            };\n            match drop_side {\n                Left => {\n                    let mut drop_from = target_idx;\n                    if child_gone {\n                        drop_from += 1;\n                    }\n                    children.drop_left(drop_from);\n                    if let Size::Size(value) = *size {\n                        *size = Size::table_from_size(&pool.size_pool, level, value);\n                    }\n                    let size_table = if let Size::Table(ref mut size_ref) = size {\n                        PoolRef::make_mut(&pool.size_pool, size_ref)\n                    } else {\n                        unreachable!()\n                    };\n                    let dropped_size = if target_idx > 0 {\n                        size_table[target_idx - 1]\n                    } else {\n                        0\n                    };\n                    dropped += dropped_size;\n                    size_table.drop_left(drop_from);\n                    for i in size_table.iter_mut() {\n                        *i -= dropped;\n                    }\n                }\n                Right => {\n                    let at_last = target_idx == children.len() - 1;\n                    let mut drop_from = target_idx + 1;\n                    if child_gone {\n                        drop_from -= 1;\n                    }\n                    if drop_from < children.len() {\n                        children.drop_right(drop_from);\n                    }\n                    match size {\n                        Size::Size(ref mut size) if at_last => {\n                            *size -= dropped;\n                        }\n                        Size::Size(ref mut size) => {\n                            let size_per_child = NODE_SIZE.pow(level as u32);\n                            let remainder = (target_idx + 1) * size_per_child;\n                            let new_size = remainder - dropped;\n                            if new_size < *size {\n                                dropped = *size - new_size;\n                                *size = new_size;\n                            } else {\n                                unreachable!(\n                                    \"this means node is empty, should be caught at start of method\"\n                                );\n                            }\n                        }\n                        Size::Table(ref mut size_ref) => {\n                            let size_table = PoolRef::make_mut(&pool.size_pool, size_ref);\n                            let dropped_size =\n                                size_table[size_table.len() - 1] - size_table[target_idx];\n                            if drop_from < size_table.len() {\n                                size_table.drop_right(drop_from);\n                            }\n                            if !child_gone {\n                                size_table[target_idx] -= dropped;\n                            }\n                            dropped += dropped_size;\n                        }\n                    }\n                }\n            }\n            SplitResult::Dropped(dropped)\n        } else {\n            SplitResult::OutOfBounds\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Node::<A>::update_size":["#[inline]\nfn update_size(&mut self, pool: &RRBPool<A>, index: usize, level: usize, value: isize){\n        if let Entry::Nodes(ref mut size, _) = self.children {\n            size.update(&pool.size_pool, index, level, value)\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::PopResult":["pub(crate) enum PopResult<A> {\n    Done(A),\n    Drained(A),\n    Empty,\n}","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::PushResult":["pub(crate) enum PushResult<A> {\n    Full(A, usize),\n    Done,\n}","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Size":["enum Size {\n    Size(usize),\n    Table(PoolRef<Chunk<usize>>),\n}","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Size::is_size":["fn is_size(&self) -> bool{\n        match self {\n            Size::Size(_) => true,\n            Size::Table(_) => false,\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Size::pop":["fn pop(&mut self, pool: &Pool<Chunk<usize>>, side: Side, level: usize, value: usize){\n        let size = match self {\n            Size::Size(ref mut size) => match side {\n                Left => *size,\n                Right => {\n                    *size -= value;\n                    return;\n                }\n            },\n            Size::Table(ref mut size_ref) => {\n                let size_table = PoolRef::make_mut(pool, size_ref);\n                match side {\n                    Left => {\n                        let first = size_table.pop_front();\n                        debug_assert_eq!(value, first);\n                        for entry in size_table.iter_mut() {\n                            *entry -= value;\n                        }\n                    }\n                    Right => {\n                        let pop = size_table.pop_back();\n                        let last = size_table.last().unwrap_or(&0);\n                        debug_assert_eq!(value, pop - last);\n                    }\n                }\n                return;\n            }\n        };\n        *self = Size::table_from_size(pool, level, size);\n        self.pop(pool, side, level, value);\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Size::push":["fn push(&mut self, pool: &Pool<Chunk<usize>>, side: Side, level: usize, value: usize){\n        let size = match self {\n            Size::Size(ref mut size) => match side {\n                Left => *size,\n                Right => {\n                    *size += value;\n                    return;\n                }\n            },\n            Size::Table(ref mut size_ref) => {\n                let size_table = PoolRef::make_mut(pool, size_ref);\n                debug_assert!(size_table.len() < NODE_SIZE);\n                match side {\n                    Left => {\n                        for entry in size_table.iter_mut() {\n                            *entry += value;\n                        }\n                        size_table.push_front(value);\n                    }\n                    Right => {\n                        let prev = *(size_table.last().unwrap_or(&0));\n                        size_table.push_back(value + prev);\n                    }\n                }\n                return;\n            }\n        };\n        *self = Size::table_from_size(pool, level, size);\n        self.push(pool, side, level, value);\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Size::size":["fn size(&self) -> usize{\n        match self {\n            Size::Size(s) => *s,\n            Size::Table(sizes) => *sizes.last().unwrap_or(&0),\n        }\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Size::table_from_size":["fn table_from_size(pool: &Pool<Chunk<usize>>, level: usize, size: usize) -> Self{\n        let mut chunk = Chunk::new();\n        let mut remaining = size;\n        if let Some(child_size) = NODE_SIZE.checked_pow(level as u32) {\n            while remaining > child_size {\n                let next_value = chunk.last().unwrap_or(&0) + child_size;\n                chunk.push_back(next_value);\n                remaining -= child_size;\n            }\n        }\n        if remaining > 0 {\n            let next_value = chunk.last().unwrap_or(&0) + remaining;\n            chunk.push_back(next_value);\n        }\n        Size::Table(PoolRef::new(pool, chunk))\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::Size::update":["fn update(&mut self, pool: &Pool<Chunk<usize>>, index: usize, level: usize, value: isize){\n        let size = match self {\n            Size::Size(ref size) => *size,\n            Size::Table(ref mut size_ref) => {\n                let size_table = PoolRef::make_mut(pool, size_ref);\n                for entry in size_table.iter_mut().skip(index) {\n                    *entry = (*entry as isize + value) as usize;\n                }\n                return;\n            }\n        };\n        *self = Size::table_from_size(pool, level, size);\n        self.update(pool, index, level, value);\n    }","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"nodes::rrb::SplitResult":["pub(crate) enum SplitResult {\n    Dropped(usize),\n    OutOfBounds,\n}","Real(LocalPath(\"src/nodes/rrb.rs\"))"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::cmp_keys":["fn cmp_keys<BK>(&self, other: &BK) -> Ordering\n    where\n        BK: Ord + ?Sized,\n        Self::Key: Borrow<BK>,{\n        Self::Key::borrow(&self.0).cmp(other)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::cmp_values":["fn cmp_values(&self, other: &Self) -> Ordering{\n        self.0.cmp(&other.0)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::ptr_eq":["fn ptr_eq(&self, _other: &Self) -> bool{\n        false\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::search_key":["fn search_key<BK>(slice: &[Self], key: &BK) -> Result<usize, usize>\n    where\n        BK: Ord + ?Sized,\n        Self::Key: Borrow<BK>,{\n        linear_search_by(slice, |value| Self::Key::borrow(&value.0).cmp(key))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::search_value":["fn search_value(slice: &[Self], key: &Self) -> Result<usize, usize>{\n        linear_search_by(slice, |value| value.0.cmp(&key.0))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::DiffItem":["/// A description of a difference between two ordered maps.\npub enum DiffItem<'a, K, V> {\n    /// This value has been added to the new map.\n    Add(&'a K, &'a V),\n    /// This value has been changed between the two maps.\n    Update {\n        /// The old value.\n        old: (&'a K, &'a V),\n        /// The new value.\n        new: (&'a K, &'a V),\n    },\n    /// This value has been removed from the new map.\n    Remove(&'a K, &'a V),\n}","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::DiffIter":["/// An iterator over the differences between two maps.\npub struct DiffIter<'a, K, V> {\n    it: NodeDiffIter<'a, (K, V)>,\n}","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::Entry":["/// A handle for a key and its associated value.\npub enum Entry<'a, K, V>\nwhere\n    K: Ord + Clone,\n    V: Clone,\n{\n    /// An entry which exists in the map.\n    Occupied(OccupiedEntry<'a, K, V>),\n    /// An entry which doesn't exist in the map.\n    Vacant(VacantEntry<'a, K, V>),\n}","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::Entry::<'a, K, V>::and_modify":["/// Call the provided function to modify the value if the value\n/// exists.\npub fn and_modify<F>(mut self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),{\n        match &mut self {\n            Entry::Occupied(ref mut entry) => f(entry.get_mut()),\n            Entry::Vacant(_) => (),\n        }\n        self\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::Entry::<'a, K, V>::key":["/// Get the key for this entry.\n#[must_use]\npub fn key(&self) -> &K{\n        match self {\n            Entry::Occupied(entry) => entry.key(),\n            Entry::Vacant(entry) => entry.key(),\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::Entry::<'a, K, V>::or_default":["/// Insert a default value if there was no value already, and\n/// return a mutable reference to the value.\npub fn or_default(self) -> &'a mut V\n    where\n        V: Default,{\n        self.or_insert_with(Default::default)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::Entry::<'a, K, V>::or_insert":["/// Insert the default value provided if there was no value\n/// already, and return a mutable reference to the value.\npub fn or_insert(self, default: V) -> &'a mut V{\n        self.or_insert_with(|| default)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::Entry::<'a, K, V>::or_insert_with":["/// Insert the default value from the provided function if there\n/// was no value already, and return a mutable reference to the\n/// value.\npub fn or_insert_with<F>(self, default: F) -> &'a mut V\n    where\n        F: FnOnce() -> V,{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default()),\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::Iter":["/// An iterator over the key/value pairs of a map.\npub struct Iter<'a, K, V> {\n    it: RangedIter<'a, (K, V)>,\n}","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::Keys":["/// An iterator ove the keys of a map.\npub struct Keys<'a, K, V> {\n    it: Iter<'a, K, V>,\n}","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OccupiedEntry":["/// An entry for a mapping that already exists in the map.\npub struct OccupiedEntry<'a, K, V>\nwhere\n    K: Ord + Clone,\n    V: Clone,\n{\n    map: &'a mut OrdMap<K, V>,\n    key: K,\n}","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OccupiedEntry::<'a, K, V>::get":["/// Get the current value.\n#[must_use]\npub fn get(&self) -> &V{\n        self.map.get(&self.key).unwrap()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OccupiedEntry::<'a, K, V>::get_mut":["/// Get a mutable reference to the current value.\n#[must_use]\npub fn get_mut(&mut self) -> &mut V{\n        self.map.get_mut(&self.key).unwrap()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OccupiedEntry::<'a, K, V>::insert":["/// Overwrite the current value.\npub fn insert(&mut self, value: V) -> V{\n        mem::replace(self.get_mut(), value)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OccupiedEntry::<'a, K, V>::into_mut":["/// Convert this entry into a mutable reference.\n#[must_use]\npub fn into_mut(self) -> &'a mut V{\n        self.map.get_mut(&self.key).unwrap()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OccupiedEntry::<'a, K, V>::key":["/// Get the key for this entry.\n#[must_use]\npub fn key(&self) -> &K{\n        &self.key\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OccupiedEntry::<'a, K, V>::remove":["/// Remove this entry from the map and return the removed value.\npub fn remove(self) -> V{\n        self.remove_entry().1\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OccupiedEntry::<'a, K, V>::remove_entry":["/// Remove this entry from the map and return the removed mapping.\npub fn remove_entry(self) -> (K, V){\n        self.map\n            .remove_with_key(&self.key)\n            .expect(\"ordmap::OccupiedEntry::remove_entry: key has vanished!\")\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap":["/// An ordered map.\n///\n/// An immutable ordered map implemented as a B-tree.\n///\n/// Most operations on this type of map are O(log n). A\n/// [`HashMap`][hashmap::HashMap] is usually a better choice for\n/// performance, but the `OrdMap` has the advantage of only requiring\n/// an [`Ord`][std::cmp::Ord] constraint on the key, and of being\n/// ordered, so that keys always come out from lowest to highest,\n/// where a [`HashMap`][hashmap::HashMap] has no guaranteed ordering.\n///\n/// [hashmap::HashMap]: ../hashmap/struct.HashMap.html\n/// [std::cmp::Ord]: https://doc.rust-lang.org/std/cmp/trait.Ord.html\npub struct OrdMap<K, V> {\n    size: usize,\n    pool: OrdMapPool<K, V>,\n    root: PoolRef<Node<(K, V)>>,\n}","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::alter":["/// Update the value for a given key by calling a function with\n/// the current value and overwriting it with the function's\n/// return value.\n///\n/// The function gets an [`Option<V>`][std::option::Option] and\n/// returns the same, so that it can decide to delete a mapping\n/// instead of updating the value, and decide what to do if the\n/// key isn't in the map.\n///\n/// Time: O(log n)\n///\n/// [std::option::Option]: https://doc.rust-lang.org/std/option/enum.Option.html\n#[must_use]\npub fn alter<F>(&self, f: F, k: K) -> Self\n    where\n        F: FnOnce(Option<V>) -> Option<V>,{\n        let pop = self.extract_with_key(&k);\n        match (f(pop.as_ref().map(|&(_, ref v, _)| v.clone())), pop) {\n            (None, None) => self.clone(),\n            (Some(v), None) => self.update(k, v),\n            (None, Some((_, _, m))) => m,\n            (Some(v), Some((_, _, m))) => m.update(k, v),\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::clear":["/// Discard all elements from the map.\n///\n/// This leaves you with an empty map, and all elements that\n/// were previously inside it are dropped.\n///\n/// Time: O(n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::OrdMap;\n/// let mut map = ordmap![1=>1, 2=>2, 3=>3];\n/// map.clear();\n/// assert!(map.is_empty());\n/// ```\npub fn clear(&mut self){\n        if !self.is_empty() {\n            self.root = PoolRef::default(&self.pool.0);\n            self.size = 0;\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::contains_key":["/// Test for the presence of a key in a map.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map = ordmap!{123 => \"lol\"};\n/// assert!(\n///   map.contains_key(&123)\n/// );\n/// assert!(\n///   !map.contains_key(&321)\n/// );\n/// ```\n#[must_use]\npub fn contains_key<BK>(&self, k: &BK) -> bool\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        self.get(k).is_some()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::diff":["/// Get an iterator over the differences between this map and\n/// another, i.e. the set of entries to add, update, or remove to\n/// this map in order to make it equal to the other map.\n///\n/// This function will avoid visiting nodes which are shared\n/// between the two maps, meaning that even very large maps can be\n/// compared quickly if most of their structure is shared.\n///\n/// Time: O(n) (where n is the number of unique elements across\n/// the two maps, minus the number of elements belonging to nodes\n/// shared between them)\n#[must_use]\npub fn diff<'a>(&'a self, other: &'a Self) -> DiffIter<'a, K, V>{\n        DiffIter {\n            it: NodeDiffIter::new(&self.root, &other.root),\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::difference":["/// Construct the symmetric difference between two maps by discarding keys\n/// which occur in both maps.\n///\n/// This is an alias for the\n/// [`symmetric_difference`][symmetric_difference] method.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 3 => 4};\n/// let map2 = ordmap!{2 => 2, 3 => 5};\n/// let expected = ordmap!{1 => 1, 2 => 2};\n/// assert_eq!(expected, map1.difference(map2));\n/// ```\n///\n/// [symmetric_difference]: #method.symmetric_difference\n#[inline]\n#[must_use]\npub fn difference(self, other: Self) -> Self{\n        self.symmetric_difference(other)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::difference_with":["/// Construct the symmetric difference between two maps by using a function\n/// to decide what to do if a key occurs in both.\n///\n/// This is an alias for the\n/// [`symmetric_difference_with`][symmetric_difference_with] method.\n///\n/// Time: O(n log n)\n///\n/// [symmetric_difference_with]: #method.symmetric_difference_with\n#[inline]\n#[must_use]\npub fn difference_with<F>(self, other: Self, f: F) -> Self\n    where\n        F: FnMut(V, V) -> Option<V>,{\n        self.symmetric_difference_with(other, f)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::difference_with_key":["/// Construct the symmetric difference between two maps by using a function\n/// to decide what to do if a key occurs in both. The function\n/// receives the key as well as both values.\n///\n/// This is an alias for the\n/// [`symmetric_difference_with_key`][symmetric_difference_with_key]\n/// method.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 3 => 4};\n/// let map2 = ordmap!{2 => 2, 3 => 5};\n/// let expected = ordmap!{1 => 1, 2 => 2, 3 => 9};\n/// assert_eq!(expected, map1.difference_with_key(\n///     map2,\n///     |key, left, right| Some(left + right)\n/// ));\n/// ```\n/// [symmetric_difference_with_key]: #method.symmetric_difference_with_key\n#[must_use]\npub fn difference_with_key<F>(self, other: Self, f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> Option<V>,{\n        self.symmetric_difference_with_key(other, f)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::entry":["/// Get the [`Entry`][Entry] for a key in the map for in-place manipulation.\n///\n/// Time: O(log n)\n///\n/// [Entry]: enum.Entry.html\n#[must_use]\npub fn entry(&mut self, key: K) -> Entry<'_, K, V>{\n        if self.contains_key(&key) {\n            Entry::Occupied(OccupiedEntry { map: self, key })\n        } else {\n            Entry::Vacant(VacantEntry { map: self, key })\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::extract":["/// Remove a key/value pair from a map, if it exists, and return\n/// the removed value as well as the updated list.\n///\n/// Time: O(log n)\n#[must_use]\npub fn extract<BK>(&self, k: &BK) -> Option<(V, Self)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        self.extract_with_key(k).map(|(_, v, m)| (v, m))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::extract_with_key":["/// Remove a key/value pair from a map, if it exists, and return\n/// the removed key and value as well as the updated list.\n///\n/// Time: O(log n)\n#[must_use]\npub fn extract_with_key<BK>(&self, k: &BK) -> Option<(K, V, Self)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        let mut out = self.clone();\n        let result = out.remove_with_key(k);\n        result.map(|(k, v)| (k, v, out))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::get":["/// Get the value for a key from a map.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map = ordmap!{123 => \"lol\"};\n/// assert_eq!(\n///   map.get(&123),\n///   Some(&\"lol\")\n/// );\n/// ```\n#[must_use]\npub fn get<BK>(&self, key: &BK) -> Option<&V>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        self.root.lookup(key).map(|(_, v)| v)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::get_key_value":["/// Get the key/value pair for a key from a map.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map = ordmap!{123 => \"lol\"};\n/// assert_eq!(\n///   map.get_key_value(&123),\n///   Some((&123, &\"lol\"))\n/// );\n/// ```\n#[must_use]\npub fn get_key_value<BK>(&self, key: &BK) -> Option<(&K, &V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        self.root.lookup(key).map(|&(ref k, ref v)| (k, v))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::get_max":["/// Get the largest key in a map, along with its value. If the map\n/// is empty, return `None`.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// assert_eq!(Some(&(3, 33)), ordmap!{\n///   1 => 11,\n///   2 => 22,\n///   3 => 33\n/// }.get_max());\n/// ```\n#[must_use]\npub fn get_max(&self) -> Option<&(K, V)>{\n        self.root.max()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::get_min":["/// Get the smallest key in a map, along with its value. If the\n/// map is empty, return `None`.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// assert_eq!(Some(&(1, 11)), ordmap!{\n///   1 => 11,\n///   2 => 22,\n///   3 => 33\n/// }.get_min());\n/// ```\n#[must_use]\npub fn get_min(&self) -> Option<&(K, V)>{\n        self.root.min()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::get_mut":["/// Get a mutable reference to the value for a key from a map.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let mut map = ordmap!{123 => \"lol\"};\n/// if let Some(value) = map.get_mut(&123) {\n///     *value = \"omg\";\n/// }\n/// assert_eq!(\n///   map.get(&123),\n///   Some(&\"omg\")\n/// );\n/// ```\n#[must_use]\npub fn get_mut<BK>(&mut self, key: &BK) -> Option<&mut V>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n        root.lookup_mut(&self.pool.0, key).map(|(_, v)| v)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::get_next":["/// Get the closest larger entry in a map to a given key\n/// as a mutable reference.\n///\n/// If the set contains the given value, this is returned.\n/// Otherwise, the closest value in the set larger than the\n/// given value is returned. If the largest value in the set\n/// is smaller than the given value, `None` is returned.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::OrdMap;\n/// let map = ordmap![1 => 1, 3 => 3, 5 => 5];\n/// assert_eq!(Some((&5, &5)), map.get_next(&4));\n/// ```\n#[must_use]\npub fn get_next<BK>(&self, key: &BK) -> Option<(&K, &V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        self.root.lookup_next(key).map(|(k, v)| (k, v))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::get_next_mut":["/// Get the closest larger entry in a map to a given key\n/// as a mutable reference.\n///\n/// If the set contains the given value, this is returned.\n/// Otherwise, the closest value in the set larger than the\n/// given value is returned. If the largest value in the set\n/// is smaller than the given value, `None` is returned.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::OrdMap;\n/// let mut map = ordmap![1 => 1, 3 => 3, 5 => 5];\n/// if let Some((key, value)) = map.get_next_mut(&4) {\n///     *value = 4;\n/// }\n/// assert_eq!(ordmap![1 => 1, 3 => 3, 5 => 4], map);\n/// ```\n#[must_use]\npub fn get_next_mut<BK>(&mut self, key: &BK) -> Option<(&K, &mut V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        let pool = &self.pool.0;\n        PoolRef::make_mut(pool, &mut self.root)\n            .lookup_next_mut(pool, key)\n            .map(|(ref k, ref mut v)| (k, v))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::get_prev":["/// Get the closest smaller entry in a map to a given key\n/// as a mutable reference.\n///\n/// If the map contains the given key, this is returned.\n/// Otherwise, the closest key in the map smaller than the\n/// given value is returned. If the smallest key in the map\n/// is larger than the given key, `None` is returned.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::OrdMap;\n/// let map = ordmap![1 => 1, 3 => 3, 5 => 5];\n/// assert_eq!(Some((&3, &3)), map.get_prev(&4));\n/// ```\n#[must_use]\npub fn get_prev<BK>(&self, key: &BK) -> Option<(&K, &V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        self.root.lookup_prev(key).map(|(k, v)| (k, v))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::get_prev_mut":["/// Get the closest smaller entry in a map to a given key\n/// as a mutable reference.\n///\n/// If the map contains the given key, this is returned.\n/// Otherwise, the closest key in the map smaller than the\n/// given value is returned. If the smallest key in the map\n/// is larger than the given key, `None` is returned.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::OrdMap;\n/// let mut map = ordmap![1 => 1, 3 => 3, 5 => 5];\n/// if let Some((key, value)) = map.get_prev_mut(&4) {\n///     *value = 4;\n/// }\n/// assert_eq!(ordmap![1 => 1, 3 => 4, 5 => 5], map);\n/// ```\n#[must_use]\npub fn get_prev_mut<BK>(&mut self, key: &BK) -> Option<(&K, &mut V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        let pool = &self.pool.0;\n        PoolRef::make_mut(pool, &mut self.root)\n            .lookup_prev_mut(pool, key)\n            .map(|(ref k, ref mut v)| (k, v))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::insert":["/// Insert a key/value mapping into a map.\n///\n/// This is a copy-on-write operation, so that the parts of the\n/// map's structure which are shared with other maps will be\n/// safely copied before mutating.\n///\n/// If the map already has a mapping for the given key, the\n/// previous value is overwritten.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let mut map = ordmap!{};\n/// map.insert(123, \"123\");\n/// map.insert(456, \"456\");\n/// assert_eq!(\n///   map,\n///   ordmap!{123 => \"123\", 456 => \"456\"}\n/// );\n/// ```\n///\n/// [insert]: #method.insert\n#[inline]\npub fn insert(&mut self, key: K, value: V) -> Option<V>{\n        let new_root = {\n            let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n            match root.insert(&self.pool.0, (key, value)) {\n                Insert::Replaced((_, old_value)) => return Some(old_value),\n                Insert::Added => {\n                    self.size += 1;\n                    return None;\n                }\n                Insert::Split(left, median, right) => PoolRef::new(\n                    &self.pool.0,\n                    Node::new_from_split(&self.pool.0, left, median, right),\n                ),\n            }\n        };\n        self.size += 1;\n        self.root = new_root;\n        None\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::intersection":["/// Construct the intersection of two maps, keeping the values\n/// from the current map.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 2 => 2};\n/// let map2 = ordmap!{2 => 3, 3 => 4};\n/// let expected = ordmap!{2 => 2};\n/// assert_eq!(expected, map1.intersection(map2));\n/// ```\n#[inline]\n#[must_use]\npub fn intersection(self, other: Self) -> Self{\n        self.intersection_with_key(other, |_, v, _| v)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::intersection_with":["/// Construct the intersection of two maps, calling a function\n/// with both values for each key and using the result as the\n/// value for the key.\n///\n/// Time: O(n log n)\n#[inline]\n#[must_use]\npub fn intersection_with<B, C, F>(self, other: OrdMap<K, B>, mut f: F) -> OrdMap<K, C>\n    where\n        B: Clone,\n        C: Clone,\n        F: FnMut(V, B) -> C,{\n        self.intersection_with_key(other, |_, v1, v2| f(v1, v2))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::intersection_with_key":["/// Construct the intersection of two maps, calling a function\n/// with the key and both values for each key and using the result\n/// as the value for the key.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 2 => 2};\n/// let map2 = ordmap!{2 => 3, 3 => 4};\n/// let expected = ordmap!{2 => 5};\n/// assert_eq!(expected, map1.intersection_with_key(\n///     map2,\n///     |key, left, right| left + right\n/// ));\n/// ```\n#[must_use]\npub fn intersection_with_key<B, C, F>(mut self, other: OrdMap<K, B>, mut f: F) -> OrdMap<K, C>\n    where\n        B: Clone,\n        C: Clone,\n        F: FnMut(&K, V, B) -> C,{\n        let mut out = OrdMap::<K, C>::default();\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => (),\n                Some(left_value) => {\n                    let result = f(&key, left_value, right_value);\n                    out.insert(key, result);\n                }\n            }\n        }\n        out\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::is_empty":["/// Test whether a map is empty.\n///\n/// Time: O(1)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// assert!(\n///   !ordmap!{1 => 2}.is_empty()\n/// );\n/// assert!(\n///   OrdMap::<i32, i32>::new().is_empty()\n/// );\n/// ```\n#[inline]\n#[must_use]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::is_proper_submap":["/// Test whether a map is a proper submap of another map, meaning\n/// that all keys in our map must also be in the other map, with\n/// the same values. To be a proper submap, ours must also contain\n/// fewer keys than the other map.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 2 => 2};\n/// let map2 = ordmap!{1 => 1, 2 => 2, 3 => 3};\n/// assert!(map1.is_proper_submap(map2));\n///\n/// let map3 = ordmap!{1 => 1, 2 => 2};\n/// let map4 = ordmap!{1 => 1, 2 => 2};\n/// assert!(!map3.is_proper_submap(map4));\n/// ```\n#[must_use]\npub fn is_proper_submap<RM>(&self, other: RM) -> bool\n    where\n        V: PartialEq,\n        RM: Borrow<Self>,{\n        self.is_proper_submap_by(other.borrow(), PartialEq::eq)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::is_proper_submap_by":["/// Test whether a map is a proper submap of another map, meaning\n/// that all keys in our map must also be in the other map, with\n/// the same values. To be a proper submap, ours must also contain\n/// fewer keys than the other map.\n///\n/// Use the provided function to decide whether values are equal.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn is_proper_submap_by<B, RM, F>(&self, other: RM, cmp: F) -> bool\n    where\n        F: FnMut(&V, &B) -> bool,\n        RM: Borrow<OrdMap<K, B>>,{\n        self.len() != other.borrow().len() && self.is_submap_by(other, cmp)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::is_submap":["/// Test whether a map is a submap of another map, meaning that\n/// all keys in our map must also be in the other map, with the\n/// same values.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 2 => 2};\n/// let map2 = ordmap!{1 => 1, 2 => 2, 3 => 3};\n/// assert!(map1.is_submap(map2));\n/// ```\n#[must_use]\npub fn is_submap<RM>(&self, other: RM) -> bool\n    where\n        V: PartialEq,\n        RM: Borrow<Self>,{\n        self.is_submap_by(other.borrow(), PartialEq::eq)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::is_submap_by":["/// Test whether a map is a submap of another map, meaning that\n/// all keys in our map must also be in the other map, with the\n/// same values.\n///\n/// Use the provided function to decide whether values are equal.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn is_submap_by<B, RM, F>(&self, other: RM, mut cmp: F) -> bool\n    where\n        F: FnMut(&V, &B) -> bool,\n        RM: Borrow<OrdMap<K, B>>,{\n        self.iter()\n            .all(|(k, v)| other.borrow().get(k).map(|ov| cmp(v, ov)).unwrap_or(false))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::iter":["/// Get an iterator over the key/value pairs of a map.\n#[must_use]\npub fn iter(&self) -> Iter<'_, K, V>{\n        Iter {\n            it: RangedIter::new(&self.root, self.size, ..),\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::keys":["/// Get an iterator over a map's keys.\n#[must_use]\npub fn keys(&self) -> Keys<'_, K, V>{\n        Keys { it: self.iter() }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::len":["/// Get the size of a map.\n///\n/// Time: O(1)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// assert_eq!(3, ordmap!{\n///   1 => 11,\n///   2 => 22,\n///   3 => 33\n/// }.len());\n/// ```\n#[inline]\n#[must_use]\npub fn len(&self) -> usize{\n        self.size\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::new":["/// Construct an empty map.\n#[must_use]\npub fn new() -> Self{\n        let pool = OrdMapPool::default();\n        let root = PoolRef::default(&pool.0);\n        OrdMap {\n            size: 0,\n            pool,\n            root,\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::ptr_eq":["/// Test whether two maps refer to the same content in memory.\n///\n/// This is true if the two sides are references to the same map,\n/// or if the two maps refer to the same root node.\n///\n/// This would return true if you're comparing a map to itself, or\n/// if you're comparing a map to a fresh clone of itself.\n///\n/// Time: O(1)\npub fn ptr_eq(&self, other: &Self) -> bool{\n        std::ptr::eq(self, other) || PoolRef::ptr_eq(&self.root, &other.root)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::range":["/// Create an iterator over a range of key/value pairs.\n#[must_use]\npub fn range<R, BK>(&self, range: R) -> Iter<'_, K, V>\n    where\n        R: RangeBounds<BK>,\n        K: Borrow<BK>,\n        BK: Ord + ?Sized,{\n        Iter {\n            it: RangedIter::new(&self.root, self.size, range),\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::relative_complement":["/// Construct the relative complement between two maps by discarding keys\n/// which occur in `other`.\n///\n/// Time: O(m log n) where m is the size of the other map\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 3 => 4};\n/// let map2 = ordmap!{2 => 2, 3 => 5};\n/// let expected = ordmap!{1 => 1};\n/// assert_eq!(expected, map1.relative_complement(map2));\n/// ```\n#[inline]\n#[must_use]\npub fn relative_complement(mut self, other: Self) -> Self{\n        for (key, _) in other {\n            let _ = self.remove(&key);\n        }\n        self\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::remove":["/// Remove a key/value mapping from a map if it exists.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let mut map = ordmap!{123 => \"123\", 456 => \"456\"};\n/// map.remove(&123);\n/// map.remove(&456);\n/// assert!(map.is_empty());\n/// ```\n///\n/// [remove]: #method.remove\n#[inline]\npub fn remove<BK>(&mut self, k: &BK) -> Option<V>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        self.remove_with_key(k).map(|(_, v)| v)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::remove_with_key":["/// Remove a key/value pair from a map, if it exists, and return\n/// the removed key and value.\n///\n/// Time: O(log n)\npub fn remove_with_key<BK>(&mut self, k: &BK) -> Option<(K, V)>\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        let (new_root, removed_value) = {\n            let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n            match root.remove(&self.pool.0, k) {\n                Remove::NoChange => return None,\n                Remove::Removed(pair) => {\n                    self.size -= 1;\n                    return Some(pair);\n                }\n                Remove::Update(pair, root) => (PoolRef::new(&self.pool.0, root), Some(pair)),\n            }\n        };\n        self.size -= 1;\n        self.root = new_root;\n        removed_value\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::skip":["/// Construct a map with the `n` smallest keys removed from a\n/// given map.\n#[must_use]\npub fn skip(&self, n: usize) -> Self{\n        self.iter()\n            .skip(n)\n            .map(|(k, v)| (k.clone(), v.clone()))\n            .collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::split":["/// Split a map into two, with the left hand map containing keys\n/// which are smaller than `split`, and the right hand map\n/// containing keys which are larger than `split`.\n///\n/// The `split` mapping is discarded.\n#[must_use]\npub fn split<BK>(&self, split: &BK) -> (Self, Self)\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        let (l, _, r) = self.split_lookup(split);\n        (l, r)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::split_lookup":["/// Split a map into two, with the left hand map containing keys\n/// which are smaller than `split`, and the right hand map\n/// containing keys which are larger than `split`.\n///\n/// Returns both the two maps and the value of `split`.\n#[must_use]\npub fn split_lookup<BK>(&self, split: &BK) -> (Self, Option<V>, Self)\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        // TODO this is atrociously slow, got to be a better way\n        self.iter()\n            .fold((ordmap![], None, ordmap![]), |(l, m, r), (k, v)| {\n                match k.borrow().cmp(split) {\n                    Ordering::Less => (l.update(k.clone(), v.clone()), m, r),\n                    Ordering::Equal => (l, Some(v.clone()), r),\n                    Ordering::Greater => (l, m, r.update(k.clone(), v.clone())),\n                }\n            })\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::symmetric_difference":["/// Construct the symmetric difference between two maps by discarding keys\n/// which occur in both maps.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 3 => 4};\n/// let map2 = ordmap!{2 => 2, 3 => 5};\n/// let expected = ordmap!{1 => 1, 2 => 2};\n/// assert_eq!(expected, map1.symmetric_difference(map2));\n/// ```\n#[inline]\n#[must_use]\npub fn symmetric_difference(self, other: Self) -> Self{\n        self.symmetric_difference_with_key(other, |_, _, _| None)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::symmetric_difference_with":["/// Construct the symmetric difference between two maps by using a function\n/// to decide what to do if a key occurs in both.\n///\n/// Time: O(n log n)\n#[inline]\n#[must_use]\npub fn symmetric_difference_with<F>(self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(V, V) -> Option<V>,{\n        self.symmetric_difference_with_key(other, |_, a, b| f(a, b))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::symmetric_difference_with_key":["/// Construct the symmetric difference between two maps by using a function\n/// to decide what to do if a key occurs in both. The function\n/// receives the key as well as both values.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 3 => 4};\n/// let map2 = ordmap!{2 => 2, 3 => 5};\n/// let expected = ordmap!{1 => 1, 2 => 2, 3 => 9};\n/// assert_eq!(expected, map1.symmetric_difference_with_key(\n///     map2,\n///     |key, left, right| Some(left + right)\n/// ));\n/// ```\n#[must_use]\npub fn symmetric_difference_with_key<F>(mut self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> Option<V>,{\n        let mut out = Self::default();\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => {\n                    out.insert(key, right_value);\n                }\n                Some(left_value) => {\n                    if let Some(final_value) = f(&key, left_value, right_value) {\n                        out.insert(key, final_value);\n                    }\n                }\n            }\n        }\n        out.union(self)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::take":["/// Construct a map with only the `n` smallest keys from a given\n/// map.\n#[must_use]\npub fn take(&self, n: usize) -> Self{\n        self.iter()\n            .take(n)\n            .map(|(k, v)| (k.clone(), v.clone()))\n            .collect()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::union":["/// Construct the union of two maps, keeping the values in the\n/// current map when keys exist in both maps.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 3 => 3};\n/// let map2 = ordmap!{2 => 2, 3 => 4};\n/// let expected = ordmap!{1 => 1, 2 => 2, 3 => 3};\n/// assert_eq!(expected, map1.union(map2));\n/// ```\n#[inline]\n#[must_use]\npub fn union(mut self, other: Self) -> Self{\n        for (k, v) in other {\n            self.entry(k).or_insert(v);\n        }\n        self\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::union_with":["/// Construct the union of two maps, using a function to decide\n/// what to do with the value when a key is in both maps.\n///\n/// The function is called when a value exists in both maps, and\n/// receives the value from the current map as its first argument,\n/// and the value from the other map as the second. It should\n/// return the value to be inserted in the resulting map.\n///\n/// Time: O(n log n)\n#[inline]\n#[must_use]\npub fn union_with<F>(self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(V, V) -> V,{\n        self.union_with_key(other, |_, v1, v2| f(v1, v2))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::union_with_key":["/// Construct the union of two maps, using a function to decide\n/// what to do with the value when a key is in both maps.\n///\n/// The function is called when a value exists in both maps, and\n/// receives a reference to the key as its first argument, the\n/// value from the current map as the second argument, and the\n/// value from the other map as the third argument. It should\n/// return the value to be inserted in the resulting map.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 3 => 4};\n/// let map2 = ordmap!{2 => 2, 3 => 5};\n/// let expected = ordmap!{1 => 1, 2 => 2, 3 => 9};\n/// assert_eq!(expected, map1.union_with_key(\n///     map2,\n///     |key, left, right| left + right\n/// ));\n/// ```\n#[must_use]\npub fn union_with_key<F>(mut self, other: Self, mut f: F) -> Self\n    where\n        F: FnMut(&K, V, V) -> V,{\n        for (key, right_value) in other {\n            match self.remove(&key) {\n                None => {\n                    self.insert(key, right_value);\n                }\n                Some(left_value) => {\n                    let final_value = f(&key, left_value, right_value);\n                    self.insert(key, final_value);\n                }\n            }\n        }\n        self\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::unions":["/// Construct the union of a sequence of maps, selecting the value\n/// of the leftmost when a key appears in more than one map.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map1 = ordmap!{1 => 1, 3 => 3};\n/// let map2 = ordmap!{2 => 2};\n/// let expected = ordmap!{1 => 1, 2 => 2, 3 => 3};\n/// assert_eq!(expected, OrdMap::unions(vec![map1, map2]));\n/// ```\n#[must_use]\npub fn unions<I>(i: I) -> Self\n    where\n        I: IntoIterator<Item = Self>,{\n        i.into_iter().fold(Self::default(), Self::union)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::unions_with":["/// Construct the union of a sequence of maps, using a function to\n/// decide what to do with the value when a key is in more than\n/// one map.\n///\n/// The function is called when a value exists in multiple maps,\n/// and receives the value from the current map as its first\n/// argument, and the value from the next map as the second. It\n/// should return the value to be inserted in the resulting map.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn unions_with<I, F>(i: I, f: F) -> Self\n    where\n        I: IntoIterator<Item = Self>,\n        F: Fn(V, V) -> V,{\n        i.into_iter()\n            .fold(Self::default(), |a, b| a.union_with(b, &f))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::unions_with_key":["/// Construct the union of a sequence of maps, using a function to\n/// decide what to do with the value when a key is in more than\n/// one map.\n///\n/// The function is called when a value exists in multiple maps,\n/// and receives a reference to the key as its first argument, the\n/// value from the current map as the second argument, and the\n/// value from the next map as the third argument. It should\n/// return the value to be inserted in the resulting map.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn unions_with_key<I, F>(i: I, f: F) -> Self\n    where\n        I: IntoIterator<Item = Self>,\n        F: Fn(&K, V, V) -> V,{\n        i.into_iter()\n            .fold(Self::default(), |a, b| a.union_with_key(b, &f))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::unit":["/// Construct a map with a single mapping.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map = OrdMap::unit(123, \"onetwothree\");\n/// assert_eq!(\n///   map.get(&123),\n///   Some(&\"onetwothree\")\n/// );\n/// ```\n#[inline]\n#[must_use]\npub fn unit(key: K, value: V) -> Self{\n        let pool = OrdMapPool::default();\n        let root = PoolRef::new(&pool.0, Node::unit((key, value)));\n        OrdMap {\n            size: 1,\n            pool,\n            root,\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::update":["/// Construct a new map by inserting a key/value mapping into a\n/// map.\n///\n/// If the map already has a mapping for the given key, the\n/// previous value is overwritten.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordmap::OrdMap;\n/// let map = ordmap!{};\n/// assert_eq!(\n///   map.update(123, \"123\"),\n///   ordmap!{123 => \"123\"}\n/// );\n/// ```\n#[must_use]\npub fn update(&self, key: K, value: V) -> Self{\n        let mut out = self.clone();\n        out.insert(key, value);\n        out\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::update_lookup_with_key":["/// Construct a new map by inserting a key/value mapping into a\n/// map, returning the old value for the key as well as the new\n/// map.\n///\n/// If the map already has a mapping for the given key, we call\n/// the provided function with the key, the old value and the new\n/// value, and insert the result as the new value.\n///\n/// Time: O(log n)\n#[must_use]\npub fn update_lookup_with_key<F>(self, k: K, v: V, f: F) -> (Option<V>, Self)\n    where\n        F: FnOnce(&K, &V, V) -> V,{\n        match self.extract_with_key(&k) {\n            None => (None, self.update(k, v)),\n            Some((_, v2, m)) => {\n                let out_v = f(&k, &v2, v);\n                (Some(v2), m.update(k, out_v))\n            }\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::update_with":["/// Construct a new map by inserting a key/value mapping into a\n/// map.\n///\n/// If the map already has a mapping for the given key, we call\n/// the provided function with the old value and the new value,\n/// and insert the result as the new value.\n///\n/// Time: O(log n)\n#[must_use]\npub fn update_with<F>(self, k: K, v: V, f: F) -> Self\n    where\n        F: FnOnce(V, V) -> V,{\n        self.update_with_key(k, v, |_, v1, v2| f(v1, v2))\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::update_with_key":["/// Construct a new map by inserting a key/value mapping into a\n/// map.\n///\n/// If the map already has a mapping for the given key, we call\n/// the provided function with the key, the old value and the new\n/// value, and insert the result as the new value.\n///\n/// Time: O(log n)\n#[must_use]\npub fn update_with_key<F>(self, k: K, v: V, f: F) -> Self\n    where\n        F: FnOnce(&K, V, V) -> V,{\n        match self.extract_with_key(&k) {\n            None => self.update(k, v),\n            Some((_, v2, m)) => {\n                let out_v = f(&k, v2, v);\n                m.update(k, out_v)\n            }\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::values":["/// Get an iterator over a map's values.\n#[must_use]\npub fn values(&self) -> Values<'_, K, V>{\n        Values { it: self.iter() }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::without":["/// Remove a key/value pair from a map, if it exists.\n///\n/// Time: O(log n)\n#[must_use]\npub fn without<BK>(&self, k: &BK) -> Self\n    where\n        BK: Ord + ?Sized,\n        K: Borrow<BK>,{\n        self.extract(k)\n            .map(|(_, m)| m)\n            .unwrap_or_else(|| self.clone())\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::without_max":["/// Remove the largest key from a map, and return its value as\n/// well as the updated map.\n#[must_use]\npub fn without_max(&self) -> (Option<V>, Self){\n        let (pop, next) = self.without_max_with_key();\n        (pop.map(|(_, v)| v), next)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::without_max_with_key":["/// Remove the largest key from a map, and return that key, its\n/// value as well as the updated map.\n#[must_use]\npub fn without_max_with_key(&self) -> (Option<(K, V)>, Self){\n        match self.get_max() {\n            None => (None, self.clone()),\n            Some((k, _)) => {\n                let (key, value, next) = self.extract_with_key(k).unwrap();\n                (Some((key, value)), next)\n            }\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::without_min":["/// Remove the smallest key from a map, and return its value as\n/// well as the updated map.\n#[must_use]\npub fn without_min(&self) -> (Option<V>, Self){\n        let (pop, next) = self.without_min_with_key();\n        (pop.map(|(_, v)| v), next)\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMap::<K, V>::without_min_with_key":["/// Remove the smallest key from a map, and return that key, its\n/// value as well as the updated map.\n#[must_use]\npub fn without_min_with_key(&self) -> (Option<(K, V)>, Self){\n        match self.get_min() {\n            None => (None, self.clone()),\n            Some((k, _)) => {\n                let (key, value, next) = self.extract_with_key(k).unwrap();\n                (Some((key, value)), next)\n            }\n        }\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::OrdMapPool":["/// A memory pool for the appropriate node type.\npub struct $name<$($arg,)*>(Pool<$pooltype>);","Real(LocalPath(\"src/util.rs\"))"],"ord::map::OrdMapPool::<K, V>::fill":["/// Fill the pool with preallocated chunks.\npub fn fill(&self){\n                self.0.fill();\n            }","Real(LocalPath(\"src/util.rs\"))"],"ord::map::OrdMapPool::<K, V>::new":["/// Create a new pool with the given size.\npub fn new(size: usize) -> Self{\n                Self(Pool::new(size))\n            }","Real(LocalPath(\"src/util.rs\"))"],"ord::map::OrdMapPool::<K, V>::pool_size":["///Get the current size of the pool.\npub fn pool_size(&self) -> usize{\n                self.0.get_pool_size()\n            }","Real(LocalPath(\"src/util.rs\"))"],"ord::map::VacantEntry":["/// An entry for a mapping that does not already exist in the map.\npub struct VacantEntry<'a, K, V>\nwhere\n    K: Ord + Clone,\n    V: Clone,\n{\n    map: &'a mut OrdMap<K, V>,\n    key: K,\n}","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::VacantEntry::<'a, K, V>::insert":["/// Insert a value into this entry.\npub fn insert(self, value: V) -> &'a mut V{\n        self.map.insert(self.key.clone(), value);\n        // TODO insert_mut ought to return this reference\n        self.map.get_mut(&self.key).unwrap()\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::VacantEntry::<'a, K, V>::into_key":["/// Convert this entry into its key.\n#[must_use]\npub fn into_key(self) -> K{\n        self.key\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::VacantEntry::<'a, K, V>::key":["/// Get the key for this entry.\n#[must_use]\npub fn key(&self) -> &K{\n        &self.key\n    }","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::map::Values":["/// An iterator over the values of a map.\npub struct Values<'a, K, V> {\n    it: Iter<'a, K, V>,\n}","Real(LocalPath(\"src/ord/map.rs\"))"],"ord::set::ConsumingIter":["/// A consuming iterator over the elements of a set.\npub struct ConsumingIter<A> {\n    it: ConsumingNodeIter<Value<A>>,\n}","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::DiffIter":["/// An iterator over the difference between two sets.\npub struct DiffIter<'a, A> {\n    it: NodeDiffIter<'a, Value<A>>,\n}","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::Iter":["/// An iterator over the elements of a set.\npub struct Iter<'a, A> {\n    it: NodeIter<'a, Value<A>>,\n}","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet":["/// An ordered set.\n///\n/// An immutable ordered set implemented as a [B-tree] [1].\n///\n/// Most operations on this type of set are O(log n). A\n/// [`HashSet`][hashset::HashSet] is usually a better choice for\n/// performance, but the `OrdSet` has the advantage of only requiring\n/// an [`Ord`][std::cmp::Ord] constraint on its values, and of being\n/// ordered, so values always come out from lowest to highest, where a\n/// [`HashSet`][hashset::HashSet] has no guaranteed ordering.\n///\n/// [1]: https://en.wikipedia.org/wiki/B-tree\n/// [hashset::HashSet]: ../hashset/struct.HashSet.html\n/// [std::cmp::Ord]: https://doc.rust-lang.org/std/cmp/trait.Ord.html\npub struct OrdSet<A> {\n    size: usize,\n    pool: OrdSetPool<A>,\n    root: PoolRef<Node<Value<A>>>,\n}","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::clear":["/// Discard all elements from the set.\n///\n/// This leaves you with an empty set, and all elements that\n/// were previously inside it are dropped.\n///\n/// Time: O(n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::OrdSet;\n/// let mut set = ordset![1, 2, 3];\n/// set.clear();\n/// assert!(set.is_empty());\n/// ```\npub fn clear(&mut self){\n        if !self.is_empty() {\n            self.root = PoolRef::default(&self.pool.0);\n            self.size = 0;\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::contains":["/// Test if a value is part of a set.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// let mut set = ordset!{1, 2, 3};\n/// assert!(set.contains(&1));\n/// assert!(!set.contains(&4));\n/// ```\n#[inline]\n#[must_use]\npub fn contains<BA>(&self, a: &BA) -> bool\n    where\n        BA: Ord + ?Sized,\n        A: Borrow<BA>,{\n        self.root.lookup(a).is_some()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::diff":["/// Get an iterator over the differences between this set and\n/// another, i.e. the set of entries to add or remove to this set\n/// in order to make it equal to the other set.\n///\n/// This function will avoid visiting nodes which are shared\n/// between the two sets, meaning that even very large sets can be\n/// compared quickly if most of their structure is shared.\n///\n/// Time: O(n) (where n is the number of unique elements across\n/// the two sets, minus the number of elements belonging to nodes\n/// shared between them)\n#[must_use]\npub fn diff<'a>(&'a self, other: &'a Self) -> DiffIter<'_, A>{\n        DiffIter {\n            it: NodeDiffIter::new(&self.root, &other.root),\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::difference":["/// Construct the symmetric difference between two sets.\n///\n/// This is an alias for the\n/// [`symmetric_difference`][symmetric_difference] method.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// let set1 = ordset!{1, 2};\n/// let set2 = ordset!{2, 3};\n/// let expected = ordset!{1, 3};\n/// assert_eq!(expected, set1.difference(set2));\n/// ```\n///\n/// [symmetric_difference]: #method.symmetric_difference\n#[must_use]\npub fn difference(self, other: Self) -> Self{\n        self.symmetric_difference(other)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::get_max":["/// Get the largest value in a set.\n///\n/// If the set is empty, returns `None`.\n///\n/// Time: O(log n)\n#[must_use]\npub fn get_max(&self) -> Option<&A>{\n        self.root.max().map(Deref::deref)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::get_min":["/// Get the smallest value in a set.\n///\n/// If the set is empty, returns `None`.\n///\n/// Time: O(log n)\n#[must_use]\npub fn get_min(&self) -> Option<&A>{\n        self.root.min().map(Deref::deref)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::get_next":["/// Get the closest larger value in a set to a given value.\n///\n/// If the set contains the given value, this is returned.\n/// Otherwise, the closest value in the set larger than the\n/// given value is returned. If the largest value in the set\n/// is smaller than the given value, `None` is returned.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::OrdSet;\n/// let set = ordset![1, 3, 5, 7, 9];\n/// assert_eq!(Some(&5), set.get_next(&4));\n/// ```\n#[must_use]\npub fn get_next(&self, key: &A) -> Option<&A>{\n        self.root.lookup_next(key).map(|v| &v.0)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::get_prev":["/// Get the closest smaller value in a set to a given value.\n///\n/// If the set contains the given value, this is returned.\n/// Otherwise, the closest value in the set smaller than the\n/// given value is returned. If the smallest value in the set\n/// is larger than the given value, `None` is returned.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::OrdSet;\n/// let set = ordset![1, 3, 5, 7, 9];\n/// assert_eq!(Some(&5), set.get_prev(&6));\n/// ```\n#[must_use]\npub fn get_prev(&self, key: &A) -> Option<&A>{\n        self.root.lookup_prev(key).map(|v| &v.0)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::insert":["/// Insert a value into a set.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// let mut set = ordset!{};\n/// set.insert(123);\n/// set.insert(456);\n/// assert_eq!(\n///   set,\n///   ordset![123, 456]\n/// );\n/// ```\n#[inline]\npub fn insert(&mut self, a: A) -> Option<A>{\n        let new_root = {\n            let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n            match root.insert(&self.pool.0, Value(a)) {\n                Insert::Replaced(Value(old_value)) => return Some(old_value),\n                Insert::Added => {\n                    self.size += 1;\n                    return None;\n                }\n                Insert::Split(left, median, right) => PoolRef::new(\n                    &self.pool.0,\n                    Node::new_from_split(&self.pool.0, left, median, right),\n                ),\n            }\n        };\n        self.size += 1;\n        self.root = new_root;\n        None\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::intersection":["/// Construct the intersection of two sets.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// let set1 = ordset!{1, 2};\n/// let set2 = ordset!{2, 3};\n/// let expected = ordset!{2};\n/// assert_eq!(expected, set1.intersection(set2));\n/// ```\n#[must_use]\npub fn intersection(self, other: Self) -> Self{\n        let mut out = Self::default();\n        for value in other {\n            if self.contains(&value) {\n                out.insert(value);\n            }\n        }\n        out\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::is_empty":["/// Test whether a set is empty.\n///\n/// Time: O(1)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// assert!(\n///   !ordset![1, 2, 3].is_empty()\n/// );\n/// assert!(\n///   OrdSet::<i32>::new().is_empty()\n/// );\n/// ```\n#[inline]\n#[must_use]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::is_proper_subset":["/// Test whether a set is a proper subset of another set, meaning\n/// that all values in our set must also be in the other set. A\n/// proper subset must also be smaller than the other set.\n///\n/// Time: O(n log m) where m is the size of the other set\n#[must_use]\npub fn is_proper_subset<RS>(&self, other: RS) -> bool\n    where\n        RS: Borrow<Self>,{\n        self.len() != other.borrow().len() && self.is_subset(other)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::is_subset":["/// Test whether a set is a subset of another set, meaning that\n/// all values in our set must also be in the other set.\n///\n/// Time: O(n log m) where m is the size of the other set\n#[must_use]\npub fn is_subset<RS>(&self, other: RS) -> bool\n    where\n        RS: Borrow<Self>,{\n        let other = other.borrow();\n        if other.len() < self.len() {\n            return false;\n        }\n        self.iter().all(|a| other.contains(&a))\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::iter":["/// Create an iterator over the contents of the set.\n#[must_use]\npub fn iter(&self) -> Iter<'_, A>{\n        Iter {\n            it: NodeIter::new(&self.root, self.size, ..),\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::len":["/// Get the size of a set.\n///\n/// Time: O(1)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// assert_eq!(3, ordset![1, 2, 3].len());\n/// ```\n#[inline]\n#[must_use]\npub fn len(&self) -> usize{\n        self.size\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::new":["/// Construct an empty set.\n#[must_use]\npub fn new() -> Self{\n        let pool = OrdSetPool::default();\n        let root = PoolRef::default(&pool.0);\n        OrdSet {\n            size: 0,\n            pool,\n            root,\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::ptr_eq":["/// Test whether two sets refer to the same content in memory.\n///\n/// This is true if the two sides are references to the same set,\n/// or if the two sets refer to the same root node.\n///\n/// This would return true if you're comparing a set to itself, or\n/// if you're comparing a set to a fresh clone of itself.\n///\n/// Time: O(1)\npub fn ptr_eq(&self, other: &Self) -> bool{\n        std::ptr::eq(self, other) || PoolRef::ptr_eq(&self.root, &other.root)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::range":["/// Create an iterator over a range inside the set.\n#[must_use]\npub fn range<R, BA>(&self, range: R) -> RangedIter<'_, A>\n    where\n        R: RangeBounds<BA>,\n        A: Borrow<BA>,\n        BA: Ord + ?Sized,{\n        RangedIter {\n            it: NodeIter::new(&self.root, self.size, range),\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::relative_complement":["/// Construct the relative complement between two sets, that is the set\n/// of values in `self` that do not occur in `other`.\n///\n/// Time: O(m log n) where m is the size of the other set\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// let set1 = ordset!{1, 2};\n/// let set2 = ordset!{2, 3};\n/// let expected = ordset!{1};\n/// assert_eq!(expected, set1.relative_complement(set2));\n/// ```\n#[must_use]\npub fn relative_complement(mut self, other: Self) -> Self{\n        for value in other {\n            let _ = self.remove(&value);\n        }\n        self\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::remove":["/// Remove a value from a set.\n///\n/// Time: O(log n)\n#[inline]\npub fn remove<BA>(&mut self, a: &BA) -> Option<A>\n    where\n        BA: Ord + ?Sized,\n        A: Borrow<BA>,{\n        let (new_root, removed_value) = {\n            let root = PoolRef::make_mut(&self.pool.0, &mut self.root);\n            match root.remove(&self.pool.0, a) {\n                Remove::Update(value, root) => (PoolRef::new(&self.pool.0, root), Some(value.0)),\n                Remove::Removed(value) => {\n                    self.size -= 1;\n                    return Some(value.0);\n                }\n                Remove::NoChange => return None,\n            }\n        };\n        self.size -= 1;\n        self.root = new_root;\n        removed_value\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::remove_max":["/// Remove the largest value from a set.\n///\n/// Time: O(log n)\npub fn remove_max(&mut self) -> Option<A>{\n        // FIXME implement this at the node level for better efficiency\n        let key = match self.get_max() {\n            None => return None,\n            Some(v) => v,\n        }\n        .clone();\n        self.remove(&key)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::remove_min":["/// Remove the smallest value from a set.\n///\n/// Time: O(log n)\npub fn remove_min(&mut self) -> Option<A>{\n        // FIXME implement this at the node level for better efficiency\n        let key = match self.get_min() {\n            None => return None,\n            Some(v) => v,\n        }\n        .clone();\n        self.remove(&key)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::skip":["/// Construct a set with the `n` smallest values removed from a\n/// given set.\n///\n/// Time: O(n)\n#[must_use]\npub fn skip(&self, n: usize) -> Self{\n        self.iter().skip(n).cloned().collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::split":["/// Split a set into two, with the left hand set containing values\n/// which are smaller than `split`, and the right hand set\n/// containing values which are larger than `split`.\n///\n/// The `split` value itself is discarded.\n///\n/// Time: O(n)\n#[must_use]\npub fn split<BA>(self, split: &BA) -> (Self, Self)\n    where\n        BA: Ord + ?Sized,\n        A: Borrow<BA>,{\n        let (left, _, right) = self.split_member(split);\n        (left, right)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::split_member":["/// Split a set into two, with the left hand set containing values\n/// which are smaller than `split`, and the right hand set\n/// containing values which are larger than `split`.\n///\n/// Returns a tuple of the two sets and a boolean which is true if\n/// the `split` value existed in the original set, and false\n/// otherwise.\n///\n/// Time: O(n)\n#[must_use]\npub fn split_member<BA>(self, split: &BA) -> (Self, bool, Self)\n    where\n        BA: Ord + ?Sized,\n        A: Borrow<BA>,{\n        let mut left = Self::default();\n        let mut right = Self::default();\n        let mut present = false;\n        for value in self {\n            match value.borrow().cmp(split) {\n                Ordering::Less => {\n                    left.insert(value);\n                }\n                Ordering::Equal => {\n                    present = true;\n                }\n                Ordering::Greater => {\n                    right.insert(value);\n                }\n            }\n        }\n        (left, present, right)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::symmetric_difference":["/// Construct the symmetric difference between two sets.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// let set1 = ordset!{1, 2};\n/// let set2 = ordset!{2, 3};\n/// let expected = ordset!{1, 3};\n/// assert_eq!(expected, set1.symmetric_difference(set2));\n/// ```\n#[must_use]\npub fn symmetric_difference(mut self, other: Self) -> Self{\n        for value in other {\n            if self.remove(&value).is_none() {\n                self.insert(value);\n            }\n        }\n        self\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::take":["/// Construct a set with only the `n` smallest values from a given\n/// set.\n///\n/// Time: O(n)\n#[must_use]\npub fn take(&self, n: usize) -> Self{\n        self.iter().take(n).cloned().collect()\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::union":["/// Construct the union of two sets.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// let set1 = ordset!{1, 2};\n/// let set2 = ordset!{2, 3};\n/// let expected = ordset!{1, 2, 3};\n/// assert_eq!(expected, set1.union(set2));\n/// ```\n#[must_use]\npub fn union(mut self, other: Self) -> Self{\n        for value in other {\n            self.insert(value);\n        }\n        self\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::unions":["/// Construct the union of multiple sets.\n///\n/// Time: O(n log n)\n#[must_use]\npub fn unions<I>(i: I) -> Self\n    where\n        I: IntoIterator<Item = Self>,{\n        i.into_iter().fold(Self::default(), Self::union)\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::unit":["/// Construct a set with a single value.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// let set = OrdSet::unit(123);\n/// assert!(set.contains(&123));\n/// ```\n#[inline]\n#[must_use]\npub fn unit(a: A) -> Self{\n        let pool = OrdSetPool::default();\n        let root = PoolRef::new(&pool.0, Node::unit(Value(a)));\n        OrdSet {\n            size: 1,\n            pool,\n            root,\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::update":["/// Construct a new set from the current set with the given value\n/// added.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::ordset::OrdSet;\n/// let set = ordset![456];\n/// assert_eq!(\n///   set.update(123),\n///   ordset![123, 456]\n/// );\n/// ```\n#[must_use]\npub fn update(&self, a: A) -> Self{\n        let mut out = self.clone();\n        out.insert(a);\n        out\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::without":["/// Construct a new set with the given value removed if it's in\n/// the set.\n///\n/// Time: O(log n)\n#[must_use]\npub fn without<BA>(&self, a: &BA) -> Self\n    where\n        BA: Ord + ?Sized,\n        A: Borrow<BA>,{\n        let mut out = self.clone();\n        out.remove(a);\n        out\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::without_max":["/// Remove the largest value from a set, and return that value as\n/// well as the updated set.\n///\n/// Time: O(log n)\n#[must_use]\npub fn without_max(&self) -> (Option<A>, Self){\n        match self.get_max() {\n            Some(v) => (Some(v.clone()), self.without(&v)),\n            None => (None, self.clone()),\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSet::<A>::without_min":["/// Remove the smallest value from a set, and return that value as\n/// well as the updated set.\n///\n/// Time: O(log n)\n#[must_use]\npub fn without_min(&self) -> (Option<A>, Self){\n        match self.get_min() {\n            Some(v) => (Some(v.clone()), self.without(&v)),\n            None => (None, self.clone()),\n        }\n    }","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::OrdSetPool":["/// A memory pool for the appropriate node type.\npub struct $name<$($arg,)*>(Pool<$pooltype>);","Real(LocalPath(\"src/util.rs\"))"],"ord::set::OrdSetPool::<A>::fill":["/// Fill the pool with preallocated chunks.\npub fn fill(&self){\n                self.0.fill();\n            }","Real(LocalPath(\"src/util.rs\"))"],"ord::set::OrdSetPool::<A>::new":["/// Create a new pool with the given size.\npub fn new(size: usize) -> Self{\n                Self(Pool::new(size))\n            }","Real(LocalPath(\"src/util.rs\"))"],"ord::set::OrdSetPool::<A>::pool_size":["///Get the current size of the pool.\npub fn pool_size(&self) -> usize{\n                self.0.get_pool_size()\n            }","Real(LocalPath(\"src/util.rs\"))"],"ord::set::RangedIter":["/// A ranged iterator over the elements of a set.\n///\n/// The only difference from `Iter` is that this one doesn't implement\n/// `ExactSizeIterator` because we can't know the size of the range without first\n/// iterating over it to count.\npub struct RangedIter<'a, A> {\n    it: NodeIter<'a, Value<A>>,\n}","Real(LocalPath(\"src/ord/set.rs\"))"],"ord::set::Value":["struct Value<A>(A);","Real(LocalPath(\"src/ord/set.rs\"))"],"sort::do_quicksort":["fn do_quicksort<A, F, R>(vector: FocusMut<'_, A>, cmp: &F, rng: &mut R)\nwhere\n    A: Clone,\n    F: Fn(&A, &A) -> Ordering,\n    R: RngCore,{\n    if vector.len() <= 1 {\n        return;\n    }\n\n    // We know there are at least 2 elements here\n    let pivot_index = gen_range(rng, 0, vector.len());\n    let (mut first, mut rest) = vector.split_at(1);\n\n    if pivot_index > 0 {\n        mem::swap(rest.index_mut(pivot_index - 1), first.index_mut(0));\n    }\n    // Pivot is now always in the first slice\n    let pivot_item = first.index(0);\n\n    // Find the exact place to put the pivot or pivot-equal items\n    let mut less_count = 0;\n    let mut equal_count = 0;\n\n    for index in 0..rest.len() {\n        let item = rest.index(index);\n        let comp = cmp(item, pivot_item);\n        match comp {\n            Ordering::Less => less_count += 1,\n            Ordering::Equal => equal_count += 1,\n            Ordering::Greater => {}\n        }\n    }\n\n    // If by accident we picked the minimum element as a pivot, we just call sort again with the\n    // rest of the vector.\n    if less_count == 0 {\n        do_quicksort(rest, cmp, rng);\n        return;\n    }\n\n    // We know here that there is at least one item before the pivot, so we move the minimum to the\n    // beginning part of the vector. First, however we swap the pivot to the start of the equal\n    // zone.\n    less_count -= 1;\n    equal_count += 1;\n    let first_item = first.index_mut(0);\n    mem::swap(first_item, rest.index_mut(less_count));\n    for index in 0..rest.len() {\n        if index == less_count {\n            // This is the position we swapped the pivot to. We can't move it from its position, and\n            // we know its not the minimum.\n            continue;\n        }\n        let rest_item = rest.index_mut(index);\n        if cmp(rest_item, first_item) == Ordering::Less {\n            mem::swap(first_item, rest_item);\n        }\n    }\n\n    // Split the vector up into less_than, equal to and greater than parts.\n    let (remaining, mut greater_focus) = rest.split_at(less_count + equal_count);\n    let (mut less_focus, mut equal_focus) = remaining.split_at(less_count);\n\n    let mut less_position = 0;\n    let mut equal_position = 0;\n    let mut greater_position = 0;\n\n    while less_position != less_focus.len() || greater_position != greater_focus.len() {\n        // At start of this loop, equal_position always points to an equal item\n        let mut equal_swap_side = None;\n        let equal_item = equal_focus.index(equal_position);\n\n        // Advance the less_position until we find an out of place item\n        while less_position != less_focus.len() {\n            let less_item = less_focus.index(less_position);\n            match cmp(less_item, equal_item) {\n                Ordering::Equal => {\n                    equal_swap_side = Some(Ordering::Less);\n                    break;\n                }\n                Ordering::Greater => {\n                    break;\n                }\n                _ => {}\n            }\n            less_position += 1;\n        }\n\n        // Advance the greater until we find an out of place item\n        while greater_position != greater_focus.len() {\n            let greater_item = greater_focus.index(greater_position);\n            match cmp(greater_item, equal_item) {\n                Ordering::Less => break,\n                Ordering::Equal => {\n                    equal_swap_side = Some(Ordering::Greater);\n                    break;\n                }\n                _ => {}\n            }\n            greater_position += 1;\n        }\n\n        if let Some(swap_side) = equal_swap_side {\n            // One of the sides is equal to the pivot, advance the pivot\n            let item = if swap_side == Ordering::Less {\n                less_focus.index_mut(less_position)\n            } else {\n                greater_focus.index_mut(greater_position)\n            };\n\n            // We are guaranteed not to hit the end of the equal focus\n            while cmp(item, equal_focus.index(equal_position)) == Ordering::Equal {\n                equal_position += 1;\n            }\n\n            // Swap the equal position and the desired side, it's important to note that only the\n            // equals focus is guaranteed to have made progress so we don't advance the side's index\n            mem::swap(item, equal_focus.index_mut(equal_position));\n        } else if less_position != less_focus.len() && greater_position != greater_focus.len() {\n            // Both sides are out of place and not equal to the pivot, this can only happen if there\n            // is a greater item in the lesser zone and a lesser item in the greater zone. The\n            // solution is to swap both sides and advance both side's indices.\n            debug_assert_ne!(\n                cmp(\n                    less_focus.index(less_position),\n                    equal_focus.index(equal_position)\n                ),\n                Ordering::Equal\n            );\n            debug_assert_ne!(\n                cmp(\n                    greater_focus.index(greater_position),\n                    equal_focus.index(equal_position)\n                ),\n                Ordering::Equal\n            );\n            mem::swap(\n                less_focus.index_mut(less_position),\n                greater_focus.index_mut(greater_position),\n            );\n            less_position += 1;\n            greater_position += 1;\n        }\n    }\n\n    // Now we have partitioned both sides correctly, we just have to recurse now\n    do_quicksort(less_focus, cmp, rng);\n    if !greater_focus.is_empty() {\n        do_quicksort(greater_focus, cmp, rng);\n    }\n}","Real(LocalPath(\"src/sort.rs\"))"],"sort::gen_range":["fn gen_range<R: RngCore>(rng: &mut R, min: usize, max: usize) -> usize{\n    let range = max - min;\n    min + (rng.next_u64() as usize % range)\n}","Real(LocalPath(\"src/sort.rs\"))"],"sort::quicksort":["pub(crate) fn quicksort<A, F>(vector: FocusMut<'_, A>, cmp: &F)\nwhere\n    A: Clone,\n    F: Fn(&A, &A) -> Ordering,{\n    let mut rng = rand_xoshiro::Xoshiro256Plus::seed_from_u64(0);\n    do_quicksort(vector, cmp, &mut rng);\n}","Real(LocalPath(\"src/sort.rs\"))"],"sync::lock::Lock":["/// Thread safe lock: just wraps a `Mutex`.\npub(crate) struct Lock<A> {\n        lock: Arc<Mutex<A>>,\n    }","Real(LocalPath(\"src/sync.rs\"))"],"sync::lock::Lock::<A>::lock":["#[inline]\npub(crate) fn lock(&mut self) -> Option<MutexGuard<'_, A>>{\n            self.lock.lock().ok()\n        }","Real(LocalPath(\"src/sync.rs\"))"],"sync::lock::Lock::<A>::new":["pub(crate) fn new(value: A) -> Self{\n            Lock {\n                lock: Arc::new(Mutex::new(value)),\n            }\n        }","Real(LocalPath(\"src/sync.rs\"))"],"util::Side":["pub(crate) enum Side {\n    Left,\n    Right,\n}","Real(LocalPath(\"src/util.rs\"))"],"util::clone_ref":["pub(crate) fn clone_ref<A>(r: Ref<A>) -> A\nwhere\n    A: Clone,{\n    Ref::try_unwrap(r).unwrap_or_else(|r| (*r).clone())\n}","Real(LocalPath(\"src/util.rs\"))"],"util::linear_search_by":["#[allow(dead_code)]\npub(crate) fn linear_search_by<'a, A, I, F>(iterable: I, mut cmp: F) -> Result<usize, usize>\nwhere\n    A: 'a,\n    I: IntoIterator<Item = &'a A>,\n    F: FnMut(&A) -> Ordering,{\n    let mut pos = 0;\n    for value in iterable {\n        match cmp(value) {\n            Ordering::Equal => return Ok(pos),\n            Ordering::Greater => return Err(pos),\n            Ordering::Less => {}\n        }\n        pos += 1;\n    }\n    Err(pos)\n}","Real(LocalPath(\"src/util.rs\"))"],"util::swap_indices":["/// Swap two values of anything implementing `IndexMut`.\n///\n/// Like `slice::swap`, but more generic.\n#[allow(unsafe_code)]\npub(crate) fn swap_indices<V>(vector: &mut V, a: usize, b: usize)\nwhere\n    V: IndexMut<usize>,\n    V::Output: Sized,{\n    if a == b {\n        return;\n    }\n    // so sorry, but there's no implementation for this in std that's\n    // sufficiently generic\n    let pa: *mut V::Output = &mut vector[a];\n    let pb: *mut V::Output = &mut vector[b];\n    unsafe {\n        ptr::swap(pa, pb);\n    }\n}","Real(LocalPath(\"src/util.rs\"))"],"util::to_range":["pub(crate) fn to_range<R>(range: &R, right_unbounded: usize) -> Range<usize>\nwhere\n    R: RangeBounds<usize>,{\n    let start_index = match range.start_bound() {\n        Bound::Included(i) => *i,\n        Bound::Excluded(i) => *i + 1,\n        Bound::Unbounded => 0,\n    };\n    let end_index = match range.end_bound() {\n        Bound::Included(i) => *i + 1,\n        Bound::Excluded(i) => *i,\n        Bound::Unbounded => right_unbounded,\n    };\n    start_index..end_index\n}","Real(LocalPath(\"src/util.rs\"))"],"vector::Chunks":["/// An iterator over the leaf nodes of a vector.\n///\n/// To obtain one, use [`Vector::chunks()`][chunks].\n///\n/// [chunks]: enum.Vector.html#method.chunks\npub struct Chunks<'a, A> {\n    focus: Focus<'a, A>,\n    front_index: usize,\n    back_index: usize,\n}","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Chunks::<'a, A>::new":["fn new(seq: &'a Vector<A>) -> Self{\n        Chunks {\n            focus: seq.focus(),\n            front_index: 0,\n            back_index: seq.len(),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::ChunksMut":["/// A mutable iterator over the leaf nodes of a vector.\n///\n/// To obtain one, use [`Vector::chunks_mut()`][chunks_mut].\n///\n/// [chunks_mut]: enum.Vector.html#method.chunks_mut\npub struct ChunksMut<'a, A> {\n    focus: FocusMut<'a, A>,\n    front_index: usize,\n    back_index: usize,\n}","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::ChunksMut::<'a, A>::new":["fn new(seq: &'a mut Vector<A>) -> Self{\n        let len = seq.len();\n        ChunksMut {\n            focus: seq.focus_mut(),\n            front_index: 0,\n            back_index: len,\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::ConsumingIter":["/// A consuming iterator over vectors with values of type `A`.\npub struct ConsumingIter<A> {\n    vector: Vector<A>,\n}","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::ConsumingIter::<A>::new":["fn new(vector: Vector<A>) -> Self{\n        Self { vector }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Iter":["/// An iterator over vectors with values of type `A`.\n///\n/// To obtain one, use [`Vector::iter()`][iter].\n///\n/// [iter]: enum.Vector.html#method.iter\npub struct Iter<'a, A> {\n    focus: Focus<'a, A>,\n    front_index: usize,\n    back_index: usize,\n}","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Iter::<'a, A>::from_focus":["fn from_focus(focus: Focus<'a, A>) -> Self{\n        Iter {\n            front_index: 0,\n            back_index: focus.len(),\n            focus,\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Iter::<'a, A>::new":["fn new(seq: &'a Vector<A>) -> Self{\n        Iter {\n            focus: seq.focus(),\n            front_index: 0,\n            back_index: seq.len(),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::IterMut":["/// A mutable iterator over vectors with values of type `A`.\n///\n/// To obtain one, use [`Vector::iter_mut()`][iter_mut].\n///\n/// [iter_mut]: enum.Vector.html#method.iter_mut\npub struct IterMut<'a, A> {\n    focus: FocusMut<'a, A>,\n    front_index: usize,\n    back_index: usize,\n}","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::IterMut::<'a, A>::from_focus":["fn from_focus(focus: FocusMut<'a, A>) -> Self{\n        IterMut {\n            front_index: 0,\n            back_index: focus.len(),\n            focus,\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::IterMut::<'a, A>::new":["fn new(seq: &'a mut Vector<A>) -> Self{\n        let focus = seq.focus_mut();\n        let len = focus.len();\n        IterMut {\n            focus,\n            front_index: 0,\n            back_index: len,\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::RRB":["#[doc(hidden)]\npub struct RRB<A> {\n    length: usize,\n    middle_level: usize,\n    outer_f: PoolRef<Chunk<A>>,\n    inner_f: PoolRef<Chunk<A>>,\n    middle: Ref<Node<A>>,\n    inner_b: PoolRef<Chunk<A>>,\n    outer_b: PoolRef<Chunk<A>>,\n}","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::RRB::<A>::new":["fn new(pool: &RRBPool<A>) -> Self{\n        RRB {\n            length: 0,\n            middle_level: 0,\n            outer_f: PoolRef::default(&pool.value_pool),\n            inner_f: PoolRef::default(&pool.value_pool),\n            middle: Ref::new(Node::new()),\n            inner_b: PoolRef::default(&pool.value_pool),\n            outer_b: PoolRef::default(&pool.value_pool),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::RRB::<A>::pop_back":["fn pop_back(&mut self, pool: &RRBPool<A>) -> Option<A>{\n        if self.length == 0 {\n            return None;\n        }\n        if self.outer_b.is_empty() {\n            if self.inner_b.is_empty() {\n                if self.middle.is_empty() {\n                    if self.inner_f.is_empty() {\n                        swap(&mut self.outer_b, &mut self.outer_f);\n                    } else {\n                        swap(&mut self.outer_b, &mut self.inner_f);\n                    }\n                } else {\n                    self.outer_b = self.pop_middle(pool, Side::Right).unwrap();\n                }\n            } else {\n                swap(&mut self.outer_b, &mut self.inner_b);\n            }\n        }\n        self.length -= 1;\n        let outer_b = PoolRef::make_mut(&pool.value_pool, &mut self.outer_b);\n        Some(outer_b.pop_back())\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::RRB::<A>::pop_front":["fn pop_front(&mut self, pool: &RRBPool<A>) -> Option<A>{\n        if self.length == 0 {\n            return None;\n        }\n        if self.outer_f.is_empty() {\n            if self.inner_f.is_empty() {\n                if self.middle.is_empty() {\n                    if self.inner_b.is_empty() {\n                        swap(&mut self.outer_f, &mut self.outer_b);\n                    } else {\n                        swap(&mut self.outer_f, &mut self.inner_b);\n                    }\n                } else {\n                    self.outer_f = self.pop_middle(pool, Side::Left).unwrap();\n                }\n            } else {\n                swap(&mut self.outer_f, &mut self.inner_f);\n            }\n        }\n        self.length -= 1;\n        let outer_f = PoolRef::make_mut(&pool.value_pool, &mut self.outer_f);\n        Some(outer_f.pop_front())\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::RRB::<A>::pop_middle":["fn pop_middle(&mut self, pool: &RRBPool<A>, side: Side) -> Option<PoolRef<Chunk<A>>>{\n        let chunk = {\n            let middle = Ref::make_mut(&mut self.middle);\n            match middle.pop_chunk(pool, self.middle_level, side) {\n                PopResult::Empty => return None,\n                PopResult::Done(chunk) => chunk,\n                PopResult::Drained(chunk) => {\n                    middle.clear_node();\n                    self.middle_level = 0;\n                    chunk\n                }\n            }\n        };\n        Some(chunk)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::RRB::<A>::prune":["fn prune(&mut self){\n        if self.middle.is_empty() {\n            self.middle = Ref::new(Node::new());\n            self.middle_level = 0;\n        } else {\n            while self.middle_level > 0 && self.middle.is_single() {\n                // FIXME could be optimised, cloning the node is expensive\n                self.middle = Ref::new(self.middle.first_child().clone());\n                self.middle_level -= 1;\n            }\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::RRB::<A>::push_back":["fn push_back(&mut self, pool: &RRBPool<A>, value: A){\n        if self.outer_b.is_full() {\n            swap(&mut self.outer_b, &mut self.inner_b);\n            if !self.outer_b.is_empty() {\n                let mut chunk = PoolRef::new(&pool.value_pool, Chunk::new());\n                swap(&mut chunk, &mut self.outer_b);\n                self.push_middle(pool, Side::Right, chunk);\n            }\n        }\n        self.length = self.length.checked_add(1).expect(\"Vector length overflow\");\n        let outer_b = PoolRef::make_mut(&pool.value_pool, &mut self.outer_b);\n        outer_b.push_back(value)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::RRB::<A>::push_front":["fn push_front(&mut self, pool: &RRBPool<A>, value: A){\n        if self.outer_f.is_full() {\n            swap(&mut self.outer_f, &mut self.inner_f);\n            if !self.outer_f.is_empty() {\n                let mut chunk = PoolRef::new(&pool.value_pool, Chunk::new());\n                swap(&mut chunk, &mut self.outer_f);\n                self.push_middle(pool, Side::Left, chunk);\n            }\n        }\n        self.length = self.length.checked_add(1).expect(\"Vector length overflow\");\n        let outer_f = PoolRef::make_mut(&pool.value_pool, &mut self.outer_f);\n        outer_f.push_front(value)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::RRB::<A>::push_middle":["fn push_middle(&mut self, pool: &RRBPool<A>, side: Side, chunk: PoolRef<Chunk<A>>){\n        if chunk.is_empty() {\n            return;\n        }\n        let new_middle = {\n            let middle = Ref::make_mut(&mut self.middle);\n            match middle.push_chunk(pool, self.middle_level, side, chunk) {\n                PushResult::Done => return,\n                PushResult::Full(chunk, _num_drained) => Ref::from({\n                    match side {\n                        Side::Left => Node::from_chunk(pool, self.middle_level, chunk)\n                            .join_branches(pool, middle.clone(), self.middle_level),\n                        Side::Right => middle.clone().join_branches(\n                            pool,\n                            Node::from_chunk(pool, self.middle_level, chunk),\n                            self.middle_level,\n                        ),\n                    }\n                }),\n            }\n        };\n        self.middle_level += 1;\n        self.middle = new_middle;\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector":["/// A persistent vector.\n///\n/// This is a sequence of elements in insertion order - if you need a list of\n/// things, any kind of list of things, this is what you're looking for.\n///\n/// It's implemented as an [RRB vector][rrbpaper] with [smart head/tail\n/// chunking][chunkedseq]. In performance terms, this means that practically\n/// every operation is O(log n), except push/pop on both sides, which will be\n/// O(1) amortised, and O(log n) in the worst case. In practice, the push/pop\n/// operations will be blindingly fast, nearly on par with the native\n/// [`VecDeque`][VecDeque], and other operations will have decent, if not high,\n/// performance, but they all have more or less the same O(log n) complexity, so\n/// you don't need to keep their performance characteristics in mind -\n/// everything, even splitting and merging, is safe to use and never too slow.\n///\n/// ## Performance Notes\n///\n/// Because of the head/tail chunking technique, until you push a number of\n/// items above double the tree's branching factor (that's `self.len()` = 2 \n/// *k* (where *k* = 64) = 128) on either side, the data structure is still just\n/// a handful of arrays, not yet an RRB tree, so you'll see performance and\n/// memory characteristics similar to [`Vec`][Vec] or [`VecDeque`][VecDeque].\n///\n/// This means that the structure always preallocates four chunks of size *k*\n/// (*k* being the tree's branching factor), equivalent to a [`Vec`][Vec] with\n/// an initial capacity of 256. Beyond that, it will allocate tree nodes of\n/// capacity *k* as needed.\n///\n/// In addition, vectors start out as single chunks, and only expand into the\n/// full data structure once you go past the chunk size. This makes them\n/// perform identically to [`Vec`][Vec] at small sizes.\n///\n/// [rrbpaper]: https://infoscience.epfl.ch/record/213452/files/rrbvector.pdf\n/// [chunkedseq]: http://deepsea.inria.fr/pasl/chunkedseq.pdf\n/// [Vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n/// [VecDeque]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html\npub struct Vector<A> {\n    vector: VectorInner<A>,\n}","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::append":["/// Append the vector `other` to the end of the current vector.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// let mut vec = vector![1, 2, 3];\n/// vec.append(vector![7, 8, 9]);\n/// assert_eq!(vector![1, 2, 3, 7, 8, 9], vec);\n/// ```\npub fn append(&mut self, mut other: Self){\n        if other.is_empty() {\n            return;\n        }\n\n        if self.is_empty() {\n            replace(self, other);\n            return;\n        }\n\n        self.promote_inline();\n        other.promote_inline();\n\n        let total_length = self\n            .len()\n            .checked_add(other.len())\n            .expect(\"Vector length overflow\");\n\n        match &mut self.vector {\n            Inline(_, _) => unreachable!(\"inline vecs should have been promoted\"),\n            Single(pool, left) => {\n                match &mut other.vector {\n                    Inline(_, _) => unreachable!(\"inline vecs should have been promoted\"),\n                    // If both are single chunks and left has room for right: directly\n                    // memcpy right into left\n                    Single(_, ref mut right) if total_length <= CHUNK_SIZE => {\n                        PoolRef::make_mut(&pool.value_pool, left)\n                            .append(PoolRef::make_mut(&pool.value_pool, right));\n                        return;\n                    }\n                    // If only left is a single chunk and has room for right: push\n                    // right's elements into left\n                    _ if total_length <= CHUNK_SIZE => {\n                        while let Some(value) = other.pop_front() {\n                            PoolRef::make_mut(&pool.value_pool, left).push_back(value);\n                        }\n                        return;\n                    }\n                    _ => {}\n                }\n            }\n            Full(pool, left) => {\n                if let Full(_, mut right) = other.vector {\n                    // If left and right are trees with empty middles, left has no back\n                    // buffers, and right has no front buffers: copy right's back\n                    // buffers over to left\n                    if left.middle.is_empty()\n                        && right.middle.is_empty()\n                        && left.outer_b.is_empty()\n                        && left.inner_b.is_empty()\n                        && right.outer_f.is_empty()\n                        && right.inner_f.is_empty()\n                    {\n                        left.inner_b = right.inner_b;\n                        left.outer_b = right.outer_b;\n                        left.length = total_length;\n                        return;\n                    }\n                    // If left and right are trees with empty middles and left's buffers\n                    // can fit right's buffers: push right's elements onto left\n                    if left.middle.is_empty()\n                        && right.middle.is_empty()\n                        && total_length <= CHUNK_SIZE * 4\n                    {\n                        while let Some(value) = right.pop_front(pool) {\n                            left.push_back(pool, value);\n                        }\n                        return;\n                    }\n                    // Both are full and big: do the full RRB join\n                    let inner_b1 = left.inner_b.clone();\n                    left.push_middle(pool, Side::Right, inner_b1);\n                    let outer_b1 = left.outer_b.clone();\n                    left.push_middle(pool, Side::Right, outer_b1);\n                    let inner_f2 = right.inner_f.clone();\n                    right.push_middle(pool, Side::Left, inner_f2);\n                    let outer_f2 = right.outer_f.clone();\n                    right.push_middle(pool, Side::Left, outer_f2);\n\n                    let mut middle1 = clone_ref(replace(&mut left.middle, Ref::from(Node::new())));\n                    let mut middle2 = clone_ref(right.middle);\n                    let normalised_middle = match left.middle_level.cmp(&right.middle_level) {\n                        Ordering::Greater => {\n                            middle2 = middle2.elevate(pool, left.middle_level - right.middle_level);\n                            left.middle_level\n                        }\n                        Ordering::Less => {\n                            middle1 = middle1.elevate(pool, right.middle_level - left.middle_level);\n                            right.middle_level\n                        }\n                        Ordering::Equal => left.middle_level,\n                    };\n                    left.middle = Ref::new(Node::merge(pool, middle1, middle2, normalised_middle));\n                    left.middle_level = normalised_middle + 1;\n\n                    left.inner_b = right.inner_b;\n                    left.outer_b = right.outer_b;\n                    left.length = total_length;\n                    left.prune();\n                    return;\n                }\n            }\n        }\n        // No optimisations available, and either left, right or both are\n        // single: promote both to full and retry\n        self.promote_front();\n        other.promote_back();\n        self.append(other)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::back":["/// Get the last element of a vector.\n///\n/// If the vector is empty, `None` is returned.\n///\n/// Time: O(log n)\n#[must_use]\npub fn back(&self) -> Option<&A>{\n        if self.is_empty() {\n            None\n        } else {\n            self.get(self.len() - 1)\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::back_mut":["/// Get a mutable reference to the last element of a vector.\n///\n/// If the vector is empty, `None` is returned.\n///\n/// Time: O(log n)\n#[must_use]\npub fn back_mut(&mut self) -> Option<&mut A>{\n        if self.is_empty() {\n            None\n        } else {\n            let len = self.len();\n            self.get_mut(len - 1)\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::binary_search":["/// Binary search a sorted vector for a given element.\n///\n/// If the value is found, it returns `Ok(index)` where `index` is the index\n/// of the element. If the value isn't found, it returns `Err(index)` where\n/// `index` is the index at which the element would need to be inserted to\n/// maintain sorted order.\n///\n/// Time: O(log n)\npub fn binary_search(&self, value: &A) -> Result<usize, usize>\n    where\n        A: Ord,{\n        self.binary_search_by(|e| e.cmp(value))\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::binary_search_by":["/// Binary search a sorted vector for a given element using a comparator\n/// function.\n///\n/// Assumes the vector has already been sorted using the same comparator\n/// function, eg. by using [`sort_by`][sort_by].\n///\n/// If the value is found, it returns `Ok(index)` where `index` is the index\n/// of the element. If the value isn't found, it returns `Err(index)` where\n/// `index` is the index at which the element would need to be inserted to\n/// maintain sorted order.\n///\n/// Time: O(log n)\n///\n/// [sort_by]: #method.sort_by\npub fn binary_search_by<F>(&self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&A) -> Ordering,{\n        let mut size = self.len();\n        if size == 0 {\n            return Err(0);\n        }\n        let mut base = 0;\n        while size > 1 {\n            let half = size / 2;\n            let mid = base + half;\n            base = match f(&self[mid]) {\n                Ordering::Greater => base,\n                _ => mid,\n            };\n            size -= half;\n        }\n        match f(&self[base]) {\n            Ordering::Equal => Ok(base),\n            Ordering::Greater => Err(base),\n            Ordering::Less => Err(base + 1),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::binary_search_by_key":["/// Binary search a sorted vector for a given element with a key extract\n/// function.\n///\n/// Assumes the vector has already been sorted using the same key extract\n/// function, eg. by using [`sort_by_key`][sort_by_key].\n///\n/// If the value is found, it returns `Ok(index)` where `index` is the index\n/// of the element. If the value isn't found, it returns `Err(index)` where\n/// `index` is the index at which the element would need to be inserted to\n/// maintain sorted order.\n///\n/// Time: O(log n)\n///\n/// [sort_by_key]: #method.sort_by_key\npub fn binary_search_by_key<B, F>(&self, b: &B, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&A) -> B,\n        B: Ord,{\n        self.binary_search_by(|k| f(k).cmp(b))\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::clear":["/// Discard all elements from the vector.\n///\n/// This leaves you with an empty vector, and all elements that\n/// were previously inside it are dropped.\n///\n/// Time: O(n)\npub fn clear(&mut self){\n        if !self.is_empty() {\n            self.vector = Inline(self.pool().clone(), InlineArray::new());\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::contains":["/// Test if a given element is in the vector.\n///\n/// Searches the vector for the first occurrence of a given value,\n/// and returns `true if it's there. If it's nowhere to be found\n/// in the vector, it returns `false`.\n///\n/// Time: O(n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::Vector;\n/// let mut vec = vector![1, 2, 3, 4, 5];\n/// assert_eq!(true, vec.contains(&3));\n/// assert_eq!(false, vec.contains(&31337));\n/// ```\n#[inline]\n#[must_use]\npub fn contains(&self, value: &A) -> bool\n    where\n        A: PartialEq,{\n        self.index_of(value).is_some()\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::focus":["/// Construct a [`Focus`][Focus] for a vector.\n///\n/// Time: O(1)\n///\n/// [Focus]: enum.Focus.html\n#[inline]\n#[must_use]\npub fn focus(&self) -> Focus<'_, A>{\n        Focus::new(self)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::focus_mut":["/// Construct a [`FocusMut`][FocusMut] for a vector.\n///\n/// Time: O(1)\n///\n/// [FocusMut]: enum.FocusMut.html\n#[inline]\n#[must_use]\npub fn focus_mut(&mut self) -> FocusMut<'_, A>{\n        FocusMut::new(self)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::front":["/// Get the first element of a vector.\n///\n/// If the vector is empty, `None` is returned.\n///\n/// Time: O(log n)\n#[inline]\n#[must_use]\npub fn front(&self) -> Option<&A>{\n        self.get(0)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::front_mut":["/// Get a mutable reference to the first element of a vector.\n///\n/// If the vector is empty, `None` is returned.\n///\n/// Time: O(log n)\n#[inline]\n#[must_use]\npub fn front_mut(&mut self) -> Option<&mut A>{\n        self.get_mut(0)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::get":["/// Get a reference to the value at index `index` in a vector.\n///\n/// Returns `None` if the index is out of bounds.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::Vector;\n/// let vec = vector![\"Joe\", \"Mike\", \"Robert\"];\n/// assert_eq!(Some(&\"Robert\"), vec.get(2));\n/// assert_eq!(None, vec.get(5));\n/// ```\n#[must_use]\npub fn get(&self, index: usize) -> Option<&A>{\n        if index >= self.len() {\n            return None;\n        }\n\n        match &self.vector {\n            Inline(_, chunk) => chunk.get(index),\n            Single(_, chunk) => chunk.get(index),\n            Full(_, tree) => {\n                let mut local_index = index;\n\n                if local_index < tree.outer_f.len() {\n                    return Some(&tree.outer_f[local_index]);\n                }\n                local_index -= tree.outer_f.len();\n\n                if local_index < tree.inner_f.len() {\n                    return Some(&tree.inner_f[local_index]);\n                }\n                local_index -= tree.inner_f.len();\n\n                if local_index < tree.middle.len() {\n                    return Some(tree.middle.index(tree.middle_level, local_index));\n                }\n                local_index -= tree.middle.len();\n\n                if local_index < tree.inner_b.len() {\n                    return Some(&tree.inner_b[local_index]);\n                }\n                local_index -= tree.inner_b.len();\n\n                Some(&tree.outer_b[local_index])\n            }\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::get_mut":["/// Get a mutable reference to the value at index `index` in a\n/// vector.\n///\n/// Returns `None` if the index is out of bounds.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::Vector;\n/// let mut vec = vector![\"Joe\", \"Mike\", \"Robert\"];\n/// {\n///     let robert = vec.get_mut(2).unwrap();\n///     assert_eq!(&mut \"Robert\", robert);\n///     *robert = \"Bjarne\";\n/// }\n/// assert_eq!(vector![\"Joe\", \"Mike\", \"Bjarne\"], vec);\n/// ```\n#[must_use]\npub fn get_mut(&mut self, index: usize) -> Option<&mut A>{\n        if index >= self.len() {\n            return None;\n        }\n\n        match &mut self.vector {\n            Inline(_, chunk) => chunk.get_mut(index),\n            Single(pool, chunk) => PoolRef::make_mut(&pool.value_pool, chunk).get_mut(index),\n            Full(pool, tree) => {\n                let mut local_index = index;\n\n                if local_index < tree.outer_f.len() {\n                    let outer_f = PoolRef::make_mut(&pool.value_pool, &mut tree.outer_f);\n                    return Some(&mut outer_f[local_index]);\n                }\n                local_index -= tree.outer_f.len();\n\n                if local_index < tree.inner_f.len() {\n                    let inner_f = PoolRef::make_mut(&pool.value_pool, &mut tree.inner_f);\n                    return Some(&mut inner_f[local_index]);\n                }\n                local_index -= tree.inner_f.len();\n\n                if local_index < tree.middle.len() {\n                    let middle = Ref::make_mut(&mut tree.middle);\n                    return Some(middle.index_mut(pool, tree.middle_level, local_index));\n                }\n                local_index -= tree.middle.len();\n\n                if local_index < tree.inner_b.len() {\n                    let inner_b = PoolRef::make_mut(&pool.value_pool, &mut tree.inner_b);\n                    return Some(&mut inner_b[local_index]);\n                }\n                local_index -= tree.inner_b.len();\n\n                let outer_b = PoolRef::make_mut(&pool.value_pool, &mut tree.outer_b);\n                Some(&mut outer_b[local_index])\n            }\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::head":["/// Get the first element of a vector.\n///\n/// If the vector is empty, `None` is returned.\n///\n/// This is an alias for the [`front`][front] method.\n///\n/// Time: O(log n)\n///\n/// [front]: #method.front\n#[inline]\n#[must_use]\npub fn head(&self) -> Option<&A>{\n        self.get(0)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::index_of":["/// Get the index of a given element in the vector.\n///\n/// Searches the vector for the first occurrence of a given value,\n/// and returns the index of the value if it's there. Otherwise,\n/// it returns `None`.\n///\n/// Time: O(n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::Vector;\n/// let mut vec = vector![1, 2, 3, 4, 5];\n/// assert_eq!(Some(2), vec.index_of(&3));\n/// assert_eq!(None, vec.index_of(&31337));\n/// ```\n#[must_use]\npub fn index_of(&self, value: &A) -> Option<usize>\n    where\n        A: PartialEq,{\n        for (index, item) in self.iter().enumerate() {\n            if value == item {\n                return Some(index);\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::insert":["/// Insert an element into a vector.\n///\n/// Insert an element at position `index`, shifting all elements\n/// after it to the right.\n///\n/// ## Performance Note\n///\n/// While `push_front` and `push_back` are heavily optimised\n/// operations, `insert` in the middle of a vector requires a\n/// split, a push, and an append. Thus, if you want to insert\n/// many elements at the same location, instead of `insert`ing\n/// them one by one, you should rather create a new vector\n/// containing the elements to insert, split the vector at the\n/// insertion point, and append the left hand, the new vector and\n/// the right hand in order.\n///\n/// Time: O(log n)\npub fn insert(&mut self, index: usize, value: A){\n        if index == 0 {\n            return self.push_front(value);\n        }\n        if index == self.len() {\n            return self.push_back(value);\n        }\n        assert!(index < self.len());\n        if if let Inline(_, chunk) = &self.vector {\n            chunk.is_full()\n        } else {\n            false\n        } {\n            self.promote_inline();\n        }\n        match &mut self.vector {\n            Inline(_, chunk) => {\n                chunk.insert(index, value);\n            }\n            Single(pool, chunk) if chunk.len() < CHUNK_SIZE => {\n                PoolRef::make_mut(&pool.value_pool, chunk).insert(index, value)\n            }\n            // TODO a lot of optimisations still possible here\n            _ => {\n                let right = self.split_off(index);\n                self.push_back(value);\n                self.append(right);\n            }\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::insert_ord":["/// Insert an element into a sorted vector.\n///\n/// Insert an element into a vector in sorted order, assuming the vector is\n/// already in sorted order.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// let mut vec = vector![1, 2, 3, 7, 8, 9];\n/// vec.insert_ord(5);\n/// assert_eq!(vector![1, 2, 3, 5, 7, 8, 9], vec);\n/// ```\npub fn insert_ord(&mut self, item: A)\n    where\n        A: Ord,{\n        match self.binary_search(&item) {\n            Ok(index) => self.insert(index, item),\n            Err(index) => self.insert(index, item),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::is_empty":["/// Test whether a vector is empty.\n///\n/// Time: O(1)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::Vector;\n/// let vec = vector![\"Joe\", \"Mike\", \"Robert\"];\n/// assert_eq!(false, vec.is_empty());\n/// assert_eq!(true, Vector::<i32>::new().is_empty());\n/// ```\n#[inline]\n#[must_use]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::is_inline":["/// Test whether a vector is currently inlined.\n///\n/// Vectors small enough that their contents could be stored entirely inside\n/// the space of `std::mem::size_of::<Vector<A>>()` bytes are stored inline on\n/// the stack instead of allocating any chunks. This method returns `true` if\n/// this vector is currently inlined, or `false` if it currently has chunks allocated\n/// on the heap.\n///\n/// This may be useful in conjunction with [`ptr_eq()`][ptr_eq], which checks if\n/// two vectors' heap allocations are the same, and thus will never return `true`\n/// for inlined vectors.\n///\n/// Time: O(1)\n///\n/// [ptr_eq]: #method.ptr_eq\n#[inline]\n#[must_use]\npub fn is_inline(&self) -> bool{\n        if let Inline(_, _) = &self.vector {\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::iter":["/// Get an iterator over a vector.\n///\n/// Time: O(1)\n#[inline]\n#[must_use]\npub fn iter(&self) -> Iter<'_, A>{\n        Iter::new(self)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::iter_mut":["/// Get a mutable iterator over a vector.\n///\n/// Time: O(1)\n#[inline]\n#[must_use]\npub fn iter_mut(&mut self) -> IterMut<'_, A>{\n        IterMut::new(self)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::last":["/// Get the last element of a vector.\n///\n/// If the vector is empty, `None` is returned.\n///\n/// This is an alias for the [`back`][back] method.\n///\n/// Time: O(log n)\n///\n/// [back]: #method.back\n#[inline]\n#[must_use]\npub fn last(&self) -> Option<&A>{\n        self.back()\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::leaves":["/// Get an iterator over the leaf nodes of a vector.\n///\n/// This returns an iterator over the [`Chunk`s][Chunk] at the leaves of the\n/// RRB tree. These are useful for efficient parallelisation of work on\n/// the vector, but should not be used for basic iteration.\n///\n/// Time: O(1)\n///\n/// [Chunk]: ../chunk/struct.Chunk.html\n#[inline]\n#[must_use]\npub fn leaves(&self) -> Chunks<'_, A>{\n        Chunks::new(self)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::leaves_mut":["/// Get a mutable iterator over the leaf nodes of a vector.\n/// This returns an iterator over the [`Chunk`s][Chunk] at the leaves of the\n/// RRB tree. These are useful for efficient parallelisation of work on\n/// the vector, but should not be used for basic iteration.\n///\n/// Time: O(1)\n///\n/// [Chunk]: ../chunk/struct.Chunk.html\n#[inline]\n#[must_use]\npub fn leaves_mut(&mut self) -> ChunksMut<'_, A>{\n        ChunksMut::new(self)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::len":["/// Get the length of a vector.\n///\n/// Time: O(1)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// assert_eq!(5, vector![1, 2, 3, 4, 5].len());\n/// ```\n#[inline]\n#[must_use]\npub fn len(&self) -> usize{\n        match &self.vector {\n            Inline(_, chunk) => chunk.len(),\n            Single(_, chunk) => chunk.len(),\n            Full(_, tree) => tree.length,\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::needs_promotion":["/// True if a vector is a full inline or single chunk, ie. must be promoted\n/// to grow further.\nfn needs_promotion(&self) -> bool{\n        match &self.vector {\n            Inline(_, chunk) if chunk.is_full() => true,\n            Single(_, chunk) if chunk.is_full() => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::new":["/// Construct an empty vector.\n#[must_use]\npub fn new() -> Self{\n        Self {\n            vector: Inline(RRBPool::default(), InlineArray::new()),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::pool":["/// Get a reference to the memory pool this `Vector` is using.\n///\n/// Note that if you didn't specifically construct it with a pool, you'll\n/// get back a reference to a pool of size 0.\ndoc = \"hidden\"\npub fn pool(&self) -> &RRBPool<A>{\n        match self.vector {\n            Inline(ref pool, _) => pool,\n            Single(ref pool, _) => pool,\n            Full(ref pool, _) => pool,\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::pop_back":["/// Remove the last element from a vector and return it.\n///\n/// Time: O(1)*\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::Vector;\n/// let mut vec = vector![1, 2, 3];\n/// assert_eq!(Some(3), vec.pop_back());\n/// assert_eq!(vector![1, 2], vec);\n/// ```\npub fn pop_back(&mut self) -> Option<A>{\n        if self.is_empty() {\n            None\n        } else {\n            match &mut self.vector {\n                Inline(_, chunk) => chunk.pop(),\n                Single(pool, chunk) => Some(PoolRef::make_mut(&pool.value_pool, chunk).pop_back()),\n                Full(pool, tree) => tree.pop_back(pool),\n            }\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::pop_front":["/// Remove the first element from a vector and return it.\n///\n/// Time: O(1)*\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::Vector;\n/// let mut vec = vector![1, 2, 3];\n/// assert_eq!(Some(1), vec.pop_front());\n/// assert_eq!(vector![2, 3], vec);\n/// ```\npub fn pop_front(&mut self) -> Option<A>{\n        if self.is_empty() {\n            None\n        } else {\n            match &mut self.vector {\n                Inline(_, chunk) => chunk.remove(0),\n                Single(pool, chunk) => Some(PoolRef::make_mut(&pool.value_pool, chunk).pop_front()),\n                Full(pool, tree) => tree.pop_front(pool),\n            }\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::promote_back":["/// Promote a single to a full, with the single chunk becoming inner_b, or\n/// promote an inline to a single.\nfn promote_back(&mut self){\n        self.vector = match &mut self.vector {\n            Inline(pool, chunk) => {\n                Single(pool.clone(), PoolRef::new(&pool.value_pool, chunk.into()))\n            }\n            Single(pool, chunk) => {\n                let chunk = chunk.clone();\n                Full(\n                    pool.clone(),\n                    RRB {\n                        length: chunk.len(),\n                        middle_level: 0,\n                        outer_f: PoolRef::default(&pool.value_pool),\n                        inner_f: PoolRef::default(&pool.value_pool),\n                        middle: Ref::new(Node::new()),\n                        inner_b: chunk,\n                        outer_b: PoolRef::default(&pool.value_pool),\n                    },\n                )\n            }\n            Full(_, _) => return,\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::promote_front":["/// Promote a single to a full, with the single chunk becoming inner_f, or\n/// promote an inline to a single.\nfn promote_front(&mut self){\n        self.vector = match &mut self.vector {\n            Inline(pool, chunk) => {\n                Single(pool.clone(), PoolRef::new(&pool.value_pool, chunk.into()))\n            }\n            Single(pool, chunk) => {\n                let chunk = chunk.clone();\n                Full(\n                    pool.clone(),\n                    RRB {\n                        length: chunk.len(),\n                        middle_level: 0,\n                        outer_f: PoolRef::default(&pool.value_pool),\n                        inner_f: chunk,\n                        middle: Ref::new(Node::new()),\n                        inner_b: PoolRef::default(&pool.value_pool),\n                        outer_b: PoolRef::default(&pool.value_pool),\n                    },\n                )\n            }\n            Full(_, _) => return,\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::promote_inline":["/// Promote an inline to a single.\nfn promote_inline(&mut self){\n        if let Inline(pool, chunk) = &mut self.vector {\n            self.vector = Single(pool.clone(), PoolRef::new(&pool.value_pool, chunk.into()));\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::ptr_eq":["/// Test whether two vectors refer to the same content in memory.\n///\n/// This uses the following rules to determine equality:\n/// * If the two sides are references to the same vector, return true.\n/// * If the two sides are single chunk vectors pointing to the same chunk, return true.\n/// * If the two sides are full trees pointing to the same chunks, return true.\n///\n/// This would return true if you're comparing a vector to itself, or\n/// if you're comparing a vector to a fresh clone of itself. The exception to this is\n/// if you've cloned an inline array (ie. an array with so few elements they can fit\n/// inside the space a `Vector` allocates for its pointers, so there are no heap allocations\n/// to compare).\n///\n/// Time: O(1), or O(n) for inline vectors\n#[must_use]\npub fn ptr_eq(&self, other: &Self) -> bool{\n        fn cmp_chunk<A>(left: &PoolRef<Chunk<A>>, right: &PoolRef<Chunk<A>>) -> bool {\n            (left.is_empty() && right.is_empty()) || PoolRef::ptr_eq(left, right)\n        }\n\n        if std::ptr::eq(self, other) {\n            return true;\n        }\n\n        match (&self.vector, &other.vector) {\n            (Single(_, left), Single(_, right)) => cmp_chunk(left, right),\n            (Full(_, left), Full(_, right)) => {\n                cmp_chunk(&left.outer_f, &right.outer_f)\n                    && cmp_chunk(&left.inner_f, &right.inner_f)\n                    && cmp_chunk(&left.inner_b, &right.inner_b)\n                    && cmp_chunk(&left.outer_b, &right.outer_b)\n                    && ((left.middle.is_empty() && right.middle.is_empty())\n                        || Ref::ptr_eq(&left.middle, &right.middle))\n            }\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::ptr_eq::cmp_chunk":["fn cmp_chunk<A>(left: &PoolRef<Chunk<A>>, right: &PoolRef<Chunk<A>>) -> bool{\n            (left.is_empty() && right.is_empty()) || PoolRef::ptr_eq(left, right)\n        }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::push_back":["/// Push a value to the back of a vector.\n///\n/// Time: O(1)*\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::Vector;\n/// let mut vec = vector![1, 2, 3];\n/// vec.push_back(4);\n/// assert_eq!(vector![1, 2, 3, 4], vec);\n/// ```\npub fn push_back(&mut self, value: A){\n        if self.needs_promotion() {\n            self.promote_front();\n        }\n        match &mut self.vector {\n            Inline(_, chunk) => {\n                chunk.push(value);\n            }\n            Single(pool, chunk) => PoolRef::make_mut(&pool.value_pool, chunk).push_back(value),\n            Full(pool, tree) => tree.push_back(pool, value),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::push_front":["/// Push a value to the front of a vector.\n///\n/// Time: O(1)*\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::Vector;\n/// let mut vec = vector![5, 6, 7];\n/// vec.push_front(4);\n/// assert_eq!(vector![4, 5, 6, 7], vec);\n/// ```\npub fn push_front(&mut self, value: A){\n        if self.needs_promotion() {\n            self.promote_back();\n        }\n        match &mut self.vector {\n            Inline(_, chunk) => {\n                chunk.insert(0, value);\n            }\n            Single(pool, chunk) => PoolRef::make_mut(&pool.value_pool, chunk).push_front(value),\n            Full(pool, tree) => tree.push_front(pool, value),\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::remove":["/// Remove an element from a vector.\n///\n/// Remove the element from position 'index', shifting all\n/// elements after it to the left, and return the removec element.\n///\n/// ## Performance Note\n///\n/// While `pop_front` and `pop_back` are heavily optimised\n/// operations, `remove` in the middle of a vector requires a\n/// split, a pop, and an append. Thus, if you want to remove many\n/// elements from the same location, instead of `remove`ing them\n/// one by one, it is much better to use [`slice`][slice].\n///\n/// Time: O(log n)\n///\n/// [slice]: #method.slice\npub fn remove(&mut self, index: usize) -> A{\n        assert!(index < self.len());\n        match &mut self.vector {\n            Inline(_, chunk) => chunk.remove(index).unwrap(),\n            Single(pool, chunk) => PoolRef::make_mut(&pool.value_pool, chunk).remove(index),\n            _ => {\n                if index == 0 {\n                    return self.pop_front().unwrap();\n                }\n                if index == self.len() - 1 {\n                    return self.pop_back().unwrap();\n                }\n                // TODO a lot of optimisations still possible here\n                let mut right = self.split_off(index);\n                let value = right.pop_front().unwrap();\n                self.append(right);\n                value\n            }\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::retain":["/// Retain only the elements specified by the predicate.\n///\n/// Remove all elements for which the provided function `f`\n/// returns false from the vector.\n///\n/// Time: O(n)\npub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&A) -> bool,{\n        let len = self.len();\n        let mut del = 0;\n        {\n            let mut focus = self.focus_mut();\n            for i in 0..len {\n                if !f(focus.index(i)) {\n                    del += 1;\n                } else if del > 0 {\n                    focus.swap(i - del, i);\n                }\n            }\n        }\n        if del > 0 {\n            self.split_off(len - del);\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::set":["/// Update the value at index `index` in a vector.\n///\n/// Returns the previous value at the index.\n///\n/// Panics if the index is out of bounds.\n///\n/// Time: O(log n)\n#[inline]\npub fn set(&mut self, index: usize, value: A) -> A{\n        replace(&mut self[index], value)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::skip":["/// Construct a vector with `count` elements removed from the\n/// start of the current vector.\n///\n/// Time: O(log n)\n#[must_use]\npub fn skip(&self, count: usize) -> Self{\n        // FIXME can be made more efficient by dropping the unwanted side without constructing it\n        self.clone().split_off(count)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::slice":["/// Extract a slice from a vector.\n///\n/// Remove the elements from `start_index` until `end_index` in\n/// the current vector and return the removed slice as a new\n/// vector.\n///\n/// Time: O(log n)\npub fn slice<R>(&mut self, range: R) -> Self\n    where\n        R: RangeBounds<usize>,{\n        let r = to_range(&range, self.len());\n        if r.start >= r.end || r.start >= self.len() {\n            return Vector::new();\n        }\n        let mut middle = self.split_off(r.start);\n        let right = middle.split_off(r.end - r.start);\n        self.append(right);\n        middle\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::sort":["/// Sort a vector.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// let mut vec = vector![3, 2, 5, 4, 1];\n/// vec.sort();\n/// assert_eq!(vector![1, 2, 3, 4, 5], vec);\n/// ```\npub fn sort(&mut self)\n    where\n        A: Ord,{\n        self.sort_by(Ord::cmp)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::sort_by":["/// Sort a vector using a comparator function.\n///\n/// Time: O(n log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// let mut vec = vector![3, 2, 5, 4, 1];\n/// vec.sort_by(|left, right| left.cmp(right));\n/// assert_eq!(vector![1, 2, 3, 4, 5], vec);\n/// ```\npub fn sort_by<F>(&mut self, cmp: F)\n    where\n        F: Fn(&A, &A) -> Ordering,{\n        let len = self.len();\n        if len > 1 {\n            sort::quicksort(self.focus_mut(), &cmp);\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::split_at":["/// Split a vector at a given index.\n///\n/// Split a vector at a given index, consuming the vector and\n/// returning a pair of the left hand side and the right hand side\n/// of the split.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// let mut vec = vector![1, 2, 3, 7, 8, 9];\n/// let (left, right) = vec.split_at(3);\n/// assert_eq!(vector![1, 2, 3], left);\n/// assert_eq!(vector![7, 8, 9], right);\n/// ```\npub fn split_at(mut self, index: usize) -> (Self, Self){\n        let right = self.split_off(index);\n        (self, right)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::split_off":["/// Split a vector at a given index.\n///\n/// Split a vector at a given index, leaving the left hand side in\n/// the current vector and returning a new vector containing the\n/// right hand side.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// let mut left = vector![1, 2, 3, 7, 8, 9];\n/// let right = left.split_off(3);\n/// assert_eq!(vector![1, 2, 3], left);\n/// assert_eq!(vector![7, 8, 9], right);\n/// ```\npub fn split_off(&mut self, index: usize) -> Self{\n        assert!(index <= self.len());\n\n        match &mut self.vector {\n            Inline(pool, chunk) => Self {\n                vector: Inline(pool.clone(), chunk.split_off(index)),\n            },\n            Single(pool, chunk) => Self {\n                vector: Single(\n                    pool.clone(),\n                    PoolRef::new(\n                        &pool.value_pool,\n                        PoolRef::make_mut(&pool.value_pool, chunk).split_off(index),\n                    ),\n                ),\n            },\n            Full(pool, tree) => {\n                let mut local_index = index;\n\n                if local_index < tree.outer_f.len() {\n                    let of2 = PoolRef::make_mut(&pool.value_pool, &mut tree.outer_f)\n                        .split_off(local_index);\n                    let right = RRB {\n                        length: tree.length - index,\n                        middle_level: tree.middle_level,\n                        outer_f: PoolRef::new(&pool.value_pool, of2),\n                        inner_f: replace_pool_def(&pool.value_pool, &mut tree.inner_f),\n                        middle: std::mem::take(&mut tree.middle),\n                        inner_b: replace_pool_def(&pool.value_pool, &mut tree.inner_b),\n                        outer_b: replace_pool_def(&pool.value_pool, &mut tree.outer_b),\n                    };\n                    tree.length = index;\n                    tree.middle_level = 0;\n                    return Self {\n                        vector: Full(pool.clone(), right),\n                    };\n                }\n\n                local_index -= tree.outer_f.len();\n\n                if local_index < tree.inner_f.len() {\n                    let if2 = PoolRef::make_mut(&pool.value_pool, &mut tree.inner_f)\n                        .split_off(local_index);\n                    let right = RRB {\n                        length: tree.length - index,\n                        middle_level: tree.middle_level,\n                        outer_f: PoolRef::new(&pool.value_pool, if2),\n                        inner_f: PoolRef::<Chunk<A>>::default(&pool.value_pool),\n                        middle: std::mem::take(&mut tree.middle),\n                        inner_b: replace_pool_def(&pool.value_pool, &mut tree.inner_b),\n                        outer_b: replace_pool_def(&pool.value_pool, &mut tree.outer_b),\n                    };\n                    tree.length = index;\n                    tree.middle_level = 0;\n                    swap(&mut tree.outer_b, &mut tree.inner_f);\n                    return Self {\n                        vector: Full(pool.clone(), right),\n                    };\n                }\n\n                local_index -= tree.inner_f.len();\n\n                if local_index < tree.middle.len() {\n                    let mut right_middle = tree.middle.clone();\n                    let (c1, c2) = {\n                        let m1 = Ref::make_mut(&mut tree.middle);\n                        let m2 = Ref::make_mut(&mut right_middle);\n                        match m1.split(pool, tree.middle_level, Side::Right, local_index) {\n                            SplitResult::Dropped(_) => (),\n                            SplitResult::OutOfBounds => unreachable!(),\n                        };\n                        match m2.split(pool, tree.middle_level, Side::Left, local_index) {\n                            SplitResult::Dropped(_) => (),\n                            SplitResult::OutOfBounds => unreachable!(),\n                        };\n                        let c1 = match m1.pop_chunk(pool, tree.middle_level, Side::Right) {\n                            PopResult::Empty => PoolRef::default(&pool.value_pool),\n                            PopResult::Done(chunk) => chunk,\n                            PopResult::Drained(chunk) => {\n                                m1.clear_node();\n                                chunk\n                            }\n                        };\n                        let c2 = match m2.pop_chunk(pool, tree.middle_level, Side::Left) {\n                            PopResult::Empty => PoolRef::default(&pool.value_pool),\n                            PopResult::Done(chunk) => chunk,\n                            PopResult::Drained(chunk) => {\n                                m2.clear_node();\n                                chunk\n                            }\n                        };\n                        (c1, c2)\n                    };\n                    let mut right = RRB {\n                        length: tree.length - index,\n                        middle_level: tree.middle_level,\n                        outer_f: c2,\n                        inner_f: PoolRef::<Chunk<A>>::default(&pool.value_pool),\n                        middle: right_middle,\n                        inner_b: replace_pool_def(&pool.value_pool, &mut tree.inner_b),\n                        outer_b: replace(&mut tree.outer_b, c1),\n                    };\n                    tree.length = index;\n                    tree.prune();\n                    right.prune();\n                    return Self {\n                        vector: Full(pool.clone(), right),\n                    };\n                }\n\n                local_index -= tree.middle.len();\n\n                if local_index < tree.inner_b.len() {\n                    let ib2 = PoolRef::make_mut(&pool.value_pool, &mut tree.inner_b)\n                        .split_off(local_index);\n                    let right = RRB {\n                        length: tree.length - index,\n                        outer_b: replace_pool_def(&pool.value_pool, &mut tree.outer_b),\n                        outer_f: PoolRef::new(&pool.value_pool, ib2),\n                        ..RRB::new(pool)\n                    };\n                    tree.length = index;\n                    swap(&mut tree.outer_b, &mut tree.inner_b);\n                    return Self {\n                        vector: Full(pool.clone(), right),\n                    };\n                }\n\n                local_index -= tree.inner_b.len();\n\n                let ob2 =\n                    PoolRef::make_mut(&pool.value_pool, &mut tree.outer_b).split_off(local_index);\n                tree.length = index;\n                Self {\n                    vector: Single(pool.clone(), PoolRef::new(&pool.value_pool, ob2)),\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::swap":["/// Swap the elements at indices `i` and `j`.\n///\n/// Time: O(log n)\npub fn swap(&mut self, i: usize, j: usize){\n        swap_indices(self, i, j)\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::take":["/// Construct a vector of the first `count` elements from the\n/// current vector.\n///\n/// Time: O(log n)\n#[must_use]\npub fn take(&self, count: usize) -> Self{\n        // FIXME can be made more efficient by dropping the unwanted side without constructing it\n        let mut left = self.clone();\n        left.split_off(count);\n        left\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::truncate":["/// Truncate a vector to the given size.\n///\n/// Discards all elements in the vector beyond the given length.\n///\n/// Panics if the new length is greater than the current length.\n///\n/// Time: O(log n)\npub fn truncate(&mut self, len: usize){\n        // FIXME can be made more efficient by dropping the unwanted side without constructing it\n        self.split_off(len);\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::unit":["/// Construct a vector with a single value.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// let vec = Vector::unit(1337);\n/// assert_eq!(1, vec.len());\n/// assert_eq!(\n///   vec.get(0),\n///   Some(&1337)\n/// );\n/// ```\n#[inline]\n#[must_use]\npub fn unit(a: A) -> Self{\n        let pool = RRBPool::default();\n        if InlineArray::<A, RRB<A>>::CAPACITY > 0 {\n            let mut array = InlineArray::new();\n            array.push(a);\n            Self {\n                vector: Inline(pool, array),\n            }\n        } else {\n            let chunk = PoolRef::new(&pool.value_pool, Chunk::unit(a));\n            Self {\n                vector: Single(pool, chunk),\n            }\n        }\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::Vector::<A>::update":["/// Create a new vector with the value at index `index` updated.\n///\n/// Panics if the index is out of bounds.\n///\n/// Time: O(log n)\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate im;\n/// # use im::Vector;\n/// let mut vec = vector![1, 2, 3];\n/// assert_eq!(vector![1, 5, 3], vec.update(1, 5));\n/// ```\n#[must_use]\npub fn update(&self, index: usize, value: A) -> Self{\n        let mut out = self.clone();\n        out[index] = value;\n        out\n    }","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::VectorInner":["enum VectorInner<A> {\n    Inline(RRBPool<A>, InlineArray<A, RRB<A>>),\n    Single(RRBPool<A>, PoolRef<Chunk<A>>),\n    Full(RRBPool<A>, RRB<A>),\n}","Real(LocalPath(\"src/vector/mod.rs\"))"],"vector::focus::Focus":["/// Focused indexing over a [`Vector`][Vector].\n///\n/// By remembering the last tree node accessed through an index lookup and the\n/// path we took to get there, we can speed up lookups for adjacent indices\n/// tremendously. Lookups on indices in the same node are instantaneous, and\n/// lookups on sibling nodes are also very fast.\n///\n/// A `Focus` can also be used as a restricted view into a vector, using the\n/// [`narrow`][narrow] and [`split_at`][split_at] methods.\n///\n/// # When should I use a `Focus` for better performance?\n///\n/// `Focus` is useful when you need to perform a large number of index lookups\n/// that are more likely than not to be close to each other. It's usually worth\n/// using a `Focus` in any situation where you're batching a lot of index\n/// lookups together, even if they're not obviously adjacent - there's likely\n/// to be some performance gain for even completely random access.\n///\n/// If you're just iterating forwards or backwards over the [`Vector`][Vector]\n/// in order, you're better off with a regular iterator, which, in fact, is\n/// implemented using a `Focus`, but provides a simpler interface.\n///\n/// If you're just doing a very small number of index lookups, the setup cost\n/// for the `Focus` is probably not worth it.\n///\n/// A `Focus` is never faster than an index lookup on a small [`Vector`][Vector]\n/// with a length below the internal RRB tree's branching factor of 64.\n///\n/// # Examples\n///\n/// This example is contrived, as the better way to iterate forwards or\n/// backwards over a vector is with an actual iterator. Even so, the version\n/// using a `Focus` should run nearly an order of magnitude faster than the\n/// version using index lookups at a length of 1000. It should also be noted\n/// that [`vector::Iter`][Iter] is actually implemented using a `Focus` behind\n/// the scenes, so the performance of the two should be identical.\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// # use std::iter::FromIterator;\n/// let mut vec: Vector<i64> = Vector::from_iter(0..1000);\n///\n/// // Summing a vector, the slow way:\n/// let mut sum = 0;\n/// for i in 0..1000 {\n///     sum += *vec.get(i).unwrap();\n/// }\n/// assert_eq!(499500, sum);\n///\n/// // Summing a vector faster using a Focus:\n/// let mut sum = 0;\n/// let mut focus = vec.focus();\n/// for i in 0..1000 {\n///     sum += *focus.get(i).unwrap();\n/// }\n/// assert_eq!(499500, sum);\n///\n/// // And the easy way, for completeness:\n/// let sum: i64 = vec.iter().sum();\n/// assert_eq!(499500, sum);\n/// ```\n///\n/// [Vector]: enum.Vector.html\n/// [Iter]: struct.Iter.html\n/// [narrow]: #method.narrow\n/// [split_at]: #method.split_at\npub enum Focus<'a, A> {\n    #[doc(hidden)]\n    Single(&'a [A]),\n    #[doc(hidden)]\n    Full(TreeFocus<A>),\n}","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::Focus::<'a, A>::chunk_at":["/// Get the chunk for the given index.\n///\n/// This gives you a reference to the leaf node that contains the index,\n/// along with its start and end indices.\npub fn chunk_at(&mut self, index: usize) -> (Range<usize>, &[A]){\n        let len = self.len();\n        if index >= len {\n            panic!(\"vector::Focus::chunk_at: index out of bounds\");\n        }\n        match self {\n            Focus::Single(chunk) => (0..len, chunk),\n            Focus::Full(tree) => tree.get_chunk(index),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::Focus::<'a, A>::get":["/// Get a reference to the value at a given index.\npub fn get(&mut self, index: usize) -> Option<&A>{\n        match self {\n            Focus::Single(chunk) => chunk.get(index),\n            Focus::Full(tree) => tree.get(index),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::Focus::<'a, A>::index":["/// Get a reference to the value at a given index.\n///\n/// Panics if the index is out of bounds.\npub fn index(&mut self, index: usize) -> &A{\n        self.get(index).expect(\"index out of bounds\")\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::Focus::<'a, A>::is_empty":["/// Test if the focused [`Vector`][Vector] is empty.\n///\n/// [Vector]: enum.Vector.html\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::Focus::<'a, A>::len":["/// Get the length of the focused [`Vector`][Vector].\n///\n/// [Vector]: enum.Vector.html\npub fn len(&self) -> usize{\n        match self {\n            Focus::Single(chunk) => chunk.len(),\n            Focus::Full(tree) => tree.len(),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::Focus::<'a, A>::narrow":["/// Narrow the focus onto a subslice of the vector.\n///\n/// `Focus::narrow(range)` has the same effect as `&slice[range]`, without\n/// actually modifying the underlying vector.\n///\n/// Panics if the range isn't fully inside the current focus.\n///\n/// ## Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// # use std::iter::FromIterator;\n/// let vec = Vector::from_iter(0..1000);\n/// let narrowed = vec.focus().narrow(100..200);\n/// let narrowed_vec = narrowed.into_iter().cloned().collect();\n/// assert_eq!(Vector::from_iter(100..200), narrowed_vec);\n/// ```\n///\n/// [slice::split_at]: https://doc.rust-lang.org/std/primitive.slice.html#method.split_at\n/// [Vector::split_at]: enum.Vector.html#method.split_at\npub fn narrow<R>(self, range: R) -> Self\n    where\n        R: RangeBounds<usize>,{\n        let r = to_range(&range, self.len());\n        if r.start >= r.end || r.start >= self.len() {\n            panic!(\"vector::Focus::narrow: range out of bounds\");\n        }\n        match self {\n            Focus::Single(chunk) => Focus::Single(&chunk[r]),\n            Focus::Full(tree) => Focus::Full(tree.narrow(r)),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::Focus::<'a, A>::new":["/// Construct a `Focus` for a [`Vector`][Vector].\n///\n/// [Vector]: enum.Vector.html\npub fn new(vector: &'a Vector<A>) -> Self{\n        match &vector.vector {\n            Inline(_, chunk) => Focus::Single(chunk),\n            Single(_, chunk) => Focus::Single(chunk),\n            Full(_, tree) => Focus::Full(TreeFocus::new(tree)),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::Focus::<'a, A>::split_at":["/// Split the focus into two.\n///\n/// Given an index `index`, consume the focus and produce two new foci, the\n/// left onto indices `0..index`, and the right onto indices `index..N`\n/// where `N` is the length of the current focus.\n///\n/// Panics if the index is out of bounds.\n///\n/// This is the moral equivalent of [`slice::split_at`][slice::split_at], in\n/// that it leaves the underlying data structure unchanged, unlike\n/// [`Vector::split_at`][Vector::split_at].\n///\n/// ## Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// # use std::iter::FromIterator;\n/// let vec = Vector::from_iter(0..1000);\n/// let (left, right) = vec.focus().split_at(500);\n/// let left_vec = left.into_iter().cloned().collect();\n/// let right_vec = right.into_iter().cloned().collect();\n/// assert_eq!(Vector::from_iter(0..500), left_vec);\n/// assert_eq!(Vector::from_iter(500..1000), right_vec);\n/// ```\n///\n/// [slice::split_at]: https://doc.rust-lang.org/std/primitive.slice.html#method.split_at\n/// [Vector::split_at]: enum.Vector.html#method.split_at\npub fn split_at(self, index: usize) -> (Self, Self){\n        if index >= self.len() {\n            panic!(\"vector::Focus::split_at: index out of bounds\");\n        }\n        match self {\n            Focus::Single(chunk) => {\n                let (left, right) = chunk.split_at(index);\n                (Focus::Single(left), Focus::Single(right))\n            }\n            Focus::Full(tree) => {\n                let (left, right) = tree.split_at(index);\n                (Focus::Full(left), Focus::Full(right))\n            }\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut":["/// A mutable version of [`Focus`][Focus].\n///\n/// See [`Focus`][Focus] for more details.\n///\n/// You can only build one `FocusMut` at a time for a vector, effectively\n/// keeping a lock on the vector until you're done with the focus, which relies\n/// on the structure of the vector not changing while it exists.\n///\n/// ```rust,compile_fail\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// # use std::iter::FromIterator;\n/// let mut vec = Vector::from_iter(0..1000);\n/// let focus1 = vec.focus_mut();\n/// // Fails here in 2015 edition because you're creating\n/// // two mutable references to the same thing.\n/// let focus2 = vec.focus_mut();\n/// // Fails here in 2018 edition because creating focus2\n/// // made focus1's lifetime go out of scope.\n/// assert_eq!(Some(&0), focus1.get(0));\n/// ```\n///\n/// On the other hand, you can split that one focus into multiple sub-focuses,\n/// which is safe because they can't overlap:\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// # use std::iter::FromIterator;\n/// let mut vec = Vector::from_iter(0..1000);\n/// let focus = vec.focus_mut();\n/// let (mut left, mut right) = focus.split_at(500);\n/// assert_eq!(Some(&0), left.get(0));\n/// assert_eq!(Some(&500), right.get(0));\n/// ```\n///\n/// These sub-foci also work as a lock on the vector, even if the focus they\n/// were created from goes out of scope.\n///\n/// ```rust,compile_fail\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// # use std::iter::FromIterator;\n/// let mut vec = Vector::from_iter(0..1000);\n/// let (left, right) = {\n///     let focus = vec.focus_mut();\n///     focus.split_at(500)\n/// };\n/// // `left` and `right` are still in scope even if `focus` isn't, so we can't\n/// // create another focus:\n/// let focus2 = vec.focus_mut();\n/// assert_eq!(Some(&0), left.get(0));\n/// ```\n///\n/// [Focus]: enum.Focus.html\npub enum FocusMut<'a, A> {\n    #[doc(hidden)]\n    Single(RRBPool<A>, &'a mut [A]),\n    #[doc(hidden)]\n    Full(RRBPool<A>, TreeFocusMut<'a, A>),\n}","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::chunk_at":["/// Get the chunk for the given index.\n///\n/// This gives you a reference to the leaf node that contains the index,\n/// along with its start and end indices.\npub fn chunk_at(&mut self, index: usize) -> (Range<usize>, &mut [A]){\n        let len = self.len();\n        if index >= len {\n            panic!(\"vector::FocusMut::chunk_at: index out of bounds\");\n        }\n        match self {\n            FocusMut::Single(_, chunk) => (0..len, chunk),\n            FocusMut::Full(pool, tree) => {\n                let (range, chunk) = tree.get_chunk(pool, index);\n                (range, chunk)\n            }\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::get":["/// Get a reference to the value at a given index.\npub fn get(&mut self, index: usize) -> Option<&A>{\n        self.get_mut(index).map(|r| &*r)\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::get_mut":["/// Get a mutable reference to the value at a given index.\npub fn get_mut(&mut self, index: usize) -> Option<&mut A>{\n        match self {\n            FocusMut::Single(_, chunk) => chunk.get_mut(index),\n            FocusMut::Full(pool, tree) => tree.get(pool, index),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::index":["/// Get a reference to the value at a given index.\n///\n/// Panics if the index is out of bounds.\npub fn index(&mut self, index: usize) -> &A{\n        &*self.index_mut(index)\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::index_mut":["/// Get a mutable reference to the value at a given index.\n///\n/// Panics if the index is out of bounds.\n#[allow(clippy::should_implement_trait)]\npub fn index_mut(&mut self, index: usize) -> &mut A{\n        self.get_mut(index).expect(\"index out of bounds\")\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::is_empty":["/// Test if the focused `Vector` is empty.\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::len":["/// Get the length of the focused `Vector`.\npub fn len(&self) -> usize{\n        match self {\n            FocusMut::Single(_, chunk) => chunk.len(),\n            FocusMut::Full(_, tree) => tree.len(),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::narrow":["/// Narrow the focus onto a subslice of the vector.\n///\n/// `FocusMut::narrow(range)` has the same effect as `&slice[range]`, without\n/// actually modifying the underlying vector.\n///\n/// Panics if the range isn't fully inside the current focus.\n///\n/// ## Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// # use std::iter::FromIterator;\n/// let mut vec = Vector::from_iter(0..1000);\n/// let narrowed = vec.focus_mut().narrow(100..200);\n/// let narrowed_vec = narrowed.unmut().into_iter().cloned().collect();\n/// assert_eq!(Vector::from_iter(100..200), narrowed_vec);\n/// ```\n///\n/// [slice::split_at]: https://doc.rust-lang.org/std/primitive.slice.html#method.split_at\n/// [Vector::split_at]: enum.Vector.html#method.split_at\npub fn narrow<R>(self, range: R) -> Self\n    where\n        R: RangeBounds<usize>,{\n        let r = to_range(&range, self.len());\n        if r.start > r.end || r.start > self.len() {\n            panic!(\"vector::FocusMut::narrow: range out of bounds\");\n        }\n        match self {\n            FocusMut::Single(pool, chunk) => FocusMut::Single(pool, &mut chunk[r]),\n            FocusMut::Full(pool, tree) => FocusMut::Full(pool, tree.narrow(r)),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::new":["/// Construct a `FocusMut` for a `Vector`.\npub fn new(vector: &'a mut Vector<A>) -> Self{\n        match &mut vector.vector {\n            Inline(pool, chunk) => FocusMut::Single(pool.clone(), chunk),\n            Single(pool, chunk) => FocusMut::Single(\n                pool.clone(),\n                PoolRef::make_mut(&pool.value_pool, chunk).as_mut_slice(),\n            ),\n            Full(pool, tree) => FocusMut::Full(pool.clone(), TreeFocusMut::new(tree)),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::pair":["/// Lookup two indices simultaneously and run a function over them.\n///\n/// Useful because the borrow checker won't let you have more than one\n/// mutable reference into the same data structure at any given time.\n///\n/// Panics if either index is out of bounds, or if they are the same index.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// # use std::iter::FromIterator;\n/// let mut vec = vector![1, 2, 3, 4, 5];\n/// vec.focus_mut().pair(1, 3, |a, b| *a += *b);\n/// assert_eq!(vector![1, 6, 3, 4, 5], vec);\n/// ```\n#[allow(unsafe_code)]\npub fn pair<F, B>(&mut self, a: usize, b: usize, mut f: F) -> B\n    where\n        F: FnMut(&mut A, &mut A) -> B,{\n        if a == b {\n            panic!(\"vector::FocusMut::pair: indices cannot be equal!\");\n        }\n        let pa: *mut A = self.index_mut(a);\n        let pb: *mut A = self.index_mut(b);\n        unsafe { f(&mut *pa, &mut *pb) }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::set":["/// Update the value at a given index.\n///\n/// Returns `None` if the index is out of bounds, or the replaced value\n/// otherwise.\npub fn set(&mut self, index: usize, value: A) -> Option<A>{\n        match self.get_mut(index) {\n            Some(ref mut pos) => Some(replace(pos, value)),\n            None => None,\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::split_at":["/// Split the focus into two.\n///\n/// Given an index `index`, consume the focus and produce two new foci, the\n/// left onto indices `0..index`, and the right onto indices `index..N`\n/// where `N` is the length of the current focus.\n///\n/// Panics if the index is out of bounds.\n///\n/// This is the moral equivalent of [`slice::split_at`][slice::split_at], in\n/// that it leaves the underlying data structure unchanged, unlike\n/// [`Vector::split_at`][Vector::split_at].\n///\n/// ## Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// # use std::iter::FromIterator;\n/// let mut vec = Vector::from_iter(0..1000);\n/// {\n///     let (left, right) = vec.focus_mut().split_at(500);\n///     for ptr in left {\n///         *ptr += 100;\n///     }\n///     for ptr in right {\n///         *ptr -= 100;\n///     }\n/// }\n/// let expected = Vector::from_iter(100..600)\n///              + Vector::from_iter(400..900);\n/// assert_eq!(expected, vec);\n/// ```\n///\n/// [slice::split_at]: https://doc.rust-lang.org/std/primitive.slice.html#method.split_at\n/// [Vector::split_at]: enum.Vector.html#method.split_at\n#[allow(clippy::redundant_clone)]\npub fn split_at(self, index: usize) -> (Self, Self){\n        if index > self.len() {\n            panic!(\"vector::FocusMut::split_at: index out of bounds\");\n        }\n        match self {\n            FocusMut::Single(pool, chunk) => {\n                let (left, right) = chunk.split_at_mut(index);\n                (\n                    FocusMut::Single(pool.clone(), left),\n                    FocusMut::Single(pool, right),\n                )\n            }\n            FocusMut::Full(pool, tree) => {\n                let (left, right) = tree.split_at(index);\n                (\n                    FocusMut::Full(pool.clone(), left),\n                    FocusMut::Full(pool, right),\n                )\n            }\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::swap":["/// Swap the values at two given indices.\n///\n/// Panics if either index is out of bounds.\n///\n/// If the indices are equal, this function returns without doing anything.\npub fn swap(&mut self, a: usize, b: usize){\n        if a == b {\n            return;\n        }\n        self.pair(a, b, |left, right| swap(left, right));\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::triplet":["/// Lookup three indices simultaneously and run a function over them.\n///\n/// Useful because the borrow checker won't let you have more than one\n/// mutable reference into the same data structure at any given time.\n///\n/// Panics if any index is out of bounds, or if any indices are equal.\n///\n/// # Examples\n///\n/// ```rust\n/// # #[macro_use] extern crate im;\n/// # use im::vector::Vector;\n/// # use std::iter::FromIterator;\n/// let mut vec = vector![1, 2, 3, 4, 5];\n/// vec.focus_mut().triplet(0, 2, 4, |a, b, c| *a += *b + *c);\n/// assert_eq!(vector![9, 2, 3, 4, 5], vec);\n/// ```\n#[allow(unsafe_code)]\npub fn triplet<F, B>(&mut self, a: usize, b: usize, c: usize, mut f: F) -> B\n    where\n        F: FnMut(&mut A, &mut A, &mut A) -> B,{\n        if a == b || b == c || a == c {\n            panic!(\"vector::FocusMut::triplet: indices cannot be equal!\");\n        }\n        let pa: *mut A = self.index_mut(a);\n        let pb: *mut A = self.index_mut(b);\n        let pc: *mut A = self.index_mut(c);\n        unsafe { f(&mut *pa, &mut *pb, &mut *pc) }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::FocusMut::<'a, A>::unmut":["/// Convert a `FocusMut` into a `Focus`.\npub fn unmut(self) -> Focus<'a, A>{\n        match self {\n            FocusMut::Single(_, chunk) => Focus::Single(chunk),\n            FocusMut::Full(_, mut tree) => Focus::Full(TreeFocus {\n                tree: {\n                    let t = tree.tree.lock().unwrap();\n                    (*t).clone()\n                },\n                view: tree.view.clone(),\n                middle_range: tree.middle_range.clone(),\n                target_range: 0..0,\n                target_ptr: null(),\n            }),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocus":["pub struct TreeFocus<A> {\n    tree: RRB<A>,\n    view: Range<usize>,\n    middle_range: Range<usize>,\n    target_range: Range<usize>,\n    target_ptr: *const Chunk<A>,\n}","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocus::<A>::get":["pub fn get(&mut self, index: usize) -> Option<&A>{\n        if index >= self.len() {\n            return None;\n        }\n        let phys_index = self.physical_index(index);\n        if !contains(&self.target_range, &phys_index) {\n            self.set_focus(phys_index);\n        }\n        let target_phys_index = phys_index - self.target_range.start;\n        Some(&self.get_focus()[target_phys_index])\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocus::<A>::get_chunk":["pub fn get_chunk(&mut self, index: usize) -> (Range<usize>, &[A]){\n        let phys_index = self.physical_index(index);\n        if !contains(&self.target_range, &phys_index) {\n            self.set_focus(phys_index);\n        }\n        let mut slice: &[A] = self.get_focus();\n        let mut left = 0;\n        let mut right = 0;\n        if self.target_range.start < self.view.start {\n            left = self.view.start - self.target_range.start;\n        }\n        if self.target_range.end > self.view.end {\n            right = self.target_range.end - self.view.end;\n        }\n        slice = &slice[left..(slice.len() - right)];\n        let phys_range = (self.target_range.start + left)..(self.target_range.end - right);\n        (self.logical_range(&phys_range), slice)\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocus::<A>::get_focus":["#[allow(unsafe_code)]\nfn get_focus(&self) -> &Chunk<A>{\n        unsafe { &*self.target_ptr }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocus::<A>::len":["fn len(&self) -> usize{\n        self.view.end - self.view.start\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocus::<A>::logical_range":["fn logical_range(&self, range: &Range<usize>) -> Range<usize>{\n        (range.start - self.view.start)..(range.end - self.view.start)\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocus::<A>::narrow":["fn narrow(self, mut view: Range<usize>) -> Self{\n        view.start += self.view.start;\n        view.end += self.view.start;\n        TreeFocus {\n            view,\n            middle_range: self.middle_range.clone(),\n            target_range: 0..0,\n            target_ptr: null(),\n            tree: self.tree,\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocus::<A>::new":["fn new(tree: &RRB<A>) -> Self{\n        let middle_start = tree.outer_f.len() + tree.inner_f.len();\n        let middle_end = middle_start + tree.middle.len();\n        TreeFocus {\n            tree: tree.clone(),\n            view: 0..tree.length,\n            middle_range: middle_start..middle_end,\n            target_range: 0..0,\n            target_ptr: null(),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocus::<A>::physical_index":["fn physical_index(&self, index: usize) -> usize{\n        debug_assert!(index < self.view.end);\n        self.view.start + index\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocus::<A>::set_focus":["fn set_focus(&mut self, index: usize){\n        if index < self.middle_range.start {\n            let outer_len = self.tree.outer_f.len();\n            if index < outer_len {\n                self.target_range = 0..outer_len;\n                self.target_ptr = &*self.tree.outer_f;\n            } else {\n                self.target_range = outer_len..self.middle_range.start;\n                self.target_ptr = &*self.tree.inner_f;\n            }\n        } else if index >= self.middle_range.end {\n            let outer_start = self.middle_range.end + self.tree.inner_b.len();\n            if index < outer_start {\n                self.target_range = self.middle_range.end..outer_start;\n                self.target_ptr = &*self.tree.inner_b;\n            } else {\n                self.target_range = outer_start..self.tree.length;\n                self.target_ptr = &*self.tree.outer_b;\n            }\n        } else {\n            let tree_index = index - self.middle_range.start;\n            let (range, ptr) = self\n                .tree\n                .middle\n                .lookup_chunk(self.tree.middle_level, 0, tree_index);\n            self.target_range =\n                (range.start + self.middle_range.start)..(range.end + self.middle_range.start);\n            self.target_ptr = ptr;\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocus::<A>::split_at":["fn split_at(self, index: usize) -> (Self, Self){\n        let len = self.len();\n        let left = self.clone().narrow(0..index);\n        let right = self.narrow(index..len);\n        (left, right)\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocusMut":["pub struct TreeFocusMut<'a, A> {\n    tree: Lock<&'a mut RRB<A>>,\n    view: Range<usize>,\n    middle_range: Range<usize>,\n    target_range: Range<usize>,\n    target_ptr: AtomicPtr<Chunk<A>>,\n}","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocusMut::<'a, A>::get":["pub fn get(&mut self, pool: &RRBPool<A>, index: usize) -> Option<&mut A>{\n        if index >= self.len() {\n            return None;\n        }\n        let phys_index = self.physical_index(index);\n        if !contains(&self.target_range, &phys_index) {\n            self.set_focus(pool, phys_index);\n        }\n        let target_phys_index = phys_index - self.target_range.start;\n        Some(&mut self.get_focus()[target_phys_index])\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocusMut::<'a, A>::get_chunk":["pub fn get_chunk(&mut self, pool: &RRBPool<A>, index: usize) -> (Range<usize>, &mut [A]){\n        let phys_index = self.physical_index(index);\n        if !contains(&self.target_range, &phys_index) {\n            self.set_focus(pool, phys_index);\n        }\n        let mut left = 0;\n        let mut right = 0;\n        if self.target_range.start < self.view.start {\n            left = self.view.start - self.target_range.start;\n        }\n        if self.target_range.end > self.view.end {\n            right = self.target_range.end - self.view.end;\n        }\n        let phys_range = (self.target_range.start + left)..(self.target_range.end - right);\n        let log_range = self.logical_range(&phys_range);\n        let slice_len = self.get_focus().len();\n        let slice = &mut (self.get_focus().as_mut_slice())[left..(slice_len - right)];\n        (log_range, slice)\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocusMut::<'a, A>::get_focus":["#[allow(unsafe_code)]\nfn get_focus(&mut self) -> &mut Chunk<A>{\n        unsafe { &mut *self.target_ptr.load(Ordering::Relaxed) }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocusMut::<'a, A>::len":["fn len(&self) -> usize{\n        self.view.end - self.view.start\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocusMut::<'a, A>::logical_range":["fn logical_range(&self, range: &Range<usize>) -> Range<usize>{\n        (range.start - self.view.start)..(range.end - self.view.start)\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocusMut::<'a, A>::narrow":["fn narrow(self, mut view: Range<usize>) -> Self{\n        view.start += self.view.start;\n        view.end += self.view.start;\n        TreeFocusMut {\n            view,\n            middle_range: self.middle_range.clone(),\n            target_range: 0..0,\n            target_ptr: AtomicPtr::default(),\n            tree: self.tree,\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocusMut::<'a, A>::new":["fn new(tree: &'a mut RRB<A>) -> Self{\n        let middle_start = tree.outer_f.len() + tree.inner_f.len();\n        let middle_end = middle_start + tree.middle.len();\n        TreeFocusMut {\n            view: 0..tree.length,\n            tree: Lock::new(tree),\n            middle_range: middle_start..middle_end,\n            target_range: 0..0,\n            target_ptr: AtomicPtr::default(),\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocusMut::<'a, A>::physical_index":["fn physical_index(&self, index: usize) -> usize{\n        debug_assert!(index < self.view.end);\n        self.view.start + index\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocusMut::<'a, A>::set_focus":["fn set_focus(&mut self, pool: &RRBPool<A>, index: usize){\n        let mut tree = self\n            .tree\n            .lock()\n            .expect(\"im::vector::Focus::set_focus: unable to acquire exclusive lock on Vector\");\n        if index < self.middle_range.start {\n            let outer_len = tree.outer_f.len();\n            if index < outer_len {\n                self.target_range = 0..outer_len;\n                self.target_ptr.store(\n                    PoolRef::make_mut(&pool.value_pool, &mut tree.outer_f),\n                    Ordering::Relaxed,\n                );\n            } else {\n                self.target_range = outer_len..self.middle_range.start;\n                self.target_ptr.store(\n                    PoolRef::make_mut(&pool.value_pool, &mut tree.inner_f),\n                    Ordering::Relaxed,\n                );\n            }\n        } else if index >= self.middle_range.end {\n            let outer_start = self.middle_range.end + tree.inner_b.len();\n            if index < outer_start {\n                self.target_range = self.middle_range.end..outer_start;\n                self.target_ptr.store(\n                    PoolRef::make_mut(&pool.value_pool, &mut tree.inner_b),\n                    Ordering::Relaxed,\n                );\n            } else {\n                self.target_range = outer_start..tree.length;\n                self.target_ptr.store(\n                    PoolRef::make_mut(&pool.value_pool, &mut tree.outer_b),\n                    Ordering::Relaxed,\n                );\n            }\n        } else {\n            let tree_index = index - self.middle_range.start;\n            let level = tree.middle_level;\n            let middle = Ref::make_mut(&mut tree.middle);\n            let (range, ptr) = middle.lookup_chunk_mut(pool, level, 0, tree_index);\n            self.target_range =\n                (range.start + self.middle_range.start)..(range.end + self.middle_range.start);\n            self.target_ptr.store(ptr, Ordering::Relaxed);\n        }\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::TreeFocusMut::<'a, A>::split_at":["fn split_at(self, index: usize) -> (Self, Self){\n        let len = self.len();\n        debug_assert!(index <= len);\n        #[allow(unsafe_code)]\n        let left = TreeFocusMut {\n            view: self.view.start..(self.view.start + index),\n            middle_range: self.middle_range.clone(),\n            target_range: 0..0,\n            target_ptr: AtomicPtr::default(),\n            tree: self.tree.clone(),\n        };\n        let right = TreeFocusMut {\n            view: (self.view.start + index)..(self.view.start + len),\n            middle_range: self.middle_range.clone(),\n            target_range: 0..0,\n            target_ptr: AtomicPtr::default(),\n            tree: self.tree,\n        };\n        (left, right)\n    }","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::focus::contains":["#[inline]\nfn contains<A: Ord>(range: &Range<A>, index: &A) -> bool{\n    *index >= range.start && *index < range.end\n}","Real(LocalPath(\"src/vector/focus.rs\"))"],"vector::pool::RRBPool":["/// A memory pool for `Vector`.\npub struct RRBPool<A> {\n    pub(crate) node_pool: Pool<Chunk<Node<A>>>,\n    pub(crate) value_pool: Pool<Chunk<A>>,\n    pub(crate) size_pool: Pool<Chunk<usize>>,\n}","Real(LocalPath(\"src/vector/pool.rs\"))"],"vector::pool::RRBPool::<A>::fill":["/// Fill the memory pool with preallocated chunks.\npub fn fill(&self){\n        self.node_pool.fill();\n        self.value_pool.fill();\n        self.size_pool.fill();\n    }","Real(LocalPath(\"src/vector/pool.rs\"))"],"vector::pool::RRBPool::<A>::leaf_pool_size":["/// Get the size of the leaf node subpool.\npub fn leaf_pool_size(&self) -> usize{\n        self.value_pool.get_pool_size()\n    }","Real(LocalPath(\"src/vector/pool.rs\"))"],"vector::pool::RRBPool::<A>::new":["/// Create a new memory pool with the given size.\npub fn new(size: usize) -> Self{\n        Self::with_sizes(size, size, size)\n    }","Real(LocalPath(\"src/vector/pool.rs\"))"],"vector::pool::RRBPool::<A>::node_pool_size":["/// Get the size of the node subpool.\npub fn node_pool_size(&self) -> usize{\n        self.node_pool.get_pool_size()\n    }","Real(LocalPath(\"src/vector/pool.rs\"))"],"vector::pool::RRBPool::<A>::size_table_pool_size":["/// Get the size of the size table subpool.\npub fn size_table_pool_size(&self) -> usize{\n        self.size_pool.get_pool_size()\n    }","Real(LocalPath(\"src/vector/pool.rs\"))"],"vector::pool::RRBPool::<A>::with_sizes":["/// Create a new memory pool with the given sizes for each subpool.\npub fn with_sizes(\n        node_pool_size: usize,\n        leaf_pool_size: usize,\n        size_table_pool_size: usize,\n    ) -> Self{\n        Self {\n            node_pool: Pool::new(node_pool_size),\n            value_pool: Pool::new(leaf_pool_size),\n            size_pool: Pool::new(size_table_pool_size),\n        }\n    }","Real(LocalPath(\"src/vector/pool.rs\"))"],"vector::replace_pool_def":["#[inline]\nfn replace_pool_def<A: PoolDefault>(pool: &Pool<A>, dest: &mut PoolRef<A>) -> PoolRef<A>{\n    replace(dest, PoolRef::default(pool))\n}","Real(LocalPath(\"src/vector/mod.rs\"))"]},"struct_constructor":{"&(K, V)":["get_max","get_min"],"&<(K, V) as nodes::hamt::HashValue>::Key":["extract_key"],"&<Self as nodes::hamt::HashValue>::Key":["extract_key"],"&<fakepool::Arc<A> as std::ops::Deref>::Target":["deref"],"&<fakepool::Rc<A> as std::ops::Deref>::Target":["deref"],"&<hash::map::HashMap<K, V, S> as std::ops::Index<&'a BK>>::Output":["index"],"&<hash::set::Value<A> as nodes::hamt::HashValue>::Key":["extract_key"],"&<hash::set::Value<A> as std::ops::Deref>::Target":["deref"],"&<ord::map::OrdMap<K, V> as std::ops::Index<&'a BK>>::Output":["index"],"&<ord::set::Value<A> as std::ops::Deref>::Target":["deref"],"&<vector::Vector<A> as std::ops::Index<usize>>::Output":["index"],"&mut <hash::map::HashMap<K, V, S> as std::ops::Index<&'a BK>>::Output":["index_mut"],"&mut <ord::map::OrdMap<K, V> as std::ops::Index<&'a BK>>::Output":["index_mut"],"&mut <vector::Vector<A> as std::ops::Index<usize>>::Output":["index_mut"],"(&K, &V)":["get_key_value","get_next","get_prev"],"(&K, &mut V)":["get_next_mut","get_prev_mut"],"(A, std::option::Option<fakepool::Arc<nodes::btree::Node<A>>>)":["pop_max","pop_min"],"(K, V)":["remove_entry","remove_with_key"],"(K, V, hash::map::HashMap<K, V, S>)":["extract_with_key"],"(K, V, ord::map::OrdMap<K, V>)":["extract_with_key"],"(V, hash::map::HashMap<K, V, S>)":["extract"],"(V, ord::map::OrdMap<K, V>)":["extract"],"(ord::map::OrdMap<K, V>, ord::map::OrdMap<K, V>)":["split"],"(ord::map::OrdMap<K, V>, std::option::Option<V>, ord::map::OrdMap<K, V>)":["split_lookup"],"(ord::set::OrdSet<A>, bool, ord::set::OrdSet<A>)":["split_member"],"(ord::set::OrdSet<A>, ord::set::OrdSet<A>)":["split"],"(std::ops::Range<usize>, &[A])":["chunk_at","get_chunk"],"(std::ops::Range<usize>, &mut [A])":["chunk_at","get_chunk"],"(std::ops::Range<usize>, *const sized_chunks::Chunk<A>)":["lookup_chunk"],"(std::ops::Range<usize>, *mut sized_chunks::Chunk<A>)":["lookup_chunk_mut"],"(std::option::Option<(K, V)>, ord::map::OrdMap<K, V>)":["without_max_with_key","without_min_with_key"],"(std::option::Option<A>, ord::set::OrdSet<A>)":["without_max","without_min"],"(std::option::Option<V>, hash::map::HashMap<K, V, S>)":["update_lookup_with_key"],"(std::option::Option<V>, ord::map::OrdMap<K, V>)":["update_lookup_with_key","without_max","without_min"],"(usize, std::option::Option<usize>)":["size_hint"],"(vector::Vector<A>, vector::Vector<A>)":["split_at"],"(vector::focus::Focus<'a, A>, vector::focus::Focus<'a, A>)":["split_at"],"(vector::focus::FocusMut<'a, A>, vector::focus::FocusMut<'a, A>)":["split_at"],"(vector::focus::TreeFocus<A>, vector::focus::TreeFocus<A>)":["split_at"],"(vector::focus::TreeFocusMut<'a, A>, vector::focus::TreeFocusMut<'a, A>)":["split_at"],"<&'a hash::map::HashMap<K, V, S> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a hash::map::HashMap<K, V, S> as std::ops::Add>::Output":["add"],"<&'a hash::set::HashSet<A, S> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a hash::set::HashSet<A, S> as std::ops::Add>::Output":["add"],"<&'a hash::set::HashSet<A, S> as std::ops::Mul>::Output":["mul"],"<&'a ord::map::OrdMap<K, V> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a ord::map::OrdMap<K, V> as std::ops::Add>::Output":["add"],"<&'a ord::set::OrdSet<A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a ord::set::OrdSet<A> as std::ops::Add>::Output":["add"],"<&'a ord::set::OrdSet<A> as std::ops::Mul>::Output":["mul"],"<&'a vector::Vector<A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a vector::Vector<A> as std::ops::Add>::Output":["add"],"<<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0> as typenum::Pow<typenum::UInt<typenum::UInt<typenum::UInt<typenum::UTerm, typenum::B1>, typenum::B0>, typenum::B1>>>::Output as bitmaps::Bits>::Store":["hash_key"],"<hash::map::ConsumingIter<A> as std::iter::Iterator>::Item":["next"],"<hash::map::HashMap<K, V, S> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<hash::map::HashMap<K, V, S> as std::ops::Add>::Output":["add"],"<hash::map::Iter<'a, K, V> as std::iter::Iterator>::Item":["next"],"<hash::map::IterMut<'a, K, V> as std::iter::Iterator>::Item":["next"],"<hash::map::Keys<'a, K, V> as std::iter::Iterator>::Item":["next"],"<hash::map::Values<'a, K, V> as std::iter::Iterator>::Item":["next"],"<hash::set::ConsumingIter<A> as std::iter::Iterator>::Item":["next"],"<hash::set::HashSet<A, S> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<hash::set::HashSet<A, S> as std::ops::Add>::Output":["add"],"<hash::set::HashSet<A, S> as std::ops::Mul>::Output":["mul"],"<hash::set::Iter<'a, A> as std::iter::Iterator>::Item":["next"],"<nodes::btree::ConsumingIter<A> as std::iter::Iterator>::Item":["next","next_back"],"<nodes::btree::DiffIter<'a, A> as std::iter::Iterator>::Item":["next"],"<nodes::btree::Iter<'a, A> as std::iter::Iterator>::Item":["next","next_back"],"<nodes::hamt::Drain<A> as std::iter::Iterator>::Item":["next"],"<nodes::hamt::Iter<'a, A> as std::iter::Iterator>::Item":["next"],"<nodes::hamt::IterMut<'a, A> as std::iter::Iterator>::Item":["next"],"<ord::map::DiffIter<'a, K, V> as std::iter::Iterator>::Item":["next"],"<ord::map::Iter<'a, K, V> as std::iter::Iterator>::Item":["next","next_back"],"<ord::map::Keys<'a, K, V> as std::iter::Iterator>::Item":["next","next_back"],"<ord::map::OrdMap<K, V> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<ord::map::OrdMap<K, V> as std::ops::Add>::Output":["add"],"<ord::map::Values<'a, K, V> as std::iter::Iterator>::Item":["next","next_back"],"<ord::set::ConsumingIter<A> as std::iter::Iterator>::Item":["next"],"<ord::set::DiffIter<'a, A> as std::iter::Iterator>::Item":["next"],"<ord::set::Iter<'a, A> as std::iter::Iterator>::Item":["next","next_back"],"<ord::set::OrdSet<A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<ord::set::OrdSet<A> as std::ops::Add>::Output":["add"],"<ord::set::OrdSet<A> as std::ops::Mul>::Output":["mul"],"<ord::set::RangedIter<'a, A> as std::iter::Iterator>::Item":["next","next_back"],"<vector::Chunks<'a, A> as std::iter::Iterator>::Item":["next","next_back"],"<vector::ChunksMut<'a, A> as std::iter::Iterator>::Item":["next","next_back"],"<vector::ConsumingIter<A> as std::iter::Iterator>::Item":["next","next_back"],"<vector::Iter<'a, A> as std::iter::Iterator>::Item":["next","next_back"],"<vector::IterMut<'a, A> as std::iter::Iterator>::Item":["next","next_back"],"<vector::Vector<A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<vector::Vector<A> as std::ops::Add>::Output":["add"],"<vector::focus::Focus<'a, A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<vector::focus::FocusMut<'a, A> as std::iter::IntoIterator>::IntoIter":["into_iter"],"bool":["child_contains","cmp_chunk","contains","contains_key","eq","has_room","is_completely_dense","is_dense","is_empty","is_empty_node","is_full","is_inline","is_leaf","is_proper_submap","is_proper_submap_by","is_proper_subset","is_single","is_size","is_submap","is_submap_by","is_subset","is_value","needs_promotion","ptr_eq","test_eq","too_small"],"fakepool::Arc":["clone","clone_from","default","new","pop_middle","replace_pool_def"],"fakepool::Pool":["clone","new"],"fakepool::Rc":["clone","clone_from","default","new"],"hash::map::Entry":["entry"],"hash::map::HashMap":["alter","clone","default","from","from_iter","new","new_from","sum","unions","unions_with","unions_with_key","unit","update","update_with","update_with_key","with_hasher","without"],"hash::map::HashMapPool":["clone","default","new"],"hash::map::Iter":["iter"],"hash::map::IterMut":["iter_mut"],"hash::map::Keys":["keys"],"hash::map::Values":["values"],"hash::set::HashSet":["clone","default","from","from_iter","new","new_from","sum","unions","unit","update","with_hasher","without"],"hash::set::HashSetPool":["clone","default","new"],"hash::set::Iter":["iter"],"hash::set::Value":["clone"],"impl std::iter::Iterator<Item = A>":["unfold"],"nodes::btree::ConsumingIter":["new"],"nodes::btree::DiffIter":["new"],"nodes::btree::Insert":["insert","split"],"nodes::btree::Iter":["new"],"nodes::btree::Node":["clone","default","unit"],"nodes::btree::Remove":["remove","remove_index"],"nodes::hamt::CollisionNode":["clone","new"],"nodes::hamt::Drain":["new"],"nodes::hamt::Entry":["clone","from","from_node","pop"],"nodes::hamt::Iter":["new"],"nodes::hamt::IterMut":["new"],"nodes::hamt::Node":["clone","default","merge_values","new","pair","unit"],"nodes::rrb::Entry":["clone"],"nodes::rrb::Node":["clone","default","from_chunk","new","parent","pop_child_node"],"nodes::rrb::PopResult":["pop_chunk"],"nodes::rrb::PushResult":["push_chunk"],"nodes::rrb::Size":["clone","table_from_size"],"nodes::rrb::SplitResult":["split"],"ord::map::DiffIter":["diff"],"ord::map::Entry":["entry"],"ord::map::Iter":["iter","range"],"ord::map::Keys":["keys"],"ord::map::OrdMap":["alter","clone","default","from","from_iter","new","skip","sum","take","unions","unions_with","unions_with_key","unit","update","without"],"ord::map::OrdMapPool":["clone","default","new"],"ord::map::Values":["values"],"ord::set::DiffIter":["diff"],"ord::set::Iter":["iter"],"ord::set::OrdSet":["clone","default","from","from_iter","new","skip","sum","take","unions","unit","update","without"],"ord::set::OrdSetPool":["clone","default","new"],"ord::set::RangedIter":["range"],"ord::set::Value":["clone"],"sized_chunks::Chunk":["nodes","values"],"std::cmp::Ordering":["cmp","cmp_keys","cmp_values","partial_cmp"],"std::ops::Range":["logical_range","to_range"],"std::sync::MutexGuard":["lock"],"sync::lock::Lock":["clone","new"],"usize":["binary_search","binary_search_by","binary_search_by_key","get_pool_size","index_of","leaf_pool_size","len","linear_search_by","node_pool_size","number_of_children","pool_size","search_key","search_value","size","size_table_pool_size"],"util::Side":["clone"],"vector::Chunks":["leaves","new"],"vector::ChunksMut":["leaves_mut","new"],"vector::ConsumingIter":["new"],"vector::Iter":["from_focus","iter","new"],"vector::IterMut":["from_focus","iter_mut","new"],"vector::RRB":["clone","new"],"vector::Vector":["clone","default","from","from_iter","new","skip","slice","split_off","sum","take","unit","update"],"vector::focus::Focus":["clone","focus","into","new","unmut"],"vector::focus::FocusMut":["focus_mut","new"],"vector::focus::TreeFocus":["clone","new"],"vector::focus::TreeFocusMut":["new"],"vector::pool::RRBPool":["clone","default","new","with_sizes"]},"struct_to_trait":{"fakepool::Arc":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::ops::Deref"],"fakepool::Pool":["std::clone::Clone"],"fakepool::Rc":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::ops::Deref"],"hash::map::ConsumingIter":["std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"hash::map::HashMap":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::iter::Sum","std::ops::Add","std::ops::Index","std::ops::IndexMut"],"hash::map::HashMapPool":["std::clone::Clone","std::default::Default"],"hash::map::Iter":["std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"hash::map::IterMut":["std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"hash::map::Keys":["std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"hash::map::Values":["std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"hash::set::ConsumingIter":["std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"hash::set::HashSet":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::iter::Sum","std::ops::Add","std::ops::Mul"],"hash::set::HashSetPool":["std::clone::Clone","std::default::Default"],"hash::set::Iter":["std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"hash::set::Value":["nodes::hamt::HashValue","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref"],"nodes::btree::ConsumingIter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"nodes::btree::DiffItem":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"nodes::btree::DiffIter":["std::iter::Iterator"],"nodes::btree::Iter":["std::iter::DoubleEndedIterator","std::iter::Iterator"],"nodes::btree::Node":["fakepool::PoolClone","fakepool::PoolDefault","std::clone::Clone","std::default::Default"],"nodes::chunk::Chunk":["fakepool::PoolClone","fakepool::PoolDefault"],"nodes::hamt::CollisionNode":["std::clone::Clone"],"nodes::hamt::Drain":["std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"nodes::hamt::Entry":["std::clone::Clone","std::convert::From"],"nodes::hamt::Iter":["std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"nodes::hamt::IterMut":["std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"nodes::hamt::Node":["fakepool::PoolClone","fakepool::PoolDefault","std::clone::Clone","std::default::Default","std::fmt::Debug"],"nodes::rrb::Entry":["std::clone::Clone"],"nodes::rrb::Node":["std::clone::Clone","std::default::Default"],"nodes::rrb::Size":["std::clone::Clone","std::fmt::Debug"],"ord::map::DiffItem":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ord::map::DiffIter":["std::iter::Iterator"],"ord::map::Iter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"ord::map::Keys":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"ord::map::OrdMap":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::iter::Sum","std::ops::Add","std::ops::Index","std::ops::IndexMut"],"ord::map::OrdMapPool":["std::clone::Clone","std::default::Default"],"ord::map::Values":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"ord::set::ConsumingIter":["std::iter::Iterator"],"ord::set::DiffIter":["std::iter::Iterator"],"ord::set::Iter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator"],"ord::set::OrdSet":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::iter::Sum","std::ops::Add","std::ops::Mul"],"ord::set::OrdSetPool":["std::clone::Clone","std::default::Default"],"ord::set::RangedIter":["std::iter::DoubleEndedIterator","std::iter::Iterator"],"ord::set::Value":["nodes::btree::BTreeValue","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref"],"sync::lock::Lock":["std::clone::Clone"],"util::Side":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"vector::Chunks":["std::iter::DoubleEndedIterator","std::iter::FusedIterator","std::iter::Iterator"],"vector::ChunksMut":["std::iter::DoubleEndedIterator","std::iter::FusedIterator","std::iter::Iterator"],"vector::ConsumingIter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"vector::Iter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"vector::IterMut":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"vector::RRB":["std::clone::Clone"],"vector::Vector":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::iter::Sum","std::ops::Add","std::ops::Index","std::ops::IndexMut"],"vector::focus::Focus":["std::clone::Clone","std::iter::IntoIterator"],"vector::focus::FocusMut":["std::convert::Into","std::iter::IntoIterator"],"vector::focus::TreeFocus":["std::clone::Clone","std::marker::Send","std::marker::Sync"],"vector::pool::RRBPool":["std::clone::Clone","std::default::Default"]},"targets":{"<&'a hash::map::HashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::IntoIterator"],"<&'a hash::map::HashMap<K, V, S> as std::ops::Add>::add":["add","Real(LocalPath(\"src/hash/map.rs\"))","std::ops::Add"],"<&'a hash::set::HashSet<A, S> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/hash/set.rs\"))","std::iter::IntoIterator"],"<&'a hash::set::HashSet<A, S> as std::ops::Add>::add":["add","Real(LocalPath(\"src/hash/set.rs\"))","std::ops::Add"],"<&'a hash::set::HashSet<A, S> as std::ops::Mul>::mul":["mul","Real(LocalPath(\"src/hash/set.rs\"))","std::ops::Mul"],"<&'a ord::map::OrdMap<K, V> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::IntoIterator"],"<&'a ord::map::OrdMap<K, V> as std::ops::Add>::add":["add","Real(LocalPath(\"src/ord/map.rs\"))","std::ops::Add"],"<&'a ord::set::OrdSet<A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::IntoIterator"],"<&'a ord::set::OrdSet<A> as std::ops::Add>::add":["add","Real(LocalPath(\"src/ord/set.rs\"))","std::ops::Add"],"<&'a ord::set::OrdSet<A> as std::ops::Mul>::mul":["mul","Real(LocalPath(\"src/ord/set.rs\"))","std::ops::Mul"],"<&'a vector::Vector<A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::IntoIterator"],"<&'a vector::Vector<A> as std::ops::Add>::add":["add","Real(LocalPath(\"src/vector/mod.rs\"))","std::ops::Add"],"<fakepool::Arc<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/fakepool.rs\"))","std::clone::Clone"],"<fakepool::Arc<A> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/fakepool.rs\"))","std::cmp::PartialEq"],"<fakepool::Arc<A> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/fakepool.rs\"))","std::fmt::Debug"],"<fakepool::Arc<A> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/fakepool.rs\"))","std::ops::Deref"],"<fakepool::Pool<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/fakepool.rs\"))","std::clone::Clone"],"<fakepool::Rc<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/fakepool.rs\"))","std::clone::Clone"],"<fakepool::Rc<A> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/fakepool.rs\"))","std::cmp::PartialEq"],"<fakepool::Rc<A> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/fakepool.rs\"))","std::fmt::Debug"],"<fakepool::Rc<A> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/fakepool.rs\"))","std::ops::Deref"],"<hash::map::ConsumingIter<A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Iterator"],"<hash::map::ConsumingIter<A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Iterator"],"<hash::map::HashMap<K, V, S> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/hash/map.rs\"))","std::clone::Clone"],"<hash::map::HashMap<K, V, S> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/hash/map.rs\"))","std::cmp::Ord"],"<hash::map::HashMap<K, V, S> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/hash/map.rs\"))","std::cmp::PartialEq"],"<hash::map::HashMap<K, V, S> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/hash/map.rs\"))","std::cmp::PartialOrd"],"<hash::map::HashMap<K, V, S> as std::convert::AsRef<hash::map::HashMap<K, V, S>>>::as_ref":["as_ref","Real(LocalPath(\"src/hash/map.rs\"))","std::convert::AsRef"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a [(K, V)]>>::from":["from","Real(LocalPath(\"src/hash/map.rs\"))","std::convert::From"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a std::collections::BTreeMap<K, V>>>::from":["from","Real(LocalPath(\"src/hash/map.rs\"))","std::convert::From"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a std::collections::HashMap<K, V>>>::from":["from","Real(LocalPath(\"src/hash/map.rs\"))","std::convert::From"],"<hash::map::HashMap<K, V, S> as std::convert::From<&'a std::vec::Vec<(K, V)>>>::from":["from","Real(LocalPath(\"src/hash/map.rs\"))","std::convert::From"],"<hash::map::HashMap<K, V, S> as std::convert::From<std::collections::BTreeMap<K, V>>>::from":["from","Real(LocalPath(\"src/hash/map.rs\"))","std::convert::From"],"<hash::map::HashMap<K, V, S> as std::convert::From<std::collections::HashMap<K, V>>>::from":["from","Real(LocalPath(\"src/hash/map.rs\"))","std::convert::From"],"<hash::map::HashMap<K, V, S> as std::convert::From<std::vec::Vec<(K, V)>>>::from":["from","Real(LocalPath(\"src/hash/map.rs\"))","std::convert::From"],"<hash::map::HashMap<K, V, S> as std::default::Default>::default":["default","Real(LocalPath(\"src/hash/map.rs\"))","std::default::Default"],"<hash::map::HashMap<K, V, S> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hash/map.rs\"))","std::fmt::Debug"],"<hash::map::HashMap<K, V, S> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/hash/map.rs\"))","std::hash::Hash"],"<hash::map::HashMap<K, V, S> as std::iter::Extend<(RK, RV)>>::extend":["extend","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Extend"],"<hash::map::HashMap<K, V, S> as std::iter::FromIterator<(K, V)>>::from_iter":["from_iter","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::FromIterator"],"<hash::map::HashMap<K, V, S> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::IntoIterator"],"<hash::map::HashMap<K, V, S> as std::iter::Sum>::sum":["sum","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Sum"],"<hash::map::HashMap<K, V, S> as std::ops::Add>::add":["add","Real(LocalPath(\"src/hash/map.rs\"))","std::ops::Add"],"<hash::map::HashMap<K, V, S> as std::ops::Index<&'a BK>>::index":["index","Real(LocalPath(\"src/hash/map.rs\"))","std::ops::Index"],"<hash::map::HashMap<K, V, S> as std::ops::IndexMut<&'a BK>>::index_mut":["index_mut","Real(LocalPath(\"src/hash/map.rs\"))","std::ops::IndexMut"],"<hash::map::HashMap<OK, OV, SB> as std::convert::From<&'m hash::map::HashMap<&'k K, &'v V, SA>>>::from":["from","Real(LocalPath(\"src/hash/map.rs\"))","std::convert::From"],"<hash::map::HashMapPool<K, V> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/util.rs\"))","std::clone::Clone"],"<hash::map::HashMapPool<K, V> as std::default::Default>::default":["default","Real(LocalPath(\"src/util.rs\"))","std::default::Default"],"<hash::map::Iter<'a, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Iterator"],"<hash::map::Iter<'a, K, V> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Iterator"],"<hash::map::IterMut<'a, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Iterator"],"<hash::map::IterMut<'a, K, V> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Iterator"],"<hash::map::Keys<'a, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Iterator"],"<hash::map::Keys<'a, K, V> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Iterator"],"<hash::map::Values<'a, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Iterator"],"<hash::map::Values<'a, K, V> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/hash/map.rs\"))","std::iter::Iterator"],"<hash::set::ConsumingIter<A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hash/set.rs\"))","std::iter::Iterator"],"<hash::set::ConsumingIter<A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/hash/set.rs\"))","std::iter::Iterator"],"<hash::set::HashSet<A, S> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/hash/set.rs\"))","std::clone::Clone"],"<hash::set::HashSet<A, S> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/hash/set.rs\"))","std::cmp::Ord"],"<hash::set::HashSet<A, S> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/hash/set.rs\"))","std::cmp::PartialEq"],"<hash::set::HashSet<A, S> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/hash/set.rs\"))","std::cmp::PartialOrd"],"<hash::set::HashSet<A, S> as std::convert::From<&'a [A]>>::from":["from","Real(LocalPath(\"src/hash/set.rs\"))","std::convert::From"],"<hash::set::HashSet<A, S> as std::convert::From<&'a ord::set::OrdSet<A>>>::from":["from","Real(LocalPath(\"src/hash/set.rs\"))","std::convert::From"],"<hash::set::HashSet<A, S> as std::convert::From<&'a std::collections::BTreeSet<A>>>::from":["from","Real(LocalPath(\"src/hash/set.rs\"))","std::convert::From"],"<hash::set::HashSet<A, S> as std::convert::From<&'a std::collections::HashSet<A>>>::from":["from","Real(LocalPath(\"src/hash/set.rs\"))","std::convert::From"],"<hash::set::HashSet<A, S> as std::convert::From<&'a std::vec::Vec<A>>>::from":["from","Real(LocalPath(\"src/hash/set.rs\"))","std::convert::From"],"<hash::set::HashSet<A, S> as std::convert::From<ord::set::OrdSet<A>>>::from":["from","Real(LocalPath(\"src/hash/set.rs\"))","std::convert::From"],"<hash::set::HashSet<A, S> as std::convert::From<std::collections::HashSet<A>>>::from":["from","Real(LocalPath(\"src/hash/set.rs\"))","std::convert::From"],"<hash::set::HashSet<A, S> as std::convert::From<std::vec::Vec<A>>>::from":["from","Real(LocalPath(\"src/hash/set.rs\"))","std::convert::From"],"<hash::set::HashSet<A, S> as std::default::Default>::default":["default","Real(LocalPath(\"src/hash/set.rs\"))","std::default::Default"],"<hash::set::HashSet<A, S> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hash/set.rs\"))","std::fmt::Debug"],"<hash::set::HashSet<A, S> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/hash/set.rs\"))","std::hash::Hash"],"<hash::set::HashSet<A, S> as std::iter::Extend<R>>::extend":["extend","Real(LocalPath(\"src/hash/set.rs\"))","std::iter::Extend"],"<hash::set::HashSet<A, S> as std::iter::FromIterator<RA>>::from_iter":["from_iter","Real(LocalPath(\"src/hash/set.rs\"))","std::iter::FromIterator"],"<hash::set::HashSet<A, S> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/hash/set.rs\"))","std::iter::IntoIterator"],"<hash::set::HashSet<A, S> as std::iter::Sum>::sum":["sum","Real(LocalPath(\"src/hash/set.rs\"))","std::iter::Sum"],"<hash::set::HashSet<A, S> as std::ops::Add>::add":["add","Real(LocalPath(\"src/hash/set.rs\"))","std::ops::Add"],"<hash::set::HashSet<A, S> as std::ops::Mul>::mul":["mul","Real(LocalPath(\"src/hash/set.rs\"))","std::ops::Mul"],"<hash::set::HashSet<OA, SB> as std::convert::From<&'s hash::set::HashSet<&'a A, SA>>>::from":["from","Real(LocalPath(\"src/hash/set.rs\"))","std::convert::From"],"<hash::set::HashSetPool<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/util.rs\"))","std::clone::Clone"],"<hash::set::HashSetPool<A> as std::default::Default>::default":["default","Real(LocalPath(\"src/util.rs\"))","std::default::Default"],"<hash::set::Iter<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hash/set.rs\"))","std::iter::Iterator"],"<hash::set::Iter<'a, A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/hash/set.rs\"))","std::iter::Iterator"],"<hash::set::Value<A> as nodes::hamt::HashValue>::extract_key":["extract_key","Real(LocalPath(\"src/hash/set.rs\"))","nodes::hamt::HashValue"],"<hash::set::Value<A> as nodes::hamt::HashValue>::ptr_eq":["ptr_eq","Real(LocalPath(\"src/hash/set.rs\"))","nodes::hamt::HashValue"],"<hash::set::Value<A> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/hash/set.rs\"))","std::ops::Deref"],"<nodes::btree::ConsumingIter<A> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/nodes/btree.rs\"))","std::iter::DoubleEndedIterator"],"<nodes::btree::ConsumingIter<A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/nodes/btree.rs\"))","std::iter::Iterator"],"<nodes::btree::ConsumingIter<A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/nodes/btree.rs\"))","std::iter::Iterator"],"<nodes::btree::DiffIter<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/nodes/btree.rs\"))","std::iter::Iterator"],"<nodes::btree::Iter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/nodes/btree.rs\"))","std::iter::DoubleEndedIterator"],"<nodes::btree::Iter<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/nodes/btree.rs\"))","std::iter::Iterator"],"<nodes::btree::Iter<'a, A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/nodes/btree.rs\"))","std::iter::Iterator"],"<nodes::btree::Node<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/nodes/btree.rs\"))","std::clone::Clone"],"<nodes::btree::Node<A> as std::default::Default>::default":["default","Real(LocalPath(\"src/nodes/btree.rs\"))","std::default::Default"],"<nodes::hamt::Drain<A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/nodes/hamt.rs\"))","std::iter::Iterator"],"<nodes::hamt::Drain<A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/nodes/hamt.rs\"))","std::iter::Iterator"],"<nodes::hamt::Entry<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/nodes/hamt.rs\"))","std::clone::Clone"],"<nodes::hamt::Entry<A> as std::convert::From<nodes::hamt::CollisionNode<A>>>::from":["from","Real(LocalPath(\"src/nodes/hamt.rs\"))","std::convert::From"],"<nodes::hamt::Iter<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/nodes/hamt.rs\"))","std::iter::Iterator"],"<nodes::hamt::Iter<'a, A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/nodes/hamt.rs\"))","std::iter::Iterator"],"<nodes::hamt::IterMut<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/nodes/hamt.rs\"))","std::iter::Iterator"],"<nodes::hamt::IterMut<'a, A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/nodes/hamt.rs\"))","std::iter::Iterator"],"<nodes::hamt::Node<A> as std::default::Default>::default":["default","Real(LocalPath(\"src/nodes/hamt.rs\"))","std::default::Default"],"<nodes::hamt::Node<A> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/nodes/hamt.rs\"))","std::fmt::Debug"],"<nodes::rrb::Entry<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/nodes/rrb.rs\"))","std::clone::Clone"],"<nodes::rrb::Node<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/nodes/rrb.rs\"))","std::clone::Clone"],"<nodes::rrb::Node<A> as std::default::Default>::default":["default","Real(LocalPath(\"src/nodes/rrb.rs\"))","std::default::Default"],"<nodes::rrb::Size as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/nodes/rrb.rs\"))","std::clone::Clone"],"<ord::map::DiffIter<'a, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::Iterator"],"<ord::map::Iter<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::DoubleEndedIterator"],"<ord::map::Iter<'a, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::Iterator"],"<ord::map::Iter<'a, K, V> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::Iterator"],"<ord::map::Keys<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::DoubleEndedIterator"],"<ord::map::Keys<'a, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::Iterator"],"<ord::map::Keys<'a, K, V> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::Iterator"],"<ord::map::OrdMap<K, V> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/ord/map.rs\"))","std::clone::Clone"],"<ord::map::OrdMap<K, V> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/ord/map.rs\"))","std::cmp::Ord"],"<ord::map::OrdMap<K, V> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/ord/map.rs\"))","std::cmp::PartialEq"],"<ord::map::OrdMap<K, V> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/ord/map.rs\"))","std::cmp::PartialOrd"],"<ord::map::OrdMap<K, V> as std::convert::AsRef<ord::map::OrdMap<K, V>>>::as_ref":["as_ref","Real(LocalPath(\"src/ord/map.rs\"))","std::convert::AsRef"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a [(RK, RV)]>>::from":["from","Real(LocalPath(\"src/ord/map.rs\"))","std::convert::From"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a hash::map::HashMap<K, V, S>>>::from":["from","Real(LocalPath(\"src/ord/map.rs\"))","std::convert::From"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a std::collections::BTreeMap<RK, RV>>>::from":["from","Real(LocalPath(\"src/ord/map.rs\"))","std::convert::From"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a std::collections::HashMap<RK, RV>>>::from":["from","Real(LocalPath(\"src/ord/map.rs\"))","std::convert::From"],"<ord::map::OrdMap<K, V> as std::convert::From<&'a std::vec::Vec<(RK, RV)>>>::from":["from","Real(LocalPath(\"src/ord/map.rs\"))","std::convert::From"],"<ord::map::OrdMap<K, V> as std::convert::From<hash::map::HashMap<K, V, S>>>::from":["from","Real(LocalPath(\"src/ord/map.rs\"))","std::convert::From"],"<ord::map::OrdMap<K, V> as std::convert::From<std::collections::BTreeMap<RK, RV>>>::from":["from","Real(LocalPath(\"src/ord/map.rs\"))","std::convert::From"],"<ord::map::OrdMap<K, V> as std::convert::From<std::collections::HashMap<RK, RV>>>::from":["from","Real(LocalPath(\"src/ord/map.rs\"))","std::convert::From"],"<ord::map::OrdMap<K, V> as std::convert::From<std::vec::Vec<(RK, RV)>>>::from":["from","Real(LocalPath(\"src/ord/map.rs\"))","std::convert::From"],"<ord::map::OrdMap<K, V> as std::default::Default>::default":["default","Real(LocalPath(\"src/ord/map.rs\"))","std::default::Default"],"<ord::map::OrdMap<K, V> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ord/map.rs\"))","std::fmt::Debug"],"<ord::map::OrdMap<K, V> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/ord/map.rs\"))","std::hash::Hash"],"<ord::map::OrdMap<K, V> as std::iter::Extend<(RK, RV)>>::extend":["extend","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::Extend"],"<ord::map::OrdMap<K, V> as std::iter::FromIterator<(RK, RV)>>::from_iter":["from_iter","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::FromIterator"],"<ord::map::OrdMap<K, V> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::IntoIterator"],"<ord::map::OrdMap<K, V> as std::iter::Sum>::sum":["sum","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::Sum"],"<ord::map::OrdMap<K, V> as std::ops::Add>::add":["add","Real(LocalPath(\"src/ord/map.rs\"))","std::ops::Add"],"<ord::map::OrdMap<K, V> as std::ops::Index<&'a BK>>::index":["index","Real(LocalPath(\"src/ord/map.rs\"))","std::ops::Index"],"<ord::map::OrdMap<K, V> as std::ops::IndexMut<&'a BK>>::index_mut":["index_mut","Real(LocalPath(\"src/ord/map.rs\"))","std::ops::IndexMut"],"<ord::map::OrdMap<OK, OV> as std::convert::From<&'m ord::map::OrdMap<&'k K, &'v V>>>::from":["from","Real(LocalPath(\"src/ord/map.rs\"))","std::convert::From"],"<ord::map::OrdMapPool<K, V> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/util.rs\"))","std::clone::Clone"],"<ord::map::OrdMapPool<K, V> as std::default::Default>::default":["default","Real(LocalPath(\"src/util.rs\"))","std::default::Default"],"<ord::map::Values<'a, K, V> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::DoubleEndedIterator"],"<ord::map::Values<'a, K, V> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::Iterator"],"<ord::map::Values<'a, K, V> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/ord/map.rs\"))","std::iter::Iterator"],"<ord::set::ConsumingIter<A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::Iterator"],"<ord::set::DiffIter<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::Iterator"],"<ord::set::Iter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::DoubleEndedIterator"],"<ord::set::Iter<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::Iterator"],"<ord::set::Iter<'a, A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::Iterator"],"<ord::set::OrdSet<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/ord/set.rs\"))","std::clone::Clone"],"<ord::set::OrdSet<A> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/ord/set.rs\"))","std::cmp::Ord"],"<ord::set::OrdSet<A> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/ord/set.rs\"))","std::cmp::PartialEq"],"<ord::set::OrdSet<A> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/ord/set.rs\"))","std::cmp::PartialOrd"],"<ord::set::OrdSet<A> as std::convert::From<&'a [A]>>::from":["from","Real(LocalPath(\"src/ord/set.rs\"))","std::convert::From"],"<ord::set::OrdSet<A> as std::convert::From<&'a hash::set::HashSet<A, S>>>::from":["from","Real(LocalPath(\"src/ord/set.rs\"))","std::convert::From"],"<ord::set::OrdSet<A> as std::convert::From<&'a std::collections::BTreeSet<A>>>::from":["from","Real(LocalPath(\"src/ord/set.rs\"))","std::convert::From"],"<ord::set::OrdSet<A> as std::convert::From<&'a std::collections::HashSet<A>>>::from":["from","Real(LocalPath(\"src/ord/set.rs\"))","std::convert::From"],"<ord::set::OrdSet<A> as std::convert::From<&'a std::vec::Vec<A>>>::from":["from","Real(LocalPath(\"src/ord/set.rs\"))","std::convert::From"],"<ord::set::OrdSet<A> as std::convert::From<hash::set::HashSet<A, S>>>::from":["from","Real(LocalPath(\"src/ord/set.rs\"))","std::convert::From"],"<ord::set::OrdSet<A> as std::convert::From<std::collections::BTreeSet<A>>>::from":["from","Real(LocalPath(\"src/ord/set.rs\"))","std::convert::From"],"<ord::set::OrdSet<A> as std::convert::From<std::collections::HashSet<A>>>::from":["from","Real(LocalPath(\"src/ord/set.rs\"))","std::convert::From"],"<ord::set::OrdSet<A> as std::convert::From<std::vec::Vec<A>>>::from":["from","Real(LocalPath(\"src/ord/set.rs\"))","std::convert::From"],"<ord::set::OrdSet<A> as std::default::Default>::default":["default","Real(LocalPath(\"src/ord/set.rs\"))","std::default::Default"],"<ord::set::OrdSet<A> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ord/set.rs\"))","std::fmt::Debug"],"<ord::set::OrdSet<A> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/ord/set.rs\"))","std::hash::Hash"],"<ord::set::OrdSet<A> as std::iter::Extend<R>>::extend":["extend","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::Extend"],"<ord::set::OrdSet<A> as std::iter::FromIterator<R>>::from_iter":["from_iter","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::FromIterator"],"<ord::set::OrdSet<A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::IntoIterator"],"<ord::set::OrdSet<A> as std::iter::Sum>::sum":["sum","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::Sum"],"<ord::set::OrdSet<A> as std::ops::Add>::add":["add","Real(LocalPath(\"src/ord/set.rs\"))","std::ops::Add"],"<ord::set::OrdSet<A> as std::ops::Mul>::mul":["mul","Real(LocalPath(\"src/ord/set.rs\"))","std::ops::Mul"],"<ord::set::OrdSet<OA> as std::convert::From<&'s ord::set::OrdSet<&'a A>>>::from":["from","Real(LocalPath(\"src/ord/set.rs\"))","std::convert::From"],"<ord::set::OrdSetPool<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/util.rs\"))","std::clone::Clone"],"<ord::set::OrdSetPool<A> as std::default::Default>::default":["default","Real(LocalPath(\"src/util.rs\"))","std::default::Default"],"<ord::set::RangedIter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::DoubleEndedIterator"],"<ord::set::RangedIter<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::Iterator"],"<ord::set::RangedIter<'a, A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/ord/set.rs\"))","std::iter::Iterator"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::cmp_keys":["cmp_keys","Real(LocalPath(\"src/ord/set.rs\"))","nodes::btree::BTreeValue"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::cmp_values":["cmp_values","Real(LocalPath(\"src/ord/set.rs\"))","nodes::btree::BTreeValue"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::ptr_eq":["ptr_eq","Real(LocalPath(\"src/ord/set.rs\"))","nodes::btree::BTreeValue"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::search_key":["search_key","Real(LocalPath(\"src/ord/set.rs\"))","nodes::btree::BTreeValue"],"<ord::set::Value<A> as nodes::btree::BTreeValue>::search_value":["search_value","Real(LocalPath(\"src/ord/set.rs\"))","nodes::btree::BTreeValue"],"<ord::set::Value<A> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/ord/set.rs\"))","std::ops::Deref"],"<sync::lock::Lock<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/sync.rs\"))","std::clone::Clone"],"<vector::Chunks<'a, A> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::DoubleEndedIterator"],"<vector::Chunks<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::Iterator"],"<vector::ChunksMut<'a, A> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::DoubleEndedIterator"],"<vector::ChunksMut<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::Iterator"],"<vector::ConsumingIter<A> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::DoubleEndedIterator"],"<vector::ConsumingIter<A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::Iterator"],"<vector::ConsumingIter<A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::Iterator"],"<vector::Iter<'a, A> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::DoubleEndedIterator"],"<vector::Iter<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::Iterator"],"<vector::Iter<'a, A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::Iterator"],"<vector::IterMut<'a, A> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::DoubleEndedIterator"],"<vector::IterMut<'a, A> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::Iterator"],"<vector::IterMut<'a, A> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::Iterator"],"<vector::RRB<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/vector/mod.rs\"))","std::clone::Clone"],"<vector::Vector<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/vector/mod.rs\"))","std::clone::Clone"],"<vector::Vector<A> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/vector/mod.rs\"))","std::cmp::Ord"],"<vector::Vector<A> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/vector/mod.rs\"))","std::cmp::PartialEq"],"<vector::Vector<A> as std::cmp::PartialEq>::eq::cmp_chunk":["cmp_chunk","Real(LocalPath(\"src/vector/mod.rs\"))",""],"<vector::Vector<A> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/vector/mod.rs\"))","std::cmp::PartialOrd"],"<vector::Vector<A> as std::convert::From<&'a [A]>>::from":["from","Real(LocalPath(\"src/vector/mod.rs\"))","std::convert::From"],"<vector::Vector<A> as std::convert::From<&'a std::vec::Vec<A>>>::from":["from","Real(LocalPath(\"src/vector/mod.rs\"))","std::convert::From"],"<vector::Vector<A> as std::convert::From<std::vec::Vec<A>>>::from":["from","Real(LocalPath(\"src/vector/mod.rs\"))","std::convert::From"],"<vector::Vector<A> as std::default::Default>::default":["default","Real(LocalPath(\"src/vector/mod.rs\"))","std::default::Default"],"<vector::Vector<A> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/vector/mod.rs\"))","std::fmt::Debug"],"<vector::Vector<A> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/vector/mod.rs\"))","std::hash::Hash"],"<vector::Vector<A> as std::iter::Extend<A>>::extend":["extend","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::Extend"],"<vector::Vector<A> as std::iter::FromIterator<A>>::from_iter":["from_iter","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::FromIterator"],"<vector::Vector<A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::IntoIterator"],"<vector::Vector<A> as std::iter::Sum>::sum":["sum","Real(LocalPath(\"src/vector/mod.rs\"))","std::iter::Sum"],"<vector::Vector<A> as std::ops::Add>::add":["add","Real(LocalPath(\"src/vector/mod.rs\"))","std::ops::Add"],"<vector::Vector<A> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/vector/mod.rs\"))","std::ops::Index"],"<vector::Vector<A> as std::ops::IndexMut<usize>>::index_mut":["index_mut","Real(LocalPath(\"src/vector/mod.rs\"))","std::ops::IndexMut"],"<vector::Vector<OA> as std::convert::From<&'s vector::Vector<&'a A>>>::from":["from","Real(LocalPath(\"src/vector/mod.rs\"))","std::convert::From"],"<vector::focus::Focus<'a, A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/vector/focus.rs\"))","std::clone::Clone"],"<vector::focus::Focus<'a, A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/vector/focus.rs\"))","std::iter::IntoIterator"],"<vector::focus::FocusMut<'a, A> as std::convert::Into<vector::focus::Focus<'a, A>>>::into":["into","Real(LocalPath(\"src/vector/focus.rs\"))","std::convert::Into"],"<vector::focus::FocusMut<'a, A> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/vector/focus.rs\"))","std::iter::IntoIterator"],"<vector::focus::TreeFocus<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/vector/focus.rs\"))","std::clone::Clone"],"<vector::pool::RRBPool<A> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/vector/pool.rs\"))","std::clone::Clone"],"<vector::pool::RRBPool<A> as std::default::Default>::default":["default","Real(LocalPath(\"src/vector/pool.rs\"))","std::default::Default"],"fakepool::Arc::<A>::clone_from":["clone_from","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Arc::<A>::default":["default","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Arc::<A>::make_mut":["make_mut","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Arc::<A>::new":["new","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Arc::<A>::ptr_eq":["ptr_eq","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Arc::<A>::unwrap_or_clone":["unwrap_or_clone","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Pool::<A>::fill":["fill","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Pool::<A>::get_pool_size":["get_pool_size","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Pool::<A>::new":["new","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Rc::<A>::clone_from":["clone_from","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Rc::<A>::default":["default","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Rc::<A>::make_mut":["make_mut","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Rc::<A>::new":["new","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Rc::<A>::ptr_eq":["ptr_eq","Real(LocalPath(\"src/fakepool.rs\"))",""],"fakepool::Rc::<A>::unwrap_or_clone":["unwrap_or_clone","Real(LocalPath(\"src/fakepool.rs\"))",""],"hash::map::<impl nodes::hamt::HashValue for (K, V)>::extract_key":["extract_key","Real(LocalPath(\"src/hash/map.rs\"))","nodes::hamt::HashValue"],"hash::map::<impl nodes::hamt::HashValue for (K, V)>::ptr_eq":["ptr_eq","Real(LocalPath(\"src/hash/map.rs\"))","nodes::hamt::HashValue"],"hash::map::Entry::<'a, K, V, S>::and_modify":["and_modify","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::Entry::<'a, K, V, S>::key":["key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::Entry::<'a, K, V, S>::or_default":["or_default","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::Entry::<'a, K, V, S>::or_insert":["or_insert","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::Entry::<'a, K, V, S>::or_insert_with":["or_insert_with","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::alter":["alter","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::clear":["clear","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::contains_key":["contains_key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::difference":["difference","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::difference_with":["difference_with","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::difference_with_key":["difference_with_key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::entry":["entry","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::extract":["extract","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::extract_with_key":["extract_with_key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::get":["get","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::get_key_value":["get_key_value","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::get_mut":["get_mut","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::hasher":["hasher","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::insert":["insert","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::intersection":["intersection","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::intersection_with":["intersection_with","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::intersection_with_key":["intersection_with_key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::is_empty":["is_empty","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::is_proper_submap":["is_proper_submap","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::is_proper_submap_by":["is_proper_submap_by","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::is_submap":["is_submap","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::is_submap_by":["is_submap_by","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::iter":["iter","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::iter_mut":["iter_mut","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::keys":["keys","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::len":["len","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::new_from":["new_from","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::ptr_eq":["ptr_eq","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::relative_complement":["relative_complement","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::remove":["remove","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::remove_with_key":["remove_with_key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::retain":["retain","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::symmetric_difference_with":["symmetric_difference_with","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::symmetric_difference_with_key":["symmetric_difference_with_key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::test_eq":["test_eq","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::union":["union","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::union_with":["union_with","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::union_with_key":["union_with_key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::unions":["unions","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::unions_with":["unions_with","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::unions_with_key":["unions_with_key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::update":["update","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::update_lookup_with_key":["update_lookup_with_key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::update_with":["update_with","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::update_with_key":["update_with_key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::values":["values","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::with_hasher":["with_hasher","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V, S>::without":["without","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V>::new":["new","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMap::<K, V>::unit":["unit","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::HashMapPool::<K, V>::fill":["fill","Real(LocalPath(\"src/util.rs\"))",""],"hash::map::HashMapPool::<K, V>::new":["new","Real(LocalPath(\"src/util.rs\"))",""],"hash::map::HashMapPool::<K, V>::pool_size":["pool_size","Real(LocalPath(\"src/util.rs\"))",""],"hash::map::OccupiedEntry::<'a, K, V, S>::get":["get","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::OccupiedEntry::<'a, K, V, S>::get_mut":["get_mut","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::OccupiedEntry::<'a, K, V, S>::insert":["insert","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::OccupiedEntry::<'a, K, V, S>::into_mut":["into_mut","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::OccupiedEntry::<'a, K, V, S>::key":["key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::OccupiedEntry::<'a, K, V, S>::remove":["remove","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::OccupiedEntry::<'a, K, V, S>::remove_entry":["remove_entry","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::VacantEntry::<'a, K, V, S>::insert":["insert","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::VacantEntry::<'a, K, V, S>::into_key":["into_key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::map::VacantEntry::<'a, K, V, S>::key":["key","Real(LocalPath(\"src/hash/map.rs\"))",""],"hash::set::HashSet::<A, S>::clear":["clear","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::contains":["contains","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::difference":["difference","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::hasher":["hasher","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::insert":["insert","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::intersection":["intersection","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::is_empty":["is_empty","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::is_proper_subset":["is_proper_subset","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::is_subset":["is_subset","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::iter":["iter","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::len":["len","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::new_from":["new_from","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::ptr_eq":["ptr_eq","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::relative_complement":["relative_complement","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::remove":["remove","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::retain":["retain","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::test_eq":["test_eq","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::union":["union","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::unions":["unions","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::update":["update","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::with_hasher":["with_hasher","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A, S>::without":["without","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A>::new":["new","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSet::<A>::unit":["unit","Real(LocalPath(\"src/hash/set.rs\"))",""],"hash::set::HashSetPool::<A>::fill":["fill","Real(LocalPath(\"src/util.rs\"))",""],"hash::set::HashSetPool::<A>::new":["new","Real(LocalPath(\"src/util.rs\"))",""],"hash::set::HashSetPool::<A>::pool_size":["pool_size","Real(LocalPath(\"src/util.rs\"))",""],"iter::unfold":["unfold","Real(LocalPath(\"src/iter.rs\"))",""],"nodes::btree::ConsumingIter::<A>::new":["new","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::ConsumingIter::<A>::push":["push","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::ConsumingIter::<A>::push_back":["push_back","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::ConsumingIter::<A>::push_fwd":["push_fwd","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::ConsumingIter::<A>::push_node":["push_node","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::ConsumingIter::<A>::push_node_back":["push_node_back","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::DiffIter::<'a, A>::new":["new","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::DiffIter::<'a, A>::push":["push","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::DiffIter::<'a, A>::push_node":["push_node","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Iter::<'a, A>::get":["get","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Iter::<'a, A>::new":["new","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Iter::<'a, A>::step_back":["step_back","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Iter::<'a, A>::step_forward":["step_forward","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::child_contains":["child_contains","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::has_room":["has_room","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::insert":["insert","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::is_leaf":["is_leaf","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::lookup":["lookup","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::lookup_mut":["lookup_mut","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::lookup_next":["lookup_next","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::lookup_next_mut":["lookup_next_mut","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::lookup_prev":["lookup_prev","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::lookup_prev_mut":["lookup_prev_mut","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::max":["max","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::merge":["merge","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::min":["min","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::new_from_split":["new_from_split","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::path_first":["path_first","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::path_last":["path_last","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::path_next":["path_next","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::path_prev":["path_prev","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::pop_max":["pop_max","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::pop_min":["pop_min","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::push_max":["push_max","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::push_min":["push_min","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::remove":["remove","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::remove_index":["remove_index","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::split":["split","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::too_small":["too_small","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::btree::Node::<A>::unit":["unit","Real(LocalPath(\"src/nodes/btree.rs\"))",""],"nodes::hamt::CollisionNode::<A>::get":["get","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::CollisionNode::<A>::get_mut":["get_mut","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::CollisionNode::<A>::insert":["insert","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::CollisionNode::<A>::len":["len","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::CollisionNode::<A>::new":["new","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::CollisionNode::<A>::pop":["pop","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::CollisionNode::<A>::remove":["remove","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Drain::<A>::new":["new","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Entry::<A>::from_node":["from_node","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Entry::<A>::is_value":["is_value","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Entry::<A>::unwrap_value":["unwrap_value","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Iter::<'a, A>::new":["new","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::IterMut::<'a, A>::new":["new","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Node::<A>::get":["get","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Node::<A>::get_mut":["get_mut","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Node::<A>::insert":["insert","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Node::<A>::len":["len","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Node::<A>::merge_values":["merge_values","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Node::<A>::new":["new","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Node::<A>::pair":["pair","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Node::<A>::pop":["pop","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Node::<A>::remove":["remove","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Node::<A>::single_child":["single_child","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::Node::<A>::unit":["unit","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::hash_key":["hash_key","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::hamt::mask":["mask","Real(LocalPath(\"src/nodes/hamt.rs\"))",""],"nodes::rrb::Entry::<A>::is_empty_node":["is_empty_node","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Entry::<A>::is_full":["is_full","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Entry::<A>::len":["len","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Entry::<A>::nodes":["nodes","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Entry::<A>::unwrap_nodes":["unwrap_nodes","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Entry::<A>::unwrap_nodes_mut":["unwrap_nodes_mut","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Entry::<A>::unwrap_values":["unwrap_values","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Entry::<A>::unwrap_values_mut":["unwrap_values_mut","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Entry::<A>::values":["values","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::clear_node":["clear_node","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::elevate":["elevate","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::first_child":["first_child","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::from_chunk":["from_chunk","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::index":["index","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::index_in":["index_in","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::index_mut":["index_mut","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::is_completely_dense":["is_completely_dense","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::is_dense":["is_dense","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::is_empty":["is_empty","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::is_full":["is_full","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::is_single":["is_single","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::join_branches":["join_branches","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::join_dense":["join_dense","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::len":["len","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::lookup_chunk":["lookup_chunk","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::lookup_chunk_mut":["lookup_chunk_mut","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::merge":["merge","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::merge_leaves":["merge_leaves","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::merge_rebalance":["merge_rebalance","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::new":["new","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::number_of_children":["number_of_children","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::parent":["parent","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::pop_child_node":["pop_child_node","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::pop_chunk":["pop_chunk","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::pop_size":["pop_size","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::push_child_node":["push_child_node","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::push_chunk":["push_chunk","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::push_size":["push_size","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::single_parent":["single_parent","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::size":["size","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::size_up_to":["size_up_to","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::split":["split","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Node::<A>::update_size":["update_size","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Size::is_size":["is_size","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Size::pop":["pop","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Size::push":["push","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Size::size":["size","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Size::table_from_size":["table_from_size","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"nodes::rrb::Size::update":["update","Real(LocalPath(\"src/nodes/rrb.rs\"))",""],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::cmp_keys":["cmp_keys","Real(LocalPath(\"src/ord/map.rs\"))","nodes::btree::BTreeValue"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::cmp_values":["cmp_values","Real(LocalPath(\"src/ord/map.rs\"))","nodes::btree::BTreeValue"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::ptr_eq":["ptr_eq","Real(LocalPath(\"src/ord/map.rs\"))","nodes::btree::BTreeValue"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::search_key":["search_key","Real(LocalPath(\"src/ord/map.rs\"))","nodes::btree::BTreeValue"],"ord::map::<impl nodes::btree::BTreeValue for (K, V)>::search_value":["search_value","Real(LocalPath(\"src/ord/map.rs\"))","nodes::btree::BTreeValue"],"ord::map::Entry::<'a, K, V>::and_modify":["and_modify","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::Entry::<'a, K, V>::key":["key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::Entry::<'a, K, V>::or_default":["or_default","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::Entry::<'a, K, V>::or_insert":["or_insert","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::Entry::<'a, K, V>::or_insert_with":["or_insert_with","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OccupiedEntry::<'a, K, V>::get":["get","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OccupiedEntry::<'a, K, V>::get_mut":["get_mut","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OccupiedEntry::<'a, K, V>::insert":["insert","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OccupiedEntry::<'a, K, V>::into_mut":["into_mut","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OccupiedEntry::<'a, K, V>::key":["key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OccupiedEntry::<'a, K, V>::remove":["remove","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OccupiedEntry::<'a, K, V>::remove_entry":["remove_entry","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::alter":["alter","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::clear":["clear","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::contains_key":["contains_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::diff":["diff","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::difference":["difference","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::difference_with":["difference_with","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::difference_with_key":["difference_with_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::entry":["entry","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::extract":["extract","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::extract_with_key":["extract_with_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::get":["get","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::get_key_value":["get_key_value","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::get_max":["get_max","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::get_min":["get_min","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::get_mut":["get_mut","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::get_next":["get_next","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::get_next_mut":["get_next_mut","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::get_prev":["get_prev","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::get_prev_mut":["get_prev_mut","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::insert":["insert","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::intersection":["intersection","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::intersection_with":["intersection_with","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::intersection_with_key":["intersection_with_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::is_empty":["is_empty","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::is_proper_submap":["is_proper_submap","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::is_proper_submap_by":["is_proper_submap_by","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::is_submap":["is_submap","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::is_submap_by":["is_submap_by","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::iter":["iter","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::keys":["keys","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::len":["len","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::new":["new","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::ptr_eq":["ptr_eq","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::range":["range","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::relative_complement":["relative_complement","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::remove":["remove","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::remove_with_key":["remove_with_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::skip":["skip","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::split":["split","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::split_lookup":["split_lookup","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::symmetric_difference_with":["symmetric_difference_with","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::symmetric_difference_with_key":["symmetric_difference_with_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::take":["take","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::union":["union","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::union_with":["union_with","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::union_with_key":["union_with_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::unions":["unions","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::unions_with":["unions_with","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::unions_with_key":["unions_with_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::unit":["unit","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::update":["update","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::update_lookup_with_key":["update_lookup_with_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::update_with":["update_with","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::update_with_key":["update_with_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::values":["values","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::without":["without","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::without_max":["without_max","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::without_max_with_key":["without_max_with_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::without_min":["without_min","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMap::<K, V>::without_min_with_key":["without_min_with_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::OrdMapPool::<K, V>::fill":["fill","Real(LocalPath(\"src/util.rs\"))",""],"ord::map::OrdMapPool::<K, V>::new":["new","Real(LocalPath(\"src/util.rs\"))",""],"ord::map::OrdMapPool::<K, V>::pool_size":["pool_size","Real(LocalPath(\"src/util.rs\"))",""],"ord::map::VacantEntry::<'a, K, V>::insert":["insert","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::VacantEntry::<'a, K, V>::into_key":["into_key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::map::VacantEntry::<'a, K, V>::key":["key","Real(LocalPath(\"src/ord/map.rs\"))",""],"ord::set::OrdSet::<A>::clear":["clear","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::contains":["contains","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::diff":["diff","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::difference":["difference","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::get_max":["get_max","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::get_min":["get_min","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::get_next":["get_next","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::get_prev":["get_prev","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::insert":["insert","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::intersection":["intersection","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::is_empty":["is_empty","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::is_proper_subset":["is_proper_subset","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::is_subset":["is_subset","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::iter":["iter","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::len":["len","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::new":["new","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::ptr_eq":["ptr_eq","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::range":["range","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::relative_complement":["relative_complement","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::remove":["remove","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::remove_max":["remove_max","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::remove_min":["remove_min","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::skip":["skip","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::split":["split","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::split_member":["split_member","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::take":["take","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::union":["union","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::unions":["unions","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::unit":["unit","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::update":["update","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::without":["without","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::without_max":["without_max","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSet::<A>::without_min":["without_min","Real(LocalPath(\"src/ord/set.rs\"))",""],"ord::set::OrdSetPool::<A>::fill":["fill","Real(LocalPath(\"src/util.rs\"))",""],"ord::set::OrdSetPool::<A>::new":["new","Real(LocalPath(\"src/util.rs\"))",""],"ord::set::OrdSetPool::<A>::pool_size":["pool_size","Real(LocalPath(\"src/util.rs\"))",""],"sort::do_quicksort":["do_quicksort","Real(LocalPath(\"src/sort.rs\"))",""],"sort::gen_range":["gen_range","Real(LocalPath(\"src/sort.rs\"))",""],"sort::quicksort":["quicksort","Real(LocalPath(\"src/sort.rs\"))",""],"sync::lock::Lock::<A>::lock":["lock","Real(LocalPath(\"src/sync.rs\"))",""],"sync::lock::Lock::<A>::new":["new","Real(LocalPath(\"src/sync.rs\"))",""],"util::clone_ref":["clone_ref","Real(LocalPath(\"src/util.rs\"))",""],"util::linear_search_by":["linear_search_by","Real(LocalPath(\"src/util.rs\"))",""],"util::swap_indices":["swap_indices","Real(LocalPath(\"src/util.rs\"))",""],"util::to_range":["to_range","Real(LocalPath(\"src/util.rs\"))",""],"vector::Chunks::<'a, A>::new":["new","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::ChunksMut::<'a, A>::new":["new","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::ConsumingIter::<A>::new":["new","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Iter::<'a, A>::from_focus":["from_focus","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Iter::<'a, A>::new":["new","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::IterMut::<'a, A>::from_focus":["from_focus","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::IterMut::<'a, A>::new":["new","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::RRB::<A>::new":["new","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::RRB::<A>::pop_back":["pop_back","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::RRB::<A>::pop_front":["pop_front","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::RRB::<A>::pop_middle":["pop_middle","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::RRB::<A>::prune":["prune","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::RRB::<A>::push_back":["push_back","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::RRB::<A>::push_front":["push_front","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::RRB::<A>::push_middle":["push_middle","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::append":["append","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::back":["back","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::back_mut":["back_mut","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::binary_search":["binary_search","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::binary_search_by":["binary_search_by","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::binary_search_by_key":["binary_search_by_key","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::clear":["clear","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::contains":["contains","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::focus":["focus","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::focus_mut":["focus_mut","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::front":["front","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::front_mut":["front_mut","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::get":["get","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::get_mut":["get_mut","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::head":["head","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::index_of":["index_of","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::insert":["insert","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::insert_ord":["insert_ord","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::is_empty":["is_empty","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::is_inline":["is_inline","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::iter":["iter","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::iter_mut":["iter_mut","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::last":["last","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::leaves":["leaves","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::leaves_mut":["leaves_mut","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::len":["len","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::needs_promotion":["needs_promotion","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::new":["new","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::pool":["pool","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::pop_back":["pop_back","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::pop_front":["pop_front","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::promote_back":["promote_back","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::promote_front":["promote_front","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::promote_inline":["promote_inline","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::ptr_eq":["ptr_eq","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::ptr_eq::cmp_chunk":["cmp_chunk","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::push_back":["push_back","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::push_front":["push_front","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::remove":["remove","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::retain":["retain","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::set":["set","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::skip":["skip","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::slice":["slice","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::sort":["sort","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::sort_by":["sort_by","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::split_at":["split_at","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::split_off":["split_off","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::swap":["swap","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::take":["take","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::truncate":["truncate","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::unit":["unit","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::Vector::<A>::update":["update","Real(LocalPath(\"src/vector/mod.rs\"))",""],"vector::focus::Focus::<'a, A>::chunk_at":["chunk_at","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::Focus::<'a, A>::get":["get","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::Focus::<'a, A>::index":["index","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::Focus::<'a, A>::is_empty":["is_empty","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::Focus::<'a, A>::len":["len","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::Focus::<'a, A>::narrow":["narrow","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::Focus::<'a, A>::new":["new","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::Focus::<'a, A>::split_at":["split_at","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::chunk_at":["chunk_at","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::get":["get","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::get_mut":["get_mut","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::index":["index","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::index_mut":["index_mut","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::is_empty":["is_empty","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::len":["len","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::narrow":["narrow","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::new":["new","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::pair":["pair","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::set":["set","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::split_at":["split_at","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::swap":["swap","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::triplet":["triplet","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::FocusMut::<'a, A>::unmut":["unmut","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocus::<A>::get":["get","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocus::<A>::get_chunk":["get_chunk","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocus::<A>::get_focus":["get_focus","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocus::<A>::len":["len","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocus::<A>::logical_range":["logical_range","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocus::<A>::narrow":["narrow","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocus::<A>::new":["new","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocus::<A>::physical_index":["physical_index","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocus::<A>::set_focus":["set_focus","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocus::<A>::split_at":["split_at","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocusMut::<'a, A>::get":["get","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocusMut::<'a, A>::get_chunk":["get_chunk","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocusMut::<'a, A>::get_focus":["get_focus","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocusMut::<'a, A>::len":["len","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocusMut::<'a, A>::logical_range":["logical_range","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocusMut::<'a, A>::narrow":["narrow","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocusMut::<'a, A>::new":["new","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocusMut::<'a, A>::physical_index":["physical_index","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocusMut::<'a, A>::set_focus":["set_focus","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::TreeFocusMut::<'a, A>::split_at":["split_at","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::focus::contains":["contains","Real(LocalPath(\"src/vector/focus.rs\"))",""],"vector::pool::RRBPool::<A>::fill":["fill","Real(LocalPath(\"src/vector/pool.rs\"))",""],"vector::pool::RRBPool::<A>::leaf_pool_size":["leaf_pool_size","Real(LocalPath(\"src/vector/pool.rs\"))",""],"vector::pool::RRBPool::<A>::new":["new","Real(LocalPath(\"src/vector/pool.rs\"))",""],"vector::pool::RRBPool::<A>::node_pool_size":["node_pool_size","Real(LocalPath(\"src/vector/pool.rs\"))",""],"vector::pool::RRBPool::<A>::size_table_pool_size":["size_table_pool_size","Real(LocalPath(\"src/vector/pool.rs\"))",""],"vector::pool::RRBPool::<A>::with_sizes":["with_sizes","Real(LocalPath(\"src/vector/pool.rs\"))",""],"vector::replace_pool_def":["replace_pool_def","Real(LocalPath(\"src/vector/mod.rs\"))",""]},"trait_to_struct":{"fakepool::PoolClone":["nodes::btree::Node","nodes::chunk::Chunk","nodes::hamt::Node"],"fakepool::PoolDefault":["nodes::btree::Node","nodes::chunk::Chunk","nodes::hamt::Node"],"nodes::btree::BTreeValue":["ord::set::Value"],"nodes::hamt::HashValue":["hash::set::Value"],"std::clone::Clone":["fakepool::Arc","fakepool::Pool","fakepool::Rc","hash::map::HashMap","hash::map::HashMapPool","hash::set::HashSet","hash::set::HashSetPool","hash::set::Value","nodes::btree::Node","nodes::hamt::CollisionNode","nodes::hamt::Entry","nodes::hamt::Node","nodes::rrb::Entry","nodes::rrb::Node","nodes::rrb::Size","ord::map::OrdMap","ord::map::OrdMapPool","ord::set::OrdSet","ord::set::OrdSetPool","ord::set::Value","sync::lock::Lock","util::Side","vector::RRB","vector::Vector","vector::focus::Focus","vector::focus::TreeFocus","vector::pool::RRBPool"],"std::cmp::Eq":["fakepool::Arc","fakepool::Rc","hash::map::HashMap","hash::set::HashSet","hash::set::Value","nodes::btree::DiffItem","ord::map::DiffItem","ord::map::OrdMap","ord::set::OrdSet","ord::set::Value","util::Side","vector::Vector"],"std::cmp::Ord":["hash::map::HashMap","hash::set::HashSet","hash::set::Value","ord::map::OrdMap","ord::set::OrdSet","ord::set::Value","vector::Vector"],"std::cmp::PartialEq":["fakepool::Arc","fakepool::Rc","hash::map::HashMap","hash::set::HashSet","hash::set::Value","nodes::btree::DiffItem","ord::map::DiffItem","ord::map::OrdMap","ord::set::OrdSet","ord::set::Value","util::Side","vector::Vector"],"std::cmp::PartialOrd":["hash::map::HashMap","hash::set::HashSet","hash::set::Value","ord::map::OrdMap","ord::set::OrdSet","ord::set::Value","vector::Vector"],"std::convert::AsRef":["hash::map::HashMap","ord::map::OrdMap"],"std::convert::From":["hash::map::HashMap","hash::set::HashSet","nodes::hamt::Entry","ord::map::OrdMap","ord::set::OrdSet","vector::Vector"],"std::convert::Into":["vector::focus::FocusMut"],"std::default::Default":["fakepool::Arc","fakepool::Rc","hash::map::HashMap","hash::map::HashMapPool","hash::set::HashSet","hash::set::HashSetPool","nodes::btree::Node","nodes::hamt::Node","nodes::rrb::Node","ord::map::OrdMap","ord::map::OrdMapPool","ord::set::OrdSet","ord::set::OrdSetPool","vector::Vector","vector::pool::RRBPool"],"std::fmt::Debug":["fakepool::Arc","fakepool::Rc","hash::map::HashMap","hash::set::HashSet","hash::set::Value","nodes::btree::DiffItem","nodes::hamt::Node","nodes::rrb::Size","ord::map::DiffItem","ord::map::OrdMap","ord::set::OrdSet","ord::set::Value","util::Side","vector::Vector"],"std::hash::Hash":["hash::map::HashMap","hash::set::HashSet","ord::map::OrdMap","ord::set::OrdSet","vector::Vector"],"std::iter::DoubleEndedIterator":["nodes::btree::ConsumingIter","nodes::btree::Iter","ord::map::Iter","ord::map::Keys","ord::map::Values","ord::set::Iter","ord::set::RangedIter","vector::Chunks","vector::ChunksMut","vector::ConsumingIter","vector::Iter","vector::IterMut"],"std::iter::ExactSizeIterator":["hash::map::ConsumingIter","hash::map::Iter","hash::map::IterMut","hash::map::Keys","hash::map::Values","hash::set::ConsumingIter","hash::set::Iter","nodes::btree::ConsumingIter","nodes::hamt::Drain","nodes::hamt::Iter","nodes::hamt::IterMut","ord::map::Iter","ord::map::Keys","ord::map::Values","ord::set::Iter","vector::ConsumingIter","vector::Iter","vector::IterMut"],"std::iter::Extend":["hash::map::HashMap","hash::set::HashSet","ord::map::OrdMap","ord::set::OrdSet","vector::Vector"],"std::iter::FromIterator":["hash::map::HashMap","hash::set::HashSet","ord::map::OrdMap","ord::set::OrdSet","vector::Vector"],"std::iter::FusedIterator":["hash::map::ConsumingIter","hash::map::Iter","hash::map::IterMut","hash::map::Keys","hash::map::Values","hash::set::ConsumingIter","hash::set::Iter","nodes::hamt::Drain","nodes::hamt::Iter","nodes::hamt::IterMut","vector::Chunks","vector::ChunksMut","vector::ConsumingIter","vector::Iter","vector::IterMut"],"std::iter::IntoIterator":["hash::map::HashMap","hash::set::HashSet","ord::map::OrdMap","ord::set::OrdSet","vector::Vector","vector::focus::Focus","vector::focus::FocusMut"],"std::iter::Iterator":["hash::map::ConsumingIter","hash::map::Iter","hash::map::IterMut","hash::map::Keys","hash::map::Values","hash::set::ConsumingIter","hash::set::Iter","nodes::btree::ConsumingIter","nodes::btree::DiffIter","nodes::btree::Iter","nodes::hamt::Drain","nodes::hamt::Iter","nodes::hamt::IterMut","ord::map::DiffIter","ord::map::Iter","ord::map::Keys","ord::map::Values","ord::set::ConsumingIter","ord::set::DiffIter","ord::set::Iter","ord::set::RangedIter","vector::Chunks","vector::ChunksMut","vector::ConsumingIter","vector::Iter","vector::IterMut"],"std::iter::Sum":["hash::map::HashMap","hash::set::HashSet","ord::map::OrdMap","ord::set::OrdSet","vector::Vector"],"std::marker::Copy":["hash::set::Value","ord::set::Value","util::Side"],"std::marker::Send":["vector::focus::TreeFocus"],"std::marker::StructuralEq":["hash::set::Value","nodes::btree::DiffItem","ord::map::DiffItem","ord::set::Value","util::Side"],"std::marker::StructuralPartialEq":["hash::set::Value","nodes::btree::DiffItem","ord::map::DiffItem","ord::set::Value","util::Side"],"std::marker::Sync":["vector::focus::TreeFocus"],"std::ops::Add":["hash::map::HashMap","hash::set::HashSet","ord::map::OrdMap","ord::set::OrdSet","vector::Vector"],"std::ops::Deref":["fakepool::Arc","fakepool::Rc","hash::set::Value","ord::set::Value"],"std::ops::Index":["hash::map::HashMap","ord::map::OrdMap","vector::Vector"],"std::ops::IndexMut":["hash::map::HashMap","ord::map::OrdMap","vector::Vector"],"std::ops::Mul":["hash::set::HashSet","ord::set::OrdSet"]},"type_to_def_path":{"fakepool::Arc<A>":"fakepool::Arc","fakepool::Pool<A>":"fakepool::Pool","fakepool::Rc<A>":"fakepool::Rc","hash::map::ConsumingIter<A>":"hash::map::ConsumingIter","hash::map::Entry<'a, K, V, S>":"hash::map::Entry","hash::map::HashMap<K, V, S>":"hash::map::HashMap","hash::map::HashMapPool<K, V>":"hash::map::HashMapPool","hash::map::Iter<'a, K, V>":"hash::map::Iter","hash::map::IterMut<'a, K, V>":"hash::map::IterMut","hash::map::Keys<'a, K, V>":"hash::map::Keys","hash::map::OccupiedEntry<'a, K, V, S>":"hash::map::OccupiedEntry","hash::map::VacantEntry<'a, K, V, S>":"hash::map::VacantEntry","hash::map::Values<'a, K, V>":"hash::map::Values","hash::set::ConsumingIter<A>":"hash::set::ConsumingIter","hash::set::HashSet<A, S>":"hash::set::HashSet","hash::set::HashSetPool<A>":"hash::set::HashSetPool","hash::set::Iter<'a, A>":"hash::set::Iter","hash::set::Value<A>":"hash::set::Value","nodes::btree::ConsumingIter<A>":"nodes::btree::ConsumingIter","nodes::btree::ConsumingIterItem<A>":"nodes::btree::ConsumingIterItem","nodes::btree::DiffItem<'a, A>":"nodes::btree::DiffItem","nodes::btree::DiffIter<'a, A>":"nodes::btree::DiffIter","nodes::btree::Insert<A>":"nodes::btree::Insert","nodes::btree::InsertAction<A>":"nodes::btree::InsertAction","nodes::btree::Iter<'a, A>":"nodes::btree::Iter","nodes::btree::IterItem<'a, A>":"nodes::btree::IterItem","nodes::btree::Node<A>":"nodes::btree::Node","nodes::btree::Remove<A>":"nodes::btree::Remove","nodes::btree::RemoveAction":"nodes::btree::RemoveAction","nodes::hamt::CollisionNode<A>":"nodes::hamt::CollisionNode","nodes::hamt::Drain<A>":"nodes::hamt::Drain","nodes::hamt::Entry<A>":"nodes::hamt::Entry","nodes::hamt::Iter<'a, A>":"nodes::hamt::Iter","nodes::hamt::IterMut<'a, A>":"nodes::hamt::IterMut","nodes::hamt::Node<A>":"nodes::hamt::Node","nodes::rrb::Entry<A>":"nodes::rrb::Entry","nodes::rrb::Node<A>":"nodes::rrb::Node","nodes::rrb::PopResult<A>":"nodes::rrb::PopResult","nodes::rrb::PushResult<A>":"nodes::rrb::PushResult","nodes::rrb::Size":"nodes::rrb::Size","nodes::rrb::SplitResult":"nodes::rrb::SplitResult","ord::map::DiffItem<'a, K, V>":"ord::map::DiffItem","ord::map::DiffIter<'a, K, V>":"ord::map::DiffIter","ord::map::Entry<'a, K, V>":"ord::map::Entry","ord::map::Iter<'a, K, V>":"ord::map::Iter","ord::map::Keys<'a, K, V>":"ord::map::Keys","ord::map::OccupiedEntry<'a, K, V>":"ord::map::OccupiedEntry","ord::map::OrdMap<K, V>":"ord::map::OrdMap","ord::map::OrdMapPool<K, V>":"ord::map::OrdMapPool","ord::map::VacantEntry<'a, K, V>":"ord::map::VacantEntry","ord::map::Values<'a, K, V>":"ord::map::Values","ord::set::ConsumingIter<A>":"ord::set::ConsumingIter","ord::set::DiffIter<'a, A>":"ord::set::DiffIter","ord::set::Iter<'a, A>":"ord::set::Iter","ord::set::OrdSet<A>":"ord::set::OrdSet","ord::set::OrdSetPool<A>":"ord::set::OrdSetPool","ord::set::RangedIter<'a, A>":"ord::set::RangedIter","ord::set::Value<A>":"ord::set::Value","sync::lock::Lock<A>":"sync::lock::Lock","util::Side":"util::Side","vector::Chunks<'a, A>":"vector::Chunks","vector::ChunksMut<'a, A>":"vector::ChunksMut","vector::ConsumingIter<A>":"vector::ConsumingIter","vector::Iter<'a, A>":"vector::Iter","vector::IterMut<'a, A>":"vector::IterMut","vector::RRB<A>":"vector::RRB","vector::Vector<A>":"vector::Vector","vector::VectorInner<A>":"vector::VectorInner","vector::focus::Focus<'a, A>":"vector::focus::Focus","vector::focus::FocusMut<'a, A>":"vector::focus::FocusMut","vector::focus::TreeFocus<A>":"vector::focus::TreeFocus","vector::focus::TreeFocusMut<'a, A>":"vector::focus::TreeFocusMut","vector::pool::RRBPool<A>":"vector::pool::RRBPool"}}